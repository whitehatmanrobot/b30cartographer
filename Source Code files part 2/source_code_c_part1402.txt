e[7],BIG_BUF,INIFILENAME);
	LUIOut(L2,"Step5: Resolve ambigous name");
	LUIOut(L3,"Name: %s",szResName[7]);

	MAPIAllocateBuffer(CbNewADRLIST(cEntries), (LPVOID *) &lpAdrList);
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrList->aEntries[0].rgPropVals));
	
	lpAdrList->cEntries = cEntries;
	lpAdrList->aEntries[0].cValues = 1;
	lpAdrList->aEntries[0].rgPropVals->ulPropTag = PR_DISPLAY_NAME;
	lpAdrList->aEntries[0].rgPropVals->Value.LPSZ = szResName[7];

	if (hr = lpAdrBook->ResolveName((ULONG)GetActiveWindow(),MAPI_DIALOG, NULL, lpAdrList)
		&&( hr != MAPI_E_AMBIGUOUS_RECIP)) {
		LUIOut(LFAIL4, "ResolveName failed for name that was not specific enough");
		retval = FALSE;
		goto out;
	}
	else LUIOut(LPASS4,"ResolveName correctly returned MAPI_E_AMBUGUOUS_RECIP." );

	MAPIFreeBuffer(lpAdrList->aEntries[0].rgPropVals);
	MAPIFreeBuffer(lpAdrList);
	lpAdrList = NULL;

	//Resolves name using the oneoff provider
	cEntries = 1;
	GetPrivateProfileString("ResolveName","OneOffAddress","",szResName[8],BIG_BUF,INIFILENAME);
	LUIOut(L2,"Resolve OneOff Name");
	LUIOut(L3,"OneOff Address: %s",szResName[8]);

	MAPIAllocateBuffer(CbNewADRLIST(cEntries), (LPVOID *) &lpAdrList);
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrList->aEntries[0].rgPropVals));
	
	lpAdrList->cEntries = cEntries;
	lpAdrList->aEntries[0].cValues = 1;
	lpAdrList->aEntries[0].rgPropVals->ulPropTag = PR_DISPLAY_NAME;
	lpAdrList->aEntries[0].rgPropVals->Value.LPSZ = szResName[8];

	if(HR_FAILED(lpAdrBook->ResolveName(0,0, NULL, lpAdrList)))
	{
		LUIOut( LFAIL4, "ResolveName failed for OneOffAddress" );
		retval = FALSE;
		goto out;
	}
	LUIOut( LPASS4, "ResolveName passed for OneOffAddress" );

	//Validate the AdrList
	LUIOut(L4,"Validate the returned PropList");
	if (ValidateAdrList(lpAdrList, cEntries))
		LUIOut(LPASS4,"Validation passed");
	else {
		LUIOut(LFAIL4,"Validation unsuccessful");
		retval = FALSE;
	}

	MAPIFreeBuffer(lpAdrList->aEntries[0].rgPropVals);

	MAPIFreeBuffer(lpAdrList );
	lpAdrList = NULL;
	
	cEntries = 0;
out:
		if (cEntries > 0)
			for (i=0;i<(int)cEntries; i++) {
				MAPIFreeBuffer( lpAdrList->aEntries[i].rgPropVals );
		}
		
		if (lpAdrList) {
			MAPIFreeBuffer( lpAdrList );
			lpAdrList = NULL;
		}

		if (lpAdrBook)
			  lpAdrBook->Release();

		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
		return retval;
}


BOOL PABSetProps()
{

	HRESULT hr      = hrSuccess;
    int		retval=TRUE;

#ifdef PAB

	int i=0;
	int bFound = FALSE;

    LPMAPISESSION lpMAPISession   = NULL;
    LPADRBOOK	  lpAdrBook       = NULL;
	SPropValue  PropValue[3];
	LPSPropValue lpSPropValue = NULL;
	ULONG		  cbEidPAB = 0;
	LPENTRYID	  lpEidPAB   = NULL;
	LPABCONT	  lpPABCont= NULL;
	LPMAILUSER	lpUser=NULL;
	LPMAPITABLE lpContentsTable = NULL;
    LPSRowSet   lpRowSet    = NULL;
	ULONG     cbEid=0, cValues;
	LPENTRYID lpEid=NULL;
	ULONG   ulObjType=NULL;	
	char szLocation[SML_BUF],szComment[SML_BUF];

	SizedSPropTagArray(3,SPTTagArray) = {3, {PR_DISPLAY_NAME,
	PR_OFFICE_LOCATION, PR_COMMENT} };


	LUIOut(L1," ");
	LUIOut(L1,"Running SetProps");
	LUIOut(L2,"-> Sets properties on a MailUser in the PAB");
	LUIOut(L1," ");

	if (!(MapiInitLogon(OUT &lpMAPISession))) {
			LUIOut(L2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}
	
	// Get the IAddrBook
	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT &lpAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(L2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}
	
	if(!OpenPABID(IN lpAdrBook, OUT &cbEidPAB,
							OUT &lpEidPAB,OUT &lpPABCont, OUT &ulObjType))
	{
				LUIOut(L2,"OpenPABID Failed");
				LUIOut(L3,"Could not Open PAB");
		 		retval=FALSE;
				goto out;
	}
	assert(lpPABCont != NULL);
	assert(lpContentsTable == NULL);
	hr = lpPABCont->GetContentsTable( IN  0,          //Flags
                                OUT &lpContentsTable);

    if (HR_FAILED(hr)) {
		LUIOut(L2,"GetContentsTable: Failed");
		retval=FALSE;
		goto out;
	}
	assert(lpContentsTable != NULL);
	assert(lpRowSet == NULL);	
	while((bFound == FALSE) &&(!HR_FAILED(hr = lpContentsTable->QueryRows(IN  1,
								IN  0,
							    OUT &lpRowSet)))) {
		
	if (lpRowSet->cRows) {
		i=0;
		assert(lpRowSet != NULL);
		while(lpRowSet->aRow[0].lpProps[i].ulPropTag != PR_OBJECT_TYPE)
			if (++i >= (int) lpRowSet->aRow[0].cValues)
			{
				LUIOut( L2, "PR_OBJECT_TYPE not found in the row!" );
				retval = FALSE;
				goto out;
			}

		if(lpRowSet->aRow[0].lpProps[i].Value.ul == MAPI_MAILUSER)
			bFound = TRUE;
		else
		{
			FreeProws(lpRowSet);
			lpRowSet = NULL;
		}
	}
	else  {
		LUIOut(LFAIL2,"No Mail User Entry found in the PAB");
		retval = FALSE;
		if (lpRowSet) {
				FreeProws(lpRowSet);
				lpRowSet = NULL;
			}
			assert( lpRowSet == NULL);
			goto out;
	}
}

// check for QueryRows() errors
if (HR_FAILED(hr)){
			LUIOut(L2,"QueryRows Failed");
			retval = FALSE;
			goto out;
}
if (bFound) {
	i=0;
	assert(lpRowSet != NULL);
	while(lpRowSet->aRow[0].lpProps[i].ulPropTag != PR_ENTRYID)
		if (++i >= (int) lpRowSet->aRow[0].cValues)
		{
			LUIOut( L2, "PR_ENTRYID not found in the row!" );
			retval = FALSE;
			goto out;
		}

	cbEid = lpRowSet->aRow[0].lpProps[i].Value.bin.cb;
	lpEid = (LPENTRYID)lpRowSet->aRow[0].lpProps[i].Value.bin.lpb;
	
	assert(lpAdrBook != NULL);
	assert(lpUser == NULL);
	hr = lpAdrBook->OpenEntry(cbEid, lpEid, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpUser);
	if (HR_FAILED(hr)) {
		LUIOut(LFAIL2, "OpenEntry with modify flag on first MailUser failed");
		retval = FALSE;
		goto out;
	}
	else LUIOut(LPASS2,"OpenEntry with modify flag on first MailUser passed");
	GetPrivateProfileString("SetProps","Location","",szLocation,SML_BUF,szIniFile);
	GetPrivateProfileString("SetProps","Comment","",szComment,SML_BUF,szIniFile);
	cValues = 2;
	PropValue[0].ulPropTag  = PR_OFFICE_LOCATION;
    PropValue[1].ulPropTag  = PR_COMMENT;
   	PropValue[0].Value.LPSZ = (LPTSTR)szLocation;
	PropValue[1].Value.LPSZ = (LPTSTR)szComment;

	assert(lpUser != NULL);
	hr = lpUser->SetProps(IN  cValues,
                          IN  PropValue,
                          IN  NULL);
		
    if (HR_FAILED(hr)) {
			LUIOut(LFAIL2,"SetProps failed for the MailUser");
		 	retval=FALSE;			
			goto out;
	}
	assert(lpUser != NULL);
    hr = lpUser->SaveChanges(IN  KEEP_OPEN_READWRITE);
	if (HR_FAILED(hr)) {
			LUIOut(LFAIL2,"SaveChanges failed for SetProps");
			retval=FALSE;
            goto out;
	}
	else LUIOut(LPASS2,"Savechanges passed for the properties on the MailUser in PAB");
	assert(lpUser != NULL);
	assert(lpSPropValue == NULL);
	hr = lpUser->GetProps(
                    IN (LPSPropTagArray) &SPTTagArray,
                    IN  0,
                    OUT &cValues,
                    OUT &lpSPropValue);

    if ((HR_FAILED(hr))||(PropError(lpSPropValue->ulPropTag, cValues))) {

		LUIOut( L2,"GetProps on Mail User failed" );
		retval = FALSE;
		goto out;
	}
	else {
			LUIOut(L2,"Verification of Properties set");
			LUIOut(L3,"Entry Name: %s",(lpSPropValue[0]).Value.LPSZ);
			LUIOut(L3,"Location: %s",(lpSPropValue[1]).Value.LPSZ);
			if (lstrcmpi((lpSPropValue[1]).Value.LPSZ, (LPSTR)szLocation))
				retval = FALSE;
			LUIOut(L3,"Comment: %s",(lpSPropValue[2]).Value.LPSZ);
			if (lstrcmpi((lpSPropValue[2]).Value.LPSZ, (LPSTR)szComment))
				retval = FALSE;
	}	
	assert(lpUser != NULL);
	hr = lpUser->SaveChanges(IN  KEEP_OPEN_READWRITE);
	if (HR_FAILED(hr)) {
			LUIOut(LFAIL2,"SaveChanges, without changes, failed on Mail User in PAB");
			retval=FALSE;
            goto out;
	}
	else LUIOut(LPASS2,"SaveChanges, without changes, passed on Mail User in PAB");
}
else {
	LUIOut(LPASS2,"No Mail User Entry found in the PAB to set the properties");
	retval = FALSE;
}

out:		
	if (lpSPropValue)
		MAPIFreeBuffer(lpSPropValue);
	//if (lpEid)
	//	MAPIFreeBuffer(lpEid);
	if (lpContentsTable)
		lpContentsTable->Release();
	if (lpPABCont)
				lpPABCont->Release();
	if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
	if(lpRowSet)
			FreeProws(lpRowSet);
	if(lpUser)
		lpUser->Release();
	if (lpAdrBook)
		  lpAdrBook->Release();
	if (lpMAPISession)
		  lpMAPISession->Release();
	MAPIUninitialize();
#endif
	return retval;
}

BOOL PABQueryInterface()
{

	HRESULT hr      = hrSuccess;
    int		retval=TRUE;

#ifdef PAB

	int i=0;

    LPMAPISESSION lpMAPISession   = NULL;
    LPADRBOOK	  lpAdrBook       = NULL;
	ULONG		  cbEidPAB = 0;
	LPENTRYID	  lpEidPAB   = NULL;
	LPABCONT	  lpABCont= NULL, lpABCont2= NULL;
	LPABCONT	  lpPABCont= NULL,lpPABCont2= NULL;
	LPMAILUSER	lpUser=NULL, lpUser2=NULL;
	LPMAPITABLE lpContentsTable = NULL;
    LPSRowSet   lpRowSet    = NULL;
	ULONG     cbEid=0;
	LPENTRYID lpEid=NULL;
	ULONG   ulObjType=NULL;	
	
	LUIOut(L1," ");
	LUIOut(L1,"Running QueryInterface");
	LUIOut(L2,"-> Calls QueryInterface on all objects in the PAB");
	LUIOut(L1," ");

	if (!(MapiInitLogon(OUT &lpMAPISession))) {
			LUIOut(LFAIL2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}
	
	// Get the IAddrBook
	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT &lpAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(L2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}

	assert(lpAdrBook != NULL);
	hr = lpAdrBook->OpenEntry(0, NULL, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (!(retval = LogIt(hr,2, "OpenEntry on AddressBook")))
		goto out;
	
	if (ulObjType != MAPI_ABCONT) {
		LUIOut(LFAIL2, "Object type is not MAPI_ABCONT");
		retval = FALSE;
		goto out;
	}
	LUIOut(LPASS2, "Object type is MAPI_ABCONT");
	
	hr = (lpABCont->QueryInterface((REFIID)(IID_IUnknown), (VOID **) &lpABCont2));
	if (!(retval = LogIt(hr,2, "QueryInterface on the Root Container")))
		goto out;

	if(lpABCont2)
		(LPUNKNOWN)(lpABCont2)->Release();
	else {
		LUIOut(LFAIL2, "QueryInterface failed on the Root Container");
		retval = FALSE;
	}
	lpABCont2 = NULL;

	if(!OpenPABID(IN lpAdrBook, OUT &cbEidPAB,
							OUT &lpEidPAB,OUT &lpPABCont, OUT &ulObjType))
	{
				LUIOut(L2,"OpenPABID Failed");
				LUIOut(L3,"Could not Open PAB");
		 		retval=FALSE;
				goto out;
	}
	hr = (lpPABCont->QueryInterface((REFIID)(IID_IUnknown), (VOID **) &lpPABCont2));
	if (!(retval = LogIt(hr,2, "QueryInterface on the PAB Container")))
		goto out;

	if(lpPABCont2)
		(LPUNKNOWN)(lpPABCont2)->Release();
	else {
		LUIOut(LFAIL2, "QueryInterface failed on the Root Container");
		retval = FALSE;
	}
	lpPABCont2 = NULL;
	
	// Now open the PAB and get a user and do QueryInterface on the User
	hr = lpPABCont->GetContentsTable( IN  0,          //Flags
                                OUT &lpContentsTable);
	
    if (HR_FAILED(hr)) {
		LUIOut(LFAIL2,"GetContentsTable: Failed");
		retval=FALSE;
		goto out;
	}
	assert(lpContentsTable != NULL);
	assert(lpRowSet == NULL);	
	hr = lpContentsTable->QueryRows(1, 0, OUT &lpRowSet);
	if (!(retval = LogIt(hr,2, "QueryRows on the PAB Container")))
		goto out;

	if (lpRowSet->cRows) {
		i=0;
		while(lpRowSet->aRow[0].lpProps[i].ulPropTag != PR_ENTRYID )
			if (++i >= (int) lpRowSet->aRow[0].cValues)
			{
				LUIOut(LFAIL2,"PR_ENTRYID not found in the row!" );
				retval = FALSE;
				goto out;
			}
		cbEid = lpRowSet->aRow[0].lpProps[i].Value.bin.cb;
		lpEid = (LPENTRYID)lpRowSet->aRow[0].lpProps[i].Value.bin.lpb;

		hr = lpPABCont->OpenEntry(cbEid, lpEid, NULL, 0, &ulObjType,(LPUNKNOWN *)&lpUser);
		if (!(retval = LogIt(hr,2, "OpenEntry on EntryID for PAB Entry")))
			goto out;

		FreeProws(lpRowSet);
		lpRowSet = NULL;

		hr = lpUser->QueryInterface(IID_IUnknown, (VOID **) &lpUser2);
		if (!(retval = LogIt(hr,2, "QueryInterface on an Entry in PAB")))
			goto out;

		if(lpUser2)
			(LPUNKNOWN)(lpUser2)->Release();
		else {
			LUIOut(LFAIL2, "QueryInterface failed on an Entry in PAB");
			retval = FALSE;
		}
		lpUser2 = NULL;
	}
	else {
		LUIOut(LFAIL2, "No Entries found in the PAB");
		retval = FALSE;
		goto out;
	}

out:		
	if (lpABCont)
		lpABCont->Release();
	if (lpABCont2)
		lpABCont2->Release();
	if (lpPABCont)
		lpPABCont->Release();
	if (lpPABCont2)
		lpPABCont2->Release();
	if (lpEid)
		MAPIFreeBuffer(lpEid);
	if (lpContentsTable)
		lpContentsTable->Release();
	if (lpEidPAB)
			MAPIFreeBuffer(lpEidPAB);
	if(lpRowSet)
			FreeProws(lpRowSet);
	if(lpUser)
		lpUser->Release();
	if(lpUser2)
		lpUser2->Release();
	if (lpAdrBook)
		  lpAdrBook->Release();
	if (lpMAPISession)
		  lpMAPISession->Release();
	MAPIUninitialize();
#endif
	return retval;
}

BOOL PABPrepareRecips()
{

	HRESULT hr      = hrSuccess;
    int		retval=TRUE;

#ifdef PAB

    LPMAPISESSION lpMAPISession   = NULL;
    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpPABCont= NULL;
	ULONG cEntries=0;
	LPADRLIST lpAdrList = NULL;
	char   EntProp[10][BIG_BUF];
	ULONG		  cbEidPAB = 0;
	LPENTRYID	  lpEidPAB   = NULL;
	LPSPropValue lpSPropValueAddress = NULL;
	LPSPropTagArray lpPropTagArray = NULL;
	LPMAILUSER  lpAddress   = NULL;
	SPropValue  PropValue[3]    = {0};
	SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	char szEntryTag[SML_BUF],EntryBuf[MAX_BUF];
	int i = 0,j=0, cPropCount=0;
	ULONG     cbEid=0, cbUserEid=0, cValues;
	LPENTRYID lpEid = NULL, lpUserEid = NULL;

	
	LUIOut(L1," ");
	LUIOut(L1,"Running PrepareRecips");
		LUIOut(L2,"-> Does Prepare Recipients Test on PAB");
		LUIOut(L1," ");

	if (!(MapiInitLogon(OUT &lpMAPISession))) {
		LUIOut(LFAIL2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}

	// Get the IAddrBook
	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT &lpAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(LFAIL2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}

	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
							OUT &lpEidPAB,OUT &lpPABCont, OUT &ulObjType);
						
	if (HR_FAILED(hr)) {
				LUIOut(L2,"OpenPABID Failed");
				LUIOut(L3,"Could not Open PAB");
		 		retval=FALSE;
				goto out;
	}

	LUIOut(L2,"Create a User Entry in PAB");
	hr = lpPABCont->GetProps(  IN  (LPSPropTagArray) &SPTArrayAddress,
                                IN  0,      //Flags
                                OUT &cValues,
                                OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
				LUIOut(L3,"GetProps failed for Default template");
		 		retval=FALSE;			
				goto out;
	}
	cbUserEid = lpSPropValueAddress->Value.bin.cb;
	if ( !MAPIAllocateBuffer(cbUserEid, (LPVOID *)&lpUserEid)) {						
          CopyMemory(lpUserEid, (LPENTRYID) lpSPropValueAddress->Value.bin.lpb, cbUserEid);
	}
	else {
		retval = FALSE;
		LUIOut(LFAIL3," MAPIAllocateBuffer failed");
		goto out;
	}
	
       // The returned value of PR_DEF_CREATE_MAILUSER is an
       // EntryID which one can pass to CreateEntry
       //
	
    hr = lpPABCont->CreateEntry(
                    IN  lpSPropValueAddress->Value.bin.cb,               //Template cbEid
                    IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,  //Template lpEid
                    IN  0,
                    OUT (LPMAPIPROP *) &lpAddress);

    if (HR_FAILED(hr)) {
				LUIOut(LFAIL3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
		 		retval=FALSE;			
			    goto out;
	}
  //
  // Then set the properties
  //

	PropValue[0].ulPropTag  = PR_DISPLAY_NAME;
    PropValue[1].ulPropTag  = PR_ADDRTYPE;
	PropValue[2].ulPropTag  = PR_EMAIL_ADDRESS;

	cValues = 3; //# of props we are setting
	lstrcpy((LPSTR)szEntryTag,"CreateUserAddress");
	// Addresses are comma delimited and enclosed in quotes
	GetPrivateProfileString("PrepareRecips",szEntryTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
	
	LUIOut(L3,"Entry to Create: %s",EntProp[0]);
	
	for (i=0; i<(int)cValues;i++)
		PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
    hr = lpAddress->SetProps(IN  cValues,
                               IN  PropValue,
                               IN  NULL);
	
    if (HR_FAILED(hr)) {
		LUIOut(L3,"SetProps failed for %s",PropValue[0].Value.LPSZ);
		 	retval=FALSE;			
			goto out;
	}
	hr = lpAddress->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

   if (HR_FAILED(hr)) {
			LUIOut(L3,"SaveChanges failed for SetProps");
			retval=FALSE;
            goto out;
   }
   else LUIOut(LPASS3,"Entry Added to PAB");

   LUIOut(L2,"Create a OneOff Entry in PAB");
   // Create a oneoff user
   cValues = 3;
   lstrcpy((LPSTR)szEntryTag,"CreateOneOffAddress");
   GetPrivateProfileString("PrepareRecips",szEntryTag,"",EntryBuf,MAX_BUF,INIFILENAME);
   GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
   LUIOut(L3,"Entry to Create: %s",EntProp[0]);
   hr = lpAdrBook->CreateOneOff(EntProp[0],EntProp[1],EntProp[2],NULL,&cbEid,&lpEid);

   if (HR_FAILED(hr)) {		
	   LUIOut(LFAIL3,"CreateOneOff");
			 retval=FALSE;
			 goto out;
   }
   else LUIOut(LPASS3,"CreateOneOff");

   LUIOut(L2,"Call PrepareRecips on these two entries in the PAB");
    cEntries = 2;
    MAPIAllocateBuffer(CbNewADRLIST(cEntries), (LPVOID *) &lpAdrList );
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrList->aEntries[0].rgPropVals));
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrList->aEntries[1].rgPropVals));
	
	lpAdrList->cEntries = cEntries;
	lpAdrList->aEntries[0].cValues = 1;
	lpAdrList->aEntries[0].rgPropVals->ulPropTag = PR_ENTRYID;
	lpAdrList->aEntries[0].rgPropVals->dwAlignPad = 0;
	lpAdrList->aEntries[0].rgPropVals->Value.bin.cb = cbUserEid;
	lpAdrList->aEntries[0].rgPropVals->Value.bin.lpb = (LPBYTE) lpUserEid;
	
	lpAdrList->aEntries[1].cValues = 1;
	lpAdrList->aEntries[1].rgPropVals->ulPropTag = PR_ENTRYID;
	lpAdrList->aEntries[1].rgPropVals->dwAlignPad = 0;
	lpAdrList->aEntries[1].rgPropVals->Value.bin.cb = cbEid;
	lpAdrList->aEntries[1].rgPropVals->Value.bin.lpb = (LPBYTE) lpEid;

	cPropCount = 8;
	MAPIAllocateBuffer( CbNewSPropTagArray(cPropCount), (void **)&lpPropTagArray );
	lpPropTagArray->cValues = cPropCount;
	lpPropTagArray->aulPropTag[0] = PR_DISPLAY_NAME;
	lpPropTagArray->aulPropTag[1] = PR_OBJECT_TYPE;
	lpPropTagArray->aulPropTag[2] = PR_ADDRTYPE;
	lpPropTagArray->aulPropTag[3] = PR_EMAIL_ADDRESS;
	lpPropTagArray->aulPropTag[4] = PR_DISPLAY_TYPE;
	lpPropTagArray->aulPropTag[5] = PR_CALLBACK_TELEPHONE_NUMBER;
	lpPropTagArray->aulPropTag[6] = PR_COMMENT;
	lpPropTagArray->aulPropTag[7] = PR_OFFICE_LOCATION;

	if( lpAdrBook->PrepareRecips( 0, lpPropTagArray, lpAdrList ) )
	{
		LUIOut(LFAIL3, "PrepareRecips failed" );
		retval = FALSE;
		goto out;
	}
	else LUIOut(LPASS3, "PrepareRecips passed" );

	if(lpAdrList->cEntries == 0 )
	{
		LUIOut(LFAIL3, "No entries were prepared" );
		retval = FALSE;
		goto out;
	}
	LUIOut(L2,"Verify the returned Properties");

	for ( i = 0; i < (int) cEntries; i++ ) {
		LUIOut(L3,"Entry #: %d",i);
		if (lpAdrList->aEntries[i].cValues != (ULONG)(cPropCount + 1)) {
			LUIOut(LFAIL4, "Number of returned properties is incorrect");
			retval = FALSE;
			goto out;
		}
		else LUIOut(LPASS4, "Number of returned properties is correct");
		for ( j = 0; j < cPropCount; j++ )	{
			if ( PROP_ID(lpAdrList->aEntries[i].rgPropVals[j].ulPropTag) !=
				PROP_ID(lpPropTagArray->aulPropTag[j])) {
				LUIOut(LFAIL4, "Property IDs do not match in the returned data");
				retval = FALSE;
				goto out;
			}
		}
		LUIOut(LPASS4, "All Property IDs match in the returned data");		
		if (lpAdrList->aEntries[i].rgPropVals[j].ulPropTag != PR_ENTRYID ) 	{
				LUIOut(LFAIL4, "Last Property Tag != PR_ENTRYID");
				retval = FALSE;
				goto out;
		} else 	LUIOut(LPASS4, "Last Property Tag == PR_ENTRYID");
				
	}

out:
		if (cEntries > 0)
			for (i=0;i<(int)cEntries; i++) {
				MAPIFreeBuffer( lpAdrList->aEntries[i].rgPropVals );
		}
		
		if (lpAdrList) {
			MAPIFreeBuffer( lpAdrList );
			lpAdrList = NULL;
		}
		if (lpPABCont)
				lpPABCont->Release();
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpUserEid)
			MAPIFreeBuffer(lpUserEid);
		if (lpAddress)
			lpAddress->Release();
		if (lpPropTagArray)
			MAPIFreeBuffer(lpPropTagArray);
		if (lpAdrBook)
			  lpAdrBook->Release();
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
		return retval;
}

BOOL PABCopyEntries()
{

	HRESULT hr      = hrSuccess;
    int		retval=TRUE;

#ifdef PAB

	SizedSPropTagArray(2,SPTTagArray) = {2, {PR_DISPLAY_NAME, PR_ENTRYID } };
    LPMAPISESSION lpMAPISession   = NULL;
    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpPABCont= NULL,lpABCont = NULL, lpABPCont = NULL;
	LPMAPITABLE lpABTable = NULL,lpABPTable= NULL;
    LPSRowSet   lpRowSet    = NULL, lpPRowSet = NULL;
	ULONG     cbEid = 0, cbEidPAB = 0;
	LPENTRYID lpEid = NULL, lpEidPAB = NULL;
	ULONG   ulObjType=NULL, ulSeed=0,ulMaxEntries = 0;	
	ULONG ulPRowCount=0, ulTotalCount=0;
	int idx=0;
	LONG lSeekRow=0,lRowsSeeked=0,lPRowsSeeked=0,lPSeekRow=0;
	LPENTRYLIST lpEntries= NULL;


	LUIOut(L1," ");
	LUIOut(L1,"Running CopyEntries");
		LUIOut(L2,"-> Copies Entries from other Providers into PAB");
		LUIOut(L1," ");

	if (!(MapiInitLogon(OUT &lpMAPISession))) {
		LUIOut(LFAIL2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}

	// Get the IAddrBook	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT &lpAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(LFAIL2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}

	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
							OUT &lpEidPAB,OUT &lpPABCont, OUT &ulObjType);
						
	if (HR_FAILED(hr)) {
				LUIOut(L2,"OpenPABID Failed");
				LUIOut(L3,"Could not Open PAB");
		 		retval=FALSE;
				goto out;
	}
	assert(lpAdrBook != NULL);
	hr = lpAdrBook->OpenEntry(0, NULL, NULL,0,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (!(retval = LogIt(hr,2, "OpenEntry on Root Container AddressBook")))
		goto out;
	
	if (ulObjType != MAPI_ABCONT) {
		LUIOut(LFAIL2, "Object type is not MAPI_ABCONT");
		retval = FALSE;
		goto out;
	}
	LUIOut(LPASS2, "Object type is MAPI_ABCONT");
	
	hr = lpABCont->GetHierarchyTable(CONVENIENT_DEPTH,&lpABTable);
//	hr = lpABCont->GetHierarchyTable(0,&lpABTable);
	if (!(retval = LogIt(hr,2, "GetHierarchyTable on Root Container")))
		goto out;
	
	hr = lpABTable->GetRowCount(0,&ulTotalCount);
	if (!(retval = LogIt(hr,2, "GetRowCount on Root Container")))
		goto out;
	if (ulTotalCount == 0)
	{
		LUIOut(LFAIL2,"No rows in Root AddressBook table.");
		retval = FALSE;
		goto out;
	}

	hr = lpABTable->SetColumns(IN  (LPSPropTagArray) &SPTTagArray,
                                IN  0);
	if (!(retval = LogIt(hr,2, "SetColumns")))
		goto out;

	ulSeed = (unsigned)time( NULL );
	//LUIOut(LPASS3, "Random seed = %lu", ulSeed );
	srand(ulSeed);
	ulMaxEntries = GetPrivateProfileInt("CopyEntries","ulMaxEntries", 3, INIFILENAME);
	for(idx = 0; (idx < ((int)ulTotalCount) && (idx < (int) ulMaxEntries)); ++idx)
	{
		/* Generate a random number */
		/* Seek to that row */
		lSeekRow = idx;
		hr = lpABTable->SeekRow(BOOKMARK_BEGINNING, (LONG)lSeekRow,
					   &lRowsSeeked);
		if (!(retval = LogIt(hr,2, "SeekRow on Root Address Book Table")))
			goto out;
	
		hr = lpABTable->QueryRows(1, TBL_NOADVANCE, &lpRowSet);
		if (!(retval = LogIt(hr,2, "QueryRows on Root Address Book Table")))
			goto out;
		LUIOut(L3," # %d: Provider is %s",idx+1,lpRowSet->aRow[0].lpProps[0].Value.LPSZ);
		cbEid = lpRowSet->aRow[0].lpProps[1].Value.bin.cb;
		lpEid = (LPENTRYID)lpRowSet->aRow[0].lpProps[1].Value.bin.lpb;

		/* Open the entry */
		hr = lpAdrBook->OpenEntry(cbEid,lpEid, NULL, 0, &ulObjType,
					 OUT (LPUNKNOWN *) &lpABPCont);
		if (!(retval = LogIt(hr,4, "OpenEntry on an entry in the hierarchy table")))
			goto out;
		
		hr = lpABPCont->GetContentsTable(0, &lpABPTable);
		if (HR_FAILED(hr))
			goto directory;

		LUIOut(LPASS4,"GetContentsTable");
		
		hr = lpABPTable->GetRowCount(0, &ulPRowCount);
		if (!(retval = LogIt(hr,4, "GetRowCount on Provider table")))
			goto out;
		
		if(ulPRowCount > 0)
		{
			hr = lpABPTable->SetColumns(IN  (LPSPropTagArray) &SPTTagArray, 0);
			if (!(retval = LogIt(hr,4, "SetColumns on Provider table")))
			goto out;
	
			lPSeekRow = (rand() % ulPRowCount);
			hr = lpABPTable->SeekRow(BOOKMARK_BEGINNING, (LONG)lPSeekRow,
						&lPRowsSeeked);
			if (!(retval = LogIt(hr,4, "SeekRows on Provider table")))
			goto out;

			hr = lpABPTable->QueryRows(1, TBL_NOADVANCE, &lpPRowSet);
			if (!(retval = LogIt(hr,4, "QueryRows on Provider table")))
			goto out;

			if(!lpPRowSet->cRows)
				goto directory;
			else
			{
				LUIOut(L3,"Entry to Copy is %s",lpPRowSet->aRow[0].lpProps[0].Value.LPSZ);
		
				/* Copy the entry */
				int temp = sizeof(ENTRYLIST);
				MAPIAllocateBuffer(sizeof(ENTRYLIST),(LPVOID *)&lpEntries);
				if (lpEntries ) {
					lpEntries->cValues = 1;	
					lpEntries->lpbin = NULL;
					MAPIAllocateBuffer((sizeof(SBinary)*lpEntries->cValues),
								(LPVOID *) &(lpEntries->lpbin));
					if (lpEntries->lpbin) {
						lpEntries->lpbin->cb = lpPRowSet->aRow[0].lpProps[1].Value.bin.cb;
						lpEntries->lpbin->lpb = NULL;
						MAPIAllocateBuffer(lpPRowSet->aRow[0].lpProps[1].Value.bin.cb,
									(LPVOID *)&(lpEntries->lpbin->lpb));
						if (lpEntries->lpbin->lpb) {
					
							CopyMemory(lpEntries->lpbin->lpb,
								 lpPRowSet->aRow[0].lpProps[1].Value.bin.lpb,
								 (size_t)lpPRowSet->aRow[0].lpProps[1].Value.bin.cb);
						}
						else {
								LUIOut(LFAIL3,"MAPIAllocateBuffer" );
								retval = FALSE;
								goto out;
						}
					}	
					else {
								LUIOut(LFAIL3,"MAPIAllocateBuffer" );
								retval = FALSE;
								goto out;
					}
				}
				else {
								LUIOut(LFAIL3,"MAPIAllocateBuffer" );
								retval = FALSE;
								goto out;
				}
				
				/* Add to PAB */
				hr = lpPABCont->CopyEntries(lpEntries, (ULONG)GetActiveWindow(), NULL, CREATE_CHECK_DUP_STRICT);
				if (HR_FAILED(hr))
				{
					LUIOut(LFAIL3,"User could not be added to the PAB." );
					retval = FALSE;
					goto out;
				}
				LUIOut(LPASS3,"User was added to the PAB");
		
				/* Free the EntryList */
				
				MAPIFreeBuffer(lpEntries->lpbin->lpb);
				lpEntries->lpbin->lpb = NULL;
				MAPIFreeBuffer(lpEntries->lpbin);
				lpEntries->lpbin = NULL;
				MAPIFreeBuffer(lpEntries);
				lpEntries = NULL;

				/* Free Row */
				if (lpPRowSet) {
					FreeProws(lpPRowSet);
					lpPRowSet = NULL;
				}
				
			}
			
		}
		else //if (lstrcmpi(lpRowSet->aRow[0].lpProps[0].Value.LPSZ,"Personal Address Book"))
directory:
		{
		//--idx;
			/* We want to decrement our counter so we dont add x-1. */
			LUIOut(L3, "Nothing to add. No Rows in the Provider");
		}
		if(lpABPTable) {
			lpABPTable->Release();
			lpABPTable = NULL;
		}
		
		if(lpABPCont) {
			lpABPCont->Release();
			lpABPCont = NULL;
		}

		if (lpRowSet) {
			FreeProws(lpRowSet);
			lpRowSet = NULL;
		}
}

out:
		if (lpEntries) {
			if (lpEntries->lpbin) {
				if (lpEntries->lpbin->lpb)
					MAPIFreeBuffer(lpEntries->lpbin->lpb);
				MAPIFreeBuffer(lpEntries->lpbin);
			}
			MAPIFreeBuffer(lpEntries);
			lpEntries->lpbin = NULL;
		}
				
		if(lpRowSet)
			FreeProws(lpRowSet);
		if(lpPRowSet)
			FreeProws(lpPRowSet);

		if (lpPABCont)
				lpPABCont->Release();
		if (lpABCont)
				lpABCont->Release();
		if (lpABPCont)
				lpABPCont->Release();	
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpABTable)
			lpABTable->Release();
		if (lpABPTable)
			lpABPTable->Release();

	
		//if (lpUserEid)
		//	MAPIFreeBuffer(lpUserEid);
		if (lpAdrBook)
			  lpAdrBook->Release();
		if (lpMAPISession)
			  lpMAPISession->Release();
	MAPIUninitialize();
#endif
	return retval;
}

BOOL PABRunBVT()
{
	LUIOut(L1,"");
	LUIOut(L1,"Running BVT");
	int retval = TRUE;
	//First Clear the PAB
	if (ClearPab(0))  {
		LUIOut(L2,"Clearing PAB");
		LUIOut(LPASS3,"Delete All Entries");
	}
	else  {
		LUIOut(LFAIL3,"Delete All Entries: %d");
		retval = FALSE;
	}
	// Create Entries in the PAB
	if (PabCreateEntry())  {
		LUIOut(L2,"Creating Entries in the PAB");
		LUIOut(LPASS3,"Create Entries");
	}
	else  {
		LUIOut(LFAIL3,"Create Entries");
		retval = FALSE;
	}
	//Enuerate the Entries in PAB
	if (PabEnumerateAll())  {
		LUIOut(L2,"Enumerate All Entries in the PAB");
		LUIOut(LPASS3,"Enumerate All");
	}
	else  {
		LUIOut(LFAIL3,"Enumerate All");
		retval = FALSE;
	}
	
	//Delete Entries in PAB
	if (PabDeleteEntry())  {
		LUIOut(L2,"Delete specified Entries");
		LUIOut(LPASS3,"DeleteEntries");
	}
	else  {
		LUIOut(LFAIL3,"DeleteEntries");
		retval = FALSE;
	}
	// Create a OneOff Entry
	if (CreateOneOff())  {
		LUIOut(L2,"Create a OneOff Entry in the PAB");
		LUIOut(LPASS3,"CreateOneOff");
	}
	else  {
		LUIOut(LFAIL3,"CreateOneOff");
		retval = FALSE;
	}
	// Do a SetProps on a Mail User
	if (PABSetProps())  {
		LUIOut(L2,"SetProps on a Mail User Entry in the PAB");
		LUIOut(LPASS3,"SetProps");
	}
	else  {
		LUIOut(LFAIL3,"SetProps");
		retval = FALSE;
	}
	// CopyEntries from other providers
	if (PABCopyEntries())  {
		LUIOut(L2,"CopyEntries");
		LUIOut(LPASS3,"CopyEntries");
	}
	else  {
		LUIOut(LFAIL3,"CopyEntries");
		retval = FALSE;
	}
	// Resolve Names
	if (PABResolveName())  {
		LUIOut(L2,"ResolveName");
		LUIOut(LPASS3,"ResolveName");
	}
	else  {
		LUIOut(LFAIL3,"ResolveName");
		retval = FALSE;
	}
	// Query Interface
	if (PABQueryInterface())  {
		LUIOut(L2,"ResolveName");
		LUIOut(LPASS3,"QueryInterface");
	}
	else  {
		LUIOut(LFAIL3,"QueryInterface");
		retval = FALSE;
	}
	// PrepareRecips
	if (PABPrepareRecips())  {
		LUIOut(L2,"PrepareRecips");
		LUIOut(LPASS3,"PrepareRecips");
	}
	else  {
		LUIOut(LFAIL3,"PrepareRecips");
		retval = FALSE;
	}
	// Delete Users Only
	if (ClearPab(1))  {
		LUIOut(L2,"Delete Mail Users Only");
		LUIOut(LPASS3,"DeleteUsers");
	}
	else  {
		LUIOut(LFAIL3,"DeleteUsers");
		retval = FALSE;
	}
	return retval;
}

BOOL CALLBACK SetIniFile(HWND hWndDlg,UINT msg, WPARAM wParam, LONG lParam)
{

static char szNewIniFile[BIG_BUF];

	switch(msg)
	{
		case WM_INITDIALOG:	
			SendDlgItemMessage(hWndDlg,IDC_EDIT,WM_SETTEXT, 0,(LPARAM)(LPCTSTR)szIniFile);
			SetFocus(GetDlgItem(hWndDlg,IDC_EDIT));
			return FALSE;			
			
		case WM_COMMAND:
			switch(LOWORD(wParam))
			
			{						
				case IDOK:
					SendDlgItemMessage(hWndDlg,IDC_EDIT,WM_GETTEXT, BIG_BUF,(LPARAM)szNewIniFile);
					if (lstrcmpi(szNewIniFile,szIniFile))
						lstrcpy(szIniFile,szNewIniFile);
					EndDialog(hWndDlg,TRUE);
					return TRUE;
   			
			    		
				case IDCANCEL:
					EndDialog(hWndDlg,FALSE);
					return TRUE;					
			}
			break;
	
		default:
			return FALSE;
	}
	return FALSE;
}

BOOL VerifyBuffer(DWORD ** lppvBufPtr, DWORD dwBufferSize)
{
	DWORD	*lpdwWrkPtr = *lppvBufPtr;
	DWORD	counter, cells, part, cellsize;
	BYTE	*lpbPart;

	// Walk through the allocated buffer's BUFFERSIZE/sizeof(DWORD) cells
	// and fill each DWORD with a pattern (the # of the cell). Then walk
	// the buffer and verify each pattern.

	cellsize = sizeof(DWORD);
	LUIOut(L3,"Writing test patterns to all cells in the buffer.");
	cells = (dwBufferSize/cellsize);	// How many DWORD cells in the buffer?
	part= (ULONG)fmod((double)dwBufferSize, (double)cellsize);	// Is there a remaining section?
	// Write the pattern to memory for the 'cells' portion of the buffer
	for(counter=0; counter < cells; counter++, lpdwWrkPtr++)	{
		*lpdwWrkPtr = counter;
	}
	
	lpbPart = (BYTE*)lpdwWrkPtr;
	// Write the pattern to memory for the 'part' leftover portion of the buffer
	for (counter = 0; counter < part; counter++, lpbPart++)	{
		*lpbPart = PATTERN;
	}

	lpdwWrkPtr = *lppvBufPtr;	//reset work pointer to beginning of buffer
	LUIOut(L3,"Verifying test patterns for %u %u-byte cells in the buffer.",
		cells, cellsize);
	// Verify the pattern in memory for the 'cells' portion of the buffer
	for(counter=0; counter < cells; counter++, lpdwWrkPtr++)	{
		if (*lpdwWrkPtr != counter)	{
			LUIOut(L3,"Verification Failed: Cell %u, expected %u but found %u",
				counter, counter, *lpdwWrkPtr);			
			goto bailout;
		}
	}
	LUIOut(L3,"Verified %u cells succesfully", counter);

	LUIOut(L3,"Verifying test patterns for the remaining %u bytes in the buffer.",
		part);
	// Verify the pattern in memory for the 'part' leftover portion of the buffer
	lpbPart = (BYTE*)lpdwWrkPtr;
	for(counter=0; counter < part; counter++, lpdwWrkPtr++)	{
		if (*lpbPart != PATTERN)	{
			LUIOut(L3,"Verification Failed: Byte %u, expected %u but found %u",
				counter, PATTERN, *lpdwWrkPtr);			
			goto bailout;
		}
	}
	LUIOut(L3,"Verified remaining buffer succesfully");
	return TRUE;

bailout: //verification failed, so I'm outa here!
	return FALSE;

 }

BOOL GetAB(OUT LPADRBOOK* lppAdrBook)
{
	HRESULT	hr;
	BOOL	retval = TRUE;

	//### token to find pab/wab dependencies

#ifdef WAB

	// WAB
	LPVOID	lpReserved = NULL;
	DWORD	dwReserved = 0;
	WAB_PARAM		WP;

	ZeroMemory((void *)&WP, sizeof(WAB_PARAM));
	WP.cbSize=sizeof(WAB_PARAM);
	
	LUIOut(L1, "[ Using the WAB ]");
	lpWABObject=NULL;
//	hr = WABOpen(lppAdrBook, &lpWABObject, &WP, dwReserved);
	hr = WABOpen(lppAdrBook, &lpWABObject, (WAB_PARAM*)lpReserved, dwReserved);
	if (HR_FAILED(hr)) {		
			 LUIOut(L2,"WABOpen FAILED with hr = 0x%x", hr);
			 retval=FALSE;
			 goto out;
	}
	// store the ab pointer in a global variable, temporary kludge to workaround
	// the mulitple wabopen/release bug
	glbllpAdrBook = *lppAdrBook;

#endif

#ifdef PAB

	//	MAPI-PAB


	LUIOut(L1, "[ Using the MAPI-PAB ]");
	if (!(MapiInitLogon(OUT &lpMAPISession))) {
			LUIOut(L2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}

	// Get the IAddrBook - MAPI
	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT lppAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(L2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}

	
#endif
out:
	return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabtool\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	wabtool.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabtool\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__268ADD6D_EF27_11D0_9A7E_00A0C91F9C8B__INCLUDED_)
#define AFX_STDAFX_H__268ADD6D_EF27_11D0_9A7E_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__268ADD6D_EF27_11D0_9A7E_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabtool\wabtool.h ===
// wabtool.h : main header file for the WABTOOL application
//

#if !defined(AFX_WABTOOL_H__268ADD69_EF27_11D0_9A7E_00A0C91F9C8B__INCLUDED_)
#define AFX_WABTOOL_H__268ADD69_EF27_11D0_9A7E_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CWabtoolApp:
// See wabtool.cpp for the implementation of this class
//

class CWabtoolApp : public CWinApp
{
public:
	CWabtoolApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWabtoolApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CWabtoolApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WABTOOL_H__268ADD69_EF27_11D0_9A7E_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabtool\wabtool.cpp ===
// wabtool.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "wabtool.h"
#include "wabtoolDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWabtoolApp

BEGIN_MESSAGE_MAP(CWabtoolApp, CWinApp)
	//{{AFX_MSG_MAP(CWabtoolApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWabtoolApp construction

CWabtoolApp::CWabtoolApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWabtoolApp object

CWabtoolApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CWabtoolApp initialization

BOOL CWabtoolApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

    CCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);

	CWabtoolDlg dlg;
    dlg.m_pszFileName = new CString(cmdInfo.m_strFileName);
        

	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

    delete(dlg.m_pszFileName);

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabtool\wabobject.h ===
#include "stdafx.h"
#include "afxcview.h"
#include "wab.h"

class CWAB
{
public:
    CWAB(CString * pszFileName);
    ~CWAB();
    
    HRESULT LoadWABContents(CListCtrl * pListView);
    void ClearWABLVContents(CListCtrl * pListView);

    void LoadPropTags(CListBox * pList);
    void SetPropString(CEdit * pEdit, ULONG ulPropTag);

    void    ShowSelectedItemDetails(HWND hWndParent);
    HRESULT ShowNewEntryDialog(HWND hWndParent);
    HRESULT DeleteEntry();

    void GetSelectedItemPropArray();

    BOOL GetStringPropVal(HWND hWnd, ULONG ulPropTag, LPTSTR sz, ULONG cbsz);
    BOOL SetSingleStringProp(HWND hWnd, ULONG ulPropTag, LPTSTR sz);

    void SetSelection(CListCtrl * pListView);
    
    void ShowAddressBook(HWND hWnd);

private:
    BOOL        m_bInitialized;
    HINSTANCE   m_hinstWAB;
    LPWABOPEN   m_lpfnWABOpen;
    LPADRBOOK   m_lpAdrBook; 
    LPWABOBJECT m_lpWABObject;
    HWND        m_hWndModelessWABWindow;
    
    // Cache Proparray of currently selected item in the list view
    LPSPropValue m_lpPropArray;
    ULONG       m_ulcValues;
    
    // Cache entry id of currently selected item in the listview
    SBinary     m_SB;

    void FreeProws(LPSRowSet prows);
    HRESULT HrGetWABTemplateID(ULONG   ulObjectType, ULONG * lpcbEID, LPENTRYID * lppEID);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabtool\wabtooldlg.cpp ===
// wabtoolDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wabtool.h"
#include "wabobject.h"
#include "wabtoolDlg.h"
#include "DlgProp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CWAB * g_pWAB;

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWabtoolDlg dialog

CWabtoolDlg::CWabtoolDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CWabtoolDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CWabtoolDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CWabtoolDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWabtoolDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CWabtoolDlg, CDialog)
	//{{AFX_MSG_MAP(CWabtoolDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_NOTIFY(NM_DBLCLK, IDC_LIST, OnDblclkList)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST, OnItemchangedList)
	ON_LBN_SELCHANGE(IDC_LIST_TAGS, OnSelchangeListTags)
	ON_BN_CLICKED(IDC_BUTTON_DETAILS, OnButtonDetails)
	ON_BN_CLICKED(IDC_BUTTON_NEW, OnButtonNew)
	ON_BN_CLICKED(IDC_BUTTON_DELETE, OnButtonDelete)
	ON_BN_CLICKED(IDC_BUTTON_ADDPROP, OnButtonAddprop)
	ON_BN_CLICKED(IDC_BUTTON_MODIFYPROP, OnButtonModifyprop)
	ON_LBN_DBLCLK(IDC_LIST_TAGS, OnDblclkListTags)
	ON_BN_CLICKED(IDC_BUTTON_REFRESH, OnButtonRefresh)
	ON_BN_CLICKED(IDC_BUTTON_WABVIEW, OnButtonWabview)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWabtoolDlg message handlers

BOOL CWabtoolDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
    InitCommonControls();

    LoadContents(TRUE);

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CWabtoolDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CWabtoolDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CWabtoolDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

BOOL CWabtoolDlg::DestroyWindow() 
{
	// TODO: Add your specialized code here and/or call the base class
    ClearCurrentWAB(TRUE);
    
	return CDialog::DestroyWindow();
}

//
// Double-clicking the contents list view shows Details on the 
// selected entries
//
void CWabtoolDlg::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    g_pWAB->ShowSelectedItemDetails(m_hWnd);

	*pResult = 0;
}

//
// Clicking the browse button lets the user select a new WAB file
// to inspect
//
void CWabtoolDlg::OnButtonBrowse() 
{

    char szFilters[]="WAB Files (*.wab)|*.wab|All Files (*.*)|*.*||";
    CFileDialog CFileDlg (TRUE, "wab", "*.wab",
                        OFN_FILEMUSTEXIST, szFilters, this);

    if(CFileDlg.DoModal() == IDOK)
    {
        delete m_pszFileName;
        m_pszFileName = new CString(CFileDlg.GetPathName());

        ClearCurrentWAB(TRUE);
    
        LoadContents(TRUE);

    }
}

// Loads the WAB contents into the list view
// 
// bLoadNew is true if we are loading a new file
//
void CWabtoolDlg::LoadContents(BOOL bLoadNew)
{

    CListCtrl * pListView = (CListCtrl *) GetDlgItem(IDC_LIST);

    if(bLoadNew)
        g_pWAB = new CWAB(m_pszFileName);

    g_pWAB->LoadWABContents(pListView);

    CStatic * pFileName = (CStatic *) GetDlgItem(IDC_STATIC_FILENAME);
    pFileName->SetWindowText((LPTSTR) (LPCTSTR) *m_pszFileName);

    TCHAR sz[256];
    wsprintf(sz, "%d entries", pListView->GetItemCount());
    CStatic * pCount = (CStatic *) GetDlgItem(IDC_STATIC_NUMENTRIES);
    pCount->SetWindowText(sz);

    // select the first item in the list view
    pListView->SetItem( 0, 0,
                        LVIF_STATE,NULL,
                        0,
                        LVNI_SELECTED | LVNI_FOCUSED,
                        LVNI_SELECTED | LVNI_FOCUSED,
                        NULL);

}

//
// Clear out the currently loaded WAB
//
void CWabtoolDlg::ClearCurrentWAB(BOOL bLoadNew)
{
    CListCtrl * pListView = (CListCtrl *) GetDlgItem(IDC_LIST);
    g_pWAB->ClearWABLVContents(pListView);
    
    if(bLoadNew) // we'll be loading a new address book so lose this object
        delete g_pWAB;
}

void CWabtoolDlg::OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    CListCtrl * pListView = (CListCtrl *) GetDlgItem(IDC_LIST);

    static int oldItem = -1;

    int newItem = pListView->GetNextItem(-1, LVNI_SELECTED);

    if(newItem != oldItem && newItem != -1)
    {
        g_pWAB->SetSelection(pListView);
        g_pWAB->GetSelectedItemPropArray();

        TCHAR sz[MAX_PATH];
        g_pWAB->GetStringPropVal(m_hWnd, PR_DISPLAY_NAME, sz, sizeof(sz));
        ((CStatic *)GetDlgItem(IDC_STATIC_SELECTED))->SetWindowText(sz);

        UpdatePropTagData();

        OnSelchangeListTags();

        oldItem = newItem;
    }
	
	*pResult = 0;
}

void CWabtoolDlg::UpdatePropTagData()
{
    g_pWAB->LoadPropTags((CListBox *) GetDlgItem(IDC_LIST_TAGS));
}

void CWabtoolDlg::OnSelchangeListTags() 
{
    TCHAR sz[64];

    CListBox * pList = (CListBox *) GetDlgItem(IDC_LIST_TAGS);

    ULONG ulPropTag = (ULONG) pList->GetItemData(pList->GetCurSel());

    pList->GetText(pList->GetCurSel(), sz);

    SetPropTagString(sz);
    SetPropTypeString(ulPropTag);
    SetPropNameString(ulPropTag);
    SetPropDataString(ulPropTag);

}

LPTSTR PropTypeString(ULONG ulPropType) {
    switch (ulPropType) {
        case PT_UNSPECIFIED:
            return("PT_UNSPECIFIED");
        case PT_NULL:
            return("PT_NULL       ");
        case PT_I2:
            return("PT_I2         ");
        case PT_LONG:
            return("PT_LONG       ");
        case PT_R4:
            return("PT_R4         ");
        case PT_DOUBLE:
            return("PT_DOUBLE     ");
        case PT_CURRENCY:
            return("PT_CURRENCY   ");
        case PT_APPTIME:
            return("PT_APPTIME    ");
        case PT_ERROR:
            return("PT_ERROR      ");
        case PT_BOOLEAN:
            return("PT_BOOLEAN    ");
        case PT_OBJECT:
            return("PT_OBJECT     ");
        case PT_I8:
            return("PT_I8         ");
        case PT_STRING8:
            return("PT_STRING8    ");
        case PT_UNICODE:
            return("PT_UNICODE    ");
        case PT_SYSTIME:
            return("PT_SYSTIME    ");
        case PT_CLSID:
            return("PT_CLSID      ");
        case PT_BINARY:
            return("PT_BINARY     ");
        case PT_MV_I2:
            return("PT_MV_I2      ");
        case PT_MV_LONG:
            return("PT_MV_LONG    ");
        case PT_MV_R4:
            return("PT_MV_R4      ");
        case PT_MV_DOUBLE:
            return("PT_MV_DOUBLE  ");
        case PT_MV_CURRENCY:
            return("PT_MV_CURRENCY");
        case PT_MV_APPTIME:
            return("PT_MV_APPTIME ");
        case PT_MV_SYSTIME:
            return("PT_MV_SYSTIME ");
        case PT_MV_STRING8:
            return("PT_MV_STRING8 ");
        case PT_MV_BINARY:
            return("PT_MV_BINARY  ");
        case PT_MV_UNICODE:
            return("PT_MV_UNICODE ");
        case PT_MV_CLSID:
            return("PT_MV_CLSID   ");
        case PT_MV_I8:
            return("PT_MV_I8      ");
        default:
            return("   <unknown>  ");
    }
}

void CWabtoolDlg::SetPropTypeString(ULONG ulPropTag)
{
    ((CStatic *) GetDlgItem(IDC_STATIC_PROPTYPE))->SetWindowText(PropTypeString(PROP_TYPE(ulPropTag)));
}

void CWabtoolDlg::SetPropTagString(LPTSTR lpTag)
{
    ((CStatic *) GetDlgItem(IDC_STATIC_PROPTAG))->SetWindowText(lpTag);
}

void CWabtoolDlg::OnButtonDetails() 
{
    g_pWAB->ShowSelectedItemDetails(m_hWnd);
    // refresh the list view
    OnButtonRefresh();
}

#define RETURN_PROP_CASE(pt) case PROP_ID(pt): return(#pt)

/***************************************************************************

    Name      : PropTagName

    Purpose   : Associate a name with a property tag

    Parameters: ulPropTag = property tag

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
LPTSTR PropTagName(ULONG ulPropTag) {
    static TCHAR szPropTag[35]; // see string on default

    switch (PROP_ID(ulPropTag)) {
        RETURN_PROP_CASE(PR_7BIT_DISPLAY_NAME);
        RETURN_PROP_CASE(PR_ACCOUNT);
        RETURN_PROP_CASE(PR_ADDRTYPE);
        RETURN_PROP_CASE(PR_ALTERNATE_RECIPIENT);
        RETURN_PROP_CASE(PR_ASSISTANT);
        RETURN_PROP_CASE(PR_ASSISTANT_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BIRTHDAY);
        RETURN_PROP_CASE(PR_BUSINESS_FAX_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_HOME_PAGE);
        RETURN_PROP_CASE(PR_BUSINESS_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS2_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CALLBACK_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CELLULAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CHILDRENS_NAMES);
        RETURN_PROP_CASE(PR_COMMENT);
        RETURN_PROP_CASE(PR_COMPANY_MAIN_PHONE_NUMBER);
        RETURN_PROP_CASE(PR_COMPANY_NAME);
        RETURN_PROP_CASE(PR_COMPUTER_NETWORK_NAME);
        RETURN_PROP_CASE(PR_CONTACT_ADDRTYPES);
        RETURN_PROP_CASE(PR_CONTACT_DEFAULT_ADDRESS_INDEX);
        RETURN_PROP_CASE(PR_CONTACT_EMAIL_ADDRESSES);
        RETURN_PROP_CASE(PR_CONTACT_ENTRYIDS);
        RETURN_PROP_CASE(PR_CONTACT_VERSION);
        RETURN_PROP_CASE(PR_CONVERSION_PROHIBITED);
        RETURN_PROP_CASE(PR_COUNTRY);
        RETURN_PROP_CASE(PR_CUSTOMER_ID);
        RETURN_PROP_CASE(PR_DEPARTMENT_NAME);
        RETURN_PROP_CASE(PR_DISCLOSE_RECIPIENTS);
        RETURN_PROP_CASE(PR_DISPLAY_NAME);
        RETURN_PROP_CASE(PR_DISPLAY_NAME_PREFIX);
        RETURN_PROP_CASE(PR_EMAIL_ADDRESS);
        RETURN_PROP_CASE(PR_ENTRYID);
        RETURN_PROP_CASE(PR_FTP_SITE);
        RETURN_PROP_CASE(PR_GENDER);
        RETURN_PROP_CASE(PR_GENERATION);
        RETURN_PROP_CASE(PR_GIVEN_NAME);
        RETURN_PROP_CASE(PR_GOVERNMENT_ID_NUMBER);
        RETURN_PROP_CASE(PR_HOBBIES);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_CITY);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_COUNTRY);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_POSTAL_CODE);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_STATE_OR_PROVINCE);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_STREET);
        RETURN_PROP_CASE(PR_HOME_FAX_NUMBER);
        RETURN_PROP_CASE(PR_HOME_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_HOME2_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_INITIALS);
        RETURN_PROP_CASE(PR_ISDN_NUMBER);
        RETURN_PROP_CASE(PR_KEYWORD);
        RETURN_PROP_CASE(PR_LANGUAGE);
        RETURN_PROP_CASE(PR_LOCALITY);
        RETURN_PROP_CASE(PR_LOCATION);
        RETURN_PROP_CASE(PR_MAIL_PERMISSION);
        RETURN_PROP_CASE(PR_MANAGER_NAME);
        RETURN_PROP_CASE(PR_MHS_COMMON_NAME);
        RETURN_PROP_CASE(PR_MIDDLE_NAME);
        RETURN_PROP_CASE(PR_NICKNAME);
        RETURN_PROP_CASE(PR_OBJECT_TYPE);
        RETURN_PROP_CASE(PR_OFFICE_LOCATION);
        RETURN_PROP_CASE(PR_ORGANIZATIONAL_ID_NUMBER);
        RETURN_PROP_CASE(PR_ORIGINAL_DISPLAY_NAME);
        RETURN_PROP_CASE(PR_ORIGINAL_ENTRYID);
        RETURN_PROP_CASE(PR_ORIGINAL_SEARCH_KEY);
        RETURN_PROP_CASE(PR_OTHER_ADDRESS_CITY);
        RETURN_PROP_CASE(PR_OTHER_ADDRESS_COUNTRY);
        RETURN_PROP_CASE(PR_OTHER_ADDRESS_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_OTHER_ADDRESS_POSTAL_CODE);
        RETURN_PROP_CASE(PR_OTHER_ADDRESS_STATE_OR_PROVINCE);
        RETURN_PROP_CASE(PR_OTHER_ADDRESS_STREET);
        RETURN_PROP_CASE(PR_OTHER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_PAGER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_PERSONAL_HOME_PAGE);
        RETURN_PROP_CASE(PR_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_POSTAL_ADDRESS);
        RETURN_PROP_CASE(PR_POSTAL_CODE);
        RETURN_PROP_CASE(PR_PREFERRED_BY_NAME);
        RETURN_PROP_CASE(PR_PRIMARY_FAX_NUMBER);
        RETURN_PROP_CASE(PR_PRIMARY_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_PROFESSION);
        RETURN_PROP_CASE(PR_RADIO_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_SEND_INTERNET_ENCODING);
        RETURN_PROP_CASE(PR_SEND_RICH_INFO);
        RETURN_PROP_CASE(PR_SPOUSE_NAME);
        RETURN_PROP_CASE(PR_STATE_OR_PROVINCE);
        RETURN_PROP_CASE(PR_STREET_ADDRESS);
        RETURN_PROP_CASE(PR_SURNAME);
        RETURN_PROP_CASE(PR_TELEX_NUMBER);
        RETURN_PROP_CASE(PR_TITLE);
        RETURN_PROP_CASE(PR_TRANSMITABLE_DISPLAY_NAME);
        RETURN_PROP_CASE(PR_TTYTDD_PHONE_NUMBER);
        RETURN_PROP_CASE(PR_USER_CERTIFICATE);
        RETURN_PROP_CASE(PR_USER_X509_CERTIFICATE);
        RETURN_PROP_CASE(PR_WEDDING_ANNIVERSARY);
        RETURN_PROP_CASE(PR_SEARCH_KEY);

        default:
            wsprintf(szPropTag, "Unknown property tag 0x%x", PROP_ID(ulPropTag));
            return(szPropTag);
    }
}


void CWabtoolDlg::SetPropNameString(ULONG ulPropTag)
{
    LPTSTR lp = PropTagName(ulPropTag);

    CStatic * pType = (CStatic *) GetDlgItem(IDC_STATIC_PROPNAME);

    pType->SetWindowText(lp);
}


void CWabtoolDlg::SetPropDataString(ULONG ulPropTag)
{
    CEdit * pEdit = (CEdit *) GetDlgItem(IDC_EDIT_PROPDATA);
    
    g_pWAB->SetPropString(pEdit, ulPropTag);
}

void CWabtoolDlg::OnButtonNew() 
{

    HRESULT hr = g_pWAB->ShowNewEntryDialog(m_hWnd);

    if(!hr)
        OnButtonRefresh();
}

void CWabtoolDlg::OnButtonDelete() 
{
    g_pWAB->DeleteEntry();
    // refresh the list view
    OnButtonRefresh();
}

void CWabtoolDlg::OnButtonAddprop() 
{
    TCHAR sz[512];
    *sz = '\0';
    CDlgProp dlgProp;

    dlgProp.m_ulPropTag = 0;
    dlgProp.m_lpszPropVal = sz;
    dlgProp.m_cbsz = sizeof(sz);

    if(dlgProp.DoModal())
    {
        g_pWAB->SetSingleStringProp(m_hWnd, dlgProp.m_ulPropTag, sz);
        UpdatePropTagData();
        OnSelchangeListTags();
    }

}

void CWabtoolDlg::OnButtonModifyprop() 
{
	
    CListBox * pList = (CListBox *) GetDlgItem(IDC_LIST_TAGS);

    ULONG ulPropTag = (ULONG) pList->GetItemData(pList->GetCurSel());

    TCHAR sz[512];

    if(g_pWAB->GetStringPropVal(m_hWnd, ulPropTag, sz, sizeof(sz)))
    {
        CDlgProp dlgProp;

        dlgProp.m_ulPropTag = ulPropTag;
        dlgProp.m_lpszPropVal = sz;
        dlgProp.m_cbsz = sizeof(sz);

        if(dlgProp.DoModal())
        {
            g_pWAB->SetSingleStringProp(m_hWnd, ulPropTag, sz);
            UpdatePropTagData();
            OnSelchangeListTags();
        }


    }

}

void CWabtoolDlg::OnDblclkListTags() 
{
    OnButtonModifyprop();	
}

void CWabtoolDlg::OnButtonRefresh() 
{
    // refresh the list view
    ClearCurrentWAB(FALSE);
    LoadContents(FALSE);
}

void CWabtoolDlg::OnButtonWabview() 
{
    g_pWAB->ShowAddressBook(m_hWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabtool\wabtooldlg.h ===
// wabtoolDlg.h : header file
//

#if !defined(AFX_WABTOOLDLG_H__268ADD6B_EF27_11D0_9A7E_00A0C91F9C8B__INCLUDED_)
#define AFX_WABTOOLDLG_H__268ADD6B_EF27_11D0_9A7E_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CWabtoolDlg dialog

class CWabtoolDlg : public CDialog
{
// Construction
public:
	CWabtoolDlg(CWnd* pParent = NULL);	// standard constructor

    void LoadContents(BOOL bLoadNew);
    void ClearCurrentWAB(BOOL bLoadNew);

    void UpdatePropTagData();
    void SetPropTagString(LPTSTR lpTag);
    void SetPropTypeString(ULONG ulPropTag);
    void SetPropNameString(ULONG ulPropTag);
    void SetPropDataString(ULONG ulPropTag);

    CString * m_pszFileName;

// Dialog Data
	//{{AFX_DATA(CWabtoolDlg)
	enum { IDD = IDD_WABTOOL_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWabtoolDlg)
	public:
	virtual BOOL DestroyWindow();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CWabtoolDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnButtonBrowse();
	afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSelchangeListTags();
	afx_msg void OnButtonDetails();
	afx_msg void OnButtonNew();
	afx_msg void OnButtonDelete();
	afx_msg void OnButtonAddprop();
	afx_msg void OnButtonModifyprop();
	afx_msg void OnDblclkListTags();
	afx_msg void OnButtonRefresh();
	afx_msg void OnButtonWabview();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WABTOOLDLG_H__268ADD6B_EF27_11D0_9A7E_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabtool\wabobject.cpp ===
#include "wabobject.h"



enum {
    ieidPR_DISPLAY_NAME = 0,
    ieidPR_ENTRYID,
	ieidPR_OBJECT_TYPE,
    ieidMax
};
static const SizedSPropTagArray(ieidMax, ptaEid)=
{
    ieidMax,
    {
        PR_DISPLAY_NAME,
        PR_ENTRYID,
		PR_OBJECT_TYPE,
    }
};


enum {
    iemailPR_DISPLAY_NAME = 0,
    iemailPR_ENTRYID,
    iemailPR_EMAIL_ADDRESS,
    iemailPR_OBJECT_TYPE,
    iemailMax
};
static const SizedSPropTagArray(iemailMax, ptaEmail)=
{
    iemailMax,
    {
        PR_DISPLAY_NAME,
        PR_ENTRYID,
        PR_EMAIL_ADDRESS,
        PR_OBJECT_TYPE
    }
};


/*********************************************************************************/


// contructor for CWAB object
//
// pszFileName - FileName of WAB file to open
//          if no file name is specified, opens the default
//
CWAB::CWAB(CString * pszFileName)
{
    // Here we load the WAB Object and initialize it
    m_bInitialized = FALSE;
	m_lpPropArray = NULL;
    m_ulcValues = 0;
    m_hWndModelessWABWindow = NULL;

    {
        TCHAR  szWABDllPath[MAX_PATH];
        DWORD  dwType = 0;
        ULONG  cbData = sizeof(szWABDllPath);
        HKEY hKey = NULL;

        *szWABDllPath = '\0';
        
        // First we look under the default WAB DLL path location in the
        // Registry. 
        // WAB_DLL_PATH_KEY is defined in wabapi.h
        //
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WAB_DLL_PATH_KEY, 0, KEY_READ, &hKey))
            RegQueryValueEx( hKey, "", NULL, &dwType, (LPBYTE) szWABDllPath, &cbData);

        if(hKey) RegCloseKey(hKey);

        // if the Registry came up blank, we do a loadlibrary on the wab32.dll
        // WAB_DLL_NAME is defined in wabapi.h
        //
        m_hinstWAB = LoadLibrary( (lstrlen(szWABDllPath)) ? szWABDllPath : WAB_DLL_NAME );
    }

    if(m_hinstWAB)
    {
        // if we loaded the dll, get the entry point 
        //
        m_lpfnWABOpen = (LPWABOPEN) GetProcAddress(m_hinstWAB, "WABOpen");

        if(m_lpfnWABOpen)
        {
            HRESULT hr = E_FAIL;
            WAB_PARAM wp = {0};
            wp.cbSize = sizeof(WAB_PARAM);
            wp.szFileName = (LPTSTR) (LPCTSTR) *pszFileName;
        
            // if we choose not to pass in a WAB_PARAM object, 
            // the default WAB file will be opened up
            //
            hr = m_lpfnWABOpen(&m_lpAdrBook,&m_lpWABObject,&wp,0);

            if(!hr)
                m_bInitialized = TRUE;
        }
    }

}


// Destructor
//
CWAB::~CWAB()
{
    if(m_SB.lpb)
        LocalFree(m_SB.lpb);

    if(m_bInitialized)
    {
        if(m_hWndModelessWABWindow)
            DestroyWindow(m_hWndModelessWABWindow);

        if(m_lpPropArray)
            m_lpWABObject->FreeBuffer(m_lpPropArray);

        if(m_lpAdrBook)
            m_lpAdrBook->Release();

        if(m_lpWABObject)
            m_lpWABObject->Release();

        if(m_hinstWAB)
            FreeLibrary(m_hinstWAB);
    }
}


// Opens a wab file and puts its contents into the specified list view
//
HRESULT CWAB::LoadWABContents(CListCtrl * pListView)
{
    ULONG ulObjType =   0;
	LPMAPITABLE lpAB =  NULL;
    LPTSTR * lppszArray=NULL;
    ULONG cRows =       0;
    LPSRowSet lpRow =   NULL;
	LPSRowSet lpRowAB = NULL;
    LPABCONT  lpContainer = NULL;
	int cNumRows = 0;
    int nRows=0;

    HRESULT hr = E_FAIL;

    ULONG lpcbEID;
	LPENTRYID lpEID = NULL;

    // Get the entryid of the root PAB container
    //
    hr = m_lpAdrBook->GetPAB( &lpcbEID, &lpEID);

	ulObjType = 0;

    // Open the root PAB container
    // This is where all the WAB contents reside
    //
    hr = m_lpAdrBook->OpenEntry(lpcbEID,
					    		(LPENTRYID)lpEID,
						    	NULL,
							    0,
							    &ulObjType,
							    (LPUNKNOWN *)&lpContainer);

	m_lpWABObject->FreeBuffer(lpEID);

	lpEID = NULL;
	
    if(HR_FAILED(hr))
        goto exit;

    // Get a contents table of all the contents in the
    // WABs root container
    //
    hr = lpContainer->GetContentsTable( 0,
            							&lpAB);

    if(HR_FAILED(hr))
        goto exit;

    // Order the columns in the ContentsTable to conform to the
    // ones we want - which are mainly DisplayName, EntryID and
    // ObjectType
    // The table is gauranteed to set the columns in the order 
    // requested
    //
	hr =lpAB->SetColumns( (LPSPropTagArray)&ptaEid, 0 );

    if(HR_FAILED(hr))
        goto exit;


    // Reset to the beginning of the table
    //
	hr = lpAB->SeekRow( BOOKMARK_BEGINNING, 0, NULL );

    if(HR_FAILED(hr))
        goto exit;

    // Read all the rows of the table one by one
    //
	do {

		hr = lpAB->QueryRows(1,	0, &lpRowAB);

        if(HR_FAILED(hr))
            break;

        if(lpRowAB)
        {
            cNumRows = lpRowAB->cRows;

		    if (cNumRows)
		    {
                LPTSTR lpsz = lpRowAB->aRow[0].lpProps[ieidPR_DISPLAY_NAME].Value.lpszA;
                LPENTRYID lpEID = (LPENTRYID) lpRowAB->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.lpb;
                ULONG cbEID = lpRowAB->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb;

                // There are 2 kinds of objects - the MAPI_MAILUSER contact object
                // and the MAPI_DISTLIST contact object
                // For the purposes of this sample, we will only consider MAILUSER
                // objects
                //
                if(lpRowAB->aRow[0].lpProps[ieidPR_OBJECT_TYPE].Value.l == MAPI_MAILUSER)
                {
                    // We will now take the entry-id of each object and cache it
                    // on the listview item representing that object. This enables
                    // us to uniquely identify the object later if we need to
                    //
                    LPSBinary lpSB = NULL;

                    m_lpWABObject->AllocateBuffer(sizeof(SBinary), (LPVOID *) &lpSB);
                
                    if(lpSB)
                    {
                        m_lpWABObject->AllocateMore(cbEID, lpSB, (LPVOID *) &(lpSB->lpb));

                        if(!lpSB->lpb)
                        {
                            m_lpWABObject->FreeBuffer(lpSB);
                            continue;
                        }
                    
                        CopyMemory(lpSB->lpb, lpEID, cbEID);
                        lpSB->cb = cbEID;

                        LV_ITEM lvi = {0};
                        lvi.mask = LVIF_TEXT | LVIF_PARAM;
                        lvi.iItem = pListView->GetItemCount();
                        lvi.iSubItem = 0;
                        lvi.pszText = lpsz;
                        lvi.lParam = (LPARAM) lpSB;

                        // Now add this item to the list view
                        pListView->InsertItem(&lvi);
                    }
                }
		    }
		    FreeProws(lpRowAB );		
        }

	}while ( SUCCEEDED(hr) && cNumRows && lpRowAB)  ;

exit:

	if ( lpContainer )
		lpContainer->Release();

	if ( lpAB )
		lpAB->Release();

    return hr;
}


// Clears the contents of the specified ListView
//
void CWAB::ClearWABLVContents(CListCtrl * pListView)
{
    int i;
    int nCount = pListView->GetItemCount();
    
    if(nCount<=0)
        return;

    for(i=0;i<nCount;i++)
    {
        LV_ITEM lvi ={0};
        lvi.mask = LVIF_PARAM;
        lvi.iItem = i;
        lvi.iSubItem = 0;
        pListView->GetItem(&lvi);
        if(lvi.lParam)
        {
            LPSBinary lpSB = (LPSBinary) lvi.lParam;
            m_lpWABObject->FreeBuffer(lpSB);
        }
    }
    pListView->DeleteAllItems();
}



void CWAB::FreeProws(LPSRowSet prows)
{
	ULONG		irow;
	if (!prows)
		return;
	for (irow = 0; irow < prows->cRows; ++irow)
		m_lpWABObject->FreeBuffer(prows->aRow[irow].lpProps);
	m_lpWABObject->FreeBuffer(prows);
}

// When an item is selected in the listview, we
// cache its entry id as a special selected item
//
void CWAB::SetSelection(CListCtrl * pListView)
{

    LV_ITEM lvi = {0};
    // Get the Selected Item from the listview
    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = pListView->GetNextItem(-1, LVNI_SELECTED);

    if(lvi.iItem == -1)
        return;

    pListView->GetItem(&lvi);

    if(lvi.lParam)
    {
        LPSBinary lpSB = (LPSBinary) lvi.lParam;
        if(m_SB.lpb)
            LocalFree(m_SB.lpb);
        m_SB.cb = lpSB->cb;
        m_SB.lpb = (LPBYTE) LocalAlloc(LMEM_ZEROINIT, m_SB.cb);
        if(m_SB.lpb)
            CopyMemory(m_SB.lpb, lpSB->lpb, m_SB.cb);
        else
            m_SB.cb = 0;
    }    
}



// Show details on the selected item
//
void CWAB::ShowSelectedItemDetails(HWND hWndParent)
{
    HRESULT hr = S_OK;

    // if we have a specially cached entryid ..
    //
    if(m_SB.cb && m_SB.lpb)
    {
        HWND hWnd = NULL;
        LPSBinary lpSB = (LPSBinary) &m_SB;
        hr = m_lpAdrBook->Details(  (LPULONG) &hWnd,
					        		NULL, NULL,
								    lpSB->cb,
								    (LPENTRYID) lpSB->lpb,
								    NULL, NULL,
								    NULL, 0);
    }
    return;
}

// Gets a SPropValue array for the selected item
// This array contains all the properties for that item
// though we could actually get a subset too if we
// wanted to
//
void CWAB::GetSelectedItemPropArray()
{
    if(m_SB.lpb && m_SB.cb)
    {
        LPMAILUSER lpMailUser = NULL;
        LPSBinary lpSB = (LPSBinary) &m_SB;
        ULONG ulObjType = 0;

        // Open the selected entry 
        //
        m_lpAdrBook->OpenEntry(lpSB->cb,
                               (LPENTRYID) lpSB->lpb,
                              NULL,         // interface
                              0,            // flags
                              &ulObjType,
                              (LPUNKNOWN *)&lpMailUser);

        if(lpMailUser)
        {
            // Flush away any old array we might have cached
            //
            if(m_lpPropArray)
                m_lpWABObject->FreeBuffer(m_lpPropArray);
            m_ulcValues = 0;

            lpMailUser->GetProps(NULL, 0, &m_ulcValues, &m_lpPropArray);

            lpMailUser->Release();
        }
    }
    return;
}


// Loads the proptags for the selected entry into the
// PropTags list box
//
void CWAB::LoadPropTags(CListBox * pList)
{
    if(!m_ulcValues || !m_lpPropArray)
        return;

    pList->ResetContent();

    ULONG i;
    TCHAR sz[32];
    for(i=0;i<m_ulcValues;i++)
    {
        wsprintf(sz, "0x%.8x", m_lpPropArray[i].ulPropTag);
        pList->SetItemData(pList->AddString(sz), m_lpPropArray[i].ulPropTag);
    }

    pList->SetCurSel(-1);
    pList->SetCurSel(0);
}


// Sets the property value, if understandable, into the
// given edit box
//
void CWAB::SetPropString(CEdit * pEdit, ULONG ulPropTag)
{
    pEdit->SetWindowText("");

    if(!m_ulcValues || !m_lpPropArray)
        return;

    ULONG i;

    for(i=0;i<m_ulcValues;i++)
    {
        if(m_lpPropArray[i].ulPropTag == ulPropTag)
        {
            switch(PROP_TYPE(ulPropTag))
            {
            case PT_TSTRING:
                pEdit->SetWindowText(m_lpPropArray[i].Value.LPSZ);
                break;
            case PT_MV_TSTRING:
                {
                    ULONG j;
                    LPSPropValue lpProp = &(m_lpPropArray[i]);
                    for(j=0;j<lpProp->Value.MVSZ.cValues;j++)
                    {
                        pEdit->ReplaceSel(lpProp->Value.MVSZ.LPPSZ[j]);
                        pEdit->ReplaceSel("\r\n");
                    }
                }
                break;
            case PT_BINARY:
                pEdit->SetWindowText("Binary data");
                break;
            case PT_I2:
            case PT_LONG:
            case PT_R4:
            case PT_DOUBLE:
            case PT_BOOLEAN:
                {
                    TCHAR sz[256];
                    wsprintf(sz,"%d",m_lpPropArray[i].Value.l);
                    pEdit->SetWindowText(sz);
                }
                break;
            default:
                pEdit->SetWindowText("Unrecognized or undisplayable data");
                break;
            }
            break;
        }
    }

}


enum {
    icrPR_DEF_CREATE_MAILUSER = 0,
    icrPR_DEF_CREATE_DL,
    icrMax
};

const SizedSPropTagArray(icrMax, ptaCreate)=
{
    icrMax,
    {
        PR_DEF_CREATE_MAILUSER,
        PR_DEF_CREATE_DL,
    }
};


// Gets the WABs default Template ID for MailUsers
// or DistLists. These Template IDs are needed for creating
// new mailusers and distlists
//
HRESULT CWAB::HrGetWABTemplateID(ULONG   ulObjectType,
                                ULONG * lpcbEID,
                                LPENTRYID * lppEID)
{
    LPABCONT lpContainer = NULL;
    HRESULT hr  = hrSuccess;
    SCODE sc = ERROR_SUCCESS;
    ULONG ulObjType = 0;
    ULONG cbWABEID = 0;
    LPENTRYID lpWABEID = NULL;
    LPSPropValue lpCreateEIDs = NULL;
    LPSPropValue lpNewProps = NULL;
    ULONG cNewProps;
    ULONG nIndex;

    if (    (!m_lpAdrBook) ||
           ((ulObjectType != MAPI_MAILUSER) && (ulObjectType != MAPI_DISTLIST)) )
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    *lpcbEID = 0;
    *lppEID = NULL;

    if (HR_FAILED(hr = m_lpAdrBook->GetPAB( &cbWABEID,
                                      &lpWABEID)))
    {
        goto out;
    }

    if (HR_FAILED(hr = m_lpAdrBook->OpenEntry(cbWABEID,     // size of EntryID to open
                                        lpWABEID,     // EntryID to open
                                        NULL,         // interface
                                        0,            // flags
                                        &ulObjType,
                                        (LPUNKNOWN *)&lpContainer)))
    {
        goto out;
    }

    // Opened PAB container OK

    // Get us the default creation entryids
    if (HR_FAILED(hr = lpContainer->GetProps(   (LPSPropTagArray)&ptaCreate,
                                                0,
                                                &cNewProps,
                                                &lpCreateEIDs)  )   )
    {
        goto out;
    }

    // Validate the properites
    if (    lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].ulPropTag != PR_DEF_CREATE_MAILUSER ||
            lpCreateEIDs[icrPR_DEF_CREATE_DL].ulPropTag != PR_DEF_CREATE_DL)
    {
        goto out;
    }

    if(ulObjectType == MAPI_DISTLIST)
        nIndex = icrPR_DEF_CREATE_DL;
    else
        nIndex = icrPR_DEF_CREATE_MAILUSER;

    *lpcbEID = lpCreateEIDs[nIndex].Value.bin.cb;

    m_lpWABObject->AllocateBuffer(*lpcbEID, (LPVOID *) lppEID);
    
    if (sc != S_OK)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }
    CopyMemory(*lppEID,lpCreateEIDs[nIndex].Value.bin.lpb,*lpcbEID);

out:
    if (lpCreateEIDs)
        m_lpWABObject->FreeBuffer(lpCreateEIDs);

    if (lpContainer)
        lpContainer->Release();

    if (lpWABEID)
        m_lpWABObject->FreeBuffer(lpWABEID);

    return hr;
}


// Shows the NewEntry dialog to enable creating a new contact in the WAB
//
HRESULT CWAB::ShowNewEntryDialog(HWND hWndParent)
{
	ULONG cbEID=0;
	LPENTRYID lpEID=NULL;

    HRESULT hr = hrSuccess;
    ULONG cbTplEID = 0;
    LPENTRYID lpTplEID = NULL;

    // Get the template id which is needed to create the
    // new object
    //
    if(HR_FAILED(hr = HrGetWABTemplateID(   MAPI_MAILUSER,
                                            &cbTplEID,
                                            &lpTplEID)))
    {
        goto out;
    }

    // Display the New Entry dialog to create the new entry
    //
	if (HR_FAILED(hr = m_lpAdrBook->NewEntry(	(ULONG) hWndParent,
							            		0,
									            0,NULL,
									            cbTplEID,lpTplEID,
									            &cbEID,&lpEID)))
    {
        goto out;
    }

out:
    return hr;
}


// Delete an entry from the WAB
//
HRESULT CWAB::DeleteEntry()
{
	HRESULT hr = hrSuccess;
    ULONG cbWABEID = 0;
    LPENTRYID lpWABEID = NULL;
    LPABCONT lpWABCont = NULL;
    ULONG ulObjType;
    SBinaryArray SBA;

    hr = m_lpAdrBook->GetPAB( &cbWABEID,
                              &lpWABEID);
    if(HR_FAILED(hr))
        goto out;

    hr = m_lpAdrBook->OpenEntry(  cbWABEID,     // size of EntryID to open
                                  lpWABEID,     // EntryID to open
                                  NULL,         // interface
                                  0,            // flags
                                  &ulObjType,
                                  (LPUNKNOWN *)&lpWABCont);

    if(HR_FAILED(hr))
        goto out;

    SBA.cValues = 1;
    SBA.lpbin = &m_SB;

    hr = lpWABCont->DeleteEntries((LPENTRYLIST) &SBA, 0);

    if(m_lpPropArray)
        m_lpWABObject->FreeBuffer(m_lpPropArray);

    m_lpPropArray = NULL;
    m_ulcValues = 0;

out:
    if(lpWABCont)
        lpWABCont->Release();

    if(lpWABEID)
        m_lpWABObject->FreeBuffer(lpWABEID);

    return hr;
}


// Gets the property value for specified String property
//
BOOL CWAB::GetStringPropVal(HWND hWnd, ULONG ulPropTag, LPTSTR sz, ULONG cbsz)
{

    BOOL bRet = FALSE;

    if(PROP_TYPE(ulPropTag) != PT_TSTRING)
    {
        MessageBox(hWnd, "This tool only supports modifying string type props right now",
            "Error", MB_OK | MB_ICONINFORMATION);
        goto out;
    }

    ULONG i;

    // Since we already cached the proparray for the selected
    // item, all we need to do is look in the cached proparray
    // for the requested proptag
    //
    for(i=0;i<m_ulcValues;i++)
    {
        if(m_lpPropArray[i].ulPropTag == ulPropTag)
        {
            LPTSTR lp = m_lpPropArray[i].Value.LPSZ;
            ULONG nLen = (ULONG) lstrlen(lp);
            if(nLen >= cbsz)
            {
                CopyMemory(sz, lp, cbsz-1);
                sz[cbsz-1]='\0';
            }
            else 
                lstrcpy(sz,lp);
            break;
        }
    }

    bRet = TRUE;
out:
    return bRet;
}


// Sets a single string property onto a mailuser object
//
BOOL CWAB::SetSingleStringProp(HWND hWnd, ULONG ulPropTag, LPTSTR sz)
{
    SPropValue Prop;
    BOOL bRet = FALSE;

    if(PROP_TYPE(ulPropTag) != PT_TSTRING)
    {
        MessageBox(hWnd, "This version of the tool can only set string properties.",
            "Error", MB_OK | MB_ICONINFORMATION);
        goto out;
    }

    Prop.ulPropTag = ulPropTag;
    Prop.Value.LPSZ = sz;

    // Open the cached entry and get a mailuser object
    // representing that entry
    //
    if(m_SB.lpb && m_SB.cb)
    {
        LPMAILUSER lpMailUser = NULL;
        LPSBinary lpSB = (LPSBinary) &m_SB;
        ULONG ulObjType = 0;

        // To modify an object, make sure to specify the 
        // MAPI_MODIFY flag otherwise the object is always
        // opened read-only be default
        //
        m_lpAdrBook->OpenEntry(lpSB->cb,
                               (LPENTRYID) lpSB->lpb,
                              NULL,         // interface
                              MAPI_MODIFY,            // flags
                              &ulObjType,
                              (LPUNKNOWN *)&lpMailUser);

        if(lpMailUser)
        {

            // Knock out this prop if it exists so we can overwrite it
            //
            {
                SPropTagArray SPTA;
                SPTA.cValues = 1;
                SPTA.aulPropTag[0] = ulPropTag;

                lpMailUser->DeleteProps(&SPTA, NULL);
            }

            // Set the new property on the mailuser
            //
            if (!HR_FAILED(lpMailUser->SetProps(1, &Prop, NULL)))
            {
                // **NOTE** if you dont call SaveChanges, the
                // changes are not saved (duh). Also if you didnt
                // open the object with the MAPI_MODIFY flag, you
                // are likely to get an ACCESS_DENIED error
                //
                lpMailUser->SaveChanges(0);
                bRet = TRUE;
            }
            lpMailUser->Release();
        }
    }

out:

    GetSelectedItemPropArray();
    return bRet;
}


void STDMETHODCALLTYPE TestDismissFunction(ULONG ulUIParam, LPVOID lpvContext)
{
    LPDWORD lpdw = (LPDWORD) lpvContext;
    return;
}

DWORD dwContext = 77;

// Shows the Address Book
//
void CWAB::ShowAddressBook(HWND hWnd)
{
    ADRPARM AdrParm = {0};
    
    AdrParm.lpszCaption = "WABTool Address Book View";      

    AdrParm.cDestFields = 0;
    AdrParm.ulFlags = DIALOG_SDI;
    AdrParm.lpvDismissContext = &dwContext;
    AdrParm.lpfnDismiss = &TestDismissFunction;
    AdrParm.lpfnABSDI = NULL;

    m_lpAdrBook->Address(  (ULONG *) &m_hWndModelessWABWindow,     
                            &AdrParm,   
                            NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\childfrm.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// childfrm.cpp : implementation of the CChildFrame class
//

#include "stdafx.h"
#include "VC.h"

#include "childfrm.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CChildFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
	// TODO: add member initialization code here
	
}

CChildFrame::~CChildFrame()
{
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	cs.style = WS_CHILD | WS_VISIBLE | WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU
		| FWS_ADDTOTITLE | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_MAXIMIZE;

	return CMDIChildWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
	CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\childfrm.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// childfrm.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

class CChildFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CChildFrame)
public:
	CChildFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildFrame)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CChildFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CChildFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\callcntr.h ===
// CallCntr.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCallCenter dialog

class CCallCenter : public CDialog
{
// Construction
public:
	CCallCenter(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCallCenter)
	enum { IDD = IDD_DIALOG_CALLCENTER };
	CString	m_addrCity;
	CString	m_addrState;
	CString	m_addrStreet;
	CString	m_addrZip;
	CString	m_callerID;
	CString	m_employer;
	CString	m_firstName;
	CString	m_lastName;
	CString	m_telFax;
	CString	m_telHome;
	CString	m_telWork;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCallCenter)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCallCenter)
	afx_msg void OnButtonClear();
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonAnswer();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\callcntr.cpp ===
// CallCntr.cpp : implementation file
//

#include "stdafx.h"
#include "VC.h"
#include "CallCntr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCallCenter dialog


CCallCenter::CCallCenter(CWnd* pParent /*=NULL*/)
	: CDialog(CCallCenter::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCallCenter)
	m_addrCity = _T("");
	m_addrState = _T("");
	m_addrStreet = _T("");
	m_addrZip = _T("");
	m_callerID = _T("");
	m_employer = _T("");
	m_firstName = _T("");
	m_lastName = _T("");
	m_telFax = _T("");
	m_telHome = _T("");
	m_telWork = _T("");
	//}}AFX_DATA_INIT
}


void CCallCenter::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCallCenter)
	DDX_Text(pDX, IDC_EDIT_ADDRCITY, m_addrCity);
	DDX_Text(pDX, IDC_EDIT_ADDRSTATE, m_addrState);
	DDX_Text(pDX, IDC_EDIT_ADDRSTREET, m_addrStreet);
	DDX_Text(pDX, IDC_EDIT_ADDRZIP, m_addrZip);
	DDX_Text(pDX, IDC_EDIT_CALLERID, m_callerID);
	DDX_Text(pDX, IDC_EDIT_EMPLOYER, m_employer);
	DDX_Text(pDX, IDC_EDIT_FIRSTNAME, m_firstName);
	DDX_Text(pDX, IDC_EDIT_LASTNAME, m_lastName);
	DDX_Text(pDX, IDC_EDIT_TELFAX, m_telFax);
	DDX_Text(pDX, IDC_EDIT_TELHOME, m_telHome);
	DDX_Text(pDX, IDC_EDIT_TELWORK, m_telWork);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCallCenter, CDialog)
	//{{AFX_MSG_MAP(CCallCenter)
	ON_BN_CLICKED(IDC_BUTTON_CLEAR, OnButtonClear)
	ON_BN_CLICKED(IDC_BUTTON_ANSWER, OnButtonAnswer)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCallCenter message handlers

void CCallCenter::OnButtonClear() 
{
	m_addrCity = _T("");
	m_addrState = _T("");
	m_addrStreet = _T("");
	m_addrZip = _T("");
	m_callerID = _T("");
	m_employer = _T("");
	m_firstName = _T("");
	m_lastName = _T("");
	m_telFax = _T("");
	m_telHome = _T("");
	m_telWork = _T("");
	UpdateData(FALSE);
}

BOOL CCallCenter::OnInitDialog() 
{
	WINDOWPLACEMENT wndpl;

	CDialog::OnInitDialog();
	
	VERIFY(GetWindowPlacement(&wndpl));
	wndpl.showCmd = SW_SHOWMAXIMIZED;
	VERIFY(SetWindowPlacement(&wndpl));
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CCallCenter::OnButtonAnswer() 
{
	//((CVCApp *)AfxGetApp())->ReceiveCard("D:\\VC_DEMO\\Adaptec.vcf");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\clist.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// Class List

#ifndef __CLIST_H__
#define __CLIST_H__

#include "vcenv.h"

class CListElement
	{
public:
	CListElement  *m_prev;
	CListElement  *m_next;
	void  *m_item;
	CListElement();
	~CListElement();
	};
	
typedef CListElement *CLISTPOSITION;
typedef int (*CListSearchFunc)(void *item, void *context);

class CList
    {
protected:
    CListElement  *m_head;
    CListElement  *m_tail;
    U32 m_count;
public:
	void  *GetHead(void);
	void  *GetTail(void);
	CListElement  *GetHeadPosition(void);
	CListElement  *GetTailPosition(void);
    CListElement  *Find( void  * );
    CListElement *Search(CListSearchFunc compare, void *context);
    void  *GetNext(CLISTPOSITION& );
    void  *GetPrev(CLISTPOSITION& );
    void RemoveAt( CListElement  * );
    void RemoveNoDel( CListElement  * );
    void RemoveAll(void);
    void  *GetAt( CListElement  * );
    void InsertAfter( CListElement  *, CListElement  * );
    CListElement  *InsertAfter( CListElement  *, void * );
    void InsertBefore( CListElement  *, CListElement  * );
    CListElement  *InsertBefore( CListElement  *, void * );
    void InsertAtTail( CListElement  * );
    void InsertAtHead( CListElement  * );
    CListElement  *AddTail( void  * );
    CListElement  *AddHead( void  * );
    void MoveToTail( CListElement  * );
    void MoveToHead( CListElement  * );
    S32 GetCount(void);
    U32 IsEmpty(void);
    CList();
    ~CList();
    };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\filestf.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// base buffered file input
#include "stdafx.h"
#ifndef __MWERKS__
#else
#define tellg() rdbuf()->pubseekoff(0,ios::cur).offset()	// thanx bjs
#endif

#include <ctype.h>
#include "vcenv.h"
#include "filestf.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

P_FILEBUF OpenFile( istream *f )
    {
    P_FILEBUF temp;

	temp = new FILEBUF;
	// if (temp == 0)
	// 	fprintf(stderr, "failed buffer allocation\n");
	temp->nextChar = 0;
	temp->lastChar = 0;
	temp->strm = f;

	if (temp->strm != 0)
		{
		//temp->lastChar = fread( temp->buf, 1, 4096, temp->strm );
		//temp->nextChar = 0;
		temp->nextChar = temp->lastChar = 4096;
		}
	return(temp);
    }

void CloseFile( P_FILEBUF fb )
    {
	//fclose( fb->strm );
	delete fb;
    }

BOOL FileGetC( P_FILEBUF file, P_U8 c )
    {
	if (file->nextChar == file->lastChar)
		{
		if (file->lastChar != 4096)
			return FALSE;
		long pos = file->strm->tellg();
		file->strm->read(file->buf, 4096);
		file->lastChar = file->strm->tellg() - pos;
		if (file->lastChar == 0)
			return FALSE;
		file->nextChar = 0;
		}
    *c = file->buf[file->nextChar];
	file->nextChar += 1;
    return TRUE;
    }

BOOL FilePeekC( P_FILEBUF file, P_U8 c )
    {
	if (file->nextChar == file->lastChar)
		{
		if (file->lastChar != 4096)
			return FALSE;
		long pos = file->strm->tellg();
		file->strm->read(file->buf, 4096);
		file->lastChar = file->strm->tellg() - pos;
		if (file->lastChar == 0)
			return FALSE;
		file->nextChar = 0;
		}
    *c = file->buf[file->nextChar];
    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\clist.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// Class List

#include "stdafx.h"
#ifndef __MWERKS__	// gca
#else
#include <assert.h>	// gca
#define	ASSERT assert
#endif
#include <ctype.h>
#include "clist.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CListElement::CListElement()
	{
	m_next = NULL;
	m_prev = NULL;
	m_item = NULL;
	}
	
CListElement::~CListElement()
	{
	}
	
CList::CList()
	{
	m_head = NULL;
	m_tail = NULL;
	m_count = 0;
	}

CList::~CList()
	{
	RemoveAll();
	}

void CList::InsertAfter( CListElement  *here, CListElement  *elem )
	{
	if ( here == NULL )
		{
		// put it at the front (bottom) of the group
		elem->m_prev = NULL;
		elem->m_next = m_head;
		if (m_head != NULL)
			m_head->m_prev = elem;
		m_head = elem;
        if (m_tail == NULL)
			m_tail = elem;
		}
    else
		{
		if ( here == m_tail )
			{
		    elem->m_next = here->m_next;  // NULL
		    elem->m_prev = here;
		    here->m_next = elem;
			m_tail = elem;
			}
        else
			{
		    elem->m_next = here->m_next;
		    elem->m_prev = here;
		    here->m_next->m_prev = elem;
		    here->m_next = elem;
			}
		}
	m_count += 1;
	}

CListElement  * CList::InsertAfter( CListElement  *here, void  *item )
	{
	CListElement  *le;
	
	le = new CListElement;
	le->m_item = item;
	InsertAfter( here, le );
	return (le);
	}
	
void CList::InsertBefore( CListElement  *here, CListElement  *elem )
	{
	if (here != NULL)
        InsertAfter( here->m_prev, elem );
    else
        InsertAfter( here, elem );
    }
    
CListElement  * CList::InsertBefore( CListElement  *here, void  *item )
	{
	CListElement  *le;
	
	le = new CListElement;
	le->m_item = item;
	InsertBefore( here, le );
	return (le);
	}
	
void CList::RemoveNoDel( CListElement  *elem )
	{
    if (elem == m_head)
		m_head = elem->m_next;
    if (elem == m_tail)
		m_tail = elem->m_prev;
    if ( elem->m_prev != NULL )
        elem->m_prev->m_next = elem->m_next;
    if ( elem->m_next != NULL )
		elem->m_next->m_prev = elem->m_prev;
	m_count -= 1;
	}

void CList::RemoveAt( CListElement  *elem )
	{
	RemoveNoDel( elem );
	delete elem;
	}

void CList::RemoveAll()
	{
	while (m_tail)
		RemoveAt(m_tail);
	ASSERT(m_count == 0);
	ASSERT(m_head == NULL);
	}
	
void CList::MoveToTail( CListElement  *elem )
	{
	RemoveNoDel( elem );
	InsertAfter( m_tail, elem );
	}

void CList::MoveToHead( CListElement  *elem )
	{
	RemoveNoDel( elem );
	InsertAfter( NULL, elem );
	}

void CList::InsertAtTail( CListElement  *elem )
	{
	InsertAfter( m_tail, elem );
	}

void CList::InsertAtHead( CListElement  *elem )
	{
	InsertAfter( NULL, elem );
	}
	
CListElement  * CList::AddTail( void  *item )
	{
	CListElement  *le;
	
	le = new CListElement;
	le->m_item = item;
	InsertAfter( m_tail, le );
	return (le);
	}

CListElement  * CList::AddHead( void  *item )
	{
	CListElement  *le;
	
	le = new CListElement;
	le->m_item = item;
	InsertAfter( NULL, le );
	return (le);
	}
	
CListElement  * CList::Find( void  *item )
	{
	CListElement  *le;
	
	for( le = m_head; le != NULL; le = le->m_next )
		if( le->m_item == item )
		    return( le );
	return (NULL);
	}

CListElement * CList::Search(CListSearchFunc compare, void *context)
	{
	CListElement  *le;
	
	for( le = m_head; le != NULL; le = le->m_next )
		if( compare( le->m_item, context ))
		    return( le );
	return (NULL);
	}

void  * CList::GetHead(void)
	{
	return m_head->m_item;
	}

void  * CList::GetTail(void)
	{
	return m_tail->m_item;
	}
	
CListElement  * CList::GetHeadPosition(void)
	{
	return m_head;
	}
	
CListElement  * CList::GetTailPosition(void)
	{
	return m_tail;
	}
	
void  * CList::GetNext( CLISTPOSITION& le )
	{
	void  *temp;
	
	temp = le->m_item;
	le = le->m_next;
	
	return temp;
	}
	
void  * CList::GetPrev( CLISTPOSITION& le )
	{
	void  *temp;
	
	temp = le->m_item;
	le = le->m_prev;
	
	return temp;
	}
	
S32 CList::GetCount(void)
	{
	return m_count;
	}

U32 CList::IsEmpty(void)
	{
	if (m_count == 0)
		return 1;
	else
		return 0;
	}
	
void *  CList::GetAt(CListElement  *elem)
	{
	return (elem->m_item);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\filestf.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/


#ifndef __FILESTF_H__
#define __FILESTF_H__

#include <iostream.h>


typedef struct
	{
	istream *strm;
	U8 buf[4096];
	S32 nextChar;
	S32 lastChar;
	} FILEBUF, *P_FILEBUF, **PP_FILEBUF;
	
P_FILEBUF OpenFile( istream *f );
void CloseFile( P_FILEBUF fb );
BOOL FileGetC( P_FILEBUF file, P_U8 c );
BOOL FilePeekC( P_FILEBUF file, P_U8 c );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\mainfrm.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// mainfrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnEditPaste();
	afx_msg void OnEditPasteSpecial();
	afx_msg void OnDebugShowCallCenter();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\gifread.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/


#ifndef __GIFREAD_H__
#define __GIFREAD_H__

#include "filestf.h"
#include "vcenv.h"

typedef struct
	{
	U8 r, g, b, u;
	} GIFRGB, *P_GIFRGB, **PP_GIFRGB;
	
typedef struct
	{
	S16 r, g, b, u;
	} ERRGB, *P_ERRGB, **PP_ERRGB;

typedef struct
	{
	U8 sig[3];
	U8 version[3];
	} GIFHEADER, *P_GIFHEADER, **PP_GIFHEADER;

typedef struct
	{
	GIFRGB *globalColorTable;
	U16 width;
	U16 height;
	U16 globalColorTableSize;
	U8 flags;
	BOOL hasGlobalColorTable;
	U8 colorResolution;
	BOOL sorted;
	U8 backgroundColor;
	U8 aspect;
	} GIFLOGICALSCREENDESCRIPTOR, *P_GIFLOGICALSCREENDESCRIPTOR, **PP_GIFLOGICALSCREENDESCRIPTOR;

typedef struct
	{
	U16 delayTime;
	U8 flags;
	BOOL hasTransparency;
	U8 transparentColor;
	} GIFGRAPHICCONTROLEXTENSION, *P_GIFGRAPHICCONTROLEXTENSION, **PP_GIFGRAPHICCONTROLEXTENSION;

typedef struct
	{
	U8 *data;
	U16 gridLeft, gridTop, gridWidth, gridHeight;
	U8 cellWidth, cellHeight;
	U8 foregroundColor, backgroundColor;
	} GIFPLAINTEXTEXTENSION;

typedef struct
	{
	U8 *data;
	} GIFCOMMENT;

typedef struct
	{
	U8 *data;
	U8 ID[8];
	U8 auth[3];
	} GIFAPPLICATIONEXTENSION;

typedef struct
	{
	U8 *data;
	GIFRGB *localColorTable;
	U16 left, top, width, height;
	U16 localColorTableSize;
	BOOL hasLocalColorTable;
	BOOL interlaced;
	BOOL sorted;
	U8 flags;
	} GIFIMAGEDESCRIPTOR, *P_GIFIMAGEDESCRIPTOR, **PP_GIFIMAGEDESCRIPTOR;

typedef struct
	{
	GIFHEADER header;
	GIFLOGICALSCREENDESCRIPTOR screen;
	} GIFENTITY, *P_GIFENTITY, **PP_GIFENTITY;

typedef struct
	{
	GIFENTITY *entity;
	GIFGRAPHICCONTROLEXTENSION gext;
	GIFIMAGEDESCRIPTOR image;
	} GIFIMAGE, *P_GIFIMAGE, **PP_GIFIMAGE;

#define MAX_CODES   4095

	
class CGifReader
	{
	CDC *m_maskDC;
	P_FILEBUF m_file;
	P_GIFRGB m_currentColorTable;
	BOOL m_dither;
	BOOL m_errorDiffuse;
	BOOL m_buildMask;
	BOOL m_interlaced;
	U16 m_left, m_top, m_width, m_height;
	U16 m_lineCount;
	U16 m_pass;
	S32 m_bitsPerPixel;
	S32 m_badCodeCount;
	U32 m_currentSize;
	U32 m_clear;
	U32 m_ending;
	U32 m_newCodes;
	U32 m_topSlot;
	U32 m_slot;
    U32 m_availableBytes;              /* # bytes left in block */
    U32 m_availableBits;                /* # bits left in current byte */
    U8 m_currentByte;                           /* Current byte */
	U8 *m_pBytes;                      /* Pointer to next byte in block */
    U8 m_byteBuff[258];               /* Current block */
	U8 m_stack[MAX_CODES + 1];            /* Stack for storing pixels */
	U8 m_suffix[MAX_CODES + 1];           /* Suffix table */
	U16 m_prefix[MAX_CODES + 1];           /* Prefix linked list */ 
	U8 m_transparentIndex;
	P_ERRGB m_errRow;
	U8 *m_imageBytes;
	BOOL GetBlockByte(P_U8 b);
    BOOL ReadHeader( P_FILEBUF file, GIFHEADER *header );
    BOOL ReadColorTable( P_FILEBUF file, U16 count, P_GIFRGB ct );    
	BOOL ReadLogicalScreenDescriptor( P_FILEBUF file,
								  P_GIFLOGICALSCREENDESCRIPTOR screen );
	BOOL ReadImageDescriptor( P_FILEBUF file, P_GIFIMAGEDESCRIPTOR image );
	BOOL ReadGraphicControlExtension( P_FILEBUF file,
									P_GIFGRAPHICCONTROLEXTENSION ext );
	BOOL TrashDataSubBlocks( P_FILEBUF file );
	BOOL TrashCommentExtension( P_FILEBUF file );
	BOOL TrashApplicationExtension( P_FILEBUF file );
	BOOL TrashPlainTextExtension( P_FILEBUF file );
	S16 InitDecoder(S16 size);
	BOOL GetNextCode(P_U32 code);
	BOOL Decode(U32 linewidth);
	BOOL OutputLine(U8 *pixels, U32 linelen); 
	BOOL OutputLineD(U8 *pixels, U32 linelen); 
	BOOL OutputLineE(U8 *pixels, U32 linelen); 
	BOOL OutputLineDefered(U8 *pixels, U32 linelen); 
public:
	CDC *m_pDC;
	BOOL GetGifSize(istream *istrm, P_FCOORD size, BOOL *transparency);
	BOOL ReadGif(istream *istrm, CDC *pDC, CDC *maskDC);
	CGifReader();
	~CGifReader();
	};
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\gifread.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// the gif file reader

	#include "stdafx.h"
#ifndef __MWERKS__				// gca 12/19/95
	#include <malloc.h>
#else
	#include "WindowsToMac.h"
	#include <stdlib.h>
#endif							// gca 12/19/95

#include <ctype.h>
#include "vcenv.h"
#include "filestf.h"
#include "gifread.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

U8 DitherRGB( P_GIFRGB grgb, U32 x, U32 y );	// gca 12/19/95
U8 MapRGB( P_GIFRGB grgb, U32 x, U32 y );		// gca  12/19/95

BOOL CGifReader::ReadHeader( P_FILEBUF file, GIFHEADER *header )
	{
	S32 i;

	for (i = 0; i < 3; i++)
		if (!FileGetC( file, &(header->sig[i]) ))
			return FALSE;
	for (i = 0; i < 3; i++)
		if (!FileGetC( file, &(header->version[i]) ))
			return FALSE;
	if((header->sig[0] == 'G') && (header->sig[1] == 'I') && (header->sig[2] == 'F'))
		{
		if (header->version[0] == '8')
			return TRUE;
		else
			return FALSE;
		}
	else
		return FALSE;
	}

/*
void DumpHeader( GIFHEADER *header )
	{
	S32 i;

	for (i = 0; i < 3; i++)
		printf( "%c", header->sig[i]);
	printf( "\n");
	for (i = 0; i < 3; i++)
		printf( "%c", header->version[i]);
	printf( "\n");
	}
*/

BOOL CGifReader::ReadColorTable( P_FILEBUF file, U16 count, P_GIFRGB ct )
	{
	U32 i;

	for (i = 0; i < count; i++)
		{
		if (!FileGetC( file, &(ct->r) ))
			return FALSE;
		if (!FileGetC( file, &(ct->g) ))
			return FALSE;
		if (!FileGetC( file, &(ct->b) ))
			return FALSE;
		// printf( "r %d g %d b %d\n", (int )ct->r, (int )ct->g, (int )ct->b );
		ct++;
		}
	return TRUE;
	}

BOOL CGifReader::ReadLogicalScreenDescriptor( P_FILEBUF file,
								  P_GIFLOGICALSCREENDESCRIPTOR screen )
	{
	S32 i;
	U8 b;

	screen->width = 0;
	screen->height = 0;

	for (i = 0; i < 2; i++)
		{
		if (!FileGetC( file, &b ))
			return FALSE;
		screen->width |= ((U16 )b) << (i << 3);
		}
	for (i = 0; i < 2; i++)
		{
		if (!FileGetC( file, &b ))
			return FALSE;
		screen->height |= ((U16 )b) << (i << 3);
		}
	if (!FileGetC( file, &(screen->flags) ))
		return FALSE;
	screen->hasGlobalColorTable = screen->flags >> 7;
	screen->colorResolution = (screen->flags >> 4) & 0x07;
	screen->sorted = (screen->flags >> 3) & 0x01;
	screen->globalColorTableSize = ((U16 )0x01) << ((screen->flags & 0x07) + 1);
	if (!FileGetC( file, &(screen->backgroundColor) ))
		return FALSE;
	if (!FileGetC( file, &(screen->aspect) ))
		return FALSE;
	if (screen->hasGlobalColorTable)
		{
		screen->globalColorTable = new GIFRGB[screen->globalColorTableSize];
		ReadColorTable( file, screen->globalColorTableSize,
								 screen->globalColorTable );
		}
	else
		screen->globalColorTable = NULL;
#if __MWERKS__
	m_pDC->CreateOffscreen(screen->width,screen->height);	// create 32 bit color offscreen!!!
	m_pDC->FocusTheWorld();	// the active port!!

#endif
	return TRUE;
	}

/*
void DumpLSD( GIFLOGICALSCREENDESCRIPTOR *screen )
	{
	printf("width %d height %d \n", (int )screen->width, (int )screen->height );
	printf("has table %d color res %d sorted %d size %d \n",
			  (int )screen->hasGlobalColorTable, (int )screen->colorResolution,
			  (int )screen->sorted, (int )screen->globalColorTableSize );
	printf("background %d aspect %d \n", (int )screen->backgroundColor,
			  (int )screen->aspect);
	}
*/

BOOL CGifReader::ReadImageDescriptor( P_FILEBUF file, P_GIFIMAGEDESCRIPTOR image )
	{
	S32 i;
	U8 b;

	image->left = 0;
	image->top = 0;
	image->width = 0;
	image->height = 0;

	for (i = 0; i < 2; i++)
		{
		if (!FileGetC( file, &b ))
			return FALSE;
		image->left |= ((U16 )b) << (i << 3);
		}
	for (i = 0; i < 2; i++)
		{
		if (!FileGetC( file, &b ))
			return FALSE;
		image->top |= ((U16 )b) << (i << 3);
		}
	for (i = 0; i < 2; i++)
		{
		if (!FileGetC( file, &b ))
			return FALSE;
		image->width |= ((U16 )b) << (i << 3);
		}
	for (i = 0; i < 2; i++)
		{
		if (!FileGetC( file, &b ))
			return FALSE;
		image->height |= ((U16 )b) << (i << 3);
		}
	m_left = image->left;
	m_top = image->top;
	m_width = image->width;
	m_height = image->height;
	if (!FileGetC( file, &(image->flags )))
		return FALSE;
	image->hasLocalColorTable = image->flags >> 7;
	image->interlaced = (image->flags >> 6) & 0x01;
	m_interlaced = image->interlaced;
	image->sorted = (image->flags >> 5) & 0x01;
	image->localColorTableSize = ((U16 )0x01) << ((image->flags & 0x07) + 1);
	if (image->hasLocalColorTable)
		{
		image->localColorTable = new GIFRGB[image->localColorTableSize];
		ReadColorTable( file, image->localColorTableSize,
								 image->localColorTable );
		}	
	else
		image->localColorTable = NULL;
	return TRUE;
	}

/*
void DumpID( GIFIMAGEDESCRIPTOR *image )
	{
	printf("left %d top %d \n", (int )image->left, (int )image->top );
	printf("width %d height %d \n", (int )image->width, (int )image->height );
	printf("has table %d sorted %d size %d \n",
			  (int )image->hasLocalColorTable,
			  (int )image->sorted, (int )image->localColorTableSize );
	printf("interlaced %d \n", (int )image->interlaced);
	}
*/
BOOL CGifReader::ReadGraphicControlExtension( P_FILEBUF file,
									P_GIFGRAPHICCONTROLEXTENSION ext )
	{
	S32 i;
	U8 b;

	if (!FileGetC( file, &b))
		return FALSE;
	if (b != 4)
		return FALSE;
	
	if (!FileGetC( file, &b))
		return FALSE;
	ext->flags = b;
	if (ext->flags & 0x01)
		m_buildMask = ext->hasTransparency = TRUE;
	else
	    ext->hasTransparency = FALSE;

	for (i = 0; i < 2; i++)
		{
		if (!FileGetC( file, &b ))
			return FALSE;
		ext->delayTime |= ((U16 )b) << (i << 3);
		}

	if (!FileGetC( file, &b))
		return FALSE;
	ext->transparentColor = b;
	m_transparentIndex = b;
	if (!FileGetC( file, &b))
		return FALSE;
	if (b == 0)
		return TRUE;
	else
		return FALSE;
	}
	
BOOL CGifReader::TrashDataSubBlocks( P_FILEBUF file )
	{
	S32 i;
	U8 b, count;
    
    if (!FileGetC( file, &count))
    	return FALSE;
    while (count)
    	{
    	for (i = 0; i < count; i++)
			if (!FileGetC( file, &b))
				return FALSE;
    	if (!FileGetC( file, &count))
    		return FALSE;
    	}
    return TRUE;
	}

BOOL CGifReader::TrashCommentExtension( P_FILEBUF file )
	{
	TrashDataSubBlocks( file );
    return TRUE;
	}
	
BOOL CGifReader::TrashPlainTextExtension( P_FILEBUF file )
	{
	S32 i;
	U8 b;
    
    for (i = 0; i < 12; i++)
		if (!FileGetC( file, &b))
			return FALSE;
	TrashDataSubBlocks( file );
    return TRUE;
	}
	
BOOL CGifReader::TrashApplicationExtension( P_FILEBUF file )
	{
	S32 i;
	U8 b;
    
    for (i = 0; i < 11; i++)
		if (!FileGetC( file, &b))
			return FALSE;
	TrashDataSubBlocks( file );
    return TRUE;
	}


/* Another try... but this doesn't seem too good
const U8 FireOrder[64] = {
59,11,43,31,  50,34, 2,30,
35,27,63, 3,  10,18,58,46,
 7,51,19,39,  54,42,26,14,
23,47,15,55,  22, 6,38,62,

49,33, 1,29,  60,12,44,33,
 9,17,57,45,  36,28,64, 4,
53,41,25,13,   8,52,20,40,
21, 5,37,61,  24,48,16,56 }; */

/* this one is reverse-symetric but it doesn't seem to be better ???  */

const U8 FireOrder[64] = {
 2,53,10,61,   3,56,11,64,
37,18,41,26,  40,19,44,27,
14,57, 6,49,  15,60, 7,52,
45,30,33,22,  48,31,36,23,

 4,55,12,63,   1,54, 9,62,
39,20,43,28,  38,17,42,25,
16,59, 8,51,  13,58, 5,50,
47,32,35,24,  46,29,34,21 };

U8 DitherRGB( P_GIFRGB grgb, U32 x, U32 y )
	{
	U16 RedS, GreenS, BlueS;
	U8 RedP, GreenP, BlueP;
	U8 index;
	
	RedS = (U16 )grgb->r + 1;
	RedS += (RedS >> 2);
	GreenS = (U16 )grgb->g + 1;
	GreenS += (GreenS >> 2);
	BlueS = (U16 )grgb->b + 1;
	BlueS += (BlueS >> 2);

	RedP = (U8 )(RedS >> 6);
	GreenP = (U8 )(GreenS >> 6);
	BlueP = (U8 )(BlueS >> 6);

	if ((RedP < 5) && (FireOrder[((y & 7) << 3)|(x & 7)] <= ((U8 )(RedS & 63))))
		RedP += 1;
	if ((GreenP < 5) && (FireOrder[((y & 7) << 3)|(x & 7)] <= ((U8 )(GreenS & 63))))
		GreenP += 1;
	if ((BlueP < 5) && (FireOrder[((y & 7) << 3)|(x & 7)] <= ((U8 )(BlueS & 63))))
		BlueP += 1;

	index = ((RedP << 5)+(RedP << 2)) + ((GreenP << 2)+(GreenP << 1)) + BlueP;
		
	return index;
    }

U8 MapRGB( P_GIFRGB grgb, U32 x, U32 y )
	{
	U16 RedS, GreenS, BlueS;
	U8 RedP, GreenP, BlueP;
	U8 index;
	
	RedS = (U16 )grgb->r + 1;
	RedS += (RedS >> 2);
	GreenS = (U16 )grgb->g + 1;
	GreenS += (GreenS >> 2);
	BlueS = (U16 )grgb->b + 1;
	BlueS += (BlueS >> 2);

	RedP = (U8 )(RedS >> 6);
	GreenP = (U8 )(GreenS >> 6);
	BlueP = (U8 )(BlueS >> 6);
	index = ((RedP << 5)+(RedP << 2)) + ((GreenP << 2)+(GreenP << 1)) + BlueP;
		
	return index;
    }

extern LOGPALETTE *bublp;
extern CPalette bubPalette;

// stores the pixels to m_imageBytes so that we can do an error diffusion before display
BOOL CGifReader::OutputLineDefered(U8 *pixels, U32 linelen)
	{
	U32 i;
	U8 *tmp;
	
	tmp = m_imageBytes + (m_lineCount * linelen);
	
	for( i = 0; i < linelen; i++)
		tmp[i] = pixels[i];
	
	
    if (m_interlaced)  // this is always true
    	{
    	if ((m_pass == 0) || (m_pass == 1))
    		{
    		m_lineCount += 8;
    		if (m_lineCount >= (m_top + m_height))
    			{
    			m_pass += 1;
    			if (m_pass == 1)
    				m_lineCount = m_top + 4;
    			else if (m_pass == 2)
    				m_lineCount = m_top + 2;
    			}
    		}
    	else if (m_pass == 2)
    		{
    		m_lineCount += 4;
    		if (m_lineCount >= (m_top + m_height))
    			{
    			m_pass += 1;
    			m_lineCount = m_top + 1;
    			}
    		}
    	else /* m_pass == 3 */
    		{
    		m_lineCount += 2;
    		}
    	}
    else	
		m_lineCount += 1;
	return TRUE;
	}

// this version has my trial error-diffusion which has potential... 
// if it is going to be used, it could probably stand some simple optimization
BOOL CGifReader::OutputLineE(U8 *pixels, U32 linelen)
	{
#ifndef __MWERKS__
	COLORREF color;
#else
	RGBCOLOR color;		// gca 1/21/96
#endif
	U32 i, j;
	GIFRGB grgb;
	U8 pix, index;
	S16 rerr, gerr, berr;
	S16 rerr1, gerr1, berr1;
	S16 rerr2, gerr2, berr2;
	ERRGB hold;
	
	rerr = gerr = berr = 0;
	rerr1 = gerr1 = berr1 = 0;
	rerr2 = gerr2 = berr2 = 0; 
	
	hold = m_errRow[1];
	
	m_errRow[0].r = 0;
	m_errRow[0].g = 0;
	m_errRow[0].b = 0;
	m_errRow[1].r = 0;
	m_errRow[1].g = 0;
	m_errRow[1].b = 0;
	
    j = 1;
	
	if (m_buildMask && m_maskDC)
		{
		for (i = 0; i < linelen; i++)
			{
			pix = pixels[i];
			grgb = m_currentColorTable[pix];
			if (m_dither)
				{
				rerr = (S16 )grgb.r + rerr1 + hold.r;
				gerr = (S16 )grgb.g + gerr1 + hold.g;
				berr = (S16 )grgb.b + berr1 + hold.b;
				if (rerr > 255)
					rerr = 255;
				else if (rerr < 0)
					rerr = 0;
				if (gerr > 255)
					gerr = 255;
				else if (gerr < 0)
					gerr = 0;
				if (berr > 255)
					berr = 255;
				else if (berr < 0)
					berr = 0;
				grgb.r = (U8 )rerr;
				grgb.g = (U8 )gerr;
				grgb.b = (U8 )berr;
				index = MapRGB(&grgb, i, m_lineCount);
				if (m_bitsPerPixel == 8)
					color = PALETTEINDEX(index);
				else
					color = RGB(bublp->palPalEntry[index].peRed, bublp->palPalEntry[index].peGreen, bublp->palPalEntry[index].peBlue);
				m_pDC->SetPixelV((int )i, (int )m_lineCount, color);
				rerr = (S16 )grgb.r - (S16 )bublp->palPalEntry[index].peRed;
				gerr = (S16 )grgb.g - (S16 )bublp->palPalEntry[index].peGreen;
				berr = (S16 )grgb.b - (S16 )bublp->palPalEntry[index].peBlue;
				rerr2 = rerr >> 4;
				gerr2 = gerr >> 4;
				berr2 = berr >> 4;
				rerr1 = (rerr >> 1) - rerr2;
				gerr1 = (gerr >> 1) - gerr2;
				berr1 = (berr >> 1) - berr2;
				m_errRow[j-1].r += (rerr >> 3) - rerr2;
				m_errRow[j-1].g += (gerr >> 3) - gerr2;
				m_errRow[j-1].b += (berr >> 3) - berr2;
				m_errRow[j].r += (rerr >> 2) + rerr2;
				m_errRow[j].g += (gerr >> 2) + gerr2;
				m_errRow[j].b += (berr >> 2) + berr2;
				hold = m_errRow[j+1];
				m_errRow[j+1].r = rerr2;
				m_errRow[j+1].g = gerr2;
				m_errRow[j+1].b = berr2;
				j += 1;
				}
			else
				{
				color = RGB(grgb.r, grgb.g, grgb.b);
				m_pDC->SetPixelV((int )i, (int )m_lineCount, color);
				}
            if (pix == m_transparentIndex)
            	m_maskDC->SetPixelV((int )i, (int )m_lineCount, RGB(255, 255, 255));
            else
            	m_maskDC->SetPixelV((int )i, (int )m_lineCount, RGB(0,0,0));
			}
		}
	else
		{
		for (i = 0; i < linelen; i++)
			{
			grgb = m_currentColorTable[pixels[i]];
			if (m_dither)
				{
				rerr = (S16 )grgb.r + rerr1 + hold.r;
				gerr = (S16 )grgb.g + gerr1 + hold.g;
				berr = (S16 )grgb.b + berr1 + hold.b;
				if (rerr > 255)
					rerr = 255;
				else if (rerr < 0)
					rerr = 0;
				if (gerr > 255)
					gerr = 255;
				else if (gerr < 0)
					gerr = 0;
				if (berr > 255)
					berr = 255;
				else if (berr < 0)
					berr = 0;
				grgb.r = (U8 )rerr;
				grgb.g = (U8 )gerr;
				grgb.b = (U8 )berr;
				index = MapRGB(&grgb, i, m_lineCount); 
				if (m_bitsPerPixel == 8)
					color = PALETTEINDEX(index);
				else
					color = RGB(bublp->palPalEntry[index].peRed, bublp->palPalEntry[index].peGreen, bublp->palPalEntry[index].peBlue);
				m_pDC->SetPixelV((int )i, (int )m_lineCount, color);
				rerr = (S16 )grgb.r - (S16 )bublp->palPalEntry[index].peRed;
				gerr = (S16 )grgb.g - (S16 )bublp->palPalEntry[index].peGreen;
				berr = (S16 )grgb.b - (S16 )bublp->palPalEntry[index].peBlue;
				rerr2 = rerr >> 4;
				gerr2 = gerr >> 4;
				berr2 = berr >> 4;
				rerr1 = (rerr >> 1) - rerr2;
				gerr1 = (gerr >> 1) - gerr2;
				berr1 = (berr >> 1) - berr2;
				m_errRow[j-1].r += (rerr >> 3) - rerr2;
				m_errRow[j-1].g += (gerr >> 3) - gerr2;
				m_errRow[j-1].b += (berr >> 3) - berr2;
				m_errRow[j].r += (rerr >> 2) + rerr2;
				m_errRow[j].g += (gerr >> 2) + gerr2;
				m_errRow[j].b += (berr >> 2) + berr2;
				hold = m_errRow[j+1];
				m_errRow[j+1].r = rerr2;
				m_errRow[j+1].g = gerr2;
				m_errRow[j+1].b = berr2;
				j += 1;
				}
			else
				{
				color = RGB(grgb.r, grgb.g, grgb.b);
				m_pDC->SetPixelV((int )i, (int )m_lineCount, color);
				}

			}
		}
    if (m_interlaced)
    	{
    	if ((m_pass == 0) || (m_pass == 1))
    		{
    		m_lineCount += 8;
    		if (m_lineCount >= (m_top + m_height))
    			{
    			m_pass += 1;
    			if (m_pass == 1)
    				m_lineCount = m_top + 4;
    			else if (m_pass == 2)
    				m_lineCount = m_top + 2;
    			}
    		}
    	else if (m_pass == 2)
    		{
    		m_lineCount += 4;
    		if (m_lineCount >= (m_top + m_height))
    			{
    			m_pass += 1;
    			m_lineCount = m_top + 1;
    			}
    		}
    	else /* m_pass == 3 */
    		{
    		m_lineCount += 2;
    		}
    	}
    else	
		m_lineCount += 1;
	return TRUE;
	}

BOOL CGifReader::OutputLineD(U8 *pixels, U32 linelen)
	{
#ifndef __MWERKS__
	COLORREF color;
#else
	RGBCOLOR color;		// gca 1/21/96
#endif
	U32 i;
	P_GIFRGB grgb;
	U8 pix, index;
         	
	if (m_buildMask && m_maskDC)
		{
		if (m_dither)
			{
			if (m_bitsPerPixel == 8)
				{
				for (i = 0; i < linelen; i++)
					{
					pix = pixels[i];
					grgb = &(m_currentColorTable[pix]);
					index = DitherRGB(grgb, i, m_lineCount);
					color = PALETTEINDEX(index);
					m_pDC->SetPixelV((int )i, (int )m_lineCount, color);
            		if (pix == m_transparentIndex)
            			m_maskDC->SetPixelV((int )i, (int )m_lineCount, RGB(255, 255, 255));
            		else
            			m_maskDC->SetPixelV((int )i, (int )m_lineCount, RGB(0,0,0));
					}
				}
			else
				{
				for (i = 0; i < linelen; i++)
					{
					pix = pixels[i];
					grgb = &(m_currentColorTable[pix]);
					index = DitherRGB(grgb, i, m_lineCount);
					color = RGB(bublp->palPalEntry[index].peRed, bublp->palPalEntry[index].peGreen, bublp->palPalEntry[index].peBlue);
					m_pDC->SetPixelV((int )i, (int )m_lineCount, color);
            		if (pix == m_transparentIndex)
            			m_maskDC->SetPixelV((int )i, (int )m_lineCount, RGB(255, 255, 255));
            		else
            			m_maskDC->SetPixelV((int )i, (int )m_lineCount, RGB(0,0,0));
            		}
            	}
			}
		else
			{
			for (i = 0; i < linelen; i++)
				{
				pix = pixels[i];
				grgb = &(m_currentColorTable[pix]);
				color = RGB(grgb->r, grgb->g, grgb->b);
				m_pDC->SetPixelV((int )i, (int )m_lineCount, color);
            	if (pix == m_transparentIndex)
            		m_maskDC->SetPixelV((int )i, (int )m_lineCount, RGB(255, 255, 255));
            	else
            		m_maskDC->SetPixelV((int )i, (int )m_lineCount, RGB(0,0,0));
				}
			}
		}
	else
		{
		if (m_dither)
			{
			if (m_bitsPerPixel == 8)
				{
				for (i = 0; i < linelen; i++)
					{
					pix = pixels[i];
					grgb = &(m_currentColorTable[pix]);
					index = DitherRGB(grgb, i, m_lineCount);
					color = PALETTEINDEX(index);
					m_pDC->SetPixelV((int )i, (int )m_lineCount, color);
					}
				}
			else
				{
				for (i = 0; i < linelen; i++)
					{
					pix = pixels[i];
					grgb = &(m_currentColorTable[pix]);
					index = DitherRGB(grgb, i, m_lineCount);
					color = RGB(bublp->palPalEntry[index].peRed, bublp->palPalEntry[index].peGreen, bublp->palPalEntry[index].peBlue);
					m_pDC->SetPixelV((int )i, (int )m_lineCount, color);
					}
				}
			}
		else
			{
			for (i = 0; i < linelen; i++)
				{
				pix = pixels[i];
				grgb = &(m_currentColorTable[pix]);
				color = RGB(grgb->r, grgb->g, grgb->b);
				m_pDC->SetPixelV((int )i, (int )m_lineCount, color);
				}
			}
		}
    if (m_interlaced)
    	{
    	if ((m_pass == 0) || (m_pass == 1))
    		{
    		m_lineCount += 8;
    		if (m_lineCount >= (m_top + m_height))
    			{
    			m_pass += 1;
    			if (m_pass == 1)
    				m_lineCount = m_top + 4;
    			else if (m_pass == 2)
    				m_lineCount = m_top + 2;
    			}
    		}
    	else if (m_pass == 2)
    		{
    		m_lineCount += 4;
    		if (m_lineCount >= (m_top + m_height))
    			{
    			m_pass += 1;
    			m_lineCount = m_top + 1;
    			}
    		}
    	else /* m_pass == 3 */
    		{
    		m_lineCount += 2;
    		}
    	}
    else	
		m_lineCount += 1;
	return TRUE;
	}
     
BOOL CGifReader::OutputLine(U8 *pixels, U32 linelen)
	{
	if (m_dither && m_errorDiffuse )
		{
        if (m_interlaced)
			return OutputLineDefered(pixels, linelen);
		else
        	return OutputLineE(pixels, linelen);
        }	
    else
    	return OutputLineD(pixels, linelen);
	}

const S32 codeMask[13] = {
     0,
     0x0001, 0x0003,
     0x0007, 0x000F,
     0x001F, 0x003F,
     0x007F, 0x00FF,
     0x01FF, 0x03FF,
     0x07FF, 0x0FFF
     };

BOOL CGifReader::GetBlockByte(P_U8 b)
	{
	U8 c;
	U32 i;
    if (m_availableBytes == 0)
         {

         /* Out of bytes in current block, so read next block
          */
         m_pBytes = m_byteBuff;
		 if(!FileGetC(m_file, &c))
			return FALSE;
		 if (c == 0)
			return FALSE;
		 m_availableBytes = c;
         for (i = 0; i < m_availableBytes; ++i)
            {
            if (!FileGetC(m_file, &c))
               return FALSE;
            m_byteBuff[i] = c;
            }
         m_currentByte = *m_pBytes++;
         --m_availableBytes;
		 }
    else
		{
         m_currentByte = *m_pBytes++;
         --m_availableBytes;
		}
	*b = m_currentByte;
	return TRUE;
	}


/* This function initializes the decoder for reading a new image.
 */
S16 CGifReader::InitDecoder(S16 size)
   {
   m_currentSize = size + 1;
   m_topSlot = 1 << m_currentSize;
   m_clear = 1 << size;
   m_ending = m_clear + 1;
   m_slot = m_newCodes = m_ending + 1;
   m_availableBits = 0;
   m_availableBytes = 0;
   m_lineCount = 0;
   m_pass = 0;
   return(0);
   }

/* get_next_code()
 * - gets the next code from the GIF file.  Returns the code, or else
 * a negative number in case of file errors...
 */
BOOL CGifReader::GetNextCode(P_U32 code)
   {
   U32 ret;

   if (m_availableBits == 0)
      { 
      if (!GetBlockByte(&m_currentByte))
		 return FALSE;
      m_availableBits = 8;
      }

   ret = m_currentByte >> (8 - m_availableBits);
   while (m_currentSize > m_availableBits)
      {
	  if (!GetBlockByte(&m_currentByte))
		return FALSE;
      ret |= m_currentByte << m_availableBits;
      m_availableBits += 8;
      }
   m_availableBits -= m_currentSize;
   ret &= codeMask[m_currentSize];
   *code = ret;
   return TRUE;
   }


/* The reason we have these seperated like this instead of using
 * a structure like the original Wilhite code did, is because this
 * stuff generally produces significantly faster code when compiled...
 * This code is full of similar speedups...  (For a good book on writing
 * C for speed or for space optomisation, see Efficient C by Tom Plum,
 * published by Plum-Hall Associates...)
 */
//U8 m_stack[MAX_CODES + 1];            /* Stack for storing pixels */
//U8 m_suffix[MAX_CODES + 1];           /* Suffix table */
//U16 m_prefix[MAX_CODES + 1];           /* Prefix linked list */

/* S16 decoder(linewidth)
 *    S16 linewidth;               * Pixels per line of image *
 *
 * - This function decodes an LZW image, according to the method used
 * in the GIF spec.  Every *linewidth* "characters" (ie. pixels) decoded
 * will generate a call to OutLine(), which is a user specific function
 * to display a line of pixels.  The function gets it's codes from
 * get_next_code() which is responsible for reading blocks of data and
 * seperating them into the proper size codes.  Finally, get_byte() is
 * the global routine to read the next byte from the GIF file.
 *
 * It is generally a good idea to have linewidth correspond to the actual
 * width of a line (as specified in the Image header) to make your own
 * code a bit simpler, but it isn't absolutely necessary.
 *
 * Returns: 0 if successful, else negative.  (See ERRS.H)
 *
 */

BOOL CGifReader::Decode(U32 linewidth)
   {
   U8 *sp;
   U8 *bufptr;
   U8 *buf;
   U32 fc, oc;
   U32 c, code, bufcnt;
   U8 size, b;

   /* Initialize for decoding a new image... */
   if (!FileGetC( m_file, &b))
	  return FALSE;
   size = b;
   if (size < 2 || 9 < size)
      return FALSE;

   InitDecoder(size);

   /* Initialize in case they forgot to put in a clear code.
    * (This shouldn't happen, but we'll try and decode it anyway...)
    */
   oc = fc = 0;

   /* Allocate space for the decode buffer
    */
   buf = (U8 *)malloc(linewidth + 1);
   if (buf == NULL)
      return FALSE;

   /* Set up the stack pointer and decode buffer pointer
    */
   sp = m_stack;
   bufptr = buf;
   bufcnt = linewidth;

   /* This is the main loop.  For each code we get we pass through the
    * linked list of prefix codes, pushing the corresponding "character" for
    * each code onto the stack.  When the list reaches a single "character"
    * we push that on the stack too, and then start unstacking each
    * character for output in the correct order.  Special handling is
    * included for the clear code, and the whole thing ends when we get
    * an ending code.
    */
   while ((GetNextCode(&c)) && (c != m_ending))
      {


      /* If the code is a clear code, reinitialize all necessary items.
       */
      if (c == m_clear)
         {
         m_currentSize = size + 1;
         m_slot = m_newCodes;
         m_topSlot = 1 << m_currentSize;

         /* Continue reading codes until we get a non-clear code
          * (Another unlikely, but possible case...)
          */
         while ((GetNextCode(&c)) && (c == m_clear))
            ;

         /* If we get an ending code immediately after a clear code
          * (Yet another unlikely case), then break out of the loop.
          */
         if (c == m_ending)
            break;

         /* Finally, if the code is beyond the range of already set codes,
          * (This one had better NOT happen...  I have no idea what will
          * result from this, but I doubt it will look good...) then set it
          * to color zero.
          */
         if (c >= m_slot)
            c = 0;

         oc = fc = c;

         /* And let us not forget to put the char into the buffer... And
          * if, on the off chance, we were exactly one pixel from the end
          * of the line, we have to send the buffer to the OutLine()
          * routine...
          */
         *bufptr++ = (U8 )c;
         if (--bufcnt == 0)
            {
            if (!OutputLine(buf, linewidth))
            	{
            	free(buf);
            	return FALSE;
            	}
            bufptr = buf;
            bufcnt = linewidth;
            }
         }
      else
         {

         /* In this case, it's not a clear code or an ending code, so
          * it must be a code code...  So we can now decode the code into
          * a stack of character codes. (Clear as mud, right?)
          */
         code = c;

         /* Here we go again with one of those off chances...  If, on the
          * off chance, the code we got is beyond the range of those already
          * set up (Another thing which had better NOT happen...) we trick
          * the decoder into thinking it actually got the last code read.
          * (Hmmn... I'm not sure why this works...  But it does...)
          */
         if (code >= m_slot)
            {
            if (code > m_slot)
               ++m_badCodeCount;
            code = oc;
            *sp++ = (U8 )fc;
            }

         /* Here we scan back along the linked list of prefixes, pushing
          * helpless characters (ie. suffixes) onto the stack as we do so.
          */
         while (code >= m_newCodes)
            {
            *sp++ = m_suffix[code];
            code = m_prefix[code];
            }

         /* Push the last character on the stack, and set up the new
          * prefix and suffix, and if the required slot number is greater
          * than that allowed by the current bit size, increase the bit
          * size.  (NOTE - If we are all full, we *don't* save the new
          * suffix and prefix...  I'm not certain if this is correct...
          * it might be more proper to overwrite the last code...
          */
         *sp++ = (U8 )code;
         if (m_slot < m_topSlot)
            {
            fc = code;
            m_suffix[m_slot] = (U8 )fc;
            m_prefix[m_slot++] = (U16 )oc;
            oc = c;
            }
         if (m_slot >= m_topSlot)
            if (m_currentSize < 12)
               {
               m_topSlot <<= 1;
               ++m_currentSize;
               } 

         /* Now that we've pushed the decoded string (in reverse order)
          * onto the stack, lets pop it off and put it into our decode
          * buffer...  And when the decode buffer is full, write another
          * line...
          */
         while (sp > m_stack)
            {
            *bufptr++ = *(--sp);
            if (--bufcnt == 0)
               {
            	if (!OutputLine(buf, linewidth))
            		{
            		free(buf);
            		return FALSE;
            		}
               bufptr = buf;
               bufcnt = linewidth;
               }
            }
         }
      }
   if (bufcnt != linewidth)
		if (!OutputLine(buf, (linewidth - bufcnt)))
            {
            free(buf);
            return FALSE;
            }
   free(buf);
   if (!FileGetC( m_file, &b))
	  return FALSE;
   //printf( "should be zero %d\n", (int )b );
   return TRUE;
   }

BOOL CGifReader::GetGifSize(istream *istrm, P_FCOORD size, BOOL *transparency)
	{
	P_GIFENTITY gif;
	P_GIFIMAGE image;
	U8 code, ext;

	if (!(gif = new GIFENTITY))
		return FALSE;
	
	*transparency = FALSE;
    
   	if (!(m_file = OpenFile(istrm)))
    	{
    	delete gif;
    	return FALSE;
    	}

	if (!ReadHeader( m_file, &(gif->header) ))
    	{
    	delete gif;
		CloseFile( m_file );
    	return FALSE;
    	}
	if (!ReadLogicalScreenDescriptor( m_file, &(gif->screen) ))
    	{
    	delete gif;
		CloseFile( m_file );
    	return FALSE;
    	}
	while (FileGetC(m_file, &code))
		{
		if (code == 0x2C)
			{
			break;
			}
		else if (code == 0x21)
			{
			/* need to read the extension */
			if (!FileGetC(m_file, &ext))
				break;
			if (ext == 0xF9)
				{
				/* read graphic control extension */
				// printf("graphic control ext \n");
				image = new GIFIMAGE;
				image->entity = gif;
                if(!ReadGraphicControlExtension( m_file, &(image->gext) ))
                	{
					delete image;
					if (gif->screen.hasGlobalColorTable)
						delete [] gif->screen.globalColorTable;
    				delete gif;
					CloseFile( m_file );
    				return FALSE;
                	}
                
                *transparency = image->gext.hasTransparency;
                delete image;
                break;
                // this is what we are looking for... the "transparency" flag
				}
			else if (ext == 0xFE)
				{
				/* read the comment extension */
				//printf("comment ext \n");
				TrashCommentExtension( m_file );
				}
			else if (ext == 0x01)
				{
				/* read the plain text extension */
				//printf("plain text ext \n");
				TrashPlainTextExtension( m_file );
				}
			else if (ext == 0xFF)
				{
				/* read the application extension */
				//printf("application ext \n");
				TrashApplicationExtension( m_file );
				}
			else
				break;
			}
		else 
			{
			break;
			}
		
		}

	CloseFile( m_file );
	size->x = (F32 )gif->screen.width;
	size->y = (F32 )gif->screen.height;
	if (gif->screen.hasGlobalColorTable)
		delete [] gif->screen.globalColorTable;
	delete gif;
	return TRUE;
	}
	
BOOL CGifReader::ReadGif(istream *istrm, CDC *pDC, CDC *maskDC)
	{
	P_GIFENTITY gif;
	P_GIFIMAGE image;
	U8 code, ext;
	S32 i;
	U8 *tmp;
	U32 size;
    
	if (!(gif = new GIFENTITY))
		return FALSE;
    
    if (!(m_file = OpenFile(istrm)))
    	{
    	delete gif;
    	return FALSE;
    	}
    
    m_pDC = pDC;
    
    m_maskDC = maskDC;
    
    m_buildMask = FALSE;
    m_interlaced = FALSE;
    
 	m_bitsPerPixel = (S32 )m_pDC->GetDeviceCaps(BITSPIXEL);
   
	if(m_bitsPerPixel <= 8)
		{
    	m_pDC->SelectPalette( &bubPalette, 0 );
    	m_pDC->RealizePalette();
	    m_dither = TRUE;
	    m_errorDiffuse = FALSE;  // could go either way :-)
	    }
	else
	    m_dither = FALSE;
   
	if (!ReadHeader( m_file, &(gif->header) ))
    	{
    	delete gif;
		CloseFile( m_file );
    	return FALSE;
    	}
	// DumpHeader( &(gif->header));
	if (!ReadLogicalScreenDescriptor( m_file, &(gif->screen) ))
    	{
    	delete gif;
		CloseFile( m_file );
    	return FALSE;
    	}
	// DumpLSD( &(gif->screen));
	image = new GIFIMAGE;
	image->entity = gif;
	while (FileGetC(m_file, &code))
		{
		if (code == 0x2C)
			{
			if (ReadImageDescriptor( m_file, &(image->image) ))
				{
				// DumpID( &(image->image));
				if (image->image.hasLocalColorTable)
					m_currentColorTable = image->image.localColorTable;
				else
					m_currentColorTable = gif->screen.globalColorTable;
				m_lineCount = 0;
				m_pass = 0;
				if (m_dither && m_errorDiffuse)
					{
					m_errRow = new ERRGB[ image->image.width + 2 ];
					for (i = 0; i < (S32 )(image->image.width + 2); i++)
						m_errRow[i].r = m_errRow[i].g = m_errRow[i].b = 0;
					if (m_interlaced)
						{
						size = (U32 )image->image.width;
						size = size * (U32 )image->image.height;
						m_imageBytes = (U8 *)malloc((long )size);
						}
					}
		    	if (!Decode( image->image.width ))
					{
					if (image->image.hasLocalColorTable)
						delete [] image->image.localColorTable;
					if (m_dither && m_errorDiffuse)
						{
						delete [] m_errRow;
						if (m_interlaced)
							free( m_imageBytes );
						}
					delete image;
					if (gif->screen.hasGlobalColorTable)
						delete [] gif->screen.globalColorTable;
    				delete gif;
					CloseFile( m_file );
    				return FALSE;
					}
				if (m_dither && m_errorDiffuse)
					{
					if (m_interlaced)
						{
						m_interlaced = FALSE;
						m_lineCount = 0;
						tmp = m_imageBytes;
						for( i = 0; i < (S32 )image->image.height; i++)
							{
							OutputLineE(tmp, image->image.width);
							tmp += image->image.width;
							}
						free( m_imageBytes );
						}
					delete [] m_errRow;
					}
				if (image->image.hasLocalColorTable)
					delete [] image->image.localColorTable;
				}
			else
				{
				delete image;
				if (gif->screen.hasGlobalColorTable)
					delete [] gif->screen.globalColorTable;
    			delete gif;
				CloseFile( m_file );
    			return FALSE;
				}
			}
		else if (code == 0x21)
			{
			/* need to read the extension */
			if (!FileGetC(m_file, &ext))
				break;
			if (ext == 0xF9)
				{
				/* read graphic control extension */
				// printf("graphic control ext \n");
                if (!ReadGraphicControlExtension( m_file, &(image->gext) ))
                	{
					if (image->image.hasLocalColorTable)
						delete [] image->image.localColorTable;
					delete image;
					if (gif->screen.hasGlobalColorTable)
						delete [] gif->screen.globalColorTable;
    				delete gif;
					CloseFile( m_file );
    				return FALSE;
                	}
				}
			else if (ext == 0xFE)
				{
				/* read the comment extension */
				//printf("comment ext \n");
				TrashCommentExtension( m_file );
				}
			else if (ext == 0x01)
				{
				/* read the plain text extension */
				//printf("plain text ext \n");
				TrashPlainTextExtension( m_file );
				}
			else if (ext == 0xFF)
				{
				/* read the application extension */
				//printf("application ext \n");
				TrashApplicationExtension( m_file );
				}
			else
				break;
			}
		else if (code == 0x3B)
			{
			//printf ("clean file termination \n");
			break;   /* this is the gif file terminator */
			}
		else
			{
			//printf ("bad file end %d \n", (int )code);
			break;
			}
		
		}
	if (image)
		delete image;
	CloseFile( m_file );
	if (gif->screen.hasGlobalColorTable)
		delete [] gif->screen.globalColorTable;
	delete gif;
	return TRUE;
	}

CGifReader::CGifReader()
	{
	m_maskDC = NULL;
	m_file = NULL;
	m_currentColorTable = NULL;
	m_dither = FALSE;
	m_errorDiffuse = FALSE;
	m_buildMask = FALSE;
	m_interlaced = FALSE;
	m_left = m_top = m_width = m_height = 0;
	m_lineCount = 0;
	m_pass = 0;
	m_bitsPerPixel = 0;
	m_badCodeCount = 0;
	m_currentSize = 0;
	m_clear = 0;
	m_ending = 0;
	m_newCodes = 0;
	m_topSlot = 0;
	m_slot = 0;
    m_availableBytes = 0;
    m_availableBits = 0;
    m_currentByte = 0;
	m_pBytes = NULL;
	m_transparentIndex = 0;
	m_errRow = NULL;
	m_imageBytes = NULL;
	m_pDC = NULL;
	}
	
CGifReader::~CGifReader()
	{
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\mime_tab.cpp ===
//#ifndef __MWERKS__
#include "stdafx.h"
//#endif
#ifndef lint
static char yysccsid[] = "@(#)yaccpar	1.10 (Berkeley) 09/07/95 swb";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 10
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#ifdef __cplusplus
#define CFUNCTIONS 		extern "C" {
#define END_CFUNCTIONS	}
#else
#define CFUNCTIONS
#define END_CFUNCTIONS
#endif
#define yyparse mime_parse
#define yylex mime_lex
#define yyerror mime_error
#define yychar mime_char
#define p_yyval p_mime_val
#undef yyval
#define yyval (*p_mime_val)
#define p_yylval p_mime_lval
#undef yylval
#define yylval (*p_mime_lval)
#define yydebug mime_debug
#define yynerrs mime_nerrs
#define yyerrflag mime_errflag
#define yyss mime_ss
#define yyssp mime_ssp
#define yyvs mime_vs
#define yyvsp mime_vsp
#define yylhs mime_lhs
#define yylen mime_len
#define yydefred mime_defred
#define yydgoto mime_dgoto
#define yysindex mime_sindex
#define yyrindex mime_rindex
#define yygindex mime_gindex
#define yytable mime_table
#define yycheck mime_check
#define yyname mime_name
#define yyrule mime_rule
#define YYPREFIX "mime_"
#line 2 "mime.y"

/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

/*
To invoke this parser, see the "Public Interface" section below.

This MS/V parser accepts input such as the following:
	[vCard
	O=AT&T/Versit;
	FN=Roland H. Alden
	TITLE=Consultant (Versit Project Office)
	N=Alden;Roland
	A:DOM,POSTAL,PARCEL,HOME,WORK=Suite 2208;One Pine Street;San Francisco;CA;94111;U.S.A.
	A.FADR:DOM,POSTAL,PARCEL,HOME,WORK=Roland H. Alden\
	Suite 2208\
	One Pine Street\
	San Francisco, CA 94111
	A.FADR:POSTAL,PARCEL,HOME,WORK=Roland H. Alden\
	Suite 2208\
	One Pine Street\
	San Francisco, CA 94111\
	U.S.A.
	B.T:HOME,WORK,PREF,MSG=+1 (415) 296-9106
	C.T:WORK,FAX=+1 (415) 296-9016
	D.T:MSG,CELL=+1 (415) 608-5981
	E.EMAIL:WORK,PREF,INTERNET=sf!rincon!ralden@alden.attmail.com
	F.EMAIL:INTERNET=ralden@sfgate.com
	G.EMAIL:HOME,MCIMail=242-2200
	PN=ROW-LAND ALL-DEN
	PN:WAV,BASE64=<bindata>
		UklGRtQ4AABXQVZFZm10IBAAAAABAAEAESsAABErAAABAAgAZGF0Ya84AACAgoSD
		...
		e319fYCAg4WEhIAA
	</bindata>
	]

For the purposes of the following grammar, a LINESEP token indicates either
a \r char (0x0D), a \n char (0x0A), or a combination of one of each,
in either order (\r\n or \n\r).  This is a bit more lenient than the spec.
*/


#ifdef _WIN32
#include <wchar.h>
#else
#include "wchar.h"
#endif
#include <string.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include "clist.h"
#include "vcard.h"
#include "mime.h"

#if defined(_WIN32) || defined(__MWERKS__)
#define HNEW(_t, _n) new _t[_n]
#define HFREE(_h) delete [] _h
#else
#define HNEW(_t, _n) (_t __huge *)_halloc(_n, 1)
/*#define HNEW(_t, _n) (_t __huge *)_halloc(_n, 1); {char buf[40]; sprintf(buf, "_halloc(%ld)\n", _n); Parse_Debug(buf);}*/
#define HFREE(_h) _hfree(_h)
#endif


/****  Types, Constants  ****/

#define YYDEBUG			1		/* 1 to compile in some debugging code */
#define MAXTOKEN		256		/* maximum token (line) length */
#define MAXFLAGS		((MAXTOKEN / 2) / sizeof(char *))
#define YYSTACKSIZE 	50
#define MAXASSOCKEY		24
#define MAXASSOCVALUE	64
#define MAXCARD			2		/* max # of nested cards parseable */
								/* (includes outermost) */
typedef enum {none, sevenbit, qp, base64} MIME_ENCODING;

typedef struct {
	const char* known[MAXFLAGS];
	char extended[MAXTOKEN / 2];
} PARAMS_STRUCT;

typedef struct {
	char key[MAXASSOCKEY];
	char value[MAXASSOCVALUE];
} AssocEntry;	/* a simple key/value association, impl'd using CList */

/* some fake property names that represent special cases */
static const char* mime_fam_given		= "family;given";
static const char* mime_orgname_orgunit	= "org_name;org_unit";
static const char* mime_address			= "six part address";

static const char* propNames[] = {
	vcLogoProp,
	vcPhotoProp,
	vcDeliveryLabelProp,
	vcFullNameProp,
	vcTitleProp,
	vcPronunciationProp,
	vcLanguageProp,
	vcTelephoneProp,
	vcEmailAddressProp,
	vcTimeZoneProp,
	vcLocationProp,
	vcCommentProp,
	vcURLProp,
	vcCharSetProp,
	vcLastRevisedProp,
	vcUniqueStringProp,
	vcPublicKeyProp,
	vcMailerProp,
	vcAgentProp,
	vcBirthDateProp,
	vcBusinessRoleProp,
	NULL
};

static const char *mime_addrProps[] = {
	vcPostalBoxProp,
	vcExtAddressProp,
	vcStreetAddressProp,
	vcCityProp,
	vcRegionProp,
	vcPostalCodeProp,
	vcCountryNameProp,
	NULL
};

static const char *mime_nameProps[] = {
	vcFamilyNameProp,
	vcGivenNameProp,
	vcAdditionalNamesProp,
	vcNamePrefixesProp,
	vcNameSuffixesProp,
	NULL
};

static const char *mime_orgProps[] = {
	vcOrgNameProp,
	vcOrgUnitProp,
	vcOrgUnit2Prop,
	vcOrgUnit3Prop,
	vcOrgUnit4Prop,
	NULL
};


/****  Global Variables  ****/

int mime_lineNum, mime_numErrors; /* yyerror() can use these */

static S32 curPos, inputLen;
static int pendingToken;
static const char *inputString;
static CFile* inputFile;
static BOOL paramExp, inBinary, semiSpecial;
static MIME_ENCODING expected;
static char __huge *longString;
static S32 longStringLen, longStringMax;
static CList* global_vcList;

static CVCard *cardBuilt;
static CVCard* cardToBuild[MAXCARD];
static int curCard;
static CVCNode *bodyToBuild;


/****  External Functions  ****/

CFUNCTIONS

extern void Parse_Debug(const char *s);
extern void yyerror(char *s);

END_CFUNCTIONS


/****  Private Forward Declarations  ****/

CFUNCTIONS

/* A helpful utility for the rest of the app. */
extern CVCNode* FindOrCreatePart(CVCNode *node, const char *name);

static const char* StrToProp(const char* str);
static int StrToParam(const char *s, PARAMS_STRUCT *params);
static void StrCat(char *dst, const char *src1, const char *src2);
static void ExpectValue(PARAMS_STRUCT* params);
static BOOL Parse_Assoc(
	const char *groups, const char *prop, PARAMS_STRUCT *params,
	char *value);
static BOOL Parse_Agent(
	const char *groups, const char *prop, PARAMS_STRUCT *params,
	CVCard *agentCard);
int yyparse();
static U8 __huge * DataFromBase64(
	const char __huge *str, S32 strLen, S32 *len);
static BOOL PushVCard();
static CVCard* PopVCard();
static int flagslen(const char **params);
static BOOL FlagsHave(PARAMS_STRUCT *params, const char *propName);
static void AddBoolProps(CVCNode *node, PARAMS_STRUCT *params);

END_CFUNCTIONS

#line 249 "mime.y"
typedef union
{
	char str[MAXTOKEN];
	PARAMS_STRUCT params;
	CVCard *vCard;
} YYSTYPE;
#line 299 "mime_tab.cpp"
#define EQ 257
#define COLON 258
#define DOT 259
#define SEMI 260
#define SPACE 261
#define HTAB 262
#define LINESEP 263
#define NEWLINE 264
#define VCARD 265
#define TERM 266
#define BEGIN 267
#define END 268
#define TYPE 269
#define VALUE 270
#define ENCODING 271
#define WORD 272
#define XWORD 273
#define STRING 274
#define QP 275
#define B64 276
#define PROP 277
#define PROP_AGENT 278
#define LANGUAGE 279
#define CHARSET 280
#define INLINE 281
#define URL 282
#define CONTENTID 283
#define SEVENBIT 284
#define QUOTEDP 285
#define BASE64 286
#define DOM 287
#define INTL 288
#define POSTAL 289
#define PARCEL 290
#define HOME 291
#define WORK 292
#define PREF 293
#define VOICE 294
#define FAX 295
#define MSG 296
#define CELL 297
#define PAGER 298
#define BBS 299
#define MODEM 300
#define CAR 301
#define ISDN 302
#define VIDEO 303
#define AOL 304
#define APPLELINK 305
#define ATTMAIL 306
#define CIS 307
#define EWORLD 308
#define INTERNET 309
#define IBMMAIL 310
#define MSN 311
#define MCIMAIL 312
#define POWERSHARE 313
#define PRODIGY 314
#define TLX 315
#define X400 316
#define GIF 317
#define CGM 318
#define WMF 319
#define BMP 320
#define MET 321
#define PMB 322
#define DIB 323
#define PICT 324
#define TIFF 325
#define ACROBAT 326
#define PS 327
#define JPEG 328
#define QTIME 329
#define MPEG 330
#define MPEG2 331
#define AVI 332
#define WAVE 333
#define AIFF 334
#define PCM 335
#define X509 336
#define PGP 337
#define YYERRCODE 256
short mime_lhs[] = {                                        -1,
   18,   18,   18,   19,   19,   20,   20,   20,   20,   20,
   20,   20,    0,    0,    0,    0,   21,   23,   26,   17,
   24,   24,   28,   27,   29,   27,   27,   27,   27,   27,
    9,   10,   10,   11,   11,   11,   11,   11,   11,   11,
   11,   11,   11,   12,   12,   13,   13,   14,   14,   15,
   15,   16,   16,   16,   16,    8,    8,    8,    8,    8,
    8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
    8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
    8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
    8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
    8,    8,    8,    8,    8,    8,    2,    2,    2,    2,
    1,    1,    1,    3,    3,    4,    4,    7,    7,   30,
   30,   30,   30,   32,   32,   22,   22,   25,   25,    5,
    5,    5,    5,    6,    6,   31,
};
short mime_len[] = {                                         2,
    3,    2,    1,    2,    1,    2,    2,    2,    2,    2,
    1,    1,    3,    2,    2,    1,    0,    0,    0,   17,
    3,    1,    0,    6,    0,    6,    7,    7,    2,    2,
    4,    5,    1,    5,    1,    1,    1,    1,    1,    1,
    5,    5,    5,    5,    1,    5,    1,    5,    1,    5,
    1,    5,    5,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    4,    3,    1,    2,
    2,    2,    1,    4,    3,    3,    1,    1,    1,    2,
    2,    1,    1,    2,    1,    1,    1,    1,    1,    2,
    3,    1,    1,    3,    1,    0,
};
short mime_defred[] = {                                      0,
    0,   11,   12,    0,    0,    3,    0,    0,    5,   10,
    9,    0,    6,    7,    8,    2,    0,    0,    4,   17,
    1,    0,    0,  118,    0,  119,   18,    0,  125,    0,
  127,    0,    0,  122,  123,  135,    0,    0,    0,   22,
    0,  133,  124,   30,    0,    0,    0,    0,    0,    0,
    0,  120,  121,   29,    0,    0,    0,  129,    0,    0,
  134,   21,   19,    0,   23,   25,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   51,   54,
   55,   45,   47,   49,   56,   57,   58,   59,   60,   61,
   62,   63,   64,   65,   66,   67,   68,   69,   70,   71,
   72,   73,   74,   75,   76,   77,   78,   79,   80,   81,
   82,   83,   84,   85,   86,   87,   88,   89,   90,   91,
   92,   93,   94,   95,   96,   97,   98,   99,  100,  101,
  102,  103,  104,  105,  106,   35,    0,   33,   36,   37,
   38,   39,   40,    0,    0,    0,    0,    0,    0,  109,
  117,   24,    0,  113,    0,   26,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  110,    0,  111,
    0,  112,    0,    0,    0,    0,    0,    0,    0,    0,
   27,   28,    0,    0,    0,  115,  116,    0,    0,    0,
    0,    0,    0,    0,    0,  114,  107,   34,   50,   52,
   53,   44,   46,   48,   43,   42,   41,   32,   20,
};
short mime_dgoto[] = {                                       5,
  152,  153,  154,  155,   37,   38,   25,  136,   56,  137,
  138,  139,  140,  141,  142,  143,    6,    7,    8,    9,
   23,   30,   28,   39,   49,   70,   40,   71,   72,   50,
   58,   32,
};
short mime_sindex[] = {                                   -178,
 -250,    0,    0, -168,    0,    0, -178, -178,    0,    0,
    0, -242,    0,    0,    0,    0, -178, -178,    0,    0,
    0, -178, -234,    0, -213,    0,    0, -196,    0, -208,
    0, -184, -160,    0,    0,    0, -206, -145, -161,    0,
 -179,    0,    0,    0, -143, -143, -165, -208, -139, -141,
    0,    0,    0,    0, -129, -120, -251,    0, -119, -173,
    0,    0,    0, -165,    0,    0, -126, -143, -143, -143,
 -201, -201, -143, -143, -143, -143, -143, -143,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0, -143,    0,    0,    0,
    0,    0,    0, -127, -127, -112, -115, -125, -114,    0,
    0,    0, -214,    0, -113,    0,  -45,  -44,  -42,  -41,
  -40,  -39,  -46,  -38,  -37,  -36, -143,    0,  -35,    0,
  -34,    0, -252, -143, -143, -143, -143, -143, -143, -143,
    0,    0,  -33, -198,  -56,    0,    0,  131, -177, -176,
  -51,  -50,  -49, -126, -143,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,
};
short mime_rindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,  224,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  225,  230,    0,    0,
    0,  231,  -30,    0,    0,    0,    0, -220,    0, -186,
    0, -217,    0,    0,    0,    0,    0,    0, -209,    0,
 -155,    0,    0,    0, -163, -163, -152, -186,    0,    1,
 -256,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0, -150,    0,    0,    0,  -32,  -32,  -24,
    0,    0,  -21,  -21,  -21,  -21,  -21,  -21,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0, -163,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  -19,    0,    0,    0,  -28,    0,    0,    0,
    0,    0,    0,  182, -170, -169,  -31,  -31,  -31,   80,
    0,    0,    0,    0, -187,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   81,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,
};
short mime_gindex[] = {                                      0,
  166,    0,    0,   92,    0,  201,    0,   55,  198,    0,
   51,    0,    0,    0,    0,    0,   -3,  238,   59,   29,
    0,  208,    0,    0,  -43,    0,  200,    0,    0,  -20,
  -10,    0,
};
#define YYTABLESIZE 519
short mime_table[] = {                                     127,
  128,   57,   60,   16,  127,  127,   66,   10,   67,   41,
  186,  129,   26,   21,   16,  127,   11,   31,   21,   42,
  127,  127,   20,  187,  144,  145,  146,   41,   51,  157,
  158,  159,  160,  161,  162,  136,   19,   42,  126,   24,
  136,  136,  171,  126,  126,   19,  136,   33,  172,   27,
   19,  136,   34,   35,  126,  147,  136,  136,  136,  126,
  126,  148,  136,   36,  196,   17,   29,  136,  136,  108,
   45,   46,  149,  150,  151,  108,   22,  187,   43,    1,
  136,   52,   53,   54,   69,    2,   67,    3,    4,   12,
  136,  136,   36,  163,  136,   13,  136,   14,   15,   34,
   35,   29,   44,  199,  200,  201,   61,  202,  203,  204,
  136,  136,  136,   47,  136,  136,  136,   34,   35,   52,
   53,  132,  132,  183,  130,  130,  131,  131,   63,   64,
  188,  189,  190,  191,  192,  193,  194,   65,   68,  164,
  165,  166,   73,   74,   75,  167,   76,  168,  170,  173,
  151,  209,   77,   78,   79,   80,   81,   82,   83,   84,
   85,   86,   87,   88,   89,   90,   91,   92,   93,   94,
   95,   96,   97,   98,   99,  100,  101,  102,  103,  104,
  105,  106,  107,  108,  109,  110,  111,  112,  113,  114,
  115,  116,  117,  118,  119,  120,  121,  122,  123,  124,
  125,  126,  127,  128,  129,  130,  131,  132,  133,  134,
  135,  174,  175,  180,  176,  177,  178,  179,  197,   12,
  205,  206,  207,   16,   15,  181,  182,  184,  185,   14,
   13,  195,  136,  136,  136,  136,  136,  156,   31,  169,
  136,   55,  198,   59,  208,   18,   48,   62,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  128,  128,    0,
  128,    0,    0,  128,  128,  128,  128,  128,  128,  128,
  128,  128,  128,  128,    0,    0,    0,    0,    0,  128,
  128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
  128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
  128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
  128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
  128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
  128,  128,  128,  128,  128,  128,  128,  128,  136,    0,
    0,    0,    0,  136,  136,    0,  136,  136,  136,  136,
  136,    0,  136,    0,    0,    0,    0,    0,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,  136,   85,   86,   87,
   88,   89,   90,   91,   92,   93,   94,   95,   96,   97,
   98,   99,  100,  101,  102,  103,  104,  105,  106,  107,
  108,  109,  110,  111,  112,  113,  114,  115,  116,  117,
  118,  119,  120,  121,  122,  123,  124,  125,  126,  127,
  128,  129,  130,  131,  132,  133,  134,  135,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,
};
short mime_check[] = {                                     256,
    0,   45,   46,    7,  261,  262,  258,  258,  260,   30,
  263,  268,   23,   17,   18,  272,  267,   28,   22,   30,
  277,  278,  265,  276,   68,   69,   70,   48,   39,   73,
   74,   75,   76,   77,   78,  256,    8,   48,  256,  274,
  261,  262,  257,  261,  262,   17,  256,  256,  263,  263,
   22,  272,  261,  262,  272,  257,  277,  278,  268,  277,
  278,  263,  272,  272,  263,    7,  263,  277,  278,  257,
  277,  278,  274,  275,  276,  263,   18,  276,  263,  258,
    0,  261,  262,  263,  258,  264,  260,  266,  267,  258,
  277,  278,  272,  137,  258,  264,  260,  266,  267,  261,
  262,  263,  263,  281,  282,  283,  272,  284,  285,  286,
  281,  282,  283,  259,  284,  285,  286,  261,  262,  261,
  262,  277,  278,  167,  277,  278,  277,  278,  268,  259,
  174,  175,  176,  177,  178,  179,  180,  258,  258,  267,
  144,  145,  269,  270,  271,  258,  273,  263,  263,  263,
  276,  195,  279,  280,  281,  282,  283,  284,  285,  286,
  287,  288,  289,  290,  291,  292,  293,  294,  295,  296,
  297,  298,  299,  300,  301,  302,  303,  304,  305,  306,
  307,  308,  309,  310,  311,  312,  313,  314,  315,  316,
  317,  318,  319,  320,  321,  322,  323,  324,  325,  326,
  327,  328,  329,  330,  331,  332,  333,  334,  335,  336,
  337,  257,  257,  260,  257,  257,  257,  257,  275,  258,
  272,  272,  272,    0,    0,  263,  263,  263,  263,    0,
    0,  265,  263,  258,  267,  257,  265,   72,  258,  148,
  272,   41,  188,   46,  194,    8,   39,   48,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,  258,   -1,
  260,   -1,   -1,  263,  264,  265,  266,  267,  268,  269,
  270,  271,  272,  273,   -1,   -1,   -1,   -1,   -1,  279,
  280,  281,  282,  283,  284,  285,  286,  287,  288,  289,
  290,  291,  292,  293,  294,  295,  296,  297,  298,  299,
  300,  301,  302,  303,  304,  305,  306,  307,  308,  309,
  310,  311,  312,  313,  314,  315,  316,  317,  318,  319,
  320,  321,  322,  323,  324,  325,  326,  327,  328,  329,
  330,  331,  332,  333,  334,  335,  336,  337,  258,   -1,
   -1,   -1,   -1,  263,  264,   -1,  266,  267,  269,  270,
  271,   -1,  273,   -1,   -1,   -1,   -1,   -1,  279,  280,
  281,  282,  283,  284,  285,  286,  287,  288,  289,  290,
  291,  292,  293,  294,  295,  296,  297,  298,  299,  300,
  301,  302,  303,  304,  305,  306,  307,  308,  309,  310,
  311,  312,  313,  314,  315,  316,  317,  318,  319,  320,
  321,  322,  323,  324,  325,  326,  327,  328,  329,  330,
  331,  332,  333,  334,  335,  336,  337,  287,  288,  289,
  290,  291,  292,  293,  294,  295,  296,  297,  298,  299,
  300,  301,  302,  303,  304,  305,  306,  307,  308,  309,
  310,  311,  312,  313,  314,  315,  316,  317,  318,  319,
  320,  321,  322,  323,  324,  325,  326,  327,  328,  329,
  330,  331,  332,  333,  334,  335,  336,  337,  287,  288,
  289,  290,  291,  292,  293,  294,  295,  296,  297,  298,
  299,  300,  301,  302,  303,  304,  305,  306,  307,  308,
  309,  310,  311,  312,  313,  314,  315,  316,  317,  318,
  319,  320,  321,  322,  323,  324,  325,  326,  327,  328,
  329,  330,  331,  332,  333,  334,  335,  336,  337,
};
#define YYFINAL 5
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 337
#if YYDEBUG
char *mime_name[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"EQ","COLON","DOT","SEMI","SPACE",
"HTAB","LINESEP","NEWLINE","VCARD","TERM","BEGIN","END","TYPE","VALUE",
"ENCODING","WORD","XWORD","STRING","QP","B64","PROP","PROP_AGENT","LANGUAGE",
"CHARSET","INLINE","URL","CONTENTID","SEVENBIT","QUOTEDP","BASE64","DOM","INTL",
"POSTAL","PARCEL","HOME","WORK","PREF","VOICE","FAX","MSG","CELL","PAGER","BBS",
"MODEM","CAR","ISDN","VIDEO","AOL","APPLELINK","ATTMAIL","CIS","EWORLD",
"INTERNET","IBMMAIL","MSN","MCIMAIL","POWERSHARE","PRODIGY","TLX","X400","GIF",
"CGM","WMF","BMP","MET","PMB","DIB","PICT","TIFF","ACROBAT","PS","JPEG","QTIME",
"MPEG","MPEG2","AVI","WAVE","AIFF","PCM","X509","PGP",
};
char *mime_rule[] = {
"$accept : mime",
"vcards : vcards junk vcard",
"vcards : vcards vcard",
"vcards : vcard",
"junk : junk atom",
"junk : atom",
"atom : BEGIN NEWLINE",
"atom : BEGIN TERM",
"atom : BEGIN BEGIN",
"atom : COLON BEGIN",
"atom : COLON COLON",
"atom : NEWLINE",
"atom : TERM",
"mime : junk vcards junk",
"mime : junk vcards",
"mime : vcards junk",
"mime : vcards",
"$$1 :",
"$$2 :",
"$$3 :",
"vcard : BEGIN COLON VCARD $$1 opt_str LINESEP $$2 opt_ls items opt_ws END $$3 opt_ws COLON opt_ws VCARD opt_ws",
"items : items opt_ls item",
"items : item",
"$$4 :",
"item : groups PROP params COLON $$4 value",
"$$5 :",
"item : groups PROP opt_ws COLON $$5 value",
"item : groups PROP_AGENT params COLON opt_ws vcard LINESEP",
"item : groups PROP_AGENT opt_ws COLON opt_ws vcard LINESEP",
"item : ws LINESEP",
"item : error LINESEP",
"params : opt_ws SEMI plist opt_ws",
"plist : plist opt_ws SEMI opt_ws param",
"plist : param",
"param : TYPE opt_ws EQ opt_ws ptypeval",
"param : ptypeval",
"param : param_7bit",
"param : param_qp",
"param : param_base64",
"param : param_inline",
"param : param_ref",
"param : CHARSET opt_ws EQ opt_ws WORD",
"param : LANGUAGE opt_ws EQ opt_ws WORD",
"param : XWORD opt_ws EQ opt_ws WORD",
"param_7bit : ENCODING opt_ws EQ opt_ws SEVENBIT",
"param_7bit : SEVENBIT",
"param_qp : ENCODING opt_ws EQ opt_ws QUOTEDP",
"param_qp : QUOTEDP",
"param_base64 : ENCODING opt_ws EQ opt_ws BASE64",
"param_base64 : BASE64",
"param_inline : VALUE opt_ws EQ opt_ws INLINE",
"param_inline : INLINE",
"param_ref : VALUE opt_ws EQ opt_ws URL",
"param_ref : VALUE opt_ws EQ opt_ws CONTENTID",
"param_ref : URL",
"param_ref : CONTENTID",
"ptypeval : DOM",
"ptypeval : INTL",
"ptypeval : POSTAL",
"ptypeval : PARCEL",
"ptypeval : HOME",
"ptypeval : WORK",
"ptypeval : PREF",
"ptypeval : VOICE",
"ptypeval : FAX",
"ptypeval : MSG",
"ptypeval : CELL",
"ptypeval : PAGER",
"ptypeval : BBS",
"ptypeval : MODEM",
"ptypeval : CAR",
"ptypeval : ISDN",
"ptypeval : VIDEO",
"ptypeval : AOL",
"ptypeval : APPLELINK",
"ptypeval : ATTMAIL",
"ptypeval : CIS",
"ptypeval : EWORLD",
"ptypeval : INTERNET",
"ptypeval : IBMMAIL",
"ptypeval : MSN",
"ptypeval : MCIMAIL",
"ptypeval : POWERSHARE",
"ptypeval : PRODIGY",
"ptypeval : TLX",
"ptypeval : X400",
"ptypeval : GIF",
"ptypeval : CGM",
"ptypeval : WMF",
"ptypeval : BMP",
"ptypeval : MET",
"ptypeval : PMB",
"ptypeval : DIB",
"ptypeval : PICT",
"ptypeval : TIFF",
"ptypeval : ACROBAT",
"ptypeval : PS",
"ptypeval : JPEG",
"ptypeval : QTIME",
"ptypeval : MPEG",
"ptypeval : MPEG2",
"ptypeval : AVI",
"ptypeval : WAVE",
"ptypeval : AIFF",
"ptypeval : PCM",
"ptypeval : X509",
"ptypeval : PGP",
"qp : qp EQ LINESEP QP",
"qp : qp EQ LINESEP",
"qp : QP",
"qp : EQ LINESEP",
"value : STRING LINESEP",
"value : qp LINESEP",
"value : base64",
"base64 : LINESEP lines LINESEP LINESEP",
"base64 : lines LINESEP LINESEP",
"lines : lines LINESEP B64",
"lines : B64",
"opt_str : STRING",
"opt_str : empty",
"ws : ws SPACE",
"ws : ws HTAB",
"ws : SPACE",
"ws : HTAB",
"ls : ls LINESEP",
"ls : LINESEP",
"opt_ls : ls",
"opt_ls : empty",
"opt_ws : ws",
"opt_ws : empty",
"groups : grouplist DOT",
"groups : ws grouplist DOT",
"groups : ws",
"groups : empty",
"grouplist : grouplist DOT WORD",
"grouplist : WORD",
"empty :",
};
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH 500
#endif
#endif
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
short *yyssp;
YYSTYPE *yyvsp;
YYSTYPE *p_yyval;
YYSTYPE *p_yylval;
short *yyss; /* YYSTACKSIZE long */
YYSTYPE *yyvs; /* YYSTACKSIZE long */
#undef yylval
#define yylval (*p_yylval)
#undef yyval
#define yyval (*p_yyval)
#define yystacksize YYSTACKSIZE
CFUNCTIONS
#line 537 "mime.y"

/***************************************************************************/
/***						The lexical analyzer						****/
/***************************************************************************/

/*/////////////////////////////////////////////////////////////////////////*/
#define IsLineBreak(_c) ((_c == '\n') || (_c == '\r'))

/*/////////////////////////////////////////////////////////////////////////*/
/* This appends onto yylval.str, unless MAXTOKEN has been exceeded.
 * In that case, yylval.str is set to 0 length, and longString is used.
 */
static void AppendCharToToken(char c, S32 *len)
{
	if (*len < MAXTOKEN - 1) {
		yylval.str[*len] = c; yylval.str[++(*len)] = 0;
	} else if (*len == MAXTOKEN - 1) { /* copy to "longString" */
		if (!longString) {
			longStringMax = MAXTOKEN * 2;
			longString = HNEW(char, longStringMax);
		}
		memcpy(longString, yylval.str, (size_t)*len + 1);
		longString[*len] = c; longString[++(*len)] = 0;
		yylval.str[0] = 0;
		longStringLen = *len;
	} else {
		if (longStringLen == longStringMax - 1) {
			char __huge *newStr = HNEW(char, longStringMax * 2);
			_hmemcpy((U8 __huge *)newStr, (U8 __huge *)longString, longStringLen + 1);
			longStringMax *= 2;
			HFREE(longString);
			longString = newStr;
		}
		longString[*len] = c; longString[++(*len)] = 0;
		longStringLen = *len;
	}
}

/*/////////////////////////////////////////////////////////////////////////*/
/* StrCat appends onto dst, ensuring that longString is used appropriately.
 * src1 may be of 0 length, in which case "longString" should be used.
 * "longString" would never be used for src2.
 */
static void StrCat(char *dst, const char *src1, const char *src2)
{
	S32 src1Len = strlen(src1);
	S32 src2Len = strlen(src2);
	S32 req;

	if (!src1Len && longString) {
		src1Len = longStringLen;
		src1 = longString;
	}
	if ((req = src1Len + src2Len + 1) > MAXTOKEN) {
		if (longString) { /* longString == src1 */
			if (longStringMax - longStringLen < src2Len) {
				/* since src2Len must be < MAXTOKEN, doubling longString
				   is guaranteed to be enough room */
				char __huge *newStr = HNEW(char, longStringMax * 2);
				_hmemcpy((U8 __huge *)newStr, (U8 __huge *)longString, longStringLen + 1);
				longStringMax *= 2;
				HFREE(longString);
				longString = newStr;
			}
			_hmemcpy((U8 __huge *)(longString + longStringLen), (U8 __huge *)src2, src2Len + 1);
			longStringLen += src2Len;
		} else { /* haven't yet used longString, so set it up */
			longStringMax = MAXTOKEN * 2;
			longString = HNEW(char, longStringMax);
			memcpy(longString, src1, (size_t)src1Len + 1);
			memcpy(longString + src1Len, src2, (size_t)src2Len + 1);
			longStringLen = src1Len + src2Len;
		}
		*dst = 0; /* indicate result is in longString */
	} else { /* both will fit in MAXTOKEN, so src1 can't be longString */
		if (dst != src1)
			strcpy(dst, src1);
		strcat(dst, src2);
	}
}

/*/////////////////////////////////////////////////////////////////////////*/
/* Set up the lexor to parse a string value. */
static void ExpectValue(PARAMS_STRUCT* params)
{
	if (FlagsHave(params, vcQuotedPrintableProp))
		expected = qp;
	else if (FlagsHave(params, vcBase64Prop))
		expected = base64;
	else
		expected = sevenbit;
	if (longString) {
		HFREE(longString); longString = NULL;
		longStringLen = 0;
	}
	paramExp = FALSE;
}

/*/////////////////////////////////////////////////////////////////////////*/
#define FlushWithPending(_t) { \
	if (len) { \
		pendingToken = _t; \
		goto Pending; \
	} else { \
		mime_lineNum += ((_t == LINESEP) || (_t == NEWLINE)); \
		return _t; \
	} \
}

static int peekn;
static char peekc[2];

/*/////////////////////////////////////////////////////////////////////////*/
static char lex_getc()
{
	if (peekn) {
		return peekc[--peekn];
	}
	if (curPos == inputLen)
		return EOF;
	else if (inputString)
		return *(inputString + curPos++);
	else {
		char result;
		return inputFile->Read(&result, 1) == 1 ? result : EOF;
	}
}

/*/////////////////////////////////////////////////////////////////////////*/
static void lex_ungetc(char c)
{
	ASSERT(peekn < 2);
	peekc[peekn++] = c;
}

/*/////////////////////////////////////////////////////////////////////////*/
/* Collect up a 7bit string value. */
static int Lex7bit()
{
	char cur;
	S32 len = 0;

	do {
		cur = lex_getc();
		switch (cur) {
			case '\r':
			case '\n': {
				char next = lex_getc();
				if (!(((next == '\r') || (next == '\n')) && (cur != next)))
					lex_ungetc(next);
				pendingToken = LINESEP;
				goto EndString;
			}
			case (char)EOF:
				pendingToken = EOF;
				break;
			default:
				AppendCharToToken(cur, &len);
				break;
		} /* switch */
	} while (cur != (char)EOF);

EndString:
	if (!len) {
		/* must have hit something immediately, in which case pendingToken
		   is set.  return it. */
		int result = pendingToken;
		pendingToken = 0;
		mime_lineNum += ((result == LINESEP) || (result == NEWLINE));
		return result;
	}

	return STRING;
} /* Lex7bit */

/*/////////////////////////////////////////////////////////////////////////*/
/* Collect up a quoted-printable string value. */
static int LexQuotedPrintable()
{
	char cur;
	S32 len = 0;

	do {
		cur = lex_getc();
		switch (cur) {
			case '=': {
				char c = 0;
				char next[2];
				int i;
				for (i = 0; i < 2; i++) {
					next[i] = lex_getc();
					if (next[i] >= '0' && next[i] <= '9')
						c = c * 16 + next[i] - '0';
					else if (next[i] >= 'A' && next[i] <= 'F')
						c = c * 16 + next[i] - 'A' + 10;
					else
						break;
				}
				if (i == 0) {
					if (next[i] == '\r') {
						next[1] = lex_getc();
						if (next[1] == '\n') {
							lex_ungetc(next[1]); /* so that we'll pick up the LINESEP again */
							pendingToken = EQ;
							goto EndString;
						} else {
							lex_ungetc(next[1]);
							lex_ungetc(next[0]);
							AppendCharToToken('=', &len);
						}
					} else if (next[i] == '\n') {
						lex_ungetc(next[i]); /* so that we'll pick up the LINESEP again */
						pendingToken = EQ;
						goto EndString;
					} else {
						lex_ungetc(next[i]);
						AppendCharToToken('=', &len);
					}
				} else if (i == 1) {
					lex_ungetc(next[1]);
					lex_ungetc(next[0]);
					AppendCharToToken('=', &len);
				} else
					AppendCharToToken(c, &len);

				break;
			} /* '=' */
			case '\r':
			case '\n': {
				char next = lex_getc();
				if (!(((next == '\r') || (next == '\n')) && (cur != next)))
					lex_ungetc(next);
				pendingToken = LINESEP;
				goto EndString;
			}
			case (char)EOF:
				pendingToken = EOF;
				break;
			default:
				AppendCharToToken(cur, &len);
				break;
		} /* switch */
	} while (cur != (char)EOF);

EndString:
	if (!len) {
		/* must have hit something immediately, in which case pendingToken
		   is set.  return it. */
		int result = pendingToken;
		pendingToken = 0;
		mime_lineNum += ((result == LINESEP) || (result == NEWLINE));
		return result;
	}

	return QP;
} /* LexQuotedPrintable */

/*/////////////////////////////////////////////////////////////////////////*/
/* Collect up a base64 string value. */
static int LexBase64()
{
	char cur;
	S32 len = 0;

	do {
		cur = lex_getc();
		switch (cur) {
			case '\r':
			case '\n': {
				char next = lex_getc();
				if (!(((next == '\r') || (next == '\n')) && (cur != next)))
					lex_ungetc(next);
				pendingToken = LINESEP;
				goto EndString;
			}
			case (char)EOF:
				pendingToken = EOF;
				break;
			default:
				AppendCharToToken(cur, &len);
				break;
		} /* switch */
	} while (cur != (char)EOF);

EndString:
	if (!len) {
		/* must have hit something immediately, in which case pendingToken
		   is set.  return it. */
		int result = pendingToken;
		pendingToken = 0;
		mime_lineNum += ((result == LINESEP) || (result == NEWLINE));
		return result;
	}

	return B64;
} /* LexBase64 */

/*/////////////////////////////////////////////////////////////////////////*/
/*
 * Read chars from the input.
 * Return one of the token types (or -1 for EOF).
 * Set yylval to indicate the value of the token, if any.
 */
int mime_lex();
int mime_lex()
{
	char cur;
	S32 len = 0;
	static BOOL beginning = TRUE;

	if (pendingToken) {
		int result = pendingToken;
		pendingToken = 0;
		mime_lineNum += ((result == LINESEP) || (result == NEWLINE));
		return result;
	}

	yylval.str[0] = 0;

	switch (expected) {
		case sevenbit: return Lex7bit();
		case qp: return LexQuotedPrintable();
		case base64: return LexBase64();
		default: break;
	}
	
	if (curCard == -1) {
		do {
			cur = lex_getc();
			switch (cur) {
				case ':':  FlushWithPending(COLON);
				case ' ':
				case '\t':
					if (len) goto Pending;
					break;
				case '\r':
				case '\n': {
					char next = lex_getc();
					if (!(((next == '\r') || (next == '\n')) && (cur != next)))
						lex_ungetc(next);
					FlushWithPending(NEWLINE);
				}
				case (char)EOF: FlushWithPending(EOF);
				default:
					yylval.str[len] = cur; yylval.str[++len] = 0;
					break;
			} /* switch */
		} while (len < MAXTOKEN-1);
		goto Pending;
	}

	do {
		cur = lex_getc();
		switch (cur) {
			case '=':  FlushWithPending(EQ);
			case ':':  FlushWithPending(COLON);
			case '.':  FlushWithPending(DOT);
			case ';':  FlushWithPending(SEMI);
			case ' ':  FlushWithPending(SPACE);
			case '\t': FlushWithPending(HTAB);
			case '\r':
			case '\n': {
				char next = lex_getc();
				if (!(((next == '\r') || (next == '\n')) && (cur != next)))
					lex_ungetc(next);
				FlushWithPending(LINESEP);
			}
			case (char)EOF: FlushWithPending(EOF);
			default:
				yylval.str[len] = cur; yylval.str[++len] = 0;
				break;
		} /* switch */
	} while (len < MAXTOKEN-1);
	return WORD;

Pending:
	{
		if (stricmp(yylval.str, "begin") == 0) {
			beginning = TRUE;
			return BEGIN;
		} else if (stricmp(yylval.str, "vcard") == 0) {
			if (beginning && curCard == -1 && pendingToken == NEWLINE)
				pendingToken = LINESEP;
			else if (!beginning && curCard == -1 && pendingToken == LINESEP)
				pendingToken = NEWLINE;
			return VCARD;
		} else if (stricmp(yylval.str, "end") == 0) {
			beginning = FALSE;
			return END;
		}
		if (paramExp) {
			PARAMS_STRUCT params;
			int param;
			if ((param = StrToParam(yylval.str, &params))) {
				yylval.params = params;
				return param;
			} else if (stricmp(yylval.str, "type") == 0)
				return TYPE;
			else if (stricmp(yylval.str, "value") == 0)
				return VALUE;
			else if (stricmp(yylval.str, "encoding") == 0)
				return ENCODING;
			else if (stricmp(yylval.str, "charset") == 0)
				return CHARSET;
			else if (stricmp(yylval.str, "language") == 0)
				return LANGUAGE;
			else if (strnicmp(yylval.str, "X-", 2) == 0)
				return XWORD;
		} else if ((curCard != -1) && StrToProp(yylval.str)
			|| (strnicmp(yylval.str, "X-", 2) == 0)) {
#if YYDEBUG
			if (yydebug) {
				char buf[80];
				sprintf(buf, "property \"%s\"\n", yylval.str);
				Parse_Debug(buf);
			}
#endif
			paramExp = TRUE;
			/* check for special props that are tokens */
			if (stricmp(yylval.str, "AGENT") == 0)
				return PROP_AGENT;
			else
				return PROP;
		}
	}
	return (curCard == -1) ? TERM : WORD;
}


/***************************************************************************/
/***							Public Functions						****/
/***************************************************************************/

static BOOL Parse_MIMEHelper(CList *vcList)
{
	BOOL success = FALSE;

	curCard = -1;
	mime_numErrors = 0;
	pendingToken = 0;
	mime_lineNum = 1;
	peekn = 0;
	global_vcList = vcList;

	expected = none;
	paramExp = FALSE;
	longString = NULL; longStringLen = 0; longStringMax = 0;

	/* this winds up invoking the Parse_* callouts. */
	if (yyparse() != 0)
		goto Done;

	success = TRUE;

Done:
	if (longString) { HFREE(longString); longString = NULL; }
	if (!success) {
		for (int i = 0; i < MAXCARD; i++)
			if (cardToBuild[i]) {
				delete cardToBuild[i];
				cardToBuild[i] = NULL;
			}
		if (cardBuilt) delete cardBuilt;
	}
	cardBuilt = NULL;
	return success;
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This is the public API to call to parse a buffer and create a CVCard. */
BOOL Parse_MIME(
	const char *input,	/* In */
	S32 len,			/* In */
	CVCard **card)		/* Out */
{
	CList vcList;
	BOOL result;

	inputString = input;
	inputLen = len;
	curPos = 0;
	inputFile = NULL;
	result = Parse_MIMEHelper(&vcList);
	if (vcList.GetCount()) {
		BOOL first = TRUE;
		for (CLISTPOSITION pos = vcList.GetHeadPosition(); pos; ) {
			CVCard *vCard = (CVCard *)vcList.GetNext(pos);
			if (first) {
				*card = vCard;
				first = FALSE;
			} else
				delete vCard;
		}
	} else
		*card = NULL;
	return result;
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This is the public API to call to parse a buffer and create a CVCard. */
extern BOOL Parse_Many_MIME(
	const char *input,	/* In */
	S32 len,			/* In */
	CList *vcList)		/* Out: CVCard objects added to existing list */
{
	inputString = input;
	inputLen = len;
	curPos = 0;
	inputFile = NULL;
	return Parse_MIMEHelper(vcList);
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This is the public API to call to parse a buffer and create a CVCard. */
BOOL Parse_MIME_FromFile(
	CFile *file,		/* In */
	CVCard **card)		/* Out */
{
	CList vcList;
	BOOL result;
	DWORD startPos;

	inputString = NULL;
	inputLen = -1;
	curPos = 0;
	inputFile = file;
	startPos = file->GetPosition();
	result = Parse_MIMEHelper(&vcList);
	if (vcList.GetCount()) {
		BOOL first = TRUE;
		for (CLISTPOSITION pos = vcList.GetHeadPosition(); pos; ) {
			CVCard *vCard = (CVCard *)vcList.GetNext(pos);
			if (first) {
				*card = vCard;
				first = FALSE;
			} else
				delete vCard;
		}
	} else {
		*card = NULL;
		file->Seek(startPos, CFile::begin);
	}
	return result;
}

extern BOOL Parse_Many_MIME_FromFile(
	CFile *file,		/* In */
	CList *vcList)		/* Out: CVCard objects added to existing list */
{
	DWORD startPos;
	BOOL result;

	inputString = NULL;
	inputLen = -1;
	curPos = 0;
	inputFile = file;
	startPos = file->GetPosition();
	if (!(result = Parse_MIMEHelper(vcList)))
		file->Seek(startPos, CFile::begin);
	return result;
}


/***************************************************************************/
/***						Parser Callout Functions					****/
/***************************************************************************/

typedef struct {
	const char *name;
	int token;
} PARAM_PAIR;

static PARAM_PAIR typePairs[] = {
	vcDomesticProp,			DOM,
	vcInternationalProp,	INTL,
	vcPostalProp,			POSTAL,
	vcParcelProp,			PARCEL,
	vcHomeProp,				HOME,
	vcWorkProp,				WORK,
	vcPreferredProp,		PREF,
	vcVoiceProp,			VOICE,
	vcFaxProp,				FAX,
	vcMessageProp,			MSG,
	vcCellularProp,			CELL,
	vcPagerProp,			PAGER,
	vcBBSProp,				BBS,
	vcModemProp,			MODEM,
	vcCarProp,				CAR,
	vcISDNProp,				ISDN,
	vcVideoProp,			VIDEO,
	vcAOLProp,				AOL,
	vcAppleLinkProp,		APPLELINK,
	vcATTMailProp,			ATTMAIL,
	vcCISProp,				CIS,
	vcEWorldProp,			EWORLD,
	vcInternetProp,			INTERNET,
	vcIBMMailProp,			IBMMAIL,
	vcMSNProp,				MSN,
	vcMCIMailProp,			MCIMAIL,
	vcPowerShareProp,		POWERSHARE,
	vcProdigyProp,			PRODIGY,
	vcTLXProp,				TLX,
	vcX400Prop,				X400,
	vcGIFProp,				GIF,
	vcCGMProp,				CGM,
	vcWMFProp,				WMF,
	vcBMPProp,				BMP,
	vcMETProp,				MET,
	vcPMBProp,				PMB,
	vcDIBProp,				DIB,
	vcPICTProp,				PICT,
	vcTIFFProp,				TIFF,
	vcAcrobatProp,			ACROBAT,
	vcPSProp,				PS,
	vcJPEGProp,				JPEG,
	vcQuickTimeProp,		QTIME,
	vcMPEGProp,				MPEG,
	vcMPEG2Prop,			MPEG2,
	vcAVIProp,				AVI,
	vcWAVEProp,				WAVE,
	vcAIFFProp,				AIFF,
	vcPCMProp,				PCM,
	vcX509Prop,				X509,
	vcPGPProp,				PGP,
	NULL,					NULL
};

static PARAM_PAIR valuePairs[] = {
	vcInlineProp,			INLINE,
	//vcURLValueProp,		URL,
	vcContentIDProp,		CONTENTID,
	NULL,					NULL
};

static PARAM_PAIR encodingPairs[] = {
	vc7bitProp,				SEVENBIT,
	//vcQuotedPrintableProp,QUOTEDP,
	vcBase64Prop,			BASE64,
	NULL,					NULL
};

/*/////////////////////////////////////////////////////////////////////////*/
static void YYDebug(const char *s)
{
	Parse_Debug(s);
}

/*/////////////////////////////////////////////////////////////////////////*/
static int StrToParam(const char *s, PARAMS_STRUCT *params)
{
	int i;

	params->known[1] = NULL;
	params->extended[0] = 0;
	
	for (i = 0; typePairs[i].name; i++)
		if (stricmp(s, strrchr(typePairs[i].name, '/') + 1) == 0) {
			params->known[0] = typePairs[i].name;
			return typePairs[i].token;
		}
	for (i = 0; valuePairs[i].name; i++)
		if (stricmp(s, strrchr(valuePairs[i].name, '/') + 1) == 0) {
			params->known[0] = valuePairs[i].name;
			return valuePairs[i].token;
		}
	for (i = 0; encodingPairs[i].name; i++)
		if (stricmp(s, strrchr(encodingPairs[i].name, '/') + 1) == 0) {
			params->known[0] = encodingPairs[i].name;
			return encodingPairs[i].token;
		}
	if (stricmp(s, "quoted-printable") == 0) {
		params->known[0] = vcQuotedPrintableProp;
		return QUOTEDP;
	} else if (stricmp(s, "url") == 0) {
		params->known[0] = vcURLValueProp;
		return URL;
	}
	return 0;
}

/*/////////////////////////////////////////////////////////////////////////*/
static const char* StrToProp(const char* str)
{
	int i;
	
	if (stricmp(str, "N") == 0)
		return mime_fam_given;
	else if (stricmp(str, "ORG") == 0)
		return mime_orgname_orgunit;
	else if (stricmp(str, "ADR") == 0)
		return mime_address;
	for (i = 0; propNames[i]; i++)
		if (stricmp(str, strrchr(propNames[i], '/') + 1) == 0) {
			return propNames[i];
		}
	return NULL;
}

/*/////////////////////////////////////////////////////////////////////////*/
static void AddParam(PARAMS_STRUCT* dst, PARAMS_STRUCT* src)
{
	if (src->known[0]) {
		int len = flagslen(dst->known);
		dst->known[len] = src->known[0];
		dst->known[len+1] = NULL;
	} else {
		char *p = dst->extended;
		int len = strlen(src->extended);
		while (*p) p += strlen(p) + 1;
		memcpy(p, src->extended, len + 1);
		*(p + len + 1) = 0;
	}
}

/*/////////////////////////////////////////////////////////////////////////*/
static int ComponentsSeparatedByChar(
	char* str, char pat, CList& list)
{
	char* p;
	char* s = str;
	int num = 0;

	while ((p = strchr(s, pat))) {
		if (p == s || *(p-1) != '\\') {
			*p = 0;
			list.AddTail(str);
			num++;
			s = str = p + 1;
		} else {
			s = p + 1;
		}
	}
	list.AddTail(str);
	num++;

    for (CLISTPOSITION pos = list.GetHeadPosition(); pos; ) {
		s = (char*)list.GetNext(pos);
		while ((p = strchr(s, pat))) {
			int len = strlen(p+1);
			memmove(p-1, p, len+1);
			*(p+len) = 0;
			s = p;
		}
	}

	return num;
}

static void AddStringProps(
	CVCNode* node, const char** props, char* val)
{
	CList list;

	ComponentsSeparatedByChar(val, ';', list);
    for (CLISTPOSITION pos = list.GetHeadPosition(); pos && *props; props++) {
		char* s = (char*)list.GetNext(pos);
		if (*s)
			node->AddStringProp(*props, s);
	}
}

/*/////////////////////////////////////////////////////////////////////////*/
static BOOL Parse_Assoc(
	const char *groups, const char *prop, PARAMS_STRUCT *params, char *value)
{
	CVCNode *node = NULL;
	const char *propName;
	char *val = *value ? value : longString;
	S32 valLen = *value ? strlen(value) : longStringLen;
	U8 __huge *bytes = NULL;

	if (!valLen)
		return TRUE; /* don't treat an empty value as a syntax error */

	propName = StrToProp(prop);
	/* prop is a word like "PN", and propName is now */
	/* the real prop name of the form "+//ISBN 1-887687-00-9::versit..." */
	if (*groups) {
		node = FindOrCreatePart(bodyToBuild, groups);
	} else { /* this is a "top level" property name */
		if (propName) {
			if (strcmp(propName, vcCharSetProp) == 0
				|| strcmp(propName, vcLanguageProp) == 0) {
				node = bodyToBuild;
				node->RemoveProp(propName);
			} else
				node = bodyToBuild->AddPart();
		} else 
			node = bodyToBuild->AddPart();
	}

	if (FlagsHave(params, vcBase64Prop)) {
		S32 len;
		bytes = DataFromBase64(val, valLen, &len);
		valLen = len;
		if (!bytes)
			return FALSE;
	}

	if (!propName) { /* it's an extended property */
		if (bytes) {
			node->AddProp(new CVCProp(prop, vcOctetsType, bytes, valLen));
			HFREE(bytes);
			AddBoolProps(node, params);
		} else {
			node->AddStringProp(prop, value);
			AddBoolProps(node, params);
		}
		return TRUE;
	}

	if ((strcmp(propName, vcLogoProp) == 0)
		|| (strcmp(propName, vcPhotoProp) == 0)) {
		if (bytes) {
			if (FlagsHave(params, vcGIFProp)
				&& !FlagsHave(params, vcURLValueProp)
				&& !FlagsHave(params, vcContentIDProp))
				node->AddProp(new CVCProp(propName, vcGIFType, bytes, valLen));
			else
				node->AddProp(new CVCProp(propName, vcOctetsType, bytes, valLen));
			HFREE(bytes);
			AddBoolProps(node, params);
		} else {
			node->AddStringProp(propName, value);
			AddBoolProps(node, params);
		}
	} else if (strcmp(propName, vcPronunciationProp) == 0) {
		if (bytes) {
			if (FlagsHave(params, vcWAVEProp)
				&& !FlagsHave(params, vcURLValueProp)
				&& !FlagsHave(params, vcContentIDProp))
				node->AddProp(new CVCProp(propName, vcWAVType, bytes, valLen));
			else
				node->AddProp(new CVCProp(propName, vcOctetsType, bytes, valLen));
			HFREE(bytes);
			AddBoolProps(node, params);
		} else {
			node->AddStringProp(propName, value);
			AddBoolProps(node, params);
		}
	} else if (strcmp(propName, vcPublicKeyProp) == 0) {
		if (bytes) {
			node->AddProp(new CVCProp(propName, vcOctetsType, bytes, valLen));
			HFREE(bytes);
			AddBoolProps(node, params);
		} else {
			node->AddStringProp(propName, value);
			AddBoolProps(node, params);
		}
	} else if (strcmp(propName, mime_fam_given) == 0) {
		AddStringProps(node, mime_nameProps, val);
		AddBoolProps(node, params);
	} else if (strcmp(propName, mime_orgname_orgunit) == 0) {
		AddStringProps(node, mime_orgProps, val);
		AddBoolProps(node, params);
	} else if (strcmp(propName, mime_address) == 0) {
		AddStringProps(node, mime_addrProps, val);
		AddBoolProps(node, params);
	} else {
		node->AddStringProp(propName, value);
		AddBoolProps(node, params);
	}

	return TRUE;
}

/*/////////////////////////////////////////////////////////////////////////*/
static BOOL Parse_Agent(
	const char *groups, const char *prop, PARAMS_STRUCT *params,
	CVCard *agentCard)
{
	CVCNode *node = NULL;

	if (*groups) {
		node = FindOrCreatePart(bodyToBuild, groups);
	} else { /* this is a "top level" property name */
		node = bodyToBuild->AddPart();
	}

	node->AddProp(new CVCProp(vcAgentProp, VCNextObjectType, agentCard));
	AddBoolProps(node, params);

	return TRUE;
}


/***************************************************************************/
/***						Private Utility Functions					****/
/***************************************************************************/

/*/////////////////////////////////////////////////////////////////////////*/
/* This parses and converts the base64 format for binary encoding into
 * a decoded buffer (allocated with new).  See RFC 1521.
 */
static U8 __huge * DataFromBase64(
	const char __huge *str, S32 strLen, S32 *len)
{
	S32 cur = 0, bytesLen = 0, bytesMax = 0;
	int quadIx = 0, pad = 0;
	U32 trip = 0;
	U8 b;
	char c;
	U8 __huge *bytes = NULL;

	while (cur < strLen) {
		c = str[cur];
		if ((c >= 'A') && (c <= 'Z'))
			b = (U8)(c - 'A');
		else if ((c >= 'a') && (c <= 'z'))
			b = (U8)(c - 'a') + 26;
		else if ((c >= '0') && (c <= '9'))
			b = (U8)(c - '0') + 52;
		else if (c == '+')
			b = 62;
		else if (c == '/')
			b = 63;
		else if (c == '=') {
			b = 0;
			pad++;
		} else if ((c == '\n') || (c == ' ') || (c == '\t')) {
			cur++;
			continue;
		} else { /* error condition */
			if (bytes) delete [] bytes;
			return NULL;
		}
		trip = (trip << 6) | b;
		if (++quadIx == 4) {
			U8 outBytes[3];
			int numOut;
			for (int i = 0; i < 3; i++) {
				outBytes[2-i] = (U8)(trip & 0xFF);
				trip >>= 8;
			}
			numOut = 3 - pad;
			if (bytesLen + numOut > bytesMax) {
				if (!bytes) {
					bytes = HNEW(U8, 1024L);
					bytesMax = 1024;
				} else {
					U8 __huge *newBytes = HNEW(U8, bytesMax * 2);
					_hmemcpy(newBytes, bytes, bytesLen);
					HFREE(bytes);
					bytes = newBytes;
					bytesMax *= 2;
				}
			}
			memcpy(bytes + bytesLen, outBytes, numOut);
			bytesLen += numOut;
			trip = 0;
			quadIx = 0;
		}
		cur++;
	} /* while */
	*len = bytesLen;
	return bytes;
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This creates an empty CVCard shell with an English body in preparation
 * for parsing properties onto it.  This is used for both the outermost
 * card, as well as any AGENT properties, which are themselves vCards.
 */
static BOOL PushVCard()
{
	CVCard *card;
	CVCNode *root, *english;

	if (curCard == MAXCARD - 1)
		return FALSE;

	card = new CVCard;
	card->AddObject(root = new CVCNode);					/* create root */
	root->AddProp(new CVCProp(VCRootObject));				/* mark it so */

	/* add a body having the default language */
	english = root->AddObjectProp(vcBodyProp, VCBodyObject);
	cardToBuild[++curCard] = card;
	bodyToBuild = english;

	return TRUE;
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This pops the recently built vCard off the stack and returns it. */
static CVCard* PopVCard()
{
	CVCard *result = cardToBuild[curCard];

	cardToBuild[curCard--] = NULL;
	bodyToBuild = (curCard == -1) ? NULL : cardToBuild[curCard]->FindBody();

	return result;
}

/*/////////////////////////////////////////////////////////////////////////*/
static int flagslen(const char **params)
{
	int i;
	for (i = 0; *params; params++, i++) ;
	return i;
}

/*/////////////////////////////////////////////////////////////////////////*/
static BOOL FlagsHave(PARAMS_STRUCT *params, const char *propName)
{
	const char **kf;
	
	if (!params)
		return FALSE;
	kf = params->known;
	while (*kf)
		if (*kf++ == propName)
			return TRUE;
	return FALSE;
}

/*/////////////////////////////////////////////////////////////////////////*/
static void AddBoolProps(CVCNode *node, PARAMS_STRUCT *params)
{
	const char **kf;
	const char *ext;

	if (!params)
		return;
	kf = params->known;
	ext = params->extended;

	// process the known boolean properties
	while (*kf) {
		node->AddBoolProp(*kf);
		kf++;
	}

	// process the extended properties
	while (*ext) {
		const char* eq = strchr(ext, '=');
		ASSERT(eq);
		if (eq-ext == 7 && strnicmp(ext, "charset", 7) == 0) {
			if (!node->GetProp(vcCharSetProp))
				node->AddProp(new CVCProp(vcCharSetProp, vcFlagsType, (void*)(eq+1), strlen(eq+1)+1));
		} else if (eq-ext == 8 && strnicmp(ext, "language", 8) == 0) {
			if (!node->GetProp(vcLanguageProp))
				node->AddProp(new CVCProp(vcLanguageProp, vcFlagsType, (void*)(eq+1), strlen(eq+1)+1));
		} else {
			char buf[256];
			strncpy(buf, ext, eq-ext);
			buf[eq-ext] = 0;
			node->AddProp(new CVCProp(buf, vcFlagsType, (void*)(eq+1), strlen(eq+1)+1));
		}
		ext += strlen(ext) + 1;
	}
}

#line 1849 "mime_tab.cpp"
#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab
int
yyparse()
{
    int yym, yyn, yystate, yyresult;
#if YYDEBUG
    char *yys;
    char debugbuf[1024];

    if (yys = getenv("YYDEBUG"))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    p_yyval = NULL; p_yylval = NULL; yyss = NULL; yyvs = NULL;
    if ((p_yyval = (YYSTYPE*)malloc(sizeof(*p_yyval))) == NULL) goto yyabort;
    if ((p_yylval = (YYSTYPE*)malloc(sizeof(*p_yylval))) == NULL) goto yyabort;
    if ((yyss = (short*)malloc(sizeof(*yyss) * YYSTACKSIZE)) == NULL) goto yyabort;
    if ((yyvs = (YYSTYPE*)malloc(sizeof(*yyvs) * YYSTACKSIZE)) == NULL) goto yyabort;

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if (yyn = yydefred[yystate]) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            sprintf(debugbuf, "%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys); YYDebug(debugbuf);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug) {
            sprintf(debugbuf, "%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]); YYDebug(debugbuf);}
#endif
        if (yyssp >= yyss + yystacksize - 1)
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#ifdef lint
    goto yynewerror;
#endif
yynewerror:
    yyerror("syntax error");
#ifdef lint
    goto yyerrlab;
#endif
yyerrlab:
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug) {
                    sprintf(debugbuf, 
                        "%sdebug: state %d, error recovery shifting to state %d\n",
                        YYPREFIX, *yyssp, yytable[yyn]); YYDebug(debugbuf);}
#endif
                if (yyssp >= yyss + yystacksize - 1)
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug) {
                    sprintf(debugbuf, "%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp); YYDebug(debugbuf);}
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            sprintf(debugbuf, "%sdebug: state %d, error recovery discards token %d(%s)\n",
                    YYPREFIX, yystate, yychar, yys); YYDebug(debugbuf);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug) {
        sprintf(debugbuf, "%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]); YYDebug(debugbuf);}
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 1:
#line 307 "mime.y"
{ global_vcList->AddTail(yyvsp[0].vCard); }
break;
case 2:
#line 309 "mime.y"
{ global_vcList->AddTail(yyvsp[0].vCard); }
break;
case 3:
#line 311 "mime.y"
{ global_vcList->AddTail(yyvsp[0].vCard); }
break;
case 17:
#line 334 "mime.y"
{
				if (!PushVCard())
					YYERROR;
				ExpectValue(NULL);
			}
break;
case 18:
#line 340 "mime.y"
{ expected = none; }
break;
case 19:
#line 342 "mime.y"
{ yyval.vCard = PopVCard(); }
break;
case 20:
#line 344 "mime.y"
{ yyval.vCard = yyvsp[-5].vCard; }
break;
case 23:
#line 352 "mime.y"
{ ExpectValue(&(yyvsp[-1].params)); }
break;
case 24:
#line 353 "mime.y"
{
				expected = none;
				if (!Parse_Assoc(yyvsp[-5].str, yyvsp[-4].str, &(yyvsp[-3].params), yyvsp[0].str))
					YYERROR;
			}
break;
case 25:
#line 359 "mime.y"
{ ExpectValue(NULL); }
break;
case 26:
#line 360 "mime.y"
{
				expected = none;
				if (!Parse_Assoc(yyvsp[-5].str, yyvsp[-4].str, NULL, yyvsp[0].str))
					YYERROR;
			}
break;
case 27:
#line 366 "mime.y"
{
				expected = none;
				if (!Parse_Agent(yyvsp[-6].str, yyvsp[-5].str, &(yyvsp[-4].params), yyvsp[-1].vCard)) {
					delete yyvsp[-1].vCard;
					YYERROR;
				}
			}
break;
case 28:
#line 374 "mime.y"
{
				expected = none;
				if (!Parse_Agent(yyvsp[-6].str, yyvsp[-5].str, NULL, yyvsp[-1].vCard)) {
					delete yyvsp[-1].vCard;
					YYERROR;
				}
			}
break;
case 30:
#line 383 "mime.y"
{
				expected = none;
				paramExp = FALSE;
				yyerrok;
				yyclearin;
			}
break;
case 31:
#line 391 "mime.y"
{ yyval.params = yyvsp[-1].params; }
break;
case 32:
#line 394 "mime.y"
{
						yyval.params = yyvsp[-4].params;
						AddParam(&(yyval.params), &(yyvsp[0].params));
					}
break;
case 34:
#line 401 "mime.y"
{ yyval.params = yyvsp[0].params; }
break;
case 41:
#line 409 "mime.y"
{
						yyval.params.known[0] = NULL;
						strcpy(yyval.params.extended, yyvsp[-4].str);
						strcat(yyval.params.extended, "=");
						strcat(yyval.params.extended, yyvsp[0].str);
						yyval.params.extended[strlen(yyval.params.extended)+1] = 0;
					}
break;
case 42:
#line 417 "mime.y"
{
						yyval.params.known[0] = NULL;
						strcpy(yyval.params.extended, yyvsp[-4].str);
						strcat(yyval.params.extended, "=");
						strcat(yyval.params.extended, yyvsp[0].str);
						yyval.params.extended[strlen(yyval.params.extended)+1] = 0;
					}
break;
case 43:
#line 425 "mime.y"
{
						yyval.params.known[0] = NULL;
						strcpy(yyval.params.extended, yyvsp[-4].str);
						strcat(yyval.params.extended, "=");
						strcat(yyval.params.extended, yyvsp[0].str);
						yyval.params.extended[strlen(yyval.params.extended)+1] = 0;
					}
break;
case 44:
#line 434 "mime.y"
{ yyval.params = yyvsp[0].params; }
break;
case 46:
#line 438 "mime.y"
{ yyval.params = yyvsp[0].params; }
break;
case 48:
#line 442 "mime.y"
{ yyval.params = yyvsp[0].params; }
break;
case 50:
#line 446 "mime.y"
{ yyval.params = yyvsp[0].params; }
break;
case 52:
#line 450 "mime.y"
{ yyval.params = yyvsp[0].params; }
break;
case 53:
#line 451 "mime.y"
{ yyval.params = yyvsp[0].params; }
break;
case 107:
#line 470 "mime.y"
{
				StrCat(yyval.str, yyvsp[-3].str, yyvsp[0].str);
			}
break;
case 108:
#line 474 "mime.y"
{
				StrCat(yyval.str, yyvsp[-2].str, "");
			}
break;
case 110:
#line 479 "mime.y"
{
				yyval.str[0] = 0;
			}
break;
case 114:
#line 487 "mime.y"
{ StrCat(yyval.str, yyvsp[-2].str, ""); }
break;
case 115:
#line 489 "mime.y"
{ StrCat(yyval.str, yyvsp[-2].str, ""); }
break;
case 116:
#line 493 "mime.y"
{
				StrCat(yyval.str, yyvsp[-2].str, "\n");
				StrCat(yyval.str, yyval.str, yyvsp[0].str);
			}
break;
case 119:
#line 500 "mime.y"
{ yyval.str[0] = 0; }
break;
case 131:
#line 518 "mime.y"
{ StrCat(yyval.str, yyvsp[-1].str, ""); }
break;
case 132:
#line 520 "mime.y"
{ yyval.str[0] = 0; }
break;
case 133:
#line 522 "mime.y"
{ yyval.str[0] = 0; }
break;
case 134:
#line 526 "mime.y"
{
				strcpy(yyval.str, yyvsp[-2].str);
				strcat(yyval.str, ".");
				strcat(yyval.str, yyvsp[0].str);
			}
break;
#line 2208 "mime_tab.cpp"
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug) {
            sprintf(debugbuf, 
                "%sdebug: after reduction, shifting from state 0 to state %d\n",
                YYPREFIX, YYFINAL); YYDebug(debugbuf);}
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                sprintf(debugbuf, "%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys); YYDebug(debugbuf);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug) {
        sprintf(debugbuf, 
            "%sdebug: after reduction, shifting from state %d to state %d\n",
            YYPREFIX, *yyssp, yystate); YYDebug(debugbuf);}
#endif
    if (yyssp >= yyss + yystacksize - 1)
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    yyresult = 1;
    goto yyfinish;
yyaccept:
    yyresult = 0;
yyfinish:
    if (p_yyval) free(p_yyval);
    if (p_yylval) free(p_yylval);
    if (yyss) free(yyss);
    if (yyvs) free(yyvs);
    return yyresult;
}
END_CFUNCTIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\mainfrm.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// mainfrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "VC.h"
#include "mainfrm.h"
#include "callcntr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_COMMAND(ID_EDIT_PASTE_SPECIAL, OnEditPasteSpecial)
	ON_COMMAND(ID_DEBUG_SHOWCALLCENTER, OnDebugShowCallCenter)
	//}}AFX_MSG_MAP
	// Global help commands
	ON_COMMAND(ID_HELP_INDEX, CMDIFrameWnd::OnHelpIndex)
	ON_COMMAND(ID_HELP_USING, CMDIFrameWnd::OnHelpUsing)
	ON_COMMAND(ID_HELP, CMDIFrameWnd::OnHelp)
	ON_COMMAND(ID_CONTEXT_HELP, CMDIFrameWnd::OnContextHelp)
	ON_COMMAND(ID_DEFAULT_HELP, CMDIFrameWnd::OnHelpIndex)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// arrays of IDs used to initialize control bars
	
static UINT BASED_CODE indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	// TODO: Remove this if you don't want tool tips or a resizeable toolbar
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY /*| CBRS_SIZE_DYNAMIC*/);

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	/*
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar); */

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	// TODO: Remove this if you don't want tool tips
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY);

	return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

void CMainFrame::OnEditPaste() 
{
	SendMessage(WM_COMMAND, ID_FILE_NEW);
	// now the newly active view will pick up the following command...
	SendMessage(WM_COMMAND, ID_EDIT_PASTE);
}

void CMainFrame::OnEditPasteSpecial() 
{
	SendMessage(WM_COMMAND, ID_FILE_NEW);
	// now the newly active view will pick up the following command...
	SendMessage(WM_COMMAND, ID_EDIT_PASTE_SPECIAL);
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs) 
{
	cs.style = WS_OVERLAPPED | WS_CAPTION | FWS_ADDTOTITLE
		| WS_THICKFRAME | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_MAXIMIZE;
	
	return CMDIFrameWnd::PreCreateWindow(cs);
}

void CMainFrame::OnDebugShowCallCenter() 
{
	CCallCenter cc;
	cc.DoModal();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\mime.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#ifndef __MIME_H__
#define __MIME_H__

#include "parse.h"

extern int mime_lineNum; /* line number for syntax error */
extern int mime_numErrors;

#ifdef __cplusplus
extern "C" {
#endif

extern BOOL Parse_MIME(
	const char *input,	/* In */
	S32 len,			/* In */
	CVCard **card		/* Out */
	);

extern BOOL Parse_Many_MIME(
	const char *input,	/* In */
	S32 len,			/* In */
	CList *vcList		/* Out: CVCard objects added to existing list */
	);

// If successful, the file's seek position is left at the end of the
// parsed card.  If not successful, the file's seek position is reset
// back to where it was when this function was invoked.
extern BOOL Parse_MIME_FromFile(
	CFile *file,		/* In */
	CVCard **card		/* Out */
	);

// This function parses as many cards as possible, in sequence, until EOF
// is reached or a fatal syntax error occurs.  It returns TRUE if it
// successfully parsed at least one card, and in this case the file's
// seek position is left where the parser stopped (at EOF or a syntax
// error).  If FALSE is returned, the file's seek position is reset
// back to where it was when this function was invoked.
extern BOOL Parse_Many_MIME_FromFile(
	CFile *file,		/* In */
	CList *vcList		/* Out: CVCard objects added to existing list */
	);

#ifdef __cplusplus
};
#endif

#endif // __MIME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\msv_tab.cpp ===
//#ifndef __MWERKS__
#include "stdafx.h"
//#endif
#ifndef lint
static char yysccsid[] = "@(#)yaccpar	1.10 (Berkeley) 09/07/95 swb";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 10
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#ifdef __cplusplus
#define CFUNCTIONS 		extern "C" {
#define END_CFUNCTIONS	}
#else
#define CFUNCTIONS
#define END_CFUNCTIONS
#endif
#define yyparse msv_parse
#define yylex msv_lex
#define yyerror msv_error
#define yychar msv_char
#define p_yyval p_msv_val
#undef yyval
#define yyval (*p_msv_val)
#define p_yylval p_msv_lval
#undef yylval
#define yylval (*p_msv_lval)
#define yydebug msv_debug
#define yynerrs msv_nerrs
#define yyerrflag msv_errflag
#define yyss msv_ss
#define yyssp msv_ssp
#define yyvs msv_vs
#define yyvsp msv_vsp
#define yylhs msv_lhs
#define yylen msv_len
#define yydefred msv_defred
#define yydgoto msv_dgoto
#define yysindex msv_sindex
#define yyrindex msv_rindex
#define yygindex msv_gindex
#define yytable msv_table
#define yycheck msv_check
#define yyname msv_name
#define yyrule msv_rule
#define YYPREFIX "msv_"
#line 2 "msv.y"

/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

/*
To invoke this parser, see the "Public Interface" section below.

This MS/V parser accepts input such as the following:
	[vCard
	O=AT&T/Versit;
	FN=Roland H. Alden
	TITLE=Consultant (Versit Project Office)
	N=Alden;Roland
	A:DOM,POSTAL,PARCEL,HOME,WORK=Suite 2208;One Pine Street;San Francisco;CA;94111;U.S.A.
	A.FADR:DOM,POSTAL,PARCEL,HOME,WORK=Roland H. Alden\
	Suite 2208\
	One Pine Street\
	San Francisco, CA 94111
	A.FADR:POSTAL,PARCEL,HOME,WORK=Roland H. Alden\
	Suite 2208\
	One Pine Street\
	San Francisco, CA 94111\
	U.S.A.
	B.T:HOME,WORK,PREF,MSG=+1 (415) 296-9106
	C.T:WORK,FAX=+1 (415) 296-9016
	D.T:MSG,CELL=+1 (415) 608-5981
	E.EMAIL:WORK,PREF,INTERNET=sf!rincon!ralden@alden.attmail.com
	F.EMAIL:INTERNET=ralden@sfgate.com
	G.EMAIL:HOME,MCIMail=242-2200
	PN=ROW-LAND ALL-DEN
	PN:WAV,BASE64=<bindata>
		UklGRtQ4AABXQVZFZm10IBAAAAABAAEAESsAABErAAABAAgAZGF0Ya84AACAgoSD
		...
		e319fYCAg4WEhIAA
	</bindata>
	]

For the purposes of the following grammar, a LINESEP token indicates either
a \r char (0x0D), a \n char (0x0A), or a combination of one of each,
in either order (\r\n or \n\r).  This is a bit more lenient than the spec.
*/


#ifdef _WIN32
#include <wchar.h>
#else
#include "wchar.h"
#endif
#include <string.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include "clist.h"
#include "vcard.h"
#include "msv.h"

#if defined(_WIN32) || defined(__MWERKS__)
#define HNEW(_t, _n) new _t[_n]
#define HFREE(_h) delete [] _h
#else
#define HNEW(_t, _n) (_t __huge *)_halloc(_n, 1)
/*#define HNEW(_t, _n) (_t __huge *)_halloc(_n, 1); {char buf[40]; sprintf(buf, "_halloc(%ld)\n", _n); Parse_Debug(buf);}*/
#define HFREE(_h) _hfree(_h)
#endif


/****  Types, Constants  ****/

#define YYDEBUG			1		/* 1 to compile in some debugging code */
#define MAXTOKEN		256		/* maximum token (line) length */
#define MAXFLAGS		((MAXTOKEN / 2) / sizeof(char *))
#define YYSTACKSIZE 	50
#define MAXASSOCKEY		24
#define MAXASSOCVALUE	64
#define MAXCARD			2		/* max # of nested cards parseable */
								/* (includes outermost) */

typedef struct {
	const char* known[MAXFLAGS];
	char extended[MAXTOKEN / 2];
} FLAGS_STRUCT;

typedef struct {
	char key[MAXASSOCKEY];
	char value[MAXASSOCVALUE];
} AssocEntry;	/* a simple key/value association, impl'd using CList */

/* some fake property names that represent special cases */
#define msv_fam_given			"family;given"
#define msv_orgname_orgunit		"org_name;org_unit"
#define msv_address				"six part address"

/*
 * These strings are defined as a courtesy for the rest of the app code.
 * They are useful here because the tail end of each is the cleartext
 * string to match according to this grammar.
 */
const char* vcDefaultLang			= "en-US";

const char* vcISO9070Prefix			= VCISO9070Prefix;
const char* vcClipboardFormatVCard	= VCClipboardFormatVCard;

const char* vcISO639Type			= VCISO639Type;
const char* vcStrIdxType			= VCStrIdxType;
const char* vcFlagsType				= VCFlagsType;
const char* vcNextObjectType		= VCNextObjectType;
const char* vcOctetsType 			= VCOctetsType;
const char* vcGIFType				= VCGIFType;
const char* vcWAVType				= VCWAVType;
const char* vcNullType 				= VCNullType;

const char* vcRootObject			= VCRootObject;
const char* vcBodyObject			= VCBodyObject;
const char* vcPartObject			= VCPartObject;
const char* vcBodyProp				= VCBodyProp;
const char* vcPartProp				= VCPartProp;
const char* vcNextObjectProp		= VCNextObjectProp;

const char* vcLogoProp				= VCLogoProp;
const char* vcPhotoProp				= VCPhotoProp;
const char* vcDeliveryLabelProp     = VCDeliveryLabelProp;
const char* vcPostalBoxProp			= VCPostalBoxProp;
const char* vcStreetAddressProp		= VCStreetAddressProp;
const char* vcExtAddressProp		= VCExtAddressProp;
const char* vcCountryNameProp		= VCCountryNameProp;
const char* vcPostalCodeProp		= VCPostalCodeProp;
const char* vcRegionProp			= VCRegionProp;
const char* vcCityProp				= VCCityProp;
const char* vcFullNameProp			= VCFullNameProp;
const char* vcTitleProp				= VCTitleProp;
const char* vcOrgNameProp			= VCOrgNameProp;
const char* vcOrgUnitProp			= VCOrgUnitProp;
const char* vcOrgUnit2Prop			= VCOrgUnit2Prop;
const char* vcOrgUnit3Prop			= VCOrgUnit3Prop;
const char* vcOrgUnit4Prop			= VCOrgUnit4Prop;
const char* vcFamilyNameProp		= VCFamilyNameProp;
const char* vcGivenNameProp			= VCGivenNameProp;
const char* vcAdditionalNamesProp	= VCAdditionalNamesProp;
const char* vcNamePrefixesProp		= VCNamePrefixesProp;
const char* vcNameSuffixesProp		= VCNameSuffixesProp;
const char* vcPronunciationProp		= VCPronunciationProp;
const char* vcLanguageProp			= VCLanguageProp;
const char* vcTelephoneProp			= VCTelephoneProp;
const char* vcEmailAddressProp		= VCEmailAddressProp;
const char* vcTimeZoneProp			= VCTimeZoneProp;
const char* vcLocationProp			= VCLocationProp;
const char* vcCommentProp			= VCCommentProp;
const char* vcCharSetProp			= VCCharSetProp;
const char* vcLastRevisedProp		= VCLastRevisedProp;
const char* vcUniqueStringProp		= VCUniqueStringProp;
const char* vcPublicKeyProp			= VCPublicKeyProp;
const char* vcMailerProp			= VCMailerProp;
const char* vcAgentProp				= VCAgentProp;
const char* vcBirthDateProp			= VCBirthDateProp;
const char* vcBusinessRoleProp		= VCBusinessRoleProp;
const char* vcCaptionProp			= VCCaptionProp;
const char* vcURLProp				= VCURLProp;

const char* vcDomesticProp			= VCDomesticProp;
const char* vcInternationalProp		= VCInternationalProp;
const char* vcPostalProp			= VCPostalProp;
const char* vcParcelProp			= VCParcelProp;
const char* vcHomeProp				= VCHomeProp;
const char* vcWorkProp				= VCWorkProp;
const char* vcPreferredProp			= VCPreferredProp;
const char* vcVoiceProp				= VCVoiceProp;
const char* vcFaxProp				= VCFaxProp;
const char* vcMessageProp			= VCMessageProp;
const char* vcCellularProp			= VCCellularProp;
const char* vcPagerProp				= VCPagerProp;
const char* vcBBSProp				= VCBBSProp;
const char* vcModemProp				= VCModemProp;
const char* vcCarProp				= VCCarProp;
const char* vcISDNProp				= VCISDNProp;
const char* vcVideoProp				= VCVideoProp;

const char* vcInlineProp			= VCInlineProp;
const char* vcURLValueProp			= VCURLValueProp;
const char* vcContentIDProp			= VCContentIDProp;

const char* vc7bitProp				= VC7bitProp;
const char* vcQuotedPrintableProp	= VCQuotedPrintableProp;
const char* vcBase64Prop			= VCBase64Prop;

const char* vcAOLProp				= VCAOLProp;
const char* vcAppleLinkProp			= VCAppleLinkProp;
const char* vcATTMailProp			= VCATTMailProp;
const char* vcCISProp				= VCCISProp;
const char* vcEWorldProp			= VCEWorldProp;
const char* vcInternetProp			= VCInternetProp;
const char* vcIBMMailProp			= VCIBMMailProp;
const char* vcMSNProp				= VCMSNProp;
const char* vcMCIMailProp			= VCMCIMailProp;
const char* vcPowerShareProp		= VCPowerShareProp;
const char* vcProdigyProp			= VCProdigyProp;
const char* vcTLXProp				= VCTLXProp;
const char* vcX400Prop				= VCX400Prop;

const char* vcGIFProp				= VCGIFProp;
const char* vcCGMProp				= VCCGMProp;
const char* vcWMFProp				= VCWMFProp;
const char* vcBMPProp				= VCBMPProp;
const char* vcMETProp				= VCMETProp;
const char* vcPMBProp				= VCPMBProp;
const char* vcDIBProp				= VCDIBProp;
const char* vcPICTProp				= VCPICTProp;
const char* vcTIFFProp				= VCTIFFProp;
const char* vcAcrobatProp			= VCAcrobatProp;
const char* vcPSProp				= VCPSProp;
const char* vcJPEGProp				= VCJPEGProp;
const char* vcQuickTimeProp			= VCQuickTimeProp;
const char* vcMPEGProp				= VCMPEGProp;
const char* vcMPEG2Prop				= VCMPEG2Prop;
const char* vcAVIProp				= VCAVIProp;

const char* vcWAVEProp				= VCWAVEProp;
const char* vcAIFFProp				= VCAIFFProp;
const char* vcPCMProp				= VCPCMProp;

const char* vcX509Prop				= VCX509Prop;
const char* vcPGPProp				= VCPGPProp;

const char* vcNodeNameProp			= VCNodeNameProp;

typedef struct {
	const char *name;
	unsigned long value;
} VC_FLAG_PAIR;

static VC_FLAG_PAIR generalFlags[] = {
	vcDomesticProp,			VC_DOM,
	vcInternationalProp,	VC_INTL,
	vcPostalProp,			VC_POSTAL,
	vcParcelProp,			VC_PARCEL,
	vcHomeProp,				VC_HOME,
	vcWorkProp,				VC_WORK,
	vcPreferredProp,		VC_PREF,
	vcVoiceProp,			VC_VOICE,
	vcFaxProp,				VC_FAX,
	vcMessageProp,			VC_MSG,
	vcCellularProp,			VC_CELL,
	vcPagerProp,			VC_PAGER,
	vcBBSProp,				VC_BBS,
	vcModemProp,			VC_MODEM,
	vcCarProp,				VC_CAR,
	vcISDNProp,				VC_ISDN,
	vcVideoProp,			VC_VIDEO,
	vcBase64Prop,			VC_BASE64,
	NULL,					NULL
};

static VC_FLAG_PAIR emailFlags[] = {
	vcAOLProp,				VC_AOL,
	vcAppleLinkProp,		VC_AppleLink,
	vcATTMailProp,			VC_ATTMail,
	vcCISProp,				VC_CIS,
	vcEWorldProp,			VC_eWorld,
	vcInternetProp,			VC_INTERNET,
	vcIBMMailProp,			VC_IBMMail,
	vcMSNProp,				VC_MSN,
	vcMCIMailProp,			VC_MCIMail,
	vcPowerShareProp,		VC_POWERSHARE,
	vcProdigyProp,			VC_PRODIGY,
	vcTLXProp,				VC_TLX,
	vcX400Prop,				VC_X400,
	NULL,					NULL
};

static VC_FLAG_PAIR videoFlags[] = {
	vcGIFProp,				VC_GIF,
	vcCGMProp,				VC_CGM,
	vcWMFProp,				VC_WMF,
	vcBMPProp,				VC_BMP,
	vcMETProp,				VC_MET,
	vcPMBProp,				VC_PMB,
	vcDIBProp,				VC_DIB,
	vcPICTProp,				VC_PICT,
	vcTIFFProp,				VC_TIFF,
	vcAcrobatProp,			VC_ACROBAT,
	vcPSProp,				VC_PS,
	NULL,					NULL
};

static VC_FLAG_PAIR audioFlags[] = {
	vcWAVEProp,				VC_WAV,
	NULL,					NULL
};

static const char *addrProps[] = {
	vcExtAddressProp,
	vcStreetAddressProp,
	vcCityProp,
	vcRegionProp,
	vcPostalCodeProp,
	vcCountryNameProp,
	NULL
};

static const char *nameProps[] = {
	vcFamilyNameProp,
	vcGivenNameProp,
	vcAdditionalNamesProp,
	vcNamePrefixesProp,
	vcNameSuffixesProp,
	NULL
};

static const char *orgProps[] = {
	vcOrgNameProp,
	vcOrgUnitProp,
	vcOrgUnit2Prop,
	vcOrgUnit3Prop,
	vcOrgUnit4Prop,
	NULL
};


/****  Global Variables  ****/

int msv_lineNum, msv_numErrors; /* yyerror() can use these */

static S32 curPos, inputLen;
static int pendingToken;
static const char *inputString;
static CFile* inputFile;
static BOOL stringExpected, flagExpected, inBinary, semiSpecial;
static CList *mapProps;
static char __huge *longString;
static S32 longStringLen, longStringMax;
static CList* global_vcList;

static CVCard *cardBuilt;
static CVCard* cardToBuild[MAXCARD];
static int curCard;
static CVCNode *bodyToBuild;


/****  External Functions  ****/

CFUNCTIONS

extern void Parse_Debug(const char *s);
extern void yyerror(char *s);

END_CFUNCTIONS


/****  Private Forward Declarations  ****/

CFUNCTIONS

/* A helpful utility for the rest of the app. */
CVCNode* FindOrCreatePart(CVCNode *node, const char *name);

static BOOL StrToFlags(const char *s, FLAGS_STRUCT *flags, VC_PTR_FLAGS capFlags);
static void StrCat(char *dst, const char *src1, const char *src2);
static void ExpectString(void);
static BOOL Parse_Assoc(
	const char *groups, const char *prop, FLAGS_STRUCT *flags,
	const char *value);
static BOOL Parse_SemiValue(
	const char *groups, const char *prop, FLAGS_STRUCT *flags,
	char *parts, const char **props);
static BOOL Parse_TwoPart(
	const char *groups, const char *prop, FLAGS_STRUCT *flags,
	char *parts);
static BOOL Parse_Agent(
	const char *groups, const char *prop, FLAGS_STRUCT *flags,
	CVCard *agentCard);
static void AddAssoc(CList *table, const char *key, const char *value);
/*static void SetAssoc(CList *table, const char *key, const char *value);*/
static const char *Lookup(CList *table, const char *key);
static void RemoveAll(CList *table);
static void InitMapProps(void);
int yyparse();
static U8 __huge * DataFromBase64(
	const char __huge *str, S32 strLen, S32 *len);
static BOOL PushVCard();
static CVCard* PopVCard();
static int flagslen(const char **flags);
static BOOL FlagsHave(FLAGS_STRUCT *flags, const char *propName);
static void AddBoolProps(CVCNode *node, FLAGS_STRUCT *flags);

END_CFUNCTIONS

#line 428 "msv.y"
typedef union
{
	char str[MAXTOKEN];
	FLAGS_STRUCT flags;
	CVCard *vCard;
} YYSTYPE;
#line 478 "msv_tab.cpp"
#define OBRKT 257
#define CBRKT 258
#define EQ 259
#define COLON 260
#define DOT 261
#define COMMA 262
#define SEMI 263
#define SPACE 264
#define HTAB 265
#define LINESEP 266
#define NEWLINE 267
#define VCARD 268
#define BBINDATA 269
#define EBINDATA 270
#define BKSLASH 271
#define TERM 272
#define WORD 273
#define STRING 274
#define PROP 275
#define PROP_A 276
#define PROP_N 277
#define PROP_O 278
#define PROP_AGENT 279
#define FLAG 280
#define YYERRCODE 256
short msv_lhs[] = {                                        -1,
   11,   11,   11,   12,   12,   13,   13,   13,   13,   13,
   13,   13,    0,    0,    0,    0,   14,   16,   10,   15,
   15,   19,   17,   20,   17,   21,   17,   22,   17,   17,
   17,    7,    7,   24,   24,   24,   24,   18,   18,    6,
    6,    6,   25,   26,    5,    1,    1,    1,    1,    8,
    8,    2,    2,    3,    3,    3,    3,    4,    4,    9,
   27,    9,    9,   23,
};
short msv_len[] = {                                         2,
    3,    2,    1,    2,    1,    2,    2,    2,    2,    2,
    1,    1,    3,    2,    2,    1,    0,    0,    8,    2,
    1,    0,    8,    0,    8,    0,    8,    0,    8,    8,
    2,    1,    1,    2,    2,    1,    1,    1,    1,    1,
    1,    1,    0,    0,    9,    4,    3,    1,    2,    3,
    1,    3,    1,    2,    3,    1,    1,    3,    1,    3,
    0,    3,    1,    0,
};
short msv_defred[] = {                                      0,
    0,   11,    0,   12,    0,    3,    0,    0,    5,    8,
    6,   17,    7,    9,   10,    2,    0,    0,    4,    0,
    1,    0,    0,   48,    0,    0,   33,   49,    0,   18,
    0,    0,   46,    0,   36,   37,   59,    0,    0,    0,
   21,   57,    0,   31,    0,    0,    0,    0,    0,    0,
   19,   20,   34,   35,    0,   61,    0,   63,    0,    0,
    0,    0,   58,    0,    0,    0,    0,   39,    0,    0,
    0,    0,    0,   62,   60,   22,   24,   26,   28,    0,
    0,    0,    0,    0,    0,    0,   43,    0,   41,    0,
   42,   51,    0,    0,    0,    0,    0,   23,    0,   25,
   27,   29,   30,    0,   50,   53,    0,    0,   52,    0,
    0,    0,   45,
};
short msv_dgoto[] = {                                       5,
   25,  107,   38,   39,   89,   90,   92,   93,   57,    6,
    7,    8,    9,   20,   40,   32,   41,   67,   81,   82,
   83,   84,   68,   69,   97,  110,   65,
};
short msv_sindex[] = {                                   -227,
 -224,    0, -221,    0,    0,    0, -227, -227,    0,    0,
    0,    0,    0,    0,    0,    0, -227, -227,    0, -236,
    0, -227, -257,    0, -237, -214,    0,    0, -212,    0,
 -218, -254,    0, -196,    0,    0,    0, -184, -201, -241,
    0,    0, -206,    0, -170, -170, -170, -170, -170, -145,
    0,    0,    0,    0, -130,    0, -177,    0, -177, -177,
 -177, -177,    0, -145, -148, -147, -125,    0, -243, -124,
 -123, -122, -121,    0,    0,    0,    0,    0,    0, -118,
 -185, -236, -236, -236, -128, -190,    0, -237,    0, -120,
    0,    0, -143, -142, -141, -119, -117,    0, -236,    0,
    0,    0,    0, -133,    0,    0, -116, -132,    0, -190,
 -127, -190,    0,
};
short msv_rindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,  144,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  145,  148,    0, -115,
    0,  152,    0,    0, -137,    0,    0,    0,    0,    0,
 -198, -179,    0,    0,    0,    0,    0,    0,    0, -179,
    0,    0, -174,    0, -193, -193, -193, -193, -193, -169,
    0,    0,    0,    0,    0,    0, -106,    0, -106, -106,
 -106, -106,    0, -164,    0,    0,    0,    0, -217,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 -115, -136, -136, -136,    0, -115,    0, -112,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0, -136,    0,
    0,    0,    0,    0,    0,    0,    0, -187,    0, -114,
    0, -115,    0,
};
short msv_gindex[] = {                                      0,
   74,    0,    0,  114,    0,    0,  -19,   -2,   70,   -4,
  150,   32,   29,    0,    0,    0,  119,  -55,    0,    0,
    0,    0,  -20,  -24,    0,    0,    0,
};
#define YYTABLESIZE 159
short msv_table[] = {                                      27,
   26,   34,   16,   70,   71,   72,   73,   43,   28,   35,
   36,   42,   21,   16,   34,   43,   51,   21,   37,   42,
   53,   54,   35,   36,   58,   58,   58,   58,   58,    1,
   96,   37,   10,   29,   23,   14,   19,   24,   17,    2,
    3,   38,   11,   12,    4,   19,   15,   13,   38,   22,
   19,   30,   38,   31,  111,   33,  113,   53,   54,   50,
   91,   27,   27,   27,   47,   64,   37,   47,   64,   44,
   64,   64,   47,   35,   36,   86,   44,   44,   27,  105,
   94,   95,   44,   87,   66,   23,   35,   36,   24,   56,
   45,   46,   47,   48,   49,   64,   64,   64,   64,   64,
   56,   56,   56,   56,   56,   54,   54,   54,   54,   54,
   55,   55,   55,   55,   55,   59,   60,   61,   62,   99,
   99,   99,  100,  101,  102,   32,   64,   63,   32,   64,
   64,   74,   75,   76,   77,   78,   79,   80,   85,   12,
  106,  109,  112,   16,   15,   98,  103,   14,  104,  108,
   64,   13,   64,   40,   88,   64,   55,   18,   52,
};
short msv_check[] = {                                      20,
   20,  256,    7,   59,   60,   61,   62,   32,  266,  264,
  265,   32,   17,   18,  256,   40,  258,   22,  273,   40,
  264,  265,  264,  265,   45,   46,   47,   48,   49,  257,
   86,  273,  257,  271,  271,  257,    8,  274,    7,  267,
  268,  259,  267,  268,  272,   17,  268,  272,  266,   18,
   22,  266,  270,  266,  110,  274,  112,  264,  265,  261,
   81,   82,   83,   84,  263,  259,  273,  266,  262,  266,
  264,  265,  271,  264,  265,   80,  264,  265,   99,   99,
   83,   84,  270,  269,  262,  271,  264,  265,  274,  260,
  275,  276,  277,  278,  279,  275,  276,  277,  278,  279,
  275,  276,  277,  278,  279,  275,  276,  277,  278,  279,
  275,  276,  277,  278,  279,   46,   47,   48,   49,  263,
  263,  263,  266,  266,  266,  263,  263,  273,  266,  266,
  261,  280,  280,  259,  259,  259,  259,  259,  257,  268,
  274,  274,  270,    0,    0,  266,  266,    0,  266,  266,
  266,    0,  259,  266,   81,  270,   43,    8,   40,
};
#define YYFINAL 5
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 280
#if YYDEBUG
char *msv_name[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"OBRKT","CBRKT","EQ","COLON",
"DOT","COMMA","SEMI","SPACE","HTAB","LINESEP","NEWLINE","VCARD","BBINDATA",
"EBINDATA","BKSLASH","TERM","WORD","STRING","PROP","PROP_A","PROP_N","PROP_O",
"PROP_AGENT","FLAG",
};
char *msv_rule[] = {
"$accept : msv",
"vcards : vcards junk vcard",
"vcards : vcards vcard",
"vcards : vcard",
"junk : junk atom",
"junk : atom",
"atom : OBRKT NEWLINE",
"atom : OBRKT TERM",
"atom : OBRKT OBRKT",
"atom : VCARD OBRKT",
"atom : VCARD VCARD",
"atom : NEWLINE",
"atom : TERM",
"msv : junk vcards junk",
"msv : junk vcards",
"msv : vcards junk",
"msv : vcards",
"$$1 :",
"$$2 :",
"vcard : OBRKT VCARD $$1 opt_str LINESEP $$2 items CBRKT",
"items : items item",
"items : item",
"$$3 :",
"item : groups PROP flags opt_ws EQ $$3 value LINESEP",
"$$4 :",
"item : groups PROP_A flags opt_ws EQ $$4 semistrings LINESEP",
"$$5 :",
"item : groups PROP_N flags opt_ws EQ $$5 semistrings LINESEP",
"$$6 :",
"item : groups PROP_O flags opt_ws EQ $$6 semistrings LINESEP",
"item : groups PROP_AGENT flags opt_ws EQ vcard opt_ws LINESEP",
"item : error LINESEP",
"opt_str : string",
"opt_str : empty",
"ws : ws SPACE",
"ws : ws HTAB",
"ws : SPACE",
"ws : HTAB",
"opt_ws : ws",
"opt_ws : empty",
"value : string",
"value : binary",
"value : empty",
"$$7 :",
"$$8 :",
"binary : BBINDATA $$7 LINESEP lines LINESEP $$8 opt_ws EBINDATA opt_ws",
"string : string BKSLASH LINESEP STRING",
"string : string BKSLASH LINESEP",
"string : STRING",
"string : BKSLASH LINESEP",
"semistrings : semistrings SEMI opt_str",
"semistrings : opt_str",
"lines : lines LINESEP STRING",
"lines : STRING",
"groups : grouplist DOT",
"groups : ws grouplist DOT",
"groups : ws",
"groups : empty",
"grouplist : grouplist DOT WORD",
"grouplist : WORD",
"flags : flags COMMA FLAG",
"$$9 :",
"flags : COLON $$9 FLAG",
"flags : empty",
"empty :",
};
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH 500
#endif
#endif
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
short *yyssp;
YYSTYPE *yyvsp;
YYSTYPE *p_yyval;
YYSTYPE *p_yylval;
short *yyss; /* YYSTACKSIZE long */
YYSTYPE *yyvs; /* YYSTACKSIZE long */
#undef yylval
#define yylval (*p_yylval)
#undef yyval
#define yyval (*p_yyval)
#define yystacksize YYSTACKSIZE
CFUNCTIONS
#line 665 "msv.y"

/***************************************************************************/
/***						The lexical analyzer						****/
/***************************************************************************/

/*/////////////////////////////////////////////////////////////////////////*/
#define IsLineBreak(_c) ((_c == '\n') || (_c == '\r'))

/*/////////////////////////////////////////////////////////////////////////*/
/* This appends onto yylval.str, unless MAXTOKEN has been exceeded.
 * In that case, yylval.str is set to 0 length, and longString is used.
 */
static void AppendCharToToken(char c, S32 *len)
{
	if (*len < MAXTOKEN - 1) {
		yylval.str[*len] = c; yylval.str[++(*len)] = 0;
	} else if (*len == MAXTOKEN - 1) { /* copy to "longString" */
		if (!longString) {
			longStringMax = MAXTOKEN * 2;
			longString = HNEW(char, longStringMax);
		}
		memcpy(longString, yylval.str, (size_t)*len + 1);
		longString[*len] = c; longString[++(*len)] = 0;
		yylval.str[0] = 0;
		longStringLen = *len;
	} else {
		if (longStringLen == longStringMax - 1) {
			char __huge *newStr = HNEW(char, longStringMax * 2);
			_hmemcpy((U8 __huge *)newStr, (U8 __huge *)longString, longStringLen + 1);
			longStringMax *= 2;
			HFREE(longString);
			longString = newStr;
		}
		longString[*len] = c; longString[++(*len)] = 0;
		longStringLen = *len;
	}
}

/*/////////////////////////////////////////////////////////////////////////*/
/* StrCat appends onto dst, ensuring that longString is used appropriately.
 * src1 may be of 0 length, in which case "longString" should be used.
 * "longString" would never be used for src2.
 */
static void StrCat(char *dst, const char *src1, const char *src2)
{
	S32 src1Len = strlen(src1);
	S32 src2Len = strlen(src2);
	S32 req;

	if (!src1Len && longString) {
		src1Len = longStringLen;
		src1 = longString;
	}
	if ((req = src1Len + src2Len + 1) > MAXTOKEN) {
		if (longString) { /* longString == src1 */
			if (longStringMax - longStringLen < src2Len) {
				/* since src2Len must be < MAXTOKEN, doubling longString
				   is guaranteed to be enough room */
				char __huge *newStr = HNEW(char, longStringMax * 2);
				_hmemcpy((U8 __huge *)newStr, (U8 __huge *)longString, longStringLen + 1);
				longStringMax *= 2;
				HFREE(longString);
				longString = newStr;
			}
			_hmemcpy((U8 __huge *)(longString + longStringLen), (U8 __huge *)src2, src2Len + 1);
			longStringLen += src2Len;
		} else { /* haven't yet used longString, so set it up */
			longStringMax = MAXTOKEN * 2;
			longString = HNEW(char, longStringMax);
			memcpy(longString, src1, (size_t)src1Len + 1);
			memcpy(longString + src1Len, src2, (size_t)src2Len + 1);
			longStringLen = src1Len + src2Len;
		}
		*dst = 0; /* indicate result is in longString */
	} else { /* both will fit in MAXTOKEN, so src1 can't be longString */
		if (dst != src1)
			strcpy(dst, src1);
		strcat(dst, src2);
	}
}

/*/////////////////////////////////////////////////////////////////////////*/
/* Set up the lexor to parse a string value. */
static void ExpectString(void)
{
	stringExpected = TRUE;
	if (longString) {
		HFREE(longString); longString = NULL;
		longStringLen = 0;
	}
	flagExpected = FALSE;
}

/*/////////////////////////////////////////////////////////////////////////*/
#define FlushWithPending(_t) { \
	if (len) { \
		pendingToken = _t; \
		goto Pending; \
	} else { \
		msv_lineNum += ((_t == LINESEP) || (_t == NEWLINE)); \
		return _t; \
	} \
}

static int peekn;
static char peekc[2];

/*/////////////////////////////////////////////////////////////////////////*/
static char lex_getc()
{
	if (peekn) {
		return peekc[--peekn];
	}
	if (curPos == inputLen)
		return EOF;
	else if (inputString)
		return *(inputString + curPos++);
	else {
		char result;
		return inputFile->Read(&result, 1) == 1 ? result : EOF;
	}
}

/*/////////////////////////////////////////////////////////////////////////*/
static void lex_ungetc(char c)
{
	ASSERT(peekn < 2);
	peekc[peekn++] = c;
}

/*/////////////////////////////////////////////////////////////////////////*/
/* Collect up a string value. */
static int LexString()
{
	char cur;
	S32 len = 0;

	do {
		cur = lex_getc();
		switch (cur) {
			case '\\': { /* check for CR-LF combos after the backslash */
				char next = lex_getc();
				if (semiSpecial && (next == ';')) {
					AppendCharToToken(';', &len);
				} else if (!inBinary && ((next == '\r') || (next == '\n'))) {
					char next2;
					next2 = lex_getc();
					if (!(((next2 == '\r') || (next2 == '\n')) && (next != next2)))
						lex_ungetc(next2);
					lex_ungetc(next); /* so that we'll pick up the LINESEP again */
					pendingToken = BKSLASH;
					goto EndString;
				} else if (!inBinary && (next == '\\')) {
					/* double backslash detected */
					next = lex_getc();
					if ((next == '\r') || (next == '\n')) {
						/* found \\ at end of line */
						char next2;
						next2 = lex_getc();
						if (!(((next2 == '\r') || (next2 == '\n')) && (next != next2)))
							lex_ungetc(next2);
						AppendCharToToken('\\', &len);
						pendingToken = LINESEP;
						goto EndString;
					}
					/* within a line */
					AppendCharToToken('\\', &len);
					lex_ungetc(next); /* now pointing at second backslash */
					/* here we let the top level switch handle it the next
					   time around */
				} else {
					AppendCharToToken(cur, &len);
				}
				break;
			} /* backslash */
			case ';':
				if (semiSpecial) {
					pendingToken = SEMI;
					goto EndString;
				} else
					AppendCharToToken(cur, &len);
				break;
			case '\r':
			case '\n': {
				char next = lex_getc();
				if (!(((next == '\r') || (next == '\n')) && (cur != next)))
					lex_ungetc(next);
				pendingToken = LINESEP;
				goto EndString;
			}
			case (char)EOF:
				pendingToken = EOF;
				break;
			default:
				AppendCharToToken(cur, &len);
				break;
		} /* switch */
	} while (cur != (char)EOF);

EndString:
	if (strncmp(yylval.str + strspn(yylval.str, " \t"), "<bindata>", 9) == 0)
		return BBINDATA;
	else if (strncmp(yylval.str + strspn(yylval.str, " \t"), "</bindata>", 10) == 0)
		return EBINDATA;
	else if (!len) {
		/* must have hit something immediately, in which case pendingToken
		   is set.  return it. */
		int result = pendingToken;
		pendingToken = 0;
		msv_lineNum += ((result == LINESEP) || (result == NEWLINE));
		return result;
	}

	return STRING;
} /* LexString */

/*/////////////////////////////////////////////////////////////////////////*/
/*
 * Read chars from the input.
 * Return one of the token types (or -1 for EOF).
 * Set yylval to indicate the value of the token, if any.
 */
int msv_lex();
int msv_lex()
{
	char cur;
	S32 len = 0;

	if (pendingToken) {
		int result = pendingToken;
		pendingToken = 0;
		msv_lineNum += ((result == LINESEP) || (result == NEWLINE));
		return result;
	}

	yylval.str[0] = 0;

	if (stringExpected)
		return LexString();
	else if (curCard == -1) {
		do {
			cur = lex_getc();
			switch (cur) {
				case '[':  FlushWithPending(OBRKT);
				case ' ':
				case '\t':
					if (len) goto Pending;
					break;
				case '\r':
				case '\n': {
					char next = lex_getc();
					if (!(((next == '\r') || (next == '\n')) && (cur != next)))
						lex_ungetc(next);
					FlushWithPending(NEWLINE);
				}
				case (char)EOF: FlushWithPending(EOF);
				default:
					yylval.str[len] = cur; yylval.str[++len] = 0;
					break;
			} /* switch */
		} while (len < MAXTOKEN-1);
		goto Pending;
	}

	do {
		cur = lex_getc();
		switch (cur) {
			case '[':  FlushWithPending(OBRKT);
			case ']':  FlushWithPending(CBRKT);
			case '=':  FlushWithPending(EQ);
			case ':':  FlushWithPending(COLON);
			case '.':  FlushWithPending(DOT);
			case ',':  FlushWithPending(COMMA);
			case ' ':  FlushWithPending(SPACE);
			case '\t': FlushWithPending(HTAB);
			case '\\': FlushWithPending(BKSLASH);
			case '\r':
			case '\n': {
				char next = lex_getc();
				if (!(((next == '\r') || (next == '\n')) && (cur != next)))
					lex_ungetc(next);
				FlushWithPending(LINESEP);
			}
			case (char)EOF: FlushWithPending(EOF);
			default:
				yylval.str[len] = cur; yylval.str[++len] = 0;
				break;
		} /* switch */
	} while (len < MAXTOKEN-1);
	return WORD;

Pending:
	{
		if (strcmp(yylval.str, "vCard") == 0) {
			if (pendingToken == NEWLINE)
				pendingToken = LINESEP;
			return VCARD;
		}
		if (flagExpected) {
			FLAGS_STRUCT flags;
			if (StrToFlags(yylval.str, &flags, NULL)) {
				yylval.flags = flags;
				return FLAG;
			} else {
				char buf[40];
				sprintf(buf, "unknown flag name \"%s\"", yylval.str);
				yyerror(buf);
			}
		} else if ((curCard != -1) && Lookup(mapProps, yylval.str)
			|| (strnicmp(yylval.str, "X-", 2) == 0)) {
#if YYDEBUG
			if (yydebug) {
				char buf[80];
				sprintf(buf, "property \"%s\"\n", yylval.str);
				Parse_Debug(buf);
			}
#endif
			/* check for special props that are tokens */
			if (stricmp(yylval.str, "A") == 0)
				return PROP_A;
			else if (stricmp(yylval.str, "N") == 0)
				return PROP_N;
			else if (stricmp(yylval.str, "O") == 0)
				return PROP_O;
			else if (stricmp(yylval.str, "AGENT") == 0)
				return PROP_AGENT;
			else
				return PROP;
		}
	}
	return (curCard == -1) ? TERM : WORD;
}


/***************************************************************************/
/***							Public Functions						****/
/***************************************************************************/

static BOOL Parse_MSVHelper(CList *vcList)
{
	BOOL success = FALSE;

	curCard = -1;
	msv_numErrors = 0;
	InitMapProps();
	pendingToken = 0;
	msv_lineNum = 1;
	peekn = 0;
	global_vcList = vcList;

	stringExpected = flagExpected = FALSE;
	longString = NULL; longStringLen = 0; longStringMax = 0;

	/* this winds up invoking the Parse_* callouts. */
	if (yyparse() != 0)
		goto Done;

	success = TRUE;

Done:
	if (longString) { HFREE(longString); longString = NULL; }
	RemoveAll(mapProps); delete mapProps; mapProps = NULL;
	if (!success) {
		for (int i = 0; i < MAXCARD; i++)
			if (cardToBuild[i]) {
				delete cardToBuild[i];
				cardToBuild[i] = NULL;
			}
		if (cardBuilt) delete cardBuilt;
	}
	cardBuilt = NULL;
	return success;
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This is the public API to call to parse a buffer and create a CVCard. */
BOOL Parse_MSV(
	const char *input,	/* In */
	S32 len,			/* In */
	CVCard **card)		/* Out */
{
	CList vcList;
	BOOL result;

	inputString = input;
	inputLen = len;
	curPos = 0;
	inputFile = NULL;
	result = Parse_MSVHelper(&vcList);
	if (vcList.GetCount()) {
		BOOL first = TRUE;
		for (CLISTPOSITION pos = vcList.GetHeadPosition(); pos; ) {
			CVCard *vCard = (CVCard *)vcList.GetNext(pos);
			if (first) {
				*card = vCard;
				first = FALSE;
			} else
				delete vCard;
		}
	} else
		*card = NULL;
	return result;
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This is the public API to call to parse a buffer and create a CVCard. */
extern BOOL Parse_Many_MSV(
	const char *input,	/* In */
	S32 len,			/* In */
	CList *vcList)		/* Out: CVCard objects added to existing list */
{
	inputString = input;
	inputLen = len;
	curPos = 0;
	inputFile = NULL;
	return Parse_MSVHelper(vcList);
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This is the public API to call to parse a buffer and create a CVCard. */
BOOL Parse_MSV_FromFile(
	CFile *file,		/* In */
	CVCard **card)		/* Out */
{
	CList vcList;
	BOOL result;
	DWORD startPos;

	inputString = NULL;
	inputLen = -1;
	curPos = 0;
	inputFile = file;
	startPos = file->GetPosition();
	result = Parse_MSVHelper(&vcList);
	if (vcList.GetCount()) {
		BOOL first = TRUE;
		for (CLISTPOSITION pos = vcList.GetHeadPosition(); pos; ) {
			CVCard *vCard = (CVCard *)vcList.GetNext(pos);
			if (first) {
				*card = vCard;
				first = FALSE;
			} else
				delete vCard;
		}
	} else {
		*card = NULL;
		file->Seek(startPos, CFile::begin);
	}
	return result;
}

extern BOOL Parse_Many_MSV_FromFile(
	CFile *file,		/* In */
	CList *vcList)		/* Out: CVCard objects added to existing list */
{
	DWORD startPos;
	BOOL result;

	inputString = NULL;
	inputLen = -1;
	curPos = 0;
	inputFile = file;
	startPos = file->GetPosition();
	if (!(result = Parse_MSVHelper(vcList)))
		file->Seek(startPos, CFile::begin);
	return result;
}


/***************************************************************************/
/***						Parser Callout Functions					****/
/***************************************************************************/

/*/////////////////////////////////////////////////////////////////////////*/
static void YYDebug(const char *s)
{
	Parse_Debug(s);
}

/*/////////////////////////////////////////////////////////////////////////*/
static BOOL StrToFlags(const char *s, FLAGS_STRUCT *flags, VC_PTR_FLAGS capFlags)
{
	int i;

	memset(flags, 0, sizeof(*flags));
	
	if (strnicmp(s, "X-", 2) == 0) {
		strcpy(flags->extended, s);
		return TRUE;
	}

	for (i = 0; generalFlags[i].name; i++)
		if (stricmp(s, strrchr(generalFlags[i].name, '/') + 1) == 0) {
			flags->known[0] = generalFlags[i].name;
			if (capFlags) capFlags->general |= generalFlags[i].value;
			return TRUE;
		}
	for (i = 0; emailFlags[i].name; i++)
		if (stricmp(s, strrchr(emailFlags[i].name, '/') + 1) == 0) {
			flags->known[0] = emailFlags[i].name;
			if (capFlags)
				capFlags->email = (VC_EMAIL_TYPE)emailFlags[i].value;
			return TRUE;
		}
	for (i = 0; videoFlags[i].name; i++)
		if (stricmp(s, strrchr(videoFlags[i].name, '/') + 1) == 0) {
			flags->known[0] = videoFlags[i].name;
			if (capFlags)
				capFlags->video = (VC_VIDEO_TYPE)videoFlags[i].value;
			return TRUE;
		}
	if (stricmp(s, "WAV") == 0) {
		flags->known[0] = audioFlags[0].name;
		if (capFlags)
			capFlags->audio = (VC_AUDIO_TYPE)audioFlags[0].value;
		return TRUE;
	}
	return FALSE;
}

static BOOL NeedsQP(const char* str)
{
	while (*str) {
		if (!((*str >= 32 && *str <= 60) || (*str >= 62 && *str <= 126)))
			return TRUE;
		str++;
	}
	return FALSE;
}

/*/////////////////////////////////////////////////////////////////////////*/
static BOOL Parse_Assoc(
	const char *groups, const char *prop, FLAGS_STRUCT *flags, const char *value)
{
	CVCNode *node = NULL;
	const char *propName;
	const char *val = *value ? value : longString;
	S32 valLen = *value ? strlen(value) : longStringLen;

	if (!valLen)
		return TRUE; /* don't treat an empty value as a syntax error */

	propName = Lookup(mapProps, prop);
	/* prop is a word like "PN", and propName is now */
	/* the real prop name of the form "+//ISBN 1-887687-00-9::versit..." */
	if (*groups) {
		node = FindOrCreatePart(bodyToBuild, groups);
	} else { /* this is a "top level" property name */
		node = bodyToBuild->AddPart();
	}

	if (!propName) { /* it's an extended property */
		if (FlagsHave(flags, vcBase64Prop)) {
			U8 __huge *bytes;
			S32 len;
			bytes = DataFromBase64(val, valLen, &len);
			if (bytes) {
				node->AddProp(new CVCProp(prop, vcOctetsType, bytes, len));
				HFREE(bytes);
				AddBoolProps(node, flags);
			} else
				return FALSE;
		} else {
			node->AddStringProp(prop, value);
			AddBoolProps(node, flags);
			node->AddBoolProp(vcQuotedPrintableProp);
		}
		return TRUE;
	}

	if ((strcmp(propName, vcLogoProp) == 0)
		|| (strcmp(propName, vcPhotoProp) == 0)) {
		if (FlagsHave(flags, vcGIFProp) && FlagsHave(flags, vcBase64Prop)) {
			U8 *bytes;
			S32 len;
			bytes = DataFromBase64(val, valLen, &len);
			if (bytes) {
				node->AddProp(new CVCProp(propName, VCGIFType, bytes, len));
				HFREE(bytes);
				AddBoolProps(node, flags);
			} else
				return FALSE;
		}
	} else if (strcmp(propName, vcPronunciationProp) == 0) {
		if (FlagsHave(flags, vcBase64Prop)) {
			if (FlagsHave(flags, vcWAVEProp) && FlagsHave(flags, vcBase64Prop)) {
				U8 __huge *bytes;
				S32 len;
				bytes = DataFromBase64(val, valLen, &len);
				if (bytes) {
					node->AddProp(new CVCProp(propName, VCWAVType, bytes, len));
					HFREE(bytes);
					AddBoolProps(node, flags);
				} else
					return FALSE;
			}
		} else {
			node->AddStringProp(propName, value);
			AddBoolProps(node, flags);
			if (NeedsQP(value))
				node->AddBoolProp(vcQuotedPrintableProp);
		}
	} else if ((strcmp(propName, vcPublicKeyProp) == 0)
		&& FlagsHave(flags, vcBase64Prop)) {
		U8 __huge *bytes;
		S32 len;
		bytes = DataFromBase64(val, valLen, &len);
		if (bytes) {
			node->AddProp(new CVCProp(propName, VCOctetsType, bytes, len));
			HFREE(bytes);
			AddBoolProps(node, flags);
		} else
			return FALSE;
	} else {
		node->AddStringProp(propName, value);
		AddBoolProps(node, flags);
		if (NeedsQP(value))
			node->AddBoolProp(vcQuotedPrintableProp);
	}

	return TRUE;
}

/*/////////////////////////////////////////////////////////////////////////*/
static BOOL Parse_SemiValue(
	const char *groups, const char *prop, FLAGS_STRUCT *flags,
	char *parts, const char **props)
{
	CVCNode *node = NULL;
	const char *propName = Lookup(mapProps, prop);
	char *p = *parts ? parts : longString;
	int i = 0;
	char *sep;
	BOOL needsQP = FALSE;

	if (!*p)
		return TRUE; /* don't treat an empty value as a syntax error */

	do {
		if ((sep = strchr(p, '\177')))
			*sep = 0;
		if (strlen(p)) {
			if (!node) {
				if (*groups) {
					node = FindOrCreatePart(bodyToBuild, groups);
				} else { /* this is a "top level" property name */
					node = bodyToBuild->AddPart();
				}
			}
			node->AddStringProp(props[i], p);
			needsQP |= NeedsQP(p);
		}
		if (sep)
			p = sep + 1;
	} while (sep && props[++i]);

	if (node) {
		AddBoolProps(node, flags);
		if (needsQP)
			node->AddBoolProp(vcQuotedPrintableProp);
	}

	return TRUE;
}

/*/////////////////////////////////////////////////////////////////////////*/
static BOOL Parse_Agent(
	const char *groups, const char *prop, FLAGS_STRUCT *flags,
	CVCard *agentCard)
{
	CVCNode *node = NULL;

	if (*groups) {
		node = FindOrCreatePart(bodyToBuild, groups);
	} else { /* this is a "top level" property name */
		node = bodyToBuild->AddPart();
	}

	node->AddProp(new CVCProp(vcAgentProp, VCNextObjectType, agentCard));
	AddBoolProps(node, flags);

	return TRUE;
}


/***************************************************************************/
/***						Private Utility Functions					****/
/***************************************************************************/

/*/////////////////////////////////////////////////////////////////////////*/
static void AddAssoc(CList *table, const char *key, const char *value)
{
	AssocEntry *entry = new AssocEntry;
	int len;

	if ((len = strlen(key)) < MAXASSOCKEY)
		strcpy(entry->key, key);
	else {
		strncpy(entry->key, key, MAXASSOCKEY - 1);
		entry->key[MAXASSOCKEY - 1] = 0;
	}

	if ((len = strlen(value)) < MAXASSOCVALUE)
		strcpy(entry->value, value);
	else {
		strncpy(entry->value, value, MAXASSOCVALUE - 1);
		entry->value[MAXASSOCVALUE - 1] = 0;
	}
	table->AddTail(entry);
}

/*/////////////////////////////////////////////////////////////////////////*/
# if 0
static void SetAssoc(CList *table, const char *key, const char *value)
{
	for (CLISTPOSITION pos = table->GetHeadPosition(); pos; ) {
		AssocEntry *entry = (AssocEntry *)table->GetNext(pos);
		if (strcmp(key, entry->key) == 0) {
			int len;
			if ((len = strlen(value)) < MAXASSOCVALUE)
				strcpy(entry->value, value);
			else {
				strncpy(entry->value, value, MAXASSOCVALUE - 1);
				entry->value[MAXASSOCVALUE - 1] = 0;
			}
			return;
		}
	}
	AddAssoc(table, key, value);
}
#endif

/*/////////////////////////////////////////////////////////////////////////*/
static const char *Lookup(CList *table, const char *key)
{
	for (CLISTPOSITION pos = table->GetHeadPosition(); pos; ) {
		AssocEntry *entry = (AssocEntry *)table->GetNext(pos);
		if (stricmp(key, entry->key) == 0)
			return entry->value;
	}
	return NULL;
}

/*/////////////////////////////////////////////////////////////////////////*/
static void RemoveAll(CList *table)
{
	for (CLISTPOSITION pos = table->GetHeadPosition(); pos; ) {
		AssocEntry *entry = (AssocEntry *)table->GetNext(pos);
		delete entry;
	}
	table->RemoveAll();
}

/*/////////////////////////////////////////////////////////////////////////*/
/* "name" is of the form A.FOO.BAZ, where each is a node name. */
/* Walk the node tree starting at "node" looking for part objects */
/* having the given name for that level.  At each level, if a part */
/* object isn't found, create one and give it that name. */
CVCNode* FindOrCreatePart(CVCNode *node, const char *name)
{
	const char *remain = name;
	char *dot = strchr(remain, '.');
	int size, len;
	char thisName[128];
	wchar_t *thisUnicode;
	CVCNode *thisNode = node, *thisPart;
	CList *props;

	do {
		if (dot) {
			len = dot - remain;
			strncpy(thisName, remain, len);
			*(thisName + len) = 0;
		} else
			strcpy(thisName, remain);
		thisUnicode = FakeUnicode(thisName, &size);
		props = thisNode->GetProps();
		thisPart = NULL;

		for (CLISTPOSITION pos = props->GetHeadPosition(); pos; ) {
			CVCProp *prop = (CVCProp *)props->GetNext(pos);

			if (strcmp(prop->GetName(), vcPartProp) != 0)
				continue;

			CVCNode *part = (CVCNode *)prop->FindValue(
				VCNextObjectType)->GetValue();
			CVCProp *nodeNameProp;
			if (!(nodeNameProp = part->GetProp(vcNodeNameProp)))
				continue;
			if (wcscmp(thisUnicode, (wchar_t *)nodeNameProp->FindValue(VCStrIdxType)->GetValue()) == 0) {
				thisPart = part;
				break;
			}
		}

		delete [] thisUnicode;

		if (!thisPart) {
			thisPart = thisNode->AddPart();
			thisPart->AddStringProp(vcNodeNameProp, thisName);
		}

		if (!dot)
			return thisPart;

		remain = dot + 1;
		dot = strchr(remain, '.');
		thisNode = thisPart;
	} while (TRUE);
	return NULL; /* never reached */
} /* FindOrCreatePart */

/*/////////////////////////////////////////////////////////////////////////*/
static void InitMapProps(void)
{
	mapProps = new CList;

	AddAssoc(mapProps, "LOGO", vcLogoProp);
	AddAssoc(mapProps, "PHOTO", vcPhotoProp);
	AddAssoc(mapProps, "FADR", vcDeliveryLabelProp);
	AddAssoc(mapProps, "A", msv_address);
	AddAssoc(mapProps, "FN", vcFullNameProp);
	AddAssoc(mapProps, "TITLE", vcTitleProp);
	AddAssoc(mapProps, "O", msv_orgname_orgunit);
	AddAssoc(mapProps, "N", msv_fam_given);
	AddAssoc(mapProps, "PN", vcPronunciationProp);
	AddAssoc(mapProps, "LANG", vcLanguageProp);
	AddAssoc(mapProps, "T", vcTelephoneProp);
	AddAssoc(mapProps, "EMAIL", vcEmailAddressProp);
	AddAssoc(mapProps, "TZ", vcTimeZoneProp);
	AddAssoc(mapProps, "GEO", vcLocationProp);
	AddAssoc(mapProps, "NOTE", vcCommentProp);
	AddAssoc(mapProps, "URL", vcURLProp);
	AddAssoc(mapProps, "CS", vcCharSetProp);
	AddAssoc(mapProps, "REV", vcLastRevisedProp);
	AddAssoc(mapProps, "UID", vcUniqueStringProp);
	AddAssoc(mapProps, "KEY", vcPublicKeyProp);
	AddAssoc(mapProps, "MAILER", vcMailerProp);
	AddAssoc(mapProps, "AGENT", vcAgentProp);
	AddAssoc(mapProps, "BD", vcBirthDateProp);
	AddAssoc(mapProps, "ROLE", vcBusinessRoleProp);
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This parses and converts the base64 format for binary encoding into
 * a decoded buffer (allocated with new).  See RFC 1521.
 */
static U8 __huge * DataFromBase64(
	const char __huge *str, S32 strLen, S32 *len)
{
	S32 cur = 0, bytesLen = 0, bytesMax = 0;
	int quadIx = 0, pad = 0;
	U32 trip = 0;
	U8 b;
	char c;
	U8 __huge *bytes = NULL;

	while (cur < strLen) {
		c = str[cur];
		if ((c >= 'A') && (c <= 'Z'))
			b = (U8)(c - 'A');
		else if ((c >= 'a') && (c <= 'z'))
			b = (U8)(c - 'a') + 26;
		else if ((c >= '0') && (c <= '9'))
			b = (U8)(c - '0') + 52;
		else if (c == '+')
			b = 62;
		else if (c == '/')
			b = 63;
		else if (c == '=') {
			b = 0;
			pad++;
		} else if ((c == '\n') || (c == ' ') || (c == '\t')) {
			cur++;
			continue;
		} else { /* error condition */
			if (bytes) delete [] bytes;
			return NULL;
		}
		trip = (trip << 6) | b;
		if (++quadIx == 4) {
			U8 outBytes[3];
			int numOut;
			for (int i = 0; i < 3; i++) {
				outBytes[2-i] = (U8)(trip & 0xFF);
				trip >>= 8;
			}
			numOut = 3 - pad;
			if (bytesLen + numOut > bytesMax) {
				if (!bytes) {
					bytes = HNEW(U8, 1024L);
					bytesMax = 1024;
				} else {
					U8 __huge *newBytes = HNEW(U8, bytesMax * 2);
					_hmemcpy(newBytes, bytes, bytesLen);
					HFREE(bytes);
					bytes = newBytes;
					bytesMax *= 2;
				}
			}
			memcpy(bytes + bytesLen, outBytes, numOut);
			bytesLen += numOut;
			trip = 0;
			quadIx = 0;
		}
		cur++;
	} /* while */
	*len = bytesLen;
	return bytes;
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This creates an empty CVCard shell with an English body in preparation
 * for parsing properties onto it.  This is used for both the outermost
 * card, as well as any AGENT properties, which are themselves vCards.
 */
static BOOL PushVCard()
{
	CVCard *card;
	CVCNode *root, *english;

	if (curCard == MAXCARD - 1)
		return FALSE;

	card = new CVCard;
	card->AddObject(root = new CVCNode);					/* create root */
	root->AddProp(new CVCProp(VCRootObject));				/* mark it so */

	/* add a body having the default language */
	english = root->AddObjectProp(vcBodyProp, VCBodyObject);
	cardToBuild[++curCard] = card;
	bodyToBuild = english;

	return TRUE;
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This pops the recently built vCard off the stack and returns it. */
static CVCard* PopVCard()
{
	CVCard *result = cardToBuild[curCard];

	cardToBuild[curCard--] = NULL;
	bodyToBuild = (curCard == -1) ? NULL : cardToBuild[curCard]->FindBody();

	return result;
}

/*/////////////////////////////////////////////////////////////////////////*/
static int flagslen(const char **flags)
{
	int i;
	for (i = 0; *flags; flags++, i++) ;
	return i;
}

/*/////////////////////////////////////////////////////////////////////////*/
static BOOL FlagsHave(FLAGS_STRUCT *flags, const char *propName)
{
	const char **kf = flags->known;

	while (*kf)
		if (*kf++ == propName)
			return TRUE;
	return FALSE;
}

/*/////////////////////////////////////////////////////////////////////////*/
static void AddBoolProps(CVCNode *node, FLAGS_STRUCT *flags)
{
	const char **kf = flags->known;
	const char *ext = flags->extended;

	// process the known boolean properties
	while (*kf) {
		node->AddBoolProp(*kf);
		kf++;
	}

	// process the extended boolean properties
	while (*ext) {
		node->AddBoolProp(ext);
		ext += strlen(ext) + 1;
	}
}

#line 1712 "msv_tab.cpp"
#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab
int
yyparse()
{
    int yym, yyn, yystate, yyresult;
#if YYDEBUG
    char *yys;
    char debugbuf[1024];

    if (yys = getenv("YYDEBUG"))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    p_yyval = NULL; p_yylval = NULL; yyss = NULL; yyvs = NULL;
    if ((p_yyval = (YYSTYPE*)malloc(sizeof(*p_yyval))) == NULL) goto yyabort;
    if ((p_yylval = (YYSTYPE*)malloc(sizeof(*p_yylval))) == NULL) goto yyabort;
    if ((yyss = (short*)malloc(sizeof(*yyss) * YYSTACKSIZE)) == NULL) goto yyabort;
    if ((yyvs = (YYSTYPE*)malloc(sizeof(*yyvs) * YYSTACKSIZE)) == NULL) goto yyabort;

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if (yyn = yydefred[yystate]) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            sprintf(debugbuf, "%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys); YYDebug(debugbuf);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug) {
            sprintf(debugbuf, "%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]); YYDebug(debugbuf);}
#endif
        if (yyssp >= yyss + yystacksize - 1)
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#ifdef lint
    goto yynewerror;
#endif
yynewerror:
    yyerror("syntax error");
#ifdef lint
    goto yyerrlab;
#endif
yyerrlab:
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug) {
                    sprintf(debugbuf, 
                        "%sdebug: state %d, error recovery shifting to state %d\n",
                        YYPREFIX, *yyssp, yytable[yyn]); YYDebug(debugbuf);}
#endif
                if (yyssp >= yyss + yystacksize - 1)
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug) {
                    sprintf(debugbuf, "%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp); YYDebug(debugbuf);}
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            sprintf(debugbuf, "%sdebug: state %d, error recovery discards token %d(%s)\n",
                    YYPREFIX, yystate, yychar, yys); YYDebug(debugbuf);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug) {
        sprintf(debugbuf, "%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]); YYDebug(debugbuf);}
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 1:
#line 472 "msv.y"
{ global_vcList->AddTail(yyvsp[0].vCard); }
break;
case 2:
#line 474 "msv.y"
{ global_vcList->AddTail(yyvsp[0].vCard); }
break;
case 3:
#line 476 "msv.y"
{ global_vcList->AddTail(yyvsp[0].vCard); }
break;
case 17:
#line 499 "msv.y"
{
				if (!PushVCard())
					YYERROR;
				ExpectString();
			}
break;
case 18:
#line 505 "msv.y"
{ stringExpected = FALSE; }
break;
case 19:
#line 507 "msv.y"
{ yyval.vCard = PopVCard(); }
break;
case 22:
#line 515 "msv.y"
{ ExpectString(); }
break;
case 23:
#line 517 "msv.y"
{
				if (!Parse_Assoc(yyvsp[-7].str, yyvsp[-6].str, &(yyvsp[-5].flags), yyvsp[-1].str))
					YYERROR;
			}
break;
case 24:
#line 522 "msv.y"
{ ExpectString(); semiSpecial = TRUE; }
break;
case 25:
#line 524 "msv.y"
{
				semiSpecial = stringExpected = FALSE;
				if (!Parse_SemiValue(yyvsp[-7].str, yyvsp[-6].str, &(yyvsp[-5].flags), yyvsp[-1].str, addrProps))
					YYERROR;
			}
break;
case 26:
#line 530 "msv.y"
{ ExpectString(); semiSpecial = TRUE; }
break;
case 27:
#line 532 "msv.y"
{
				semiSpecial = stringExpected = FALSE;
				if (!Parse_SemiValue(yyvsp[-7].str, yyvsp[-6].str, &(yyvsp[-5].flags), yyvsp[-1].str, nameProps))
					YYERROR;
			}
break;
case 28:
#line 538 "msv.y"
{ ExpectString(); semiSpecial = TRUE; }
break;
case 29:
#line 540 "msv.y"
{
				semiSpecial = stringExpected = FALSE;
				if (!Parse_SemiValue(yyvsp[-7].str, yyvsp[-6].str, &(yyvsp[-5].flags), yyvsp[-1].str, orgProps))
					YYERROR;
			}
break;
case 30:
#line 546 "msv.y"
{
				if (!Parse_Agent(yyvsp[-7].str, yyvsp[-6].str, &(yyvsp[-5].flags), yyvsp[-2].vCard)) {
					delete yyvsp[-2].vCard;
					YYERROR;
				}
			}
break;
case 31:
#line 553 "msv.y"
{
				stringExpected = flagExpected = FALSE;
				yyerrok;
				yyclearin;
			}
break;
case 33:
#line 560 "msv.y"
{ yyval.str[0] = 0; }
break;
case 40:
#line 573 "msv.y"
{ stringExpected = FALSE; }
break;
case 41:
#line 575 "msv.y"
{ stringExpected = FALSE; }
break;
case 42:
#line 577 "msv.y"
{
				yyval.str[0] = 0;
				stringExpected = FALSE;
			}
break;
case 43:
#line 583 "msv.y"
{ inBinary = TRUE; }
break;
case 44:
#line 585 "msv.y"
{ inBinary = FALSE; }
break;
case 45:
#line 586 "msv.y"
{
				StrCat(yyval.str, yyvsp[-5].str, "");
			}
break;
case 46:
#line 592 "msv.y"
{
				StrCat(yyval.str, yyvsp[-3].str, "\n");
				StrCat(yyval.str, yyval.str, yyvsp[0].str);
			}
break;
case 47:
#line 597 "msv.y"
{
				StrCat(yyval.str, yyvsp[-2].str, "\n");
			}
break;
case 49:
#line 602 "msv.y"
{
				StrCat(yyval.str, "\n", "");
			}
break;
case 50:
#line 608 "msv.y"
{
				StrCat(yyval.str, yyvsp[-2].str, "\177");
				StrCat(yyval.str, yyval.str, yyvsp[0].str);
			}
break;
case 52:
#line 616 "msv.y"
{
				StrCat(yyval.str, yyvsp[-2].str, "\n");
				StrCat(yyval.str, yyval.str, yyvsp[0].str);
			}
break;
case 55:
#line 625 "msv.y"
{ StrCat(yyval.str, yyvsp[-1].str, ""); }
break;
case 56:
#line 627 "msv.y"
{ yyval.str[0] = 0; }
break;
case 57:
#line 629 "msv.y"
{ yyval.str[0] = 0; }
break;
case 58:
#line 633 "msv.y"
{
				strcpy(yyval.str, yyvsp[-2].str);
				strcat(yyval.str, ".");
				strcat(yyval.str, yyvsp[0].str);
			}
break;
case 60:
#line 642 "msv.y"
{
				yyval.flags = yyvsp[-2].flags;
				if (yyvsp[0].flags.known[0]) {
					int len = flagslen(yyvsp[-2].flags.known);
					yyval.flags.known[len] = yyvsp[0].flags.known[0];
					yyval.flags.known[len+1] = NULL;
				} else {
					char *p = yyval.flags.extended;
					int len = strlen(yyvsp[0].flags.extended);
					while (*p) p += strlen(p) + 1;
					memcpy(p, yyvsp[0].flags.extended, len + 1);
					*(p + len + 1) = 0;
				}
			}
break;
case 61:
#line 656 "msv.y"
{ flagExpected = TRUE; }
break;
case 62:
#line 657 "msv.y"
{ yyval.flags = yyvsp[0].flags; }
break;
case 63:
#line 659 "msv.y"
{ yyval.flags.known[0] = NULL; yyval.flags.extended[0] = 0; }
break;
#line 2067 "msv_tab.cpp"
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug) {
            sprintf(debugbuf, 
                "%sdebug: after reduction, shifting from state 0 to state %d\n",
                YYPREFIX, YYFINAL); YYDebug(debugbuf);}
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                sprintf(debugbuf, "%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys); YYDebug(debugbuf);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug) {
        sprintf(debugbuf, 
            "%sdebug: after reduction, shifting from state %d to state %d\n",
            YYPREFIX, *yyssp, yystate); YYDebug(debugbuf);}
#endif
    if (yyssp >= yyss + yystacksize - 1)
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    yyresult = 1;
    goto yyfinish;
yyaccept:
    yyresult = 0;
yyfinish:
    if (p_yyval) free(p_yyval);
    if (p_yylval) free(p_yylval);
    if (yyss) free(yyss);
    if (yyvs) free(yyvs);
    return yyresult;
}
END_CFUNCTIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\propemal.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// propemal.cpp : implementation file
//

#include "stdafx.h"
#include "VC.h"
#include "propemal.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropEmail property page

IMPLEMENT_DYNCREATE(CPropEmail, CPropertyPage)

CPropEmail::CPropEmail() : CPropertyPage(CPropEmail::IDD)
{
	//{{AFX_DATA_INIT(CPropEmail)
	m_popup_std1 = _T("");
	m_popup_std2 = _T("");
	m_popup_std3 = _T("");
	m_edit_email1 = _T("");
	m_edit_email2 = _T("");
	m_edit_email3 = _T("");
	m_button_pref2 = FALSE;
	m_button_pref1 = FALSE;
	m_button_pref3 = FALSE;
	m_button_office1 = FALSE;
	m_button_office2 = FALSE;
	m_button_office3 = FALSE;
	m_button_home1 = FALSE;
	m_button_home2 = FALSE;
	m_button_home3 = FALSE;
	//}}AFX_DATA_INIT

	m_node1 = m_node2 = m_node3 = NULL;
}

CPropEmail::~CPropEmail()
{
}

void CPropEmail::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropEmail)
	DDX_CBString(pDX, IDC_EDIT_EMAIL_STANDARD, m_popup_std1);
	DDX_CBString(pDX, IDC_EDIT_EMAIL_STANDARD2, m_popup_std2);
	DDX_CBString(pDX, IDC_EDIT_EMAIL_STANDARD3, m_popup_std3);
	DDX_Text(pDX, IDC_EDIT_EMAIL_STRING, m_edit_email1);
	DDX_Text(pDX, IDC_EDIT_EMAIL_STRING2, m_edit_email2);
	DDX_Text(pDX, IDC_EDIT_EMAIL_STRING3, m_edit_email3);
	DDX_Check(pDX, IDC_EDIT_PREFERRED4, m_button_pref2);
	DDX_Check(pDX, IDC_EDIT_PREFERRED, m_button_pref1);
	DDX_Check(pDX, IDC_EDIT_PREFERRED5, m_button_pref3);
	DDX_Check(pDX, IDC_EDIT_OFFICE, m_button_office1);
	DDX_Check(pDX, IDC_EDIT_OFFICE4, m_button_office2);
	DDX_Check(pDX, IDC_EDIT_OFFICE5, m_button_office3);
	DDX_Check(pDX, IDC_EDIT_HOME, m_button_home1);
	DDX_Check(pDX, IDC_EDIT_HOME2, m_button_home2);
	DDX_Check(pDX, IDC_EDIT_HOME4, m_button_home3);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropEmail, CPropertyPage)
	//{{AFX_MSG_MAP(CPropEmail)
	ON_BN_CLICKED(IDC_BUTTON_MAIL, OnButtonMail)
	ON_BN_CLICKED(IDC_BUTTON_MAIL2, OnButtonMail2)
	ON_BN_CLICKED(IDC_BUTTON_MAIL3, OnButtonMail3)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
void CPropEmail::Mail(const CString &recip)
{
	// TODO: implement MAPI calls here
}

/////////////////////////////////////////////////////////////////////////////
// CPropEmail message handlers

void CPropEmail::OnButtonMail() 
{
	Mail(m_edit_email1);
}

void CPropEmail::OnButtonMail2() 
{
	Mail(m_edit_email2);
}

void CPropEmail::OnButtonMail3() 
{
	Mail(m_edit_email3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\propemal.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// propemal.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPropEmail dialog

class CVCNode;

class CPropEmail : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropEmail)

// Construction
public:
	CPropEmail();
	~CPropEmail();

// Dialog Data
	//{{AFX_DATA(CPropEmail)
	enum { IDD = IDD_EMAIL_ADDRESS };
	CString	m_popup_std1;
	CString	m_popup_std2;
	CString	m_popup_std3;
	CString	m_edit_email1;
	CString	m_edit_email2;
	CString	m_edit_email3;
	BOOL	m_button_pref2;
	BOOL	m_button_pref1;
	BOOL	m_button_pref3;
	BOOL	m_button_office1;
	BOOL	m_button_office2;
	BOOL	m_button_office3;
	BOOL	m_button_home1;
	BOOL	m_button_home2;
	BOOL	m_button_home3;
	//}}AFX_DATA

	CVCNode *m_node1, *m_node2, *m_node3;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropEmail)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	void Mail(const CString &recip);

	// Generated message map functions
	//{{AFX_MSG(CPropEmail)
	afx_msg void OnButtonMail();
	afx_msg void OnButtonMail2();
	afx_msg void OnButtonMail3();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\msv.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#ifndef __MSV_H__
#define __MSV_H__

#include "parse.h"

extern int msv_lineNum; /* line number for syntax error */
extern int msv_numErrors;

#ifdef __cplusplus
extern "C" {
#endif

extern BOOL Parse_MSV(
	const char *input,	/* In */
	S32 len,			/* In */
	CVCard **card		/* Out */
	);

extern BOOL Parse_Many_MSV(
	const char *input,	/* In */
	S32 len,			/* In */
	CList *vcList		/* Out: CVCard objects added to existing list */
	);

// If successful, the file's seek position is left at the end of the
// parsed card.  If not successful, the file's seek position is reset
// back to where it was when this function was invoked.
extern BOOL Parse_MSV_FromFile(
	CFile *file,		/* In */
	CVCard **card		/* Out */
	);

// This function parses as many cards as possible, in sequence, until EOF
// is reached or a fatal syntax error occurs.  It returns TRUE if it
// successfully parsed at least one card, and in this case the file's
// seek position is left where the parser stopped (at EOF or a syntax
// error).  If FALSE is returned, the file's seek position is reset
// back to where it was when this function was invoked.
extern BOOL Parse_Many_MSV_FromFile(
	CFile *file,		/* In */
	CList *vcList		/* Out: CVCard objects added to existing list */
	);

#ifdef __cplusplus
};
#endif

#endif // __MSV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\proplocb.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// proplocb.cpp : implementation file
//

#include "stdafx.h"
#include "VC.h"
#include "proplocb.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropLocBasic property page

IMPLEMENT_DYNCREATE(CPropLocBasic, CPropertyPage)

CPropLocBasic::CPropLocBasic() : CPropertyPage(CPropLocBasic::IDD)
{
	//{{AFX_DATA_INIT(CPropLocBasic)
	m_button_home = FALSE;
	m_edit_location = _T("");
	m_button_office = FALSE;
	m_button_parcel = FALSE;
	m_button_postal = FALSE;
	m_edit_postdom = _T("");
	m_edit_postintl = _T("");
	m_edit_timezone = _T("");
	//}}AFX_DATA_INIT

	m_nodeloc = m_nodetz = m_nodepostdom = m_nodepostintl = NULL;
}

CPropLocBasic::~CPropLocBasic()
{
}

void CPropLocBasic::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropLocBasic)
	DDX_Check(pDX, IDC_EDIT_HOME, m_button_home);
	DDX_Text(pDX, IDC_EDIT_LOCATION, m_edit_location);
	DDX_Check(pDX, IDC_EDIT_OFFICE, m_button_office);
	DDX_Check(pDX, IDC_EDIT_PARCEL, m_button_parcel);
	DDX_Check(pDX, IDC_EDIT_POSTAL, m_button_postal);
	DDX_Text(pDX, IDC_EDIT_POSTDOM, m_edit_postdom);
	DDX_Text(pDX, IDC_EDIT_POSTINTL, m_edit_postintl);
	DDX_Text(pDX, IDC_EDIT_TIME_ZONE, m_edit_timezone);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropLocBasic, CPropertyPage)
	//{{AFX_MSG_MAP(CPropLocBasic)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPropLocBasic message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\parse.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#ifndef __PARSE_H__
#define __PARSE_H__

extern const char* vcDefaultLang;

extern const char* vcISO9070Prefix;
extern const char* vcClipboardFormatVCard;

extern const char* vcISO639Type;
extern const char* vcStrIdxType;
extern const char* vcFlagsType;
extern const char* vcNextObjectType;
extern const char* vcNullType;

// These three types have __huge values
extern const char* vcOctetsType;
extern const char* vcGIFType;
extern const char* vcWAVType;

extern const char* vcRootObject;
extern const char* vcBodyObject;
extern const char* vcPartObject;
extern const char* vcBodyProp;
extern const char* vcPartProp;
extern const char* vcNextObjectProp;

extern const char* vcLogoProp;
extern const char* vcPhotoProp;
extern const char* vcDeliveryLabelProp;
extern const char* vcPostalBoxProp;
extern const char* vcStreetAddressProp;
extern const char* vcExtAddressProp;
extern const char* vcCountryNameProp;
extern const char* vcPostalCodeProp;
extern const char* vcRegionProp;
extern const char* vcCityProp;
extern const char* vcFullNameProp;
extern const char* vcTitleProp;
extern const char* vcOrgNameProp;
extern const char* vcOrgUnitProp;
extern const char* vcOrgUnit2Prop;
extern const char* vcOrgUnit3Prop;
extern const char* vcOrgUnit4Prop;
extern const char* vcFamilyNameProp;
extern const char* vcGivenNameProp;
extern const char* vcAdditionalNamesProp;
extern const char* vcNamePrefixesProp;
extern const char* vcNameSuffixesProp;
extern const char* vcPronunciationProp;
extern const char* vcLanguageProp;
extern const char* vcTelephoneProp;
extern const char* vcEmailAddressProp;
extern const char* vcTimeZoneProp;
extern const char* vcLocationProp;
extern const char* vcCommentProp;
extern const char* vcCharSetProp;
extern const char* vcLastRevisedProp;
extern const char* vcUniqueStringProp;
extern const char* vcPublicKeyProp;
extern const char* vcMailerProp;
extern const char* vcAgentProp;
extern const char* vcBirthDateProp;
extern const char* vcBusinessRoleProp;
extern const char* vcCaptionProp;
extern const char* vcURLProp;

extern const char* vcDomesticProp;
extern const char* vcInternationalProp;
extern const char* vcPostalProp;
extern const char* vcParcelProp;
extern const char* vcHomeProp;
extern const char* vcWorkProp;
extern const char* vcPreferredProp;
extern const char* vcVoiceProp;
extern const char* vcFaxProp;
extern const char* vcMessageProp;
extern const char* vcCellularProp;
extern const char* vcPagerProp;
extern const char* vcBBSProp;
extern const char* vcModemProp;
extern const char* vcCarProp;
extern const char* vcISDNProp;
extern const char* vcVideoProp;

extern const char* vcInlineProp;
extern const char* vcURLValueProp;
extern const char* vcContentIDProp;

extern const char* vc7bitProp;
extern const char* vcQuotedPrintableProp;
extern const char* vcBase64Prop;

extern const char* vcAOLProp;
extern const char* vcAppleLinkProp;
extern const char* vcATTMailProp;
extern const char* vcCISProp;
extern const char* vcEWorldProp;
extern const char* vcInternetProp;
extern const char* vcIBMMailProp;
extern const char* vcMSNProp;
extern const char* vcMCIMailProp;
extern const char* vcPowerShareProp;
extern const char* vcProdigyProp;
extern const char* vcTLXProp;
extern const char* vcX400Prop;

extern const char* vcGIFProp;
extern const char* vcCGMProp;
extern const char* vcWMFProp;
extern const char* vcBMPProp;
extern const char* vcMETProp;
extern const char* vcPMBProp;
extern const char* vcDIBProp;
extern const char* vcPICTProp;
extern const char* vcTIFFProp;
extern const char* vcAcrobatProp;
extern const char* vcPSProp;
extern const char* vcJPEGProp;
extern const char* vcQuickTimeProp;
extern const char* vcMPEGProp;
extern const char* vcMPEG2Prop;
extern const char* vcAVIProp;

extern const char* vcWAVEProp;
extern const char* vcAIFFProp;
extern const char* vcPCMProp;

extern const char* vcX509Prop;
extern const char* vcPGPProp;

extern const char* vcNodeNameProp;

#endif // __PARSE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\proplocx.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// proplocx.cpp : implementation file
//

#include "stdafx.h"
#include "VC.h"
#include "proplocx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropLocX property page

IMPLEMENT_DYNCREATE(CPropLocX, CPropertyPage)

CPropLocX::CPropLocX() : CPropertyPage(CPropLocX::IDD)
{
	//{{AFX_DATA_INIT(CPropLocX)
	m_edit_city = _T("");
	m_edit_cntry = _T("");
	m_edit_xaddr = _T("");
	m_edit_pobox = _T("");
	m_edit_pocode = _T("");
	m_edit_region = _T("");
	m_edit_straddr = _T("");
	//}}AFX_DATA_INIT

	m_node = NULL;
}

CPropLocX::~CPropLocX()
{
}

void CPropLocX::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropLocX)
	DDX_Text(pDX, IDC_EDIT_CITY, m_edit_city);
	DDX_Text(pDX, IDC_EDIT_COUNTRY_NAME, m_edit_cntry);
	DDX_Text(pDX, IDC_EDIT_EXTENDED_ADDRESS, m_edit_xaddr);
	DDX_Text(pDX, IDC_EDIT_POSTAL_BOX, m_edit_pobox);
	DDX_Text(pDX, IDC_EDIT_POSTAL_CODE, m_edit_pocode);
	DDX_Text(pDX, IDC_EDIT_REGION, m_edit_region);
	DDX_Text(pDX, IDC_EDIT_STREET_ADDRESS, m_edit_straddr);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropLocX, CPropertyPage)
	//{{AFX_MSG_MAP(CPropLocX)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPropLocX message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\proptel.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// proptel.cpp : implementation file
//

#include "stdafx.h"
#include "VC.h"
#include "proptel.h"
#include "tapi.h"
#include "vcard.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropTel property page

IMPLEMENT_DYNCREATE(CPropTel, CPropertyPage)

CPropTel::CPropTel() : CPropertyPage(CPropTel::IDD)
{
	//{{AFX_DATA_INIT(CPropTel)
	m_button_fax1 = FALSE;
	m_button_fax2 = FALSE;
	m_button_fax3 = FALSE;
	m_edit_fullName1 = _T("");
	m_edit_fullName2 = _T("");
	m_edit_fullName3 = _T("");
	m_button_home1 = FALSE;
	m_button_home2 = FALSE;
	m_button_home3 = FALSE;
	m_button_message1 = FALSE;
	m_button_message2 = FALSE;
	m_button_message3 = FALSE;
	m_button_office1 = FALSE;
	m_button_office2 = FALSE;
	m_button_office3 = FALSE;
	m_button_pref1 = FALSE;
	m_button_pref2 = FALSE;
	m_button_pref3 = FALSE;
	m_button_cell1 = FALSE;
	m_button_cell2 = FALSE;
	m_button_cell3 = FALSE;
	//}}AFX_DATA_INIT

	m_node1 = m_node2 = m_node3 = NULL;
}

CPropTel::~CPropTel()
{
}

void CPropTel::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropTel)
	DDX_Check(pDX, IDC_EDIT_FAX, m_button_fax1);
	DDX_Check(pDX, IDC_EDIT_FAX2, m_button_fax2);
	DDX_Check(pDX, IDC_EDIT_FAX3, m_button_fax3);
	DDX_Text(pDX, IDC_EDIT_FULL_NAME, m_edit_fullName1);
	DDX_Text(pDX, IDC_EDIT_FULL_NAME2, m_edit_fullName2);
	DDX_Text(pDX, IDC_EDIT_FULL_NAME3, m_edit_fullName3);
	DDX_Check(pDX, IDC_EDIT_HOME, m_button_home1);
	DDX_Check(pDX, IDC_EDIT_HOME2, m_button_home2);
	DDX_Check(pDX, IDC_EDIT_HOME3, m_button_home3);
	DDX_Check(pDX, IDC_EDIT_MESSAGE, m_button_message1);
	DDX_Check(pDX, IDC_EDIT_MESSAGE2, m_button_message2);
	DDX_Check(pDX, IDC_EDIT_MESSAGE3, m_button_message3);
	DDX_Check(pDX, IDC_EDIT_OFFICE, m_button_office1);
	DDX_Check(pDX, IDC_EDIT_OFFICE2, m_button_office2);
	DDX_Check(pDX, IDC_EDIT_OFFICE3, m_button_office3);
	DDX_Check(pDX, IDC_EDIT_PREFERRED, m_button_pref1);
	DDX_Check(pDX, IDC_EDIT_PREFERRED2, m_button_pref2);
	DDX_Check(pDX, IDC_EDIT_PREFERRED3, m_button_pref3);
	DDX_Check(pDX, IDC_EDIT_CELLULAR, m_button_cell1);
	DDX_Check(pDX, IDC_EDIT_CELLULAR2, m_button_cell2);
	DDX_Check(pDX, IDC_EDIT_CELLULAR3, m_button_cell3);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropTel, CPropertyPage)
	//{{AFX_MSG_MAP(CPropTel)
	ON_BN_CLICKED(IDC_BUTTON_DIAL, OnButtonDial1)
	ON_BN_CLICKED(IDC_BUTTON_DIAL2, OnButtonDial2)
	ON_BN_CLICKED(IDC_BUTTON_DIAL3, OnButtonDial3)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPropTel message handlers

void CPropTel::OnButtonDial1() 
{
	if (m_edit_fullName1.IsEmpty())
		return;

	CString fullName("");
	CVCProp *prop;

	if ((prop = m_body->GetProp(VCFullNameProp))) {
		char buf[1024];
		fullName = UI_CString(
			(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
	}

	tapiRequestMakeCall(
		m_edit_fullName1, NULL,
		fullName.IsEmpty() ? NULL : fullName, NULL);
}

void CPropTel::OnButtonDial2() 
{
	if (m_edit_fullName2.IsEmpty())
		return;

	CString fullName("");
	CVCProp *prop;

	if ((prop = m_body->GetProp(VCFullNameProp))) {
		char buf[1024];
		fullName = UI_CString(
			(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
	}

	tapiRequestMakeCall(
		m_edit_fullName2, NULL,
		fullName.IsEmpty() ? NULL : fullName, NULL);
}

void CPropTel::OnButtonDial3() 
{
	if (m_edit_fullName3.IsEmpty())
		return;

	CString fullName("");
	CVCProp *prop;

	if ((prop = m_body->GetProp(VCFullNameProp))) {
		char buf[1024];
		fullName = UI_CString(
			(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
	}

	tapiRequestMakeCall(
		m_edit_fullName3, NULL,
		fullName.IsEmpty() ? NULL : fullName, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\prp_comp.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// prp_comp.cpp : implementation file
//

#include "stdafx.h"
#include "VC.h"
#include "prp_comp.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropCompany property page

IMPLEMENT_DYNCREATE(CPropCompany, CPropertyPage)

CPropCompany::CPropCompany() : CPropertyPage(CPropCompany::IDD)
{
	//{{AFX_DATA_INIT(CPropCompany)
	m_edit_orgname = _T("");
	m_edit_orgunit = _T("");
	m_edit_title = _T("");
	//}}AFX_DATA_INIT
	m_nodeOrg = NULL;
	m_nodeTitle = NULL;
}

CPropCompany::~CPropCompany()
{
}

void CPropCompany::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropCompany)
	DDX_Text(pDX, IDC_EDIT_ORGNAME, m_edit_orgname);
	DDX_Text(pDX, IDC_EDIT_ORGUNIT, m_edit_orgunit);
	DDX_Text(pDX, IDC_EDIT_TITLE, m_edit_title);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropCompany, CPropertyPage)
	//{{AFX_MSG_MAP(CPropCompany)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPropCompany message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\proplocb.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// proplocb.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPropLocBasic dialog

class CVCNode;

class CPropLocBasic : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropLocBasic)

// Construction
public:
	CPropLocBasic();
	~CPropLocBasic();

// Dialog Data
	//{{AFX_DATA(CPropLocBasic)
	enum { IDD = IDD_PROP_LOCATION_BASIC };
	BOOL	m_button_home;
	CString	m_edit_location;
	BOOL	m_button_office;
	BOOL	m_button_parcel;
	BOOL	m_button_postal;
	CString	m_edit_postdom;
	CString	m_edit_postintl;
	CString	m_edit_timezone;
	//}}AFX_DATA

	CVCNode *m_nodeloc, *m_nodetz, *m_nodepostdom, *m_nodepostintl;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropLocBasic)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPropLocBasic)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\proplocx.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// proplocx.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPropLocX dialog

class CVCNode;

class CPropLocX : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropLocX)

// Construction
public:
	CPropLocX();
	~CPropLocX();

// Dialog Data
	//{{AFX_DATA(CPropLocX)
	enum { IDD = IDD_LOCATION_EXTENDED };
	CString	m_edit_city;
	CString	m_edit_cntry;
	CString	m_edit_xaddr;
	CString	m_edit_pobox;
	CString	m_edit_pocode;
	CString	m_edit_region;
	CString	m_edit_straddr;
	//}}AFX_DATA

	CVCNode *m_node;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropLocX)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPropLocX)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\prp_pers.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// prp_pers.cpp : implementation file
//

#include "stdafx.h"
#include "VC.h"
#include "prp_pers.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropPers property page

IMPLEMENT_DYNCREATE(CPropPers, CPropertyPage)

CPropPers::CPropPers() : CPropertyPage(CPropPers::IDD)
{
	//{{AFX_DATA_INIT(CPropPers)
	m_edit_famname = _T("");
	m_edit_fullname = _T("");
	m_edit_givenname = _T("");
	m_edit_pronun = _T("");
	//}}AFX_DATA_INIT

	m_nodeName = NULL;
	m_nodeFullName = NULL;
	m_nodePronun = NULL;
}

CPropPers::~CPropPers()
{
}

void CPropPers::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropPers)
	DDX_Text(pDX, IDC_EDIT_FAMILY_NAME, m_edit_famname);
	DDX_Text(pDX, IDC_EDIT_FULL_NAME, m_edit_fullname);
	DDX_Text(pDX, IDC_EDIT_GIVEN_NAME, m_edit_givenname);
	DDX_Text(pDX, IDC_EDIT_PRONUNCIATION, m_edit_pronun);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropPers, CPropertyPage)
	//{{AFX_MSG_MAP(CPropPers)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPropPers message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\prp_comp.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// prp_comp.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPropCompany dialog

class CVCNode;

class CPropCompany : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropCompany)

// Construction
public:
	CPropCompany();
	~CPropCompany();

// Dialog Data
	//{{AFX_DATA(CPropCompany)
	enum { IDD = IDD_PROP_COMPANY };
	CString	m_edit_orgname;
	CString	m_edit_orgunit;
	CString	m_edit_title;
	//}}AFX_DATA

	CVCNode *m_nodeOrg;
	CVCNode *m_nodeTitle;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropCompany)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPropCompany)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\prp_pers.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// prp_pers.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPropPers dialog

class CVCNode;

class CPropPers : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropPers)

// Construction
public:
	CPropPers();
	~CPropPers();

// Dialog Data
	//{{AFX_DATA(CPropPers)
	enum { IDD = IDD_PROP_NAME };
	CString	m_edit_famname;
	CString	m_edit_fullname;
	CString	m_edit_givenname;
	CString	m_edit_pronun;
	//}}AFX_DATA

	CVCNode *m_nodeName;
	CVCNode *m_nodeFullName;
	CVCNode *m_nodePronun;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropPers)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPropPers)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\proptel.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// proptel.h : header file
//

class CVCNode;

/////////////////////////////////////////////////////////////////////////////
// CPropTel dialog

class CPropTel : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropTel)

// Construction
public:
	CPropTel();
	~CPropTel();

	CVCNode *m_body;

// Dialog Data
	//{{AFX_DATA(CPropTel)
	enum { IDD = IDD_TELEPHONES };
	BOOL	m_button_fax1;
	BOOL	m_button_fax2;
	BOOL	m_button_fax3;
	CString	m_edit_fullName1;
	CString	m_edit_fullName2;
	CString	m_edit_fullName3;
	BOOL	m_button_home1;
	BOOL	m_button_home2;
	BOOL	m_button_home3;
	BOOL	m_button_message1;
	BOOL	m_button_message2;
	BOOL	m_button_message3;
	BOOL	m_button_office1;
	BOOL	m_button_office2;
	BOOL	m_button_office3;
	BOOL	m_button_pref1;
	BOOL	m_button_pref2;
	BOOL	m_button_pref3;
	BOOL	m_button_cell1;
	BOOL	m_button_cell2;
	BOOL	m_button_cell3;
	//}}AFX_DATA

	CVCNode *m_node1, *m_node2, *m_node3;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropTel)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPropTel)
	afx_msg void OnButtonDial1();
	afx_msg void OnButtonDial2();
	afx_msg void OnButtonDial3();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\ref.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#ifndef __REF_H__
#define __REF_H__

/* The following pragma is compiler specific. The objective is to obtain
*  "packed" structures as defined in the section of the specification
*  dealing with "Bit-Level Data Representation". You may have to change
*  this pragma, set compiler options, or edit the declarations in this file
*  to achieve the same effect.
*/
#pragma pack(1)

#define	VCISO9070Prefix			"+//ISBN 1-887687-00-9::versit::PDI//"
#define	VCClipboardFormatVCard	"+//ISBN 1-887687-00-9::versit::PDI//vCard"

#define	VCISO639Type			"+//ISBN 1-887687-00-9::versit::PDI//ISO639Type"
#define	VCStrIdxType			"+//ISBN 1-887687-00-9::versit::PDI//StrIdxType"
#define	VCFlagsType				"+//ISBN 1-887687-00-9::versit::PDI//FlagsType"
#define	VCNextObjectType		"+//ISBN 1-887687-00-9::versit::PDI//NextType"
#define	VCOctetsType 			"+//ISBN 1-887687-00-9::versit::PDI//OctetsType"
#define	VCGIFType				"+//ISBN 1-887687-00-9::versit::PDI//GIFType"
#define VCWAVType				"+//ISBN 1-887687-00-9::versit::PDI//WAVType"
#define	VCNullType 				"+//ISBN 1-887687-00-9::versit::PDI//NULL"

#define	VCRootObject			"+//ISBN 1-887687-00-9::versit::PDI//RootObj"
#define	VCBodyObject			"+//ISBN 1-887687-00-9::versit::PDI//BodyObj"
#define	VCPartObject			"+//ISBN 1-887687-00-9::versit::PDI//PartObj"
#define	VCBodyProp				"+//ISBN 1-887687-00-9::versit::PDI//Body"
#define	VCPartProp				"+//ISBN 1-887687-00-9::versit::PDI//Part"
#define	VCNextObjectProp		"+//ISBN 1-887687-00-9::versit::PDI//Object"

#define	VCLogoProp				"+//ISBN 1-887687-00-9::versit::PDI//LOGO"
#define	VCPhotoProp				"+//ISBN 1-887687-00-9::versit::PDI//PHOTO"
#define	VCDeliveryLabelProp     "+//ISBN 1-887687-00-9::versit::PDI//LABEL"
#define	VCPostalBoxProp			"+//ISBN 1-887687-00-9::versit::PDI//BOX"
#define	VCStreetAddressProp		"+//ISBN 1-887687-00-9::versit::PDI//STREET"
#define	VCExtAddressProp		"+//ISBN 1-887687-00-9::versit::PDI//EXT ADD"
#define	VCCountryNameProp		"+//ISBN 1-887687-00-9::versit::PDI//C"
#define	VCPostalCodeProp		"+//ISBN 1-887687-00-9::versit::PDI//PC"
#define	VCRegionProp			"+//ISBN 1-887687-00-9::versit::PDI//R"
#define	VCCityProp				"+//ISBN 1-887687-00-9::versit::PDI//L"
#define	VCFullNameProp			"+//ISBN 1-887687-00-9::versit::PDI//FN"
#define	VCTitleProp				"+//ISBN 1-887687-00-9::versit::PDI//TITLE"
#define	VCOrgNameProp			"+//ISBN 1-887687-00-9::versit::PDI//ORG"
#define	VCOrgUnitProp			"+//ISBN 1-887687-00-9::versit::PDI//OUN"
#define	VCOrgUnit2Prop			"+//ISBN 1-887687-00-9::versit::PDI//OUN2"
#define	VCOrgUnit3Prop			"+//ISBN 1-887687-00-9::versit::PDI//OUN3"
#define	VCOrgUnit4Prop			"+//ISBN 1-887687-00-9::versit::PDI//OUN4"
#define	VCFamilyNameProp		"+//ISBN 1-887687-00-9::versit::PDI//F"
#define	VCGivenNameProp			"+//ISBN 1-887687-00-9::versit::PDI//G"
#define	VCAdditionalNamesProp	"+//ISBN 1-887687-00-9::versit::PDI//ADDN"
#define	VCNamePrefixesProp		"+//ISBN 1-887687-00-9::versit::PDI//NPRE"
#define	VCNameSuffixesProp		"+//ISBN 1-887687-00-9::versit::PDI//NSUF"
#define	VCPronunciationProp		"+//ISBN 1-887687-00-9::versit::PDI//SOUND"
#define	VCLanguageProp			"+//ISBN 1-887687-00-9::versit::PDI//LANG"
#define	VCTelephoneProp			"+//ISBN 1-887687-00-9::versit::PDI//TEL"
#define	VCEmailAddressProp		"+//ISBN 1-887687-00-9::versit::PDI//EMAIL"
#define	VCTimeZoneProp			"+//ISBN 1-887687-00-9::versit::PDI//TZ"
#define	VCLocationProp			"+//ISBN 1-887687-00-9::versit::PDI//GEO"
#define	VCCommentProp			"+//ISBN 1-887687-00-9::versit::PDI//NOTE"
#define	VCCharSetProp			"+//ISBN 1-887687-00-9::versit::PDI//CS"
#define	VCLastRevisedProp		"+//ISBN 1-887687-00-9::versit::PDI//REV"
#define	VCUniqueStringProp		"+//ISBN 1-887687-00-9::versit::PDI//UID"
#define	VCPublicKeyProp			"+//ISBN 1-887687-00-9::versit::PDI//KEY"
#define	VCMailerProp			"+//ISBN 1-887687-00-9::versit::PDI//MAILER"
#define	VCAgentProp				"+//ISBN 1-887687-00-9::versit::PDI//AGENT"
#define	VCBirthDateProp			"+//ISBN 1-887687-00-9::versit::PDI//BDAY"
#define	VCBusinessRoleProp		"+//ISBN 1-887687-00-9::versit::PDI//ROLE"
#define	VCCaptionProp			"+//ISBN 1-887687-00-9::versit::PDI//CAP"
#define	VCURLProp				"+//ISBN 1-887687-00-9::versit::PDI//URL"

#define	VCDomesticProp			"+//ISBN 1-887687-00-9::versit::PDI//DOM"
#define	VCInternationalProp		"+//ISBN 1-887687-00-9::versit::PDI//INTL"
#define	VCPostalProp			"+//ISBN 1-887687-00-9::versit::PDI//POSTAL"
#define	VCParcelProp			"+//ISBN 1-887687-00-9::versit::PDI//PARCEL"
#define	VCHomeProp				"+//ISBN 1-887687-00-9::versit::PDI//HOME"
#define	VCWorkProp				"+//ISBN 1-887687-00-9::versit::PDI//WORK"
#define	VCPreferredProp			"+//ISBN 1-887687-00-9::versit::PDI//PREF"
#define	VCVoiceProp				"+//ISBN 1-887687-00-9::versit::PDI//VOICE"
#define	VCFaxProp				"+//ISBN 1-887687-00-9::versit::PDI//FAX"
#define	VCMessageProp			"+//ISBN 1-887687-00-9::versit::PDI//MSG"
#define	VCCellularProp			"+//ISBN 1-887687-00-9::versit::PDI//CELL"
#define	VCPagerProp				"+//ISBN 1-887687-00-9::versit::PDI//PAGER"
#define	VCBBSProp				"+//ISBN 1-887687-00-9::versit::PDI//BBS"
#define	VCModemProp				"+//ISBN 1-887687-00-9::versit::PDI//MODEM"
#define	VCCarProp				"+//ISBN 1-887687-00-9::versit::PDI//CAR"
#define	VCISDNProp				"+//ISBN 1-887687-00-9::versit::PDI//ISDN"
#define	VCVideoProp				"+//ISBN 1-887687-00-9::versit::PDI//VIDEO"

#define	VCInlineProp			"+//ISBN 1-887687-00-9::versit::PDI//INLINE"
#define	VCURLValueProp			"+//ISBN 1-887687-00-9::versit::PDI//URLVAL"
#define	VCContentIDProp			"+//ISBN 1-887687-00-9::versit::PDI//CONTENT-ID"

#define	VC7bitProp				"+//ISBN 1-887687-00-9::versit::PDI//7BIT"
#define	VCQuotedPrintableProp	"+//ISBN 1-887687-00-9::versit::PDI//QP"
#define	VCBase64Prop			"+//ISBN 1-887687-00-9::versit::PDI//BASE64"

#define	VCAOLProp				"+//ISBN 1-887687-00-9::versit::PDI//AOL"
#define	VCAppleLinkProp			"+//ISBN 1-887687-00-9::versit::PDI//AppleLink"
#define	VCATTMailProp			"+//ISBN 1-887687-00-9::versit::PDI//ATTMail"
#define	VCCISProp				"+//ISBN 1-887687-00-9::versit::PDI//CIS"
#define	VCEWorldProp			"+//ISBN 1-887687-00-9::versit::PDI//eWorld"
#define	VCInternetProp			"+//ISBN 1-887687-00-9::versit::PDI//INTERNET"
#define	VCIBMMailProp			"+//ISBN 1-887687-00-9::versit::PDI//IBMMail"
#define	VCMSNProp				"+//ISBN 1-887687-00-9::versit::PDI//MSN"
#define	VCMCIMailProp			"+//ISBN 1-887687-00-9::versit::PDI//MCIMail"
#define	VCPowerShareProp		"+//ISBN 1-887687-00-9::versit::PDI//POWERSHARE"
#define	VCProdigyProp			"+//ISBN 1-887687-00-9::versit::PDI//Prodigy"
#define	VCTLXProp				"+//ISBN 1-887687-00-9::versit::PDI//TLX"
#define	VCX400Prop				"+//ISBN 1-887687-00-9::versit::PDI//X400"

#define	VCGIFProp				"+//ISBN 1-887687-00-9::versit::PDI//GIF"
#define	VCCGMProp				"+//ISBN 1-887687-00-9::versit::PDI//CGM"
#define	VCWMFProp				"+//ISBN 1-887687-00-9::versit::PDI//WMF"
#define	VCBMPProp				"+//ISBN 1-887687-00-9::versit::PDI//BMP"
#define	VCMETProp				"+//ISBN 1-887687-00-9::versit::PDI//MET"
#define	VCPMBProp				"+//ISBN 1-887687-00-9::versit::PDI//PMB"
#define	VCDIBProp				"+//ISBN 1-887687-00-9::versit::PDI//DIB"
#define	VCPICTProp				"+//ISBN 1-887687-00-9::versit::PDI//PICT"
#define	VCTIFFProp				"+//ISBN 1-887687-00-9::versit::PDI//TIFF"
#define	VCAcrobatProp			"+//ISBN 1-887687-00-9::versit::PDI//ACROBAT"
#define	VCPSProp				"+//ISBN 1-887687-00-9::versit::PDI//PS"
#define	VCJPEGProp				"+//ISBN 1-887687-00-9::versit::PDI//JPEG"
#define	VCQuickTimeProp			"+//ISBN 1-887687-00-9::versit::PDI//QTIME"
#define	VCMPEGProp				"+//ISBN 1-887687-00-9::versit::PDI//MPEG"
#define	VCMPEG2Prop				"+//ISBN 1-887687-00-9::versit::PDI//MPEG2"
#define	VCAVIProp				"+//ISBN 1-887687-00-9::versit::PDI//AVI"

#define	VCWAVEProp				"+//ISBN 1-887687-00-9::versit::PDI//WAVE"
#define	VCAIFFProp				"+//ISBN 1-887687-00-9::versit::PDI//AIFF"
#define	VCPCMProp				"+//ISBN 1-887687-00-9::versit::PDI//PCM"

#define	VCX509Prop				"+//ISBN 1-887687-00-9::versit::PDI//X509"
#define	VCPGPProp				"+//ISBN 1-887687-00-9::versit::PDI//PGP"

#define	VCNodeNameProp			"+//ISBN 1-887687-00-9::versit::PDI//NodeName"


/* Currently Unused, and To Be Removed

#define	VCListObject			"+//ISBN 1-887687-00-9::versit::PDI//LIST"
#define VCStringDataObject		"+//ISBN 1-887687-00-9::versit::PDI//StringDataObj"
#define VCStringDataLSBProp		"+//ISBN 1-887687-00-9::versit::PDI//StringDataLSB"
#define VCStringDataMSBProp		"+//ISBN 1-887687-00-9::versit::PDI//StringDataMSB"
#define	VCMsgProp				"+//ISBN 1-887687-00-9::versit::PDI//MSG"
#define	VCEncryptionProp		"+//ISBN 1-887687-00-9::versit::PDI//KEY"
#define	VCNextObjectProp		"+//ISBN 1-887687-00-9::versit::PDI//NextObject"
#define	VCMyReferenceProp		"+//ISBN 1-887687-00-9::versit::PDI//M"
#define	VCYourReferenceProp		"+//ISBN 1-887687-00-9::versit::PDI//Y"

#define VCCharSetType			"+//ISBN 1-887687-00-9::versit::PDI//CharSetType"
#define	VCReferenceType			"+//ISBN 1-887687-00-9::versit::PDI//ReferenceType"
#define VCLocationType			"+//ISBN 1-887687-00-9::versit::PDI//LocationType"
*/

typedef enum {
	VC_EMAIL_NONE = 0,
	VC_AOL, VC_AppleLink, VC_ATTMail, VC_CIS, VC_eWorld, VC_INTERNET, VC_IBMMail, VC_MSN, VC_MCIMail,
	VC_POWERSHARE, VC_PRODIGY, VC_TLX, VC_X400
} VC_EMAIL_TYPE;

typedef enum {
	VC_VIDEO_NONE = 0,
	VC_GIF, VC_CGM, VC_WMF, VC_BMP, VC_MET, VC_PMB, VC_DIB, VC_PICT, VC_TIFF, VC_ACROBAT, VC_PS
} VC_VIDEO_TYPE;

typedef enum {
	VC_AUDIO_NONE = 0,
	VC_WAV
} VC_AUDIO_TYPE;

typedef struct {
	unsigned long general;
	VC_EMAIL_TYPE email;
	VC_AUDIO_TYPE audio;
	VC_VIDEO_TYPE video;
} VC_FLAGS, * VC_PTR_FLAGS;

// General flags
#define VC_DOM           ((unsigned long)0x00000001) 
#define VC_INTL			 ((unsigned long)0x00000002) 
#define VC_POSTAL        ((unsigned long)0x00000004) 
#define VC_PARCEL        ((unsigned long)0x00000008) 
#define VC_HOME          ((unsigned long)0x00000010) 
#define VC_WORK			 ((unsigned long)0x00000020) 
#define VC_PREF          ((unsigned long)0x00000040) 
#define VC_VOICE         ((unsigned long)0x00000080) 
#define VC_FAX           ((unsigned long)0x00000100) 
#define VC_MSG           ((unsigned long)0x00000200) 
#define VC_CELL          ((unsigned long)0x00000400) 
#define VC_PAGER         ((unsigned long)0x00000800) 
#define VC_BBS           ((unsigned long)0x00001000) 
#define VC_MODEM         ((unsigned long)0x00002000) 
#define VC_CAR           ((unsigned long)0x00004000) 
#define VC_ISDN          ((unsigned long)0x00008000) 
#define VC_VIDEO         ((unsigned long)0x00010000) 
#define VC_BASE64        ((unsigned long)0x00020000) 
#define VC_HEX           ((unsigned long)0x00040000) 
#define VC_UUENCODE      ((unsigned long)0x00080000) 


// stuff added for the demo code

#define	VCDisplayInfoTextType "+//ISBN 1-887687-00-9::versit::PDI//EXTENSION//DisplayInfoText"
#define	VCDisplayInfoGIFType "+//ISBN 1-887687-00-9::versit::PDI//EXTENSION//DisplayInfoGIF"
#define	VCDisplayInfoProp  		"+//ISBN 1-887687-00-9::versit::PDI//EXTENSION//DisplayInfoProp"

#define VC_LEFT 		1
#define VC_CENTER  	(~0)
#define VC_RIGHT 		3

#define VC_CLASSIC 	1
#define VC_MODERN 	2
#define VC_BOLD		 	1
#define VC_ITALIC 	2

typedef struct 									// VCDisplayInfoTextType
{
  signed short  	x,y;					// absolute position or VC_CENTER
	unsigned char		typeSize,			// range of 6..144, units are points
									textAlign,		// VC_LEFT, VC_CENTER or VC_RIGHT
									textClass,		// VC_CLASSIC or VC_MODERN
									textAttrs;		// VC_BOLD | VC_ITALIC

} VC_DISPTEXT, * VC_PTR_DISPTEXT;

typedef struct 										// VCDisplayInfoTIFFType
{
  signed short  	left, bottom, right, top;
  BOOL				hasMask;

} VC_DISPGIF, * VC_PTR_DISPGIF;

#pragma pack()

#endif // __REF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by VC.rc
//
#define IDR_VCTYPE_SRVR_IP              4
#define IDR_VCTYPE_SRVR_EMB             5
#define IDR_VCTYPE_CNTR_IP              6
#define IDD_ABOUTBOX                    100
#define IDP_OLE_INIT_FAILED             100
#define IDP_FAILED_TO_CREATE            102
#define IDP_SOCKETS_INIT_FAILED         104
#define IDR_MAINFRAME                   128
#define IDR_VCTYPE                      129
#define IDD_PROP_PERS                   130
#define IDD_PROP_NAME                   130
#define IDD_PROP_CO                     131
#define IDD_PROP_COMPANY                131
#define IDD_PROP_LOCATION_BASIC         132
#define IDD_LOCATION_EXTENDED           133
#define IDD_TELEPHONES                  134
#define IDD_EMAIL_ADDRESS               135
#define IDD_DIALOG_COMM                 137
#define IDB_PRONUN_U                    139
#define IDB_PRONUN_D                    140
#define IDD_DIALOG_CALLCENTER           142
#define IDC_EDIT_FULLNAME               1000
#define IDC_EDIT_FULL_NAME              1000
#define IDC_EDIT_FIRSTNAME              1000
#define IDC_EDIT_FAMNAME                1001
#define IDC_EDIT_FAMILY_NAME            1001
#define IDC_EDIT_FULL_NAME2             1001
#define IDC_EDIT_LASTNAME               1001
#define IDC_EDIT_GIVENNAME              1002
#define IDC_EDIT_GIVEN_NAME             1002
#define IDC_EDIT_FULL_NAME3             1002
#define IDC_EDIT_ADDRSTREET             1002
#define IDC_EDIT_TITLE                  1003
#define IDC_EDIT_PRONUNCIATION          1003
#define IDC_EDIT_ADDRCITY               1003
#define IDC_EDIT_ORGUNIT                1004
#define IDC_EDIT_ADDRSTATE              1004
#define IDC_EDIT_ORGNAME                1005
#define IDC_EDIT_ADDRZIP                1005
#define IDC_EDIT_POSTDOM                1006
#define IDC_EDIT_TELHOME                1006
#define IDC_EDIT_POSTINTL               1007
#define IDC_EDIT_TELWORK                1007
#define IDC_EDIT_TELFAX                 1008
#define IDC_EDIT_EXTENDED_ADDRESS       1009
#define IDC_EDIT_EMPLOYER               1009
#define IDC_EDIT_TIME_ZONE              1010
#define IDC_EDIT_CALLERID               1010
#define IDC_EDIT_STREET_ADDRESS         1011
#define IDC_BUTTON_ANSWER               1011
#define IDC_EDIT_CITY                   1012
#define IDC_BUTTON_CLEAR                1012
#define IDC_EDIT_POSTAL_CODE            1013
#define IDC_BUTTON3                     1013
#define IDC_EDIT_REGION                 1014
#define IDC_EDIT_COUNTRY_NAME           1015
#define IDC_EDIT_POSTAL_BOX             1016
#define IDC_EDIT_LOCATION               1017
#define IDC_EDIT_OFFICE                 1018
#define IDC_EDIT_HOME                   1019
#define IDC_EDIT_PARCEL                 1020
#define IDC_EDIT_Voice                  1020
#define IDC_EDIT_OFFICE4                1020
#define IDC_EDIT_CELLULAR               1020
#define IDC_EDIT_POSTAL                 1021
#define IDC_EDIT_MESSAGE                1021
#define IDC_EDIT_EMAIL_STANDARD         1021
#define IDC_EDIT_FAX                    1022
#define IDC_EDIT_EMAIL_STRING           1022
#define IDC_EDIT_PREFERRED              1023
#define IDC_EDIT_OFFICE2                1024
#define IDC_EDIT_EMAIL_STRING2          1024
#define IDC_EDIT_HOME2                  1025
#define IDC_EDIT_Voice2                 1026
#define IDC_EDIT_PREFERRED4             1026
#define IDC_EDIT_CELLULAR2              1026
#define IDC_EDIT_MESSAGE2               1027
#define IDC_EDIT_EMAIL_STANDARD2        1027
#define IDC_EDIT_FAX2                   1028
#define IDC_EDIT_EMAIL_STRING3          1028
#define IDC_EDIT_PREFERRED2             1029
#define IDC_EDIT_OFFICE5                1029
#define IDC_EDIT_OFFICE3                1030
#define IDC_EDIT_HOME4                  1030
#define IDC_EDIT_HOME3                  1031
#define IDC_EDIT_PREFERRED5             1031
#define IDC_EDIT_Voice3                 1032
#define IDC_EDIT_EMAIL_STANDARD3        1032
#define IDC_EDIT_CELLULAR3              1032
#define IDC_EDIT_MESSAGE3               1033
#define IDC_EDIT_FAX3                   1034
#define IDC_EDIT_PREFERRED3             1035
#define IDC_BUTTON_DIAL                 1036
#define IDC_BUTTON_DIAL2                1037
#define IDC_BUTTON_DIAL3                1038
#define IDC_LIST_PORT                   1039
#define IDC_LIST_BAUD                   1040
#define IDC_BUTTON_MAIL                 1043
#define IDC_BUTTON_MAIL2                1044
#define IDC_BUTTON_MAIL3                1045
#define ID_CANCEL_EDIT_CNTR             32768
#define ID_CANCEL_EDIT_SRVR             32769
#define ID_FILE_SAVEAS                  32772
#define ID_EDIT_COPY_SPECIAL            32774
#define ID_EDIT_PROPERTIES              32775
#define ID_INSERT_NAME                  32776
#define ID_INSERT_COMPANY               32777
#define ID_INSERT_ADDRESS               32778
#define ID_INSERT_TEL                   32779
#define ID_INSERT_EMAIL                 32780
#define ID_INSERT_URL                   32781
#define ID_VIEW_OPTIONS                 32782
#define ID_INSERT_PAGE                  32783
#define ID_VIEW_TEXT                    32784
#define ID_VIEW_DEBUG                   32785
#define ID_VIEW_SIMPLEGRAM              32786
#define ID_VIEW_NORMAL                  32787
#define ID_DEBUG_TESTVCCLASSES          32788
#define ID_IRDA_SEND                    32789
#define ID_IRDA_RECEIVE                 32790
#define ID_IRDA_OPTIONS                 32791
#define ID_IRDA_CONNECT                 32792
#define ID_IRDA_DISCONNECT              32793
#define ID_DEBUG_TRACE_PARSER           32794
#define ID_DEBUG_TRACE_COMM             32795
#define ID_EDIT_PASTE_MSV               32796
#define ID_IRDA_SEND_IRLMP              32797
#define ID_INSERT_LOGO                  32798
#define ID_INSERT_PHOTO                 32799
#define ID_INSERT_PRONUN                32800
#define ID_SEND_IRDA                    32801
#define ID_SEND_MAIL                    32811
#define ID_DEBUG_SHOWCALLCENTER         32812

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        143
#define _APS_NEXT_COMMAND_VALUE         32813
#define _APS_NEXT_CONTROL_VALUE         1044
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\stdafx.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// stdafx.cpp : source file that includes just the standard includes
//	VC.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\stdafx.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

//#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vc.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// VC.h : main header file for the VC application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols
#include "vcenv.h"
#include "ref.h"
#include "clist.h"

/////////////////////////////////////////////////////////////////////////////
// CVCApp:
// See VC.cpp for the implementation of this class
//

class CVCApp : public CWinApp
{
public:
	CVCApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVCApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation
	COleTemplateServer m_server;
		// Server object for document creation

	//{{AFX_MSG(CVCApp)
	afx_msg void OnAppAbout();
	afx_msg void OnDebugTestVCClasses();
	afx_msg void OnDebugTraceComm();
	afx_msg void OnUpdateDebugTraceComm(CCmdUI* pCmdUI);
	afx_msg void OnDebugTraceParser();
	afx_msg void OnUpdateDebugTraceParser(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	BOOL ProcessShellCommand(CCommandLineInfo& rCmdInfo);
	void ResetIncomingInfo();
	void ProcessIncomingBytes(const char *bytes, int len);
	long ReceiveCard(LPCTSTR nativePath);

	BOOL CanSendFileViaIR();
	long SendFileViaIR(LPCTSTR nativePath, LPCTSTR asPath, BOOL isCardFile);

protected:
	P_U8 m_incomingHeader; // ex.: "VERSIT/size/checksum/V/lenpath/path..." (all are string representations)
	int m_incomingHeaderLen, m_incomingHeaderMaxLen;
	CString m_incomingPath;
	FILE *m_incomingFile;
	int m_incomingChecksum;
	int m_incomingSize;
	int m_incomingPathLen;
	int m_sizeWritten;
	U32 m_checksumInProgress;
	int m_incomingIsCardFile;
};


/////////////////////////////////////////////////////////////////////////////
extern BOOL traceComm;
extern UINT cf_eCard;

// Simple-minded conversion from UNICODE to char string
extern char *UI_CString(const wchar_t *u, char *dst);

extern VC_DISPTEXT *DisplayInfoForProp(const char *name, VC_DISPTEXT *info);

extern CString FirstEmailPropStr(CList *plist);
extern int VCMatchProp(void *item, void *context);

#define VC_PLAY_BUTTON_ID	2711 // arbitrary
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vc.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// VC.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "VC.h"

#include "MainFrm.h"
#include "ChildFrm.h"
#include "VCDoc.h"
#include "VCView.h"
#include "vcard.h"
#include "vcir.h"
#include "msv.h"
#include "mime.h"
#include "callcntr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BOOL traceComm = FALSE;
IVCServer_IR *vcServer_IR = NULL;
UINT cf_eCard;
extern CCallCenter *callCenter;


/////////////////////////////////////////////////////////////////////////////
// CVCApp

BEGIN_MESSAGE_MAP(CVCApp, CWinApp)
	//{{AFX_MSG_MAP(CVCApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	ON_COMMAND(ID_DEBUG_TESTVCCLASSES, OnDebugTestVCClasses)
	ON_COMMAND(ID_DEBUG_TRACE_COMM, OnDebugTraceComm)
	ON_UPDATE_COMMAND_UI(ID_DEBUG_TRACE_COMM, OnUpdateDebugTraceComm)
	ON_COMMAND(ID_DEBUG_TRACE_PARSER, OnDebugTraceParser)
	ON_UPDATE_COMMAND_UI(ID_DEBUG_TRACE_PARSER, OnUpdateDebugTraceParser)
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVCApp construction

CVCApp::CVCApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
	m_incomingHeader = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CVCApp object

CVCApp theApp;

// This identifier was generated to be statistically unique for your app.
// You may change it if you prefer to choose a specific identifier.

// {3007AD10-D013-11CE-A9E6-000000000000}
static const CLSID clsid =
{ 0x3007ad10, 0xd013, 0x11ce, { 0xa9, 0xe6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 } };

/////////////////////////////////////////////////////////////////////////////
// CVCApp initialization

// create a palette for use on 8-bit display devices

CPalette bubPalette;

LOGPALETTE *bublp;

void InitBubPalette(void)
{
	int i, r, g, b, size;
	
	size = sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * 216);
	i = 0;
	
	bublp = (LOGPALETTE *) new char[size];
	
	for( r=0; r < 6; r++ )
		{
		for( g=0; g < 6; g++ )
			{
			for( b=0; b < 6; b++ )
				{
				bublp->palPalEntry[i].peRed = 51 * r;
				bublp->palPalEntry[i].peGreen = 51 * g;
				bublp->palPalEntry[i].peBlue = 51 * b;
				bublp->palPalEntry[i].peFlags = 4;
				i += 1;
				}
			}
		}
	bublp->palVersion = 0x300;  // GAK!
	bublp->palNumEntries = 216;
	
	bubPalette.CreatePalette(bublp);
}

static BOOL InitVCServer()
{
	// create the vcServer_IR object that we'll drive through OLE automation
	COleException e;
	CLSID clsid;
	if (CLSIDFromProgID(OLESTR("VCIR.VCSERVER"), &clsid) != NOERROR)
	{
		//AfxMessageBox(IDP_UNABLE_TO_CREATE);
		return FALSE;
	}

	vcServer_IR = new IVCServer_IR;

	// try to get the active vcServer_IR before creating a new one
	LPUNKNOWN lpUnk;
	LPDISPATCH lpDispatch;
	if (GetActiveObject(clsid, NULL, &lpUnk) == NOERROR)
	{
		HRESULT hr = lpUnk->QueryInterface(IID_IDispatch, 
			(LPVOID*)&lpDispatch);
		lpUnk->Release();
		if (hr == NOERROR)
			vcServer_IR->AttachDispatch(lpDispatch, TRUE);
	}

	// if not dispatch ptr attached yet, need to create one
	if (vcServer_IR->m_lpDispatch == NULL && 
		!vcServer_IR->CreateDispatch(clsid, &e))
	{
		//AfxMessageBox(IDP_UNABLE_TO_CREATE);
		delete vcServer_IR; vcServer_IR = NULL;
		return FALSE;
	}

	return TRUE;
}

// The default impl for FileOpen doesn't handle file paths that contain
// spaces, since the system doesn't enquote such paths (and so the 
// pieces show up in successive arguments).  This is a more flexible
// approach, but it still won't handle paths that originally had
// more than one space in a row.
BOOL CVCApp::ProcessShellCommand(CCommandLineInfo& rCmdInfo)
{
	if (rCmdInfo.m_nShellCommand == CCommandLineInfo::FileOpen) {
		CString path;
		for (int i = 1; i < __argc; i++) {
			if (*(__argv[i]) == '-' || *(__argv[i]) == '/')
				continue;
			path = path + __argv[i] + " ";
		}
		path.TrimRight();
		return OpenDocumentFile(path) != NULL;
	}
	return CWinApp::ProcessShellCommand(rCmdInfo);
}

BOOL CVCApp::InitInstance()
{
	InitBubPalette();

	// Initialize OLE libraries
	if (!AfxOleInit())
	{
		AfxMessageBox(IDP_OLE_INIT_FAILED);
		return FALSE;
	}

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	LoadStdProfileSettings(6);  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CMultiDocTemplate* pDocTemplate;
	pDocTemplate = new CMultiDocTemplate(
		IDR_VCTYPE,
		RUNTIME_CLASS(CVCDoc),
		RUNTIME_CLASS(CChildFrame), // custom MDI child frame
		RUNTIME_CLASS(CVCView));
	AddDocTemplate(pDocTemplate);

	// Connect the COleTemplateServer to the document template.
	//  The COleTemplateServer creates new documents on behalf
	//  of requesting OLE containers by using information
	//  specified in the document template.
	m_server.ConnectTemplate(clsid, pDocTemplate, FALSE);

	// Register all OLE server factories as running.  This enables the
	//  OLE libraries to create objects from other applications.
	COleTemplateServer::RegisterAll();
		// Note: MDI applications register all server objects without regard
		//  to the /Embedding or /Automation on the command line.

	InitVCServer();
	cf_eCard = RegisterClipboardFormat(VCClipboardFormatVCard);

	// create main MDI Frame window
	CMainFrame* pMainFrame = new CMainFrame;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;
	m_pMainWnd = pMainFrame;

	// Enable drag/drop open
	m_pMainWnd->DragAcceptFiles();

	// Enable DDE Execute open
	EnableShellOpen();
	RegisterShellFileTypes(TRUE);

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Check to see if launched as OLE server
	if (cmdInfo.m_bRunEmbedded || cmdInfo.m_bRunAutomated)
	{
		// Application was run with /Embedding or /Automation.  Don't show the
		//  main window in this case.
		return TRUE;
	}

	// When a server application is launched stand-alone, it is a good idea
	//  to update the system registry in case it has been damaged.
	m_server.UpdateRegistry(OAT_DISPATCH_OBJECT);
	COleObjectFactory::UpdateRegistryAll();

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	// The main window has been initialized, so show and update it.
	pMainFrame->ShowWindow(
		m_nCmdShow == SW_SHOWNORMAL ? SW_SHOWMAXIMIZED : m_nCmdShow);
	pMainFrame->UpdateWindow();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CVCApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CVCApp commands

/////////////////////////////////////////////////////////////////////////////
// This is used for debugging output only.  Its implementation is platform
// specific.  This impl works for MS MFC.
void debugf(const char *s)
{
	TRACE0(s);
}

CM_CFUNCTIONS

void Parse_Debug(const char *s)
{
	TRACE0(s);
}

/*/////////////////////////////////////////////////////////////////////////*/
void msv_error(char *s)
{
	if (++msv_numErrors <= 3) {
		char buf[80];
		sprintf(buf, "%s at line %d", s, msv_lineNum);
		//AfxMessageBox(buf);
	}
}

/*/////////////////////////////////////////////////////////////////////////*/
void mime_error(char *s)
{
	if (++mime_numErrors <= 3) {
		char buf[80];
		sprintf(buf, "%s at line %d", s, mime_lineNum);
		AfxMessageBox(buf);
	}
}

CM_END_CFUNCTIONS

void CVCApp::OnDebugTestVCClasses() 
{
	if (OpenDocumentFile("Alden.htm")) { // powerful magic here
		// play the card's pronunciation, if any
		CView *view = ((CMainFrame *)GetMainWnd())->MDIGetActive()->GetActiveView();
		view->SendMessage(WM_COMMAND, VC_PLAY_BUTTON_ID);
	}
}

int CVCApp::ExitInstance() 
{
	if (bublp)
		delete bublp;

	if (m_incomingHeader) delete [] m_incomingHeader;
	if (vcServer_IR) delete vcServer_IR;

	return CWinApp::ExitInstance();
}

void CVCApp::OnDebugTraceComm() 
{
	traceComm = !traceComm;
}

void CVCApp::OnUpdateDebugTraceComm(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(traceComm);
}

void CVCApp::OnDebugTraceParser() 
{
	char *str = getenv("YYDEBUG");
	if (str && (*str == '1'))
		putenv("YYDEBUG=0");
	else
		putenv("YYDEBUG=1");
}

void CVCApp::OnUpdateDebugTraceParser(CCmdUI* pCmdUI) 
{
	char *str = getenv("YYDEBUG");
	pCmdUI->SetCheck(str && (*str == '1'));
}

BOOL CVCApp::CanSendFileViaIR() { return vcServer_IR != NULL; }

long CVCApp::SendFileViaIR(LPCTSTR nativePath, LPCTSTR asPath, BOOL isCardFile)
{
	if (!vcServer_IR)
		return 0;

	return vcServer_IR->SendFile(nativePath);
}

long CVCApp::ReceiveCard(LPCTSTR nativePath)
{
	if (OpenDocumentFile(nativePath)) { // powerful magic here
		CVCView *view = (CVCView*)((CMainFrame *)GetMainWnd())->MDIGetActive()->GetActiveView();
		view->GetDocument()->SetModifiedFlag();
		if (callCenter) {
			view->InitCallCenter(*callCenter);
			callCenter->UpdateData(FALSE);
		} else
			// play the card's pronunciation, if any
			view->SendMessage(WM_COMMAND, VC_PLAY_BUTTON_ID);
	}
	unlink(nativePath);
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vc32.h ===
/////////////////////////////////////////////////////////////////////////////
// CVc32App
// See vc32.cpp for the implementation of this class
//

class CVc32App : public CWinApp
{
public:
	CVc32App();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVc32App)
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CVc32App)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcard.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#include "stdafx.h" // PORTING: comment out this line on non-Windows platforms
#ifdef _WIN32
#include <wchar.h>
#else
#include "wchar.h"
#ifdef __MWERKS__
#include <assert.h>	// gca
#define	ASSERT assert
#endif
#endif

#include <string.h>
#include <malloc.h>
#include <fstream.h>
#include "vcard.h"
#include "clist.h"
#include "msv.h"

#ifdef _WIN32
#ifdef _DEBUG
#define new DEBUG_NEW
#endif
#endif

#if defined(_WIN32) || defined(__MWERKS__)
#define HNEW(_t, _n) new _t[_n]
#define HFREE(_h) delete [] _h
#else
#define HNEW(_t, _n) (_t __huge *)_halloc(_n, 1)
#define HFREE(_h) _hfree(_h)
#endif

extern void debugf(const char *s);

// This translates wide char strings into 8-bit, and also translates
// 0x2028 into \n
extern char *UI_CString(const wchar_t *u, char *dst);

static char *NewStr(const char *str);
static char * ShortName(char * ps);
static void NewlineTab(int nl, int tab);
static char *FakeCString(wchar_t *u, char *dst);
static void WriteLineBreakString(ostream& strm, wchar_t *str, BOOL qp);

static char buf[80];

typedef struct {
	BOOL didFamGiven, didOrg, didLocA;
	CVCard* card;
} MSVContext;

static char *paramsep = ";";


/**** class CVCard  ****/

/////////////////////////////////////////////////////////////////////////////
CVCard::CVCard()
{
	m_roots = new CList;
}

/////////////////////////////////////////////////////////////////////////////
CVCard::~CVCard()
{
    CLISTPOSITION pos;

    for (pos = m_roots->GetHeadPosition(); pos; ) {
    	CVCObject *node = (CVCObject *)m_roots->GetNext(pos);
    	delete node;
    }
    m_roots->RemoveAll();
    delete m_roots;
}

/////////////////////////////////////////////////////////////////////////////
CVCObject* CVCard::Copy()
{
	CVCard *result = new CVCard;
	CLISTPOSITION pos;

	for (pos = m_roots->GetHeadPosition(); pos; ) {
		CVCObject *node = (CVCObject *)m_roots->GetNext(pos);
		result->AddObject((CVCNode *)node->Copy());
	}
	return result;
}

/////////////////////////////////////////////////////////////////////////////
CList* CVCard::GetObjects()
{
	return m_roots;
}

/////////////////////////////////////////////////////////////////////////////
CVCard& CVCard::AddObject(CVCNode *object)
{
	m_roots->AddTail(object);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
CVCard& CVCard::RemoveObject(CVCNode *object, BOOL destroy)
{
	CLISTPOSITION pos;

	if ((pos = m_roots->Find(object))) {
		m_roots->RemoveAt(pos);
		if (destroy)
			delete object;
	}
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
CVCNode* CVCard::ParentForObject(CVCNode *object)
{
	CLISTPOSITION pos;
	CList *anc = new CList;
	CVCNode *result = NULL;

	// for each root object
	for (pos = m_roots->GetHeadPosition(); pos; ) {
		CVCNode *root = (CVCNode *)m_roots->GetNext(pos);
		if (root == object) {
			result = object;
			break;
		}
		// try finding the ancestry chain for each root
		if (root->AncestryForObject(object, anc)) {
			// BINGO!  The chain has 'object' at the head, so skip that.
			pos = anc->GetHeadPosition();
			anc->GetNext(pos);
			// and return object's parent
			result = (CVCNode *)anc->GetAt(pos);
			break;
		}
	}
	anc->RemoveAll();
	delete anc;
	return result;
}

/////////////////////////////////////////////////////////////////////////////
// This method tries to get an ancestry chain from each root to the
// passed object.  When it finds one, it walks the chain from head to tail
// (i.e. from child to root) looking for the named property.
CVCProp* CVCard::GetInheritedProp(CVCNode *object, const char *name, CVCNode **node)
{
	CLISTPOSITION pos;
	CList *anc = new CList;
	CVCProp *result = NULL;

	// for each root
	for (pos = m_roots->GetHeadPosition(); pos; ) {
		CVCNode *root = (CVCNode *)m_roots->GetNext(pos);
		if (root == object) {
			result = object->GetProp(name);
			if (node) *node = object;
			break;
		}
		if (root->AncestryForObject(object, anc)) {
			// Aha!  Found the chain, so walk it from head to tail.
			for (pos = anc->GetHeadPosition(); pos; ) {
				CVCNode *obj = (CVCNode *)anc->GetNext(pos);
				if ((result = obj->GetProp(name))) {
					if (node) *node = obj;
					break;
				}
			}
			break;
		}
	}
	anc->RemoveAll();
	delete anc;
	return result;
}

/////////////////////////////////////////////////////////////////////////////
void CVCard::GetPropsInEffect(CVCNode *object, CList *list)
{
	CLISTPOSITION pos;
	CList *anc = new CList;

	// for each root
	for (pos = m_roots->GetHeadPosition(); pos; ) {
		CVCNode *root = (CVCNode *)m_roots->GetNext(pos);
		if (root == object) {
			CList *props = object->GetProps();
			for (pos = props->GetHeadPosition(); pos; )
				list->AddTail((CVCProp *)props->GetNext(pos));
			break;
		}
		if (root->AncestryForObject(object, anc)) {
			// Aha!  Found the chain, so walk it from head to tail.
			for (pos = anc->GetHeadPosition(); pos; ) {
				CVCNode *obj = (CVCNode *)anc->GetNext(pos);
				CList *props = obj->GetProps();
				for (CLISTPOSITION p = props->GetHeadPosition(); p; )
					list->AddTail((CVCProp *)props->GetNext(p));
			}
			break;
		}
	}
	anc->RemoveAll();
	delete anc;
}

/////////////////////////////////////////////////////////////////////////////
CVCNode* CVCard::FindBody(const char* language)
{
	CVCNode *root = (CVCNode *)GetObjects()->GetHead();
	CList *rootProps = root->GetProps();
	CVCNode *firstBody = NULL, *body = NULL;

	for (CLISTPOSITION pos = rootProps->GetHeadPosition(); pos; ) {
		CVCProp *prop = (CVCProp *)rootProps->GetNext(pos);
		if (strcmp(vcBodyProp, prop->GetName()) == 0) {
			CVCNode *thisBody = (CVCNode *)prop->FindValue(
				VCNextObjectType)->GetValue();
			CVCProp *langProp;
			CVCValue *value;
			char buf[256];
			if (!firstBody) {
				firstBody = thisBody;
				if (!language)
					return firstBody;
			}
			if ((langProp = thisBody->GetProp(vcLanguageProp))
				&& (value = langProp->FindValue(VCStrIdxType))
				&& (strcmp(FakeCString((wchar_t*)value->GetValue(), buf), language) == 0)) {
				body = thisBody;
				break;
			}
		}
	}
	if (!firstBody)
		body = root;
	else if (!body)
		body = firstBody;

	return body;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVCard::Write(FILE *outputFile)
{
	ofstream strm(_fileno(outputFile));
	return Write(strm);
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVCard::Write(ostream& strm)
{
	wchar_t null = 0;
	MSVContext ctx;

	memset(&ctx, 0, sizeof(ctx));
	ctx.card = this;

	strm << "BEGIN:VCARD\n";
	for (CLISTPOSITION pos = m_roots->GetHeadPosition(); pos; ) {
		CVCNode *node = (CVCNode *)m_roots->GetNext(pos);
		if (!node->Write(strm, &null, &ctx))
			return FALSE;
	}
	strm << "END:VCARD\n";
	return TRUE;
}


/**** class CVCNode  ****/

/////////////////////////////////////////////////////////////////////////////
CVCNode::CVCNode(CVCProp *prop)
{
	m_props = new CList;
	if (prop)
		m_props->AddTail(prop);
}

/////////////////////////////////////////////////////////////////////////////
CVCNode::~CVCNode()
{
    CLISTPOSITION pos;

    for (pos = m_props->GetHeadPosition(); pos; ) {
    	CVCProp *prop = (CVCProp *)m_props->GetNext(pos);
    	delete prop;
    }
    m_props->RemoveAll();
    delete m_props;
}

/////////////////////////////////////////////////////////////////////////////
CVCObject* CVCNode::Copy()
{
	CVCNode *result = new CVCNode;
	CLISTPOSITION pos;
	CList *props = result->GetProps();

	for (pos = m_props->GetHeadPosition(); pos; ) {
		CVCProp *prop = (CVCProp *)m_props->GetNext(pos);
		props->AddTail(prop->Copy());
	}
	return result;
}

/////////////////////////////////////////////////////////////////////////////
CList* CVCNode::GetProps()
{
	return m_props;
}

/////////////////////////////////////////////////////////////////////////////
CVCProp* CVCNode::GetProp(const char *name)
{
	CLISTPOSITION pos;

	for (pos = m_props->GetHeadPosition(); pos; ) {
		CVCProp *prop = (CVCProp *)m_props->GetNext(pos);
		if (strcmp(name, prop->GetName()) == 0)
			return prop;
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
CVCNode& CVCNode::AddProp(CVCProp *prop)
{
	m_props->AddTail(prop);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
CVCNode* CVCNode::AddObjectProp(const char *propName, const char *marker)
{
	CVCNode *newobj = new CVCNode;
																			
	if (marker)
		newobj->AddProp(new CVCProp(marker));     			 	
	AddProp(new CVCProp(propName, VCNextObjectType, newobj));			

	return newobj;
}

/////////////////////////////////////////////////////////////////////////////
CVCNode* CVCNode::AddPart()
{
	return AddObjectProp(vcPartProp, VCPartObject);
}

/////////////////////////////////////////////////////////////////////////////
CVCProp* CVCNode::AddStringProp(
	const char *propName, const char *value, VC_DISPTEXT *dispText)
{
	CVCProp *prop;
	int size;
	wchar_t *uniValue = FakeUnicode(value, &size);

	FixCRLF(uniValue);
	AddProp(prop = new CVCProp(propName, VCStrIdxType, uniValue, size));
	delete [] uniValue;
	if (dispText)
		prop->AddValue(
			new CVCValue(VCDisplayInfoTextType, dispText, sizeof(*dispText)));

	return prop;
}

/////////////////////////////////////////////////////////////////////////////
CVCProp* CVCNode::AddBoolProp(const char *propName)
{
	CVCProp *prop = new CVCProp(propName, vcFlagsType);
	AddProp(prop);			
	return prop;
}

/////////////////////////////////////////////////////////////////////////////
CVCNode& CVCNode::RemoveProp(const char *name, BOOL destroy)
{
	CLISTPOSITION pos, lastPos;

	for (pos = m_props->GetHeadPosition(); pos; ) {
		CVCProp *prop;
		lastPos = pos;
		prop = (CVCProp *)m_props->GetNext(pos);
		if (strcmp(name, prop->GetName()) == 0) {
			m_props->RemoveAt(lastPos);
			if (destroy)
				delete prop;
			break;

		}
	}
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
// This is a recursive method, and it adjusts ancestry as described in the
// header file comment.  The only tricky part is that it skips over objects
// held by vcNextObjectProp values, as these don't represent "child" objects.
BOOL CVCNode::AncestryForObject(CVCNode *object, CList *ancestry)
{
	CLISTPOSITION pos, headPos;

	headPos = ancestry->AddHead(this);
	// for every property of self
	for (pos = m_props->GetHeadPosition(); pos; ) {
		CVCProp *prop = (CVCProp *)m_props->GetNext(pos);
		if ((strcmp(prop->GetName(), vcBodyProp) == 0)
			|| (strcmp(prop->GetName(), vcPartProp) == 0)
			|| (strcmp(prop->GetName(), vcNextObjectProp) == 0)) {
			CVCNode *obj = (CVCNode *)prop->FindValue(
				VCNextObjectType)->GetValue();
			if (obj) {
				if (obj == object) {
					// Eureka!  Self was added above, and so just add
					// the object itself and return success.
					ancestry->AddHead(object);
					return TRUE;
				} else {
					// This is a non-matching, non-NULL object value, so
					// try recursing downward as long as it's not
					// a vcNextObjectProp.
					if ((strcmp(prop->GetName(), vcNextObjectProp) != 0)
						&& obj->AncestryForObject(object, ancestry))
						return TRUE;
				}
			}
		}
	}
	ancestry->RemoveAt(headPos);
	return FALSE;
}

void CVCNode::WriteMultipart(
	ostream& strm, const char *propName,
	const char *propName1, const char *propName2, const char *propName3,
	const char *propName4, const char *propName5, BOOL qp)
{
	CVCProp *prop1 = GetProp(propName1);
	CVCProp *prop2 = GetProp(propName2);
	CVCProp *prop3 = GetProp(propName3);
	CVCProp *prop4 = GetProp(propName4);
	CVCProp *prop5 = GetProp(propName5);
	wchar_t propVal[256];
	char outName[128];
	char flagsStr[80];

	strcpy(outName, propName);
	FlagsToOutput(flagsStr);
	if (*flagsStr) {
		strcat(outName, ";");
		strcat(outName, flagsStr);
	}

	propVal[0] = 0;
	if (prop1) wcscpy(propVal, (wchar_t *)prop1->FindValue(VCStrIdxType)->GetValue());
	strm << outName << ":";
	WriteLineBreakString(strm, propVal, qp);
	strm << ";";
	propVal[0] = 0;
	if (prop2) wcscpy(propVal, (wchar_t *)prop2->FindValue(VCStrIdxType)->GetValue());
	WriteLineBreakString(strm, propVal, qp);

	if (prop3 || prop4 || prop5) {
		strm << ";";
		propVal[0] = 0;
		if (prop3) wcscpy(propVal, (wchar_t *)prop3->FindValue(VCStrIdxType)->GetValue());
		WriteLineBreakString(strm, propVal, qp);
	}
	if (prop4 || prop5) {
		strm << ";";
		propVal[0] = 0;
		if (prop4) wcscpy(propVal, (wchar_t *)prop4->FindValue(VCStrIdxType)->GetValue());
		WriteLineBreakString(strm, propVal, qp);
	}
	if (prop5) {
		strm << ";";
		propVal[0] = 0;
		if (prop5) wcscpy(propVal, (wchar_t *)prop5->FindValue(VCStrIdxType)->GetValue());
		WriteLineBreakString(strm, propVal, qp);
	}

	strm << "\n";
}

/////////////////////////////////////////////////////////////////////////////
void CVCNode::FlagsToOutput(char *str)
{
	str[0] = 0;

	for (CLISTPOSITION pos = m_props->GetHeadPosition(); pos; ) {
		CVCProp *prop = (CVCProp *)m_props->GetNext(pos);
		const char *propName = prop->GetName();
		if (prop->IsBool()) {
			if (strnicmp(propName, "X-", 2) == 0) {
				strcat(str, propName);
				strcat(str, "=");
				strcat(str, (const char*)prop->FindValue(VCFlagsType)->GetValue());
				strcat(str, paramsep);
			} else if (strcmp(propName, vcCharSetProp) == 0) {
				strcat(str, "CHARSET=");
				strcat(str, (const char*)prop->FindValue(VCFlagsType)->GetValue());
				strcat(str, paramsep);
			} else if (strcmp(propName, vcLanguageProp) == 0) {
				strcat(str, "LANGUAGE=");
				strcat(str, (const char*)prop->FindValue(VCFlagsType)->GetValue());
				strcat(str, paramsep);
			} else {
				const char *tail;
				if (strcmp(propName, vcQuotedPrintableProp) == 0)
					tail = "QUOTED-PRINTABLE";
				else if (strcmp(propName, vcURLValueProp) == 0)
					tail = "URL";
				else 
					tail = strrchr(propName, '/') + 1;
				strcat(str, tail);
				strcat(str, paramsep);
			}
		}
	} // for

	if (*str) str[strlen(str)-1] = 0; // remove last comma
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVCNode::Write(ostream& strm, const wchar_t *prefix, void *context)
{
	CVCProp *nodeNameProp = GetProp(vcNodeNameProp), *prop;
	wchar_t myPrefix[128];
	CLISTPOSITION pos;
	MSVContext *ctx = (MSVContext *)context;
	BOOL qp = ctx->card->GetInheritedProp(this, vcQuotedPrintableProp) != NULL;

	wcscpy(myPrefix, prefix);
	if (nodeNameProp) {
		if (wcslen(myPrefix)) {
			wchar_t dot[2];
			dot[0] = '.';
			dot[1] = 0;
			wcscat(myPrefix, dot);
		}
		wcscat(myPrefix, (wchar_t *)nodeNameProp->FindValue(VCStrIdxType)->GetValue());
	}

	for (pos = m_props->GetHeadPosition(); pos; ) {
		const char *propName;

		prop = (CVCProp *)m_props->GetNext(pos);
		propName = prop->GetName();

		if (!prop->IsBool() && (strcmp(propName, vcCharSetProp) == 0
			|| strcmp(propName, vcLanguageProp) == 0))
			if (!prop->Write(strm, myPrefix, this, context))
				return FALSE;
	}

	// for each non-bool prop that isn't Logo, Photo, or Pronunciation...
	for (pos = m_props->GetHeadPosition(); pos; ) {
		const char *propName;

		prop = (CVCProp *)m_props->GetNext(pos);
		propName = prop->GetName();

		if ((strcmp(propName, vcLogoProp) == 0)
			|| (strcmp(propName, vcPhotoProp) == 0)
			|| (strcmp(propName, vcPronunciationProp) == 0)
			|| (strcmp(propName, vcCharSetProp) == 0)
			|| (strcmp(propName, vcLanguageProp) == 0)
			|| prop->IsBool())
			continue;

		if ((strcmp(propName, vcFamilyNameProp) == 0)
			|| (strcmp(propName, vcGivenNameProp) == 0)
			|| (strcmp(propName, vcAdditionalNamesProp) == 0)
			|| (strcmp(propName, vcNamePrefixesProp) == 0)
			|| (strcmp(propName, vcNameSuffixesProp) == 0)) {
			if (!ctx->didFamGiven) {
				WriteMultipart(strm, "N",
					vcFamilyNameProp, vcGivenNameProp, vcAdditionalNamesProp,
					vcNamePrefixesProp, vcNameSuffixesProp, qp);
				ctx->didFamGiven = TRUE;
			}
		} else if ((strcmp(propName, vcOrgNameProp) == 0)
			|| (strcmp(propName, vcOrgUnitProp) == 0)
			|| (strcmp(propName, vcOrgUnit2Prop) == 0)
			|| (strcmp(propName, vcOrgUnit3Prop) == 0)
			|| (strcmp(propName, vcOrgUnit4Prop) == 0)) {
			if (!ctx->didOrg) {
				WriteMultipart(strm, "ORG",
					vcOrgNameProp, vcOrgUnitProp, vcOrgUnit2Prop,
					vcOrgUnit3Prop, vcOrgUnit4Prop, qp);
				ctx->didOrg = TRUE;
			}
		} else if ((strcmp(propName, vcPostalBoxProp) == 0)
			|| (strcmp(propName, vcExtAddressProp) == 0)
			|| (strcmp(propName, vcStreetAddressProp) == 0)
			|| (strcmp(propName, vcCityProp) == 0)
			|| (strcmp(propName, vcRegionProp) == 0)
			|| (strcmp(propName, vcPostalCodeProp) == 0)
			|| (strcmp(propName, vcCountryNameProp) == 0)) {
			if (ctx->didLocA)
				continue;
			CVCProp *prop1 = GetProp(vcPostalBoxProp);
			CVCProp *prop2 = GetProp(vcExtAddressProp);
			CVCProp *prop3 = GetProp(vcStreetAddressProp);
			CVCProp *prop4 = GetProp(vcCityProp);
			CVCProp *prop5 = GetProp(vcRegionProp);
			CVCProp *prop6 = GetProp(vcPostalCodeProp);
			CVCProp *prop7 = GetProp(vcCountryNameProp);
			wchar_t propVal[256];
			char flagsStr[80];

			FlagsToOutput(flagsStr);
			if (strlen(flagsStr))
				strm << "ADR;" << flagsStr << ":";
			else
				strm << "ADR:";
			propVal[0] = 0;
			if (prop1) wcscpy(propVal, (wchar_t *)prop1->FindValue(VCStrIdxType)->GetValue());
			WriteLineBreakString(strm, propVal, qp);
			strm << ";";
			propVal[0] = 0;
			if (prop2) wcscpy(propVal, (wchar_t *)prop2->FindValue(VCStrIdxType)->GetValue());
			WriteLineBreakString(strm, propVal, qp);
			strm << ";";
			propVal[0] = 0;
			if (prop3) wcscpy(propVal, (wchar_t *)prop3->FindValue(VCStrIdxType)->GetValue());
			WriteLineBreakString(strm, propVal, qp);
			strm << ";";
			propVal[0] = 0;
			if (prop4) wcscpy(propVal, (wchar_t *)prop4->FindValue(VCStrIdxType)->GetValue());
			WriteLineBreakString(strm, propVal, qp);
			strm << ";";
			propVal[0] = 0;
			if (prop5) wcscpy(propVal, (wchar_t *)prop5->FindValue(VCStrIdxType)->GetValue());
			WriteLineBreakString(strm, propVal, qp);
			strm << ";";
			propVal[0] = 0;
			if (prop6) wcscpy(propVal, (wchar_t *)prop6->FindValue(VCStrIdxType)->GetValue());
			WriteLineBreakString(strm, propVal, qp);
			strm << ";";
			propVal[0] = 0;
			if (prop7) wcscpy(propVal, (wchar_t *)prop7->FindValue(VCStrIdxType)->GetValue());
			WriteLineBreakString(strm, propVal, qp);
			strm << "\n";
			ctx->didLocA = TRUE;
		} else if (!prop->Write(strm, myPrefix, this, context))
			return FALSE;
	}

	// finally write the logo/photo/pronunciation props	
	for (pos = m_props->GetHeadPosition(); pos; ) {
		CVCProp *prop = (CVCProp *)m_props->GetNext(pos);
		if ((strcmp(prop->GetName(), vcLogoProp) == 0)
			|| (strcmp(prop->GetName(), vcPhotoProp) == 0)
			|| (strcmp(prop->GetName(), vcPronunciationProp) == 0))
			if (!prop->Write(strm, myPrefix, this, context))
				return FALSE;
	}

	return TRUE;
}


/**** class CVCProp  ****/

/////////////////////////////////////////////////////////////////////////////
CVCProp::CVCProp(const char *name, CVCValue *value)
{
	m_name = NewStr(name);
	m_values = new CList;
	m_values->AddTail(value ? value : new CVCValue());
}

/////////////////////////////////////////////////////////////////////////////
CVCProp::CVCProp(const char *name, const char *type, void *value, S32 size)
{
	m_name = NewStr(name);
	m_values = new CList;
	m_values->AddTail(new CVCValue(type, value, size));
}

/////////////////////////////////////////////////////////////////////////////
CVCProp::~CVCProp()
{
    CLISTPOSITION pos;

    for (pos = m_values->GetHeadPosition(); pos; ) {
    	CVCValue *val = (CVCValue *)m_values->GetNext(pos);
    	delete val;
    }
    m_values->RemoveAll();
    delete m_values;
	delete [] m_name;
}

/////////////////////////////////////////////////////////////////////////////
CVCObject* CVCProp::Copy()
{
	CVCProp *result = new CVCProp(m_name);
	CLISTPOSITION pos;
	CList *values = result->GetValues();

	// clear out every value that is in result's prop list before adding copies
    for (pos = values->GetHeadPosition(); pos; ) {
    	CVCValue *val = (CVCValue *)values->GetNext(pos);
    	delete val;
    }
    values->RemoveAll();

	for (pos = m_values->GetHeadPosition(); pos; ) {
		CVCValue *value = (CVCValue *)m_values->GetNext(pos);
		values->AddTail(value->Copy());
	}
	return result;
}

/////////////////////////////////////////////////////////////////////////////
CList* CVCProp::GetValues()
{
	return m_values;
}

/////////////////////////////////////////////////////////////////////////////
const char *CVCProp::GetName()
{
	return m_name;
}

/////////////////////////////////////////////////////////////////////////////
CVCProp& CVCProp::SetName(const char *name)
{
	if (m_name)
		delete [] m_name;
	m_name = NewStr(name);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
CVCProp& CVCProp::AddValue(CVCValue *value)
{
	m_values->AddTail(value);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
CVCProp& CVCProp::RemoveValue(CVCValue *value, BOOL destroy)
{
	CLISTPOSITION pos, lastPos;

	for (pos = m_values->GetHeadPosition(); pos; ) {
		CVCValue *val;
		lastPos = pos;
		val = (CVCValue *)m_values->GetNext(pos);
		if (val == value) {
			m_values->RemoveAt(lastPos);
			if (destroy)
				delete value;
			break;

		}
	}
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
CVCProp& CVCProp::RemoveValue(const char *type, BOOL destroy)
{
	CLISTPOSITION pos, lastPos;

	for (pos = m_values->GetHeadPosition(); pos; ) {
		CVCValue *value;
		lastPos = pos;
		value = (CVCValue *)m_values->GetNext(pos);
		if (strcmp(type, value->GetType()) == 0) {
			m_values->RemoveAt(lastPos);
			if (destroy)
				delete value;
			break;

		}
	}
	return *this;
}

CVCValue* CVCProp::FindValue(const char *type, void *value)
{
	CLISTPOSITION pos;

	for (pos = m_values->GetHeadPosition(); pos; ) {
		CVCValue *val = (CVCValue *)m_values->GetNext(pos);
		if (type) {
			if (strcmp(type, val->GetType()) == 0)
				return val;
		} else {
			if (value == val->GetValue())
				return val;
		}
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
static void WriteLineBreakString(ostream& strm, wchar_t *str, BOOL qp)
{
	if (qp) {
		while (*str) {
			if ((*str >= 32 && *str <= 60) || (*str >= 62 && *str <= 126))
				strm << (char)*str;
			else if (*str == 0x2028)
				strm << "=0A=\n";
			else if (HIBYTE(*str) == 0) {
				U8 c = LOBYTE(*str);
				char n[2];
				U8 d = c >> 4;
				n[0] = d > 9 ? d - 10 + 'A' : d + '0';
				d = c & 0xF;
				n[1] = d > 9 ? d - 10 + 'A' : d + '0';
				strm << "=" << n[0] << n[1];
			}
			str++;
		}
	} else {
		while (*str) {
			if (*str >= 32 && *str <= 126)
				strm << (char)*str;
			str++;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
static BOOL WriteBase64(ostream& strm, U8 __huge *bytes, S32 len)
{
	S32 cur = 0;
	int i, numQuads = 0;
	U32 trip;
	U8 b;
	char quad[5];
#define MAXQUADS 16

	quad[4] = 0;

	while (cur < len) {
		// collect the triplet of bytes into 'trip'
		trip = 0;
		for (i = 0; i < 3; i++) {
			b = (cur < len) ? *(bytes + cur) : 0;
			cur++;
			trip = trip << 8 | b;
		}
		// fill in 'quad' with the appropriate four characters
		for (i = 3; i >= 0; i--) {
			b = (U8)(trip & 0x3F);
			trip = trip >> 6;
			if ((3 - i) < (cur - len))
				quad[i] = '='; // pad char
			else if (b < 26) quad[i] = (char)b + 'A';
			else if (b < 52) quad[i] = (char)(b - 26) + 'a';
			else if (b < 62) quad[i] = (char)(b - 52) + '0';
			else if (b == 62) quad[i] = '+';
			else quad[i] = '/';
		}
		// now output 'quad' with appropriate whitespace and line ending
		strm
			<< (numQuads == 0 ? "    " : "")
			<< quad
			<< ((cur >= len) ? "\n" : (numQuads == MAXQUADS - 1 ? "\n" : ""));
		numQuads = (numQuads + 1) % MAXQUADS;
	}
	strm << "\n";

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVCProp::IsBool()
{
	return FindValue(vcFlagsType) != NULL;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVCProp::Write(
	ostream& strm, const wchar_t *prefix, CVCNode *node, void *context)
{
	CVCValue *value;
	char outName[128];
	char flagsStr[80];
	MSVContext *ctx = (MSVContext *)context;

	if (strcmp(m_name, vcPartProp) == 0) {
		CVCNode *node = (CVCNode *)FindValue(VCNextObjectType)->GetValue();
		return node->Write(strm, prefix, context);
	} else if (strcmp(m_name, vcBodyProp) == 0) {
		CVCNode *node = (CVCNode *)FindValue(VCNextObjectType)->GetValue();
		return node->Write(strm, prefix, context);
	} else if (strcmp(m_name, vcNodeNameProp) == 0) {
		// don't write this "property" out
		return TRUE;
	}
	
	outName[0] = 0;
	if (strnicmp(m_name, "X-", 2) == 0)
		strcpy(outName, m_name);
	else
		strcpy(outName, strrchr(m_name, '/') + 1);
	node->FlagsToOutput(flagsStr);
	if (*flagsStr) {
		strcat(outName, ";");
		strcat(outName, flagsStr);
	}

	if (((strcmp(m_name, vcPronunciationProp) == 0) && (value = FindValue(VCWAVType)))
		|| ((strcmp(m_name, vcPublicKeyProp) == 0) && (value = FindValue(VCOctetsType)))
		|| ((strcmp(m_name, vcLogoProp) == 0) && (value = FindValue(VCGIFType)))
		|| ((strcmp(m_name, vcPhotoProp) == 0) && (value = FindValue(VCGIFType)))
		|| ((strnicmp(m_name, "X-", 2) == 0) && (value = FindValue(VCOctetsType)))
		) {
		//char buf[80];
		ASSERT(*outName);
		if (wcslen(prefix)) {
			strm
				<< UI_CString(prefix, buf) << "."
				<< outName << ":\n";
			return WriteBase64(strm, (U8 __huge *)value->GetValue(), value->GetSize());
		} else {
			strm
				<< outName << ":\n";
			return WriteBase64(strm, (U8 __huge *)value->GetValue(), value->GetSize());
		}
	} else if (strcmp(m_name, vcAgentProp) == 0) {
		//char buf[80];
		ASSERT(*outName);
		value = FindValue(VCNextObjectType);
		if (wcslen(prefix))
			strm
				<< UI_CString(prefix, buf) << "."
				<< outName << ":";
		else
			strm << outName << ":";
		return ((CVCard *)value->GetValue())->Write(strm);
	} else if ((value = FindValue(VCStrIdxType)) && *outName) {
		//char buf[80];
		BOOL qp = ctx->card->GetInheritedProp(node, vcQuotedPrintableProp) != NULL;
		if (wcslen(prefix)) {
			strm
				<< UI_CString(prefix, buf) << "."
				<< outName << ":";
			WriteLineBreakString(strm, (wchar_t *)value->GetValue(), qp);
			strm << "\n";
		} else {
			strm << outName << ":";
			WriteLineBreakString(strm, (wchar_t *)value->GetValue(), qp);
			strm << "\n";
		}
	}
	
	return TRUE;
}


/**** class CVCValue  ****/

/////////////////////////////////////////////////////////////////////////////
CVCValue::CVCValue(const char *type, void *value, S32 size)
{
	m_type = NewStr(type ? type : VCNullType);
	m_value = value;
	m_size = size;
	if (size) {
		U8 __huge *newVal = HNEW(U8, size);
		_hmemcpy(newVal, (U8 __huge *)value, size);
		m_value = newVal;
	}
}

/////////////////////////////////////////////////////////////////////////////
CVCValue::~CVCValue()
{
	if (m_value)
		if (strcmp(m_type, VCNextObjectType) == 0)
			delete (CVCObject *)m_value;
		else
			if (m_size)
				HFREE((char*)m_value);
	delete [] m_type;
}

/////////////////////////////////////////////////////////////////////////////
CVCObject* CVCValue::Copy()
{
	CVCValue *result;
	
	if (strcmp(m_type, VCNextObjectType) == 0)
		result = new CVCValue(m_type, ((CVCObject *)m_value)->Copy(), m_size);
	else
		result = new CVCValue(m_type, m_value, m_size);
	return result;
}

/////////////////////////////////////////////////////////////////////////////
const char *CVCValue::GetType()
{
	return m_type;
}

/////////////////////////////////////////////////////////////////////////////
CVCValue& CVCValue::SetType(const char *type)
{
	SetValue(); // to clean up any old value before changing the type
	delete [] m_type;
	m_type = NewStr(type);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
void* CVCValue::GetValue()
{
	return m_value;
}

/////////////////////////////////////////////////////////////////////////////
CVCValue& CVCValue::SetValue(void *value, S32 size)
{
	if (m_value)
		if (strcmp(m_type, VCNextObjectType) == 0)
			delete (CVCObject *)m_value;
		else
			if (m_size)
				HFREE((char*)m_value);
	if (size) {
		m_value = HNEW(char, size);
		_hmemcpy((U8 __huge *)m_value, (U8 __huge *)value, size);
	} else
		m_value = value;
	m_size = size;
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
S32 CVCValue::GetSize()
{
	return m_size;
}


/**** class CVCPropEnumerator  ****/

/////////////////////////////////////////////////////////////////////////////
CVCPropEnumerator::CVCPropEnumerator(CVCNode *root)
{
	m_objects = new CList;
	m_objects->AddHead(root);
	m_positions = new CList;
	m_positions->AddHead(root->GetProps()->GetHeadPosition());
}

/////////////////////////////////////////////////////////////////////////////
CVCPropEnumerator::~CVCPropEnumerator()
{
    m_objects->RemoveAll();
    delete m_objects;
    m_positions->RemoveAll();
    delete m_positions;
}

/////////////////////////////////////////////////////////////////////////////
CVCProp* CVCPropEnumerator::NextProp(CVCNode **node)
{
	CLISTPOSITION curPos = NULL;

	if (node) *node = NULL;

	// if the current pos is NULL, "pop" the stack until we find
	// a non-NULL position or stack is empty
	while (!m_objects->IsEmpty()
		&& !(curPos = (CLISTPOSITION)m_positions->GetHead())) {
		m_objects->RemoveAt(m_objects->GetHeadPosition());
		m_positions->RemoveAt(m_positions->GetHeadPosition());
		if (m_objects->IsEmpty())
			curPos = NULL;
	}

	if (curPos) {
		CVCNode *curObj = (CVCNode *)m_objects->GetHead();
		CList *props = curObj->GetProps();
		CVCProp *prop = (CVCProp *)props->GetNext(curPos);

		// advance position at top of stack to next in list.
		m_positions->GetHeadPosition()->m_item = curPos;

		// we'll return 'prop', but set up for next time by going deep.
		if ((strcmp(prop->GetName(), vcBodyProp) == 0)
			|| (strcmp(prop->GetName(), vcPartProp) == 0)
			|| (strcmp(prop->GetName(), vcNextObjectProp) == 0)) {
			CVCNode *nextObj = (CVCNode *)prop->FindValue(
				VCNextObjectType)->GetValue();
			m_objects->AddHead(nextObj);
			m_positions->AddHead(nextObj->GetProps()->GetHeadPosition());
		}
		if (node) *node = curObj;
		return prop;
	}

	return NULL;
}


/**** Utility Functions  ****/

static char *NewStr(const char *str)
{
	char *buf = new char[strlen(str) + 1];
	strcpy(buf, str);
	return buf;
}

/* ShortName takes a ISO 9070 string and checks to see if it is one
*  defined by versitcard. If so, it shortens it to the final substring
*  after the last //. These substrings are, by definition, the property
*  labels used in Simplegrams. (It doesn't have to be done this way, a
*  lookup table could be used, but this provides a convenient defacto
*  idiom for extending Simplegrams. In fact, we might want to change this
*  algorithm to "remove everything up to the final //" and not even check
*  if it is a versit-defined identifier?
*/
static char * ShortName(char * ps)
{
	if (strstr(ps,"+//ISBN 1-887687-00-9::versit::PDI//"))	 // if it's one of ours
	{
	  ps = strrchr(ps,'/');														 // abbreviate it
		ps++;
	}
	return ps;

} // ShortName

/* FixCRLF takes a pointer to a wide character (Unicode) string and searches
*  for old-fashioned ASCII \n and \r characters and hammers them into Unicode
*  line and paragraph separator characters.
*/
void FixCRLF(wchar_t * ps)
{
	do {	

		if (*ps == (wchar_t)'\n')			// translate linefeed to
			*ps = 0x2028;		 						// Unicode line separator 

		if (*ps == (wchar_t)'\r')			// translate carriage return to
			*ps = 0x2029;								// Unicode paragraph separator

	}	while (*ps++ != (wchar_t)NULL);

}	// FixCRLF

/* FakeUnicode takes a char * string and returns a wide character (Unicode)
*  equivalent. It does so by simply transforming 8-bits into 16 which will
*  not generally be a perfect translation. For purposes of this code the only
*  imperfection that is critical is handled by a followup call to FixCRLF.
*  If 'bytes' is non_NULL, *bytes is set to the number of bytes allocated.
*/
wchar_t * FakeUnicode(const char * ps, int * bytes)
{
	wchar_t	*r, *pw;
	int len = strlen(ps)+1;

	pw = r = new wchar_t[len];
	if (bytes)
		*bytes = len * sizeof(wchar_t);

	for (;;)
	{ 
		*pw++ = (wchar_t)(unsigned char)*ps;
			
	  if (*ps == 0)
			break;
		else
			ps++;
	}				 
	
	return r;

}	// FakeUnicode

// Simple-minded conversion from UNICODE to char string
static char *FakeCString(wchar_t *u, char *dst)
{
	char *str = dst;
	while (*u) {
		if (*u == 0x2028) {
			*dst++ = '\n';
			u++;
		} else if (*u == 0x2029) {
			*dst++ = '\r';
			u++;
		} else
			*dst++ = (char)*u++;
	}
	*dst = '\000';
	return str;
}

/* NewlineTab outputs the number of newlines and tabs requested.
*/
static void NewlineTab(int nl, int tab)
{
	char s[128];

	s[0] = 0;

	while (nl-- > 0)	strcat(s,"\n");
	while (tab-- > 0)	strcat(s,"\t");

	debugf(s);
}

U8 __huge * _hmemcpy(U8 __huge * dst, U8 __huge * src, S32 len)
{
	U8 *d = dst;
	U8 *s = src;
	S32 l = 0;
	S32 c;
	do {
		c = min(len - l, 0xFFFF);
		memcpy(d, s, (size_t)c);
		d += c;
		s += c;
		l += c;
	} while (l < len);
	return dst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcdll.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// vc32.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include <fstream.h>
#include "vc32.h"
#include "vcdll.h"
#include "clist.h"
#include "vcard.h"
#include "msv.h"
#include "mime.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CVc32App

BEGIN_MESSAGE_MAP(CVc32App, CWinApp)
	//{{AFX_MSG_MAP(CVc32App)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVc32App construction

CVc32App::CVc32App()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CVc32App object

CVc32App theApp;

typedef struct {
	CVCard *vCard;
	CVCPropEnumerator *pEnum; // if NULL, indicates a "one-shot" enum
	CVCProp *prop;
	CVCNode *node;
	CList *pendingRemove;
} VCEnumPropPriv, *HVCEnumPropPriv;

typedef struct {
	CList list;
	CLISTPOSITION pos;
	CVCNode *node;
	HVCEnumPropPriv parentPropEnum;
} VCEnumListPriv, *HVCEnumListPriv;

typedef struct {
	CVCProp *prop;
	CVCNode *node;
} VCPendingRemove;

static HGLOBAL LoadFile(LPCSTR path);
static HVCEnumProp NewProp(
	HVCEnumCard hVCEnum, LPCSTR lpszPropName, LPCSTR lpszType,
	void *value, S32 size);

//---------------------------------------------------------------------------
// Exported functions
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
extern "C" 
DllExport HVCEnumCard VCGetFirstCardFromPath(LPCSTR lpszFileName)
{
    HVCEnumListPriv hVCEnumPriv = new VCEnumListPriv;
    CStdioFile file(lpszFileName, CFile::modeRead | CFile::typeBinary);
    
    if (!Parse_Many_MSV_FromFile(&file, &hVCEnumPriv->list)
    	&& !Parse_Many_MIME_FromFile(&file, &hVCEnumPriv->list)) {
    	delete hVCEnumPriv; hVCEnumPriv = NULL;
    } else {
    	hVCEnumPriv->pos = hVCEnumPriv->list.GetHeadPosition();
    	hVCEnumPriv->parentPropEnum = NULL;
    	hVCEnumPriv->node = NULL;
    }
	return (HVCEnumCard)hVCEnumPriv;
}

/////////////////////////////////////////////////////////////////////////////
extern "C" 
DllExport HVCEnumCard VCGetFirstCardFromMem(HGLOBAL hGlobal)
{
    HVCEnumListPriv hVCEnumPriv;
    const char *data = (const char *)GlobalLock(hGlobal);
    
    if (!data)
    	return (HVCEnumCard)NULL;
    
    hVCEnumPriv = new VCEnumListPriv;
    if (!Parse_Many_MSV(data, GlobalSize(hGlobal), &hVCEnumPriv->list)
    	&& !Parse_Many_MIME(data, GlobalSize(hGlobal), &hVCEnumPriv->list)) {
    	delete hVCEnumPriv; hVCEnumPriv = NULL;
    } else {
    	hVCEnumPriv->pos = hVCEnumPriv->list.GetHeadPosition();
    	hVCEnumPriv->parentPropEnum = NULL;
    	hVCEnumPriv->node = NULL;
    }
    GlobalUnlock(hGlobal);
	return (HVCEnumCard)hVCEnumPriv;
}

/////////////////////////////////////////////////////////////////////////////
extern "C" 
DllExport HVCEnumCard VCGetNewCard()
{
    HVCEnumListPriv hVCEnumPriv = new VCEnumListPriv;
	CVCard *vCard = new CVCard;
	CVCNode *root, *english;
	CVCProp *prop;
	
	vCard->AddObject(root = new CVCNode);					// create root
	root->AddProp(new CVCProp(vcRootObject));				// mark it so
	english = root->AddObjectProp(vcBodyProp, vcBodyObject);
	english->AddProp(prop = new CVCProp(vcLanguageProp));	
	prop->AddValue(new CVCValue(vcISO639Type, "en", (size_t)2));
	
	hVCEnumPriv->list.AddTail(vCard);
	hVCEnumPriv->pos = hVCEnumPriv->list.GetHeadPosition();
	hVCEnumPriv->parentPropEnum = NULL;
    hVCEnumPriv->node = NULL;

	return (HVCEnumCard)hVCEnumPriv;
}

/////////////////////////////////////////////////////////////////////////////
extern "C" 
DllExport DWORD VCGetNextCard(HVCEnumCard hVCEnum)
{
    HVCEnumListPriv hVCEnumPriv = (HVCEnumListPriv)hVCEnum;
    
    hVCEnumPriv->list.GetNext(hVCEnumPriv->pos);
    if (hVCEnumPriv->pos == NULL)
    	return 0;
    return 1;
}

/////////////////////////////////////////////////////////////////////////////
extern "C" 
DllExport void VCGetCardClose(HVCEnumCard hVCEnum)
{
    HVCEnumListPriv hVCEnumPriv = (HVCEnumListPriv)hVCEnum;

    for (CLISTPOSITION pos = hVCEnumPriv->list.GetHeadPosition(); pos; ) {
    	CVCard* vCard = (CVCard*)hVCEnumPriv->list.GetNext(pos);
    	delete vCard;
    }
    delete hVCEnumPriv;
}

/////////////////////////////////////////////////////////////////////////////
extern "C" 
DllExport HVCEnumProp VCGetFirstProp(HVCEnumCard hVCEnum)
{
    HVCEnumListPriv hVCEnumListPriv = (HVCEnumListPriv)hVCEnum;
    CVCard *vCard = (CVCard*)hVCEnumListPriv->list.GetAt(hVCEnumListPriv->pos);
	CVCNode *body = vCard->FindBody();
    HVCEnumPropPriv hVCEnumPriv = new VCEnumPropPriv;

	hVCEnumPriv->pEnum = new CVCPropEnumerator(body);
	hVCEnumPriv->pendingRemove = NULL;
	hVCEnumPriv->vCard = vCard;
	while ((hVCEnumPriv->prop = hVCEnumPriv->pEnum->NextProp(&(hVCEnumPriv->node)))) {
		if (!hVCEnumPriv->prop->IsBool())
			return (HVCEnumProp)hVCEnumPriv;
	}
	delete hVCEnumPriv->pEnum;
	delete hVCEnumPriv;
	return (HVCEnumProp)NULL;
}

/////////////////////////////////////////////////////////////////////////////
extern "C" 
DllExport DWORD VCGetNextProp(HVCEnumProp hVCEnum)
{
    HVCEnumPropPriv hVCEnumPriv = (HVCEnumPropPriv)hVCEnum;
    
	if (!hVCEnumPriv->pEnum)
		return FALSE;
	while ((hVCEnumPriv->prop = hVCEnumPriv->pEnum->NextProp(&(hVCEnumPriv->node)))) {
		if (!hVCEnumPriv->prop->IsBool())
			return TRUE;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport void VCGetPropClose(HVCEnumProp hVCEnum)
{
    HVCEnumPropPriv hVCEnumPriv = (HVCEnumPropPriv)hVCEnum;

	if (hVCEnumPriv->pEnum)
		delete hVCEnumPriv->pEnum;
    if (hVCEnumPriv->pendingRemove) {
    	for (CLISTPOSITION pos = hVCEnumPriv->pendingRemove->GetHeadPosition(); pos; ) {
    		VCPendingRemove *pr = (VCPendingRemove*)hVCEnumPriv->pendingRemove->GetNext(pos);
			if (pr->prop->IsBool()) {
				CList *props = pr->node->GetProps();
				CLISTPOSITION pos2;
				if ((pos2 = props->Find(pr->prop))) {
					props->RemoveAt(pos2);
					delete pr->prop;
				}
			} else {
				CVCNode *parent = hVCEnumPriv->vCard->ParentForObject(pr->node);
				CList *props = parent->GetProps();
		    	for (CLISTPOSITION pos2 = props->GetHeadPosition(); pos2; ) {
		    		CVCProp *prop = (CVCProp*)props->GetNext(pos2);
		    		CVCValue *value = prop->FindValue(vcNextObjectType);
		    		if (value && (CVCObject*)value->GetValue() == pr->node) {
		    			props->RemoveAt(pos2 ? pos2->m_prev : props->GetTailPosition());
		    			delete prop;
		    			break;
		    		}
		    	}
		    }
    		delete pr;
    	}
    	delete hVCEnumPriv->pendingRemove;
    }
	delete hVCEnumPriv;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport HVCEnumBoolProp VCGetFirstBoolProp(HVCEnumProp hVCEnum)
{
    HVCEnumPropPriv hVCEnumPropPriv = (HVCEnumPropPriv)hVCEnum;
    HVCEnumListPriv hVCEnumPriv = new VCEnumListPriv;
    CList *props = hVCEnumPropPriv->node->GetProps();

    for (CLISTPOSITION pos = props->GetHeadPosition(); pos; ) {
    	CVCProp *prop = (CVCProp*)props->GetNext(pos);
    	if (prop->IsBool())
    		hVCEnumPriv->list.AddTail(prop);
    }
    if (hVCEnumPriv->list.GetCount() == 0) {
    	delete hVCEnumPriv; hVCEnumPriv = NULL;
    } else {
    	hVCEnumPriv->pos = hVCEnumPriv->list.GetHeadPosition();
    	hVCEnumPriv->parentPropEnum = hVCEnumPropPriv;
        hVCEnumPriv->node = hVCEnumPropPriv->node;
	}
	return (HVCEnumBoolProp)hVCEnumPriv;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport DWORD VCGetNextBoolProp(HVCEnumBoolProp hVCEnum)
{
    HVCEnumListPriv hVCEnumPriv = (HVCEnumListPriv)hVCEnum;
    
    hVCEnumPriv->list.GetNext(hVCEnumPriv->pos);
    if (hVCEnumPriv->pos == NULL)
    	return 0;
    return 1;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport void VCGetBoolPropClose(HVCEnumBoolProp hVCEnum)
{
    HVCEnumListPriv hVCEnumPriv = (HVCEnumListPriv)hVCEnum;
	delete hVCEnumPriv;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport void VCPropName(HVCEnumProp hVCEnum, LPSTR lpstr)
{
    HVCEnumPropPriv hVCEnumPriv = (HVCEnumPropPriv)hVCEnum;
	strcpy(lpstr, hVCEnumPriv->prop->GetName());
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport void VCBoolPropName(HVCEnumBoolProp hVCEnum, LPSTR lpstr)
{
    HVCEnumListPriv hVCEnumPriv = (HVCEnumListPriv)hVCEnum;
    CVCProp *prop = (CVCProp*)hVCEnumPriv->list.GetAt(hVCEnumPriv->pos);
	strcpy(lpstr, prop->GetName());
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport int VCPropStringValue(HVCEnumProp hVCEnum, LPWSTR lpwstr, int len)
{
    HVCEnumPropPriv hVCEnumPriv = (HVCEnumPropPriv)hVCEnum;
    CVCValue *value = (CVCValue*)hVCEnumPriv->prop->FindValue(vcStrIdxType);
    if (!value)
		return 0;
	LPCWSTR str = (LPCWSTR)value->GetValue();
	int strlen = wcslen(str);
	if (strlen + 1 > len)
		return -(strlen + 1);
	wcscpy(lpwstr, str);
	return strlen;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport HGLOBAL VCPropBinaryValue(HVCEnumProp hVCEnum, LPCSTR lpszType)
{
    HVCEnumPropPriv hVCEnumPriv = (HVCEnumPropPriv)hVCEnum;
    CVCValue *value = (CVCValue*)hVCEnumPriv->prop->FindValue(lpszType);
    long count;
    HGLOBAL hGlobal;
    U8 __huge *ptr;
    
    if (!value)
		return NULL;
	count = value->GetSize();
	if ((hGlobal = GlobalAlloc(GMEM_SHARE, count)) == NULL)
		return hGlobal;
	if ((ptr = (U8 __huge *)GlobalLock(hGlobal)) == NULL) {
		GlobalUnlock(hGlobal);
		return NULL;
	}
	_hmemcpy(ptr, (U8 __huge *)value->GetValue(), count);
	GlobalUnlock(hGlobal);
	return hGlobal;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport HVCEnumProp VCAddStringProp(
	HVCEnumCard hVCEnum, LPCSTR lpszPropName, LPCWSTR value)
{
    return NewProp(
    	hVCEnum, lpszPropName, vcStrIdxType, (void*)value,
		(wcslen(value) + 1) * sizeof(wchar_t));
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport HVCEnumProp VCAddBinaryProp(
	HVCEnumCard hVCEnum, LPCSTR lpszPropName, LPCSTR lpszType, HGLOBAL value)
{
	HVCEnumProp hVCEnumProp;
    U8 __huge *ptr;
    
	if ((ptr = (U8 __huge *)GlobalLock(value)) == NULL)
		return NULL;
    hVCEnumProp = NewProp(
    	hVCEnum, lpszPropName, lpszType, (void*)ptr, GlobalSize(value));
	GlobalUnlock(value);
	return hVCEnumProp;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport DWORD VCSetStringProp(HVCEnumProp hVCEnum, LPCWSTR value)
{
    HVCEnumPropPriv hVCEnumPriv = (HVCEnumPropPriv)hVCEnum;
    CVCValue *val = (CVCValue*)hVCEnumPriv->prop->FindValue(vcStrIdxType);
    if (!val)
		return FALSE;
	val->SetValue((void*)value, (wcslen(value) + 1) * sizeof(wchar_t));
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport DWORD VCSetBinaryProp(HVCEnumProp hVCEnum, LPCSTR lpszType, HGLOBAL value)
{
    HVCEnumPropPriv hVCEnumPriv = (HVCEnumPropPriv)hVCEnum;
    CVCValue *val = (CVCValue*)hVCEnumPriv->prop->FindValue(lpszType);
    U8 __huge *ptr;
    
    if (!val)
		return FALSE;
	if ((ptr = (U8 __huge *)GlobalLock(value)) == NULL)
		return FALSE;
	val->SetValue((void*)ptr, GlobalSize(value));
	GlobalUnlock(value);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport DWORD VCAddBoolProp(LPCSTR lpszPropName, HVCEnumProp addTo)
{
    HVCEnumPropPriv hVCEnumPriv = (HVCEnumPropPriv)addTo;
    hVCEnumPriv->node->AddBoolProp(lpszPropName);
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport void VCRemoveProp(HVCEnumProp hVCEnum)
{
    HVCEnumPropPriv hVCEnumPriv = (HVCEnumPropPriv)hVCEnum;
    VCPendingRemove *pr;
    
    if (!hVCEnumPriv->pendingRemove)
    	hVCEnumPriv->pendingRemove = new CList;
    pr = new VCPendingRemove;
    pr->node = hVCEnumPriv->node;
    pr->prop = hVCEnumPriv->prop;
    hVCEnumPriv->pendingRemove->AddTail(pr);
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport void VCRemoveBoolProp(HVCEnumBoolProp hVCEnum)
{
    HVCEnumListPriv hVCEnumPriv = (HVCEnumListPriv)hVCEnum;
    CVCProp *prop = (CVCProp*)hVCEnumPriv->list.GetAt(hVCEnumPriv->pos);
    VCPendingRemove *pr;
    
    if (!hVCEnumPriv->parentPropEnum->pendingRemove)
    	hVCEnumPriv->parentPropEnum->pendingRemove = new CList;
    pr = new VCPendingRemove;
    pr->node = hVCEnumPriv->node;
    pr->prop = prop;
    hVCEnumPriv->parentPropEnum->pendingRemove->AddTail(pr);
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport void VCRemoveBoolPropByName(HVCEnumProp hVCEnum, LPCSTR name)
{
	HVCEnumBoolProp bprop = VCGetFirstBoolProp(hVCEnum);
	
	if (bprop) {
		char propName[VC_PROPNAME_MAX];
		VCBoolPropName(bprop, propName);
		if (strcmp(propName, name) == 0)
			VCRemoveBoolProp(bprop);
		// process remaining props
		while (VCGetNextBoolProp(bprop)) {
			VCBoolPropName(bprop, propName);
			if (strcmp(propName, name) == 0)
				VCRemoveBoolProp(bprop);
		}
		VCGetBoolPropClose(bprop);
	}
}

/////////////////////////////////////////////////////////////////////////////
extern "C" 
DllExport DWORD VCSaveCardToPath(LPCSTR path, HVCEnumCard hVCEnum)
{
    HVCEnumListPriv hVCEnumPriv = (HVCEnumListPriv)hVCEnum;
	CVCard *vCard = (CVCard*)hVCEnumPriv->list.GetAt(hVCEnumPriv->pos);
	ofstream strm(path, ios::app);
	vCard->Write(strm);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
extern "C" 
DllExport HGLOBAL VCSaveCardToMem(HVCEnumCard hVCEnum)
{
	char *tempname;
	HGLOBAL hGlobal = NULL;

	tempname = _tempnam(NULL, "CARD");
	if (VCSaveCardToPath(tempname, hVCEnum)) {
		hGlobal = LoadFile(tempname);
		unlink(tempname);
	}
	free(tempname);
	return hGlobal;
}


//---------------------------------------------------------------------------
// Private functions
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
static HGLOBAL LoadFile(LPCSTR path)
{
	fpos_t inLength;
	DWORD count, numAlloc, num;
	FILE *file;
	U8 __huge *ptr;
	BOOL error = FALSE;
	HGLOBAL hGlobal = NULL;

	file = fopen(path, "rb");
	fseek(file, 0, SEEK_END);
	fgetpos(file, &inLength);
	fseek(file, 0, SEEK_SET);
	count = (DWORD)inLength;
	if ((hGlobal = GlobalAlloc(GMEM_SHARE, count)) == NULL)
		goto Done;
	if ((ptr = (U8 __huge *)GlobalLock(hGlobal)) == NULL) {
		GlobalFree(hGlobal); hGlobal = NULL;
		goto Done;
	}
	if ((numAlloc = GlobalSize(hGlobal)) > count)
		memset(ptr + count, 0, (int)(numAlloc - count));
	do {
		num = min(count, 0x7FFF);
		fread(ptr, 1, (size_t)num, file);
		if (ferror(file))
			error = TRUE;
		else {
			count -= num;
			ptr += num;
		}
	} while (count && !error);
	GlobalUnlock(hGlobal);
	if (error) {
		GlobalFree(hGlobal); hGlobal = NULL;
	}
Done:
	fclose(file);
	return hGlobal;
}

static const char *groupAddr[] = {
	vcExtAddressProp,
	vcStreetAddressProp,
	vcCityProp,
	vcRegionProp,
	vcPostalCodeProp,
	vcCountryNameProp,
	NULL
};

static const char *groupPersonName[] = {
	vcFamilyNameProp,
	vcGivenNameProp,
	NULL
};

static const char *groupCompanyName[] = {
	vcOrgNameProp,
	vcOrgUnitProp,
	NULL
};

static BOOL IsMemberOfGroup(const char *propName, const char **group)
{
	while (*group) {
		if (strcmp(propName, *group) == 0)
			return TRUE;
		group++;
	}
	return FALSE;
}

static CVCNode* FindGroup(CVCNode* body, const char **group)
{
	CVCPropEnumerator enumerator(body);
	CVCNode* node;
	CVCProp* prop;
	
	while ((prop = enumerator.NextProp(&node))) {
		if (IsMemberOfGroup(prop->GetName(), group))
			return node;
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
static HVCEnumProp NewProp(
	HVCEnumCard hVCEnum, LPCSTR lpszPropName, LPCSTR lpszType,
	void *value, S32 size)
{
    HVCEnumListPriv hVCEnumListPriv = (HVCEnumListPriv)hVCEnum;
    CVCard *vCard = (CVCard*)hVCEnumListPriv->list.GetAt(hVCEnumListPriv->pos);
	CVCNode *body = vCard->FindBody();
    HVCEnumPropPriv hVCEnumPriv = new VCEnumPropPriv;
	
	if (IsMemberOfGroup(lpszPropName, groupAddr))
		hVCEnumPriv->node = FindGroup(body, groupAddr);
	else if (IsMemberOfGroup(lpszPropName, groupPersonName))
		hVCEnumPriv->node = FindGroup(body, groupPersonName);
	else if (IsMemberOfGroup(lpszPropName, groupCompanyName))
		hVCEnumPriv->node = FindGroup(body, groupCompanyName);
	else
		hVCEnumPriv->node = body->AddPart();
	if (!hVCEnumPriv->node)
		hVCEnumPriv->node = body->AddPart();
	hVCEnumPriv->node->AddProp(
		hVCEnumPriv->prop = new CVCProp(lpszPropName, lpszType, value, size));

	hVCEnumPriv->pEnum = NULL;
	hVCEnumPriv->pendingRemove = NULL;
	hVCEnumPriv->vCard = vCard;
	return (HVCEnumProp)hVCEnumPriv;
}

// Simple-minded conversion from UNICODE to char string
char *UI_CString(const wchar_t *u, char *dst)
{
	char *str = dst;
	while (*u) {
		if (*u == 0x2028) {
			*dst++ = '\r';
			*dst++ = '\n';
			u++;
		} else
			*dst++ = (char)*u++;
	}
	*dst = '\000';
	return str;
}

CM_CFUNCTIONS

void Parse_Debug(const char *s)
{
	::AfxTrace(s);
}

/*/////////////////////////////////////////////////////////////////////////*/
void msv_error(char *s)
{
	if (++msv_numErrors <= 3) {
		char buf[80];
		sprintf(buf, "%s at line %d", s, msv_lineNum);
		//TRACE1("%s\n", buf);
	}
}

/*/////////////////////////////////////////////////////////////////////////*/
void mime_error(char *s)
{
	if (++mime_numErrors <= 3) {
		char buf[80];
		sprintf(buf, "%s at line %d", s, mime_lineNum);
		//TRACE1("%s\n", buf);
	}
}

CM_END_CFUNCTIONS


/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcdatsrc.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#include "stdafx.h"
#include "VCDoc.h"
#include "VCard.h"
#include "VCDatSrc.h"

/////////////////////////////////////////////////////////////////////////////
CVCDataSource::CVCDataSource(CVCDoc *doc)
{
	m_cards = (CVCard *)doc->GetVCard()->Copy();
}

/////////////////////////////////////////////////////////////////////////////
CVCDataSource::~CVCDataSource()
{
	delete m_cards;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVCDataSource::OnRenderData(
	LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
	FILE *file;
	char *tempname;
	HGLOBAL hGlobal = NULL;

	ASSERT(lpFormatEtc->tymed & TYMED_HGLOBAL);
	tempname = _tempnam(NULL, "CARD");
	if (!(file = fopen(tempname, "w+"))) {
		free(tempname);
		return FALSE;
	}

	if (m_cards->Write(file)) {
		fpos_t inLength;
		DWORD count, numAlloc;
		U8 *ptr;

		fclose(file);
		file = fopen(tempname, "rb");
		fseek(file, 0, SEEK_END);
		fgetpos(file, &inLength);
		fseek(file, 0, SEEK_SET);
		count = (int)inLength;
		hGlobal = GlobalAlloc(GMEM_SHARE, count);
		ptr = (U8 *)GlobalLock(hGlobal);
		if ((numAlloc = GlobalSize(hGlobal)) > count)
			memset(ptr + count, 0, numAlloc - count);
		fread(ptr, 1, count, file);
		GlobalUnlock(hGlobal);
		if (ferror(file)) {
			GlobalFree(hGlobal); hGlobal = NULL;
		}
	}

	fclose(file);
	unlink(tempname);
	free(tempname);
	lpStgMedium->tymed = hGlobal ? TYMED_HGLOBAL : TYMED_NULL;
	lpStgMedium->hGlobal = hGlobal;
	lpStgMedium->pUnkForRelease = NULL;
	return hGlobal != NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcdatsrc.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#include <afxole.h>

class CVCard;

class CVCDataSource : public COleDataSource
{
public:
	CVCDataSource(CVCDoc *doc);
	virtual ~CVCDataSource();

	BOOL OnRenderData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);
	
protected:
	CVCard *m_cards;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcdll.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#ifndef _VCDLL_H_
#define _VCDLL_H_

#include "wchar.h"

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#define VC_PROPNAME_MAX		64	// includes null terminator

typedef DWORD HVCEnumCard;
typedef DWORD HVCEnumProp;
typedef DWORD HVCEnumBoolProp;

#define VCARDAPI CALLBACK __export 


//---------------------------------------------------------------------------
// vCard enumeration functions
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// Use this to begin an enumeration of the vCards in a file.
// lpszFileName is the path to the file.  The returned value indicates
// the first vCard in the file.  Pass this value to VCGetNextCard to find
// more vCards in the file, if any.  Use VCGetCardClose on the returned value
// to close the enumeration.  This function will return NULL if no vCard
// could be successfully parsed from the file (and so VCGetCardClose does not
// need to be called).
HVCEnumCard VCARDAPI VCGetFirstCardFromPath(LPCSTR lpszFileName);

/////////////////////////////////////////////////////////////////////////////
// Same as above, but takes a block of memory.
HVCEnumCard VCARDAPI VCGetFirstCardFromMem(HGLOBAL hGlobal);

/////////////////////////////////////////////////////////////////////////////
// Same as above, but creates a new card.
// Although there isn't much point in enumerating this, it is useful
// to then use the VCAdd* functions to construct the new card, then save it.
HVCEnumCard VCARDAPI VCGetNewCard();

/////////////////////////////////////////////////////////////////////////////
// VCGetNextCard sets the hVCEnum to indicate the next vCard in the file.
// hVCEnum is a handle obtained previously from VCGetFirstCard*.
// This function returns non-zero if successful, and 0 if there were no
// more cards that could be parsed from the file.  Use VCGetCardClose on the
// hVCEnum when finished.
DWORD VCARDAPI VCGetNextCard(HVCEnumCard hVCEnum);

/////////////////////////////////////////////////////////////////////////////
// Closes a card enumeration.
void VCARDAPI VCGetCardClose(HVCEnumCard hVCEnum);


//---------------------------------------------------------------------------
// property enumeration functions
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// Gets the first non-boolean prop.  Has the same enumeration semantics
// as with VCGetFirstCard*.
HVCEnumProp VCARDAPI VCGetFirstProp(HVCEnumCard hVCEnum);

/////////////////////////////////////////////////////////////////////////////
// Gets the next non-boolean prop.  Has the same enumeration semantics
// as with VCGetNextCard.
DWORD VCARDAPI VCGetNextProp(HVCEnumProp hVCEnum);

/////////////////////////////////////////////////////////////////////////////
// Closes a property enumeration.
void VCARDAPI VCGetPropClose(HVCEnumProp hVCEnum);

/////////////////////////////////////////////////////////////////////////////
// Gets the first boolean prop associated with hVCProp.
HVCEnumBoolProp VCARDAPI VCGetFirstBoolProp(HVCEnumProp hVCEnum);

/////////////////////////////////////////////////////////////////////////////
// Gets the next boolean prop associated with hVCEnum.
DWORD VCARDAPI VCGetNextBoolProp(HVCEnumBoolProp hVCEnum);

/////////////////////////////////////////////////////////////////////////////
// Closes a bool property enumeration.
void VCARDAPI VCGetBoolPropClose(HVCEnumBoolProp hVCEnum);


//---------------------------------------------------------------------------
// property data functions
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// Copies into lpstr the name of the property.
// The buffer must be of at least VC_PROPNAME_MAX in length.
void VCARDAPI VCPropName(HVCEnumProp hVCEnum, LPSTR lpstr);

/////////////////////////////////////////////////////////////////////////////
// Copies into lpstr the name of the property.
// The buffer must be of at least VC_PROPNAME_MAX in length.
void VCARDAPI VCBoolPropName(HVCEnumBoolProp hVCEnum, LPSTR lpstr);

/////////////////////////////////////////////////////////////////////////////
// Copies into lpstr the string value of the property, if any.
// If the property has no string value, lpstr[0] is set to 0 and the
// function returns 0.  If there isn't enough room in the buffer,
// the function returns the negative of the number of characters needed.
// When successful, the function returns the length of the returned string.
int VCARDAPI VCPropStringValue(HVCEnumProp hVCEnum, LPWSTR lpwstr, int len);

/////////////////////////////////////////////////////////////////////////////
// This function returns a copy of the prop's value of the given type,
// or NULL if the prop has no such type.  lpszType should be one of
// VCOctetsType, VCGIFType, or VCWAVType.  The client is responsible
// for freeing the returned data.
HGLOBAL VCARDAPI VCPropBinaryValue(HVCEnumProp hVCEnum, LPCSTR lpszType);


//---------------------------------------------------------------------------
// editing functions
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// This adds a string property to a card.
// The returned prop won't have any associated boolean props.
// The client must call VCGetPropClose on the returned prop when finished.
// The returned enumeration is restricted to just this new property,
// so calling VCGet*Prop on it is pointless.
// Note: any open enumerations of this card may or may not discover and
// return this new property.  The client should close any open enumerations
// of the card and begin with new enumerations after using VCAddStringProp
// in order to achieve predictable results.
HVCEnumProp VCARDAPI VCAddStringProp(
	HVCEnumCard hVCEnum, LPCSTR lpszPropName, LPCWSTR value);

/////////////////////////////////////////////////////////////////////////////
// Adds a binary prop to the card.  The value is copied, so the parameter
// value is still "owned" by the caller.
// The parameter type should be one of VCOctetsType, VCGIFType, or VCWAVType.
// This function has the same semantics as VCAddStringProp with respect to
// using VCGetPropClose and the effects on open enumerations.
HVCEnumProp VCARDAPI VCAddBinaryProp(
	HVCEnumCard hVCEnum, LPCSTR lpszPropName, LPCSTR lpszType, HGLOBAL value);

/////////////////////////////////////////////////////////////////////////////
// Changes the value of an existing string prop.
// This function returns non-zero if successful.
DWORD VCARDAPI VCSetStringProp(HVCEnumProp hVCEnum, LPCWSTR value);

/////////////////////////////////////////////////////////////////////////////
// Changes the value of an existing binary prop.
// This function returns non-zero if successful.
// The value is copied.
// The parameter type should be one of VCOctetsType, VCGIFType, or VCWAVType.
DWORD VCARDAPI VCSetBinaryProp(HVCEnumProp hVCEnum, LPCSTR lpszType, HGLOBAL value);

/////////////////////////////////////////////////////////////////////////////
// Associates a boolean prop with the given property.
// This function returns non-zero if successful.
// Note: any open enumerations of this card may or may not discover and
// return this new property.  The client should close any open enumerations
// of the card and begin with new enumerations after using VCAddBoolProp
// in order to achieve predictable results.
DWORD VCARDAPI VCAddBoolProp(LPCSTR lpszPropName, HVCEnumProp addTo);

/////////////////////////////////////////////////////////////////////////////
// Removes a prop.  This will remove all associated boolean props.
// Note: the actual removal won't happen until the prop enumeration is closed
// with VCGetPropClose.
void VCARDAPI VCRemoveProp(HVCEnumProp hVCEnum);

/////////////////////////////////////////////////////////////////////////////
// Removes a bool prop.
// Note: the actual removal won't happen until the enclosing non-bool prop
// enumeration is closed with VCGetPropClose.
// See Also: VCRemoveBoolPropByName.
void VCARDAPI VCRemoveBoolProp(HVCEnumBoolProp hVCEnum);

/////////////////////////////////////////////////////////////////////////////
// This is a convenience function that opens up a new bool prop enumeration
// for the given prop, searches for any bool props of the given name, and
// removes them (typically just one will be found).  This function uses
// VCRemoveBoolProp.
// See Also: VCRemoveBoolProp.
void VCARDAPI VCRemoveBoolPropByName(HVCEnumProp hVCEnum, LPCSTR name);


//---------------------------------------------------------------------------
// card output functions
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// Writes a vCard to a file.
DWORD VCARDAPI VCSaveCardToPath(LPCSTR path, HVCEnumCard hVCEnum);

/////////////////////////////////////////////////////////////////////////////
// Same as above, but writes to a new memory block.
// The caller is responsible for freeing it.
HGLOBAL VCARDAPI VCSaveCardToMem(HVCEnumCard hVCEnum);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* _VCDLL_H_ */

/***************************************************************************/

#if 0
// This is some sample code.  It will print to the debugging output
// the VCFullNameProp and all VCTelephoneProp's that are FAX numbers
// (those that have the associated boolean prop VCFaxProp).
void ProcessCardFile(LPCSTR path)
{
	HVCEnumCard hVCEnumCard;
	
	hVCEnumCard = VCGetFirstCardFromPath(path);
	if (hVCEnumCard) {
		ProcessCard(hVCEnumCard);
		// process remaining cards
		while (VCGetNextCard(hVCEnumCard)) {
			// process a card
		}
		VCGetCardClose(hVCEnumCard);
	}
} // ProcessCardFile

void ProcessCard(HVCEnumCard hVCEnumCard)
{
	HVCEnumProp hVCEnumProp;

	hVCEnumProp = VCGetFirstProp(hVCEnumCard);
	if (hVCEnumProp) {
		ProcessProp(hVCEnumProp);
		// process remaining props
		while (VCGetNextProp(hVCEnumProp)) {
			ProcessProp(hVCEnumProp);
		}
		VCGetPropClose(hVCEnumProp);
	}
} // ProcessCard

void ProcessProp(HVCEnumProp hVCEnumProp)
{
#define STRBUFLEN 128
	char propName[VC_PROPNAME_MAX];
	wchar_t stackUniBuf[STRBUFLEN];
	char stackStrBuf[STRBUFLEN];
	int len;
	
	VCPropName(hVCEnumProp, propName);
	if (strcmp(propName, VCFullNameProp) == 0) {
		if ((len = VCPropStringValue(hVCEnumProp, stackUniBuf, STRBUFLEN)) < 0) {
			// need to allocate because it's bigger than STRBUFLEN
			// -(len) is number of characters required
		} else {
			// string value fits within STRBUFLEN
			TRACE1("full name is %s\n", UI_CString(stackUniBuf, stackStrBuf));
		}
	} else if (strcmp(propName, VCTelephoneProp) == 0) {
		HVCEnumBoolProp hVCEnumBoolProp;
		BOOL isFax = FALSE;
		
		hVCEnumBoolProp = VCGetFirstBoolProp(hVCEnumProp);
		if (hVCEnumBoolProp) {
			VCBoolPropName(hVCEnumBoolProp, propName);
			if (strcmp(propName, VCFaxProp) == 0) {
				isFax = TRUE;
			} else {
				while (VCGetNextBoolProp(hVCEnumBoolProp)) {
					VCBoolPropName(hVCEnumBoolProp, propName);
					if (strcmp(propName, VCFaxProp) == 0) {
						isFax = TRUE;
						break;
					}
				}
			}
			if (isFax) {
				if ((len = VCPropStringValue(hVCEnumProp, stackUniBuf, STRBUFLEN)) < 0) {
					// need to allocate because it's bigger than STRBUFLEN
					// -(len) is number of characters required
				} else {
					// string value fits within STRBUFLEN
					TRACE1("FAX TEL is %s\n", UI_CString(stackUniBuf, stackStrBuf));
				}
			}
			VCGetBoolPropClose(hVCEnumBoolProp);
		}
	}
} // ProcessProp

// Simple-minded conversion from UNICODE to char string
char *UI_CString(const wchar_t *u, char *dst)
{
	char *str = dst;
	while (*u) {
		if (*u == 0x2028) {
			*dst++ = '\r';
			*dst++ = '\n';
			u++;
		} else
			*dst++ = (char)*u++;
	}
	*dst = '\000';
	return str;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcard.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#ifndef __VCARD_H__
#define __VCARD_H__

#if defined(_WIN32)
#include <wchar.h>
#else
#include "wchar.h"
#endif
#include <iostream.h>
#include <stdio.h>
#include "vcenv.h"
#include "ref.h"

#if defined(_WIN32) || defined(__MWERKS__)
#define __huge
#endif

class CVCNode;
class CVCProp;
class CVCValue;
class CList;

/////////////////////////////////////////////////////////////////////////////
class CVCObject
{
public:
	virtual ~CVCObject() {}
	virtual CVCObject *Copy() = 0;
};

/////////////////////////////////////////////////////////////////////////////

// A CVCard represents a VersitCard that can contain zero or more
// root objects.  Class CVCard implements reading from / writing to
// filed representations in either Html or MSV formats.
class CVCard : public CVCObject
{
public:
	CVCard();
	~CVCard();
	CVCObject *Copy();

	CList *GetObjects(); // each is a CVCNode*

	CVCard &AddObject(CVCNode *object);
		// to end of list; object becomes owned by CVCard
	CVCard &RemoveObject(CVCNode *object, BOOL destroy = TRUE);

	CVCNode *ParentForObject(CVCNode *object);
		// Find the parent, if any.  If it was a root, it itself is returned.
		// If the object is nowhere in the CVCard, NULL is returned.

	CVCProp *GetInheritedProp(CVCNode *object, const char *name, CVCNode **node = NULL);
		// Beginning at the object and moving parent-ward to the root,
		// look for a property maching the name along the way.
		// Return the property value, or NULL if none found.
		// If node is supplied, set *node to the node that has the property.

	void GetPropsInEffect(CVCNode *object, CList *list);
		// Collect all the properties in effect for an object.

	CVCNode *FindBody(const char *language = NULL);
		// searches the first root object for a body of the given language.
		// If no body objects match, returns the first body object.
		// If the first root object has no body objects, returns the first
		// root object.  If language is NULL, returns first body.

	BOOL Write(ostream& strm);
	BOOL Write(FILE *outputFile); // older version for compatibility

protected:
	CList *m_roots;
};

/*
 Boolean properties, such as VCDomesticProp, are represented in the card
 as the presence or absence of the property itself.  When present, the
 property has no real value (just one CVCValue of type VCNullType).
*/

/////////////////////////////////////////////////////////////////////////////

// A CVCNode represents an object that can have properties.
class CVCNode : public CVCObject
{
public:
	CVCNode(CVCProp *prop = NULL);
		// if supplied, an initial property is added (and the property
		// becomes owned by CVCNode)
	~CVCNode();
	CVCObject *Copy();

	CList *GetProps(); // each is a CVCProp*

	// These are short forms of using GetProps() and using the list directly.
	CVCProp *GetProp(const char *name);

	CVCNode &AddProp(CVCProp *prop);
		// to end of list; property becomes owned by CVCNode

	CVCNode *AddObjectProp(const char *propName, const char *marker = NULL);
		// Create a new CVCNode, optionally add a "marker" property to it
		// if supplied, and add this new object to self's properties
		// under "propName" (as a CVCValue of type VCNextObjectType).
		// Return the created node.

	CVCNode *AddPart();
		// Convenience for AddObjectProp(VCPartProp, VCPartObject).

	CVCProp *AddStringProp(const char *propName, const char *value, VC_DISPTEXT *dispText = NULL);
		// Add a property under "propName" whose value is a UNICODE string
		// derived from the given 8-bit string.

	CVCProp *AddBoolProp(const char *propName);
		// Sets the boolean property on this node.  By its presence, this
		// indicates a value of TRUE.

	CVCNode &RemoveProp(const char *name, BOOL destroy = TRUE);

	BOOL AncestryForObject(CVCNode *object, CList *ancestry);
		// If the object is a "child" of self, extend the ancestry list
		// to reflect the entire chain.  If not, the ancestry list remains
		// untouched.  Answer whether the object was found as a child.
		// This method assumes that the ancestry list passed is non-NULL
		// and contains self's parent (as head) thru the root object (as tail).

	BOOL Write(ostream& strm, const wchar_t *prefix, void *context);
	void FlagsToOutput(char *str);

protected:
	void WriteMultipart(
		ostream& strm, const char *outName, const char *propName1,
		const char *propName2, const char *propName3,
		const char *propName4, const char *propName5, BOOL qp);

	CList *m_props; // each item is a CVCProp*
};

/////////////////////////////////////////////////////////////////////////////

// A CVCProp represents a named list of type/value associations.
class CVCProp : public CVCObject
{
public:
	CVCProp(const char *name, CVCValue *value = NULL);
		// name is copied; value, if supplied, would become owned by CVCProp
	CVCProp(const char *name, const char *type, void *value = NULL, S32 size = 0);
		// name is copied.  Creates a new CVCValue from other arguments
		// and adds that value.
	~CVCProp();
	CVCObject *Copy();

	CList *GetValues(); // each is a CVCValue*

	const char *GetName();
	CVCProp &SetName(const char *name); // name is copied

	CVCProp &AddValue(CVCValue *value);
		// to end of list; value becomes owned by CVCProp
	CVCProp &RemoveValue(CVCValue *value, BOOL destroy = TRUE);
	CVCProp &RemoveValue(const char *type, BOOL destroy = TRUE);

	CVCValue *FindValue(const char *type = NULL, void *value = NULL);
		// Find and return the first value that has either the given type or value.
		// For value comparisons, only pointer equality is used.

	BOOL IsBool();
	
	BOOL Write(
		ostream& strm, const wchar_t *prefix, CVCNode *node, void *context);

protected:
	char *m_name;
	CList *m_values;
};

/////////////////////////////////////////////////////////////////////////////

// A CVCValue represents a typed, but otherwise nameless, value.
// Values of type VCNextObjectType hold a pointer to a CVCNode object.
// The 'size' quantity for such values is 0.
// All other values hold a void* pointer together with a size in bytes of
// that storage.  A size of 0 indicates that the void* pointer wasn't
// allocated, and the void* should be considered to be a U32.
class CVCValue : public CVCObject
{
public:
	CVCValue(const char *type = NULL, void *value = NULL, S32 size = 0);
		// type and value are copied
		// If type is NULL, the value's type will be VCNullType

	~CVCValue();
	CVCObject *Copy();

	const char *GetType();
	CVCValue &SetType(const char *type); // type is copied
		// does a SetValue() first so that an old value
		// is cleaned up properly

	void *GetValue();
	CVCValue &SetValue(void *value = NULL, S32 size = 0);
		// value is copied; old value is destroyed, if any

	S32 GetSize();

protected:
	char *m_type;
	void *m_value;
	S32 m_size;
};

/////////////////////////////////////////////////////////////////////////////

// CVCPropEnumerator provides for deep enumeration of properties beginning at
// some arbitrary object.  CVCPropEnumerator knows about VCBodyProp,
// VCPartProp, and VCNextObjectProp, and will search down those lists.
class CVCPropEnumerator
{
public:
	CVCPropEnumerator(CVCNode *root);

	virtual ~CVCPropEnumerator();

	CVCProp *NextProp(CVCNode **node = NULL);

protected:
	CList *m_objects;
	CList *m_positions;
};

extern void FixCRLF(wchar_t * ps);
extern wchar_t *FakeUnicode(const char * ps, int * bytes);
U8 __huge * _hmemcpy(U8 __huge * dst, U8 __huge * src, S32 len);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcir.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// Machine generated IDispatch wrapper class(es) created with ClassWizard
/////////////////////////////////////////////////////////////////////////////
// IVCServer_IR wrapper class

class IVCServer_IR : public COleDispatchDriver
{
public:
	IVCServer_IR() {}		// Calls COleDispatchDriver default constructor
	IVCServer_IR(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	IVCServer_IR(const IVCServer_IR& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	long SendFile(LPCTSTR path);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcir.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// Machine generated IDispatch wrapper class(es) created with ClassWizard

#include "stdafx.h"
#include "vcir.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// IVCServer_IR properties

/////////////////////////////////////////////////////////////////////////////
// IVCServer_IR operations

long IVCServer_IR::SendFile(LPCTSTR path)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x1, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		path);
	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcenv.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#ifndef __VCENV_H__
#define __VCENV_H__
                      
typedef char			S8,   *P_S8,   **PP_S8;
typedef unsigned char	U8,   *P_U8,   **PP_U8;
typedef short			S16,  *P_S16,  **PP_S16;
typedef unsigned short	U16,  *P_U16,  **PP_U16;	// WORD and UINT are equivalent
typedef long			S32,  *P_S32,  **PP_S32;
typedef unsigned long	U32,  *P_U32,  **PP_U32;	// DWORD is equivalent
typedef float			F32,  *P_F32,  **PP_F32;
typedef double			F64,  *P_F64,  **PP_F64;
//typedef unsigned short	UNICODE,  *P_UNICODE,  **PP_UNICODE;

#define maxS8  0x7F
#define maxU8  0xFF
#define maxS16 0x7FFF
#define maxU16 0xFFFF
#define maxS32 0x7FFFFFFF
#define maxU32 0xFFFFFFFF

typedef struct
    {
    F32 x, y;
    } FCOORD,  *P_FCOORD,  **PP_FCOORD;

#ifndef BOOL
typedef int                 BOOL;
#ifndef __MWERKS__
#define TRUE 1
#define FALSE 0
#endif
#endif

#ifdef __cplusplus
#define CM_CFUNCTION 		extern "C" {
#define CM_CFUNCTIONS 		extern "C" {
#define CM_END_CFUNCTION	}
#define CM_END_CFUNCTIONS	}
#else
#define CM_CFUNCTION
#define CM_CFUNCTIONS
#define CM_END_CFUNCTION
#define CM_END_CFUNCTIONS
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcdoc.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// VCdoc.cpp : implementation of the CVCDoc class

#include "stdafx.h"
#include "VC.h"

#include <strstrea.h>
#include "VCdoc.h"
#include "vcard.h"
#include "clist.h"
#include "gifread.h"
#include "mainfrm.h"
#include "msv.h"
#include "mime.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//#define TRY_CFILE

#define smPt 14
#define bgPt 16

CM_CFUNCTIONS

#if 0
extern BOOL Parse_HTML(
	const char *input,			/* In */
	int len,					/* In */
	const char *dirPath,		/* In */
	CVCard **card,				/* Out */
	int *_posPreambleEnd,		/* Out */
	int *_posPostambleStart,	/* Out */
	char **_unknownTags);		/* Out */
#endif

CM_END_CFUNCTIONS

CString CanonicalPath(const CString &path);
CString NativePath(const CString &path);


/////////////////////////////////////////////////////////////////////////////
// CVCDoc

IMPLEMENT_DYNCREATE(CVCDoc, CDocument)

BEGIN_MESSAGE_MAP(CVCDoc, CDocument)
	//{{AFX_MSG_MAP(CVCDoc)
	ON_COMMAND(ID_INSERT_LOGO, OnInsertLogo)
	ON_COMMAND(ID_INSERT_PHOTO, OnInsertPhoto)
	ON_COMMAND(ID_INSERT_PRONUN, OnInsertPronun)
	ON_COMMAND(ID_SEND_IRDA, OnSendIrda)
	ON_UPDATE_COMMAND_UI(ID_SEND_IRDA, OnUpdateSendIrda)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVCDoc construction/destruction

/////////////////////////////////////////////////////////////////////////////
CVCDoc::CVCDoc()
{
	// TODO: add one-time construction code here
	m_sizeDoc = CSize(8192, 5000);
	m_minSizeDoc = CSize(8192, 5000);
	m_vcard = NULL;
	m_preamble = m_postamble = NULL;
	m_preambleLen = m_postambleLen = 0;
	m_unknownTags = NULL;
}

/////////////////////////////////////////////////////////////////////////////
CVCDoc::~CVCDoc()
{
	if (m_vcard) delete m_vcard;
	if (m_preamble) delete [] m_preamble;
	if (m_postamble) delete [] m_postamble;
	if (m_unknownTags) delete m_unknownTags;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVCDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	CVCNode *root, *english;

	if (m_vcard)
		delete m_vcard;

	m_vcard = new CVCard;
	m_vcard->AddObject(root = new CVCNode);					// create root
	root->AddProp(new CVCProp(VCRootObject));				// mark it so

	english = root->AddObjectProp(vcBodyProp, VCBodyObject);

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CVCDoc serialization

void CVCDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
		ar << m_sizeDoc;
	}
	else
	{
		// TODO: add loading code here
		ar >> m_sizeDoc;
	}

	// Calling the base class CDocument enables serialization
	//  of the container document's COleClientItem objects.
	CDocument::Serialize(ar);
}

/////////////////////////////////////////////////////////////////////////////
// CVCDoc diagnostics

#ifdef _DEBUG
void CVCDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CVCDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CVCDoc commands

CString CVCDoc::PathToAuxFile(const char *auxPath)
{
	CString directory = GetPathName(), path;
	int slash = directory.ReverseFind('\\');
	CString auxStr(auxPath);

	if (slash == -1)
		directory = "";
	else
		directory = directory.Left(slash);
	path = (auxStr[0] == '/') ? NativePath(auxStr) : (directory + "\\" + NativePath(auxStr));
	return path;
}

/////////////////////////////////////////////////////////////////////////////
CString PathSansVolume(const CString &path)
{
	CString result;
	if (path.Find(':') == 1) // strip the volume name
		result = path.Right(path.GetLength() - 2);
	else if ((path.GetLength() > 2) && (path.Left(2) == "\\\\")) {
		// a path like \\Host\path
		int slash;
		result = path.Right(path.GetLength() - 2);
		VERIFY((slash = result.Find('\\')) != -1);
		result = result.Right(result.GetLength() - slash);
	} else
		result = path;
	return result;
}

HGLOBAL CVCDoc::ReadFileIntoMemory(const char *path, int *inputLen)
{
	fpos_t inLength;
	FILE *inputFile;
	U8 *buf = NULL;

	inputFile = fopen(path, "rb");
	if (!inputFile)
		goto Error;

	fseek(inputFile, 0, SEEK_END);
	fgetpos(inputFile, &inLength);
	fseek(inputFile, 0, SEEK_SET);

	if (!(buf = (U8 *)GlobalAlloc(0, (long)inLength)))
		goto Error;

	if (fread(buf, 1, (long)inLength, inputFile) < (unsigned)inLength)
		goto Error;

	*inputLen = (int)inLength;
	goto Done;

Error:
	if (buf) { GlobalFree(buf); buf = NULL; }

Done:
	if (inputFile)
		fclose(inputFile);
	return buf;
}

/////////////////////////////////////////////////////////////////////////////
// This sets some estimated display locations for some string properties.
// The final locations can be determined only after all the properties have
// been added to the body, and that is done by AdjustDisplayLocations().
VC_DISPTEXT *DisplayInfoForProp(const char *name, VC_DISPTEXT *info)
{
    //CClientDC dc(AfxGetApp()->m_pMainWnd);
    //dc.AssertValid();
	//int ppi = GetDeviceCaps(dc.m_hDC, LOGPIXELSY);

	memset(info, 0, sizeof(*info));
	info->typeSize = smPt;
	info->textAlign = VC_LEFT;
	info->textClass = VC_MODERN;

	/****  middle right group  ****/
	if (strcmp(name, vcFullNameProp) == 0) {
		info->x = 4200;
		info->y = 2500 + (smPt * 3) * 20;
	} else if (strcmp(name, vcTitleProp) == 0) {
		info->x = 4200;
		info->y = 2500 + (smPt * 2) * 20;
		info->textAttrs = VC_ITALIC;
	} else
	/****  lower right group  ****/
	if (strcmp(name, vcTelephoneProp) == 0) {
		info->x = 4200;
		info->y = 300 + (10 * 2) * 20;
		info->typeSize = 10;
	} else if (strcmp(name, vcEmailAddressProp) == 0) {
		info->x = 4200;
		info->y = 300 + (10 * 1) * 20;
		info->typeSize = 10;
	} else
	/****  upper left group  ****/
	if (strcmp(name, vcOrgNameProp) == 0) {
		info->x = 300;
		info->y = 5000 - 300;
		info->typeSize = bgPt;
	} else
	/****  middle left group  ****/
	if (strcmp(name, vcOrgUnitProp) == 0) {
		info->x = 300;
		info->y = 2500 + (smPt * 3) * 20;
	} else if (strcmp(name, vcDeliveryLabelProp) == 0) {
		info->x = 300;
		info->y = 2500 + (smPt * 2) * 20;
	}

	return info->x ? info : NULL;
}

/////////////////////////////////////////////////////////////////////////////
// This is called as a final step in the parsing, after the entire body has
// been built.  Now that all the properties and their estimated locations are
// there, some final tweaking can be done.
void AdjustDisplayLocations(CVCNode *body)
{
	CVCPropEnumerator *enumerator;
	CVCProp *prop;
	VC_DISPGIF *gifInfo = NULL;

	// is there a logo?
	enumerator = new CVCPropEnumerator(body);
	while ((prop = enumerator->NextProp())) {
		if (strcmp(prop->GetName(), vcLogoProp) == 0) {
			CVCValue *value = prop->FindValue(VCDisplayInfoGIFType);
			if (value) {
				gifInfo = (VC_DISPGIF *)value->GetValue();
				if (gifInfo->top < 1700) {
					VC_DISPGIF dt;
					int h = gifInfo->top - gifInfo->bottom;
					dt = *gifInfo;
					dt.top = 1700;
					dt.bottom = dt.top - h;
					value->SetValue(&dt, sizeof(dt));
					gifInfo = (VC_DISPGIF *)value->GetValue();
				}
			}
			break;
		}
	} // while
	delete enumerator;

	if (!gifInfo)
		return;

	// if have a logo, move middle right group (name, title) so that its top
	// is aligned with the top of the logo and adjust the top of the photo, if any
	enumerator = new CVCPropEnumerator(body);
	while ((prop = enumerator->NextProp())) {
		if (strcmp(prop->GetName(), vcFullNameProp) == 0) {
			VC_DISPTEXT *info = (VC_DISPTEXT *)prop->FindValue(VCDisplayInfoTextType)->GetValue();
			info->y = gifInfo->top;
		} else if (strcmp(prop->GetName(), vcTitleProp) == 0) {
			VC_DISPTEXT *info = (VC_DISPTEXT *)prop->FindValue(VCDisplayInfoTextType)->GetValue();
			info->y = gifInfo->top - smPt * 20;
		} else if (strcmp(prop->GetName(), vcPhotoProp) == 0) {
			CVCValue *value = prop->FindValue(VCDisplayInfoGIFType);
			VC_DISPGIF *photoInfo;
			int h;
			if (!value) continue;
			photoInfo = (VC_DISPGIF *)value->GetValue();
			h = photoInfo->top - photoInfo->bottom;
			photoInfo->bottom = gifInfo->top + smPt * 20;
			photoInfo->top = photoInfo->bottom + h;
		}
	} // while
	delete enumerator;
}

/////////////////////////////////////////////////////////////////////////////
void CVCDoc::SetDisplayInfo(CVCNode *body, const char *docPath)
{
	CVCPropEnumerator enumerator(body);
	CVCProp *prop;
	CString directory(docPath);
	int slash = directory.ReverseFind('\\');
	BOOL hasMask;
	FCOORD size;
	CGifReader gifRdr;

	if (slash == -1)
		directory = "";
	else
		directory = directory.Left(slash);

	while ((prop = enumerator.NextProp())) {
		const char *propName = prop->GetName();
		if (strcmp(propName, vcPhotoProp) == 0) {
			CVCValue *value = prop->FindValue(VCGIFType);
			istrstream strm((char *)value->GetValue(), value->GetSize());

			if (gifRdr.GetGifSize(&strm, &size, &hasMask)) {
				/****  upper right group  ****/
				VC_DISPGIF gifInfo;
				gifInfo.left = 4200;
				gifInfo.right = gifInfo.left + (int)size.x * 20;
				gifInfo.top = 5000 - 300;
				gifInfo.bottom = gifInfo.top - (int)size.y * 20;
				gifInfo.hasMask = hasMask;
				prop->AddValue(new CVCValue(VCDisplayInfoGIFType, &gifInfo, sizeof(gifInfo)));
			}
		} else if (strcmp(propName, vcLogoProp) == 0) {
			CVCValue *value = prop->FindValue(VCGIFType);
			istrstream strm((char *)value->GetValue(), value->GetSize());

			if (gifRdr.GetGifSize(&strm, &size, &hasMask)) {
				/****  lower left group  ****/
				VC_DISPGIF gifInfo;
				gifInfo.left = 300;
				gifInfo.right = gifInfo.left + (int)size.x * 20;
				gifInfo.top = 300 + (int)size.y * 20;
				gifInfo.bottom = gifInfo.top - (int)size.y * 20;
				gifInfo.hasMask = hasMask;
				prop->AddValue(new CVCValue(VCDisplayInfoGIFType, &gifInfo, sizeof(gifInfo)));
			}
		} else {
			VC_DISPTEXT dispText;
			if (DisplayInfoForProp(propName, &dispText))
				prop->AddValue(
					new CVCValue(VCDisplayInfoTextType, &dispText, sizeof(dispText)));
		}
	}

	AdjustDisplayLocations(body);
}

#ifdef TRY_CFILE
/////////////////////////////////////////////////////////////////////////////
BOOL CVCDoc::OnOpenDocument(LPCTSTR lpszPathName) 
{
	char *unknownTags = NULL;
	BOOL doPrePostamble = FALSE;
	CFile input(lpszPathName, CFile::modeRead | CFile::shareCompat);
	CString directory(lpszPathName);
	int slash = directory.ReverseFind('\\');

	//if (!CDocument::OnOpenDocument(lpszPathName))
		//return FALSE;
	
	if (m_preamble) { delete [] m_preamble; m_preamble = NULL; }
	if (m_postamble) { delete [] m_postamble; m_postamble = NULL; }
	if (m_unknownTags) { delete m_unknownTags; m_unknownTags = NULL; }
	m_preambleLen = m_postambleLen = 0;

	if (slash == -1)
		directory = "";
	else
		directory = directory.Left(slash);

	if (Parse_MSV_FromFile(&input, &m_vcard)) {
	} else if (Parse_MIME_FromFile(&input, &m_vcard)) {
	} else
		return FALSE;

	SetDisplayInfo(m_vcard->FindBody(), lpszPathName);

	if (unknownTags) {
		if (strlen(unknownTags))
			m_unknownTags = new CString(unknownTags);
		delete [] unknownTags;
	}

	return TRUE;
}
#else
/////////////////////////////////////////////////////////////////////////////
BOOL CVCDoc::OnOpenDocument(LPCTSTR lpszPathName) 
{
	int posPreambleEnd, posPostambleStart;
	char *unknownTags = NULL;
	BOOL doPrePostamble = FALSE;
	char *input = NULL;
	int inputLen;
	CString directory(lpszPathName);
	int slash = directory.ReverseFind('\\');

	//if (!CDocument::OnOpenDocument(lpszPathName))
		//return FALSE;
	
	if (!(input = (char *)ReadFileIntoMemory(lpszPathName, &inputLen)))
		return FALSE;

	if (m_preamble) { delete [] m_preamble; m_preamble = NULL; }
	if (m_postamble) { delete [] m_postamble; m_postamble = NULL; }
	if (m_unknownTags) { delete m_unknownTags; m_unknownTags = NULL; }
	m_preambleLen = m_postambleLen = 0;

	if (slash == -1)
		directory = "";
	else
		directory = directory.Left(slash);

	if (Parse_MSV(input, inputLen, &m_vcard)) {
	} else if (Parse_MIME(input, inputLen, &m_vcard)) {
	} else
		return FALSE;

	if (doPrePostamble) { // now read in and store the preamble and postamble
		if ((m_preambleLen = posPreambleEnd)) {
			m_preamble = new char[m_preambleLen];
			memcpy(m_preamble, input, m_preambleLen);
		}

		if ((m_postambleLen = inputLen - posPostambleStart)) {
			m_postamble = new char[m_postambleLen];
			memcpy(m_postamble, input + posPostambleStart, m_postambleLen);
		}
	}
	
	SetDisplayInfo(m_vcard->FindBody(), lpszPathName);

	if (unknownTags) {
		if (strlen(unknownTags))
			m_unknownTags = new CString(unknownTags);
		delete [] unknownTags;
	}

	if (input) GlobalFree(input);
	return TRUE;
}
#endif

/////////////////////////////////////////////////////////////////////////////
BOOL CVCDoc::OnSaveDocument(LPCTSTR lpszPathName) 
{
	FILE *outputFile;
	char *tempname;
	BOOL error = FALSE;
	//int len;

	tempname = _tempnam(NULL, "CARD");
	outputFile = fopen(tempname, "w+");
#if 0
	if (m_preambleLen
		&& (fwrite(m_preamble, 1, m_preambleLen, outputFile) < (unsigned)m_preambleLen)) {
		error = TRUE;
		goto Done;
	}
#endif

	if ((error = !m_vcard->Write(outputFile)))
		goto Done;
#if 0
	if (m_unknownTags && (len = m_unknownTags->GetLength())
		&& (fwrite((const char *)*m_unknownTags, 1, len, outputFile) < (unsigned)len)) {
		error = TRUE;
		goto Done;
	}
	
	if (m_postambleLen
		&& (fwrite(m_postamble, 1, m_postambleLen, outputFile) < (unsigned)m_postambleLen)) {
		error = TRUE;
		goto Done;
	}
#endif

Done:
	fclose(outputFile);
	if (error) {
		CString msg;
		msg.Format("Could not write to file \"%s\":\n%s", tempname, strerror(errno));
		AfxMessageBox(msg);
	} else {
		unlink(lpszPathName); // remove it if it's already there
		rename(tempname, lpszPathName);
		SetModifiedFlag(FALSE);
	}
	free(tempname);
	return !error;
	// return CDocument::OnSaveDocument(lpszPathName);
}

/////////////////////////////////////////////////////////////////////////////
CString CanonicalPath(const CString &path)
{
	CString result(path);
	int len = path.GetLength();
	for (int i = 0; i < len; i++)
		if (path[i] == '\\')
			result.SetAt(i, '/');
	return result;
}

/////////////////////////////////////////////////////////////////////////////
CString NativePath(const CString &path)
{
	CString result(path);
	int len = path.GetLength();
	for (int i = 0; i < len; i++)
		if (path[i] == '/')
			result.SetAt(i, '\\');
	return result;
}


/////////////////////////////////////////////////////////////////////////////
void CVCDoc::InsertFile(const char *propName, const char *theType, const char *path)
{
	int size;
	HGLOBAL contents = ReadFileIntoMemory(path, &size);
	CVCNode *body = m_vcard->FindBody();
	CVCPropEnumerator enumerator(body);
	CVCProp *prop, *existing = NULL;

	while ((prop = enumerator.NextProp()))
		if (strcmp(prop->GetName(), propName) == 0) {
			existing = prop;
			break;
		}

	if (existing) {
		BOOL didReplace = FALSE;
		for (CLISTPOSITION pos = existing->GetValues()->GetHeadPosition(); pos; ) {
			CVCValue *value = (CVCValue *)existing->GetValues()->GetNext(pos);
			if (strcmp(value->GetType(), VCStrIdxType) == 0)
				continue;
			if (strcmp(value->GetType(), VCDisplayInfoGIFType) == 0) {
				existing->RemoveValue(value);
				continue;
			}
			if (strcmp(value->GetType(), theType) != 0)
				value->SetType(theType);
			value->SetValue(contents, size);
			didReplace = TRUE;
		}
		if (!didReplace)
			existing->AddValue(new CVCValue(theType, (void *)contents, size));
	} else {
		CVCNode *node = body->AddPart();
		node->AddProp(new CVCProp(propName, theType, (void *)contents, size));
		node->AddBoolProp(vcBase64Prop);
		node->AddBoolProp((strcmp(theType, vcGIFType) == 0) ? vcGIFProp : vcWAVEProp);
	}
	GlobalFree(contents);
	SetDisplayInfo(body, GetPathName());
	SetModifiedFlag();
	UpdateAllViews(NULL);
}

/////////////////////////////////////////////////////////////////////////////
void CVCDoc::OnInsertLogo() 
{
	CFileDialog dialog(
		TRUE, NULL, NULL, 0,
		"Image Files (*.gif) | *.gif; | All Files (*.*) | *.* ||");

	if (dialog.DoModal() == IDOK) {
		CString ext(dialog.GetFileExt());
		InsertFile(vcLogoProp, VCGIFType, dialog.GetPathName());
	}
}

/////////////////////////////////////////////////////////////////////////////
void CVCDoc::OnInsertPhoto() 
{
	CFileDialog dialog(
		TRUE, NULL, NULL, 0,
		"Image Files (*.gif;) | *.gif; | All Files (*.*) | *.* ||");

	if (dialog.DoModal() == IDOK) {
		CString ext(dialog.GetFileExt());
		InsertFile(vcPhotoProp, VCGIFType, dialog.GetPathName());
	}
}

/////////////////////////////////////////////////////////////////////////////
void CVCDoc::OnInsertPronun() 
{
	CFileDialog dialog(
		TRUE, NULL, NULL, 0,
		"Wave Files (*.wav) | *.wav | All Files (*.*) | *.* ||");

	if (dialog.DoModal() == IDOK) {
		InsertFile(vcPronunciationProp, VCWAVType, dialog.GetPathName());
	}
}

/////////////////////////////////////////////////////////////////////////////
void CVCDoc::OnSendIrda() 
{
	char *tempname;
	BOOL savedFlag = IsModified();
	CString path(GetPathName()), directory, name;
	CVCNode *body = m_vcard->FindBody();
	CVCApp *app = (CVCApp *)AfxGetApp();

	if (!app->CanSendFileViaIR())
		return;
	// save the card file to a temporary location
	tempname = _tempnam(NULL, "CARD");
	OnSaveDocument(tempname);
	SetModifiedFlag(savedFlag);

	{ // get the directory containing the card file
		int slash = path.ReverseFind('\\');

		if (slash == -1) {
			directory = "";
			name = path;
		} else {
			directory = CanonicalPath(PathSansVolume(path.Left(slash)));
			name = path.Right(path.GetLength() - slash - 1);
		}
	}

	// now send the card file
	app->SendFileViaIR(tempname, name, TRUE);

	// and remove the temporary card file
	unlink(tempname);
	free(tempname);
}

/////////////////////////////////////////////////////////////////////////////
void CVCDoc::OnUpdateSendIrda(CCmdUI* pCmdUI) 
{
	CVCApp *app = (CVCApp *)AfxGetApp();
	pCmdUI->Enable(app->CanSendFileViaIR());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcview.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// VCview.cpp : implementation of the CVCView class
//

#include "stdafx.h"
#include <mmsystem.h>
#include <fstream.h>
#include <strstrea.h>
#include "vcard.h"
#include "clist.h"
#include "VC.h"
#include "VCdoc.h"
#include "VCview.h"
#include "VCDatSrc.h"
#include "gifread.h"
#include "mainfrm.h"
#include "msv.h"
#include "mime.h"
#include "callcntr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

typedef enum {
	vc_top, vc_right, vc_bottom, vc_left
} VCsides;

#define vc_white	255
#define vc_ltgray	192
#define vc_gray		128
#define vc_dkgray	64
#define vc_black	0

static void DrawStringProp(CVCard *card, CVCProp *prop, char *prefix, CVCNode *body, CRect &r, CDC *pDC);
//static void DrawGrays(CRect &r, P_U8 sides, P_U8 grays, int len, CDC *pDC);
static void DrawText(CPoint &pt, int h, wchar_t *u, CDC *pDC);
static BOOL CacheBitmap(istream *strm, VC_IMAGEINFO *info, CDC *devDC, CDC *tempDC);

extern CPalette bubPalette;

CCallCenter *callCenter = NULL;


/////////////////////////////////////////////////////////////////////////////
// CVCView

IMPLEMENT_DYNCREATE(CVCView, CScrollView)

BEGIN_MESSAGE_MAP(CVCView, CScrollView)
	//{{AFX_MSG_MAP(CVCView)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_COMMAND(ID_EDIT_PROPERTIES, OnEditProperties)
	ON_COMMAND(ID_VIEW_DEBUG, OnViewDebug)
	ON_COMMAND(ID_VIEW_NORMAL, OnViewNormal)
	ON_COMMAND(ID_VIEW_OPTIONS, OnViewOptions)
	ON_COMMAND(ID_VIEW_SIMPLEGRAM, OnViewSimplegram)
	ON_COMMAND(ID_VIEW_TEXT, OnViewText)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
	ON_WM_LBUTTONDOWN()
	ON_WM_CREATE()
	ON_COMMAND(ID_DEBUG_SHOWCALLCENTER, OnDebugShowCallCenter)
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVCView construction/destruction

CVCView::CVCView()
{
	m_language = vcDefaultLang;
	m_photo.bitmap = m_photo.mask = NULL;
	m_logo.bitmap = m_logo.mask = NULL;
	m_viewStyle = vc_normal;
	m_playPronun = NULL;
}

/////////////////////////////////////////////////////////////////////////////
CVCView::~CVCView()
{
	if (m_photo.bitmap) delete m_photo.bitmap;
	if (m_photo.mask) delete m_photo.mask;
	if (m_logo.bitmap) delete m_logo.bitmap;
	if (m_logo.mask) delete m_logo.mask;
	if (m_playPronun) delete m_playPronun;
}

/////////////////////////////////////////////////////////////////////////////
// CVCView drawing

void CVCView::OnDraw(CDC* pDC)
{
	//switch (m_viewStyle) {
	//	default:
			OnDrawNormal(pDC);
	//		break;
	//}
} // OnDraw

/////////////////////////////////////////////////////////////////////////////
void CVCView::OnDrawNormal(CDC* pDC)
{
	CVCDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	CSize size = pDoc->GetDocSize();
	CRect r(0, 0, size.cx, -size.cy);
	// CRect rectClip;
	CRect cr;
	BOOL padHorz = FALSE, padVert = FALSE;
	//pDC->GetClipBox(&rectClip);
    GetClientRect(&cr);
	pDC->DPtoLP(&cr);

	if (size.cx < cr.Width()) {
		r.OffsetRect((cr.Width() - size.cx) / 2, 0);
		padHorz = TRUE;
	}
	if (size.cy < -cr.Height()) {
		r.OffsetRect(0, -(-cr.Height() - size.cy) / 2);
		padVert = TRUE;
	}

	if (padHorz || padVert) {
		CRect fr;
		CBrush brush(RGB(vc_ltgray, vc_ltgray, vc_ltgray));
		CBrush *oldBrush = pDC->SelectObject(&brush);
		if (padHorz) {
			fr.SetRect(0, 0, r.left, cr.bottom);
			pDC->FillRect(fr, &brush);
			fr.left = r.right;
			fr.right = cr.right;
			pDC->FillRect(fr, &brush);
		}
		if (padVert) {
			fr.SetRect(0, 0, cr.right, r.top);
			pDC->FillRect(fr, &brush);
			fr.top = r.bottom;
			fr.bottom = cr.bottom;
			pDC->FillRect(fr, &brush);
		}
		pDC->SelectObject(oldBrush);
	}

	{
		CRect fr;
		CBrush dkBrush(RGB(vc_dkgray, vc_dkgray, vc_dkgray));
		CBrush ltBrush(RGB(vc_ltgray, vc_ltgray, vc_ltgray));
		CBrush *oldBrush = pDC->SelectObject(&ltBrush);
		#define thick 60

		// bottom shadow -- small ltgray and long dkgray pieces
		fr.SetRect(r.left, r.bottom + thick, r.left + thick, r.bottom);
		pDC->FillRect(fr, &ltBrush);
		fr.left = fr.right;
		fr.right = r.right;
		pDC->FillRect(fr, &dkBrush);

		// right shadow -- small ltgray and long dkgray pieces
		fr.SetRect(r.right - thick, r.top, r.right, r.top - thick);
		pDC->FillRect(fr, &ltBrush);
		fr.top = fr.bottom;
		fr.bottom = r.bottom;
		pDC->FillRect(fr, &dkBrush);

		pDC->SelectObject(oldBrush);
		r.right -= thick;
		r.bottom += thick;

		// border
		CPen *oldPen, pen;
		pen.CreatePen(PS_SOLID, 20, RGB(vc_black, vc_black, vc_black));
		oldPen = pDC->SelectObject(&pen);
		pDC->Rectangle(r);
		pDC->SelectObject(oldPen);
		pen.DeleteObject();
		r.InflateRect(-20, -20);
	}
#if 0
	{
		U8 sides[] = {vc_top, vc_left,
			vc_right, vc_bottom, vc_right, vc_bottom,
			vc_top, vc_right, vc_bottom, vc_left};
		U8 grays[] = {vc_white, vc_white,
			vc_dkgray, vc_dkgray, vc_dkgray, vc_dkgray,
			vc_gray, vc_gray, vc_gray, vc_gray};
		DrawGrays(r, sides, grays, 10, pDC);
	}
#endif

	DrawCard(pDoc->GetVCard(), r, pDC);
}

/////////////////////////////////////////////////////////////////////////////
#if 0
static void DrawGrays(CRect &r, P_U8 sides, P_U8 grays, int len, CDC *pDC)
{
	CPen *oldPen = NULL;
	CPen pen;

	for (int i = 0; i < len; i++, sides++, grays++) {
		pen.CreatePen(PS_SOLID, 20, RGB(*grays, *grays, *grays));
		if (!oldPen)
			oldPen = pDC->SelectObject(&pen);
		else
			pDC->SelectObject(&pen);
		switch (*sides) {
			case vc_top:
				pDC->MoveTo(r.left, r.top);
				pDC->LineTo(r.right + 1, r.top);
				r.top += 20;
				break;
			case vc_right:
				pDC->MoveTo(r.right, r.top);
				pDC->LineTo(r.right, r.bottom + 1);
				r.right -= 20;
				break;
			case vc_bottom:
				pDC->MoveTo(r.right, r.bottom);
				pDC->LineTo(r.left - 1, r.bottom);
				r.bottom -= 20;
				break;
			default: // vc_left
				pDC->MoveTo(r.left, r.bottom);
				pDC->LineTo(r.left, r.top - 1);
				r.left += 20;
				break;
		}
		pDC->SelectObject(oldPen);
		pen.DeleteObject();
	}
}
#endif

/////////////////////////////////////////////////////////////////////////////
void CVCView::DrawCard(CVCard *card, CRect &r, CDC *pDC)
{
	CVCNode *root, *english, *node;
	CVCProp *prop;
	CVCPropEnumerator *enumerator;
	BOOL haveLogo = FALSE;
	int nTels = 0, nEmails = 0;
	BOOL havePrefTel = FALSE, havePrefEmail = FALSE;
	BOOL haveDrawnTel = FALSE, haveDrawnEmail = FALSE;
	CVCValue *fullNameDispInfVal = NULL;

	if (!card) return;
	// get the first root object
	root = (CVCNode *)card->GetObjects()->GetHead();

	// get the first body prop (english)
	english = (CVCNode *)root->GetProp(vcBodyProp)->FindValue(
		VCNextObjectType)->GetValue();

	enumerator = new CVCPropEnumerator(english);
	while ((prop = enumerator->NextProp(&node))) {
		if ((strcmp(prop->GetName(), vcPhotoProp) == 0)
			&& prop->FindValue(VCDisplayInfoGIFType))
			DrawGif(prop, english, r, pDC);
		else if ((strcmp(prop->GetName(), vcLogoProp) == 0)
			&& prop->FindValue(VCDisplayInfoGIFType)) {
			DrawGif(prop, english, r, pDC);
			haveLogo = TRUE;
		} else if (strcmp(prop->GetName(), vcTelephoneProp) == 0) {
			havePrefTel |= (card->GetInheritedProp(node, vcPreferredProp) != NULL);
			nTels++;
		} else if (strcmp(prop->GetName(), vcEmailAddressProp) == 0) {
			havePrefEmail |= (card->GetInheritedProp(node, vcPreferredProp) != NULL);
			nEmails++;
		} else if (strcmp(prop->GetName(), vcFullNameProp) == 0) {
			fullNameDispInfVal = prop->FindValue(VCDisplayInfoTextType);
		}
	}
	delete enumerator;

	if (!haveLogo) { // try to find the default logo file and cache its bitmap
		if (!m_logo.bitmap) { // need to cache
			char buf[FILENAME_MAX];
			char *filePart;
		    if (SearchPath(
			    NULL, "DEFAULT.GIF", NULL, FILENAME_MAX, buf, &filePart) != 0) {
				CDC tempDC;
				CClientDC devDC(this);
				ifstream strm(buf, ios::in | ios::nocreate | ios::binary);
				tempDC.CreateCompatibleDC(&devDC);
				(void)CacheBitmap(&strm, &m_logo, &devDC, &tempDC);
				// if that failed, m_logo.bitmap would still be NULL
			}
		}
		if (m_logo.bitmap) { // it's cached, so fake a prop so that we can use DrawGif
			VC_DISPGIF gifInfo;
			gifInfo.left = 300;
			gifInfo.right = gifInfo.left + m_logo.devSize.cx * 20;
			gifInfo.top = 300 + m_logo.devSize.cy * 20;
			gifInfo.bottom = gifInfo.top - m_logo.devSize.cy * 20;
			gifInfo.hasMask = (m_logo.mask != NULL);
			prop = new CVCProp(vcLogoProp, VCDisplayInfoGIFType, &gifInfo, sizeof(gifInfo));
			DrawGif(prop, english, r, pDC);
			delete prop;
		}
	}

	enumerator = new CVCPropEnumerator(english);
	while ((prop = enumerator->NextProp(&node))) {
		if ((strcmp(prop->GetName(), vcPhotoProp) == 0)
			|| (strcmp(prop->GetName(), vcLogoProp) == 0))
			continue;
		else if ((strcmp(prop->GetName(), vcPronunciationProp) == 0)
			&& prop->FindValue(VCWAVType)) {
			CRect wr(0, 0, 0, 0);
			CPoint pt;
			BOOL needUpdate = FALSE;
			if (!m_playPronun) {
				m_playPronun = new CBitmapButton();
				m_playPronun->Create(
					NULL, BS_OWNERDRAW | BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE,
					wr, this, VC_PLAY_BUTTON_ID);
				m_playPronun->LoadBitmaps(IDB_PRONUN_U, IDB_PRONUN_D);
				m_playPronun->SizeToContent();
				needUpdate = TRUE;
			}
			m_playPronun->GetWindowRect(&wr);
			if (fullNameDispInfVal) {
				VC_DISPTEXT *dispText = (VC_DISPTEXT *)fullNameDispInfVal->GetValue();
				pt.x = 7700 + r.left;
				pt.y = dispText->y + r.bottom;
			} else {
				pt.x = 7000 + r.left;
				pt.y = 2000 + r.bottom;
			}
			pDC->LPtoDP(&pt);
			wr.OffsetRect(pt.x - wr.left, pt.y - wr.top);
			m_playPronun->SetWindowPos(
				NULL, wr.left, wr.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
			if (needUpdate)
				m_playPronun->Invalidate();
		} else if (strcmp(prop->GetName(), vcTelephoneProp) == 0) {
			if (!haveDrawnTel) {
				if (havePrefTel) {
					if (card->GetInheritedProp(node, vcPreferredProp)) {
						DrawStringProp(card, prop, NULL, english, r, pDC);
						haveDrawnTel = TRUE;
					}
				} else {
					DrawStringProp(card, prop, NULL, english, r, pDC);
					haveDrawnTel = TRUE;
				}
			}
		} else if (strcmp(prop->GetName(), vcEmailAddressProp) == 0) {
			if (!haveDrawnEmail) {
				CList plist;
				char prefix[40];
				card->GetPropsInEffect(node, &plist);
				CString email = FirstEmailPropStr(&plist);
				prefix[0] = 0;
				if (!email.IsEmpty()) {
					strcpy(prefix, email);
					strcat(prefix, ":");
				}
				if (havePrefEmail) {
					if (card->GetInheritedProp(node, vcPreferredProp)) {
						DrawStringProp(card, prop, prefix, english, r, pDC);
						haveDrawnEmail = TRUE;
					}
				} else {
					DrawStringProp(card, prop, prefix, english, r, pDC);
					haveDrawnEmail = TRUE;
				}
			}
		} else if (prop->FindValue(VCStrIdxType))
			DrawStringProp(card, prop, NULL, english, r, pDC);
	}
	delete enumerator;
}

/////////////////////////////////////////////////////////////////////////////
static void RemoveMatchingLine(wchar_t *text, wchar_t *pat)
{
	int lenText = wcslen(text);
	int lenPat = wcslen(pat);
	wchar_t *sub = wcsstr(text, pat);
	if (!sub)
		return;

	BOOL atSOL = (sub == text) || (*(sub - 1) == 0x2028);
	int patStart = sub - text;
	wchar_t ch = *(text + patStart + lenPat);
	BOOL atEOL = (ch == 0x2028) || (ch == 0);

	if (atSOL && atEOL) {
		if ((sub == text) && (patStart + lenPat == lenText))
			*text = 0;
		else if (sub == text) // remove first line
			memmove(text, text + lenPat + 1, 
				(size_t)(lenText - lenPat) * sizeof(wchar_t));
		else if (patStart + lenPat == lenText) // remove last line
			*(text + patStart - 1) = 0;
		else
			memmove(text + patStart, text + patStart + lenPat + 1,
				(size_t)(lenText - (patStart + lenPat)) * sizeof(wchar_t));
	}
}

/////////////////////////////////////////////////////////////////////////////
static void DrawStringProp(CVCard *card, CVCProp *prop, char *prefix, CVCNode *body, CRect &r, CDC *pDC)
{
	CVCValue *dispInfoVal = prop->FindValue(VCDisplayInfoTextType);
	VC_DISPTEXT *dispText = dispInfoVal ? (VC_DISPTEXT *)dispInfoVal->GetValue() : NULL;
	if (!dispText)
		return;
	wchar_t *text = (wchar_t *)prop->FindValue(VCStrIdxType)->GetValue();
	int height = dispText->typeSize * 20;
	//int height = MulDiv(
	//	dispText->typeSize * 20, GetDeviceCaps(pDC->m_hDC, LOGPIXELSY), 72);
	CFont font, *oldFont;
	CPoint pt;
	wchar_t *textCopy = NULL;
	BOOL willDrawOrgUnit = FALSE, willDrawLogo = FALSE, draw = TRUE;
	int nameOrTitleY = 0;
	CVCProp *dom = NULL, *intl = NULL;

	// if this is a postal label, filter out any lines that
	// would duplicate other props.
	if (strcmp(prop->GetName(), vcDeliveryLabelProp) == 0) {
		CVCPropEnumerator enumerator = CVCPropEnumerator(body);
		CVCProp *p;
		CVCNode *node;
		
		textCopy = new wchar_t[wcslen(text)+1];
		wcscpy(textCopy, text);
		text = textCopy;

		while ((p = enumerator.NextProp(&node))) {
			if (strcmp(p->GetName(), vcFullNameProp) == 0) {
				wchar_t *fullName = (wchar_t *)p->FindValue(VCStrIdxType)->GetValue();
				VC_DISPTEXT *dt = (VC_DISPTEXT *)p->FindValue(VCDisplayInfoTextType)->GetValue();
				RemoveMatchingLine(text, fullName);
				if (wcslen(fullName) > 0)
					nameOrTitleY = dt->y;
			} else if (strcmp(p->GetName(), vcTitleProp) == 0) {
				wchar_t *title = (wchar_t *)p->FindValue(VCStrIdxType)->GetValue();
				VC_DISPTEXT *dt = (VC_DISPTEXT *)p->FindValue(VCDisplayInfoTextType)->GetValue();
				if ((wcslen(title) > 0) && !nameOrTitleY)
					nameOrTitleY = dt->y;
			} else if (strcmp(p->GetName(), vcOrgNameProp) == 0) {
				RemoveMatchingLine(text, (wchar_t *)p->FindValue(VCStrIdxType)->GetValue());
			} else if (strcmp(p->GetName(), vcOrgUnitProp) == 0) {
				wchar_t *orgUnit = (wchar_t *)p->FindValue(VCStrIdxType)->GetValue();
				RemoveMatchingLine(text, orgUnit);
				willDrawOrgUnit = wcslen(orgUnit) > 0;
			} else if (strcmp(p->GetName(), vcLogoProp) == 0) {
				willDrawLogo = TRUE;
			} else if (strcmp(p->GetName(), vcDeliveryLabelProp) == 0) {
				if (card->GetInheritedProp(node, vcDomesticProp)) {
					if (!dom)
						dom = p;
				} else if (!intl)
					intl = p;
			}
		} // while
		if (intl)
			draw = intl == prop;
		else
			draw = dom == prop;
	} else if (prefix) {
		int size;
		wchar_t *uniValue = FakeUnicode(prefix, &size);

		textCopy = new wchar_t[wcslen(text) + wcslen(uniValue) + 1];
		wcscpy(textCopy, uniValue);
		wcscat(textCopy, text);
		text = textCopy;
		delete [] uniValue;
	}

	if (!draw)
		goto Done;
	// set up the font.  The stuff that's way indented we probably don't
	// need to muck with.  The key items are indented just one level.
	font.CreateFont(
		height,
					0, 0, 0,
		/*weight*/ dispText->textAttrs & VC_BOLD ? FW_BOLD : FW_NORMAL,
		/*italic*/ dispText->textAttrs & VC_ITALIC,
		/*underline*/ FALSE,
		/*strikeout*/ FALSE,
					ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
					DRAFT_QUALITY, FF_DONTCARE | DEFAULT_PITCH,
		(dispText->textClass == VC_CLASSIC) ? "Times Roman" : "Helvetica");
	oldFont = pDC->SelectObject(&font);
	pt.x = dispText->x + r.left;
	pt.y = dispText->y + r.bottom;
	if (!willDrawOrgUnit && !willDrawLogo && (nameOrTitleY != 0))
		pt.y = nameOrTitleY + r.bottom;
	DrawText(pt, height, text, pDC);
	pDC->SelectObject(oldFont);

Done:
	if (textCopy) delete [] textCopy;
}

/////////////////////////////////////////////////////////////////////////////
static void DrawText(CPoint &pt, int h, wchar_t *u, CDC *pDC)
{
	int n = wcslen(u), i, numThis;
	char *c;
	wchar_t *curU, *endU;

	if (!n) return;
	c = new char[n];

    for (i = 0; i < n; i++)
        c[i] = (char)(S16)u[i];

	curU = u;
	do {
		endU = curU;
		while (*endU && (*endU != 0x2028) && (*endU != 0x2029))
			endU++;
		numThis = endU - curU;
		if (numThis) {
	        if (pDC->TextOut(pt.x, pt.y, c + (curU - u), numThis) == 0)
	            AfxMessageBox("TextOut failed");
		}
		pt.y -= h;
		if (*endU) // must have hit a line break
			curU = endU + 1;
		else
			break;
	} while (TRUE);

	delete [] c;
}

static BOOL CacheBitmap(istream *strm, VC_IMAGEINFO *info, CDC *devDC, CDC *tempDC)
{
	BOOL hasMask;
	FCOORD size;
	CGifReader gifRdr;

	if (!gifRdr.GetGifSize(strm, &size, &hasMask))
		return FALSE;

	strm->clear();
	strm->seekg(0);
	info->devSize.cx = (int)size.x;
	info->devSize.cy = (int)size.y;
	if (hasMask) {
		CDC *maskDC = new CDC;
		maskDC->CreateCompatibleDC(devDC);
    	info->bitmap = new CBitmap;
    	info->mask = new CBitmap;
    	info->bitmap->CreateCompatibleBitmap(devDC, info->devSize.cx, info->devSize.cy);
    	info->mask->CreateBitmap(info->devSize.cx, info->devSize.cy, 1, 1, NULL);
		tempDC->SelectObject(info->bitmap);
		maskDC->SelectObject(info->mask);
		gifRdr.ReadGif(strm, tempDC, maskDC);
		delete maskDC;			
	} else {
    	info->bitmap = new CBitmap;
    	info->bitmap->CreateCompatibleBitmap(devDC, info->devSize.cx, info->devSize.cy);
		tempDC->SelectObject(info->bitmap);
		gifRdr.ReadGif(strm, tempDC, NULL);
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
void CVCView::DrawGif(CVCProp *prop, CVCNode *body, CRect &r, CDC *pDC)
{
	CVCValue *value = prop->FindValue(VCDisplayInfoGIFType);
	VC_DISPGIF *gifInfo = value ? (VC_DISPGIF *)value->GetValue() : NULL;
	VC_IMAGEINFO *info =
		(strcmp(prop->GetName(), vcPhotoProp) == 0) ? &m_photo : &m_logo;
	CDC tempDC;
	CClientDC devDC(this);
	CPoint devPt;

	if (!gifInfo) return;
	devPt.x = gifInfo->left + r.left;
	devPt.y = gifInfo->top + r.bottom;
	
	pDC->LPtoDP(&devPt);
	devDC.AssertValid();
	//pDC = &devDC;
	tempDC.CreateCompatibleDC(&devDC);

	// If we haven't yet cached the bitmap and mask, do so.
	if (!info->bitmap) {
		CVCValue *value = prop->FindValue(VCGIFType);
		istrstream strm((char *)value->GetValue(), value->GetSize());
		if (!CacheBitmap(&strm, info, &devDC, &tempDC))
			return;
	}

	// Now do the blitting.
	if (info->mask) {
		tempDC.SelectObject(info->mask);
    	pDC->BitBlt(
    		devPt.x, devPt.y,
    		info->devSize.cx, info->devSize.cy, &tempDC, 0, 0, SRCAND);
		tempDC.SelectObject(info->bitmap);
    	pDC->BitBlt(
    		devPt.x, devPt.y,
    		info->devSize.cx, info->devSize.cy, &tempDC, 0, 0, SRCPAINT);
	} else {
		tempDC.SelectObject(info->bitmap);
    	devDC.BitBlt(
    		devPt.x, devPt.y,
    		info->devSize.cx, info->devSize.cy, &tempDC, 0, 0, SRCCOPY);
#if 0
		CRect fr(0, 0, 1000, -1000);
		CBrush brush(RGB(vc_ltgray, vc_ltgray, vc_ltgray));
		CBrush *oldBrush = pDC->SelectObject(&brush);
		fr.OffsetRect(gifInfo->left + r.left, gifInfo->top + r.bottom);
		pDC->FillRect(fr, &brush);
		pDC->SelectObject(oldBrush);
#endif
	}
}

/////////////////////////////////////////////////////////////////////////////
void CVCView::OnInitialUpdate()
{
	CRect cr;
	CSize pageSize;
	GetClientRect(&cr);
	pageSize.cx = MulDiv(cr.Width() * 20, 9, 10);
	pageSize.cy = MulDiv(cr.Height() * 20, 9, 10);

	SetScrollSizes(MM_TWIPS, GetDocument()->GetDocSize(), pageSize);
	//GetParentFrame()->RecalcLayout();
	//ResizeParentToFit();
}

/////////////////////////////////////////////////////////////////////////////
// CVCView printing

BOOL CVCView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

/////////////////////////////////////////////////////////////////////////////
void CVCView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add extra initialization before printing
}

/////////////////////////////////////////////////////////////////////////////
void CVCView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add cleanup after printing
}

/////////////////////////////////////////////////////////////////////////////
// CVCView diagnostics

#ifdef _DEBUG
void CVCView::AssertValid() const
{
	CScrollView::AssertValid();
}

void CVCView::Dump(CDumpContext& dc) const
{
	CScrollView::Dump(dc);
}

CVCDoc* CVCView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CVCDoc)));
	return (CVCDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CVCView message handlers

COleDataSource* CVCView::CreateDataSourceForCopyAndDrag()
{
	CVCDoc *doc = GetDocument();
	CVCDataSource *dataSource = new CVCDataSource(doc);

	dataSource->DelayRenderData(CF_TEXT);
	dataSource->DelayRenderData(cf_eCard);
	return dataSource;
} // CreateDataSourceForCopyAndDrag

void CVCView::OnEditCopy() 
{
	COleDataSource *dataSource = CreateDataSourceForCopyAndDrag();
	if (dataSource)
		dataSource->SetClipboard(); // dataSource now owned by clipboard
}

/////////////////////////////////////////////////////////////////////////////
// Helper for paste
CString CVCView::ClipboardStringForFormat(int format)
{
 	COleDataObject clipboardData;
	FORMATETC  formatEtc;
	STGMEDIUM  data;
	CString result("");
	BOOL found = FALSE;

	clipboardData.AttachClipboard();
	clipboardData.BeginEnumFormats();

    while (!found && clipboardData.GetNextFormat(&formatEtc)) {
		if ((formatEtc.cfFormat == format)
			&& (formatEtc.tymed & (TYMED_HGLOBAL | TYMED_ISTREAM)))
		  	found = clipboardData.GetData(format, &data, &formatEtc);
    }

	if (!found)
		return result;

	switch (data.tymed) {
		case TYMED_HGLOBAL: {
			const char *chars = (const char *)GlobalLock(data.hGlobal);
			ASSERT(chars);
			result = CString(chars, GlobalSize(data.hGlobal));
			GlobalUnlock(data.hGlobal);
			break;
		}

		case TYMED_ISTREAM: {
			char *buf = new char[1024], *nullByte;
			ULONG len = 0, maxLen = 1024, count, countRead;
			HRESULT hResult;
			LARGE_INTEGER pos = {0};
			data.pstm->Seek(pos, STREAM_SEEK_SET, NULL);
			do {
				count = maxLen - len;
				if (!count) {
					maxLen += 1024;
					char *newBuf = new char[maxLen];
					memcpy(newBuf, buf, len);
					delete [] buf;
					buf = newBuf;
					count = maxLen - len;
				}
				hResult = data.pstm->Read(buf + len, count, &countRead);
				// It's possible for there to be a null char in that data,
				// in which case we want to end the string there.
				if ((nullByte = (char *)memchr(buf + len, 0, countRead)) != NULL)
					countRead = nullByte - (buf + len);
				len += countRead;
			} while (countRead);
			result = CString(buf, len);
			delete [] buf;
			break;
		} // TYMED_ISTREAM

		default: break;
	} // switch

	ReleaseStgMedium(&data);

	return result;
}

/////////////////////////////////////////////////////////////////////////////
CStringArray* ComponentsSeparatedByString(
	const CString &str, const char *pat)
{
	CStringArray *array = new CStringArray;
	CString remain(str);
	CString patStr(pat);
	int lenPat = patStr.GetLength(), patStart;
	
	while ((patStart = remain.Find(patStr)) != -1) {
		array->Add(remain.Left(patStart));
		remain = remain.Right(remain.GetLength() - patStart - lenPat);
	}
	array->Add(remain);
	return array;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVCView::Paste(const char *data, int dataLen)
{
	CVCDoc *doc = GetDocument();
	CVCard *cards = doc->GetVCard();
	CVCNode *body = cards->FindBody(m_language);
	CVCard *tempCard;
	BOOL success = FALSE;

	if (Parse_MSV(data, dataLen, &tempCard)
		|| Parse_MIME(data, dataLen, &tempCard)) { // success!
		// first copy most of the props from tempCard onto body.
		CList *bodyProps = tempCard->FindBody()->GetProps();
		body->RemoveProp(vcLanguageProp);
		for (CLISTPOSITION pos = bodyProps->GetHeadPosition(); pos; ) {
			CVCProp *prop = (CVCProp *)bodyProps->GetNext(pos);
			if (strcmp(prop->GetName(), VCBodyObject) == 0)
				continue;
			body->AddProp((CVCProp *)prop->Copy());
		}
		delete tempCard;

		// now add display info
		CVCPropEnumerator *enumerator;
		CVCProp *prop;
		enumerator = new CVCPropEnumerator(body);
		while ((prop = enumerator->NextProp())) {
			VC_DISPTEXT dispText;
			if (DisplayInfoForProp(prop->GetName(), &dispText))
				prop->AddValue(new CVCValue(VCDisplayInfoTextType, &dispText, sizeof(dispText)));
		}
		delete enumerator;
		success = TRUE;
	}
	doc->SetModifiedFlag();
	doc->SetDisplayInfo(body, doc->GetPathName());
	doc->UpdateAllViews(NULL);
	return success;
}

/////////////////////////////////////////////////////////////////////////////
void CVCView::OnEditPaste() 
{
	CVCDoc *doc = GetDocument();
	CVCard *cards = doc->GetVCard();
	CVCNode *body = cards->FindBody(m_language);
	CList *props = body->GetProps();
	CString data = ClipboardStringForFormat(CF_TEXT);

	if (data.IsEmpty())
		return;

	// If our doc's body has more than two props (VCBodyObject and vcLanguageProp),
	// it's not empty and so we shouldn't paste into it.  Instead, have the
	// app create a new doc/view and do the paste into that.
	if (props->GetCount() > 2) {
		CVCApp *app = (CVCApp *)AfxGetApp();
		CMainFrame *mainFrame = (CMainFrame *)app->GetMainWnd();
		//CView *view;
		mainFrame->SendMessage(WM_COMMAND, ID_FILE_NEW);
		//view = mainFrame->MDIGetActive()->GetActiveView();
		mainFrame->SendMessage(WM_COMMAND, ID_EDIT_PASTE);
		return;
	}

	// Here, we know our document is "empty", and so we want to paste
	// the properties into "body".
	Paste(data, data.GetLength());
}

/////////////////////////////////////////////////////////////////////////////
void CVCView::OnUpdateEditPaste(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(TRUE);
}

void CVCView::OnViewDebug() 
{
	// TODO: Add your command handler code here
	
}

void CVCView::OnViewNormal() 
{
	// TODO: Add your command handler code here
	
}

void CVCView::OnViewOptions() 
{
	// TODO: Add your command handler code here
	
}

void CVCView::OnViewSimplegram() 
{
	// TODO: Add your command handler code here
	
}

void CVCView::OnViewText() 
{
	// TODO: Add your command handler code here
	
}

void CVCView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo) 
{
	CRect cr;
	CSize pageSize;
	GetClientRect(&cr);
	pageSize.cx = MulDiv(cr.Width() * 20, 9, 10);
	pageSize.cy = MulDiv(cr.Height() * 20, 9, 10);

	// On creation of second maximized view on Win95, OnInitialUpdate
	// isn't called before OnPaint(), so it crashes.  Ensure coord
	// system is set up by adding SetScrollSizes here.
	SetScrollSizes(MM_TWIPS, GetDocument()->GetDocSize(), pageSize);
	CScrollView::OnPrepareDC(pDC, pInfo);
	//GetClientRect(&cr);
	//pDC->SetViewportOrg(0, cr.Height());
}

// Simple-minded conversion from UNICODE to char string
char *UI_CString(const wchar_t *u, char *dst)
{
	char *str = dst;
	while (*u) {
		if (*u == 0x2028) {
			*dst++ = '\r';
			*dst++ = '\n';
			u++;
		} else
			*dst++ = (char)*u++;
	}
	*dst = '\000';
	return str;
}


void CVCView::OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView) 
{
    if (bActivate && (pActivateView == this)) {
	    CClientDC dc(this);
	    dc.AssertValid();
	    OnPrepareDC(&dc);

	    if(dc.GetDeviceCaps(BITSPIXEL) == 8) {
	    	// set up our palette
			if (!UnrealizeObject(bubPalette.m_hObject))
				TRACE0("UnrealizeObject failed\n");
		    dc.SelectPalette( &bubPalette, 0 );
	    	dc.RealizePalette();
	    }
	}
	
	CScrollView::OnActivateView(bActivate, pActivateView, pDeactiveView);
}

BOOL CVCView::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	if (wParam == VC_PLAY_BUTTON_ID) {
		CVCDoc *doc = GetDocument();
		CVCard *cards = doc->GetVCard();
		CVCNode *body = cards->FindBody(m_language);
		CVCPropEnumerator *enumerator = new CVCPropEnumerator(body);
		CVCProp *prop;

		while ((prop = enumerator->NextProp())) {
			CVCValue *value;
			if ((strcmp(prop->GetName(), vcPronunciationProp) == 0)
				&& (value = prop->FindValue(VCWAVType))) {
				PlaySound((LPCSTR)value->GetValue(), NULL, SND_MEMORY | SND_ASYNC | SND_NOWAIT);
				break;
			}
		}
		delete enumerator;
	}

	return CScrollView::OnCommand(wParam, lParam);
}

void CVCView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) 
{
	CScrollView::OnUpdate(pSender, lHint, pHint);

	if (m_photo.bitmap) { delete m_photo.bitmap; m_photo.bitmap = NULL; }
	if (m_photo.mask) { delete m_photo.mask; m_photo.mask = NULL; }
	if (m_logo.bitmap) { delete m_logo.bitmap; m_logo.bitmap = NULL; }
	if (m_logo.mask) { delete m_logo.mask; m_logo.mask = NULL; }
	if (m_playPronun) { delete m_playPronun; m_playPronun = NULL; }
}

/////////////////////////////////////////////////////////////////////////////
void CVCView::OnLButtonDown(UINT nFlags, CPoint point) 
{
	COleDataSource *dataSource = CreateDataSourceForCopyAndDrag();
	CRect r(point, point);

	ClientToScreen(&r);
	r.InflateRect(4, 4);
	dataSource->DoDragDrop(DROPEFFECT_COPY, &r);
	delete dataSource;
}

int CVCView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CScrollView::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	// TODO: Add your specialized creation code here
	
	m_dropTarget.Register(this);

	return 0;
}

DROPEFFECT CVCView::OnDragEnter(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point) 
{
	return OnDragOver(pDataObject, dwKeyState, point);
}

DROPEFFECT CVCView::OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point) 
{
	DROPEFFECT de;

	if ((dwKeyState & (MK_CONTROL|MK_SHIFT)) == (MK_CONTROL|MK_SHIFT))
		de = DROPEFFECT_LINK;
	else if ((dwKeyState & MK_CONTROL) == MK_CONTROL)
		de = DROPEFFECT_COPY;
	// check for force move
	else if ((dwKeyState & MK_ALT) == MK_ALT)
		de = DROPEFFECT_MOVE;
	// default -- recommended action is copy
	else
		de = DROPEFFECT_COPY;

	if (de == DROPEFFECT_COPY) {
		if (!pDataObject->IsDataAvailable(CF_TEXT)
			&& !pDataObject->IsDataAvailable(cf_eCard))
			return DROPEFFECT_NONE;
		return de;
	} else
		return DROPEFFECT_NONE;
}

BOOL CVCView::OnDrop(COleDataObject* pDataObject, DROPEFFECT dropEffect, CPoint point) 
{
	CVCDoc *doc = GetDocument();
	CVCard *cards = doc->GetVCard();
	CVCNode *body = cards->FindBody(m_language);
	CList *props = body->GetProps();
	HGLOBAL data;
	char *chars;
	BOOL success;

	if ((data = pDataObject->GetGlobalData(cf_eCard)) == NULL)
		data = pDataObject->GetGlobalData(CF_TEXT);
	if (!data)
		return FALSE;

	// If our doc's body has more than two props (VCBodyObject and vcLanguageProp),
	// it's not empty and so we shouldn't paste into it.  Instead, have the
	// app create a new doc/view and do the paste into that.
	if (props->GetCount() > 2) {
		CVCApp *app = (CVCApp *)AfxGetApp();
		CMainFrame *mainFrame = (CMainFrame *)app->GetMainWnd();
		CVCView *view;

		mainFrame->SendMessage(WM_COMMAND, ID_FILE_NEW);
		view = (CVCView *)mainFrame->MDIGetActive()->GetActiveView();
		chars = (char *)GlobalLock(data);
		ASSERT(chars);
		success = view->Paste(chars, GlobalSize(data));
		GlobalUnlock(data);
		GlobalFree(data);
		return success;
	}

	// Here, we know our document is "empty", and so we want to paste
	// the properties into "body".
	chars = (char *)GlobalLock(data);
	ASSERT(chars);
	success = Paste(chars, GlobalSize(data));
	GlobalUnlock(data);
	GlobalFree(data);
	return success;
}

void CVCView::InitCallCenter(CCallCenter& cc)
{
	CVCDoc *doc = GetDocument();
	CVCard *cards = doc->GetVCard();
	CVCNode *body = cards->FindBody(m_language);
	CVCPropEnumerator enumerator(body);
	CVCNode *node;
	CVCProp *prop;
	char buf[1024];

	while ((prop = enumerator.NextProp(&node))) {
		const char *propName = prop->GetName();
		if (strcmp(propName, vcCityProp) == 0)
			cc.m_addrCity = UI_CString(
				(wchar_t *)prop->FindValue(vcStrIdxType)->GetValue(), buf);
		else if (strcmp(propName, vcRegionProp) == 0)
			cc.m_addrState = UI_CString(
				(wchar_t *)prop->FindValue(vcStrIdxType)->GetValue(), buf);
		else if (strcmp(propName, vcStreetAddressProp) == 0)
			cc.m_addrStreet = UI_CString(
				(wchar_t *)prop->FindValue(vcStrIdxType)->GetValue(), buf);
		else if (strcmp(propName, vcPostalCodeProp) == 0)
			cc.m_addrZip = UI_CString(
				(wchar_t *)prop->FindValue(vcStrIdxType)->GetValue(), buf);
		else if (strcmp(propName, vcOrgNameProp) == 0)
			cc.m_employer = UI_CString(
				(wchar_t *)prop->FindValue(vcStrIdxType)->GetValue(), buf);
		else if (strcmp(propName, vcGivenNameProp) == 0)
			cc.m_firstName = UI_CString(
				(wchar_t *)prop->FindValue(vcStrIdxType)->GetValue(), buf);
		else if (strcmp(propName, vcFamilyNameProp) == 0)
			cc.m_lastName = UI_CString(
				(wchar_t *)prop->FindValue(vcStrIdxType)->GetValue(), buf);
		else if (strcmp(propName, vcTelephoneProp) == 0) {
			CList plist;
			cards->GetPropsInEffect(node, &plist);
			if (plist.Search(VCMatchProp, (void *)vcFaxProp)) {
				if (cc.m_telFax.IsEmpty())
					cc.m_telFax = UI_CString(
						(wchar_t *)prop->FindValue(vcStrIdxType)->GetValue(), buf);
			}
			if (plist.Search(VCMatchProp, (void *)vcHomeProp)) {
				if (cc.m_telHome.IsEmpty())
					cc.m_telHome = UI_CString(
						(wchar_t *)prop->FindValue(vcStrIdxType)->GetValue(), buf);
			}
			if (plist.Search(VCMatchProp, (void *)vcWorkProp)) {
				if (cc.m_telWork.IsEmpty())
					cc.m_telWork = UI_CString(
						(wchar_t *)prop->FindValue(vcStrIdxType)->GetValue(), buf);
			}
		}
	}

	cc.m_callerID = "Versitcard";
}

void CVCView::OnDebugShowCallCenter() 
{
	CCallCenter cc;

	InitCallCenter(cc);
	callCenter = &cc;
	cc.DoModal();
	callCenter = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcview.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// VCview.h : interface of the CVCView class
//
/////////////////////////////////////////////////////////////////////////////

#include <afxole.h>

class CVCCntrItem;
class CVCProp;
class CVCNode;
class CVCard;
class CVCDoc;
class CCallCenter;

typedef struct {
	CBitmap *bitmap, *mask;
	CSize devSize;
} VC_IMAGEINFO;

typedef enum {
	vc_normal, vc_text, vc_debug
} VC_VIEWSTYLE;

class CVCView : public CScrollView
{
protected: // create from serialization only
	CVCView();
	DECLARE_DYNCREATE(CVCView)

// Attributes
public:
	CVCDoc* GetDocument();

// Operations
public:
	void InitCallCenter(CCallCenter& cc);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVCView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo = NULL);
	virtual DROPEFFECT OnDragEnter(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);
	virtual DROPEFFECT OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);
	virtual BOOL OnDrop(COleDataObject* pDataObject, DROPEFFECT dropEffect, CPoint point);
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CVCView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	BOOL Paste(const char *data, int dataLen);

protected:
	CString m_language; // indicates current language to display
	VC_IMAGEINFO m_photo, m_logo;
	VC_VIEWSTYLE m_viewStyle;
	CBitmapButton *m_playPronun;
	COleDropTarget m_dropTarget;

	void DrawGif(CVCProp *prop, CVCNode *body, CRect &r, CDC *pDC);
	void DrawCard(CVCard *card, CRect &r, CDC *pDC);
	void OnDrawNormal(CDC* pDC);
	CString ClipboardStringForFormat(int format);
	COleDataSource* CreateDataSourceForCopyAndDrag();

// Generated message map functions
protected:
	//{{AFX_MSG(CVCView)
	afx_msg void OnEditCopy();
	afx_msg void OnEditPaste();
	afx_msg void OnEditProperties();
	afx_msg void OnViewDebug();
	afx_msg void OnViewNormal();
	afx_msg void OnViewOptions();
	afx_msg void OnViewSimplegram();
	afx_msg void OnViewText();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDebugShowCallCenter();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in VCview.cpp
inline CVCDoc* CVCView::GetDocument()
   { return (CVCDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcdoc.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// VCdoc.h : interface of the CVCDoc class
//
/////////////////////////////////////////////////////////////////////////////

class CVCSrvrItem;
class CVCard;
class CVCNode;

class CVCDoc : public CDocument
{
protected: // create from serialization only
	CVCDoc();
	DECLARE_DYNCREATE(CVCDoc)

// Attributes
public:
	CSize GetDocSize() { return m_sizeDoc; }
	CSize GetMinDocSize() { return m_minSizeDoc; }
	CVCard *GetVCard() { return m_vcard; }
	CString PathToAuxFile(const char *auxPath);
	void SetDisplayInfo(CVCNode *body, const char *docPath);

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVCDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	protected:
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CVCDoc();
	CSize SetDocSize(CSize &size) { CSize old = m_sizeDoc; m_sizeDoc = size; return old; }
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	HGLOBAL ReadFileIntoMemory(const char *path, int *inputLen);
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	void InsertFile(const char *propName, const char *theType, const char *path);

	CSize m_sizeDoc;
	CSize m_minSizeDoc;
	CVCard *m_vcard;
	char *m_preamble, *m_postamble;
	int m_preambleLen, m_postambleLen;
	CString *m_unknownTags;

// Generated message map functions
protected:
	//{{AFX_MSG(CVCDoc)
	afx_msg void OnInsertLogo();
	afx_msg void OnInsertPhoto();
	afx_msg void OnInsertPronun();
	afx_msg void OnSendIrda();
	afx_msg void OnUpdateSendIrda(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wab32res\commonrc.h ===
// resources that are replicated in both wab32.dll and the other WAB files

#define IDS_ALL_FILE_SPEC               60
#define IDI_ICON_VCARD                  1924
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wab32res\makefile.inc ===
WAB32_RC_DEPENDS =  resource.h \
                    resrc1.h

$O\wab32res.res : $(WAB32_RC_DEPENDS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\wchar.cpp ===
#include "stdafx.h"
#include "wchar.h"


wchar_t* wcscpy(wchar_t* dst, const wchar_t* src)
{
	wchar_t* result = dst;
	while (*src) {
		*dst++ = *src++;
	}
	*dst = 0;
	return result;
}

wchar_t* wcscat(wchar_t* dst, const wchar_t* src)
{
	wchar_t* result = dst;
	dst += wcslen(dst);
	while (*src) {
		*dst++ = *src++;
	}
	*dst = 0;
	return result;
}

int wcscmp(const wchar_t* s1, const wchar_t* s2)
{
	while (*s1 && *s2) {
		if (*s1 < *s2)
			return -1;
		else if (*s1 > *s2)
			return 1;
		s1++;
		s2++;
	}
	if (!*s1 && !*s2)
		return 0;
	else if (*s1)
		return 1;
	else
		return -1;
}

int wcslen(const wchar_t* str)
{
	int len = 0;
	while (*str++) len++;
	return len;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\viewprop.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#include "stdafx.h"
#include "vcard.h"
#include "clist.h"
#include "vc.h"
#include "vcview.h"
#include "vcdoc.h"
#include "prp_pers.h"
#include "prp_comp.h"
#include "propemal.h"
#include "proplocb.h"
#include "proplocx.h"
#include "proptel.h"
#include "msv.h"

CM_CFUNCTION
extern CVCNode* FindOrCreatePart(CVCNode *node, const char *name);
CM_END_CFUNCTION

static const char* emailProps[] = {
	vcAOLProp,
	vcAppleLinkProp,
	vcATTMailProp,
	vcCISProp,
	vcEWorldProp,
	vcInternetProp,
	vcIBMMailProp,
	vcMSNProp,
	vcMCIMailProp,
	vcPowerShareProp,
	vcProdigyProp,
	vcTLXProp,
	vcX400Prop,
	NULL
};

static char nameGen[4];


/////////////////////////////////////////////////////////////////////////////
// This uses a deep prop enumerator to find the relevant props, because
// they could be legitimately attached to either the body itself or
// a body part object.  There would only ever be one instance of any
// of these props on a given body.
void InitNamePage(CPropPers &propPageName, CVCNode *body, CVCard *card)
{
	char buf[1024];
	CVCPropEnumerator enumerator = CVCPropEnumerator(body);
	CVCProp *prop;
	CVCNode *node;
	CVCValue *value;

	while ((prop = enumerator.NextProp(&node))) {

		if (strcmp(prop->GetName(), vcFamilyNameProp) == 0) {
			propPageName.m_edit_famname = UI_CString(
				(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
			propPageName.m_nodeName = node;
		} else if (strcmp(prop->GetName(), vcFullNameProp) == 0) {
			propPageName.m_edit_fullname = UI_CString(
				(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
			propPageName.m_nodeFullName = node;
		} else if (strcmp(prop->GetName(), vcGivenNameProp) == 0) {
			propPageName.m_edit_givenname = UI_CString(
				(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
			propPageName.m_nodeName = node;
		} else if (strcmp(prop->GetName(), vcPronunciationProp) == 0) {
			if ((value = prop->FindValue(VCStrIdxType))) {
				propPageName.m_edit_pronun = UI_CString(
					(wchar_t *)value->GetValue(), buf);
				propPageName.m_nodePronun = node;
			}
		}
	} // while
} // InitNamePage

/////////////////////////////////////////////////////////////////////////////
// This uses a deep prop enumerator to find the relevant props, because
// they could be legitimately attached to either the body itself or
// a body part object.  There would only ever be one instance of any
// of these props on a given body.
void InitCompanyPage(CPropCompany &propPageCompany, CVCNode *body, CVCard *card)
{
	char buf[1024];
	CVCPropEnumerator enumerator = CVCPropEnumerator(body);
	CVCProp *prop;
	CVCNode *node;

	while ((prop = enumerator.NextProp(&node))) {

		if (strcmp(prop->GetName(), vcOrgNameProp) == 0) {
			propPageCompany.m_edit_orgname = UI_CString(
				(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
			propPageCompany.m_nodeOrg = node;
		} else if (strcmp(prop->GetName(), vcOrgUnitProp) == 0) {
			propPageCompany.m_edit_orgunit = UI_CString(
				(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
			propPageCompany.m_nodeOrg = node;
		} else if (strcmp(prop->GetName(), vcTitleProp) == 0) {
			propPageCompany.m_edit_title = UI_CString(
				(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
			propPageCompany.m_nodeTitle = node;
		}
	} // while
} // InitCompanyPage

CString FirstEmailPropStr(CList *plist)
{
	for (CLISTPOSITION pos = plist->GetHeadPosition(); pos; ) {
		CVCProp *prop = (CVCProp *)plist->GetNext(pos);
		const char **kep = emailProps;
		while (*kep) {
			if (strcmp(prop->GetName(), *kep) == 0)
				return CString(strrchr(*kep, '/') + 1);
			kep++;
		}
	}
	return CString("");
} // FirstEmailPropStr

/////////////////////////////////////////////////////////////////////////////
int VCMatchProp(void *item, void *context)
{
	CVCProp *prop = (CVCProp *)item;
	const char *propName = (const char *)context;
	return strcmp(propName, prop->GetName()) == 0;
}

/////////////////////////////////////////////////////////////////////////////
// This uses a deep enumerator, and so looks at all the part objects
// in every level of the tree.
void InitEmailPage(CPropEmail &propPageEmail, CVCNode *body, CVCard *card)
{
	char buf[1024];
	int partIndex = 0;
	CVCPropEnumerator enumerator = CVCPropEnumerator(body);
	CVCProp *prop;
	CVCNode *node;

	while ((prop = enumerator.NextProp(&node))) {

		if (strcmp(prop->GetName(), vcPartProp) != 0)
			continue;

		CVCNode *part = (CVCNode *)prop->FindValue(
			VCNextObjectType)->GetValue();
		if (!part->GetProp(vcEmailAddressProp))
			continue;

		switch (partIndex) {
			case 0: propPageEmail.m_node1 = part; break;
			case 1: propPageEmail.m_node2 = part; break;
			case 2: propPageEmail.m_node3 = part; break;
		}

		CList *partProps = part->GetProps();
		for (CLISTPOSITION pos = partProps->GetHeadPosition(); pos; ) {
			CVCProp *prop = (CVCProp *)partProps->GetNext(pos);

			if (strcmp(prop->GetName(), vcEmailAddressProp) == 0) {
				CString str(UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf));
				CList plist;
				card->GetPropsInEffect(part, &plist);
				switch (partIndex) {
					case 0:
						propPageEmail.m_edit_email1 = str;
						propPageEmail.m_popup_std1 = FirstEmailPropStr(&plist);
						propPageEmail.m_button_pref1 = plist.Search(VCMatchProp, (void *)vcPreferredProp) != NULL;
						propPageEmail.m_button_office1 = plist.Search(VCMatchProp, (void *)vcWorkProp) != NULL;
						propPageEmail.m_button_home1 = plist.Search(VCMatchProp, (void *)vcHomeProp) != NULL;
						break;
					case 1:
						propPageEmail.m_edit_email2 = str;
						propPageEmail.m_popup_std2 = FirstEmailPropStr(&plist);
						propPageEmail.m_button_pref2 = plist.Search(VCMatchProp, (void *)vcPreferredProp) != NULL;
						propPageEmail.m_button_office2 = plist.Search(VCMatchProp, (void *)vcWorkProp) != NULL;
						propPageEmail.m_button_home2 = plist.Search(VCMatchProp, (void *)vcHomeProp) != NULL;
						break;
					case 2:
						propPageEmail.m_edit_email3 = str;
						propPageEmail.m_popup_std3 = FirstEmailPropStr(&plist);
						propPageEmail.m_button_pref3 = plist.Search(VCMatchProp, (void *)vcPreferredProp) != NULL;
						propPageEmail.m_button_office3 = plist.Search(VCMatchProp, (void *)vcWorkProp) != NULL;
						propPageEmail.m_button_home3 = plist.Search(VCMatchProp, (void *)vcHomeProp) != NULL;
						break;
				} // switch
			} // email prop
		} // for each part prop

		partIndex++;
	} // for each body prop
} // InitEmailPage

/////////////////////////////////////////////////////////////////////////////
// This looks at only the part objects within the props of body itself,
// and so the properties that make up the basic location are seen only
// if they're at that level.
void InitLocBasicPage(CPropLocBasic &propPageLocBasic, CVCNode *body, CVCard *card)
{
	char buf[1024];
	CVCPropEnumerator enumerator = CVCPropEnumerator(body);
	CVCProp *prop;
	CVCNode *node;
	BOOL processedCaption = FALSE;

	while ((prop = enumerator.NextProp(&node))) {
		if (strcmp(prop->GetName(), vcLocationProp) == 0) {
			propPageLocBasic.m_edit_location = UI_CString(
				(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
			propPageLocBasic.m_nodeloc = node;
		} else if (strcmp(prop->GetName(), vcDeliveryLabelProp) == 0) {
			CList plist;
			card->GetPropsInEffect(node, &plist);
			if (plist.Search(VCMatchProp, (void *)vcDomesticProp)) {
				propPageLocBasic.m_edit_postdom = UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
				propPageLocBasic.m_nodepostdom = node;
			} else {
				propPageLocBasic.m_edit_postintl = UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
				propPageLocBasic.m_nodepostintl = node;
			}
			if (!processedCaption) {
				propPageLocBasic.m_button_home = plist.Search(VCMatchProp, (void *)vcHomeProp) != NULL;
				propPageLocBasic.m_button_office = plist.Search(VCMatchProp, (void *)vcWorkProp) != NULL;
				propPageLocBasic.m_button_parcel = plist.Search(VCMatchProp, (void *)vcParcelProp) != NULL;
				propPageLocBasic.m_button_postal = plist.Search(VCMatchProp, (void *)vcPostalProp) != NULL;
				processedCaption = TRUE;
			}
		} else if (strcmp(prop->GetName(), vcTimeZoneProp) == 0) {
			propPageLocBasic.m_edit_timezone = UI_CString(
				(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
			propPageLocBasic.m_nodetz = node;
		}
	} // while
} // InitLocBasicPage

/////////////////////////////////////////////////////////////////////////////
// This looks at only the part objects within the props of body itself,
// and so the properties that make up the extended location are seen only
// if they're at that level.
void InitLocXPage(CPropLocX &propPageLocX, CVCNode *body, CVCard *card)
{
	CList *props = body->GetProps();
	char buf[1024];

	for (CLISTPOSITION pos = props->GetHeadPosition(); pos; ) {
		CVCProp *prop = (CVCProp *)props->GetNext(pos);

		if (strcmp(prop->GetName(), vcPartProp) != 0)
			continue;

		CVCNode *part = (CVCNode *)prop->FindValue(
			VCNextObjectType)->GetValue();
		CList *partProps = part->GetProps();

		for (CLISTPOSITION pos = partProps->GetHeadPosition(); pos; ) {
			CVCProp *prop = (CVCProp *)partProps->GetNext(pos);

			if (strcmp(prop->GetName(), vcExtAddressProp) == 0) {
				propPageLocX.m_edit_xaddr = UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
				propPageLocX.m_node = part;
			} else if (strcmp(prop->GetName(), vcStreetAddressProp) == 0) {
				propPageLocX.m_edit_straddr = UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
				propPageLocX.m_node = part;
			} else if (strcmp(prop->GetName(), vcPostalBoxProp) == 0) {
				propPageLocX.m_edit_pobox = UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
				propPageLocX.m_node = part;
			} else if (strcmp(prop->GetName(), vcCityProp) == 0) {
				propPageLocX.m_edit_city = UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
				propPageLocX.m_node = part;
			} else if (strcmp(prop->GetName(), vcRegionProp) == 0) {
				propPageLocX.m_edit_region = UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
				propPageLocX.m_node = part;
			} else if (strcmp(prop->GetName(), vcPostalCodeProp) == 0) {
				propPageLocX.m_edit_pocode = UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
				propPageLocX.m_node = part;
			} else if (strcmp(prop->GetName(), vcCountryNameProp) == 0) {
				propPageLocX.m_edit_cntry = UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
				propPageLocX.m_node = part;
			}
		} // for each part prop
	} // for each body prop

	// If we don't set up one common node for these props, ApplyProp
	// would end up creating a different part for each.  We want these
	// to be grouped together, so create a holder node for them if
	// necessary.
	if (!propPageLocX.m_node)
		propPageLocX.m_node = body->AddPart();
} // InitLocXPage

/////////////////////////////////////////////////////////////////////////////
// This uses a deep enumerator, and so looks at all the part objects
// in every level of the tree.
void InitTelsPage(CPropTel &propPageTels, CVCNode *body, CVCard *card)
{
	char buf[1024];
	int partIndex = 0;
	CVCPropEnumerator enumerator = CVCPropEnumerator(body);
	CVCProp *prop;

	propPageTels.m_body = body;

	while ((prop = enumerator.NextProp())) {

		if (strcmp(prop->GetName(), vcPartProp) != 0)
			continue;

		CVCNode *part = (CVCNode *)prop->FindValue(
			VCNextObjectType)->GetValue();
		if (!part->GetProp(vcTelephoneProp))
			continue;
		
		switch (partIndex) {
			case 0: propPageTels.m_node1 = part; break;
			case 1: propPageTels.m_node2 = part; break;
			case 2: propPageTels.m_node3 = part; break;
		}

		CList *partProps = part->GetProps();
		for (CLISTPOSITION pos = partProps->GetHeadPosition(); pos; ) {
			CVCProp *prop = (CVCProp *)partProps->GetNext(pos);

			if (strcmp(prop->GetName(), vcTelephoneProp) == 0) {
				char *str = UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
				CList plist;
				card->GetPropsInEffect(part, &plist);
				switch (partIndex) {
					case 0:
						propPageTels.m_edit_fullName1 = str;
						propPageTels.m_button_fax1 = plist.Search(VCMatchProp, (void *)vcFaxProp) != NULL;
						propPageTels.m_button_home1 = plist.Search(VCMatchProp, (void *)vcHomeProp) != NULL;
						propPageTels.m_button_office1 = plist.Search(VCMatchProp, (void *)vcWorkProp) != NULL;
						propPageTels.m_button_cell1 = plist.Search(VCMatchProp, (void *)vcCellularProp) != NULL;
						propPageTels.m_button_message1 = plist.Search(VCMatchProp, (void *)vcMessageProp) != NULL;
						propPageTels.m_button_pref1 = plist.Search(VCMatchProp, (void *)vcPreferredProp) != NULL;
						break;
					case 1:
						propPageTels.m_edit_fullName2 = str;
						propPageTels.m_button_fax2 = plist.Search(VCMatchProp, (void *)vcFaxProp) != NULL;
						propPageTels.m_button_home2 = plist.Search(VCMatchProp, (void *)vcHomeProp) != NULL;
						propPageTels.m_button_office2 = plist.Search(VCMatchProp, (void *)vcWorkProp) != NULL;
						propPageTels.m_button_cell2 = plist.Search(VCMatchProp, (void *)vcCellularProp) != NULL;
						propPageTels.m_button_message2 = plist.Search(VCMatchProp, (void *)vcMessageProp) != NULL;
						propPageTels.m_button_pref2 = plist.Search(VCMatchProp, (void *)vcPreferredProp) != NULL;
						break;
					case 2:
						propPageTels.m_edit_fullName3 = str;
						propPageTels.m_button_fax3 = plist.Search(VCMatchProp, (void *)vcFaxProp) != NULL;
						propPageTels.m_button_home3 = plist.Search(VCMatchProp, (void *)vcHomeProp) != NULL;
						propPageTels.m_button_office3 = plist.Search(VCMatchProp, (void *)vcWorkProp) != NULL;
						propPageTels.m_button_cell3 = plist.Search(VCMatchProp, (void *)vcCellularProp) != NULL;
						propPageTels.m_button_message3 = plist.Search(VCMatchProp, (void *)vcMessageProp) != NULL;
						propPageTels.m_button_pref3 = plist.Search(VCMatchProp, (void *)vcPreferredProp) != NULL;
						break;
				} // switch
			} // telephone prop
		} // for each part prop

		partIndex++;
	} // for each body prop
} // InitTelsPage

static CString FilterUIString(const char *str)
{
	CString filtered(str);
	int len = filtered.GetLength(), index;

	// The passed string came from the UI (a property page), and so
	// line breaks are specified with '\r\n' (by UI_CString).
	// For the intermediate form, we keep just the '\n', which will
	// be changed to 0x2028 -- a line separator.
	while ((index = filtered.Find('\r')) != -1) {
		filtered = filtered.Left(index) + filtered.Right(len - index - 1);
		len--;
	}
	return filtered;
}

void ChangeStringProp(CVCProp *prop, const char *str)
{
	int size;
	wchar_t *uniValue;
	
	uniValue = FakeUnicode(FilterUIString(str), &size);
	FixCRLF(uniValue);
	prop->FindValue(VCStrIdxType)->SetValue(uniValue, size);
	delete [] uniValue;
}

void ApplyProp(
	const char *propName, const CString &newValue, CVCNode **node,
	CVCNode *body)
{
	if (!newValue.IsEmpty()) {
		CVCProp *prop;
		if (!*node) {
			*node = FindOrCreatePart(body, nameGen);
			nameGen[2] += 1;
		}
		prop = (*node)->GetProp(propName);
		if (prop)
			ChangeStringProp(prop, newValue);
		else {
			VC_DISPTEXT dispText;
			(*node)->AddStringProp(
				propName, FilterUIString(newValue), DisplayInfoForProp(propName, &dispText));
		}
	} else {
		if (*node && (strcmp(propName, vcPronunciationProp) != 0))
			(*node)->RemoveProp(propName);
	}
} // ApplyProp

/////////////////////////////////////////////////////////////////////////////
static void ApplyBoolProp(
	const char *propName, CVCard *card, CVCNode *node, CList *plist, BOOL wantTrue)
{
	CLISTPOSITION pos = plist->Search(VCMatchProp, (void *)propName);
	BOOL isTrue = pos != NULL;

	if (isTrue == wantTrue)
		return;

	if (isTrue) { // remove
		CVCNode *obj;
		VERIFY(card->GetInheritedProp(node, propName, &obj));
		plist->RemoveAt(pos);
		obj->RemoveProp(propName);
	} else { // add
		plist->AddTail(node->AddBoolProp(propName));
	}
}

/////////////////////////////////////////////////////////////////////////////
void ApplyNamePage(CPropPers &propPageName, CVCNode *body, CVCard *card)
{
	ApplyProp(vcFamilyNameProp,
		propPageName.m_edit_famname, &propPageName.m_nodeName, body);
	ApplyProp(vcFullNameProp,
		propPageName.m_edit_fullname, &propPageName.m_nodeFullName, body);
	ApplyProp(vcGivenNameProp,
		propPageName.m_edit_givenname, &propPageName.m_nodeName, body);
	ApplyProp(vcPronunciationProp,
		propPageName.m_edit_pronun, &propPageName.m_nodePronun, body);
}

/////////////////////////////////////////////////////////////////////////////
void ApplyCompanyPage(CPropCompany &propPageCompany, CVCNode *body, CVCard *card)
{
	ApplyProp(vcOrgNameProp,
		propPageCompany.m_edit_orgname, &propPageCompany.m_nodeOrg, body);
	ApplyProp(vcOrgUnitProp,
		propPageCompany.m_edit_orgunit, &propPageCompany.m_nodeOrg, body);
	ApplyProp(vcTitleProp,
		propPageCompany.m_edit_title, &propPageCompany.m_nodeTitle, body);
}

/////////////////////////////////////////////////////////////////////////////
static void ApplyEmailProp(
	CVCard *card, CVCNode *node, CList *plist, const char *propName)
{
	do { // remove every email prop currently in effect for this node
		const char *found = NULL;
		CLISTPOSITION foundPos;
		CVCNode *obj;

		for (CLISTPOSITION pos = plist->GetHeadPosition(); pos && (found == NULL); ) {
			foundPos = pos;
			CVCProp *prop = (CVCProp *)plist->GetNext(pos);
			const char **kep = emailProps;
			while (*kep) {
				if (strcmp(prop->GetName(), *kep) == 0) {
					found = *kep;
					break;
				}
				kep++;
			}
		}
		if (!found)
			break;
		VERIFY(card->GetInheritedProp(node, found, &obj));
		plist->RemoveAt(foundPos);
		obj->RemoveProp(found);
	} while (TRUE);

	// now add in the desired property
	plist->AddTail(node->AddBoolProp(propName));
}

/////////////////////////////////////////////////////////////////////////////
static const char* FullEmailName(const char *shortName)
{
	const char **kep = emailProps;
	while (*kep) {
		if (stricmp(strrchr(*kep, '/') + 1, shortName) == 0)
			return *kep;
		kep++;
	}
	return shortName;
}

/////////////////////////////////////////////////////////////////////////////
void ApplyEmailPage(CPropEmail &propPageEmail, CVCNode *body, CVCard *card)
{
	ApplyProp(vcEmailAddressProp,
		propPageEmail.m_edit_email1, &propPageEmail.m_node1, body);
	if (propPageEmail.m_node1) {
		CList plist;
		card->GetPropsInEffect(propPageEmail.m_node1, &plist);
		ApplyEmailProp(card, propPageEmail.m_node1, &plist,
			FullEmailName(propPageEmail.m_popup_std1));
		ApplyBoolProp(vcPreferredProp, card, propPageEmail.m_node1, &plist,
			propPageEmail.m_button_pref1);
		ApplyBoolProp(vcWorkProp, card, propPageEmail.m_node1, &plist,
			propPageEmail.m_button_office1);
		ApplyBoolProp(vcHomeProp, card, propPageEmail.m_node1, &plist,
			propPageEmail.m_button_home1);
	}

	ApplyProp(vcEmailAddressProp,
		propPageEmail.m_edit_email2, &propPageEmail.m_node2, body);
	if (propPageEmail.m_node2) {
		CList plist;
		card->GetPropsInEffect(propPageEmail.m_node2, &plist);
		ApplyEmailProp(card, propPageEmail.m_node2, &plist,
			FullEmailName(propPageEmail.m_popup_std2));
		ApplyBoolProp(vcPreferredProp, card, propPageEmail.m_node2, &plist,
			propPageEmail.m_button_pref2);
		ApplyBoolProp(vcWorkProp, card, propPageEmail.m_node2, &plist,
			propPageEmail.m_button_office2);
		ApplyBoolProp(vcHomeProp, card, propPageEmail.m_node2, &plist,
			propPageEmail.m_button_home2);
	}

	ApplyProp(vcEmailAddressProp,
		propPageEmail.m_edit_email3, &propPageEmail.m_node3, body);
	if (propPageEmail.m_node3) {
		CList plist;
		card->GetPropsInEffect(propPageEmail.m_node3, &plist);
		ApplyEmailProp(card, propPageEmail.m_node3, &plist,
			FullEmailName(propPageEmail.m_popup_std3));
		ApplyBoolProp(vcPreferredProp, card, propPageEmail.m_node3, &plist,
			propPageEmail.m_button_pref3);
		ApplyBoolProp(vcWorkProp, card, propPageEmail.m_node3, &plist,
			propPageEmail.m_button_office3);
		ApplyBoolProp(vcHomeProp, card, propPageEmail.m_node3, &plist,
			propPageEmail.m_button_home3);
	}
}

/////////////////////////////////////////////////////////////////////////////
void ApplyLocBasicPage(CPropLocBasic &propPageLocBasic, CVCNode *body, CVCard *card)
{
	ApplyProp(vcLocationProp,
		propPageLocBasic.m_edit_location, &propPageLocBasic.m_nodeloc, body);
	ApplyProp(vcTimeZoneProp,
		propPageLocBasic.m_edit_timezone, &propPageLocBasic.m_nodetz, body);

	ApplyProp(vcDeliveryLabelProp,
		propPageLocBasic.m_edit_postdom, &propPageLocBasic.m_nodepostdom, body);
	if (propPageLocBasic.m_nodepostdom) {
		CList plist;
		card->GetPropsInEffect(propPageLocBasic.m_nodepostdom, &plist);
		ApplyBoolProp(vcDomesticProp, card, propPageLocBasic.m_nodepostdom, &plist, TRUE);
		ApplyBoolProp(vcHomeProp, card, propPageLocBasic.m_nodepostdom, &plist,
			propPageLocBasic.m_button_home);
		ApplyBoolProp(vcWorkProp, card, propPageLocBasic.m_nodepostdom, &plist,
			propPageLocBasic.m_button_office);
		ApplyBoolProp(vcParcelProp, card, propPageLocBasic.m_nodepostdom, &plist,
			propPageLocBasic.m_button_parcel);
		ApplyBoolProp(vcPostalProp, card, propPageLocBasic.m_nodepostdom, &plist,
			propPageLocBasic.m_button_postal);
		ApplyBoolProp(vcQuotedPrintableProp, card, propPageLocBasic.m_nodepostdom, &plist,
			TRUE);
	}

	ApplyProp(vcDeliveryLabelProp,
		propPageLocBasic.m_edit_postintl, &propPageLocBasic.m_nodepostintl, body);
	if (propPageLocBasic.m_nodepostintl) {
		CList plist;
		card->GetPropsInEffect(propPageLocBasic.m_nodepostintl, &plist);
		ApplyBoolProp(vcHomeProp, card, propPageLocBasic.m_nodepostintl, &plist,
			propPageLocBasic.m_button_home);
		ApplyBoolProp(vcWorkProp, card, propPageLocBasic.m_nodepostintl, &plist,
			propPageLocBasic.m_button_office);
		ApplyBoolProp(vcParcelProp, card, propPageLocBasic.m_nodepostintl, &plist,
			propPageLocBasic.m_button_parcel);
		ApplyBoolProp(vcPostalProp, card, propPageLocBasic.m_nodepostintl, &plist,
			propPageLocBasic.m_button_postal);
		ApplyBoolProp(vcQuotedPrintableProp, card, propPageLocBasic.m_nodepostintl, &plist,
			TRUE);
	}
}

/////////////////////////////////////////////////////////////////////////////
void ApplyLocXPage(CPropLocX &propPageLocX, CVCNode *body, CVCard *card)
{
	CVCNode *node = propPageLocX.m_node;
	ApplyProp(vcExtAddressProp,
		propPageLocX.m_edit_xaddr, &node, body);
	node = propPageLocX.m_node;
	ApplyProp(vcStreetAddressProp,
		propPageLocX.m_edit_straddr, &node, body);
	node = propPageLocX.m_node;
	ApplyProp(vcPostalBoxProp,
		propPageLocX.m_edit_pobox, &node, body);
	node = propPageLocX.m_node;
	ApplyProp(vcCityProp,
		propPageLocX.m_edit_city, &node, body);
	node = propPageLocX.m_node;
	ApplyProp(vcRegionProp,
		propPageLocX.m_edit_region, &node, body);
	node = propPageLocX.m_node;
	ApplyProp(vcPostalCodeProp,
		propPageLocX.m_edit_pocode, &node, body);
	node = propPageLocX.m_node;
	ApplyProp(vcCountryNameProp,
		propPageLocX.m_edit_cntry, &node, body);
}

/////////////////////////////////////////////////////////////////////////////
void ApplyTelsPage(CPropTel &propPageTels, CVCNode *body, CVCard *card)
{
	ApplyProp(vcTelephoneProp,
		propPageTels.m_edit_fullName1, &propPageTels.m_node1, body);
	if (propPageTels.m_node1) {
		CList plist;
		card->GetPropsInEffect(propPageTels.m_node1, &plist);
		ApplyBoolProp(vcFaxProp, card, propPageTels.m_node1, &plist,
			propPageTels.m_button_fax1);
		ApplyBoolProp(vcHomeProp, card, propPageTels.m_node1, &plist,
			propPageTels.m_button_home1);
		ApplyBoolProp(vcWorkProp, card, propPageTels.m_node1, &plist,
			propPageTels.m_button_office1);
		ApplyBoolProp(vcCellularProp, card, propPageTels.m_node1, &plist,
			propPageTels.m_button_cell1);
		ApplyBoolProp(vcMessageProp, card, propPageTels.m_node1, &plist,
			propPageTels.m_button_message1);
		ApplyBoolProp(vcPreferredProp, card, propPageTels.m_node1, &plist,
			propPageTels.m_button_pref1);
	}

	ApplyProp(vcTelephoneProp,
		propPageTels.m_edit_fullName2, &propPageTels.m_node2, body);
	if (propPageTels.m_node2) {
		CList plist;
		card->GetPropsInEffect(propPageTels.m_node2, &plist);
		ApplyBoolProp(vcFaxProp, card, propPageTels.m_node2, &plist,
			propPageTels.m_button_fax2);
		ApplyBoolProp(vcHomeProp, card, propPageTels.m_node2, &plist,
			propPageTels.m_button_home2);
		ApplyBoolProp(vcWorkProp, card, propPageTels.m_node2, &plist,
			propPageTels.m_button_office2);
		ApplyBoolProp(vcCellularProp, card, propPageTels.m_node2, &plist,
			propPageTels.m_button_cell2);
		ApplyBoolProp(vcMessageProp, card, propPageTels.m_node2, &plist,
			propPageTels.m_button_message2);
		ApplyBoolProp(vcPreferredProp, card, propPageTels.m_node2, &plist,
			propPageTels.m_button_pref2);
	}

	ApplyProp(vcTelephoneProp,
		propPageTels.m_edit_fullName3, &propPageTels.m_node3, body);
	if (propPageTels.m_node3) {
		CList plist;
		card->GetPropsInEffect(propPageTels.m_node3, &plist);
		ApplyBoolProp(vcFaxProp, card, propPageTels.m_node3, &plist,
			propPageTels.m_button_fax3);
		ApplyBoolProp(vcHomeProp, card, propPageTels.m_node3, &plist,
			propPageTels.m_button_home3);
		ApplyBoolProp(vcWorkProp, card, propPageTels.m_node3, &plist,
			propPageTels.m_button_office3);
		ApplyBoolProp(vcCellularProp, card, propPageTels.m_node3, &plist,
			propPageTels.m_button_cell3);
		ApplyBoolProp(vcMessageProp, card, propPageTels.m_node3, &plist,
			propPageTels.m_button_message3);
		ApplyBoolProp(vcPreferredProp, card, propPageTels.m_node3, &plist,
			propPageTels.m_button_pref3);
	}
}

/////////////////////////////////////////////////////////////////////////////
char NextGeneratedNameSeed(CVCNode *body)
{
	CVCPropEnumerator enumerator = CVCPropEnumerator(body);
	CVCProp *prop;
	char nodeName[1024];
	char maxChar = 'A' - 1;

	while ((prop = enumerator.NextProp())) {
		if (strcmp(prop->GetName(), vcNodeNameProp) != 0)
			continue;
		UI_CString((wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), nodeName);
		if ((strlen(nodeName) == 3) && (strncmp(nodeName, "vc", 2) == 0))
			maxChar = max(nodeName[2], maxChar);
	}

	return maxChar + 1;
}

/////////////////////////////////////////////////////////////////////////////
void CVCView::OnEditProperties() 
{
	CVCDoc *doc = GetDocument();
	CVCard *cards = doc->GetVCard();
	CVCNode *body = cards->FindBody(m_language);
	CList *props = body->GetProps();
	CPropertySheet propSheet(IDR_MAINFRAME /* that'll read "Versitcard" */);
	CPropPers propPageName;
	CPropCompany propPageCompany;
	CPropEmail propPageEmail;
	CPropLocBasic propPageLocBasic;
	CPropLocX propPageLocX;
	CPropTel propPageTels;

	// TRACE0("dump of card before initializing props...\n");
	// cards->WriteSimplegram(NULL);

	InitNamePage(propPageName, body, cards);
	InitCompanyPage(propPageCompany, body, cards);
	InitEmailPage(propPageEmail, body, cards);
	InitLocBasicPage(propPageLocBasic, body, cards);
	InitLocXPage(propPageLocX, body, cards);
	InitTelsPage(propPageTels, body, cards);

	propSheet.AddPage(&propPageName);
	propSheet.AddPage(&propPageCompany);
	propSheet.AddPage(&propPageEmail);
	propSheet.AddPage(&propPageLocBasic);
	propSheet.AddPage(&propPageLocX);
	propSheet.AddPage(&propPageTels);

	if (propSheet.DoModal() == IDOK) {
		nameGen[0] = 'v'; nameGen[1] = 'c';
		nameGen[2] = NextGeneratedNameSeed(body);
		nameGen[3] = 0;
		ApplyNamePage(propPageName, body, cards);
		ApplyCompanyPage(propPageCompany, body, cards);
		ApplyEmailPage(propPageEmail, body, cards);
		ApplyLocBasicPage(propPageLocBasic, body, cards);
		ApplyLocXPage(propPageLocX, body, cards);
		ApplyTelsPage(propPageTels, body, cards);
		doc->SetModifiedFlag();
		doc->UpdateAllViews(NULL);
		// TRACE0("dump of card after applying props...\n");
		// cards->WriteSimplegram(NULL);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcviewer.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// VCViewer.cpp : implementation file
//

#include "stdafx.h"
#include "VC.h"
#include "VCViewer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// VCViewer

IMPLEMENT_DYNCREATE(VCViewer, CCmdTarget)

VCViewer::VCViewer()
{
	EnableAutomation();
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();
}

VCViewer::~VCViewer()
{
	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();
}


void VCViewer::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CCmdTarget::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(VCViewer, CCmdTarget)
	//{{AFX_MSG_MAP(VCViewer)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(VCViewer, CCmdTarget)
	//{{AFX_DISPATCH_MAP(VCViewer)
	DISP_FUNCTION(VCViewer, "ReceiveCard", ReceiveCard, VT_I4, VTS_BSTR)
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IVCViewer to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {128D0C5F-2A69-11CF-8F1F-B06E03C10000}
static const IID IID_IVCViewer =
{ 0x128d0c5f, 0x2a69, 0x11cf, { 0x8f, 0x1f, 0xb0, 0x6e, 0x3, 0xc1, 0x0, 0x0 } };

BEGIN_INTERFACE_MAP(VCViewer, CCmdTarget)
	INTERFACE_PART(VCViewer, IID_IVCViewer, Dispatch)
END_INTERFACE_MAP()

// {128D0C60-2A69-11CF-8F1F-B06E03C10000}
IMPLEMENT_OLECREATE(VCViewer, "VC.VCVIEWER", 0x128d0c60, 0x2a69, 0x11cf, 0x8f, 0x1f, 0xb0, 0x6e, 0x3, 0xc1, 0x0, 0x0)

/////////////////////////////////////////////////////////////////////////////
// VCViewer message handlers

long VCViewer::ReceiveCard(LPCTSTR nativePath) 
{
	CVCApp *app = (CVCApp *)AfxGetApp();

	return app->ReceiveCard(nativePath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wab32res\resource.h ===
/**********************************************************************
/
/ Resource.h - Resource symbol definitions for WAB32.Dll
/
/
/
/
/**********************************************************************/
#include ".\commonrc.h"


#define IDS_WAB_TEMP_FILE_PREFIX        1
#define IDS_ADDRBK_CAPTION              3
#define IDD_FORMVIEW                    4
#define IDC_PIC                         5
#define IDS_ADDRBK_MESSAGE_ACTION       21
#define IDS_ADDRBK_MESSAGE_NO_ITEM      22
#define IDS_ADDRBK_MESSAGE_DELETE       23
#define IDS_ADDRBK_MESSAGE_NO_ITEMS_DELETE 26
#define IDS_ADDRBK_MESSAGE_NO_ITEMS_ADD 27
#define IDS_ADDRBK_RESOLVE_CAPTION      28
#define IDS_DETAILS_CAPTION             33
#define IDS_RESOLVE_NO_MATCHES          38
#define IDS_RESOLVE_NO_MATCHES_FOR      39
#define IDS_DETAILS_MESSAGE_FIRST_LAST_REQUIRED 40
#define IDS_ADDRBK_MESSAGE_DELETING_ERROR 42
#define IDS_VCARD_FILE_SPEC             43
#define IDS_VCARD_EXPORT_TITLE          44
#define IDS_VCARD_IMPORT_TITLE          45
#define IDE_VCARD_IMPORT_FILE_ERROR     46
#define IDE_VCARD_IMPORT_FILE_BAD       47
#define IDE_VCARD_EXPORT_FILE_ERROR     48
#define IDE_VCARD_EXPORT_DISTLIST       50
#define IDE_VCARD_IMPORT_PARTIAL        51
#define IDS_VCARD_IMPORT_COLLISION      52
#define IDS_VCARD_EXPORT_NOT_ASCII      53
#define IDE_VCARD_EXPORT_FILE_EXISTS    55
#define IDS_VISIT_SERVER                56
#define IDE_SERVER_NAME_COLLISION       57
#define IDS_CERT_FILE_SPEC              59
#define IDS_CER_FILE_SPEC               61


#define IDD_DIALOG_DETAILS_PERSONAL     101
#define IDD_DIALOG_DETAILS_NET          105
#define IDD_DIALOG_ADDRESSBOOK          106
#define IDD_DIALOG_PROPERTIES           107
#define IDD_DIALOG_RESOLVENAME          112
#define IDD_DETAILS_PERSONAL            114
#define IDD_DETAILS_HOME                115
#define IDD_DETAILS_BUSINESS            116
#define IDD_DETAILS_NOTES               117
#define IDD_DISTLIST                    118
#define IDD_DETAILS_CERT                119
#define iddConflict                     120
#define iddSyncProgress                 121
#define iddPassword                     123
#define iddChooseServer                 124

#define IDC_DETAILS_EDIT_DISPLAYNAME    1003
#define IDC_DETAILS_EDIT_FIRSTNAME      1004
#define IDC_DETAILS_EDIT_LASTNAME       1005
#define IDC_DETAILS_EDIT_NOTES          1006
#define IDC_DETAILS_COMBO_EMAIL         1007
#define IDC_STATIC1                     1009
#define IDC_STATIC2                     1010
#define IDC_STATIC3                     1011
#define IDC_STATIC4                     1012
#define IDC_STATIC5                     1013
#define IDC_STATIC6                     1014
#define IDC_STATIC7                     1015
#define IDC_STATIC8                     1016
#define IDC_STATIC9                     1017
#define IDC_STATIC10                    1018
#define IDC_STATIC11                    1019
#define IDC_STATIC12                    1020
#define IDC_PROP_STATIC1                1028
#define IDC_PROP_STATIC_2               1029
#define IDC_PROP_STATIC_3               1030
#define IDC_PROP_EDIT_FIRSTNAME         1031
#define IDC_PROP_EDIT_LASTNAME          1032
#define IDC_PROP_EDIT_EMAIL             1033
#define IDC_PROP_STATIC_4               1034
#define IDC_PROP_STATIC_5               1035
#define IDC_PROP_STATIC_6               1036
#define IDC_RESOLVE_BUTTON_OK           1044
#define IDC_RESOLVE_BUTTON_CANCEL       1045
#define IDC_RESOLVE_STATIC_1            1046
#define IDC_RESOLVE_STATIC_ETCHED       1047
#define IDC_RESOLVE_BUTTON_BROWSE       1054
#define IDC_RESOLVE_LIST_MATCHES        1055
#define IDC_RESOLVE_BUTTON_PROPS        1056
#define IDC_RESOLVE_BUTTON_NEWCONTACT   1057
#define IDC_RESOLVE_BUTTON_NEWGROUP     1058
#define IDC_RESOLVE_STATIC_MATCHES      1059

#define IDI_ICON_ABOOK                  1911
#define IDI_ICON_FIND                   1912
#define IDI_ICON_CONTACT                1915
#define IDI_ICON_HOME                   1916
#define IDI_ICON_BUSINESS               1917
#define IDI_ICON_NOTES                  1918
#define IDI_ICON_GROUP                  1919
#define IDI_ICON_IE                     1920
#define IDI_ICON_CERT                   1921
#define IDI_ICON_CHECK                  1922
#define IDI_ICON_UNCHECK                1923
#define IDI_PasswordKeys                1925
#define IDI_ICON_SYNC                   1926

#define IDC_DISTLIST_STATIC_GROUPNAME   2359
#define IDC_DISTLIST_EDIT_GROUPNAME     2360
#define IDC_DISTLIST_FRAME_MEMBERS      2361
#define IDC_DISTLIST_LISTVIEW           2362
#define IDC_DISTLIST_BUTTON_ADD         2363
#define IDC_DISTLIST_BUTTON_REMOVE      2364
#define IDC_DISTLIST_STATIC_NOTES       2365
#define IDC_DISTLIST_EDIT_NOTES         2366
#define IDC_DISTLIST_BUTTON_PROPERTIES  2369
#define IDC_DISTLIST_BUTTON_ADDNEW      2370
#define IDC_DISTLIST_STATIC_COUNT       2371
#define IDC_DISTLIST_STATIC_ADD         2372
#define IDC_DISTLIST_STATIC_ADDNAME     2373
#define IDC_DISTLIST_EDIT_ADDNAME       2374
#define IDC_DISTLIST_STATIC_ADDEMAIL    2375
#define IDC_DISTLIST_EDIT_ADDEMAIL      2376
#define IDC_DISTLIST_BUTTON_ADDUPDATE   2377
#define IDC_DISTLIST_BUTTON_UPDATECANCEL    2378
#define IDD_DISTLIST_OTHER              2379
#define IDC_DISTLIST_STATIC_STREET      2380
#define IDC_DISTLIST_EDIT_ADDRESS       2381
#define IDC_DISTLIST_STATIC_CITY        2382
#define IDC_DISTLIST_EDIT_CITY          2383
#define IDC_DISTLIST_STATIC_STATE       2384
#define IDC_DISTLIST_EDIT_STATE         2385
#define IDC_DISTLIST_STATIC_ZIP         2386
#define IDC_DISTLIST_EDIT_ZIP           2387
#define IDC_DISTLIST_STATIC_COUNTRY     2388
#define IDC_DISTLIST_EDIT_COUNTRY       2389
#define IDC_DISTLIST_STATIC_PHONE       2390
#define IDC_DISTLIST_EDIT_PHONE         2391
#define IDC_DISTLIST_STATIC_FAX         2392
#define IDC_DISTLIST_EDIT_FAX           2393
#define IDC_DISTLIST_STATIC_WEB         2394
#define IDC_DISTLIST_EDIT_URL           2395
#define IDC_DISTLIST_BUTTON_URL         2396



#define IDC_DETAILS_NOTES_STATIC_NOTES          2462
#define IDC_DETAILS_NOTES_EDIT_NOTES            2463

#define IDC_DETAILS_CERT_FRAME                  2474
#define IDC_DETAILS_CERT_LIST                   2475
#define IDC_DETAILS_CERT_BUTTON_PROPERTIES      2476
#define IDC_DETAILS_CERT_BUTTON_REMOVE          2477
#define IDC_DETAILS_CERT_BUTTON_SETDEFAULT      2478
#define IDC_DETAILS_CERT_BUTTON_IMPORT          2479
#define IDC_DETAILS_CERT_BUTTON_EXPORT          2480

#define IDC_DETAILS_BUSINESS_STATIC_COMPANY     2561
#define IDC_DETAILS_BUSINESS_STATIC_JOBTITLE    2562
#define IDC_DETAILS_BUSINESS_STATIC_ADDRESS     2563
#define IDC_DETAILS_BUSINESS_STATIC_CITY        2564
#define IDC_DETAILS_BUSINESS_STATIC_STATE       2565
#define IDC_DETAILS_BUSINESS_STATIC_ZIP         2566
#define IDC_DETAILS_BUSINESS_STATIC_COUNTRY     2567
#define IDC_DETAILS_BUSINESS_STATIC_WEB         2568
#define IDC_DETAILS_BUSINESS_EDIT_COMPANY       2569
#define IDC_DETAILS_BUSINESS_EDIT_JOBTITLE      2570
#define IDC_DETAILS_BUSINESS_EDIT_ADDRESS       2571
#define IDC_DETAILS_BUSINESS_EDIT_CITY          2572
#define IDC_DETAILS_BUSINESS_EDIT_STATE         2573
#define IDC_DETAILS_BUSINESS_EDIT_ZIP           2574
#define IDC_DETAILS_BUSINESS_EDIT_COUNTRY       2575
#define IDC_DETAILS_BUSINESS_EDIT_URL           2576
#define IDC_DETAILS_BUSINESS_EDIT_PHONE         2577
#define IDC_DETAILS_BUSINESS_EDIT_FAX           2578
#define IDC_DETAILS_BUSINESS_EDIT_DEPARTMENT    2579
#define IDC_DETAILS_BUSINESS_EDIT_OFFICE        2580
#define IDC_DETAILS_BUSINESS_EDIT_PAGER         2581
#define IDC_DETAILS_BUSINESS_STATIC_PHONE       2582
#define IDC_DETAILS_BUSINESS_STATIC_FAX         2583
#define IDC_DETAILS_BUSINESS_STATIC_PAGER       2584
#define IDC_DETAILS_BUSINESS_STATIC_DEPARTMENT  2585
#define IDC_DETAILS_BUSINESS_BUTTON_URL         2586
#define IDC_DETAILS_BUSINESS_STATIC_OFFICE      2587

#define IDC_DETAILS_HOME_STATIC_ADDRESS         2659
#define IDC_DETAILS_HOME_STATIC_CITY            2660
#define IDC_DETAILS_HOME_STATIC_STATE           2661
#define IDC_DETAILS_HOME_STATIC_ZIP             2662
#define IDC_DETAILS_HOME_STATIC_COUNTRY         2663
#define IDC_DETAILS_HOME_STATIC_WEB             2664
#define IDC_DETAILS_HOME_STATIC_PHONE           2665
#define IDC_DETAILS_HOME_STATIC_FAX             2666
#define IDC_DETAILS_HOME_STATIC_CELLULAR        2667
#define IDC_DETAILS_HOME_EDIT_ADDRESS           2668
#define IDC_DETAILS_HOME_EDIT_CITY              2669
#define IDC_DETAILS_HOME_EDIT_ZIP               2670
#define IDC_DETAILS_HOME_EDIT_STATE             2671
#define IDC_DETAILS_HOME_EDIT_COUNTRY           2672
#define IDC_DETAILS_HOME_EDIT_URL               2673
#define IDC_DETAILS_HOME_EDIT_PHONE             2674
#define IDC_DETAILS_HOME_EDIT_FAX               2675
#define IDC_DETAILS_HOME_EDIT_CELLULAR          2676
#define IDC_DETAILS_HOME_BUTTON_URL             2677

#define IDC_DETAILS_PERSONAL_FRAME_NAME         2760
#define IDC_DETAILS_PERSONAL_FRAME_EMAIL        2762
#define IDC_DETAILS_PERSONAL_STATIC_FIRSTNAME   2763
#define IDC_DETAILS_PERSONAL_STATIC_LASTNAME    2764
#define IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME     2765
#define IDC_DETAILS_PERSONAL_EDIT_LASTNAME      2766
#define IDC_DETAILS_PERSONAL_STATIC_MIDDLENAME  2767
#define IDC_DETAILS_PERSONAL_STATIC_NICKNAME    2768
#define IDC_DETAILS_PERSONAL_EDIT_MIDDLENAME    2769
#define IDC_DETAILS_PERSONAL_EDIT_NICKNAME      2770
#define IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL      2771
#define IDC_DETAILS_PERSONAL_BUTTON_ADDEMAIL    2772
#define IDC_DETAILS_PERSONAL_LIST               2774
#define IDC_DETAILS_PERSONAL_BUTTON_REMOVE      2775
#define IDC_DETAILS_PERSONAL_BUTTON_SETDEFAULT  2776
#define IDC_DETAILS_PERSONAL_BUTTON_EDIT        2777
#define IDC_DETAILS_PERSONAL_BUTTON_ADDTOWAB    2778

#define IDC_SYNC_NEXT                           2800
#define IDC_SYNC_BACK                           2801
#define IDC_SYNC_CONTACTNAME                    2803
#define IDC_SYNC_LIST                           2806
#define IDC_SYNC_FIELDNAME                      2807
#define IDC_SYNC_ADDRESSBOOK                    2808
#define IDC_SYNC_HOTMAIL                        2809
#define IDC_SYNC_IGNORE                         2810

#define IDC_SYNC_PROGBAR                        2850
#define IDC_SYNC_ANI                            2851
#define IDC_SYNC_MSG                            2852

#define IDS_SERVER                              2860    
#define IDE_PASSWORD                            2861
#define IDCH_REMEMBER                           2863
#define IDE_ACCOUNT                             2864

#define IDC_SERVER_LIST                         2870

#define idsColDisplayName               3990
#define idsColEmailAddress              3991
#define idsColHomePhone                 3992
#define idsColOfficePhone               3993

#define idsButton0                      3994
#define idsButton1                      3995
#define idsButton2                      3996
#define idsButton3                      3997
#define idsButton4                      3998
#define idsButton5                      3999

#define idsQuickFindCaption             4010
#define idsGroupMemberCount             4011
#define idsIncompleteOneoffInfo         4012
#define idsRemove                       4013
#define idsShowMoreNames                4014
#define idsDetailsPersonalTitle         4015
#define idsDetailsHomeTitle             4016
#define idsDetailsBusinessTitle         4017
#define idsDetailsNotesTitle            4018
#define idsInvalidInternetAddress       4019
#define idsToolbarMaxButtonWidth        4020
#define idsDefaultEmail                 4023

#define idsGroupTabName                 4028
#define idsPleaseEnterGroupName         4029
#define idsGroupAddWellButton           4030
#define idsGroupAddCaption              4031
#define idsGroupDestWellsTitle          4032
#define idsCouldNotAddGroupToGroup      4033

#define idsLangDisplayNameIsByLastName  4034
#define idsDisplayNameByLastName        4035
#define idsDisplayNameByFirstName       4036
#define idsDisplayNameByCommaLastName   4037

#define idsSpecifySearchCriteria        4042
#define idsCouldNotSelectUser           4043
#define idsNoItemsSelectedForAdding     4045
#define idsCouldNotAddUserToWAB         4046
#define idsSuccessfullyAddedUsers       4047
#define idsLDAPSearchNoResults          4048
#define idsLDAPAmbiguousRecip           4049
#define idsLDAPAccessDenied             4050
#define idsLDAPSearchTimedOut           4051
#define idsLDAPCouldNotFindServer       4052
#define idsLDAPErrorOccured             4053
#define idsLDAPPartialResults           4060
#define idsLDAPFirstNameOnly            4061
#define idsWABIntegrityError            4062
#define idsWABUnableToRestoreBackup     4063
#define idsWABRestoreSucceeded          4064
#define idsWABUnexpectedError           4065
#define idsEntryAlreadyExists           4066
#define idsWindowTitleProperties        4068
#define idsWABImportString              4069

#define idsContactTextEmail             4070
#define idsContactTextPersonal          4071
#define idsContactTextHomeAddress       4072
#define idsContactTextHomePhone         4073
#define idsContactTextHomeFax           4074
#define idsContactTextHomeCellular      4075
#define idsContactTextPersonalWebPage   4076
#define idsContactTextBusiness          4077
#define idsContactTextTitle             4078
#define idsContactTextDepartment        4079
#define idsContactTextOffice            4080
#define idsContactTextCompany           4081
#define idsContactTextBusinessAddress   4082
#define idsContactTextBusinessPhone     4083
#define idsContactTextBusinessFax       4084
#define idsContactTextBusinessPager     4085
#define idsContactTextBusinessWebPage   4086
#define idsContactTextNotes             4087
#define idsContactAddress               4088
#define idsSendMailTo                   4089
#define idsSendMailToNoEmail            4090
#define idsDetailsCertTitle             4091
#define idsDefaultCert                  4096
#define idsLDAPUnconfigured             4102
#define idsLDAPSearchTimeExceeded       4103


#define idsMenuNewContact               4200
#define idsMenuNewGroup                 4201
#define idsMenuCopy                     4202
#define idsMenuSendMail                 4203
#define idsMenuProperties               4204
#define idsMenuDelete                   4205
#define idsMenuAddToWAB                 4206
#define idsMenuFind                     4207
#define idsMenuDirectoryService         4208
#define idsMenuExit                     4209
#define idsMenuSelectAll                4210
#define idsMenuViewToolbar              4211
#define idsMenuViewStatusBar            4212
#define idsMenuLargeIcon                4213
#define idsMenuSmallIcon                4214
#define idsMenuList                     4215
#define idsMenuDetails                  4216
#define idsMenuDisplayName              4217
#define idsMenuEmail                    4218
#define idsMenuBusinessPhone            4219
#define idsMenuHomePhone                4220
#define idsMenuFirstName                4221
#define idsMenuLastName                 4222
#define idsMenuAscending                4223
#define idsMenuDescending               4224
#define idsMenuRefresh                  4225
#define idsMenuImportVcard              4226
#define idsMenuExportVcard              4227
#define idsMenuImportOther              4228
#define idsMenuHelp                     4229
#define idsUnknown                      4230
#define idsInvalidDBCSInternetAddress   4235
#define idsResolveMatchesOnLDAP         4236
#define idsCertImportTitle              4238
#define idsCertExportTitle              4239
#define idsMenuImportWAB                4278
#define idsMenuExportOther              4287

#ifdef WIN16
#define idsDefaultDialogFace            4400
#endif

#define idsDisplayName                  4501
#define idsGivenName                    4502
#define idsSurname                      4503
#define idsNickname                     4504
#define idsEmail                        4505
#define idsHomeStreet                   4506
#define idsHomeCity                     4507
#define idsHomeState                    4508
#define idsHomePostalCode               4509
#define idsHomeCountry                  4510
#define idsCompany                      4511
#define idsWorkStreet                   4512
#define idsWorkCity                     4513
#define idsWorkState                    4514
#define idsWorkPostalCode               4515
#define idsWorkCountry                  4516
#define idsHomePhone                    4517
#define idsHomeFax                      4518
#define idsWorkPhone                    4519
#define idsWorkFax                      4520
#define idsMobilePhone                  4521
#define idsOtherPhone                   4522
#define idsBirthday                     4523
#define idsPager                        4524

#define idsMultipleSelected             4550
#define idsNicknameFmt                  4551
#define idsSyncConnecting               4552
#define idsSyncSynchronizing            4553
#define idsSyncConflicts                4554
#define idsSyncFinishing                4555
#define idsSyncField                    4556
#define idsSyncABInfo                   4557
#define idsSyncHMInfo                   4558
#define idsSyncGathering                4559
#define idsSyncKeep                     4560
#define idsSyncSkip                     4561
#define idsSyncReplace                  4562
#define idsSyncFailed                   4563
#define idsSyncError                    4564
#define idsSyncAborted                  4565
#define idsOutOfServerSpace             4566
#define idsSyncNotHandled               4567
#define idsNoInternetConnect            4568
#define idsOffline                      4569
#ifdef HM_GROUP_SYNCING
#define idsSyncGroupsTitle              4570
#define idsSyncContactsTitle            4571
#endif
#define idsExpediaURL                   4572
#define idsExpediaIntlURL               4573

#define IDR_MENU_LVCONTEXT              4105
#define IDR_ACCELERATOR1                4107
#define IDB_BITMAP_SMALL                4108
#define IDB_BITMAP_LARGE                4109
#define IDR_MENU_AB                     4110

#define IDB_BITMAP_BUTTONS              4123
//#define IDB_BITMAP_HBG                  4124
#define IDB_COOLBAR_DEFAULT             4129
#define IDB_COOLBAR_HOT                 4130
#define IDB_COOLBAR_DISABLED            4131
#define IDB_DEFAULT_EMAIL               4132
#define IDB_CERT_VALID_INVALID          4133
#define IDB_CERT                        4134
#define IDB_COOLBAR_DEFHI               4136
#define IDB_COOLBAR_HOTHI               4137
#define IDB_COOLBAR_DISHI               4138
#define IDB_SYNC_SYNCOP                 4139

#define IDM_VIEW_LARGEICON               5000
#define IDM_VIEW_SMALLICON               5001
#define IDM_VIEW_LIST                    5002
#define IDM_VIEW_DETAILS                 5003
#define IDM_VIEW_TOOLBAR                 5004
#define IDM_VIEW_REFRESH                 5005
#define IDM_VIEW_SORTBY_FIRSTNAME        5009
#define IDM_VIEW_SORTBY_LASTNAME         5010
#define IDM_VIEW_SORTBY_DISPLAYNAME      5011
#define IDM_VIEW_SORTBY_EMAILADDRESS     5012
#define IDM_VIEW_SORTBY_BUSINESSPHONE    5013
#define IDM_VIEW_SORTBY_HOMEPHONE        5014
#define IDM_VIEW_SORTBY_ASCENDING        5015
#define IDM_VIEW_SORTBY_DESCENDING       5016
#define IDM_VIEW_STATUSBAR               5017

#define IDD_DIALOG_ABOUT                5870
#define IDC_ABOUT_LABEL                 5872
#define IDC_ABOUT_LABEL_VERSION         5873
#define IDC_ABOUT_COPYRIGHT             5874

#define IDC_SEARCH_STATIC_COMBOLABEL    6251
#define IDC_SEARCH_COMBO_SHOWNAMES      6252
#define IDC_SEARCH_STATIC_NAME          6253
#define IDC_SEARCH_STATIC_LABELFIRST    6254
#define IDC_SEARCH_EDIT_FIRST           6255
#define IDC_SEARCH_STATIC_LABELLAST     6256
#define IDC_SEARCH_EDIT_LAST            6257
#define IDC_SEARCH_STATIC_LABELEMAIL    6258
#define IDC_SEARCH_EDIT_EMAIL           6259
#define IDC_SEARCH_STATIC_LABELORG      6260
#define IDC_SEARCH_EDIT_ORG             6261
#define IDC_SEARCH_STATIC_LABELCOUNTRY  6262
#define IDC_SEARCH_COMBO_COUNTRY        6263
#define IDC_SEARCH_BUTTON_SEARCH        6264
#define IDC_SEARCH_BUTTON_CANCEL        6265
#define IDD_DIALOG_SEARCH               6266
#define IDC_SEARCH_STATIC_LABELFIRST_SIMPLE     6267
#define IDC_SEARCH_EDIT_FIRST_SIMPLE    6268
#define IDC_SEARCH_BUTTON_CLEAR         6270
#define IDC_SEARCH_RADIO_SIMPLE         6271
#define IDC_SEARCH_RADIO_DETAILED       6272
#define IDC_SEARCH_STATIC_LABELCOMPANY  6273
#define IDC_SEARCH_EDIT_COMPANY         6274
#define IDC_SEARCH_STATIC_LABELBASE     6275
#define IDC_SEARCH_EDIT_BASE            6276

#define IDC_ADDRBK_COMBO_SHOWNAMES      7000
#define IDC_ADDRBK_EDIT_QUICKFIND       7001
#define IDC_ADDRBK_BUTTON_FIND          7002
#define IDC_ADDRBK_LIST_ADDRESSES       7003
#define IDC_ADDRBK_BUTTON_PROPS         7004
#define IDC_ADDRBK_BUTTON_NEW           7005
#define IDC_ADDRBK_STATIC_CONTENTS      7008
#define IDC_ADDRBK_STATIC_RECIP_TITLE   7009
#define IDC_ADDRBK_BUTTON_CANCEL        7012
#define IDC_ADDRBK_BUTTON_OK            7013
#define IDC_ADDRBK_STATIC_COMBO         7014
#define IDC_ADDRBK_STATIC_15            7015
#define IDC_ADDRBK_STATIC_16            7018
#define IDC_ADDRBK_BUTTON_TO            7020
#define IDC_ADDRBK_BUTTON_CC            7021
#define IDC_ADDRBK_BUTTON_BCC           7022
#define IDC_ADDRBK_LIST_TO              7030
#define IDC_ADDRBK_LIST_CC              7031
#define IDC_ADDRBK_LIST_BCC             7032
#define IDC_ADDRBK_BUTTON_DELETE        7033
#define IDC_ADDRBK_BUTTON_NEWGROUP      7034


#define IDC_LISTVIEW                    9001
#define IDC_STATIC_QUICK_FIND           9002
#define IDC_STATIC_SHOW_NAMES           9003    
#define IDC_EDIT_QUICK_FIND             9004
#define IDC_COMBO_SHOW_NAMES            9005
#define IDC_ABOOK_STATIC_SHOW_NAMES     9006
#define IDC_ABOOK_STATIC_QUICK_FIND     9007
#define IDC_STATUSBAR                   9008
#define IDC_TOOLTIP                     9009


#define IDM_ADDRESS_BOOK                40006
#define IDM_FILE_NEWCONTACT             40012
#define IDM_FILE_NEWGROUP               40013
#define IDM_FILE_PROPERTIES             40014
#define IDM_FILE_DELETE                 40015
#define IDM_EDIT_FIND                   40016
#define IDM_EDIT_SELECTALL              40017
#define IDM_HELP_ADDRESSBOOKHELP        40018
#define IDM_HELP_ABOUTADDRESSBOOK       40019
#define IDM_FILE_EXIT                   40020
#define IDM_FILE_DIRECTORY_SERVICE      40021
#define IDM_TOOLS_OPTIONS               40022
#define IDM_FILE_ADDTOWAB               40023
#define IDM_TOOLS_IMPORT_VCARD          40024
#define IDM_TOOLS_EXPORT_VCARD          40025
#define IDM_EDIT_COPY                   40026
#define IDM_TOOLS_IMPORT_WAB            40027
#define IDM_TOOLS_EXPORT_WAB            40028
#define IDM_TOOLS_IMPORT_OTHER          40029
#define IDM_FILE_SENDMAIL               40030
#define IDM_FILE_PRINT                  40031
#define IDM_TOOLS_EXPORT_OTHER          40032
#define IDM_TOOLS_SYNCHRONIZE_NOW       40033

#define IDM_LVCONTEXT_ADDWELL1          40128
#define IDM_LVCONTEXT_ADDWELL2          40129
#define IDM_LVCONTEXT_ADDWELL3          40130
#define IDM_LVCONTEXT_NEWCONTACT        40131
#define IDM_LVCONTEXT_NEWGROUP          40132
#define IDM_LVCONTEXT_PROPERTIES        40133
#define IDM_LVCONTEXT_DELETE            40134
#define IDM_LVCONTEXT_ADDTOWAB          40135
#define IDM_LVCONTEXT_FIND              40136
#define IDM_LVCONTEXT_COPY              40138
#define IDM_LVCONTEXT_SENDMAIL          40139
#define IDM_LVCONTEXT_INTERNET_CALL     40140


#define  idsCountryCount    7201
#define  idsCountry1    7202
#define  idsCountry2    7203
#define  idsCountry3    7204
#define  idsCountry4    7205
#define  idsCountry5    7206
#define  idsCountry6    7207
#define  idsCountry7    7208
#define  idsCountry8    7209
#define  idsCountry9    7210
#define  idsCountry10    7211
#define  idsCountry11    7212
#define  idsCountry12    7213
#define  idsCountry13    7214
#define  idsCountry14    7215
#define  idsCountry15    7216
#define  idsCountry16    7217
#define  idsCountry17    7218
#define  idsCountry18    7219
#define  idsCountry19    7220
#define  idsCountry20    7221
#define  idsCountry21    7222
#define  idsCountry22    7223
#define  idsCountry23    7224
#define  idsCountry24    7225
#define  idsCountry25    7226
#define  idsCountry26    7227
#define  idsCountry27    7228
#define  idsCountry28    7229
#define  idsCountry29    7230
#define  idsCountry30    7231
#define  idsCountry31    7232
#define  idsCountry32    7233
#define  idsCountry33    7234
#define  idsCountry34    7235
#define  idsCountry35    7236
#define  idsCountry36    7237
#define  idsCountry37    7238
#define  idsCountry38    7239
#define  idsCountry39    7240
#define  idsCountry40    7241
#define  idsCountry41    7242
#define  idsCountry42    7243
#define  idsCountry43    7244
#define  idsCountry44    7245
#define  idsCountry45    7246
#define  idsCountry46    7247
#define  idsCountry47    7248
#define  idsCountry48    7249
#define  idsCountry49    7250
#define  idsCountry50    7251
#define  idsCountry51    7252
#define  idsCountry52    7253
#define  idsCountry53    7254
#define  idsCountry54    7255
#define  idsCountry55    7256
#define  idsCountry56    7257
#define  idsCountry57    7258
#define  idsCountry58    7259
#define  idsCountry59    7260
#define  idsCountry60    7261
#define  idsCountry61    7262
#define  idsCountry62    7263
#define  idsCountry63    7264
#define  idsCountry64    7265
#define  idsCountry65    7266
#define  idsCountry66    7267
#define  idsCountry67    7268
#define  idsCountry68    7269
#define  idsCountry69    7270
#define  idsCountry70    7271
#define  idsCountry71    7272
#define  idsCountry72    7273
#define  idsCountry73    7274
#define  idsCountry74    7275
#define  idsCountry75    7276
#define  idsCountry76    7277
#define  idsCountry77    7278
#define  idsCountry78    7279
#define  idsCountry79    7280
#define  idsCountry80    7281
#define  idsCountry81    7282
#define  idsCountry82    7283
#define  idsCountry83    7284
#define  idsCountry84    7285
#define  idsCountry85    7286
#define  idsCountry86    7287
#define  idsCountry87    7288
#define  idsCountry88    7289
#define  idsCountry89    7290
#define  idsCountry90    7291
#define  idsCountry91    7292
#define  idsCountry92    7293
#define  idsCountry93    7294
#define  idsCountry94    7295
#define  idsCountry95    7296
#define  idsCountry96    7297
#define  idsCountry97    7298
#define  idsCountry98    7299
#define  idsCountry99    7300
#define  idsCountry100    7301
#define  idsCountry101    7302
#define  idsCountry102    7303
#define  idsCountry103    7304
#define  idsCountry104    7305
#define  idsCountry105    7306
#define  idsCountry106    7307
#define  idsCountry107    7308
#define  idsCountry108    7309
#define  idsCountry109    7310
#define  idsCountry110    7311
#define  idsCountry111    7312
#define  idsCountry112    7313
#define  idsCountry113    7314
#define  idsCountry114    7315
#define  idsCountry115    7316
#define  idsCountry116    7317
#define  idsCountry117    7318
#define  idsCountry118    7319
#define  idsCountry119    7320
#define  idsCountry120    7321
#define  idsCountry121    7322
#define  idsCountry122    7323
#define  idsCountry123    7324
#define  idsCountry124    7325
#define  idsCountry125    7326
#define  idsCountry126    7327
#define  idsCountry127    7328
#define  idsCountry128    7329
#define  idsCountry129    7330
#define  idsCountry130    7331
#define  idsCountry131    7332
#define  idsCountry132    7333
#define  idsCountry133    7334
#define  idsCountry134    7335
#define  idsCountry135    7336
#define  idsCountry136    7337
#define  idsCountry137    7338
#define  idsCountry138    7339
#define  idsCountry139    7340
#define  idsCountry140    7341
#define  idsCountry141    7342
#define  idsCountry142    7343
#define  idsCountry143    7344
#define  idsCountry144    7345
#define  idsCountry145    7346
#define  idsCountry146    7347
#define  idsCountry147    7348
#define  idsCountry148    7349
#define  idsCountry149    7350
#define  idsCountry150    7351
#define  idsCountry151    7352
#define  idsCountry152    7353
#define  idsCountry153    7354
#define  idsCountry154    7355
#define  idsCountry155    7356
#define  idsCountry156    7357
#define  idsCountry157    7358
#define  idsCountry158    7359
#define  idsCountry159    7360
#define  idsCountry160    7361
#define  idsCountry161    7362
#define  idsCountry162    7363
#define  idsCountry163    7364
#define  idsCountry164    7365
#define  idsCountry165    7366
#define  idsCountry166    7367
#define  idsCountry167    7368
#define  idsCountry168    7369
#define  idsCountry169    7370
#define  idsCountry170    7371
#define  idsCountry171    7372
#define  idsCountry172    7373
#define  idsCountry173    7374
#define  idsCountry174    7375
#define  idsCountry175    7376
#define  idsCountry176    7377
#define  idsCountry177    7378
#define  idsCountry178    7379
#define  idsCountry179    7380
#define  idsCountry180    7381
#define  idsCountry181    7382
#define  idsCountry182    7383
#define  idsCountry183    7384
#define  idsCountry184    7385
#define  idsCountry185    7386
#define  idsCountry186    7387
#define  idsCountry187    7388
#define  idsCountry188    7389
#define  idsCountry189    7390
#define  idsCountry190    7391
#define  idsCountry191    7392
#define  idsCountry192    7393
#define  idsCountry193    7394
#define  idsCountry194    7395
#define  idsCountry195    7396
#define  idsCountry196    7397
#define  idsCountry197    7398
#define  idsCountry198    7399
#define  idsCountry199    7400
#define  idsCountry200    7401
#define  idsCountry201    7402
#define  idsCountry202    7403
#define  idsCountry203    7404
#define  idsCountry204    7405
#define  idsCountry205    7406
#define  idsCountry206    7407
#define  idsCountry207    7408
#define  idsCountry208    7409
#define  idsCountry209    7410
#define  idsCountry210    7411
#define  idsCountry211    7412
#define  idsCountry212    7413
#define  idsCountry213    7414
#define  idsCountry214    7415
#define  idsCountry215    7416
#define  idsCountry216    7417
#define  idsCountry217    7418
#define  idsCountry218    7419
#define  idsCountry219    7420
#define  idsCountry220    7421
#define  idsCountry221    7422
#define  idsCountry222    7423
#define  idsCountry223    7424
#define  idsCountry224    7425
#define  idsCountry225    7426
#define  idsCountry226    7427
#define  idsCountry227    7428
#define  idsCountry228    7429
#define  idsCountry229    7430
#define  idsCountry230    7431
#define  idsCountry231    7432
#define  idsCountry232    7433
#define  idsCountry233    7434
#define  idsCountry234    7435
#define  idsCountry235    7436
#define  idsCountry236    7437
#define  idsCountry237    7438
#define  idsCountry238    7439
#define  idsCountry239    7440
#define  MAX_COUNTRY_NUM  239

#define ID_EXIT                         65535
#define COLSEL_MENU

#ifdef  COLSEL_MENU
// these are for the additional column selection 
#define MAX_VIEW_COLSEL                          64
#define IDR_MENU_LVCONTEXTMENU_COLSEL            8700
#define IDM_LVCONTEXTMENU_COLSEL_HPHONE          8701
#define IDM_LVCONTEXTMENU_COLSEL_BPHONE          8702
#define IDM_LVCONTEXTMENU_COLSEL_PAGER           8703
#define IDM_LVCONTEXTMENU_COLSEL_MOBILE          8704
#define IDM_LVCONTEXTMENU_COLSEL_BFAX            8705
#define IDM_LVCONTEXTMENU_COLSEL_HFAX            8706
#define IDM_LVCONTEXTMENU_COLSEL_COMPANY         8707
#define IDM_LVCONTEXTMENU_COLSEL_TITLE           8708
#define IDM_LVCONTEXTMENU_COLSEL_DEPT            8709
#define IDM_LVCONTEXTMENU_COLSEL_OFFICE          8710
#define IDM_LVCONTEXTMENU_COLSEL_BIRTHDAY        8711
#define IDM_LVCONTEXTMENU_COLSEL_ANNIVERSARY     8712

#endif // COLSEL_MENU
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\wchar.h ===
#ifndef __WCHAR_H__
#define __WCHAR_H__

typedef unsigned short wchar_t;

extern wchar_t* wcscpy(wchar_t* dst, const wchar_t* src);
extern wchar_t* wcscat(wchar_t* dst, const wchar_t* src);
extern int wcscmp(const wchar_t* s1, const wchar_t* s2);
extern int wcslen(const wchar_t* str);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcviewer.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// VCViewer.h : header file
//



/////////////////////////////////////////////////////////////////////////////
// VCViewer command target

class VCViewer : public CCmdTarget
{
	DECLARE_DYNCREATE(VCViewer)

	VCViewer();           // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(VCViewer)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~VCViewer();

	// Generated message map functions
	//{{AFX_MSG(VCViewer)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_OLECREATE(VCViewer)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(VCViewer)
	afx_msg long ReceiveCard(LPCTSTR nativePath);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\abcont.c ===
/*
 *	ABCONT.C
 *
 *	Generic IMAPIContainer implementation.
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 */

#include "_apipch.h"

#ifdef WIN16
#undef GetLastError
#endif

static HRESULT
HrGetFirstRowInTad(LPTABLEDATA lpTableData,
  LPTABLEINFO lpTableInfo,
  ULONG ulcTableInfo,
  ULONG uliTable,
  ULONG * puliRow);

static HRESULT
HrGetLastRowInTad(LPTABLEDATA lpTableData,
  LPTABLEINFO lpTableInfo,
  ULONG ulcTableInfo,
  ULONG uliTable,
  ULONG * puliRow);

OlkContInfo *FindContainer(LPIAB lpIAB, ULONG cbEntryID, LPENTRYID lpEID);

NOTIFCALLBACK lHierarchyNotifCallBack;

extern CONTAINER_Vtbl vtblROOT;
extern CONTAINER_Vtbl vtblLDAPCONT;

extern HRESULT HrSmartResolve(LPIAB lpIAB, LPABCONT lpContainer, ULONG ulFlags,
  LPADRLIST lpAdrList, LPFlagList lpFlagList, LPAMBIGUOUS_TABLES lpAmbiguousTables);

//   extern CONTAINER_Vtbl vtblDISTLIST;

CONTAINER_Vtbl vtblCONTAINER = {
    VTABLE_FILL
//    (CONTAINER_QueryInterface_METHOD *)     IAB_QueryInterface, //bug 2707:this crashes
    CONTAINER_QueryInterface,
    (CONTAINER_AddRef_METHOD *)             WRAP_AddRef,
    CONTAINER_Release,
    (CONTAINER_GetLastError_METHOD *)       IAB_GetLastError,
    (CONTAINER_SaveChanges_METHOD *)        WRAP_SaveChanges,
    (CONTAINER_GetProps_METHOD *)           WRAP_GetProps,
    (CONTAINER_GetPropList_METHOD *)        WRAP_GetPropList,
    CONTAINER_OpenProperty,
    (CONTAINER_SetProps_METHOD *)           WRAP_SetProps,
    (CONTAINER_DeleteProps_METHOD *)        WRAP_DeleteProps,
    (CONTAINER_CopyTo_METHOD *)             WRAP_CopyTo,
    (CONTAINER_CopyProps_METHOD *)          WRAP_CopyProps,
    (CONTAINER_GetNamesFromIDs_METHOD *)    WRAP_GetNamesFromIDs,
    CONTAINER_GetIDsFromNames,    
    CONTAINER_GetContentsTable,
    CONTAINER_GetHierarchyTable,
    CONTAINER_OpenEntry,
    CONTAINER_SetSearchCriteria,
    CONTAINER_GetSearchCriteria,
    CONTAINER_CreateEntry,
    CONTAINER_CopyEntries,
    CONTAINER_DeleteEntries,
    CONTAINER_ResolveNames
};

//
//  Interfaces supported by this object
//
#define CONTAINER_cInterfaces 3
LPIID CONTAINER_LPIID[CONTAINER_cInterfaces] =
{
    (LPIID) &IID_IABContainer,
    (LPIID) &IID_IMAPIContainer,
    (LPIID) &IID_IMAPIProp
};

#define DISTLIST_cInterfaces 4
LPIID DISTLIST_LPIID[DISTLIST_cInterfaces] =
{
    (LPIID) &IID_IDistList,
    (LPIID) &IID_IABContainer,
    (LPIID) &IID_IMAPIContainer,
    (LPIID) &IID_IMAPIProp
};



SizedSSortOrderSet(1, sosPR_ENTRYID) =
{
	1, 0, 0,
	{
		PR_ENTRYID
	}
};

SizedSSortOrderSet(1, sosPR_ROWID) =
{
	1, 0, 0,
	{
		PR_ROWID
	}
};

SizedSPropTagArray(2, tagaInsKey) =
{
	2,
	{
		PR_INSTANCE_KEY,
		PR_NULL				// Space for PR_ROWID
	}
};


//
// container default properties
// Put essential props first
//
enum {
    icdPR_DISPLAY_NAME,
    icdPR_OBJECT_TYPE,
    icdPR_CONTAINER_FLAGS,
    icdPR_DISPLAY_TYPE,
    icdPR_ENTRYID,              // optional
    icdPR_DEF_CREATE_MAILUSER,  // optional
    icdPR_DEF_CREATE_DL,        // optional
    icdMax
};



/***************************************************************************

    Name      : HrSetCONTAINERAccess

    Purpose   : Sets access flags on a container object

    Parameters: lpCONTAINER -> Container object
                ulOpenFlags = MAPI flags: MAPI_MODIFY | MAPI_BEST_ACCESS

    Returns   : HRESULT

    Comment   : Set the access flags on the container.

***************************************************************************/
HRESULT HrSetCONTAINERAccess(LPCONTAINER lpCONTAINER, ULONG ulFlags) {
    ULONG ulAccess = IPROP_READONLY;

    switch (ulFlags& (MAPI_MODIFY | MAPI_BEST_ACCESS)) {
        case MAPI_MODIFY:
        case MAPI_BEST_ACCESS:
            ulAccess = IPROP_READWRITE;
            break;

        case 0:
            break;

        default:
            Assert(FALSE);
    }

    return(lpCONTAINER->lpPropData->lpVtbl->HrSetObjAccess(lpCONTAINER->lpPropData, ulAccess));
}


/***************************************************************************

    Name      : HrNewCONTAINER

    Purpose   : Creates a container object

    Parameters: lpIAB -> addrbook object
                ulType = {AB_ROOT, AB_WELL, AB_DL, AB_CONTAINER}
                lpInterface -> requested interface
                ulOpenFlags = flags
                cbEID = size of lpEID
                lpEID -> optional entryid of this object
                lpulObjType -> returned object type
                lppContainer -> returned IABContainer object

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT HrNewCONTAINER(LPIAB lpIAB,
  ULONG ulType,
  LPCIID lpInterface,
  ULONG  ulOpenFlags,
  ULONG cbEID,
  LPENTRYID lpEID,
  ULONG  *lpulObjType,
  LPVOID *lppContainer)
{
    HRESULT hResult = hrSuccess;
    LPCONTAINER lpCONTAINER = NULL;
    SCODE sc;
    LPSPropValue lpProps = NULL;
    LPPROPDATA lpPropData = NULL;
    ULONG ulObjectType;
    BYTE bEntryIDType;
    ULONG cProps;
    TCHAR szDisplayName[MAX_PATH] = TEXT("");
    LPTSTR lpDisplayName = szDisplayName;
    BOOL fLoadedLDAP = FALSE;
	OlkContInfo *polkci;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    EnterCriticalSection(&lpIAB->cs);

    if (lpInterface != NULL) {
        if (memcmp(lpInterface, &IID_IABContainer, sizeof(IID)) &&
          memcmp(lpInterface, &IID_IDistList, sizeof(IID)) &&
          memcmp(lpInterface, &IID_IMAPIContainer, sizeof(IID)) &&
          memcmp(lpInterface, &IID_IMAPIProp, sizeof(IID))) {
            hResult = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);

            goto exit;
        }
    }

    //
    //  Allocate space for the CONTAINER structure
    //
    if ((sc = MAPIAllocateBuffer(sizeof(CONTAINER), (LPVOID *)&lpCONTAINER))
      != SUCCESS_SUCCESS) {
        return(ResultFromScode(sc));
    }

    // [PaulHi] 12/16/98
    // We don't set all structure variables so zero out first!
    ZeroMemory(lpCONTAINER, sizeof(CONTAINER));

	lpCONTAINER->pmbinOlk = NULL;

    switch (ulType) {
        case AB_ROOT:   // Root container object
            ulObjectType = MAPI_ABCONT;
            lpCONTAINER->lpVtbl = &vtblROOT;
            lpCONTAINER->cIID = CONTAINER_cInterfaces;
            lpCONTAINER->rglpIID = CONTAINER_LPIID;
            bEntryIDType = WAB_ROOT;
#ifdef NEW_STUFF
            if (! LoadString(hinstMapiX, idsRootName, szDisplayName, CharSizeOf(szDisplayName))) {
                DebugTrace(TEXT("Can't load root name from resource\n"));
            }
#else
            lstrcpy(szDisplayName, TEXT("WAB Root Container"));
#endif
            MAPISetBufferName(lpCONTAINER, TEXT("AB Root Container Object"));
            break;

        case AB_WELL:
            // What the heck is this supposed to be?
            Assert(FALSE);
            hResult = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
            goto exit;
            break;

        case AB_DL: // Distribution List container
            ulObjectType = MAPI_DISTLIST;
            lpCONTAINER->lpVtbl = &vtblDISTLIST;
            lpCONTAINER->cIID = DISTLIST_cInterfaces;
            lpCONTAINER->rglpIID = DISTLIST_LPIID;
            bEntryIDType = WAB_DISTLIST;
            MAPISetBufferName(lpCONTAINER,  TEXT("AB DISTLIST Container Object"));
            break;

        case AB_PAB:    // "Default" PAB Container
            ulObjectType = MAPI_ABCONT;
            lpCONTAINER->lpVtbl = &vtblCONTAINER;
            lpCONTAINER->cIID = CONTAINER_cInterfaces;
            lpCONTAINER->rglpIID = CONTAINER_LPIID;
            bEntryIDType = WAB_PAB;
		    if (pt_bIsWABOpenExSession) {
                // if this is an Outlook Session, then the container is the
                // first one in the list of Outlook containers
				Assert(lpIAB->lpPropertyStore->rgolkci);
				lpDisplayName = lpIAB->lpPropertyStore->rgolkci->lpszName;
			}
            else if(WAB_PABSHARED == IsWABEntryID(cbEID, lpEID, NULL, NULL, NULL, NULL, NULL))
            {
                // WAB's "shared contacts" container
				if(FAILED(hResult = MAPIAllocateMore( sizeof(SBinary) + cbEID, lpCONTAINER, (LPVOID *)&lpCONTAINER->pmbinOlk)))
					goto exit;
                // The shared contacts container has a special entryid of 0 bytes
                // and NULL entryid to distinguish it from other entryids
                lpCONTAINER->pmbinOlk->cb = 0;
                lpCONTAINER->pmbinOlk->lpb = NULL;
                LoadString(hinstMapiX, idsSharedContacts, szDisplayName, CharSizeOf(szDisplayName));
            }
            else if(bAreWABAPIProfileAware(lpIAB) && bIsThereACurrentUser(lpIAB))
            {
                // if calling client asked for profile support and logging into the
                // identity manager was successful and returned a valid profile, then
                // we need to return the user's default folder as the PAB
                //
				if(FAILED(hResult = MAPIAllocateMore( sizeof(SBinary) + cbEID, lpCONTAINER, (LPVOID *)&lpCONTAINER->pmbinOlk)))
					goto exit;
                lpDisplayName = lpIAB->lpWABCurrentUserFolder->lpFolderName;
				lpCONTAINER->pmbinOlk->cb = lpIAB->lpWABCurrentUserFolder->sbEID.cb;//cbEID;
				lpCONTAINER->pmbinOlk->lpb = (LPBYTE)(lpCONTAINER->pmbinOlk + 1);
				CopyMemory(lpCONTAINER->pmbinOlk->lpb, lpIAB->lpWABCurrentUserFolder->sbEID.lpb, lpCONTAINER->pmbinOlk->cb);//lpEID, cbEID);
            }
            else // old style "Contacts" container 
            if (! LoadString(hinstMapiX, idsContacts, szDisplayName, CharSizeOf(szDisplayName))) {
                DebugTrace(TEXT("Can't load pab name from resource\n"));
            }
            MAPISetBufferName(lpCONTAINER,  TEXT("AB PAB Container Object"));
            break;

        case AB_CONTAINER: // regular container/folder - we have an identifying entryid
            ulObjectType = MAPI_ABCONT;
            lpCONTAINER->lpVtbl = &vtblCONTAINER;
            lpCONTAINER->cIID = CONTAINER_cInterfaces;
            lpCONTAINER->rglpIID = CONTAINER_LPIID;
            bEntryIDType = WAB_CONTAINER;
		    if (pt_bIsWABOpenExSession || bIsWABSessionProfileAware(lpIAB)) 
            {
                // If this is an outlook session or if this is an identity-aware
                // session, look for the specified container and use it
				polkci = FindContainer(lpIAB, cbEID, lpEID);
				if (!polkci) 
                {
					hResult = ResultFromScode(MAPI_E_NOT_FOUND);
					goto exit;
				}
				lpDisplayName = polkci->lpszName;
				hResult = MAPIAllocateMore( sizeof(SBinary) + cbEID, lpCONTAINER,
				                    		(LPVOID *)&lpCONTAINER->pmbinOlk);
				if (FAILED(hResult))
					goto exit;
				lpCONTAINER->pmbinOlk->cb = cbEID;
				lpCONTAINER->pmbinOlk->lpb = (LPBYTE)(lpCONTAINER->pmbinOlk + 1);
				CopyMemory(lpCONTAINER->pmbinOlk->lpb, lpEID, cbEID);
			}
            MAPISetBufferName(lpCONTAINER,  TEXT("AB Container Object"));
            break;

        case AB_LDAP_CONTAINER: // LDAP container
            ulObjectType = MAPI_ABCONT;
            lpCONTAINER->lpVtbl = &vtblLDAPCONT;
            lpCONTAINER->cIID = CONTAINER_cInterfaces;
            lpCONTAINER->rglpIID = CONTAINER_LPIID;
            bEntryIDType = WAB_LDAP_CONTAINER;
            // Extract the server name from the LDAP entryid
            IsWABEntryID(cbEID, lpEID,&lpDisplayName,
                        NULL,NULL, NULL, NULL);
            fLoadedLDAP = InitLDAPClientLib();
            MAPISetBufferName(lpCONTAINER,  TEXT("AB LDAP Container Object"));
            break;

        default: // shouldnt' hit this one.
            MAPISetBufferName(lpCONTAINER,  TEXT("AB Container Object"));
            Assert(FALSE);
    }

    lpCONTAINER->lcInit = 1;
    lpCONTAINER->hLastError = hrSuccess;
    lpCONTAINER->idsLastError = 0;
    lpCONTAINER->lpszComponent = NULL;
    lpCONTAINER->ulContext = 0;
    lpCONTAINER->ulLowLevelError = 0;
    lpCONTAINER->ulErrorFlags = 0;
    lpCONTAINER->lpMAPIError = NULL;

    lpCONTAINER->ulType = ulType;
    lpCONTAINER->lpIAB = lpIAB;
    lpCONTAINER->fLoadedLDAP = fLoadedLDAP;

    // Addref our parent IAB object
    UlAddRef(lpIAB);

    //
    //  Create IPropData
    //
    if (FAILED(sc = CreateIProp(&IID_IMAPIPropData,
      (ALLOCATEBUFFER FAR *	) MAPIAllocateBuffer,
      (ALLOCATEMORE FAR *)	MAPIAllocateMore,
      MAPIFreeBuffer,
      NULL,
      &lpPropData))) {
        hResult = ResultFromScode(sc);

        goto exit;
    }

    MAPISetBufferName(lpPropData,  TEXT("lpPropData in HrNewCONTAINER"));

    if (sc = MAPIAllocateBuffer(icdMax * sizeof(SPropValue), &lpProps)) {
        hResult = ResultFromScode(sc);
    }

    // Set the basic set of properties on this container object such as 
    // display-name etc

    lpProps[icdPR_OBJECT_TYPE].ulPropTag = PR_OBJECT_TYPE;
    lpProps[icdPR_OBJECT_TYPE].Value.l = ulObjectType;

    lpProps[icdPR_DISPLAY_NAME].ulPropTag = PR_DISPLAY_NAME;
    lpProps[icdPR_DISPLAY_NAME].Value.LPSZ = lpDisplayName;


    lpProps[icdPR_CONTAINER_FLAGS].ulPropTag = PR_CONTAINER_FLAGS;
    lpProps[icdPR_CONTAINER_FLAGS].Value.l = (ulType == AB_ROOT) ? AB_UNMODIFIABLE : AB_MODIFIABLE;

    lpProps[icdPR_DISPLAY_TYPE].ulPropTag = PR_DISPLAY_TYPE;
    lpProps[icdPR_DISPLAY_TYPE].Value.l = DT_LOCAL;

    cProps = 4;

    // in addition to the above properties, add some additional ones depending
    // on what type of container this is...

    switch (ulType) {
        case AB_PAB:
            lpProps[icdPR_ENTRYID].ulPropTag = PR_ENTRYID;
            if(lpCONTAINER->pmbinOlk)
            {
                // if we have an entryid for the container, just reuse it
			    lpProps[icdPR_ENTRYID].Value.bin.cb = lpCONTAINER->pmbinOlk->cb; //cbEID;
			    lpProps[icdPR_ENTRYID].Value.bin.lpb = lpCONTAINER->pmbinOlk->lpb;//(LPBYTE)lpEID;
            }
            else // create a wab entryid that we can hand about
            if (HR_FAILED(hResult = CreateWABEntryID(bEntryIDType,
                                                NULL, NULL, NULL,0, 0,
                                                (LPVOID) lpProps,
                                                (LPULONG) (&lpProps[icdPR_ENTRYID].Value.bin.cb),
                                                (LPENTRYID *)&lpProps[icdPR_ENTRYID].Value.bin.lpb))) 
            {
                goto exit;
            }
            cProps++;

            // Add the default template IDs used for creating new users
            lpProps[icdPR_DEF_CREATE_MAILUSER].ulPropTag = PR_DEF_CREATE_MAILUSER;
            if (HR_FAILED(hResult = CreateWABEntryID(WAB_DEF_MAILUSER,
              NULL, NULL, NULL,
              0, 0,
              (LPVOID) lpProps,                 // lpRoot
              (LPULONG) (&lpProps[icdPR_DEF_CREATE_MAILUSER].Value.bin.cb),
              (LPENTRYID *)&lpProps[icdPR_DEF_CREATE_MAILUSER].Value.bin.lpb))) {
                goto exit;
            }
            cProps++;

            lpProps[icdPR_DEF_CREATE_DL].ulPropTag = PR_DEF_CREATE_DL;
            if (HR_FAILED(hResult = CreateWABEntryID(WAB_DEF_DL,
              NULL, NULL, NULL,
              0, 0,
              (LPVOID) lpProps,                 // lpRoot
              (LPULONG) (&lpProps[icdPR_DEF_CREATE_DL].Value.bin.cb),
              (LPENTRYID *)&lpProps[icdPR_DEF_CREATE_DL].Value.bin.lpb))) {
                goto exit;
            }
            cProps++;
            break;

        case AB_CONTAINER:
            lpProps[icdPR_ENTRYID].ulPropTag = PR_ENTRYID;
			lpProps[icdPR_ENTRYID].Value.bin.cb = cbEID;
			lpProps[icdPR_ENTRYID].Value.bin.lpb = (LPBYTE)lpEID;
            cProps++;

            lpProps[icdPR_DEF_CREATE_MAILUSER].ulPropTag = PR_DEF_CREATE_MAILUSER;
            if (HR_FAILED(hResult = CreateWABEntryID(WAB_DEF_MAILUSER,
              NULL, NULL, NULL,
              0, 0,
              (LPVOID) lpProps,                 // lpRoot
              (LPULONG) (&lpProps[icdPR_DEF_CREATE_MAILUSER].Value.bin.cb),
              (LPENTRYID *)&lpProps[icdPR_DEF_CREATE_MAILUSER].Value.bin.lpb))) {
                goto exit;
            }
            cProps++;

            lpProps[icdPR_DEF_CREATE_DL].ulPropTag = PR_DEF_CREATE_DL;
            if (HR_FAILED(hResult = CreateWABEntryID(WAB_DEF_DL,
              NULL, NULL, NULL,
              0, 0,
              (LPVOID) lpProps,                 // lpRoot
              (LPULONG) (&lpProps[icdPR_DEF_CREATE_DL].Value.bin.cb),
              (LPENTRYID *)&lpProps[icdPR_DEF_CREATE_DL].Value.bin.lpb))) {
                goto exit;
            }
            cProps++;
            break;

        case AB_ROOT:
            lpProps[icdPR_ENTRYID].ulPropTag = PR_ENTRYID;
            lpProps[icdPR_ENTRYID].Value.bin.cb = 0;
            lpProps[icdPR_ENTRYID].Value.bin.lpb = NULL;
            cProps++;

            lpProps[icdPR_DEF_CREATE_MAILUSER].ulPropTag = PR_DEF_CREATE_MAILUSER;
            if (HR_FAILED(hResult = CreateWABEntryID(WAB_DEF_MAILUSER,
              NULL, NULL, NULL,
              0, 0,
              (LPVOID) lpProps,                 // lpRoot
              (LPULONG) (&lpProps[icdPR_DEF_CREATE_MAILUSER].Value.bin.cb),
              (LPENTRYID *)&lpProps[icdPR_DEF_CREATE_MAILUSER].Value.bin.lpb))) {
                goto exit;
            }
            cProps++;

            lpProps[icdPR_DEF_CREATE_DL].ulPropTag = PR_DEF_CREATE_DL;
            if (HR_FAILED(hResult = CreateWABEntryID(WAB_DEF_DL,
              NULL, NULL, NULL,
              0, 0,
              (LPVOID) lpProps,                 // lpRoot
              (LPULONG) (&lpProps[icdPR_DEF_CREATE_DL].Value.bin.cb),
              (LPENTRYID *)&lpProps[icdPR_DEF_CREATE_DL].Value.bin.lpb))) {
                goto exit;
            }
            cProps++;
            break;

        case AB_LDAP_CONTAINER:
            lpProps[icdPR_ENTRYID].ulPropTag = PR_ENTRYID;
            lpProps[icdPR_ENTRYID].Value.bin.cb = cbEID;
            lpProps[icdPR_ENTRYID].Value.bin.lpb = (LPBYTE)lpEID;

            cProps++;

            // Hack!  Don't need PR_DEF_CREATE_* so use those slots for
            // PR_WAB_LDAP_SERVER.
            lpProps[icdPR_DEF_CREATE_MAILUSER].ulPropTag = PR_WAB_LDAP_SERVER;
            lpProps[icdPR_DEF_CREATE_MAILUSER].Value.LPSZ = lpDisplayName;

            cProps++;
            break;
    }

    //
    //  Set the default properties
    //
    if (HR_FAILED(hResult = lpPropData->lpVtbl->SetProps(lpPropData,
      cProps,
      lpProps,
      NULL))) {
        LPMAPIERROR lpMAPIError = NULL;

        lpPropData->lpVtbl->GetLastError(lpPropData,
          hResult,
          0, 			// Ansi only
          &lpMAPIError);

        goto exit;
    }

    // default object access is ReadOnly (means the container object can't
    // be modified but it's data can be modified)
    lpPropData->lpVtbl->HrSetObjAccess(lpPropData, IPROP_READONLY);

    lpCONTAINER->lpPropData = lpPropData;

    // All we want to do is initialize the Root container's critical section

    InitializeCriticalSection(&lpCONTAINER->cs);

    *lpulObjType = ulObjectType;
    *lppContainer = (LPVOID)lpCONTAINER;

exit:
    FreeBufferAndNull(&lpProps);

    if (HR_FAILED(hResult)) {
        if (fLoadedLDAP) {
            DeinitLDAPClientLib();
        }
        FreeBufferAndNull(&lpCONTAINER);
        UlRelease(lpPropData);
    }

    LeaveCriticalSection(&lpIAB->cs);

    return(hResult);
}


/***************************************************
 *
 *  ABContainer methods
 */

/*
 * IUnknown
 */

/***************************************************************************

    Name      : CONTAINER::QueryInterface

    Purpose   : Calls the IAB_QueryInterface correctly

    Parameters: 

    Returns   : 


***************************************************************************/
STDMETHODIMP
CONTAINER_QueryInterface(LPCONTAINER lpContainer,
  REFIID lpiid,
  LPVOID * lppNewObj)
{

    // Check to see if it has a jump table
    if (IsBadReadPtr(lpContainer, sizeof(LPVOID))) {
        // No jump table found
        return(ResultFromScode(E_INVALIDARG));
    }

    // Check to see if the jump table has at least sizeof IUnknown
    if (IsBadReadPtr(lpContainer->lpVtbl, 3*sizeof(LPVOID))) {
        // Jump table not derived from IUnknown
        return(ResultFromScode(E_INVALIDARG));
    }

    // Check to see that it's IAB_QueryInterface
    if (lpContainer->lpVtbl->QueryInterface != CONTAINER_QueryInterface) {
        // Not my jump table
        return(ResultFromScode(E_INVALIDARG));
    }

    // default to the IAB QueryInterface method
    return lpContainer->lpIAB->lpVtbl->QueryInterface(lpContainer->lpIAB, lpiid, lppNewObj);
}

/***************************************************************************

    Name      : CONTAINER::Release

    Purpose   : Releases the container object

    Parameters: lpCONTAINER -> Container object

    Returns   : current reference count

    Comment   : Decrememnt lpInit
                When lcInit == 0, release the parent objects and
                free up the lpCONTAINER structure

***************************************************************************/
STDMETHODIMP_(ULONG)
CONTAINER_Release(LPCONTAINER lpCONTAINER) {
#ifdef PARAMETER_VALIDATION
    // Check to see if it has a jump table
    if (IsBadReadPtr(lpCONTAINER, sizeof(LPVOID))) {
        // No jump table found
        return(1);
    }
#endif	// PARAMETER_VALIDATION

    EnterCriticalSection(&lpCONTAINER->cs);

    --lpCONTAINER->lcInit;

    if (lpCONTAINER->lcInit == 0) {
        // Remove this object from the objects currently on this session.
        // Not yet implemented...

        // Remove the associated lpPropData
        UlRelease(lpCONTAINER->lpPropData);

        // Set the Jump table to NULL.  This way the client will find out
        // real fast if it's calling a method on a released object.  That is,
        // the client will crash.  Hopefully, this will happen during the
        // development stage of the client.
        lpCONTAINER->lpVtbl = NULL;

        // Free error string if allocated from MAPI memory.
        FreeBufferAndNull(&(lpCONTAINER->lpMAPIError));

        // Release the IAB since we addref'd it in root object creation.
        UlRelease(lpCONTAINER->lpIAB);

        if (lpCONTAINER->fLoadedLDAP) {
            DeinitLDAPClientLib();
        }

        LeaveCriticalSection(&lpCONTAINER->cs);
        DeleteCriticalSection(&lpCONTAINER->cs);
        // Need to free the object

        FreeBufferAndNull(&lpCONTAINER);
        return(0);
    }

    LeaveCriticalSection(&lpCONTAINER->cs);
    return(lpCONTAINER->lcInit);
}


/*
 * IMAPIProp
 */

/***************************************************************************

    Name      : CONTAINER::OpenProperty

    Purpose   : Opens an object interface on a particular property

    Parameters: lpCONTAINER -> Container object
                ulPropTag = property to open
                lpiid -> requested interface
                ulInterfaceOptions =
                ulFlags =
                lppUnk -> returned object

    Returns   : HRESULT

    Comment   :

***************************************************************************/
STDMETHODIMP
CONTAINER_OpenProperty(LPCONTAINER lpCONTAINER,
  ULONG ulPropTag,
  LPCIID lpiid,
  ULONG ulInterfaceOptions,
  ULONG ulFlags,
  LPUNKNOWN * lppUnk)
{
	LPIAB lpIAB;
	LPSTR lpszMessage = NULL;
	ULONG ulLowLevelError = 0;
	HRESULT hr;

#ifdef	PARAMETER_VALIDATION
	 // Validate parameters

	 // Check to see if it has a jump table
	if (IsBadReadPtr(lpCONTAINER, sizeof(LPVOID))) {
		// No jump table found
		hr = ResultFromScode(MAPI_E_INVALID_PARAMETER);
		return(hr);
	}


    if ((ulInterfaceOptions & ~(MAPI_UNICODE)) || (ulFlags & ~(MAPI_DEFERRED_ERRORS))) {
        return(hr = ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (FBadOpenProperty(lpCONTAINER, ulPropTag, lpiid, ulInterfaceOptions, ulFlags,
      lppUnk)) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }


#endif	// PARAMETER_VALIDATION

#ifdef IABCONTAINER_OPENPROPERTY_SUPPORT // ??Were we supporting this? - vm 3/25/97??

    EnterCriticalSection(&lpCONTAINER->cs);


    lpIAB = lpCONTAINER->lpIAB;

    //
    //  Check to see if I need a display table
    //
    if (ulPropTag == PR_CREATE_TEMPLATES) {
        //
        //  Looking for the display table
        //

        //
        //  Check to see if they're expecting a table interface
        //
        if (memcmp(lpiid, &IID_IMAPITable, sizeof(IID))) {
            hr = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
            goto err;
        }

        //  Check to see if we already have a table
        EnterCriticalSection(&lpIAB->cs);

        //
        //  Get a view from the TAD
        //
        hr = lpIAB->lpOOData->lpVtbl->HrGetView(
          lpIAB->lpOOData,
          (LPSSortOrderSet)&sosPR_ROWID,
          NULL,
          0,
          (LPMAPITABLE *)lppUnk);

        //	 Leave the critical section after we get our view.
        LeaveCriticalSection(&lpIAB->cs);

#ifdef DEBUG
        if (hr == hrSuccess) {
            MAPISetBufferName(*lppUnk,  TEXT("OneOff Data VUE1 Object"));
        }
#endif

        goto err;  // Maybe error, maybe not...
    } else if (ulPropTag == PR_CONTAINER_CONTENTS) {
        //
        //  Check to see if they're expecting a table interface
        //
        if (memcmp(lpiid, &IID_IMAPITable, sizeof(IID))) {
            hr = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
            goto err;
        }

        hr = lpCONTAINER->lpVtbl->GetContentsTable(lpCONTAINER,
          ulInterfaceOptions,
          (LPMAPITABLE *)lppUnk);
        goto err;

    } else if (ulPropTag == PR_CONTAINER_HIERARCHY) {
        //
        //  Check to see if they're expecting a table interface
        //
        if (memcmp(lpiid, &IID_IMAPITable, sizeof(IID))) {
            hr = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
            goto err;
        }

        hr = lpCONTAINER->lpVtbl->GetHierarchyTable(lpCONTAINER,
          ulInterfaceOptions,
          (LPMAPITABLE *)lppUnk);
        goto err;
    }


    //
    //  Don't recognize the property they want opened.
    //

    hr = ResultFromScode(MAPI_E_NO_SUPPORT);

err:
    LeaveCriticalSection(&lpCONTAINER->cs);

#else // IABCONTAINER_OPENPROPERTY_SUPPORT

    hr = ResultFromScode(MAPI_E_NO_SUPPORT);

#endif // IABCONTAINER_OPENPROPERTY_SUPPORT

    DebugTraceResult(CONTAINER_OpenProperty, hr);
    return(hr);
}

/***************************************************************************

    Name      : CONTAINER_GetGetIDsFromNames

    Returns   : HRESULT

    Comment   : Just default this to the standard GetIdsFromNames
                that we use everywhere

***************************************************************************/
STDMETHODIMP
CONTAINER_GetIDsFromNames(LPCONTAINER lpRoot,  ULONG cPropNames,
                            LPMAPINAMEID * lppPropNames, ULONG ulFlags, LPSPropTagArray * lppPropTags)
{
    return HrGetIDsFromNames(lpRoot->lpIAB,  
                            cPropNames,
                            lppPropNames, ulFlags, lppPropTags);
}


/*
-
-   HrDupeOutlookContentsTable
*
*   Since Outlook is unable to provide a Unicode contents table and we can't fo into the
*   outlook contents table to modify it's data, we have to recreate the contentstable to
*   create a WAB version of it ..
*   This is likely to be a big performance issue .. :-(
*
*/
HRESULT HrDupeOutlookContentsTable(LPMAPITABLE lpOlkTable, LPMAPITABLE * lppTable)
{
    HRESULT hr = S_OK;
    ULONG ulCount = 0, iRow = 0;
    DWORD dwIndex = 0;
    LPSRowSet lpsRow = 0, lpSRowSet = NULL;
    ULONG ulCurrentRow = (ULONG)-1;
    ULONG ulNum, ulDen, lRowsSeeked;
    LPTABLEDATA lpTableData = NULL;
    SCODE sc = 0;
    // Create a table object
    if (FAILED(sc = CreateTable(  NULL,                                 // LPCIID
                                  (ALLOCATEBUFFER FAR *) MAPIAllocateBuffer,
                                  (ALLOCATEMORE FAR *)  MAPIAllocateMore,
                                  MAPIFreeBuffer,
                                  NULL,                                 // lpvReserved,
                                  TBLTYPE_DYNAMIC,                      // ulTableType,
                                  PR_ENTRYID,                        // ulPropTagIndexCol,
                                  (LPSPropTagArray)&ITableColumnsRoot,  // LPSPropTagArray lpptaCols,
                                  &lpTableData))) 
    {                     
        DebugTrace(TEXT("CreateTable failed %x\n"), sc);
        hr = ResultFromScode(sc);
        goto out;
    }
    Assert(lpTableData);

    ((TAD *)lpTableData)->bMAPIUnicodeTable = TRUE; //this is only called for retreiving unicode tables so the flag is true

    // How big is the outlook table?
    if(HR_FAILED(hr = lpOlkTable->lpVtbl->GetRowCount(lpOlkTable, 0, &ulCount)))
        goto out;

    DebugTrace( TEXT("Table contains %u rows\n"), ulCount);

    // Allocate the SRowSet
    if (FAILED(sc = MAPIAllocateBuffer(sizeof(SRowSet) + ulCount * sizeof(SRow),&lpSRowSet))) 
    {
        DebugTrace(TEXT("Allocation of SRowSet -> %x\n"), sc);
        hr = ResultFromScode(sc);
        goto out;
    }

	MAPISetBufferName(lpSRowSet, TEXT("Outlook_ContentsTable_Copy SRowSet"));
	ZeroMemory( lpSRowSet, (UINT) (sizeof(SRowSet) + ulCount * sizeof(SRow)));

    lpSRowSet->cRows = ulCount;
    iRow = 0;

    // Copy UNICODE versions of all the properties from the Outlook table
    for (dwIndex = 0; dwIndex < ulCount; dwIndex++) 
    {
        // Get the next row
        if(HR_FAILED(hr = lpOlkTable->lpVtbl->QueryRows(lpOlkTable, 1, 0, &lpsRow)))
            goto out;

        if (lpsRow) 
        {
            LPSPropValue lpSPVNew = NULL;

            Assert(lpsRow->cRows == 1); // should have exactly one row

            ///****INVESTIGATE if we can reuse this prop array without duplicating***/
            if(HR_FAILED(hr = HrDupeOlkPropsAtoWC(lpsRow->aRow[0].cValues, lpsRow->aRow[0].lpProps,  &lpSPVNew)))
                goto out;

            // Attach the props to the SRowSet
            lpSRowSet->aRow[iRow].lpProps = lpSPVNew;
            lpSRowSet->aRow[iRow].cValues = lpsRow->aRow[0].cValues;
            lpSRowSet->aRow[iRow].ulAdrEntryPad = 0;

            FreeProws(lpsRow);

            iRow++;
        }
    }

    // Add all this data we just created to the the Table.
    if (hr = lpTableData->lpVtbl->HrModifyRows(lpTableData, 0,  lpSRowSet)) 
    {
        DebugTraceResult( TEXT("ROOT_GetContentsTable:HrModifyRows"), hr);
        goto out;
    }

    hr = lpTableData->lpVtbl->HrGetView(lpTableData, NULL, ContentsViewGone, 0, lppTable);

out:

    FreeProws(lpSRowSet);

    // Cleanup table if failure
    if (HR_FAILED(hr)) 
    {
        if (lpTableData) 
        {
            UlRelease(lpTableData);
        }
    }
    return hr;
}




/***************************************************************************

    Name      : CONTAINER::GetContentsTable

    Purpose   : Opens a table of the contents of the container.

    Parameters: lpCONTAINER -> Container object

                ulFlags =   
                WAB_PROFILE_CONTENTS - When caller opens the PAB container and want's to
                    get the complete set of contents for the current identity 
                    without wanting to enumerate each sub-container seperately
                    - they can specify this flag and we'll return everything 
                    corresponding to the current identity all in the same table
                WAB_CONTENTTABLE_NODATA - Internal only flag .. GetContentsTable normally
                    loads a full contents table and if this is followed by SetColumns,
                    SetColumns also loads a full contents table .. so we basically
                    do the same work twice - to reduce this wasted work, caller can
                    specify not to load data the first time but caller must call
                    SetColumns immediately (or this will probably fault)
                                     
                lppTable -> returned table object

    Returns   : HRESULT

    Comment   :

***************************************************************************/
STDMETHODIMP
CONTAINER_GetContentsTable (LPCONTAINER lpCONTAINER,
	ULONG ulFlags,
	LPMAPITABLE * lppTable)
{

	HRESULT hResult;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

#ifdef	PARAMETER_VALIDATION
    // Check to see if it has a jump table
    if (IsBadReadPtr(lpCONTAINER, sizeof(LPVOID))) {
        // No jump table found
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags & ~(MAPI_DEFERRED_ERRORS|MAPI_UNICODE|WAB_PROFILE_CONTENTS|WAB_CONTENTTABLE_NODATA)) {
        DebugTraceArg(CONTAINER_GetContentsTable, TEXT("Unknown flags"));
        //return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (IsBadWritePtr(lppTable, sizeof(LPMAPITABLE))) {
        DebugTraceArg(CONTAINER_GetContentsTable, TEXT("Invalid Flags"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif	// PARAMETER_VALIDATION

    if(pt_bIsWABOpenExSession)
    {
        ULONG ulOlkFlags = ulFlags;

        // This is a WABOpenEx session using outlooks storage provider
        if(!lpCONTAINER->lpIAB->lpPropertyStore->hPropertyStore)
            return MAPI_E_NOT_INITIALIZED;

        // Since the Outlook store doesn't understand the private flags, these
        // flags need to be filtered out otherwise the outlook store
        // provider will fail with E_INVALIDARG or something
        //
        if(ulOlkFlags & WAB_PROFILE_CONTENTS)
            ulOlkFlags &= ~WAB_PROFILE_CONTENTS;
        if(ulOlkFlags & WAB_CONTENTTABLE_NODATA)
            ulOlkFlags &= ~WAB_CONTENTTABLE_NODATA;

        if(ulFlags & MAPI_UNICODE && !pt_bIsUnicodeOutlook)
        {
            // This version of Outlook can't handle Unicode so don't tell it to else it'll barf
            ulOlkFlags &= ~MAPI_UNICODE;
        }
        // Outlook provides it's own implementation of GetContentsTable for
        // efficiencies sake otherwise recreating the table going through the
        // WAB layer would be just too darned slow ...
        {
            LPWABSTORAGEPROVIDER lpWSP = (LPWABSTORAGEPROVIDER) lpCONTAINER->lpIAB->lpPropertyStore->hPropertyStore;

			Assert((lpCONTAINER->ulType == AB_PAB) ||
					(lpCONTAINER->ulType == AB_CONTAINER));

            hResult = lpWSP->lpVtbl->GetContentsTable(lpWSP,
            										  lpCONTAINER->pmbinOlk,
                                                      ulOlkFlags,
                                                      lppTable);

            DebugPrintTrace((TEXT("WABStorageProvider::GetContentsTable returned:%x\n"),hResult));

            if( ulFlags & MAPI_UNICODE && !pt_bIsUnicodeOutlook &&
                *lppTable && !HR_FAILED(hResult))                     
            {
                // This version of Outlook can't handle Unicode 
                // but caller wants unicode, so now we have to go in and tweak this data 
                // manually .. 
                LPMAPITABLE lpWABTable = NULL;

                if(!HR_FAILED(hResult = HrDupeOutlookContentsTable(*lppTable, &lpWABTable)))
                {
                    (*lppTable)->lpVtbl->Release(*lppTable);
                    *lppTable = lpWABTable;
                }

            }

            return hResult;
        }
    }

    // Create a new contents table object
    hResult = NewContentsTable((LPABCONT)lpCONTAINER,
      lpCONTAINER->lpIAB,
      ulFlags,
      NULL,
      lppTable);

    if(!(HR_FAILED(hResult)) && *lppTable &&
        (ulFlags & WAB_PROFILE_CONTENTS) && !(ulFlags & WAB_CONTENTTABLE_NODATA))
    {
        // There is a problem with searching multiple subfolders in that the data does not
        // come back sorted when it is collated across multiple folders. 
        // We need to sort the table before we return it .. it's somewhat inefficient to do this
        // sort at this point .. ideally the data should be added to the table sorted...
        LPSSortOrderSet lpSortCriteria = NULL;
        SCODE sc = MAPIAllocateBuffer(sizeof(SSortOrderSet)+sizeof(SSortOrder), &lpSortCriteria);
        if(!sc)
        {
            lpSortCriteria->cCategories = lpSortCriteria->cExpanded = 0;
            lpSortCriteria->cSorts = 1;
            lpSortCriteria->aSort[0].ulPropTag = PR_DISPLAY_NAME;
            if(!(((LPTAD)(*lppTable))->bMAPIUnicodeTable))
                lpSortCriteria->aSort[0].ulPropTag = CHANGE_PROP_TYPE( lpSortCriteria->aSort[0].ulPropTag, PT_STRING8);
            lpSortCriteria->aSort[0].ulOrder = TABLE_SORT_ASCEND;
	    hResult = (*lppTable)->lpVtbl->SortTable((*lppTable), lpSortCriteria, 0);
	    FreeBufferAndNull(&lpSortCriteria);
        }
        else
        {
            hResult = MAPI_E_NOT_ENOUGH_MEMORY;
        }
    }
	return(hResult);
}


/***************************************************************************

    Name      : CONTAINER::GetHierarchyTable

    Purpose   : Returns the merge of all the root hierarchy tables

    Parameters: lpCONTAINER -> Container object
                ulFlags =
                lppTable -> returned table object

    Returns   : HRESULT

    Comment   :

***************************************************************************/
STDMETHODIMP
CONTAINER_GetHierarchyTable (LPCONTAINER lpCONTAINER,
	ULONG ulFlags,
	LPMAPITABLE * lppTable)
{
    LPTSTR lpszMessage = NULL;
    ULONG ulLowLevelError = 0;
    HRESULT hr = hrSuccess;

#ifdef	PARAMETER_VALIDATION
    // Validate parameters
    // Check to see if it has a jump table
    if (IsBadReadPtr(lpCONTAINER, sizeof(LPVOID))) {
        // No jump table found
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // See if I can set the return variable
    if (IsBadWritePtr (lppTable, sizeof (LPMAPITABLE))) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check flags:
    //  The only valid flags are CONVENIENT_DEPTH and MAPI_DEFERRED_ERRORS


    if (ulFlags & ~(CONVENIENT_DEPTH|MAPI_DEFERRED_ERRORS|MAPI_UNICODE)) {
        DebugTraceArg(CONTAINER_GetHierarchyTable, TEXT("Invalid Flags"));
    //    return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

#endif

    EnterCriticalSection(&lpCONTAINER->cs);

    if (lpCONTAINER->ulType != AB_ROOT) {
        //
        //  Wrong version of this object.  Pretend this object doesn't exist.
        //
        hr = ResultFromScode(MAPI_E_NO_SUPPORT);
        goto out;
    }


    //
    //  Get a view from the TAD
    //
    hr = lpCONTAINER->lpIAB->lpTableData->lpVtbl->HrGetView(
      lpCONTAINER->lpIAB->lpTableData,
      (LPSSortOrderSet) &sosPR_ROWID,
      NULL,
      0,
      lppTable);

    if (HR_FAILED(hr)) {
        DebugTrace(TEXT("IAB_GetHierarchyTable Get Tad View failed\n"));
        goto out;
    }

#ifdef DEBUG
    if (hr == hrSuccess) {
        MAPISetBufferName(*lppTable,  TEXT("MergeHier VUE Object"));
    }
#endif

    // If the convenient depth flag was not specified we restrict on
    // PR_DEPTH == 1.
    if (!(ulFlags & CONVENIENT_DEPTH)) {
        SRestriction restrictDepth;
        SPropValue spvDepth;

        spvDepth.ulPropTag = PR_DEPTH;
        spvDepth.Value.l = 0;

        restrictDepth.rt = RES_PROPERTY;
        restrictDepth.res.resProperty.relop = RELOP_EQ;
        restrictDepth.res.resProperty.ulPropTag = PR_DEPTH;
        restrictDepth.res.resProperty.lpProp = &spvDepth;

        if (HR_FAILED(hr = (*lppTable)->lpVtbl->Restrict(*lppTable, &restrictDepth, 0))) {
            DebugTrace(TEXT("IAB_GetHierarchyTable restriction failed\n"));
            goto out;
        }
    }

out:
    LeaveCriticalSection(&lpCONTAINER->cs);

    DebugTraceResult(CONTAINER_GetHierarchyTable, hr);
    return(hr);
}


/***************************************************************************

    Name      : HrMergeTableRows

    Purpose   : Creates a merged hierarchy r of all the root level
                hierarchies from the AB providers installed.

    Parameters: lptadDst -> TABLEDATA object
                lpmtSrc -> source hierarchy table
                ulProviderNum =

    Returns   : HRESULT

    Comment   : NOTE: This may be irrelevant for WAB.

***************************************************************************/
HRESULT
HrMergeTableRows(LPTABLEDATA lptadDst,
  LPMAPITABLE lpmtSrc,
  ULONG ulProviderNum)
{
    HRESULT hResult = hrSuccess;
    SCODE   sc;
    ULONG   ulRowID = ulProviderNum * ((LONG)IAB_PROVIDER_HIERARCHY_MAX + 1);
    LPSRowSet lpsRowSet = NULL;
    LPSRow lprowT;

    if (hResult = HrQueryAllRows(lpmtSrc, NULL, NULL, NULL, 0, &lpsRowSet)) {
        DebugTrace(TEXT("HrMergeTableRows() - Could not query provider rows.\n"));
        goto ret;
    }

    if (lpsRowSet->cRows >= IAB_PROVIDER_HIERARCHY_MAX) {
        DebugTrace(TEXT("HrMergeTableRows() - Provider has too many rows.\n"));
        hResult = ResultFromScode(MAPI_E_TABLE_TOO_BIG);
        goto ret;
    }


    //	Set the ROWID to the end since will be looping in reverse order.
    ulRowID =   ulProviderNum * ((LONG) IAB_PROVIDER_HIERARCHY_MAX + 1)
      + lpsRowSet->cRows;
    for (lprowT = lpsRowSet->aRow + lpsRowSet->cRows;
      --lprowT >= lpsRowSet->aRow;) {
        ULONG cbInsKey;
        LPBYTE lpbNewKey = NULL;

        //	Make ulRowID zero based
        ulRowID--;

        //
        //  Munge the PR_INSTANCE_KEY
        //
        if ((lprowT->lpProps[0].ulPropTag != PR_INSTANCE_KEY)
          || !(cbInsKey = lprowT->lpProps[0].Value.bin.cb)
          || ((cbInsKey + sizeof(ULONG)) > UINT_MAX)
          || IsBadReadPtr(lprowT->lpProps[0].Value.bin.lpb, (UINT) cbInsKey)) {
            //	Can't create our INSTANCE_KEY without a valid provider
            //	INSTANCE_KEY
            DebugTrace(TEXT("HrMergeTableRows - Provider row has no valid PR_INSTANCE_KEY"));
            continue;
        }

        //	Allocate a new buffer for munging the instance key
        if (FAILED(sc = MAPIAllocateMore(cbInsKey + sizeof(ULONG), lprowT->lpProps, &lpbNewKey))) {
            hResult = ResultFromScode(sc);
            DebugTrace(TEXT("HrMergeTableRows() - MAPIAllocMore Failed"));
            goto ret;
        }

        *((LPULONG) lpbNewKey) = ulProviderNum;
        CopyMemory(lpbNewKey + sizeof(ULONG), lprowT->lpProps[0].Value.bin.lpb, cbInsKey);
        lprowT->lpProps[0].ulPropTag = PR_INSTANCE_KEY;
        lprowT->lpProps[0].Value.bin.lpb = lpbNewKey;
        lprowT->lpProps[0].Value.bin.cb = cbInsKey + sizeof(ULONG);

        //	Add the ROWID so that the original order of the providers is
        //	preserved
        Assert((PROP_ID(lprowT->lpProps[1].ulPropTag) == PROP_ID(PR_ROWID))
          || (PROP_ID(lprowT->lpProps[1].ulPropTag) == PROP_ID(PR_NULL)));
        lprowT->lpProps[1].ulPropTag = PR_ROWID;
        lprowT->lpProps[1].Value.l = ulRowID;
    }

    //	Now put them into the TAD all at once.
    //	Note!	We now rely on PR_ROWID to keep the rows in order
    if (HR_FAILED(hResult = lptadDst->lpVtbl->HrModifyRows(lptadDst, 0, lpsRowSet))) {
        DebugTrace(TEXT("HrMergeTableRows() - Failed to modify destination TAD.\n"));
    }

ret:
    //
    //  Free up the row set
    //
    FreeProws(lpsRowSet);

    return(hResult);
}


/***************************************************************************

    Name      : CONTAINER::OpenEntry

    Purpose   : Opens an entry

    Parameters: lpCONTAINER -> Container object
                cbEntryID = size of entryid
                lpEntryID -> EntryID to open
                lpInterface -> requested interface or NULL for default.
                ulFlags =
                lpulObjType -> returned object type
                lppUnk -> returned object

    Returns   : HRESULT

    Comment   : Calls up to IAB's OpenEntry.

***************************************************************************/
STDMETHODIMP
CONTAINER_OpenEntry(LPCONTAINER lpCONTAINER,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  LPCIID lpInterface,
  ULONG ulFlags,
  ULONG * lpulObjType,
  LPUNKNOWN * lppUnk)
{

#ifdef	PARAMETER_VALIDATION
    // Validate the object.
    if (BAD_STANDARD_OBJ(lpCONTAINER, CONTAINER_, OpenEntry, lpVtbl)) {
    // jump table not large enough to support this method
    return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check the entryid parameter. It needs to be big enough to hold an entryid.
    // Null entryids are valid
    /*
    if (lpEntryID) {
        if (cbEntryID < offsetof(ENTRYID, ab)
          || IsBadReadPtr((LPVOID)lpEntryID, (UINT)cbEntryID)) {
            DebugTraceArg(CONTAINER_OpenEntry,  TEXT("lpEntryID fails address check"));
            return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
        }

        NFAssertSz(FValidEntryIDFlags(lpEntryID->abFlags),
           TEXT("Undefined bits set in EntryID flags\n"));
    }
    */
    // Don't check the interface parameter unless the entry is something
    // MAPI itself handles. The provider should return an error if this
    // parameter is something that it doesn't understand.
    // At this point, we just make sure it's readable.
    if (lpInterface && IsBadReadPtr(lpInterface, sizeof(IID))) {
        DebugTraceArg(CONTAINER_OpenEntry, TEXT("lpInterface fails address check"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }	

    if (ulFlags & ~(MAPI_MODIFY | MAPI_DEFERRED_ERRORS | MAPI_BEST_ACCESS)) {
        DebugTraceArg(CONTAINER_OpenEntry, TEXT("Unknown flags used"));
    //    return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (IsBadWritePtr((LPVOID)lpulObjType, sizeof(ULONG))) {
        DebugTraceArg(CONTAINER_OpenEntry, TEXT("lpulObjType"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (IsBadWritePtr((LPVOID)lppUnk, sizeof(LPUNKNOWN))) {
        DebugTraceArg(CONTAINER_OpenEntry, TEXT("lppUnk"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif	// PARAMETER_VALIDATION

    // Should just call IAB::OpenEntry()...
    return(lpCONTAINER->lpIAB->lpVtbl->OpenEntry(lpCONTAINER->lpIAB,
      cbEntryID,
      lpEntryID,
      lpInterface,
      ulFlags,
      lpulObjType,
      lppUnk));
}


STDMETHODIMP
CONTAINER_SetSearchCriteria(LPCONTAINER lpCONTAINER,
  LPSRestriction lpRestriction,
  LPENTRYLIST lpContainerList,
  ULONG ulSearchFlags)
{

#ifdef PARAMETER_VALIDATION
    // Validate the object.
    if (BAD_STANDARD_OBJ(lpCONTAINER, CONTAINER_, SetSearchCriteria, lpVtbl)) {
        // jump table not large enough to support this method
        DebugTraceArg(CONTAINER_SetSearchCriteria, TEXT("Bad object/vtble"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // ensure we can read the restriction
    if (lpRestriction && IsBadReadPtr(lpRestriction, sizeof(SRestriction))) {
        DebugTraceArg(CONTAINER_SetSearchCriteria, TEXT("Bad Restriction parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (FBadEntryList(lpContainerList)) {
        DebugTraceArg(CONTAINER_SetSearchCriteria, TEXT("Bad ContainerList parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulSearchFlags & ~(STOP_SEARCH | RESTART_SEARCH | RECURSIVE_SEARCH
      | SHALLOW_SEARCH | FOREGROUND_SEARCH | BACKGROUND_SEARCH)) {
        DebugTraceArg(CONTAINER_GetSearchCriteria, TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }
	
#endif	// PARAMETER_VALIDATION

    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


/***************************************************************************

    Name      : CONTAINER::GetSearchCriteria

    Purpose   :

    Parameters: lpCONTAINER -> Container object
                ulFlags =
                lppRestriction -> Restriction to apply to searches
                lppContainerList ->
                lpulSearchState -> returned state

    Returns   : HRESULT

    Comment   : Not implemented in WAB.

***************************************************************************/
STDMETHODIMP
CONTAINER_GetSearchCriteria(LPCONTAINER lpCONTAINER,
  ULONG ulFlags,
  LPSRestriction FAR * lppRestriction,
  LPENTRYLIST FAR * lppContainerList,
  ULONG FAR * lpulSearchState)
{
#ifdef PARAMETER_VALIDATION
    // Validate the object.
    if (BAD_STANDARD_OBJ(lpCONTAINER, CONTAINER_, GetSearchCriteria, lpVtbl)) {
        // jump table not large enough to support this method
        DebugTraceArg(CONTAINER_GetSearchCriteria, TEXT("Bad object/vtble"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags & ~(MAPI_UNICODE)) {
        DebugTraceArg(CONTAINER_GetSearchCriteria, TEXT("Unknown Flags"));
    //    return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    // ensure we can write the restriction
    if (lppRestriction && IsBadWritePtr(lppRestriction, sizeof(LPSRestriction))) {
        DebugTraceArg(CONTAINER_GetSearchCriteria, TEXT("Bad Restriction write parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // ensure we can read the container list
    if (lppContainerList && IsBadWritePtr(lppContainerList, sizeof(LPENTRYLIST))) {
        DebugTraceArg(CONTAINER_GetSearchCriteria, TEXT("Bad ContainerList parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (lpulSearchState && IsBadWritePtr(lpulSearchState, sizeof(ULONG))) {
        DebugTraceArg(CONTAINER_GetSearchCriteria, TEXT("lpulSearchState fails address check"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif	// PARAMETER_VALIDATION

    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


/***************************************************************************

    Name      : CONTAINER::CreateEntry

    Purpose   : Creates an entry in the container

    Parameters: lpCONTAINER -> Container object
                
                  cbEntryID = size of entryid
                lpEntryID -> entryID of template
                [ cbEID and lpEID are the Template Entryids
                  In reality, these are actually flags that just tell
                  us internally what kind of object to create ]

                ulCreateFlags =
                lppMAPIPropEntry -> returned MAPIProp object

    Returns   : HRESULT

    Comment   :

***************************************************************************/
STDMETHODIMP
CONTAINER_CreateEntry(LPCONTAINER lpCONTAINER,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  ULONG ulCreateFlags,
  LPMAPIPROP FAR * lppMAPIPropEntry)
{
    BYTE bType;

#ifdef PARAMETER_VALIDATION
    // Validate the object.
    if (BAD_STANDARD_OBJ(lpCONTAINER, CONTAINER_, CreateEntry, lpVtbl)) {
        // jump table not large enough to support this method
        DebugTraceArg(CONTAINER_CreateEntry, TEXT("Bad object/Vtbl"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check the entryid parameter. It needs to be big enough to hold an entryid.
    // Null entryid are bad
/*
    if (lpEntryID) {
        if (cbEntryID < offsetof(ENTRYID, ab)
          || IsBadReadPtr((LPVOID) lpEntryID, (UINT)cbEntryID)) {
            DebugTraceArg(CONTAINER_CreateEntry, TEXT("lpEntryID fails address check"));
            return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
        }

        //NFAssertSz(FValidEntryIDFlags(lpEntryID->abFlags),
        //  TEXT("Undefined bits set in EntryID flags\n"));
    } else {
        DebugTraceArg(CONTAINER_CreateEntry, TEXT("lpEntryID NULL"));
        return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
    }
*/

    if (ulCreateFlags & ~(CREATE_CHECK_DUP_STRICT | CREATE_CHECK_DUP_LOOSE
      | CREATE_REPLACE | CREATE_MERGE)) {
        DebugTraceArg(CONTAINER_CreateEntry, TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (IsBadWritePtr(lppMAPIPropEntry, sizeof(LPMAPIPROP))) {
        DebugTraceArg(CONTAINER_CreateEntry, TEXT("Bad MAPI Property write parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
				
#endif	// PARAMETER_VALIDATION

#ifdef NEVER
    if (lpCONTAINER->ulType == AB_ROOT)
        return ResultFromScode(MAPI_E_NO_SUPPORT);
#endif // NEVER

    // What kind of entry are we creating?
    // Default is MailUser

    // The passed in entryid is the Tempalte entry ID
    bType = IsWABEntryID(cbEntryID, lpEntryID, NULL, NULL, NULL, NULL, NULL);

    if (bType == WAB_DEF_MAILUSER || cbEntryID == 0) {
        //
        //  Create a new (in memory) entry and return it's mapiprop
        //
        return(HrNewMAILUSER(lpCONTAINER->lpIAB, lpCONTAINER->pmbinOlk, MAPI_MAILUSER, ulCreateFlags, lppMAPIPropEntry));
    } else if (bType == WAB_DEF_DL) {
        //
        // Create a new (in memory) distribution list and return it's mapiprop?
        return(HrNewMAILUSER(lpCONTAINER->lpIAB, lpCONTAINER->pmbinOlk, MAPI_DISTLIST, ulCreateFlags, lppMAPIPropEntry));
    } else {
        DebugTrace(TEXT("CONTAINER_CreateEntry got unknown template entryID\n"));
        return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
    }
}


/***************************************************************************

    Name      : CONTAINER::CopyEntries

    Purpose   : Copies a list of entries into this container.

    Parameters: lpCONTAINER -> Container object
                lpEntries -> List of entryid's to copy
                ulUIParam = HWND
                lpPropgress -> progress dialog structure
                ulFlags =

    Returns   : HRESULT

    Comment   : Not implemented in WAB.

***************************************************************************/
STDMETHODIMP
CONTAINER_CopyEntries(LPCONTAINER lpCONTAINER,
  LPENTRYLIST lpEntries,
  ULONG_PTR ulUIParam,
  LPMAPIPROGRESS lpProgress,
  ULONG ulFlags)
{
#ifdef PARAMETER_VALIDATION
    if (BAD_STANDARD_OBJ(lpCONTAINER, CONTAINER_, CopyEntries, lpVtbl)) {
        //  jump table not large enough to support this method
        DebugTraceArg(CONTAINER_CopyEntries, TEXT("Bad object/vtbl"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // ensure we can read the container list
    if (FBadEntryList(lpEntries)) {
        DebugTraceArg(CONTAINER_CopyEntries, TEXT("Bad Entrylist parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulUIParam && ! IsWindow((HWND)ulUIParam)) {
        DebugTraceArg(CONTAINER_CopyEntries, TEXT("Invalid window handle"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (lpProgress && IsBadReadPtr(lpProgress, sizeof(IMAPIProgress))) {
        DebugTraceArg(CONTAINER_CopyEntries, TEXT("Bad MAPI Progress parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags & ~(AB_NO_DIALOG | CREATE_CHECK_DUP_LOOSE)) {
        DebugTraceArg(CONTAINER_CreateEntry, TEXT("Unknown flags used"));
    //   return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }
	
#endif	// PARAMETER_VALIDATION
    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


/***************************************************************************

    Name      : CONTAINER::DeleteEntries

    Purpose   : Delete entries from this container.

    Parameters: lpCONTAINER -> Container object
                lpEntries -> list of entryid's to delete
                ulFlags =

    Returns   : HRESULT

    Comment   :

***************************************************************************/
STDMETHODIMP
CONTAINER_DeleteEntries(LPCONTAINER lpCONTAINER,
  LPENTRYLIST lpEntries,
  ULONG ulFlags)
{
    ULONG i;
    HRESULT hResult = hrSuccess;
    ULONG cDeleted = 0;
    ULONG cToDelete;

#ifndef DONT_ADDREF_PROPSTORE
    {
        SCODE sc;
        if ((FAILED(sc = OpenAddRefPropertyStore(NULL, lpCONTAINER->lpIAB->lpPropertyStore)))) {
            hResult = ResultFromScode(sc);
            goto exitNotAddRefed;
        }
    }
#endif

#ifdef PARAMETER_VALIDATION
    if (BAD_STANDARD_OBJ(lpCONTAINER, CONTAINER_, DeleteEntries, lpVtbl)) {
        //  jump table not large enough to support this method
        DebugTraceArg(CONTAINER_DeleteEntries, TEXT("Bad object/vtbl"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // ensure we can read the container list

    if (FBadEntryList(lpEntries)) {
        DebugTraceArg(CONTAINER_DeleteEntries, TEXT("Bad Entrylist parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags) {
        DebugTraceArg(CONTAINER_CreateEntry, TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }
	
#endif	// PARAMETER_VALIDATION

    // List of entryids is in lpEntries.  This is a counted array of
    // entryid SBinary structs.
    cToDelete = lpEntries->cValues;


    // Delete each entry
    for (i = 0; i < cToDelete; i++)
    {
        if(0 != IsWABEntryID(lpEntries->lpbin[i].cb,
                             (LPENTRYID) lpEntries->lpbin[i].lpb,
                             NULL, NULL, NULL, NULL, NULL))
        {
            DebugTrace(TEXT("CONTAINER_DeleteEntries got bad entryid of size %u\n"), lpEntries->lpbin[i].cb);
            continue;
        }

        hResult = DeleteCertStuff((LPADRBOOK)lpCONTAINER->lpIAB, (LPENTRYID)lpEntries->lpbin[i].lpb, lpEntries->lpbin[i].cb);

        hResult = HrSaveHotmailSyncInfoOnDeletion((LPADRBOOK) lpCONTAINER->lpIAB, &(lpEntries->lpbin[i]));

        if (HR_FAILED(hResult = DeleteRecord(lpCONTAINER->lpIAB->lpPropertyStore->hPropertyStore,
                                            &(lpEntries->lpbin[i])))) {
            DebugTraceResult( TEXT("DeleteEntries: DeleteRecord"), hResult);
            continue;
        }
        cDeleted++;
    }


    if (! hResult) {
        if (cDeleted != cToDelete) {
            hResult = ResultFromScode(MAPI_W_PARTIAL_COMPLETION);
            DebugTrace(TEXT("DeleteEntries deleted %u of requested %u\n"), cDeleted, cToDelete);
        }
    }

#ifndef DONT_ADDREF_PROPSTORE
    ReleasePropertyStore(lpCONTAINER->lpIAB->lpPropertyStore);
exitNotAddRefed:
#endif
    return(hResult);
}


/***************************************************************************

    Name      : CONTAINER::ResolveNames

    Purpose   : Resolve names from this container.

    Parameters: lpCONTAINER -> Container object
                lptagColSet -> Set of property tags to get from each
                  resolved match.
                ulFlags = flags (none valid)
                        WAB_IGNORE_PROFILES means that even if this is 
                        a profile enabled session, search the whole WAB,
                        not just the current container
                        WAB_RESOLVE_ALL_EMAILS - valid if trying to resolve an 
                        e-mail address and we want to search across all e-mail addresses
                        not just the default. Should be used sparingly since it's a labor
                        intensive search
                        MAPI_UNICODE - Adrlist strings are in UNICODE and should return them
                        in Unicode
                lpAdrList -> [in] set of addresses to resolve, [out] resolved
                  addresses.
                lpFlagList -> [in/out] resolve flags.

    Returns   : HRESULT

    Comment   :

***************************************************************************/
STDMETHODIMP
CONTAINER_ResolveNames(LPCONTAINER lpRoot,
  LPSPropTagArray lptagaColSet,
  ULONG ulFlags,
  LPADRLIST lpAdrList,
  LPFlagList lpFlagList)
{
    LPADRENTRY lpAdrEntry;
    ULONG i, j;
    ULONG ulCount = 1;
    LPSBinary rgsbEntryIDs = NULL;
    HRESULT hResult = hrSuccess;
    LPMAPIPROP lpMailUser = NULL;
    LPSPropTagArray lpPropTags;
    LPSPropValue lpPropArray = NULL;
    LPSPropValue lpPropArrayNew = NULL;
    ULONG ulObjType, cPropsNew;
    ULONG cValues;
    SCODE sc = SUCCESS_SUCCESS;
    LPTSTR lpsz = NULL;

#ifndef DONT_ADDREF_PROPSTORE
        if ((FAILED(sc = OpenAddRefPropertyStore(NULL, lpRoot->lpIAB->lpPropertyStore)))) {
            hResult = ResultFromScode(sc);
            goto exitNotAddRefed;
        }
#endif

#ifdef PARAMETER_VALIDATION
    if (BAD_STANDARD_OBJ(lpRoot, CONTAINER_, ResolveNames, lpVtbl)) {
        //  jump table not large enough to support this method
        DebugTraceArg(CONTAINER_ResolveNames, TEXT("Bad object/vtbl"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // BUGBUG: Should also check lptagColSet, lpAdrList and lpFlagList!
    if (ulFlags&(~(WAB_IGNORE_PROFILES|WAB_RESOLVE_ALL_EMAILS|MAPI_UNICODE))) {
        DebugTraceArg(CONTAINER_ResolveNames, TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

#endif	// PARAMETER_VALIDATION

    // if no set of props to return is specified, return the default set
    lpPropTags = lptagaColSet ? lptagaColSet : (LPSPropTagArray)&ptaResolveDefaults;

    if(ulFlags & WAB_RESOLVE_ALL_EMAILS)
    {
        hResult = HrSmartResolve(lpRoot->lpIAB, (LPABCONT)lpRoot, 
                                WAB_RESOLVE_ALL_EMAILS | (ulFlags & MAPI_UNICODE ? WAB_RESOLVE_UNICODE : 0),
                                lpAdrList, lpFlagList, NULL);
        // If it's too complex, then just search normally
        if (MAPI_E_TOO_COMPLEX != hResult) {
            goto exit;
        }
        else {
            hResult = hrSuccess;
        }
    }


    // search for each name in the lpAdrList
    for (i = 0; i < lpAdrList->cEntries; i++) 
    {

        // Make sure we don't resolve an entry which is already resolved.
        if (lpFlagList->ulFlag[i] == MAPI_RESOLVED) 
        {
            continue;
        }

        lpAdrEntry = &(lpAdrList->aEntries[i]);


        // Search for this address

        // BUGBUG: For now, we only resolve perfect matches in the PR_DISPLAY_NAME or PR_EMAIL_ADDRESS
        // all other properties in ADRLIST are ignored

        // Look through the ADRENTRY for a PR_DISPLAY_NAME and create an SPropRestriction
        // to pass down to the property store.
        for (j = 0; j < lpAdrEntry->cValues; j++) 
        {
            ULONG ulPropTag = lpAdrEntry->rgPropVals[j].ulPropTag;
            if(!(ulFlags & MAPI_UNICODE) && PROP_TYPE(ulPropTag)==PT_STRING8)
                ulPropTag = CHANGE_PROP_TYPE(ulPropTag, PT_UNICODE);

            if ( ulPropTag == PR_DISPLAY_NAME || ulPropTag == PR_EMAIL_ADDRESS) 
            {
                ULONG Flags = AB_FUZZY_FAIL_AMBIGUOUS | AB_FUZZY_FIND_ALL;

                if(!(ulFlags & WAB_IGNORE_PROFILES))
                {
                    // if we didn't ask to surpress profile awareness,
                    // and profile awareness is enabled, restrict this search to
                    // the single folder
                    if(bAreWABAPIProfileAware(lpRoot->lpIAB))
                        Flags |= AB_FUZZY_FIND_PROFILEFOLDERONLY;
                }

                ulCount = 1;

                // Search the property store
                Assert(lpRoot->lpIAB->lpPropertyStore->hPropertyStore);

                if(ulFlags & MAPI_UNICODE)
                {
                    lpsz =  lpAdrEntry->rgPropVals[j].Value.lpszW;
                }
                else
                {
                    LocalFreeAndNull(&lpsz);
                    lpsz = ConvertAtoW(lpAdrEntry->rgPropVals[j].Value.lpszA);
                }
                
                if (HR_FAILED(hResult = HrFindFuzzyRecordMatches(lpRoot->lpIAB->lpPropertyStore->hPropertyStore,
				                                                  lpRoot->pmbinOlk,
                                                                  lpsz,
                                                                  Flags,
                                                                  &ulCount,                  // IN: number of matches to find, OUT: number found
                                                                  &rgsbEntryIDs))) 
                {
                    if (ResultFromScode(hResult) == MAPI_E_AMBIGUOUS_RECIP) 
                    {
                        lpFlagList->ulFlag[i] = MAPI_AMBIGUOUS;
                        continue;
                    } else 
                    {
                        DebugTraceResult( TEXT("HrFindFuzzyRecordMatches"), hResult);
                        goto exit;
                    }
                }

                if (ulCount) {  // Was a match found?
                    Assert(rgsbEntryIDs);
                    if (rgsbEntryIDs) 
                    {
                        if (ulCount == 1) 
                        {
                            // Open the entry and read the properties you care about.

                            if (HR_FAILED(hResult = lpRoot->lpVtbl->OpenEntry(lpRoot,
                                                                              rgsbEntryIDs[0].cb,    // cbEntryID
                                                                              (LPENTRYID)(rgsbEntryIDs[0].lpb),    // entryid of first match
                                                                              NULL,             // interface
                                                                              0,                // ulFlags
                                                                              &ulObjType,       // returned object type
                                                                              (LPUNKNOWN *)&lpMailUser))) 
                            {
                                // Failed!  Hmmm.
                                DebugTraceResult( TEXT("ResolveNames OpenEntry"), hResult);
                                goto exit;
                            }

                            Assert(lpMailUser);

                            if (HR_FAILED(hResult = lpMailUser->lpVtbl->GetProps(lpMailUser,
                                                                                  lpPropTags,   // lpPropTagArray
                                                                                  (ulFlags & MAPI_UNICODE) ? MAPI_UNICODE : 0,
                                                                                  &cValues,     // how many properties were there?
                                                                                  &lpPropArray))) 
                            {
                                DebugTraceResult( TEXT("ResolveNames GetProps"), hResult);
                                goto exit;
                            }

                            UlRelease(lpMailUser);
                            lpMailUser = NULL;


                            // Now, construct the new ADRENTRY
                            // (Allocate a new one, free the old one.
                            Assert(lpPropArray);

                            // Merge the new props with the ADRENTRY props
                            if (sc = ScMergePropValues(lpAdrEntry->cValues,
                                                      lpAdrEntry->rgPropVals,           // source1
                                                      cValues,
                                                      lpPropArray,                      // source2
                                                      &cPropsNew,
                                                      &lpPropArrayNew)) 
                            {               
                                goto exit;
                            }

                            // [PaulHi] 2/1/99  GetProps now returns the requested tag string
                            // types.  So if our client is non-UNICODE make sure we convert any
                            // UNICODE string properties to ANSI.
                            if (!(ulFlags & MAPI_UNICODE))
                            {
                                if(sc = ScConvertWPropsToA((LPALLOCATEMORE) (&MAPIAllocateMore), (LPSPropValue ) lpPropArrayNew, (ULONG) cPropsNew, 0))
                                    goto exit;
                            }

                            // Free the original prop value array
                            FreeBufferAndNull((LPVOID *) (&(lpAdrEntry->rgPropVals)));

                            lpAdrEntry->cValues = cPropsNew;
                            lpAdrEntry->rgPropVals = lpPropArrayNew;

                            FreeBufferAndNull(&lpPropArray);


                            // Mark this entry as found.
                            lpFlagList->ulFlag[i] = MAPI_RESOLVED;
                        } else 
                        {
                            DebugTrace(TEXT("ResolveNames found more than 1 match... MAPI_AMBIGUOUS\n"));
                            lpFlagList->ulFlag[i] = MAPI_AMBIGUOUS;
                        }

                        FreeEntryIDs(lpRoot->lpIAB->lpPropertyStore->hPropertyStore,
                                     ulCount,
                                     rgsbEntryIDs);
                    }
                }

                break;
            }
        }
    }


exit:
#ifndef DONT_ADDREF_PROPSTORE
    ReleasePropertyStore(lpRoot->lpIAB->lpPropertyStore);
exitNotAddRefed:
#endif
    FreeBufferAndNull(&lpPropArray);

    UlRelease(lpMailUser);

    if(!(ulFlags & MAPI_UNICODE))
        LocalFreeAndNull(&lpsz);

    return(hResult);
}


#ifdef NOTIFICATION // save for notifications
/***************************************************************************

    Name      : lTableNotifyCallBack

    Purpose   : Callback function for notifications

    Parameters: lpvContext ->
                cNotif =
                lpNotif ->

    Returns   :

    Comment   :

***************************************************************************/
long STDAPICALLTYPE
lTableNotifyCallBack(LPVOID lpvContext,
  ULONG cNotif,
  LPNOTIFICATION lpNotif)
{
    LPTABLEINFO lpTableInfo = (LPTABLEINFO)lpvContext;
    HRESULT     hResult;
    LPSRowSet   lpsrowsetProv = NULL;
    LPIAB       lpIAB = lpTableInfo->lpIAB;
    LPTABLEDATA lpTableData;
    ULONG       ulcTableInfo;
    LPTABLEINFO pargTableInfo;

    Assert(lpvContext);
    Assert(lpNotif);
    Assert(lpTableInfo->lpTable);
    Assert(lpTableInfo->lpIAB);
    Assert(! IsBadWritePtr(lpTableInfo->lpIAB, sizeof(IAB)));


    //	To avoid deadlock we will NOT enter the Address Books critical
    //	section.  The Address Book must enter our critical section BEFORE
    //	it modifies anything our callback needs


    // if the container is null then the tableinfo structure is being
    // used to keep track of the open one off tables otherwise its
    // being used to keep track of the open hierarchy tables.
    if (lpTableInfo->lpContainer == NULL) {
        // open one off table data
        lpTableData = lpIAB->lpOOData;
        ulcTableInfo = lpIAB->ulcOOTableInfo;
        pargTableInfo = lpIAB->pargOOTableInfo;
    } else {
        // open hierarchy table data
        lpTableData		=lpIAB->lpTableData;
        ulcTableInfo	=lpIAB->ulcTableInfo;
        pargTableInfo	=lpIAB->pargTableInfo;

        // While we here, blow away the SearchPath cache

#if defined (WIN32) && !defined (MAC)
        if (fGlobalCSValid) {
            EnterCriticalSection(&csMapiSearchPath);
        } else {
            DebugTrace(TEXT("lTableNotifyCallback: WAB32.DLL already detached.\n"));
        }
#endif
		
        FreeBufferAndNull(&(lpIAB->lpspvSearchPathCache));
        lpIAB->lpspvSearchPathCache = NULL;

#if defined (WIN32) && !defined (MAC)
        if (fGlobalCSValid) {
            LeaveCriticalSection(&csMapiSearchPath);
        } else {
            DebugTrace(TEXT("lTableNotifyCallback: WAB32.DLL got detached.\n"));
        }
#endif
    }

    switch (lpNotif->info.tab.ulTableEvent) {
        case TABLE_ROW_ADDED:
        case TABLE_ROW_DELETED:
        case TABLE_ROW_MODIFIED:
        case TABLE_CHANGED: {
            ULONG 		uliTable;

            // table has changed. We need to delete all the rows of
            // this table in the tad and then add all the rows currently
            // in that table to the tad.  We need to find the start and
            // end row indexes of the tables data in the tad.

            // get the index of the given table in the table info array
            for (uliTable=0; uliTable < ulcTableInfo; uliTable++) {
                if (pargTableInfo[uliTable].lpTable==lpTableInfo->lpTable) {
                    break;
                }
            }

            Assert(uliTable < ulcTableInfo);

            //	Delete all the rows of the table in the tad by querying
            //	all the rows from the TEXT("restricted") view for this provider
            //	and then calling HrDeleteRows.
            //	We'll add all the new rows back later
            if (HR_FAILED(hResult = HrQueryAllRows(lpTableInfo->lpmtRestricted,
              NULL, NULL, NULL, 0, &lpsrowsetProv))) {
                DebugTrace(TEXT("lTableNotifyCallBack() - Can't query rows from restricted view.\n"));
                goto ret;
            }

            if (lpsrowsetProv->cRows) {
                // Only call HrDeleteRows if there are rows to delete
                if (HR_FAILED(hResult = lpTableData->lpVtbl->HrDeleteRows(lpTableData, 0, lpsrowsetProv, NULL))) {
                    DebugTrace(TEXT("lTableNotifyCallBack() - Can't delete rows.\n"));
                    goto ret;
                }
            }

            // Add the contents of the provider table back to the TAD.

            // Seek to the beginning of the input table
            if (HR_FAILED(hResult = lpTableInfo->lpTable->lpVtbl->SeekRow(lpTableInfo->lpTable , BOOKMARK_BEGINNING, 0, NULL))) {
                // table must be empty
                goto ret;
            }

            //	Add all rows from the given provider back to the merged table.
            //	NOTE!	HrMergeTableRows takes a 1 based provider NUMBER not
            //			a provider index.
            if (HR_FAILED(hResult = HrMergeTableRows(lpTableData, lpTableInfo->lpTable, uliTable + 1))) {
                //$BUG	Handle per provider errors.
                DebugTrace(TEXT("lTableNotifyCallBack() - HrMergeTableRows returns (hResult = 0x%08lX)\n"), hResult);
            }

            break;
        }
    }
		
ret:
    // free the row set returned from MAPITABLE::QueryRows
    FreeProws(lpsrowsetProv);

    return(0);
}


/***************************************************************************

    Name      : HrGetBookmarkInTad

    Purpose   : Returns the row number in the tabledata object of the row
                that corresponds to the row at the bookmark in the given table.

    Parameters: lpTableData ->
                lpTable ->
                Bookmark =
                puliRow ->

    Returns   : HRESULT

    Comment   :

***************************************************************************/
static HRESULT
HrGetBookmarkInTad(LPTABLEDATA lpTableData,
  LPMAPITABLE lpTable,
  BOOKMARK Bookmark,
  ULONG * puliRow)
{
    LPSRowSet lpsRowSet = NULL;
    LPSRow lpsRow;
    ULONG uliProp;
    HRESULT hResult = hrSuccess;

    Assert(lpTableData);
    Assert(lpTable);
    Assert(puliRow);

    // seek to the bookmark in the given table
    if (HR_FAILED(hResult=lpTable->lpVtbl->SeekRow(
      lpTable,
      Bookmark,
      0,
      NULL))) {
        goto err;
    }

    // get the row
    if (HR_FAILED(hResult=lpTable->lpVtbl->QueryRows(
      lpTable,
      (Bookmark==BOOKMARK_END ? -1 : 1),
      TBL_NOADVANCE,
      &lpsRowSet))) {
        goto err;
    }

    // find the entryid in the property value array
    for (uliProp = 0; uliProp < lpsRowSet->aRow[0].cValues; uliProp++) {
        if (lpsRowSet->aRow[0].lpProps[uliProp].ulPropTag == PR_ENTRYID) {
            break;
        }
    }

    Assert(uliProp < lpsRowSet->aRow[0].cValues);

    // Look for the row in the tad with the same entryid.
    if (HR_FAILED(hResult=lpTableData->lpVtbl->HrQueryRow(
      lpTableData,
      lpsRowSet->aRow[0].lpProps+uliProp,
      &lpsRow,
      puliRow))) {
        // can't find the row in the table data should never happen
        goto err;
    }

    // free the row set returned from QueryRows on the tad
    FreeBufferAndNull(&lpsRow);

err:
    // free the row set returned from MAPITABLE::QueryRows
    FreeProws(lpsRowSet);
    return(hResult);
}
#endif

/*
-   FindContainer
-
*   Given an entryid, searches in the cached list of containers for
*   the structure containing the container so that we can get
*   additional container properties out of the strucutre painlessly
*   
*   Returns a pointer to an OlkContInfo structure so don't need to free
*   the returned value
*/
OlkContInfo *FindContainer(LPIAB lpIAB, ULONG cbEID, LPENTRYID lpEID)
{
	ULONG iolkci, colkci;
    BOOL ul=FALSE;
	OlkContInfo *rgolkci;

	Assert(lpIAB);
	Assert(lpIAB->lpPropertyStore);

    // If the WAB session is Profile Aware, then the WAB's list of containers
    // is cached on the IAB object
    if(bIsWABSessionProfileAware(lpIAB))
    {
        colkci = lpIAB->cwabci;
        rgolkci = lpIAB->rgwabci;
    }
    else // it's in the list of the Outlook containers
    {
	    colkci = lpIAB->lpPropertyStore->colkci;
	    rgolkci = lpIAB->lpPropertyStore->rgolkci;
    }

    // if we didn't find any cached info, nothing more to do
    if(!colkci || !rgolkci)
        return NULL;

	for (iolkci = 1; iolkci < colkci; iolkci++)
	{
		if(cbEID == rgolkci[iolkci].lpEntryID->cb)
        {
            // Look for the match and return that item
            if(cbEID && 0 == memcmp((LPVOID) lpEID,(LPVOID)rgolkci[iolkci].lpEntryID->lpb, cbEID))
            {
                ul = TRUE;
                break;
            }
        }
    }
	return(ul ? &(rgolkci[iolkci]) : NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wab32res\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ui.rc
//
#define IDC_FIND_BUTTON_FIND            3
#define IDC_FIND_BUTTON_CLEAR           4
#define IDC_FIND_BUTTON_TO              5
#define IDC_FIND_BUTTON_CC              6
#define IDC_FIND_BUTTON_BCC             7
#define IDC_FIND_BUTTON_PROPERTIES      8
#define IDC_FIND_BUTTON_DELETE          9
#define IDC_FIND_BUTTON_ADDTOWAB        10
#define IDC_FIND_BUTTON_SERVER_INFO     11
#define IDC_FIND_BUTTON_STOP            12
#define IDC_LDAPCANCEL_ANIMATE          30
#define IDC_LDAPCANCEL_STATIC_PLEASEWAIT 54
#define idsUnknownDisplayName           54
#define IDC_PRINT_FRAME_RANGE           56
#define IDC_PRINT_RADIO_ALL             57
#define IDC_PRINT_RADIO_SELECTED        58
#define IDC_PRINT_FRAME_STYLE           59
#define IDC_PRINT_RADIO_MEMO            60
#define IDC_PRINT_RADIO_CARD            61
#define IDC_PRINT_RADIO_PHONELIST       62
#define IDC_PRINT_STATIC_PRINTERNAMELABEL 63
#define IDC_PRINTCANCEL_STATIC_STATUS   64
#define IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME 67
#define IDC_FIND_BUTTON_CLOSE           68
#define IDC_DETAILS_OTHER_BUTTON_ADDTOGROUP 70
#define IDC_DETAILS_TRIDENT_GO          71
#define IDC_DETAILS_NOTES_STATIC_NOTES_GROUP 72
#define IDC_DETAILS_TRIDENT_STATIC      74
#define IDC_DETAILS_TRIDENT_STATIC_CAPTION 75
#define IDM_VIEW_GROUPSLIST             76
#define IDC_DETAILS_PERSONAL_CHECK_RICHINFO 77
#define IDC_DETAILS_NTMTG_STATIC_CAPTION2 81
#define IDC_DETAILS_NTMTG_STATIC_CAPTION3 82
#define IDC_DETAILS_NTMTG_COMBO_EMAIL   83
#define IDC_DETAILS_NTMTG_BUTTON_CALL   84
#define IDC_DETAILS_NTMTG_FRAME_SERVERS 85
#define IDC_DETAILS_NTMTG_COMBO_DEFAULTSERVER 86
#define IDC_DETAILS_NTMTG_COMBO_BACKUPSERVER 87
#define IDI_ICON_NETMEETING             89
#define IDC_DETAILS_NTMTG_FRAME_SERVERS2 89
#define IDC_DETAILS_NTMTG_EDIT_ADDSERVER 90
#define IDC_DETAILS_NTMTG_BUTTON_ADDSERVER 91
#define IDC_DETAILS_NTMTG_LIST_SERVERS  92
#define IDC_DETAILS_NTMTG_BUTTON_EDIT   93
#define IDC_DETAILS_NTMTG_BUTTON_REMOVE 94
#define IDC_DETAILS_NTMTG_BUTTON_SETDEFAULT 95
#define IDC_DETAILS_CERT_COMBO          96
#define IDC_DETAILS_PERSONAL_STATIC_CAPTION3 97
#define IDC_DETAILS_TRIDENT_BUTTON_ADDTOWAB 98
#define IDC_FIND_COMBO_LIST             99
#define IDC_TAB_FIND                    100
#define IDM_FIND_CONTEXTMENU_CONTAINER  102
#define IDC_FIND_STATIC_LOGO            102
#define IDD_DIALOG_LDAPCANCEL           103
#define IDC_DETAILS_OPS_STATIC_ICON     103
#define IDD_DIALOG_PRINT                104
#define IDC_DETAILS_OPS_STATIC_CAPTION  104
#define IDD_DIALOG_PRINTCANCEL          105
#define IDC_DETAILS_OPS_STATIC_ETCHED   105
#define IDM_TOOLS_INTERNET_CALL         106
#define IDD_DETAILS_NTMTG               107
#define IDD_DETAILS_TRIDENT             108
#define IDC_DETAILS_HOME_COMBO_GENDER   108
#define IDD_DETAILS_OPS                 110
#define IDD_DIALOG_FIND                 139
#define IDC_FIND_STATIC_FINDIN          1149
#define IDC_FIND_STATIC_FRAMESEARCH     1150
#define IDC_FIND_STATIC_NAME            1151
#define IDC_FIND_EDIT_NAME              1152
#define IDC_FIND_STATIC_EMAIL           1153
#define IDC_FIND_EDIT_EMAIL             1154
#define IDC_FIND_STATIC_FINDIN2         1155
#define IDC_FIND_FRAME_LOOKFOR          1155
#define IDC_FIND_STATIC_STREET          1156
#define IDC_FIND_EDIT_STREET            1157
#define IDC_FIND_STATIC_PHONE           1158
#define IDC_FIND_EDIT_PHONE             1159
#define IDC_FIND_STATIC_ANY             1166
#define IDC_FIND_EDIT_ANY               1167
#define IDC_FIND_LIST_RESULTS           1168
#define IDC_FIND_ANIMATE1               1170
#define IDR_AVI_WABFIND                 1171
#define IDD_DIALOG_PRINTDLGORD          1538
#define IDC_DETAILS_NOTES_EDIT_GROUPS   2465
#define IDC_DETAILS_PERSONAL_STATIC_DISPLAYNAME 2779
#define IDC_DETAILS_PERSONAL_EDIT_DISPLAYNAME 2780
#define IDC_DETAILS_NTMTG_BUTTON_SETBACKUP 2781
#define IDC_OPTIONS_RADIO_OUTLOOK       2782
#define IDC_OPTIONS_RADIO_WAB           2783
#define IDC_ABOUT_EDIT_FILENAME         2784
#define IDC_ABOUT_STATIC_FILENAME       2785
#define IDC_ADDRBK_COMBO_CONT           2786
#define IDC_FIND_STATIC_ADVANCED        2789
#define IDC_FIND_COMBO_FIELD            2790
#define IDC_FIND_COMBO_CONDITION        2791
#define IDC_FIND_EDIT_ADVANCED          2792
#define IDC_FIND_LIST_CONDITIONS        2793
#define IDC_FIND_BUTTON_ADDCONDITION    2794
#define IDC_FIND_BUTTON_REMOVECONDITION 2795
#define IDI_ICON_ORG                    2796
#define IDD_DETAILS_ORG                 2797
#define IDC_DETAILS_ORG_STATIC_MANAGER  2800
#define IDC_DETAILS_ORG_LIST_MANAGER    2801
#define IDC_DETAILS_ORG_STATIC_REPORTS  2802
#define IDC_DETAILS_ORG_LIST_REPORTS    2803
#define IDD_DIALOG_SETME                2805
#define IDC_SETME_STATIC                2806
#define IDC_SETME_RADIO_CREATE          2807
#define IDC_SETME_RADIO_SELECT          2808
#define IDC_SETME_LIST                  2809
#define IDC_DETAILS_NTMTG_BUTTON_CANCELEDIT     2810
#define IDC_DETAILS_SUMMARY_STATIC_NAME         2811
#define IDC_DETAILS_SUMMARY_STATIC_HOMEPHONE    2812
#define IDC_DETAILS_SUMMARY_STATIC_BUSINESSPHONE 2813
#define IDC_DETAILS_SUMMARY_STATIC_EMAIL        2814
#define IDC_DETAILS_SUMMARY_STATIC_BUSINESSFAX  2815
#define IDC_DETAILS_SUMMARY_STATIC_PAGER        2816
#define IDC_DETAILS_SUMMARY_STATIC_CELLULAR     2817
#define IDC_DETAILS_SUMMARY_STATIC_JOBTITLE     2818
#define IDC_DETAILS_SUMMARY_STATIC_DEPARTMENT   2819
#define IDC_DETAILS_SUMMARY_STATIC_OFFICE       2820
#define IDC_DETAILS_SUMMARY_STATIC_COMPANYNAME  2821
#define IDC_DETAILS_SUMMARY_STATIC_BUSINESSWEB  2822
#define IDC_DETAILS_SUMMARY_STATIC_PERSONALWEB  2823
#define IDC_FIND_BUTTON_MORE                    2824
#define IDC_DETAILS_HOME_BUTTON_MAP             2825
#define IDC_DETAILS_BUSINESS_BUTTON_MAP         2826
#define IDC_DISTLIST_BUTTON_MAP                 2827

#define IDM_FIND_DIRECTORYSERVICES      40001
#define IDM_FIND_CONTAINERPROPERTIES    40002
#define IDD_DIALOG_OPTIONS              6000
#define IDD_DIALOG_REPORTS              6001
#define IDC_REPORTS_LIST                6002
#define IDC_REPORTS_BUTTON_PROPERTIES   6003
#define IDD_DIALOG_FOLDER               6004
#define IDC_FOLDER_STATIC               6005
#define IDC_FOLDER_EDIT_NAME            6006
#define IDD_DETAILS_SUMMARY             6007
#define IDC_PROGRESS                    6008
#define IDC_STATIC_PROGRESS_ICON        6009
#define IDI_ICON_IMPORT                 6010
#define IDI_ICON_PRINT                  6011
#define IDD_NEWCALL                     6012
#define IDC_NEWCALL_GROUP_DIALNUM       6013
#define IDC_NEWCALL_STATIC_CONTACT      6014
#define IDC_NEWCALL_BUTTON_PROPERTIES   6015
#define IDC_NEWCALL_BUTTON_CALL         6016
#define IDC_NEWCALL_STATIC_PHNUM        6017
#define IDC_NEWCALL_COMBO_PHNUM         6018
#define IDC_NEWCALL_COMBO_CONTACT       6019
#define IDC_NEWCALL_BUTTON_DIALPROP     6020
#define IDC_NEWCALL_BUTTON_CLOSE        6021
#define IDC_DETAILS_NOTES_FRAME_FOLDER  6022
#define IDC_DETAILS_NOTES_STATIC_FOLDER 6023
#define IDC_DETAILS_BUSINESS_STATIC_IPPHONE 6024
#define IDC_DETAILS_BUSINESS_EDIT_IPPHONE   6025
#define IDC_STATIC_ETCHED               6026

#define IDD_DIALOG_RUBY                 6027
#define IDC_RUBY_STATIC_LASTNAME        6028
#define IDC_RUBY_STATIC_FIRSTNAME       6029
#define IDC_RUBY_EDIT_YOMILASTNAME      6030
#define IDC_RUBY_EDIT_LASTNAME          6031
#define IDC_RUBY_EDIT_YOMIFIRSTNAME     6032
#define IDC_RUBY_EDIT_FIRSTNAME         6033
#define IDC_DETAILS_PERSONAL_BUTTON_RUBY    6034
#define IDC_DETAILS_PERSONAL_CHECK_WESTERN  6035
#define IDC_DETAILS_PERSONAL_STATIC_RUBYLAST    6036
#define IDC_DETAILS_PERSONAL_STATIC_RUBYFIRST   6037
#define IDD_DETAILS_PERSONAL_RUBY       6038
#define IDM_FILE_SWITCHUSERS            6039
#define IDM_NOTIFY_REFRESHUSER          6040
#define IDM_FILE_SHOWALLCONTENTS        6041
#define IDI_ICON_GROUPOTHER             6042
#define IDI_ICON_PERSONAL               6043
#define IDC_FOLDER_CHECK_SHARE          6044
#define IDI_ICON_FOLDER                 6045
#define IDC_FOLDER_STATIC_CREATEDBY     6046
#define IDD_DIALOG_PRINTDLGEX           6047
#define IDC_DETAILS_PERSONAL_STATIC_TITLE 6048
#define IDC_DETAILS_PERSONAL_EDIT_TITLE 6049
#define IDC_DETAILS_HOME_CHECK_DEFAULTADDRESS 6050
#define IDC_DETAILS_BUSINESS_CHECK_DEFAULTADDRESS 6051

#define IDI_ICON_FAMILY                         6052
#define IDC_DETAILS_FAMILY_STATIC_SPOUSE        6053
#define IDC_DETAILS_FAMILY_EDIT_SPOUSE          6054
#define IDC_DETAILS_FAMILY_STATIC_CHILDREN      6055
#define IDC_DETAILS_FAMILY_LIST_CHILDREN        6056
#define IDC_DETAILS_FAMILY_BUTTON_ADDCHILD      6057
#define IDC_DETAILS_FAMILY_BUTTON_EDITCHILD     6058
#define IDC_DETAILS_FAMILY_BUTTON_REMOVECHILD   6059
#define IDC_DETAILS_FAMILY_STATIC_BIRTHDAY      6060
#define IDC_STATIC_BIRTHDAY                     6061
#define IDC_DETAILS_FAMILY_STATIC_ANNIVERSARY   6062
#define IDC_STATIC_ANNIVERSARY                  6063
#define IDC_DETAILS_FAMILY_DATE_BIRTHDAY        6064 // This ID is used for dynamically created MonthDate control
#define IDC_DETAILS_FAMILY_DATE_ANNIVERSARY     6065 // This ID is used for dynamically created MonthDate control
#define IDD_DETAILS_FAMILY                      6066

/************
//Add new Command IDs above here starting with last id number above
*************/


#define idsButton6                      4000
#define idsNoLocalSearchResults         4100
#define idsLDAPCancelMessage            4241
#define idsPrintDisplayName             4242
#define idsPrintTitle                   4243
#define idsPrintDepartment              4244
#define idsPrintOffice                  4245
#define idsPrintCompany                 4246
#define idsPrintBusinessPhone           4247
#define idsPrintBusinessFax             4248
#define idsPrintBusinessPager           4249
#define idsPrintHomePhone               4250
#define idsPrintHomeFax                 4251
#define idsPrintHomeCellular            4252
#define idsPrintBusinessWebPage         4253
#define idsPrintHomeWebPage             4254
#define idsPrintNotes                   4255
#define idsPrintEmail                   4256
#define idsPrintHomeAddress             4257
#define idsPrintBusinessAddress         4258
#define idsPrintAddressTemplate         4259
#define idsPrintGroupName               4260
#define idsPrintGroupMembers            4261
#define idsPrintDocTitle                4262
#define idsPrintBusCardAddressTemplate  4263
#define idsPrintBusCardBusinessPhone    4264
#define idsPrintBusCardBusinessFax      4265
#define idsPrintBusCardHomePhone        4266
#define idsPrintStatusBarMessage        4267
#define idsPrintNoPhone                 4268
#define idsPrintJobCannotStop           4269
#define idsPrintingPageNumber           4270
#define idsPrintFormattingName          4271
#define idsStatusBarCount               4272
#define idsNowAddingToWAB               4273
#define idsContinueAddingToWAB          4274
#define idsNotEnoughDiskSpace           4275
#define idsDefaultFontFace              4280
#define idsSearchDialogTitle            4281
#define idsSearchDialogTitleWithResults 4282
#define idsPhoneFontReduceBy            4284
#define idsPhoneTextSpaceTwips          4285
#define idsBusCardFontReduceBy          4286
#define idsPickUserSelect               4288
#define idsSendMailError                4291
#define idsDontDisplayInitials          4292
#define idsDetailsTridentTitle          4293
#define idsMenuDeleteRemove             4294
#define idsRemoveGroupFromAB            4295
#define idsRemoveGroupError             4296
#define idsRemoveSelectedFromGroup      4297
#define idsRemoveSelectedFromGroupAndAB 4298
#define idsPrintMenu                    4299
#define idsAboutMenu                    4300
#define idsGroupListMenu                4301
#define idsDefaultServer                4302
#define idsBackupServer                 4303
#define idsDetailsConferencingTitle     4304
#define idsMenuInternetCall             4305
#define idsCertsWithoutEmails           4306
#define idsImportCertNoEmail            4307
#define idsCertAlreadyExists            4308
#define idsUseLCID                      4309
#define idsEntryNotFound                4310
#define idsIncompleteConfInfo           4311
#define idsCouldNotAddSomeEntries       4312
#define idsPreferedPartnerCode          4313
#define idsFindConnecting               4315
#define idsLangPrintingOn               4316
#define idsYourName                     4317
#define idsOPSTitleString               4318
#define idsGender                       4318
#define idsGenderFemale                 4319
#define idsGenderMale                   4320
#define idsStoreChangeOnRestart         4321
#define idsNoFolderSearchResults        4322
#define idsFindTabTitle                 4323
#define idsFindTabTitle2                4324
#define idsLDAPFilterOption1            4325
#define idsLDAPFilterOption2            4326
#define idsLDAPFilterOption3            4327
#define idsLDAPFilterOption4            4328
#define idsLDAPFilterOption5            4329
#define LDAPFilterOptionMax                5 //just # of options
#define idsLDAPFilterField1             4340
#define idsLDAPFilterField2             4341
#define idsLDAPFilterField3             4342
#define idsLDAPFilterField4             4343
#define idsLDAPFilterField5             4344
#define LDAPFilterFieldMax                 5 //just # of fields
#define idsFindFilterAnd                4401
#define idsFindFilter                   4402
#define idsMenuNewFolder                4403
#define idsAddFolderName                4404
#define idsMenuPaste                    4405
#define idsRemoveFolderFromAB           4406
#define idsRemoveFolderError            4407
#define idsContacts                     4408
#define idsDetailsOrgTitle              4409
#define idsConfServer                   4410
#define idsConfEmail                    4411
#define idsConfAdd                      4412
#define idsConfUpdate                   4413
#define idsSendMailNoMapi               4414
#define idsInternetCallNoCallTo         4415
#define idsDetailsSummaryTitle          4416
#define idsSelectWABToImport            4417
#define idsEntryAlreadyInWAB            4418
#define idsImporting                    4419
#define idsImportingName                4420
#define idsImportError                  4421
#define idsImportComplete               4422
#define idsImportCompleteError          4423
#define idsImportProcessing             4424
#define idsUsersContacts                4425
#define idsAllContacts                  4426
#define idsCannotDelete                 4427
#define idsMenuEditProfile              4428
#define idsSomeHaveNoEmail              4429
#define idsNoDialerDataMsg              4430
#define idsPhoneLabelHome               4432
#define idsPhoneLabelBus                4433
#define idsPhoneLabelBus2               4434
#define idsPhoneLabelMobile             4435
#define idsPhoneLabelRadio              4436
#define idsPhoneLabelCar                4437
#define idsPhoneLabelOther              4438
#define idsPhoneLabelPager              4439
#define idsPhoneLabelAst                4440
#define idsPhoneLabelHome2              4441
#define idsPhoneLabelCompMain           4442
#define idsPhoneLabelFaxHome            4443
#define idsPhoneLabelFaxBus             4444
#define idsMenuDialer                   4445
#define idsNoPhoneNumAvailable          4446
#define idsUnableToPlaceCall            4447
#define idsUnableToShowProps            4448
#define idsInsufficientAddressInfo      4449
#define idsSharedContacts               4450
#define idsPhoneLabelIPPhone            4451
#define idsCaptionWithText              4452
#define idsMenuSwitchUser               4453
#define idsMenuShowAllContents          4454
#define idsLDAPSpecificErr              4455
#define idsFindDlgWidth                 4456
#define idsGroupOtherTabName            4457
#define idsName                         4458
#define idsDateTimeFormat               4459
#define idsNewChild                     4460
#define idsLVDateFormatString           4461
#define idsMenuExportWAB                4462
#define idsSelectWABToExport            4463
#define idsWABExportSuccess             4464
#define idsExportError                  4465

/************
//Add new String IDs above here starting with last id number above
*************/


// Reserve ids from 15000 to 15255 for extensible menu items
// When apps register a actino item, we will assign a 
// command id to its menu ..
#define IDM_EXTENDED_START              15000
#define IDM_EXTENDED_END                15255
#define MAX_EXTENDED_MENUS              256

#define IDM_LVCONTEXT_NEWFOLDER         8001
#define IDM_FILE_NEWFOLDER              8002
#define IDM_VIEW_FOLDERS1               8003
#define MAX_VIEW_FOLDERS                512     // When adding folders to the view menu on the fly, we reserve this 512 ids for added folders
#define IDM_VIEW_FOLDERSLAST            8515
#define IDM_SENDMAILTO_START            8532    
#define IDM_SENDMAILTO_MAX              64      // When creating SendMailTo contect menus on the fly, we reserve this 64 IDs for the Added Email addresses so we can identify them
#define IDM_EDIT_PASTE                  8601
#define IDM_LVCONTEXT_PASTE             8602
#define IDM_EDIT_SETME                  8603
#define IDR_MENU_LVCONTEXT_BROWSE_LV    8604
#define IDR_MENU_LVCONTEXT_TV           8605
#define IDR_MENU_LVCONTEXT_DL_LV        8606
#define IDR_MENU_LVCONTEXT_SELECT_LIST  8607
#define IDR_MENU_LVCONTEXT_FIND_LV      8608
#define IDM_DIALDLG_START               8609

/************
//Add new Menu IDs above here starting with last id number above
*************/

//////////////////////////////////////////////////////////////////////////
//  These special ids below are used for customizing the NT5 Print dialog
//
#define rad1        0x0420
#define rad2        0x0421
#define grp1        0x0430
#define grp2        0x0431
#define stc3        0x0442
#define edt2        0x0481
//////////////////////////////////////////////////////////////////////////

#define IDC_DETAILS_CERT_STATIC2        -1
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        111
#define _APS_NEXT_COMMAND_VALUE         40005
#define _APS_NEXT_CONTROL_VALUE         109
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wab32res\resrc2.h ===
/*
- Resrc2.h - Resource IDs for all the misc wab files other than wab32.dll
-
-
*/
#include ".\commonrc.h"

/*****************************************************************************
-
-   Resources for WAB.EXE
-
******************************************************************************/

#define IDI_ICON1                       101

#define idsWABTitle                     2001
#define idsWABFileNotFound              2002
#define idsWABOpenError                 2003
#define idsWABOpenFileTitle             2004
#define idsWABOpenFileFilter            2005
#define idsWABNewFileTitle              2006
#define idsWABUsage                     2007
#define idsWABPathNotFound              2008
#define idsWABInvalidCmdLine            2009
#define idsWABTitleWithFileName         2010
#define idsWABAddressError              2011
#define idsWABOpenErrorMemory           2012
#define idsWABOpenErrorLocked           2013
#define idsWABOpenErrorCorrupt          2014
#define idsWABOpenErrorDisk             2015
#define idsWABAddressErrorMissing       2016
#define idsWABOpenErrorNotWAB           2017
#define idsWABOpenErrorNotWABName       2018
#define idsWABOpenVCardError            2019
#define idsWABOpenLDAPUrlError          2020
#ifdef WIN16
#define idsWABUsage1                    2100
#endif

#define idsAddToABPaneTitle             2030
#define idsCertificateViewTitle         2031

#define IDD_DIALOG_DEFAULT_VCARD_VIEWER 2200
#define IDC_CHECK_ALWAYS                2201
#define IDC_STATIC_ASK                  2202
#define IDC_STATIC_ICON                 2203

#define IDC_ADD_TO_ADDRESS_BOOK         2204
#define IDD_CERTPROP_ADDRESS_BOOK       2205
#define IDC_ADD_TO_ADDRESS_BOOK_FRAME   2206
#define IDC_ADD_TO_ADDRESS_BOOK_TEXT    2207

#define MAX_RESOURCE_STRING             260



/*****************************************************************************
-
-   Resources for WABMig.EXE
-
******************************************************************************/

// Dialog Boxes
#define IDM_EXIT                        5
#define IDD_ImportDialog                1101
#define IDD_Options                     1102
#define IDD_ImportReplace               1103
#define IDD_ErrorImport                 1104
#define IDD_ExportDialog                1105
#define IDD_ErrorExport                 1106
#define IDD_CSV_EXPORT_WIZARD_FILE      1107
#define IDD_CSV_EXPORT_WIZARD_PICK      1108
#define IDD_ExportReplace               1109
#define IDD_CSV_IMPORT_WIZARD_FILE      1110
#define IDD_CSV_IMPORT_WIZARD_MAP       1111
#define IDD_CSV_CHANGE_MAPPING          1112


// Control Identifiers
// Import Dialog
#define IDC_Progress                    1113
#define IDC_Import                      1114
#define IDC_Options                     1115
#define IDC_Message                     1116
#define IDC_Target                      1117
#define IDC_Export                      1118

// Options Dialog
#define IDC_Replace_Always              1119
#define IDC_Replace_Never               1120
#define IDC_Replace_Prompt              1121

// Replace Dialog
#define IDC_YesToAll                    1122
#define IDC_NoToAll                     1123
#define IDC_Replace_Message             1124
#define IDC_AddDuplicate                1125
#define IDC_AddDuplicateAll             1126

// Error Dialog
#define IDC_NoMoreError                 1127
#define IDC_ErrorMessage                1128

// Test Menu
#define IDC_Test_Replace                1129
#define IDC_Test_Error                  1130

// CSV Import and Export Wizards
#define IDE_CSV_EXPORT_NAME             1131
#define IDC_BROWSE                      1132
#define IDLV_PICKER                     1133
#define IDC_WIZARD_BITMAP               1134
#define IDLV_MAPPER                     1135
#define IDE_CSV_IMPORT_NAME             1136
#define IDC_CHANGE_MAPPING              1137
#define IDC_CSV_CHANGE_MAPPING_TEXT_FIELD           1138
#define IDC_CSV_MAPPING_COMBO                       1139
#define IDC_CSV_MAPPING_SELECT                      1140
#define IDS_NETSCAPE_FILE_SPEC                      1143
#define IDS_NETSCAPE_EXPORT_TITLE                   1144
#define IDS_NETSCAPE_IMPORT_TITLE                   1145
#define IDE_NETSCAPE_IMPORT_FILE_ERROR              1146
#define IDE_NETSCAPE_EXPORT_FILE_ERROR              1147
#define IDS_NETSCAPE_IMPORT_COLLISION               1148
#define IDS_REPLACE_MESSAGE                         1149
#define IDS_NETSCAPE_MAILTO		                    1150
#define IDS_MAILTO					                1151
#define IDS_SMTP					                1152
#define IDS_STRING_SELECTPATH		                1153				
#define IDS_MESSAGE				                    1154
#define IDS_ADDRESS_HTM			                    1155
#define IDS_ERROR					                1156
#define IDS_INVALID_FILE			                1157
#define IDS_NO_ENTRY				                1158
#define IDS_ALIASOF				                    1159
#define IDS_DUMMY					                1160
#define IDS_LOOPING				                    1161
#define IDS_ENTRY_NOIMPORT			                1162
#define IDS_NETSCAPE_PATH			                1163
#define IDS_NETSCAPE_FILE			                1164
#define IDS_NETSCAPE_TITLE			                1165
#define IDS_ATHENA16_PATH			                1166
#define IDS_ATHENA16_FILE			                1167
#define IDS_ATHENA16_TITLE			                1168
#define IDS_EUDORA_PATH			                    1169
#define IDS_EUDORA_FILE			                    1170
#define IDS_EUDORA_TITLE			                1171
#define IDS_NETSCAPE_REGKEY		                    1172
#define IDS_NETSCAPE_ADDRESS_PATH	                1173
#define IDS_EUDORA_REGKEY			                1174
#define IDS_EUDORA_ADDRESS_PATH	                    1175
#define IDS_GERNERIC_ERROR			                1176
#define IDS_WAB_ERROR				                1177
#define IDS_ERROR_ADDRESSBOOK		                1178
#define IDS_EUDORA_ADDRESS			                1179
#define IDS_EUDORA_TOC				                1180
#define IDS_EOL					                    1187
#define IDS_NICKNAME				                1188
#define IDS_ALIAS_ID				                1189
#define IDS_ALIAS_OF				                1190
#define IDS_MEMORY					                1191
#define IDS_NONAME					                1192
#define IDS_EUDORA_NAME			                    1193
#define IDS_IMPORT_BUTTON                           1194
#define IDS_EUDORA_SUBDIR_NAME                      1195
#define IDS_EUDORA_GENERIC_SUFFIX                   1196
#define IDS_EUDORA_32_REGKEY                        1197
#define IDS_EUDORA_DEFAULT_INSTALL                  1198
#define IDS_NETSCAPE_ADDRESSBOOK                    1199

// String Identifiers
#define IDS_STATE_LOGGING_IN            1500
#define IDS_STATE_IMPORT_IDLE           1501
#define IDS_STATE_IMPORT_MU             1502
#define IDS_STATE_IMPORT_DL             1503
#define IDS_STATE_IMPORT_ERROR          1504
#define IDS_STATE_IMPORT_CANCEL         1505
#define IDS_STATE_IMPORT_COMPLETE       1506
#define IDS_STATE_EXPORT_IDLE           1511
#define IDS_STATE_EXPORT_MU             1512
#define IDS_STATE_EXPORT_DL             1513
#define IDS_STATE_EXPORT_ERROR          1514
#define IDS_STATE_EXPORT_CANCEL         1515
#define IDS_STATE_EXPORT_COMPLETE       1516
#define IDS_REPLACE_MESSAGE_IMPORT_1    1530
#define IDS_REPLACE_MESSAGE_IMPORT_2    1531
#define IDS_REPLACE_MESSAGE_EXPORT_1    1532
#define IDS_REPLACE_MESSAGE_EXPORT_2    1533
#define IDS_ERROR_MAPI_LOGON            1534
#define IDS_ERROR_EMAIL_ADDRESS_1       1535
#define IDS_ERROR_EMAIL_ADDRESS_2       1536
#define IDS_ERROR_GENERAL               1537
#define IDS_ERROR_NO_SUPPORT            1538
#define IDS_MESSAGE_IMPORTING_DL        1539
#define IDS_PAB                         1540
#define IDS_ERROR_DLL_NOT_FOUND         1541
#define IDS_ERROR_DLL_INVALID           1542
#define IDS_ERROR_DLL_EXCEPTION         1543
#define IDS_ERROR_MAPI_DLL_NOT_FOUND    1544
#define IDS_BUTTON_CANCEL               1545
#define IDS_BUTTON_CLOSE                1546
#define IDS_APP_TITLE                   1547
#define IDS_MESSAGE_EXPORTING_DL        1548
#define IDS_CSV                         1549
#define IDS_CSV_FILE_SPEC               1550
#define IDE_CSV_EXPORT_FILE_ERROR       1551
#define IDE_CSV_EXPORT_FILE_EXISTS      1552
#define IDS_CSV_EXPORT_PICK_FIELDS      1553
#define IDE_CSV_IMPORT_FILE_ERROR       1554
#define IDS_CSV_IMPORT_MAP_FIELDS       1555
#define IDS_CSV_IMPORT_HEADER_CSV       1556
#define IDS_CSV_IMPORT_HEADER_WAB       1557
#define IDS_CSV_CHANGE_MAPPING_TEXT_FIELD 1558
#define IDE_CSV_NO_COLUMNS              1559
#define IDS_CSV_COLUMN                  1560
#define IDS_ERROR_NOT_ENOUGH_MEMORY     1561
#define IDS_ERROR_NOT_ENOUGH_DISK       1562
#define IDS_MESSAGE_TITLE               1563
#define IDS_NO_WAB                      1564
#define IDS_TEXT_FILE_SPEC                          1566
#define IDE_LDIF_IMPORT_FILE_ERROR                  1567
#define IDS_LDIF_FILE_SPEC                          1568
#define IDS_MESS_FILE_SPEC                          1569
#define IDS_STATE_IMPORT_ERROR_FILEOPEN             1570
#define IDS_STATE_EXPORT_ERROR_NOPAB                1571
#define IDS_STATE_IMPORT_ERROR_NOPAB                1572

//
// Property Name Strigns
//
#define IDS_FIRST_EXPORT_PROP           1600

// Personal Pane
#define ids_ExportGivenName                     IDS_FIRST_EXPORT_PROP + 0
#define ids_ExportSurname                       IDS_FIRST_EXPORT_PROP + 1
#define ids_ExportMiddleName                    IDS_FIRST_EXPORT_PROP + 2
#define ids_ExportDisplayName                   IDS_FIRST_EXPORT_PROP + 3
#define ids_ExportNickname                      IDS_FIRST_EXPORT_PROP + 4
#define ids_ExportEmailAddress                  IDS_FIRST_EXPORT_PROP + 5

// Home Pane
#define ids_ExportHomeAddressStreet             IDS_FIRST_EXPORT_PROP + 6
#define ids_ExportHomeAddressCity               IDS_FIRST_EXPORT_PROP + 7
#define ids_ExportHomeAddressPostalCode         IDS_FIRST_EXPORT_PROP + 8
#define ids_ExportHomeAddressState              IDS_FIRST_EXPORT_PROP + 9
#define ids_ExportHomeAddressCountry            IDS_FIRST_EXPORT_PROP + 10
#define ids_ExportHomeTelephoneNumber           IDS_FIRST_EXPORT_PROP + 11
#define ids_ExportHomeFaxNumber                 IDS_FIRST_EXPORT_PROP + 12
#define ids_ExportCellularTelephoneNumber       IDS_FIRST_EXPORT_PROP + 13
#define ids_ExportPersonalHomePage              IDS_FIRST_EXPORT_PROP + 14

// Business Pane
#define ids_ExportBusinessAddressStreet         IDS_FIRST_EXPORT_PROP + 15
#define ids_ExportBusinessAddressCity           IDS_FIRST_EXPORT_PROP + 16
#define ids_ExportBusinessAddressPostalCode     IDS_FIRST_EXPORT_PROP + 17
#define ids_ExportBusinessAddressStateOrProvince IDS_FIRST_EXPORT_PROP + 18
#define ids_ExportBusinessAddressCountry        IDS_FIRST_EXPORT_PROP + 19
#define ids_ExportBusinessHomePage              IDS_FIRST_EXPORT_PROP + 20
#define ids_ExportBusinessTelephoneNumber       IDS_FIRST_EXPORT_PROP + 21
#define ids_ExportBusinessFaxNumber             IDS_FIRST_EXPORT_PROP + 22
#define ids_ExportPagerTelephoneNumber          IDS_FIRST_EXPORT_PROP + 23
#define ids_ExportCompanyName                   IDS_FIRST_EXPORT_PROP + 24
#define ids_ExportTitle                         IDS_FIRST_EXPORT_PROP + 25
#define ids_ExportDepartmentName                IDS_FIRST_EXPORT_PROP + 26
#define ids_ExportOfficeLocation                IDS_FIRST_EXPORT_PROP + 27

// Notes Pane
#define ids_ExportComment                       IDS_FIRST_EXPORT_PROP + 28
#define IDS_LAST_EXPORT_PROP                    ids_ExportComment
#define NUM_EXPORT_PROPS                        (1 + (IDS_LAST_EXPORT_PROP - IDS_FIRST_EXPORT_PROP))
// these are additional props
#define ids_ExportConfServer                    IDS_FIRST_EXPORT_PROP + 29
#define NUM_MORE_EXPORT_PROPS                   NUM_EXPORT_PROPS+1

// Synonym string identifiers
#define IDS_FIRST_SYNONYM_STRING                1800
#define idsSynonymCount                         IDS_FIRST_SYNONYM_STRING + 0
#define idsSynonym001                           IDS_FIRST_SYNONYM_STRING + 1
#define idsSynonym002                           IDS_FIRST_SYNONYM_STRING + 2
#define idsSynonym003                           IDS_FIRST_SYNONYM_STRING + 3
#define idsSynonym004                           IDS_FIRST_SYNONYM_STRING + 4
#define idsSynonym005                           IDS_FIRST_SYNONYM_STRING + 5
#define idsSynonym006                           IDS_FIRST_SYNONYM_STRING + 6
#define idsSynonym007                           IDS_FIRST_SYNONYM_STRING + 7
#define idsSynonym008                           IDS_FIRST_SYNONYM_STRING + 8
#define idsSynonym009                           IDS_FIRST_SYNONYM_STRING + 9
#define idsSynonym010                           IDS_FIRST_SYNONYM_STRING + 10
#define idsSynonym011                           IDS_FIRST_SYNONYM_STRING + 11
#define idsSynonym012                           IDS_FIRST_SYNONYM_STRING + 12
#define idsSynonym013                           IDS_FIRST_SYNONYM_STRING + 13
#define idsSynonym014                           IDS_FIRST_SYNONYM_STRING + 14
#define idsSynonym015                           IDS_FIRST_SYNONYM_STRING + 15
#define idsSynonym016                           IDS_FIRST_SYNONYM_STRING + 16
#define idsSynonym017                           IDS_FIRST_SYNONYM_STRING + 17
#define idsSynonym018                           IDS_FIRST_SYNONYM_STRING + 18
#define idsSynonym019                           IDS_FIRST_SYNONYM_STRING + 19
#define idsSynonym020                           IDS_FIRST_SYNONYM_STRING + 20
#define idsSynonym021                           IDS_FIRST_SYNONYM_STRING + 21
#define idsSynonym022                           IDS_FIRST_SYNONYM_STRING + 22
#define idsSynonym023                           IDS_FIRST_SYNONYM_STRING + 23
#define idsSynonym024                           IDS_FIRST_SYNONYM_STRING + 24
#define idsSynonym025                           IDS_FIRST_SYNONYM_STRING + 25
#define idsSynonym026                           IDS_FIRST_SYNONYM_STRING + 26
#define idsSynonym027                           IDS_FIRST_SYNONYM_STRING + 27
#define idsSynonym028                           IDS_FIRST_SYNONYM_STRING + 28
#define idsSynonym029                           IDS_FIRST_SYNONYM_STRING + 29
#define idsSynonym030                           IDS_FIRST_SYNONYM_STRING + 30


// ICON Identifiers
#define IDI_WabMig                      4002

// Bitmap Identifiers
#define IDB_CHECKS                      4100
#define IDB_WIZARD                      4101


// State Identifiers
#define ID_STATE_IMPORT_MU              3000
#define ID_STATE_IMPORT_NEXT_MU         3001
#define ID_STATE_IMPORT_DL              3002
#define ID_STATE_IMPORT_NEXT_DL         3003
#define ID_STATE_IMPORT_FINISH          3004
#define ID_STATE_IMPORT_ERROR           3005
#define ID_STATE_IMPORT_CANCEL          3006
#define ID_STATE_EXPORT_MU              3010
#define ID_STATE_EXPORT_NEXT_MU         3011
#define ID_STATE_EXPORT_DL              3012
#define ID_STATE_EXPORT_NEXT_DL         3013
#define ID_STATE_EXPORT_FINISH          3014
#define ID_STATE_EXPORT_ERROR           3015
#define ID_STATE_EXPORT_CANCEL          3016

// Static Identifiers
#define IDC_STATIC                      -1


/*****************************************************************************
-
-   Additional Resources for WABFind.dll
-
******************************************************************************/

#define IDI_INETFIND	    1641   /* My main icon */
#define IDM_ONTHEINTERNET	1642   /* Our sole menu item */
#define IDS_ONTHEINTERNET	1643
#define IDS_FINDHELP		1644
#define IDS_PEOPLE          1645
#define IDS_FORPEOPLE       1646
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\btnbar.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     BtnBar.h
//
//  PURPOSE:    Defines a class that can be used as a generic button bar.
//

#ifndef __BTNBAR_H__
#define __BTNBAR_H__

static const TCHAR    c_szButtonBar[] = TEXT("WABButtonBar");
static const int      c_cxButtons = 20;
static const COLORREF c_crMask = RGB(255, 0, 255);
static COLORREF g_clrSelText = RGB(255, 0, 0);
static COLORREF g_clrText = RGB(0, 0, 0);


// BTNCREATEPARAMS: This structure is used to pass information about each
//                  button to the CButtonBar::Create() function.  
typedef struct tagBTNCREATEPARAMS
{
    UINT id;            // WM_COMMAND ID to be sent to the parent when pressed
    UINT iIcon;         // Index of the icon in the image list to display
    UINT idsLabel;      // String resource ID of the title text for the button
} BTNCREATEPARAMS, *PBTNCREATEPARAMS;



HWND CBB_Create(    HWND hwndParent, 
                    UINT idButtons, 
                    UINT idHorzBackground, 
                    PBTNCREATEPARAMS pBtnCreateParams, 
                    UINT cParams);
static LRESULT CALLBACK CBB_ButtonBarProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void CBB_OnPaint(HWND hwnd);
void CBB_OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags);
void CBB_OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags);
void CBB_OnTimer(HWND hwnd, UINT id);
int CBB_OnMouseActivate(HWND hwnd, HWND hwndTopLevel, UINT codeHitTest, UINT msg);
   


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\abroot.c ===
/*
 *      ABROOT.C
 *
 *      IMAPIContainer implementation for the address book's root
 *      container.
 */

#include "_apipch.h"

extern SPropTagArray sosPR_ROWID;

/*
 *  Root jump table is defined here...
 */

ROOT_Vtbl vtblROOT =
{
    VTABLE_FILL
    (ROOT_QueryInterface_METHOD *)  CONTAINER_QueryInterface,
    (ROOT_AddRef_METHOD *)          WRAP_AddRef,
    (ROOT_Release_METHOD *)         CONTAINER_Release,
    (ROOT_GetLastError_METHOD *)    IAB_GetLastError,
    (ROOT_SaveChanges_METHOD *)     WRAP_SaveChanges,
    (ROOT_GetProps_METHOD *)        WRAP_GetProps,
    (ROOT_GetPropList_METHOD *)     WRAP_GetPropList,
    (ROOT_OpenProperty_METHOD *)    CONTAINER_OpenProperty,
    (ROOT_SetProps_METHOD *)        WRAP_SetProps,
    (ROOT_DeleteProps_METHOD *)     WRAP_DeleteProps,
    (ROOT_CopyTo_METHOD *)          WRAP_CopyTo,
    (ROOT_CopyProps_METHOD *)       WRAP_CopyProps,
    (ROOT_GetNamesFromIDs_METHOD *) WRAP_GetNamesFromIDs,
    (ROOT_GetIDsFromNames_METHOD *) WRAP_GetIDsFromNames,
    ROOT_GetContentsTable,
    ROOT_GetHierarchyTable,
    ROOT_OpenEntry,
    ROOT_SetSearchCriteria,
    ROOT_GetSearchCriteria,
    ROOT_CreateEntry,
    ROOT_CopyEntries,
    ROOT_DeleteEntries,
    ROOT_ResolveNames
};


//
//  Interfaces supported by this object
//
#define ROOT_cInterfaces 3
LPIID ROOT_LPIID[ROOT_cInterfaces] =
{
    (LPIID)&IID_IABContainer,
    (LPIID)&IID_IMAPIContainer,
    (LPIID)&IID_IMAPIProp
};

// Registry strings
const LPTSTR szWABKey                   = TEXT("Software\\Microsoft\\WAB");

// PR_AB_PROVIDER_ID for Outlook
static const MAPIUID muidCAB = {0xfd,0x42,0xaa,0x0a,0x18,0xc7,0x1a,0x10,0xe8,0x85,0x0B,0x65,0x1C,0x24,0x00,0x00};

/*
-
- SetContainerlpProps
*
*   The ROOT container will have a bunch of entries with props for each entry
*   The props are set in one place here 
*
    lpProps - LPSPropValue array in which we are storing the props
    lpszName - Container name
    iRow    - Row of this entry in the table (?)
    cb, lpb - entryid of the container
    lpEID   - alternat way of passing in the EID
    ulContainerFlags - any flags we want to cache on the container
    ulDepth ?
    bProviderID ?
    bLDAP - identifies LDAP containers which need some extra props
    fLDAPResolve - whether the LDAP container is used for name resolution or not

*/
void SetContainerlpProps(LPSPropValue lpProps, LPTSTR lpszName, ULONG iRow,
                         ULONG cb, LPBYTE lpb, LPSBinary lpEID,
                         ULONG ulContainerFlags,
                         ULONG ulDepth, BOOL bProviderID,
                         ULONG ulFlags,
                         BOOL bLDAP, BOOL fLDAPResolve)
{
    LPSTR lpszNameA = NULL;
    
    if(!(ulFlags & MAPI_UNICODE)) // <note> this assumes UNICODE is defined
        ScWCToAnsiMore((LPALLOCATEMORE) (&MAPIAllocateMore), lpProps, lpszName, &lpszNameA);

    DebugTrace(TEXT("Adding root-table container:%s\n"),lpszName);

    lpProps[ircPR_DISPLAY_TYPE].ulPropTag = PR_DISPLAY_TYPE;
    lpProps[ircPR_DISPLAY_TYPE].Value.l = DT_LOCAL;

    lpProps[ircPR_OBJECT_TYPE].ulPropTag = PR_OBJECT_TYPE;
    lpProps[ircPR_OBJECT_TYPE].Value.l = MAPI_ABCONT;

    lpProps[ircPR_ROWID].ulPropTag = PR_ROWID;
    lpProps[ircPR_ROWID].Value.l = iRow;

    lpProps[ircPR_DEPTH].ulPropTag = PR_DEPTH;
    lpProps[ircPR_DEPTH].Value.l = ulDepth;

    lpProps[ircPR_CONTAINER_FLAGS].ulPropTag = PR_CONTAINER_FLAGS;
    lpProps[ircPR_CONTAINER_FLAGS].Value.l = ulContainerFlags; 

    if(bLDAP)
    {
        if(ulFlags & MAPI_UNICODE) // <note> this assumes UNICODE is defined
        {
            lpProps[ircPR_WAB_LDAP_SERVER].ulPropTag = PR_WAB_LDAP_SERVER;
            lpProps[ircPR_WAB_LDAP_SERVER].Value.lpszW = lpszName;
        }
        else
        {
            lpProps[ircPR_WAB_LDAP_SERVER].ulPropTag =  CHANGE_PROP_TYPE( PR_WAB_LDAP_SERVER, PT_STRING8);
            lpProps[ircPR_WAB_LDAP_SERVER].Value.lpszA = lpszNameA;
        }

        lpProps[ircPR_WAB_RESOLVE_FLAG].ulPropTag = PR_WAB_RESOLVE_FLAG;
        lpProps[ircPR_WAB_RESOLVE_FLAG].Value.b = (USHORT) !!fLDAPResolve;
    }
    else
    {
        lpProps[ircPR_WAB_LDAP_SERVER].ulPropTag = PR_NULL;
        lpProps[ircPR_WAB_RESOLVE_FLAG].ulPropTag = PR_NULL;
    }

    if(ulFlags & MAPI_UNICODE) // <note> this assumes UNICODE is defined
    {
        lpProps[ircPR_DISPLAY_NAME].ulPropTag = PR_DISPLAY_NAME;
        lpProps[ircPR_DISPLAY_NAME].Value.lpszW = lpszName;
    }
    else
    {
       lpProps[ircPR_DISPLAY_NAME].ulPropTag = CHANGE_PROP_TYPE( PR_DISPLAY_NAME, PT_STRING8);
        lpProps[ircPR_DISPLAY_NAME].Value.lpszA = lpszNameA;
    }

    if(bProviderID)
    {
        lpProps[ircPR_AB_PROVIDER_ID].ulPropTag = PR_AB_PROVIDER_ID;
        lpProps[ircPR_AB_PROVIDER_ID].Value.bin.cb = sizeof(MAPIUID);
        lpProps[ircPR_AB_PROVIDER_ID].Value.bin.lpb = (LPBYTE)&muidCAB;
    } else 
    {
        lpProps[ircPR_AB_PROVIDER_ID].ulPropTag = PR_NULL;
    }

    lpProps[ircPR_ENTRYID].ulPropTag = PR_ENTRYID;
    if(lpEID)
        lpProps[ircPR_ENTRYID].Value.bin = *lpEID;
    else
    {
        lpProps[ircPR_ENTRYID].Value.bin.cb = cb;
        lpProps[ircPR_ENTRYID].Value.bin.lpb = lpb;
    }

    // Make certain we have proper indicies.
    // For now, we will equate PR_INSTANCE_KEY and PR_RECORD_KEY to PR_ENTRYID.
    lpProps[ircPR_INSTANCE_KEY].ulPropTag = PR_INSTANCE_KEY;
    lpProps[ircPR_INSTANCE_KEY].Value.bin.cb = lpProps[ircPR_ENTRYID].Value.bin.cb;
    lpProps[ircPR_INSTANCE_KEY].Value.bin.lpb = lpProps[ircPR_ENTRYID].Value.bin.lpb;

    lpProps[ircPR_RECORD_KEY].ulPropTag = PR_RECORD_KEY;
    lpProps[ircPR_RECORD_KEY].Value.bin.cb = lpProps[ircPR_ENTRYID].Value.bin.cb;
    lpProps[ircPR_RECORD_KEY].Value.bin.lpb = lpProps[ircPR_ENTRYID].Value.bin.lpb;

}

/*
-   bIsDupeContainerName 
-
*   The Root_GetContentsTable fails badly if there are multiple containers
*   with the same index name because the Table methods can't handle it ..
*
*   Therefore, to prevent such problems, we double-check if a container name
*   is duplicated before adding it to the container list. 
*   
*/
BOOL bIsDupeContainerName(LPSRowSet lpsrs, LPTSTR lpszName)
{
    ULONG i = 0;
    BOOL bRet = FALSE;

    // walk through the rows one by one
    for(i=0;i<lpsrs->cRows;i++)
    {
        LPSPropValue lpProps = lpsrs->aRow[i].lpProps;
        
        if(!lpProps || !lpsrs->aRow[i].cValues)
            continue;

        if( lpProps[ircPR_DISPLAY_NAME].ulPropTag == PR_DISPLAY_NAME &&
            !lstrcmpi(lpProps[ircPR_DISPLAY_NAME].Value.LPSZ, lpszName))
        {
            DebugTrace(TEXT("Found dupe container name .. skipping ...\n"));
            bRet = TRUE;
            break;
        }
    }
    return bRet;
}


/***************************************************
 *
 *  The actual ABContainer methods
 */

/* ---------
 * IMAPIContainer
 */

/*************************************************************************
 *
 *
 -  ROOT_GetContentsTable
 -
 *
 *  ulFlags -   WAB_LOCAL_CONTAINERS means don't add the LDAP containers to this table
 *          Just do the local WAB containers
 *              WAB_NO_PROFILE_CONTAINERS means don't add the profile containers
 *          Just add a single local container that will have all the contents
 *
 */
STDMETHODIMP
ROOT_GetContentsTable(LPROOT lpROOT, ULONG ulFlags, LPMAPITABLE * lppTable)
{
    LPTABLEDATA lpTableData = NULL;
    HRESULT hResult = hrSuccess;
    SCODE sc;
    LPSRowSet lpSRowSet = NULL;
    LPSPropValue lpProps = NULL;
    ULONG i;
    ULONG iRow;
    ULONG cProps, cRows, colkci = 0, cwabci = 0;
    ULONG cLDAPContainers = 0;
    TCHAR szBuffer[MAX_PATH];
    IImnAccountManager2 * lpAccountManager = NULL;
    LPSERVER_NAME lpServerNames = NULL, lpNextServer;
	OlkContInfo *rgolkci, *rgwabci;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    BOOL bUserProfileContainersOnly = FALSE;
    BOOL bAllContactsContainerOnly = FALSE;

	// BUGBUG: This routine actually returns the Hierarchy table, not the
	// contents table, but too much code depends on this to change it right
	// now.
#ifdef  PARAMETER_VALIDATION
    // Check to see if it has a jump table
    if (IsBadReadPtr(lpROOT, sizeof(LPVOID))) {
        // No jump table found
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check to see that it's ROOTs jump table
    if (lpROOT->lpVtbl != &vtblROOT) {
        // Not my jump table
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags & ~(MAPI_DEFERRED_ERRORS|MAPI_UNICODE|WAB_LOCAL_CONTAINERS|WAB_NO_PROFILE_CONTAINERS)) {
        DebugTraceArg(ROOT_GetContentsTable, TEXT("Unknown flags"));
    //    return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (IsBadWritePtr(lppTable, sizeof(LPMAPITABLE))) {
        DebugTraceArg(ROOT_GetContentsTable, TEXT("Invalid Table parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif  // PARAMETER_VALIDATION

    EnterCriticalSection(&lpROOT->lpIAB->cs);

    // Create a table object
    // [PaulHi] 4/5/99  Use the Internal CreateTableData() function that takes 
    // the ulFlags and will deal with ANSI/UNICODE requests correctly
    sc = CreateTableData(
                NULL,
                (ALLOCATEBUFFER FAR *	) MAPIAllocateBuffer,
                (ALLOCATEMORE FAR *)	MAPIAllocateMore,
                MAPIFreeBuffer,
                NULL,
                TBLTYPE_DYNAMIC,
                PR_RECORD_KEY,
                (LPSPropTagArray)&ITableColumnsRoot,
                NULL,
                0,
                NULL,
                ulFlags,
                &lpTableData);
    if ( FAILED(sc) )
    {
        DebugTrace(TEXT("CreateTableData() failed %x\n"), sc);
        hResult = ResultFromScode(sc);
        goto exit;
    }       
    Assert(lpTableData);

    if(ulFlags & WAB_NO_PROFILE_CONTAINERS)
        bAllContactsContainerOnly = TRUE;

    if(ulFlags & MAPI_UNICODE)
        ((TAD *)lpTableData)->bMAPIUnicodeTable = TRUE;

    // Enumerate the LDAP accounts
    if(!(ulFlags & WAB_LOCAL_CONTAINERS))
    {
        cLDAPContainers = 0;
        if (! HR_FAILED(hResult = InitAccountManager(lpROOT->lpIAB, &lpAccountManager, NULL))) {
            // Count and enumerate LDAP servers to ServerList
            if (hResult = EnumerateLDAPtoServerList(lpAccountManager, &lpServerNames, &cLDAPContainers)) {
                DebugTrace(TEXT("EnumerateLDAPtoServerList -> %x\n"), GetScode(hResult));
                hResult = hrSuccess;    // not fatal
            }
        } else {
            DebugTrace(TEXT("InitAccountManager -> %x\n"), GetScode(hResult));
            hResult = hrSuccess;
        }
    }

    // If this is an outlook session then use the outlook's list of containers
    // as provided by outlook...
    if (pt_bIsWABOpenExSession) {
		colkci = lpROOT->lpIAB->lpPropertyStore->colkci;
		Assert(colkci);
		rgolkci = lpROOT->lpIAB->lpPropertyStore->rgolkci;
		Assert(rgolkci);
	} else
		colkci = 1;

    // If we have a user profile active, then dont return the virtual PAB folder
    // as part of this table .. only return the actual folders in the user's view
    // The test for this is that (1) Have Profiles enabled (2) Have a current user
    // and (3) The NO_PROFILE_CONTAINERS should not have been specified
    bUserProfileContainersOnly = (  bAreWABAPIProfileAware(lpROOT->lpIAB) && 
                                    bIsThereACurrentUser(lpROOT->lpIAB) &&
                                    !bAllContactsContainerOnly);

    // If we have Profile awareness and no NO_PROFILE flag, 
    // use the wab's list of folder
    if (bAreWABAPIProfileAware(lpROOT->lpIAB) && !bAllContactsContainerOnly) 
    {
		cwabci = lpROOT->lpIAB->cwabci;
		Assert(cwabci);
		rgwabci = lpROOT->lpIAB->rgwabci;
		Assert(rgwabci);
	} else
		cwabci = 1;

    // Since outlook and identity_profiles are mutually exclusive, we can
    // do '-1' here to remove whatever container we don't need
    // and if we don't want ldap containers, we can do another -1
    cRows = cwabci + colkci + cLDAPContainers - 1 - (bUserProfileContainersOnly?1:0); // Outlook and Profiles are mutually exclusive
    iRow = 0;                               // current row

    // Allocate the SRowSet
    if (FAILED(sc = MAPIAllocateBuffer(sizeof(SRowSet) + cRows * sizeof(SRow),
      &lpSRowSet))) {
        DebugTrace(TEXT("Allocation of SRowSet -> %x\n"), sc);
        hResult = ResultFromScode(sc);
        goto exit;
    }
	MAPISetBufferName(lpSRowSet, TEXT("Root_ContentsTable SRowSet"));
	//	Set each LPSRow to NULL so we can easily free on error
	ZeroMemory( lpSRowSet, (UINT) (sizeof(SRowSet) + cRows * sizeof(SRow)));

    lpSRowSet->cRows = cRows;

    cProps = ircMax;
    if (FAILED(sc = MAPIAllocateBuffer(ircMax * sizeof(SPropValue), &lpProps))) {
        DebugTrace(TEXT("ROOT_GetContentsTable: Allocation of props -> %x\n"), sc);
        hResult = ResultFromScode(sc);
        goto exit;
    }

    //
    // Add our PAB container
    //
    if(!bUserProfileContainersOnly)
    {
        // Load the display name from resource string
        if (!LoadString(hinstMapiX, IDS_ADDRBK_CAPTION, szBuffer, CharSizeOf(szBuffer))) 
            lstrcpy(szBuffer, szEmpty);
        {
            ULONG cb = 0;
            LPENTRYID lpb = NULL;
            if (HR_FAILED(hResult = CreateWABEntryID(WAB_PAB, NULL, NULL, NULL, 0, 0, lpProps, &cb, &lpb))) 
                goto exit;

            // Set props for the pab object
            SetContainerlpProps(lpProps, 
                    pt_bIsWABOpenExSession ? lpROOT->lpIAB->lpPropertyStore->rgolkci->lpszName : szBuffer, 
                    iRow,
                    cb, (LPBYTE)lpb, NULL,
                    AB_MODIFIABLE | AB_RECIPIENTS,
                    pt_bIsWABOpenExSession ? 1 : 0, 
                    pt_bIsWABOpenExSession ? TRUE : FALSE,
                    ulFlags,
                    FALSE, FALSE);
        }

        // Attach the props to the SRowSet
        lpSRowSet->aRow[iRow].lpProps = lpProps;
        lpSRowSet->aRow[iRow].cValues = cProps;
        lpSRowSet->aRow[iRow].ulAdrEntryPad = 0;

        iRow++;
    }

	//
	// Next, add any additional containers
	//
	for (i = 1; i < colkci; i++) {

		if (FAILED(sc = MAPIAllocateBuffer(ircMax * sizeof(SPropValue), &lpProps))) {
			DebugTrace(TEXT("ROOT_GetContentsTable: Allocation of props -> %x\n"), sc);
			hResult = ResultFromScode(sc);
			goto exit;
		}

        SetContainerlpProps(lpProps, 
                rgolkci[i].lpszName, iRow,
                0, NULL, rgolkci[i].lpEntryID,
                AB_MODIFIABLE | AB_RECIPIENTS,
                1, TRUE,
                ulFlags,
                FALSE, FALSE);

	    // Attach the props to the SRowSet
	    lpSRowSet->aRow[iRow].lpProps = lpProps;
	    lpSRowSet->aRow[iRow].cValues = cProps;
	    lpSRowSet->aRow[iRow].ulAdrEntryPad = 0;

		iRow++;
	}

	for (i = 1; i < cwabci; i++) 
    {

		if (FAILED(sc = MAPIAllocateBuffer(ircMax * sizeof(SPropValue), &lpProps))) {
			DebugTrace(TEXT("ROOT_GetContentsTable: Allocation of props -> %x\n"), sc);
			hResult = ResultFromScode(sc);
			goto exit;
		}

        SetContainerlpProps(lpProps, 
                rgwabci[i].lpszName, iRow,
                0, NULL, rgwabci[i].lpEntryID,
                AB_MODIFIABLE | AB_RECIPIENTS,
                1, TRUE,
                ulFlags,
                FALSE, FALSE);

	    // Attach the props to the SRowSet
	    lpSRowSet->aRow[iRow].lpProps = lpProps;
	    lpSRowSet->aRow[iRow].cValues = cProps;
	    lpSRowSet->aRow[iRow].ulAdrEntryPad = 0;

		iRow++;
	}

    //
    // Now, add the LDAP objects
    //
    lpNextServer = lpServerNames;

    for (i = 0; i < cLDAPContainers && lpNextServer; i++) 
    {
        UNALIGNED WCHAR *lpName = lpNextServer->lpszName;

        if (lpName) 
        {
            LDAPSERVERPARAMS sParams;

            if(bIsDupeContainerName(lpSRowSet, (LPTSTR) lpName))
            {
                lpSRowSet->cRows--;
                goto endloop;
            }

            //DebugTrace(TEXT("LDAP Server: %s\n"), lpNextServer->lpszName);
            cProps = ircMax;

            if (FAILED(sc = MAPIAllocateBuffer(ircMax * sizeof(SPropValue), &lpProps))) {
                DebugTrace(TEXT("ROOT_GetContentsTable: Allocation of props -> %x\n"), sc);
                hResult = ResultFromScode(sc);
                goto exit;
            }

            GetLDAPServerParams(lpNextServer->lpszName, &sParams);

            {
                ULONG cb = 0;
                LPENTRYID lpb = NULL;
                LPVOID pv = lpName;

                if (HR_FAILED(hResult = CreateWABEntryID(WAB_LDAP_CONTAINER,
                                      pv,       // server name
                                      NULL, NULL, 0, 0,
                                      lpProps, &cb, &lpb))) 
                {
                    goto exit;
                }

                SetContainerlpProps(lpProps, 
                        (LPTSTR) lpName, iRow,
                        cb, (LPBYTE)lpb, NULL,
                        AB_FIND_ON_OPEN | AB_UNMODIFIABLE,
                        0, FALSE,
                        ulFlags,
                        TRUE, sParams.fResolve);
            }

            FreeLDAPServerParams(sParams);

            // Attach the props to the SRowSet
            lpSRowSet->aRow[iRow].lpProps = lpProps;
            lpSRowSet->aRow[iRow].cValues = cProps;
            lpSRowSet->aRow[iRow].ulAdrEntryPad = 0;

            iRow++;
        }
endloop:
        lpNextServer = lpNextServer->lpNext;
    }


    // Add all this data we just created to the the Table.
    if (hResult = lpTableData->lpVtbl->HrModifyRows(lpTableData,
      0,    // ulFlags
      lpSRowSet)) {
        DebugTraceResult( TEXT("ROOT_GetContentsTable:HrModifyRows"), hResult);
        goto exit;
    }


    hResult = lpTableData->lpVtbl->HrGetView(lpTableData,
      NULL,                     // LPSSortOrderSet lpsos,
      ContentsViewGone,         //  CALLERRELEASE FAR * lpfReleaseCallback,
      0,                        //  ULONG                               ulReleaseData,
      lppTable);                //  LPMAPITABLE FAR *   lplpmt)

exit:

    while(lpServerNames)
    {
        lpNextServer = lpServerNames;
        lpServerNames = lpServerNames->lpNext;
        LocalFreeAndNull(&lpNextServer->lpszName);
        LocalFreeAndNull(&lpNextServer);
    }

    FreeProws(lpSRowSet);

    // Cleanup table if failure
    if (HR_FAILED(hResult)) {
        if (lpTableData) {
            UlRelease(lpTableData);
        }
    }

    LeaveCriticalSection(&lpROOT->lpIAB->cs);

    return(hResult);
}


/*************************************************************************
 *
 *
 -      ROOT_GetHierarchyTable
 -
 *  Returns the merge of all the root hierarchy tables
 *
 *
 *
 */

STDMETHODIMP
ROOT_GetHierarchyTable (LPROOT lpROOT,
        ULONG ulFlags,
        LPMAPITABLE * lppTable)
{
    LPTSTR lpszMessage = NULL;
    ULONG ulLowLevelError = 0;
    HRESULT hr = hrSuccess;

#ifdef  PARAMETER_VALIDATION
    // Validate parameters
    // Check to see if it has a jump table
    if (IsBadReadPtr(lpROOT, sizeof(LPVOID))) {
        // No jump table found
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check to see that it's ROOTs jump table
    if (lpROOT->lpVtbl != &vtblROOT) {
        // Not my jump table
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // See if I can set the return variable
    if (IsBadWritePtr (lppTable, sizeof (LPMAPITABLE))) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check flags:
    //   The only valid flags are CONVENIENT_DEPTH and MAPI_DEFERRED_ERRORS
    if (ulFlags & ~(CONVENIENT_DEPTH|MAPI_DEFERRED_ERRORS|MAPI_UNICODE)) {
        DebugTraceArg(ROOT_GetHierarchyTable, TEXT("Unknown flags used"));
    //    return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

#endif

	// BUGBUG: We use the code which is incorrectly in GetContentsTable...
    hr = ROOT_GetContentsTable(lpROOT, ulFlags & ~CONVENIENT_DEPTH, lppTable);

    DebugTraceResult(ROOT_GetHierarchyTable, hr);
    return(hr);
}


/*************************************************************************
 *
 *
 -  ROOT_OpenEntry
 -
 *  Just call ABP_OpenEntry
 *
 *
 *
 */
STDMETHODIMP
ROOT_OpenEntry(LPROOT lpROOT,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  LPCIID lpInterface,
  ULONG ulFlags,
  ULONG * lpulObjType,
  LPUNKNOWN * lppUnk)
{
#ifdef  PARAMETER_VALIDATION
    // Validate the object.
    if (BAD_STANDARD_OBJ(lpROOT, ROOT_, OpenEntry, lpVtbl)) {
        // jump table not large enough to support this method
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check the entryid parameter. It needs to be big enough to hold an entryid.
    // Null entryids are valid
/*
    if (lpEntryID) {
        if (cbEntryID < offsetof(ENTRYID, ab)
          || IsBadReadPtr((LPVOID) lpEntryID, (UINT)cbEntryID)) {
            DebugTraceArg(ROOT_OpenEntry, TEXT("lpEntryID fails address check"));
            return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
        }

        //NFAssertSz(FValidEntryIDFlags(lpEntryID->abFlags),
        //  TEXT("Undefined bits set in EntryID flags\n"));
    }
*/

    // Don't check the interface parameter unless the entry is something
    // MAPI itself handles. The provider should return an error if this
    // parameter is something that it doesn't understand.
    // At this point, we just make sure it's readable.

    if (lpInterface && IsBadReadPtr(lpInterface, sizeof(IID))) {
        DebugTraceArg(ROOT_OpenEntry, TEXT("lpInterface fails address check"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags & ~(MAPI_MODIFY | MAPI_DEFERRED_ERRORS | MAPI_BEST_ACCESS)) {
        DebugTraceArg(ROOT_OpenEntry, TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (IsBadWritePtr((LPVOID) lpulObjType, sizeof (ULONG))) {
        DebugTraceArg(ROOT_OpenEntry, TEXT("lpulObjType"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (IsBadWritePtr((LPVOID) lppUnk, sizeof (LPUNKNOWN))) {
        DebugTraceArg(ROOT_OpenEntry, TEXT("lppUnk"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif  // PARAMETER_VALIDATION

    // Should just call IAB::OpenEntry()...
    return(lpROOT->lpIAB->lpVtbl->OpenEntry(lpROOT->lpIAB,
      cbEntryID,
      lpEntryID,
      lpInterface,
      ulFlags,
      lpulObjType,
      lppUnk));
}


STDMETHODIMP
ROOT_SetSearchCriteria(LPROOT lpROOT,
  LPSRestriction lpRestriction,
  LPENTRYLIST lpContainerList,
  ULONG ulSearchFlags)
{

#ifdef PARAMETER_VALIDATION
    // Validate the object.
    if (BAD_STANDARD_OBJ(lpROOT, ROOT_, SetSearchCriteria, lpVtbl)) {
        // jump table not large enough to support this method
        DebugTraceArg(ROOT_SetSearchCriteria, TEXT("Bad object/vtble"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // ensure we can read the restriction
    if (lpRestriction && IsBadReadPtr(lpRestriction, sizeof(SRestriction))) {
        DebugTraceArg(ROOT_SetSearchCriteria, TEXT("Bad Restriction parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (FBadEntryList(lpContainerList)) {
        DebugTraceArg(ROOT_SetSearchCriteria, TEXT("Bad ContainerList parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulSearchFlags & ~(STOP_SEARCH | RESTART_SEARCH | RECURSIVE_SEARCH
      | SHALLOW_SEARCH | FOREGROUND_SEARCH | BACKGROUND_SEARCH)) {
        DebugTraceArg(ROOT_GetSearchCriteria, TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

#endif  // PARAMETER_VALIDATION

    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


STDMETHODIMP
ROOT_GetSearchCriteria(LPROOT lpROOT,
  ULONG ulFlags,
  LPSRestriction FAR * lppRestriction,
  LPENTRYLIST FAR * lppContainerList,
  ULONG FAR * lpulSearchState)
{
#ifdef PARAMETER_VALIDATION

   // Validate the object.
    if (BAD_STANDARD_OBJ(lpROOT, ROOT_, GetSearchCriteria, lpVtbl)) {
        // jump table not large enough to support this method
        DebugTraceArg(ROOT_GetSearchCriteria, TEXT("Bad object/vtble"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags & ~(MAPI_UNICODE)) {
        DebugTraceArg(ROOT_GetSearchCriteria, TEXT("Unknown Flags"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    // ensure we can write the restriction
    if (lppRestriction && IsBadWritePtr(lppRestriction, sizeof(LPSRestriction))) {
        DebugTraceArg(ROOT_GetSearchCriteria, TEXT("Bad Restriction write parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // ensure we can read the container list

    if (lppContainerList &&  IsBadWritePtr(lppContainerList, sizeof(LPENTRYLIST))) {
        DebugTraceArg(ROOT_GetSearchCriteria, TEXT("Bad ContainerList parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }


    if (lpulSearchState && IsBadWritePtr(lpulSearchState, sizeof(ULONG))) {
        DebugTraceArg(ROOT_GetSearchCriteria, TEXT("lpulSearchState fails address check"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
#endif  // PARAMETER_VALIDATION

        return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


//----------------------------------------------------------------------------
// Synopsis:    ROOT_CreateEntry()
//
// Description:
//                              If called from a OneOff container a OneOff MAIL_USER object
//                              is created via the use of any arbitrary template.
//                              CreateEntry is not supported from a ROOT container.
//
// Parameters:
// Returns:
// Effects:
//
// Notes:               OneOff EntryIDs contain MAPI_UNICODE flag information in
//                              the ulDataType member.
//
// Revision:
//----------------------------------------------------------------------------
STDMETHODIMP
ROOT_CreateEntry(LPROOT lpROOT,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  ULONG ulCreateFlags,
  LPMAPIPROP FAR * lppMAPIPropEntry)
{
    BYTE bType;

#ifdef PARAMETER_VALIDATION

    // Validate the object.
    if (BAD_STANDARD_OBJ(lpROOT, ROOT_, CreateEntry, lpVtbl)) {
        // jump table not large enough to support this method
        DebugTraceArg(ROOT_CreateEntry,  TEXT("Bad object/Vtbl"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check the entryid parameter. It needs to be big enough to hold an entryid.
    // Null entryid are bad
/*
    if (lpEntryID) {
        if (cbEntryID < offsetof(ENTRYID, ab)
          || IsBadReadPtr((LPVOID) lpEntryID, (UINT)cbEntryID)) {
            DebugTraceArg(ROOT_CreateEntry,  TEXT("lpEntryID fails address check"));
            return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
        }

        //NFAssertSz(FValidEntryIDFlags(lpEntryID->abFlags),
        //  "Undefined bits set in EntryID flags\n");
    } else {
        DebugTraceArg(ROOT_CreateEntry,  TEXT("lpEntryID NULL"));
        return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
    }
*/

    if (ulCreateFlags & ~(CREATE_CHECK_DUP_STRICT | CREATE_CHECK_DUP_LOOSE
      | CREATE_REPLACE | CREATE_MERGE)) {
        DebugTraceArg(ROOT_CreateEntry,  TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (IsBadWritePtr(lppMAPIPropEntry, sizeof(LPMAPIPROP))) {
        DebugTraceArg(ROOT_CreateEntry,  TEXT("Bad MAPI Property write parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif  // PARAMETER_VALIDATION

#ifdef NEVER
    if (lpROOT->ulType == AB_ROOT)
        return ResultFromScode(MAPI_E_NO_SUPPORT);
#endif // NEVER

    // What kind of entry are we creating?
    // Default is MailUser

    bType = IsWABEntryID(cbEntryID, lpEntryID, NULL, NULL, NULL, NULL, NULL);

    if (bType == WAB_DEF_MAILUSER || cbEntryID == 0) {
        //
        //  Create a new (in memory) entry and return it's mapiprop
        //
        return(HrNewMAILUSER(lpROOT->lpIAB, lpROOT->pmbinOlk, MAPI_MAILUSER, ulCreateFlags, lppMAPIPropEntry));
    } else if (bType == WAB_DEF_DL) {
        //
        // Create a new (in memory) distribution list and return it's mapiprop?
        return(HrNewMAILUSER(lpROOT->lpIAB, lpROOT->pmbinOlk, MAPI_DISTLIST, ulCreateFlags, lppMAPIPropEntry));
    } else {
        DebugTrace(TEXT("ROOT_CreateEntry got unknown template entryID\n"));
        return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
    }
}


/*
 -      CopyEntries
 -
 *      Copies a list of entries into this container...  Since you can't
 *      do that with this container we just return not supported.
 */

STDMETHODIMP
ROOT_CopyEntries(LPROOT lpROOT,
  LPENTRYLIST lpEntries,
  ULONG_PTR ulUIParam,
  LPMAPIPROGRESS lpProgress,
  ULONG ulFlags)
{
#ifdef PARAMETER_VALIDATION

    if (BAD_STANDARD_OBJ(lpROOT, ROOT_, CopyEntries, lpVtbl)) {
        //  jump table not large enough to support this method

        DebugTraceArg(ROOT_CopyEntries,  TEXT("Bad object/vtbl"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // ensure we can read the container list

    if (FBadEntryList(lpEntries)) {
        DebugTraceArg(ROOT_CopyEntries,  TEXT("Bad Entrylist parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulUIParam && !IsWindow((HWND)ulUIParam)) {
        DebugTraceArg(ROOT_CopyEntries,  TEXT("Invalid window handle"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (lpProgress && IsBadReadPtr(lpProgress, sizeof(IMAPIProgress))) {
        DebugTraceArg(ROOT_CopyEntries,  TEXT("Bad MAPI Progress parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags & ~(AB_NO_DIALOG | CREATE_CHECK_DUP_LOOSE)) {
        DebugTraceArg(ROOT_CreateEntry,  TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }
#endif  // PARAMETER_VALIDATION

    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


/*
 -  DeleteEntries
 -
 *
 *  Deletes entries within this container...  Funny that.  There really
 *  isn't a true container here.  Do we just say "Sure, that worked just
 *  fine" or "Sorry this operation not supported."  I don't think it really
 *  matters...  For now it's the former.
 */
STDMETHODIMP
ROOT_DeleteEntries (LPROOT lpROOT,
                                        LPENTRYLIST                     lpEntries,
                                        ULONG                           ulFlags)
{
    ULONG i;
    HRESULT hResult = hrSuccess;
    ULONG cDeleted = 0;
    ULONG cToDelete;
    SCODE sc;

#ifndef DONT_ADDREF_PROPSTORE
    if ((FAILED(sc = OpenAddRefPropertyStore(NULL, lpROOT->lpIAB->lpPropertyStore)))) {
        hResult = ResultFromScode(sc);
        goto exitNotAddRefed;
    }
#endif

#ifdef PARAMETER_VALIDATION
    if (BAD_STANDARD_OBJ(lpROOT, ROOT_, DeleteEntries, lpVtbl)) {
        //  jump table not large enough to support this method
        DebugTraceArg(ROOT_DeleteEntries,  TEXT("Bad object/vtbl"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // ensure we can read the container list
    if (FBadEntryList(lpEntries)) {
        DebugTraceArg(ROOT_DeleteEntries,  TEXT("Bad Entrylist parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags) {
        DebugTraceArg(ROOT_DeleteEntries,  TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

#endif  // PARAMETER_VALIDATION


    // List of entryids is in lpEntries.  This is a counted array of
    // entryid SBinary structs.

    cToDelete = lpEntries->cValues;


    // Delete each entry
    for (i = 0; i < cToDelete; i++) 
    {
        if(0 != IsWABEntryID(lpEntries->lpbin[i].cb,
                             (LPENTRYID) IntToPtr(lpEntries->lpbin[i].cb),
                             NULL, NULL, NULL, NULL, NULL)) 
        {
            DebugTrace(TEXT("CONTAINER_DeleteEntries got bad entryid of size %u\n"), lpEntries->lpbin[i].cb);
            continue;
        }

        hResult = DeleteCertStuff((LPADRBOOK)lpROOT->lpIAB, (LPENTRYID)lpEntries->lpbin[i].lpb, lpEntries->lpbin[i].cb);

        hResult = HrSaveHotmailSyncInfoOnDeletion((LPADRBOOK) lpROOT->lpIAB, &(lpEntries->lpbin[i]));

        if (HR_FAILED(hResult = DeleteRecord(lpROOT->lpIAB->lpPropertyStore->hPropertyStore,
                                            &(lpEntries->lpbin[i])))) {
            DebugTraceResult( TEXT("DeleteEntries: DeleteRecord"), hResult);
            continue;
        }
        cDeleted++;
    }

    if (! hResult) {
        if (cDeleted != cToDelete) {
            hResult = ResultFromScode(MAPI_W_PARTIAL_COMPLETION);
            DebugTrace(TEXT("DeleteEntries deleted %u of requested %u\n"), cDeleted, cToDelete);
        }
    }

#ifndef DONT_ADDREF_PROPSTORE
    ReleasePropertyStore(lpROOT->lpIAB->lpPropertyStore);
exitNotAddRefed:
#endif

    return(hResult);
}



STDMETHODIMP
ROOT_ResolveNames(      LPROOT                  lpRoot,
                                        LPSPropTagArray lptagaColSet,
                                        ULONG                   ulFlags,
                                        LPADRLIST               lpAdrList,
                                        LPFlagList              lpFlagList)
{
    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\advise.c ===
/*
 *	ADVISE.C
 *
 *	HrAllocAdviseSink
 *
 *	AdviseList helpers
 */

#include "_apipch.h"



#ifndef VTABLE_FILL
#define VTABLE_FILL
#endif

#if !defined(WIN32) || defined(MAC)

#ifndef InitializeCriticalSection
#define InitializeCriticalSection(cs)
#define DeleteCriticalSection(cs)
#define EnterCriticalSection(cs)
#define LeaveCriticalSection(cs)
#define CRITICAL_SECTION int
#endif
#endif

/*
 *	The next several routines implement an IMAPIAdviseSink object
 *	based on a callback function and context pointers.
 */

#undef	INTERFACE
#define INTERFACE struct _ADVS

#undef MAPIMETHOD_
#define MAPIMETHOD_(type, method) MAPIMETHOD_DECLARE(type, method, ADVS_)
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIADVISESINK_METHODS(IMPL)
#undef	MAPIMETHOD_
#define MAPIMETHOD_(type, method) STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(ADVS_) {
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIADVISESINK_METHODS(IMPL)
};

typedef struct _ADVS FAR *LPADVS;

typedef struct _ADVS {
    ADVS_Vtbl * lpVtbl;
    UINT cRef;
    LPVOID lpvContext;
    LPNOTIFCALLBACK lpfnCallback;
} ADVS;

ADVS_Vtbl vtblADVS = {
    VTABLE_FILL
    ADVS_QueryInterface,
    ADVS_AddRef,
    ADVS_Release,
    ADVS_OnNotify
};

#define VALIDATE_ADVS(m, p, v) \
    if (IsBadWritePtr((p), sizeof(ADVS)) || \
      IsBadReadPtr((p)->lpVtbl, sizeof(ADVS_Vtbl)) || \
      (p)->lpVtbl != &vtblADVS) { \
        DebugTraceArg(m,  TEXT("Invalid object pointer")); \
        return v; \
    }

STDMETHODIMP
ADVS_QueryInterface(LPADVS padvs,
  REFIID lpiid,
  LPVOID FAR *lppObject)
{
    VALIDATE_ADVS(ADVS_QueryInterface, padvs, ResultFromScode(E_INVALIDARG));
    if (IsBadReadPtr((LPIID)lpiid, sizeof(IID)) ||
      IsBadWritePtr(lppObject, sizeof(LPVOID))) {
        DebugTraceArg(ADVS_QueryInterface,  TEXT("fails address check"));
        return(ResultFromScode(E_INVALIDARG));
    }

    *lppObject = NULL;
    if (IsEqualMAPIUID((LPMAPIUID)lpiid, (LPMAPIUID)&IID_IUnknown) ||
      IsEqualMAPIUID((LPMAPIUID)lpiid, (LPMAPIUID)&IID_IMAPIAdviseSink)) {
        ++(padvs->cRef);
        *lppObject = padvs;
        return(hrSuccess);
    }

    return(ResultFromScode(E_NOINTERFACE));
}


STDMETHODIMP_(ULONG)
ADVS_AddRef(LPADVS padvs)
{
    VALIDATE_ADVS(ADVS_AddRef, padvs, 0L);
    return((ULONG)(++padvs->cRef));
}


STDMETHODIMP_(ULONG)
ADVS_Release(LPADVS padvs)
{
    HLH hlh;

    VALIDATE_ADVS(ADVS_Release, padvs, 0xFFFFFFFF);

    if (--(padvs->cRef) == 0) {
        if (hlh = HlhUtilities()) {
            LH_Free(hlh, padvs);
        } else {
            DebugTrace(TEXT("ADVS_Release: no heap left\n"));
        }

        return(0L);
    }

    return((ULONG)padvs->cRef);
}


STDMETHODIMP_(ULONG)
ADVS_OnNotify(LPADVS padvs,
  ULONG cNotif,
  LPNOTIFICATION lpNotif)
{
    VALIDATE_ADVS(ADVS_OnNotify, padvs, 0L);
//$     Enable when we put this in a DLL -- too many deps for the library
//$     if (FAILED(ScCountNotifications((int)cNotif, lpNotif, NULL))) {
//$         DebugTraceArg(ADVS_OnNotify,  TEXT("lpNotif fails address check"));
//$         return 0L;
//$     }

    return((*(padvs->lpfnCallback))(padvs->lpvContext, cNotif, lpNotif));
}


/*
 -	HrAllocAdviseSink
 -
 *	Purpose:
 *		Creates an IMAPIAdviseSink object based on an old-style
 *		notification callback function and context pointer.
 *
 *	Arguments:
 *		lpfnCallback		in		the notification callback
 *		lpvContext			in		arbitrary context for the
 *									callback
 *		lppAdviseSink		out		the returned AdviseSink object
 *
 *	Returns:
 *		HRESULT
 *
 *	Errors:
 *		out of memory
 *		parameter validation
 */
STDAPI
HrAllocAdviseSink(LPNOTIFCALLBACK lpfnCallback,
  LPVOID lpvContext,
  LPMAPIADVISESINK FAR *lppAdviseSink)
{
    LPADVS		padvs;
    HRESULT		hr = hrSuccess;
    HLH			hlh;

    if (IsBadCodePtr((FARPROC)lpfnCallback) ||
      IsBadWritePtr(lppAdviseSink, sizeof(LPMAPIADVISESINK))) {
        DebugTraceArg(HrAllocAdviseSink,  TEXT("invalid parameter"));
        return(ResultFromScode(E_INVALIDARG));
    }

    *lppAdviseSink = NULL;

    if (! (hlh = HlhUtilities())) {
        hr = ResultFromScode(MAPI_E_NOT_INITIALIZED);
        goto ret;
    }

    padvs = LH_Alloc(hlh, sizeof(ADVS));
    if (! padvs) {
        hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto ret;
    }

    padvs->lpVtbl = &vtblADVS;
    padvs->cRef = 1;
    padvs->lpvContext = lpvContext;
    padvs->lpfnCallback = lpfnCallback;

    *lppAdviseSink = (LPMAPIADVISESINK)padvs;

ret:
    DebugTraceResult(HrAllocAdviseSink, hr);
    return(hr);
}

#ifdef SINGLE_THREAD_ADVISE_SINK

/*
 *	Single-thread advise sink wrapper. This object wrapper forces
 *	OnNotify calls to happen on the thread in which it was created,
 *	by forwarding stuff to a window proc on that thread.
 */
#if defined(WIN16) || defined(MAC)

STDAPI
HrThisThreadAdviseSink(LPMAPIADVISESINK lpAdviseSink,
  LPMAPIADVISESINK FAR *lppAdviseSink)
{
//#ifdef	PARAMETER_VALIDATION
    if (FBadUnknown(lpAdviseSink)) {
        DebugTraceArg(HrThisThreadAdviseSink,  TEXT("lpAdviseSink fails address check"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
    if (IsBadWritePtr(lppAdviseSink, sizeof(LPMAPIADVISESINK))) {
        DebugTraceArg(HrThisThreadAdviseSink,  TEXT("lppAdviseSink fails address check"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
//#endif	

    UlAddRef(lpAdviseSink);
    *lppAdviseSink = lpAdviseSink;

    return(hrSuccess);
}

#else

//	Object goo

#undef	INTERFACE
#define	INTERFACE	struct _SAS

#undef MAPIMETHOD_
#define MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, SAS_)
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIADVISESINK_METHODS(IMPL)
#undef	MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(SAS_) {
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIADVISESINK_METHODS(IMPL)
};

typedef struct _SAS FAR *LPSAS;

typedef struct _SAS {
    SAS_Vtbl * lpVtbl;
    ULONG cRef;

    ULONG cActiveOnNotifies;
    LPMAPIADVISESINK pasOrig;
    HWND hwnd;

} SAS;

SAS_Vtbl vtblSAS =
{
    //	VTABLE_FILL		//	NI on the Mac
    SAS_QueryInterface,
    SAS_AddRef,
    SAS_Release,
    SAS_OnNotify
};

#define VALIDATE_SAS(m, p, v) \
    if (IsBadWritePtr((p), sizeof(SAS)) || \
      IsBadReadPtr((p)->lpVtbl, sizeof(SAS_Vtbl)) || \
      (p)->lpVtbl != &vtblSAS) { \
        DebugTraceArg(m,  TEXT("Invalid object pointer")); \
        return v; \
    }

typedef struct {
    LPMAPIADVISESINK pas;
    LPSAS psas;
    ULONG cb;               // maybe
    ULONG cnotif;
    NOTIFICATION		rgnotif[MAPI_DIM];
} FWDNOTIF, FAR *LPFWDNOTIF;

#define SizedFWDNOTIF(_c, _name) \
    struct _FWDNOTIF_ ## name { \
        LPMAPIADVISESINK	pas; \
        ULONG				cb; \
        ULONG				cnotif; \
        NOTIFICATION		rgnotif[_c]; \
    } _name

#define CbNewFWDNOTIF(_cnotif) \
    (offsetof(FWDNOTIF, rgnotif) + ((_cnotif)*sizeof(NOTIFICATION)))
#define CbFWDNOTIF(_pf) \
    (offsetof(FWDNOTIF, rgnotif) + (((_pf)->cnotif)*sizeof(NOTIFICATION)))

//	Window class globals

#define WND_FLAGS_KEY               0   // NYI
#define cbSTClsExtra                4
#define CLS_REFCOUNT_KEY            0
TCHAR szSTClassName[] =              TEXT("WMS ST Notif Class");

//	Window globals

#define cbSTWndExtra                4
#define WND_REFCOUNT_KEY            GWL_USERDATA
#define wmSingleThreadNotif         (WM_USER + 13)
TCHAR szSTWndFmt[] =                 TEXT("WMS ST Notif Window %08X %08X");
#define NameWindow(_s)              wsprintf(_s, szSTWndFmt, \
                                      GetCurrentProcessId(), \
                                      GetCurrentThreadId());


HRESULT		HrWindowUp(HWND *phwnd);
void		WindowRelease(HWND);
LRESULT CALLBACK STWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);


STDAPI
HrThisThreadAdviseSink(LPMAPIADVISESINK pas,
  LPMAPIADVISESINK FAR *ppas)
{
    HRESULT hr;
    LPSAS psas = NULL;

//#ifdef	PARAMETER_VALIDATION
    if (FBadUnknown(pas)) {
        DebugTraceArg(HrThisThreadAdviseSink,  TEXT("lpAdviseSink fails address check"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
    if (IsBadWritePtr(ppas, sizeof(LPMAPIADVISESINK))) {
        DebugTraceArg(HrThisThreadAdviseSink,  TEXT("lppAdviseSink fails address check"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
//#endif	

    if (HR_FAILED(hr = ResultFromScode((MAPIAllocateBuffer(sizeof(SAS), &psas))))) {
        goto ret;
    }

    MAPISetBufferName(psas,  TEXT("ST Advise Sink"));
    ZeroMemory(psas, sizeof(SAS));
    psas->lpVtbl = &vtblSAS;
    psas->cRef = 1;
    psas->cActiveOnNotifies = 0;

    if (hr = HrWindowUp(&psas->hwnd)) {
        goto ret;
    }

    //	All OK, return the new object
    UlAddRef(pas);
    psas->pasOrig = pas;
    *ppas = (LPMAPIADVISESINK) psas;

ret:
    if (HR_FAILED(hr)) {
        MAPIFreeBuffer(psas);
    }

    DebugTraceResult(HrThisThreadAdviseSink, hr);
    return(hr);
}

HRESULT
HrWindowUp(HWND * phwnd)
{
    HRESULT		hr = hrSuccess;
    CHAR		szWndName[64];
    WNDCLASSA	wc;
    HWND		hwnd;
    LONG		cRef;
    HINSTANCE 	hinst;

    //	Find the window for this thread, if it exists
    NameWindow(szWndName);
    hwnd = FindWindow(szSTClassName, szWndName);

    if (hwnd) {
        //	It already exists -- add a ref to it
        cRef = GetWindowLong(hwnd, WND_REFCOUNT_KEY);
        Assert(cRef != 0L);
        SideAssert(SetWindowLong(hwnd, WND_REFCOUNT_KEY, cRef+1) == cRef);
    } else {
        //	We have to create the window.

        hinst = hinstMapiXWAB;

        if (!GetClassInfo(hinst, szSTClassName, &wc)) {
            //	We have to register the class too.
            ZeroMemory(&wc, sizeof(WNDCLASSA));
            wc.style = CS_GLOBALCLASS;
            wc.lpfnWndProc = STWndProc;
            wc.cbClsExtra = cbSTClsExtra;
            wc.cbWndExtra = cbSTWndExtra;
            wc.hInstance = hinst;
            wc.lpszClassName = szSTClassName;

            RegisterClassA(&wc);
        }

        hwnd = CreateWindowA(szSTClassName,
          szWndName,
          WS_POPUP,	//	bug 6111: pass on Win95 hotkey
          0, 0, 0, 0,
          NULL, NULL, hinst, NULL);
        if (hwnd) {	
            SetWindowLong(hwnd, WND_REFCOUNT_KEY, 1);
            cRef = (LONG) GetClassLong(hwnd, CLS_REFCOUNT_KEY);
            SideAssert((LONG) SetClassLong(hwnd, CLS_REFCOUNT_KEY, cRef+1) == cRef);
        } else {
            hr = ResultFromScode(MAPI_E_NOT_INITIALIZED);
            goto ret;
        }
    }

    *phwnd = hwnd;

ret:
    DebugTraceResult(HrWindowUp, hr);
    return(hr);
}


void
WindowRelease(HWND hwnd)
{
    CHAR	szWndName[64];
    LONG	cRefWnd;
    LONG	cRefCls;

    //	The thread-safeness of this call is not obvious to
    //	the casual observer, so it will NOT be left as an
    //	exercise at the end of the development cycle.
    //
    //	Namely, you do not have access to a window's data
    //	from any thread other than the owning thread.  This
    //	should not suprise anyone (although it did me...).
    //	So in debug builds, we will assert if we call this
    //	from any thread that is not the owning one.  What
    //	this means is that we cannot release on a thread
    //	that does not own the SAS.
    //
    if (! hwnd) {
        //	Find the window for this thread, if it exists
        NameWindow(szWndName);
        hwnd = FindWindow(szSTClassName, szWndName);
    }
#ifdef	DEBUG
    else {
        //	Find the window for this thread, if it exists
        NameWindow(szWndName);
        Assert (hwnd == FindWindow(szSTClassName, szWndName));
    }
#endif	// DEBUG
		
    if (! hwnd) {
        return;
    }

    cRefWnd = GetWindowLong(hwnd, WND_REFCOUNT_KEY);
    cRefCls = (LONG) GetClassLong(hwnd, CLS_REFCOUNT_KEY);
    if (cRefWnd > 1) {
        //	Just deref it
        SideAssert(SetWindowLong(hwnd, WND_REFCOUNT_KEY, cRefWnd-1) == cRefWnd);
    } else {
        SideAssert((LONG) SetClassLong(hwnd, CLS_REFCOUNT_KEY, cRefCls-1) == cRefCls);
        DestroyWindow(hwnd);
        if (cRefCls == 1) {
            UnregisterClass(szSTClassName, hinstMapiXWAB);
        }
    }
}


LRESULT CALLBACK
STWndProc(HWND hwnd,
  UINT msg,
  WPARAM wParam,
  LPARAM lParam)
{
    LPFWDNOTIF	pfwd = NULL;

    if (msg != wmSingleThreadNotif) {
        return(DefWindowProc(hwnd, msg, wParam, lParam));
    } else {
        //	The wparam should be 0.
        //	The lparam is the address of a forwarded notification.
        //	First, validate the structure.
        pfwd = (LPFWDNOTIF)lParam;
        if (IsBadReadPtr(pfwd, CbNewFWDNOTIF(0))) {
            DebugTrace(TEXT("STWndProc: totally invalid FWDNOTIF\n"));
            pfwd = NULL;
            goto ret;
        }
        if (IsBadReadPtr(pfwd, (UINT) pfwd->cb)) {
            DebugTrace(TEXT("STWndProc: partially invalid FWDNOTIF\n"));
            pfwd = NULL;
            goto ret;
        }
        if (FBadUnknown(pfwd->pas)) {
            DebugTrace(TEXT("STWndProc: invalid advise sink\n"));
            goto ret;
        }

        //
        //  Only call OnNotify if there are other references to the SAS other than
        //  those made specifically for the PostMessage in SAS_OnNotify.
        //
        if (pfwd->psas->cRef > pfwd->psas->cActiveOnNotifies) {
            //	Forward the notification.
            pfwd->pas->lpVtbl->OnNotify(pfwd->pas, pfwd->cnotif, pfwd->rgnotif);
        }

        pfwd->psas->cActiveOnNotifies--;

        //	Release the contained advise object
        //
        UlRelease (pfwd->psas);

ret:
        MAPIFreeBuffer(pfwd);
    }
    return(0);
}


STDMETHODIMP
SAS_QueryInterface(LPSAS psas,
  REFIID lpiid,
  LPUNKNOWN FAR *ppunk)
{
// #ifdef	PARAMETER_VALIDATION
    VALIDATE_SAS(QueryInterface, psas, ResultFromScode(E_INVALIDARG));
    if (IsBadWritePtr(ppunk, sizeof(LPUNKNOWN))) {
        DebugTraceArg(SAS_QueryInterface,  TEXT("ppunk fails address check"));
        return(ResultFromScode(E_INVALIDARG));
    }
    *ppunk = NULL;
    if (IsBadReadPtr((LPIID) lpiid, sizeof(IID))) {
        DebugTraceArg(SAS_QueryInterface,  TEXT("lpiid fails address check"));
        return(ResultFromScode(E_INVALIDARG));
    }
// #endif	/* PARAMETER_VALIDATION */

    if (! memcmp(lpiid, &IID_IUnknown, sizeof(IID)) ||
      ! memcmp(lpiid, &IID_IMAPIAdviseSink, sizeof(IID))) {
        InterlockedIncrement((LONG *)&psas->cRef);
        *ppunk = (LPUNKNOWN) psas;
        return(hrSuccess);
    }

    return(ResultFromScode(E_NOINTERFACE));
}


STDMETHODIMP_(ULONG)
SAS_AddRef(LPSAS psas) {
    VALIDATE_SAS(AddRef, psas, 1);

    InterlockedIncrement((LONG *)&psas->cRef);
}


STDMETHODIMP_(ULONG)
SAS_Release(LPSAS psas)
{
    VALIDATE_SAS(SAS_Release, psas, 1);
    InterlockedDecrement((LONG *)&psas->cRef);

    if (psas->cRef) {
        return(psas->cRef);
    }

    WindowRelease(NULL);
    if (! FBadUnknown(psas->pasOrig)) {
        UlRelease(psas->pasOrig);
    } else {
        DebugTrace(TEXT("SAS_Release: pasOrig expired\n"));
    }
    MAPIFreeBuffer(psas);
    return(0);
}


STDMETHODIMP_(ULONG)
SAS_OnNotify(LPSAS psas,
  ULONG cnotif,
  LPNOTIFICATION rgnotif)
{
	ULONG		cb;
	SCODE		sc = S_OK;
	LPFWDNOTIF	pfwd = NULL;

//#ifdef	PARAMETER_VALIDATION
	VALIDATE_SAS(SAS_OnNotify, psas, 0);
	//	notifications validated below
//#endif

    if (! IsWindow(psas->hwnd)) {
        DebugTrace(TEXT("SAS_OnNotify: my window is dead!\n"));
        goto ret;
    }

    if (sc = ScCountNotifications((int) cnotif, rgnotif, &cb)) {
        DebugTrace(TEXT("SAS_OnNotify: ScCountNotifications returns %s\n"), SzDecodeScode(sc));
        goto ret;
    }
    if (sc = MAPIAllocateBuffer(cb + offsetof(FWDNOTIF, rgnotif), &pfwd)) {
        DebugTrace(TEXT("SAS_OnNotify: MAPIAllocateBuffer returns %s\n"), SzDecodeScode(sc));
        goto ret;
    }
    MAPISetBufferName(pfwd,  TEXT("ST Notification copy"));
    UlAddRef (psas);
    pfwd->psas = psas;
    pfwd->pas = psas->pasOrig;
    pfwd->cnotif = cnotif;
    (void) ScCopyNotifications((int) cnotif, rgnotif, pfwd->rgnotif, NULL);
    pfwd->cb = cb + offsetof(FWDNOTIF, rgnotif);	//	used?

    psas->cActiveOnNotifies++;

    if (! PostMessage(psas->hwnd, wmSingleThreadNotif, 0, (LPARAM) pfwd)) {
        DebugTrace(TEXT("SAS_OnNotify: PostMessage failed with %ld\n"), GetLastError());
        MAPIFreeBuffer(pfwd);
    }

ret:
    return(0);
}

#endif	/* WIN16 */

/*
 *	Advise list maintenance.
 *
 *	These functions maintain a list of advise sink objects together
 *	with the connection dwords used to get rid of them. Along with
 *	those two basic items, an additional interface pointer and type
 *	can be remembered; MAPIX uses these to forward Unadvise calls
 *	where necessary.
 *
 *	ScAddAdviseList
 *		Creates or resizes the advise list as necessary, and adds a new
 *		member. It fails if there is already an item in the list with the
 *		same ulConnection. Takes an IMalloc interface for memory; uses
 *		the standard one if none is supplied.
 *
 *	ScDelAdviseList
 *		Removes an item identified by its ulConnection from the advise
 *		list. Does not resize the list.
 *
 *	ScFindAdviseList
 *		Given the ulConnection of an item, returns a pointer into
 *		the advise list.
 *
 *	DestroyAdviseList
 *		What it says.
 */

#define cGrowItems 10

STDAPI_(SCODE)
ScAddAdviseList(LPVOID lpvReserved,
  LPADVISELIST FAR *lppList,
  LPMAPIADVISESINK lpAdvise,
  ULONG ulConnection,
  ULONG ulType,
  LPUNKNOWN lpParent)
{
    SCODE sc = S_OK;
    LPADVISELIST plist;
    LPADVISEITEM pitem;
    HLH hlh;

    // parameter validation

#ifdef	DEBUG
    if (lpvReserved) {
       DebugTrace(TEXT("ScAddAdviseList: pmalloc is unused, now reserved, pass NULL\n"));
    }
#endif	
	
    AssertSz(! IsBadWritePtr(lppList, sizeof(LPADVISELIST)),
       TEXT("lppList fails address check"));

    AssertSz(! *lppList || ! IsBadReadPtr(*lppList, offsetof(ADVISELIST, rgItems)),
       TEXT("*lppList fails address check"));

    AssertSz(! *lppList || ! IsBadReadPtr(*lppList, (UINT)CbADVISELIST(*lppList)),
       TEXT("*lppList fails address check"));

    AssertSz(lpAdvise && ! FBadUnknown(lpAdvise),
       TEXT("lpAdvise fails address check"));

    AssertSz(! lpParent || ! FBadUnknown(lpParent),
       TEXT("lpParent fails address check"));

    if (! (hlh = HlhUtilities())) {
        sc = MAPI_E_NOT_INITIALIZED;
        goto ret;
    }

    //	Ensure space is available for new item

    if (!(plist = *lppList)) {      //  Yup, =
        if (!(plist = LH_Alloc(hlh, CbNewADVISELIST(cGrowItems)))) {
            goto oom;
        }
        LH_SetName (hlh, plist,  TEXT("core: advise list"));

#if defined(WIN32) && !defined(MAC)
        if (!(plist->lpcs = LH_Alloc (hlh, sizeof(CRITICAL_SECTION)))) {
            goto oom;
        }
        memset (plist->lpcs, 0, sizeof(CRITICAL_SECTION));
        LH_SetName (hlh, plist,  TEXT("core: advise list critical section"));
#endif
        plist->cItemsMac = 0;
        plist->cItemsMax = cGrowItems;
        InitializeCriticalSection(plist->lpcs);
        EnterCriticalSection(plist->lpcs);
        *lppList = plist;
    } else {
        EnterCriticalSection(plist->lpcs);
    }

    if (plist->cItemsMac == plist->cItemsMax) {
        if (!(plist = LH_Realloc(hlh, plist,
          (UINT)CbNewADVISELIST(plist->cItemsMax + cGrowItems)))) {
            LeaveCriticalSection((*lppList)->lpcs);	//	plist is bad ptr
            goto oom;
        }
        plist->cItemsMax += cGrowItems;
        *lppList = plist;
    }

    //	Check for duplicate key
    for (pitem = &plist->rgItems[plist->cItemsMac - 1];
      pitem >= plist->rgItems;
      --pitem) {
        if (pitem->ulConnection == ulConnection) {
            sc = MAPI_E_BAD_VALUE;
            LeaveCriticalSection(plist->lpcs);
            goto ret;
        }
    }

    //	Add the new item

    pitem = &plist->rgItems[plist->cItemsMac++];
    pitem->lpAdvise = lpAdvise;
    pitem->ulConnection = ulConnection;
    pitem->ulType = ulType;
    pitem->lpParent = lpParent;

    LeaveCriticalSection(plist->lpcs);

    UlAddRef(lpAdvise);

ret:
    //	note: no LeaveCrit here because of error returns
    DebugTraceSc(ScAddAdviseList, sc);
    return(sc);

oom:
    if (! (*lppList) && plist) {
        LH_Free (hlh, plist);
    }

    sc = MAPI_E_NOT_ENOUGH_MEMORY;
    goto ret;
}


STDAPI_(SCODE)
ScDelAdviseList(LPADVISELIST lpList, ULONG ulConnection)
{
    SCODE sc = S_OK;
    LPADVISEITEM pitem;
    LPMAPIADVISESINK padvise;
#ifndef MAC
    FARPROC FAR *	pfp;
#endif

    AssertSz(!IsBadReadPtr(lpList, offsetof(ADVISELIST, rgItems)),
       TEXT("lpList fails address check"));
    AssertSz(!IsBadReadPtr(lpList, (UINT)CbADVISELIST(lpList)),
       TEXT("lpList fails address check"));

    EnterCriticalSection(lpList->lpcs);

    if (FAILED(sc = ScFindAdviseList(lpList, ulConnection, &pitem))) {
        goto ret;
    }

    Assert(pitem >= lpList->rgItems);
    Assert(pitem < lpList->rgItems + lpList->cItemsMac);
    SideAssert(padvise = pitem->lpAdvise);

    MoveMemory(pitem, pitem+1, sizeof(ADVISEITEM) *
      ((int)lpList->cItemsMac - (pitem + 1 - lpList->rgItems)));

    --(lpList->cItemsMac);

    if (!IsBadReadPtr(padvise, sizeof(LPVOID))
      &&	!IsBadReadPtr((pfp=(FARPROC FAR *)padvise->lpVtbl), 3*sizeof(FARPROC))
      &&	!IsBadCodePtr(pfp[2])) {
        LeaveCriticalSection(lpList->lpcs);
        UlRelease(padvise);
        EnterCriticalSection(lpList->lpcs);
    }

ret:
    LeaveCriticalSection(lpList->lpcs);
    DebugTraceSc(ScDelAdviseList, sc);
    return(sc);
}



STDAPI_(SCODE)
ScFindAdviseList(LPADVISELIST lpList,
  ULONG ulConnection,
  LPADVISEITEM FAR *lppItem)
{
    SCODE sc = MAPI_E_NOT_FOUND;
    LPADVISEITEM pitem;

    AssertSz(! IsBadReadPtr(lpList, offsetof(ADVISELIST, rgItems)),
       TEXT("lpList fails address check"));
    AssertSz(! IsBadReadPtr(lpList, (UINT)CbADVISELIST(lpList)),
       TEXT("lpList Failes addres check"));
    AssertSz(! IsBadWritePtr(lppItem, sizeof(LPADVISEITEM)),
       TEXT("lppItem fails address check"));

    *lppItem = NULL;

    EnterCriticalSection(lpList->lpcs);

    for (pitem = lpList->rgItems + lpList->cItemsMac - 1;
      pitem >= lpList->rgItems;
      --pitem) {
        if (pitem->ulConnection == ulConnection) {
            *lppItem = pitem;
            sc = S_OK;
            break;
        }
    }

    //	Assert that there are no duplicates of the found key
#ifdef	DEBUG
    {
        LPADVISEITEM pitemT;

        for (pitemT = lpList->rgItems; pitemT < pitem; ++pitemT) {
            Assert(pitemT->ulConnection != ulConnection);
        }
    }
#endif

    LeaveCriticalSection(lpList->lpcs);
    DebugTraceSc(ScFindAdviseList, sc);
    return(sc);
}

STDAPI_(void)
DestroyAdviseList(LPADVISELIST FAR *lppList)
{
    LPADVISELIST plist;
    HLH hlh;

    AssertSz(! IsBadWritePtr(lppList, sizeof(LPADVISELIST)),
       TEXT("lppList fails address check"));

    if (! *lppList) {
        return;
    }

    AssertSz(! IsBadReadPtr(*lppList, offsetof(ADVISELIST, rgItems)),
       TEXT("*lppList fails address check"));
    AssertSz(! IsBadReadPtr(*lppList, (UINT)CbADVISELIST(*lppList)),
       TEXT("*lppList fails address check"));

    if (! (hlh = HlhUtilities())) {
        DebugTrace(TEXT("DestroyAdviseList: no heap for me\n")DebugTrace(TEXT(");
        return;
    }

    //	First deref any advise sinks that didn't get freed up
    plist = *lppList;
    EnterCriticalSection(plist->lpcs);
    *lppList = NULL;

    while (plist->cItemsMac > 0) {
        (void)ScDelAdviseList(plist, plist->rgItems[0].ulConnection);
    }

    LeaveCriticalSection(plist->lpcs);

    //	Now destroy the adviselist itself
    DeleteCriticalSection(plist->lpcs);
#if defined(WIN32) && !defined(MAC)
    LH_Free(hlh, plist->lpcs);
#endif
    LH_Free(hlh, plist);
}


STDAPI
HrDispatchNotifications(ULONG ulFlags)
{
    DrainFilteredNotifQueue(FALSE, 0, NULL);

    return(ResultFromScode(S_OK));
}


STDAPI
WrapProgress(LPMAPIPROGRESS lpProgress,
  ULONG ulMin,
  ULONG ulMax,
  ULONG ulFlags,
  LPMAPIPROGRESS FAR *lppProgress)
{
    AssertSz(lpProgress && ! FBadUnknown(lpProgress),
      TEXT( TEXT("lpProgress fails address check")));

    AssertSz(lppProgress && !IsBadWritePtr(lppProgress, sizeof(LPMAPIPROGRESS)),
      TEXT( TEXT("lppProgress fails address check")));

    DebugTraceSc(WrapProgress, MAPI_E_NO_SUPPORT);
    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}

#endif //#ifdef SINGLE_THREAD_ADVISE_SINK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\ansiwrap.c ===
/*
-
-   AnsiWrap.c
*
*   Contains wrappers for thunking down Unicode calls to the Win 9x ANSI versions
*
*/


#include "_apipch.h"

// we should not define the Macro for the APIs that we will implement the wrappers for.
// lets try to keep this list alphabetical for sanity

#undef CallWindowProcW
#undef CharLowerW
#undef CharNextW
#undef CharPrevW
#undef CharUpperBuffW
#undef CharUpperBuffW
#undef CharUpperW
#undef CompareStringW
#undef CopyFileW
#undef CreateDialogParamW
#undef CreateDirectoryW
#undef CreateEventW
#undef CreateFileW
#undef CreateFontIndirectW
#undef CreateMutexW
#undef CreateWindowExW
//#undef CryptAcquireContextW
#undef DefWindowProcW
#undef DeleteFileW
#undef DialogBoxParamW
#undef DispatchMessageW
#undef DragQueryFileW
#undef DrawTextW
#undef ExpandEnvironmentStringsW
#undef FindFirstChangeNotificationW
#undef FindFirstFileW
#undef FormatMessageW
#undef GetClassInfoExW
#undef GetClassInfoW
#undef GetClassNameW
#undef GetDateFormatW
#undef GetDiskFreeSpaceW
#undef GetDlgItemTextW
#undef GetFileAttributesW
#undef GetLocaleInfoW
#undef GetMenuItemInfoW
#undef GetMessageW
#undef GetModuleFileNameW
#undef GetObjectW
#undef GetPrivateProfileIntW
#undef GetPrivateProfileStringW
#undef GetProfileIntW
#undef GetStringTypeW
#undef GetSystemDirectoryW
#undef GetTempFileNameW
#undef GetTempPathW
#undef GetTextExtentPoint32W
#undef GetTimeFormatW
#undef GetUserNameW
#undef GetWindowLongW
#undef GetWindowsDirectoryW
#undef GetWindowTextLengthW
#undef GetWindowTextW
#undef InsertMenuW
#undef IsBadStringPtrW
#undef IsCharLowerW
#undef IsCharUpperW
#undef IsDialogMessageW
#undef LCMapStringW
#undef LoadAcceleratorsW
#undef LoadCursorW
#undef LoadIconW
#undef LoadImageW
#undef LoadLibraryW
#undef LoadMenuW
#undef LoadStringW
#undef lstrcatW
#undef lstrcmpiW
#undef lstrcmpW
#undef lstrcpynW
#undef lstrcpyW
#undef ModifyMenuW
#undef MoveFileW
#undef OutputDebugStringW
#undef PeekMessageW
#undef PostMessageW
#undef RegCreateKeyExW
#undef RegCreateKeyW
#undef RegDeleteKeyW
#undef RegDeleteValueW
#undef RegEnumKeyExW
#undef RegEnumValueW
#undef RegisterClassExW
#undef RegisterClassW
#undef RegisterClipboardFormatW
#undef RegisterWindowMessageW
#undef RegOpenKeyExW
#undef RegQueryInfoKeyW
#undef RegQueryValueExW
#undef RegQueryValueW
#undef RegSetValueExW
#undef RegSetValueW
#undef SendDlgItemMessageW
#undef SendMessageW
#undef SetDlgItemTextW
#undef SetMenuItemInfoW
#undef SetWindowLongW
#undef SetWindowTextW
#undef ShellExecuteW
#undef StartDocW
#undef SystemParametersInfoW
#undef TranslateAcceleratorW
#undef UnRegisterClassW
#undef wsprintfW
#undef wvsprintfW

//
//  Do this in every wrapper function to make sure the wrapper
//  prototype matches the function it is intending to replace.
//
#define VALIDATE_PROTOTYPE(f) if (f##W == f##WrapW) 0

#define InRange(val, valMin, valMax) (valMin <= val && val <= valMax)

// Because with current build setting, no lib containing wcscpy and wcslen is linked 
// so implement these two functions here.

LPWSTR My_wcscpy( LPWSTR pwszDest, LPCWSTR pwszSrc ) 

{

    LPWSTR   pwszDestT = NULL;
    LPCWSTR  pwszSrcT;

    pwszSrcT  = pwszSrc;
    pwszDestT = pwszDest;

    while ( *pwszSrcT ) 
        *pwszDestT++ =  *pwszSrcT ++;

    *pwszDestT = 0x0000;

    return pwszDest;
}
    

DWORD  My_wcslen( LPCWSTR  lpwszStr ) 
{

   DWORD   dLen =0;
   LPCWSTR  lpwszStrT;

   lpwszStrT = lpwszStr;
   dLen = 0;

   while ( *lpwszStrT ) {
       dLen ++;
       lpwszStrT ++;
   }

   return dLen;

}


LPWSTR My_wcscat( LPWSTR pwszDest, LPCWSTR pwszSrc ) 

{

    LPWSTR   pwszDestT = pwszDest;

    while ( *pwszDestT ) 
        pwszDestT++;

    My_wcscpy(pwszDestT, pwszSrc);

    return pwszDest;
}
    

// ADVAPI32.DLL

/* RegOpenKeyEx */
LONG WINAPI RegOpenKeyExWrapW(  HKEY       hKey,         // handle to open key
                                LPCTSTR    lpSubKey,     // address of name of subkey to open
                                DWORD      ulOptions,    // reserved
                                REGSAM     samDesired,   // security access mask
                                PHKEY      phkResult)    // address of handle to open key
{

    LPSTR lpSubKeyA = NULL;
    LONG  lRetValue = 0;

    VALIDATE_PROTOTYPE(RegOpenKeyEx);
    
    if (g_bRunningOnNT)
        return RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);

 
    lpSubKeyA = ConvertWtoA(lpSubKey);

    lRetValue = RegOpenKeyExA(hKey, lpSubKeyA, ulOptions, samDesired, phkResult);

    LocalFreeAndNull( &lpSubKeyA  );

    return lRetValue;

}

/* RegQueryValue */
LONG WINAPI RegQueryValueWrapW(  HKEY       hKey,         // handle to key to query
                                 LPCTSTR    lpSubKey,     // name of subkey to query
                                 LPTSTR     lpValue,      // buffer for returned string
                                 PLONG      lpcbValue)    // receives size of returned string
{

    LPSTR  lpSubKeyA = NULL;
    LPWSTR lpwszValue = NULL;
    LONG   lRetValue =0;
    LPSTR  lpValueA = NULL;
    LONG   cbValueA = 0;
    

    VALIDATE_PROTOTYPE(RegQueryValue);
    
    if (g_bRunningOnNT)
        return RegQueryValueW(hKey, lpSubKey, lpValue, lpcbValue);

 
    lpSubKeyA = ConvertWtoA(lpSubKey);

    lRetValue = RegQueryValueA(hKey, lpSubKeyA, NULL, &cbValueA);

    if ( lRetValue != ERROR_SUCCESS ) {
         LocalFreeAndNull( &lpSubKeyA);
         return lRetValue;
    }    

    lpValueA = LocalAlloc(LMEM_ZEROINIT, cbValueA);

    lRetValue = RegQueryValueA(hKey, lpSubKeyA, lpValueA, &cbValueA);

    lpwszValue = ConvertAtoW(lpValueA);

    *lpcbValue = (My_wcslen(lpwszValue) + 1 )  * sizeof(WCHAR);

    if ( lpValue != NULL )
        My_wcscpy(lpValue, lpwszValue);

    LocalFreeAndNull( &lpSubKeyA  );
    LocalFreeAndNull( &lpValueA );
    LocalFreeAndNull( &lpwszValue );

    return lRetValue;
 
}

// RegEnumKeyEx
LONG WINAPI RegEnumKeyExWrapW(   HKEY      hKey,          // handle to key to enumerate
                                 DWORD     dwIndex,       // index of subkey to enumerate
                                 LPTSTR    lpName,        // address of buffer for subkey name
                                 LPDWORD   lpcbName,      // address for size of subkey buffer
                                 LPDWORD   lpReserved,    // reserved
                                 LPTSTR    lpClass,       // address of buffer for class string
                                 LPDWORD   lpcbClass,     // address for size of class buffer
                                 PFILETIME lpftLastWriteTime )
                                                          // address for time key last written to
{
    LONG    lRetValue = 0;
    CHAR    lpNameA[MAX_PATH];
    CHAR    lpClassA[MAX_PATH];
    LPWSTR  lpNameW = NULL;
    LPWSTR  lpClassW= NULL;
    DWORD   cbName, cbClass;


    // [PaulHi] 1/11/99  Init wide char buffers
    lpNameA[0] = 0;
    lpClassA[0] = 0;

    VALIDATE_PROTOTYPE(RegEnumKeyEx);
    
    if (g_bRunningOnNT)
        return RegEnumKeyExW(hKey, dwIndex, lpName, lpcbName, lpReserved, lpClass, lpcbClass, lpftLastWriteTime);

    cbName = cbClass = MAX_PATH;

    lRetValue = RegEnumKeyExA(hKey,dwIndex,lpNameA,&cbName,lpReserved,lpClassA,&cbClass,lpftLastWriteTime);

    if ( lRetValue != ERROR_SUCCESS )  return lRetValue;

    lpClassW = ConvertAtoW( lpClassA );
    lpNameW  = ConvertAtoW( lpNameA );

    cbName = My_wcslen(lpNameW) + 1;
    cbClass= My_wcslen(lpClassW) + 1;

    // [PaulHi] 1/11/99  Be careful copying to passed in pointers
    if (lpClass && lpcbClass)
    {
        if (cbClass <= *lpcbClass)
        {
            CopyMemory(lpClass, lpClassW, cbClass * sizeof(WCHAR) );
            *lpcbClass = cbClass;
        }
        else
        {
            Assert(0);
            lpClass[0] = 0;
            *lpcbClass = 0;
            lRetValue = ERROR_INSUFFICIENT_BUFFER;
        }
    }
    if (lpName && lpcbName)
    {
        if (cbName <= *lpcbName)
        {
            CopyMemory(lpName, lpNameW, cbName * sizeof(WCHAR) );
            *lpcbName = cbName;
        }
        else
        {
            Assert(0);
            lpName[0] = 0;
            *lpcbName = 0;
            lRetValue = ERROR_INSUFFICIENT_BUFFER;
        }
    }

    LocalFreeAndNull( &lpClassW );
    LocalFreeAndNull( &lpNameW );

    return lRetValue;
}

/* RegSetValue */
LONG WINAPI RegSetValueWrapW(    HKEY    hKey,        // handle to key to set value for
                                 LPCTSTR lpSubKey,    // address of subkey name
                                 DWORD   dwType,      // type of value
                                 LPCTSTR lpData,      // address of value data
                                 DWORD   cbData )     // size of value data
{
    LPSTR  lpSubKeyA =NULL;
    LPSTR  lpDataA=NULL;
    DWORD  cbDataA =0;
    LONG   lRetValue = 0;

    VALIDATE_PROTOTYPE(RegSetValue);
    
    if (g_bRunningOnNT)
        return RegSetValueW(hKey, lpSubKey, dwType, lpData, cbData);

    lpSubKeyA = ConvertWtoA(lpSubKey );
    lpDataA = ConvertWtoA( lpData );
    cbDataA = lstrlenA( lpDataA );
    lRetValue = RegSetValueA(hKey, lpSubKeyA, dwType, lpDataA, cbDataA);
    
    LocalFreeAndNull( &lpSubKeyA );
    LocalFreeAndNull( &lpDataA );
    return lRetValue;
}

// RegDeleteKey
LONG WINAPI RegDeleteKeyWrapW(   HKEY    hKey,        // handle to open key
                                 LPCTSTR lpSubKey)   // address of name of subkey to delete
{

    LPSTR  lpSubKeyA =NULL;
    LONG   lRetValue = 0;

    VALIDATE_PROTOTYPE(RegDeleteKey);
    
    if (g_bRunningOnNT)
        return RegDeleteKeyW(hKey, lpSubKey);

    lpSubKeyA = ConvertWtoA(lpSubKey );
    lRetValue = RegDeleteKeyA(hKey, lpSubKeyA );

    LocalFreeAndNull ( &lpSubKeyA );

    return lRetValue;

}

// GetUserName
BOOL WINAPI GetUserNameWrapW(    LPTSTR  lpBuffer,    // address of name buffer
                                 LPDWORD nSize )      // address of size of name buffer
{

    CHAR    lpBufferA[MAX_PATH];
    DWORD   nSizeA, nSizeW;
    BOOL    bRetValue;
    LPWSTR  lpwszBuffer = NULL;

    VALIDATE_PROTOTYPE(GetUserName);
    
    if (g_bRunningOnNT)
        return GetUserNameW(lpBuffer, nSize);

    nSizeA = MAX_PATH;
    bRetValue = GetUserNameA( lpBufferA, &nSizeA );

    lpwszBuffer = ConvertAtoW(lpBufferA );
    
    if (lpBuffer == NULL )
        bRetValue = FALSE;

    nSizeW = My_wcslen(lpwszBuffer);
    if ( *nSize < nSizeW ) {
        *nSize = nSizeW + 1;
        bRetValue = FALSE;
    }

    if ( bRetValue == TRUE ) {
        My_wcscpy( lpBuffer, lpwszBuffer );
        *nSize = nSizeW + 1;
    }

    
    LocalFreeAndNull( &lpwszBuffer );

    return bRetValue;
        
}

// RegEnumValue
LONG WINAPI RegEnumValueWrapW(   HKEY    hKey,           // handle to key to query
                                 DWORD   dwIndex,        // index of value to query
                                 LPTSTR  lpValueName,    // address of buffer for value string
                                 LPDWORD lpcbValueName,  // address for size of value buffer
                                 LPDWORD lpReserved,     // reserved
                                 LPDWORD lpType,         // address of buffer for type code
                                 LPBYTE  lpData,         // address of buffer for value data
                                 LPDWORD lpcbData )      // address for size of data buffer
{
    LONG    lRetValue = 0;
    CHAR    lpValueNameA[MAX_PATH];
    LPWSTR  lpValueNameW = NULL, lpDataW= NULL;
    LPSTR   lpDataA = NULL;
    DWORD   cbValueName, cbData;


    VALIDATE_PROTOTYPE(RegEnumValue);
    
    if (g_bRunningOnNT)
        return RegEnumValueW(hKey, dwIndex, lpValueName, lpcbValueName, lpReserved, lpType, lpData, lpcbData);

    // [PaulHi] Validate return parameters
    if (!lpValueName || !lpcbValueName)
        return ERROR_INVALID_PARAMETER;

    if ( lpData && lpcbData &&( *lpcbData != 0 ) )
    {
       lpDataA = LocalAlloc( LMEM_ZEROINIT, *lpcbData );

       cbData = *lpcbData;
    }

    cbValueName = MAX_PATH;

    lRetValue = RegEnumValueA(hKey, dwIndex, lpValueNameA, &cbValueName, lpReserved, lpType, lpDataA, &cbData);

    if ( lRetValue != ERROR_SUCCESS ) return lRetValue;

    lpValueNameW = ConvertAtoW( lpValueNameA );
    cbValueName = My_wcslen( lpValueNameW ) + 1;
    
    if ( lpType && (*lpType != REG_EXPAND_SZ) && ( *lpType!= REG_MULTI_SZ) && ( *lpType != REG_SZ ) )
    {
        CopyMemory(lpValueName, lpValueNameW, cbValueName * sizeof(WCHAR) );
        *lpcbValueName = cbValueName;

        if ( lpData && lpcbData) {
           CopyMemory(lpData, lpDataA, cbData );
           *lpcbData = cbData;
           LocalFreeAndNull( &lpDataA );
        }

        LocalFreeAndNull( &lpValueNameW );

        return lRetValue;
    }


    if ( lpType && ((*lpType == REG_EXPAND_SZ) || (*lpType == REG_SZ)) )
    {
        CopyMemory(lpValueName, lpValueNameW, cbValueName * sizeof(WCHAR) );
        *lpcbValueName = cbValueName;

        if ( lpData && lpcbData ) {

            LPWSTR  lpDataW;

            lpDataW = ConvertAtoW( lpDataA );

            cbData = My_wcslen(lpDataW) +  1;
            CopyMemory(lpData, lpDataW, cbData * sizeof(WCHAR) );
            *lpcbData = cbData * sizeof(WCHAR);

            LocalFreeAndNull( &lpDataW );
        }

        LocalFreeAndNull( &lpValueNameW );

        return lRetValue;
    }


    // the last case REG_MULTI_SZ.
          
    CopyMemory(lpValueName, lpValueNameW, cbValueName * sizeof(WCHAR) );
    *lpcbValueName = cbValueName;

    if ( lpData && lpcbData ) {
        LPWSTR   lpDataW= NULL;
        LPSTR    lpDataAt = NULL;
        LPWSTR   lpDataT = NULL;
        DWORD    cbDataAll;
        
        lpDataAt = lpDataA;
        cbDataAll = 0;
        lpDataT = (LPWSTR)lpData;

        while ( *lpDataAt != '\0' ) {

            lpDataW = ConvertAtoW( lpDataAt );

            cbDataAll += My_wcslen( lpDataW ) + 1;

            My_wcscpy(lpDataT, lpDataW);

            lpDataT += My_wcslen(lpDataW) + 1;

            lpDataAt += lstrlenA(lpDataAt) + 1;

            LocalFreeAndNull( &lpDataW );

        }

        cbDataAll ++;
        *lpDataT = 0x0000;
         
        *lpcbData = cbDataAll * sizeof(WCHAR);
    }

    LocalFreeAndNull( &lpValueNameW );
    return lRetValue;

}

// RegDeleteValue
LONG WINAPI RegDeleteValueWrapW( HKEY    hKey,           // handle to key
                                 LPCTSTR lpValueName )   // address of value name
{

    LPSTR  lpValueNameA = NULL;
    LONG   lRetValue=0;

    VALIDATE_PROTOTYPE(RegDeleteValue);
    
    if (g_bRunningOnNT)
        return RegDeleteValueW(hKey, lpValueName);

    lpValueNameA = ConvertWtoA( lpValueName );

    lRetValue = RegDeleteValueA( hKey, lpValueNameA );

    LocalFreeAndNull( & lpValueNameA );

    return lRetValue;

}

// RegCreateKey
LONG WINAPI RegCreateKeyWrapW(   HKEY    hKey,          // handle to an open key
                                 LPCTSTR lpSubKey,      // address of name of subkey to open
                                 PHKEY   phkResult  )  // address of buffer for opened handle
{

    LPSTR  lpSubKeyA = NULL;
    LONG   lRetValue =0;

    VALIDATE_PROTOTYPE(RegCreateKey);
    
    if (g_bRunningOnNT)
        return RegCreateKeyW(hKey, lpSubKey, phkResult);

    lpSubKeyA = ConvertWtoA( lpSubKey );

    lRetValue = RegCreateKeyA(hKey, lpSubKeyA, phkResult);

    LocalFreeAndNull( &lpSubKeyA );

    return lRetValue;

}


// in header file wincrypt.h

// CryptAcquireContext
BOOL WINAPI CryptAcquireContextWrapW( HCRYPTPROV *phProv,      // out
                                      LPCTSTR    pszContainer, // in
                                      LPCTSTR    pszProvider,  // in
                                      DWORD      dwProvType,   // in
                                      DWORD      dwFlags )    // in
{

    LPSTR  pszContainerA = NULL;
    LPSTR  pszProviderA = NULL;
    BOOL   bRetValue =0;

    VALIDATE_PROTOTYPE(CryptAcquireContext);
    
    if (g_bRunningOnNT)
        return CryptAcquireContextW(phProv, pszContainer, pszProvider, dwProvType, dwFlags );

    pszContainerA = ConvertWtoA( pszContainer );
    pszProviderA = ConvertWtoA ( pszProvider );

    bRetValue = CryptAcquireContextA(phProv, pszContainerA, pszProviderA, dwProvType, dwFlags );

    LocalFreeAndNull( &pszContainerA );
    LocalFreeAndNull( &pszProviderA );

    return bRetValue;

}

LONG WINAPI RegQueryValueExWrapW( HKEY     hKey,           // handle to key to query
                                  LPCTSTR  lpValueName,    // address of name of value to query
                                  LPDWORD  lpReserved,     // reserved
                                  LPDWORD  lpType,         // address of buffer for value type
                                  LPBYTE   lpData,         // address of data buffer
                                  LPDWORD  lpcbData )      // address of data buffer size
{

    LONG    lRetValue =0;
    LPSTR   lpValueNameA= NULL;
    LPWSTR  lpDataW= NULL;
    LPSTR   lpDataA = NULL;
    DWORD   cbData=0;
    DWORD   dwRealType;

//    VALIDATE_PROTOTYPE(RegQueryValueEx);
    
    if (g_bRunningOnNT)
        return RegQueryValueExW(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData );

    cbData = 0;

    if ( lpData && lpcbData &&( *lpcbData != 0 ) )
    {
       lpDataA = LocalAlloc( LMEM_ZEROINIT, *lpcbData );
       cbData = *lpcbData;
    }

    lpValueNameA = ConvertWtoA(lpValueName);

    lRetValue = RegQueryValueExA(hKey, lpValueNameA, lpReserved, &dwRealType, lpDataA, &cbData);

    if (lpType)
        *lpType = dwRealType;

    if ( (lRetValue != ERROR_SUCCESS) || (lpData == NULL) || (lpcbData == NULL ) ) {
        LocalFreeAndNull( &lpValueNameA );
        return lRetValue;
    }

    
    if ( (dwRealType != REG_EXPAND_SZ) && ( dwRealType != REG_MULTI_SZ) && ( dwRealType != REG_SZ ) ){

       CopyMemory(lpData, lpDataA, cbData );
       *lpcbData = cbData;
       LocalFreeAndNull( &lpDataA );
       LocalFreeAndNull( &lpValueNameA );

       return lRetValue;
    }


    if ( (dwRealType == REG_EXPAND_SZ) || (dwRealType == REG_SZ) ) {

       
        LPWSTR  lpDataW= NULL;

        lpDataW = ConvertAtoW( lpDataA );

        cbData = My_wcslen(lpDataW) +  1;
        CopyMemory(lpData, lpDataW, cbData * sizeof(WCHAR) );
        *lpcbData = cbData * sizeof(WCHAR);

        LocalFreeAndNull( &lpDataW );        
        LocalFreeAndNull( &lpDataA );
        LocalFreeAndNull( &lpValueNameA );

        return lRetValue;
    }


    // the last case REG_MULTI_SZ.

    if (lpData && lpcbData) {
        LPWSTR   lpDataW= NULL;
        LPSTR    lpDataAt= NULL;
        LPWSTR   lpDataT= NULL;
        DWORD    cbDataAll=0;
        
        lpDataAt = lpDataA;
        cbDataAll = 0;
        lpDataT = (LPWSTR)lpData;

        while ( *lpDataAt != '\0' ) {

            lpDataW = ConvertAtoW( lpDataAt );

            cbDataAll += My_wcslen( lpDataW ) + 1;

            My_wcscpy(lpDataT, lpDataW);

            lpDataT += My_wcslen(lpDataW) + 1;

            lpDataAt += lstrlenA(lpDataAt) + 1;

            LocalFreeAndNull( &lpDataW );

        }

        cbDataAll ++;
        *lpDataT = 0x0000;
         
        *lpcbData = cbDataAll * sizeof(WCHAR);
    }

    LocalFreeAndNull( &lpDataA );
    LocalFreeAndNull( &lpValueNameA );
    return lRetValue;


}

// RegCreateKeyEx
LONG WINAPI RegCreateKeyExWrapW(  HKEY    hKey,                // handle to an open key
                                  LPCTSTR lpSubKey,            // address of subkey name
                                  DWORD   Reserved,            // reserved
                                  LPTSTR  lpClass,             // address of class string
                                  DWORD   dwOptions,           // special options flag
                                  REGSAM  samDesired,          // desired security access
                                  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                              // address of key security structure
                                  PHKEY   phkResult,          // address of buffer for opened handle
                                  LPDWORD lpdwDisposition )   // address of disposition value buffer
{

    LPSTR  lpSubKeyA = NULL;
    LPSTR  lpClassA = NULL;
    LONG   lRetValue=0;

    VALIDATE_PROTOTYPE(RegCreateKeyEx);
    
    if (g_bRunningOnNT)
        return RegCreateKeyExW(hKey, 
                               lpSubKey, 
                               Reserved, 
                               lpClass, 
                               dwOptions,
                               samDesired, 
                               lpSecurityAttributes,
                               phkResult, 
                               lpdwDisposition);

    lpSubKeyA = ConvertWtoA( lpSubKey );
    lpClassA = ConvertWtoA ( lpClass );

    lRetValue = RegCreateKeyExA(hKey, 
                                lpSubKeyA, 
                                Reserved, 
                                lpClassA, 
                                dwOptions,
                                samDesired, 
                                lpSecurityAttributes,
                                phkResult, 
                                lpdwDisposition);

    LocalFreeAndNull( &lpSubKeyA );
    LocalFreeAndNull( &lpClassA );

    return lRetValue;

}

// RegSetValueEx
LONG WINAPI RegSetValueExWrapW(   HKEY    hKey,           // handle to key to set value for
                                  LPCTSTR lpValueName,    // name of the value to set
                                  DWORD   Reserved,       // reserved
                                  DWORD   dwType,         // flag for value type
                                  CONST BYTE *lpData,     // address of value data
                                  DWORD   cbData )        // size of value data
{

    LPSTR  lpValueNameA = NULL;
    LPSTR  lpStrA= NULL;
    BYTE   *lpDataA= NULL;
    DWORD  cbDataA=0;
    LONG   lRetValue=0;

    VALIDATE_PROTOTYPE(RegSetValueEx);
    
    if (g_bRunningOnNT)
        return RegSetValueExW(hKey, lpValueName, Reserved, dwType, lpData, cbData);

    lpValueNameA = ConvertWtoA( lpValueName );

    if ( ( dwType != REG_EXPAND_SZ ) && (dwType != REG_MULTI_SZ) && (dwType != REG_SZ) ) {
          
        lRetValue = RegSetValueExA(hKey, lpValueNameA, Reserved, dwType, lpData, cbData);
        LocalFreeAndNull( &lpValueNameA );
        return lRetValue;
    }
    
    if ( ( dwType == REG_EXPAND_SZ) || ( dwType == REG_SZ ) ) {
        lpDataA = ConvertWtoA( (LPWSTR) lpData );
        cbDataA = lstrlenA(lpDataA) + 1;

        lRetValue = RegSetValueExA(hKey, lpValueNameA, Reserved, dwType, lpDataA, cbDataA);
        LocalFreeAndNull( &lpValueNameA );
        LocalFreeAndNull( &lpDataA );

        return lRetValue;
    }

    // the last case is for REG_MULT_SZ
 
    if ( lpData ) {
        LPWSTR   lpDataWt= NULL;
        LPSTR    lpDataAt= NULL;
        DWORD    cbDataAll=0;
        
        lpDataA = LocalAlloc(LMEM_ZEROINIT, cbData);
        lpDataAt = lpDataA;
        cbDataAll = 0;
        lpDataWt = (LPWSTR)lpData;

        while ( *lpDataWt != 0x0000 ) {

            WideCharToMultiByte(CP_ACP,0, lpDataWt, -1, lpDataAt, -1, NULL, NULL ); 

            cbDataAll += lstrlenA(lpDataAt) + 1;

            lpDataWt += My_wcslen(lpDataWt) + 1;

            lpDataAt += lstrlenA(lpDataAt) + 1;


        }

        cbDataAll ++;
        *lpDataAt = 0x00;
        lRetValue = RegSetValueExA(hKey, lpValueNameA, Reserved, dwType, lpDataA, cbDataAll);
        LocalFreeAndNull( &lpDataA );
        LocalFreeAndNull( &lpValueNameA );
        return lRetValue;

    }
    return FALSE;
    return GetLastError();
}

// RegQueryInfoKey
LONG WINAPI RegQueryInfoKeyWrapW( HKEY    hKey,                  // handle to key to query
                                  LPTSTR  lpClass,               // address of buffer for class string
                                  LPDWORD lpcbClass,             // address of size of class string buffer
                                  LPDWORD lpReserved,            // reserved
                                  LPDWORD lpcSubKeys,            // address of buffer for number of subkeys
                                  LPDWORD lpcbMaxSubKeyLen,      // address of buffer for longest subkey 
                                                                 // name length
                                  LPDWORD lpcbMaxClassLen,       // address of buffer for longest class 
                                                                 // string length
                                  LPDWORD lpcValues,             // address of buffer for number of value 
                                                                 // entries
                                  LPDWORD lpcbMaxValueNameLen,   // address of buffer for longest 
                                                                 // value name length
                                  LPDWORD lpcbMaxValueLen,       // address of buffer for longest value 
                                                                 // data length
                                  LPDWORD lpcbSecurityDescriptor,
                                                                 // address of buffer for security 
                                                                 // descriptor length
                                  PFILETIME lpftLastWriteTime)   // address of buffer for last write time
                                                             

{
    LPSTR  lpClassA= NULL;
    LONG   lRetValue=0;


    VALIDATE_PROTOTYPE(RegQueryInfoKey);
    
    if (g_bRunningOnNT)
        return RegQueryInfoKeyW(hKey, lpClass, lpcbClass, lpReserved, lpcSubKeys,
                                lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen,
                                lpcbMaxValueLen,lpcbSecurityDescriptor,lpftLastWriteTime );

    lpClassA = ConvertWtoA( lpClass );
    lRetValue = RegQueryInfoKeyA(hKey, lpClassA, lpcbClass, lpReserved, lpcSubKeys,
                                 lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen,
                                 lpcbMaxValueLen,lpcbSecurityDescriptor,lpftLastWriteTime );

    LocalFreeAndNull( &lpClassA );

    return lRetValue;


}

//GDI32.DLL

//GetObject
int WINAPI GetObjectWrapW( HGDIOBJ hgdiobj,      // handle to graphics object of interest
                           int     cbBuffer,     // size of buffer for object information
                           LPVOID  lpvObject )   // pointer to buffer for object information
{

    int iRetValue =0;
    LOGFONTA  lfFontA;
    LOGFONTW  lfFontW;

    VALIDATE_PROTOTYPE(GetObject);
    
    if (g_bRunningOnNT)
        return GetObjectW(hgdiobj, cbBuffer, lpvObject);

    
    if ( GetObjectType(hgdiobj) != OBJ_FONT ) {

        iRetValue = GetObjectA( hgdiobj, cbBuffer, lpvObject );
        return iRetValue;
    }


    // if Object type is HFONT, the return value lpvObject will point to LOGFONT which contains
    // a field lpFaceName with TCHAR * type.

    if ( cbBuffer != sizeof(LOGFONTW) )
        return 0;

    if (lpvObject == NULL )  return sizeof(LOGFONTW);

    iRetValue = GetObjectA( hgdiobj, sizeof(lfFontA), &lfFontA );

    if (iRetValue == 0 ) return 0;

    iRetValue = sizeof(LOGFONTW);

    // copy all the fields except lfFaceName from lfFontA to lfFontW
    CopyMemory(&lfFontW,&lfFontA, sizeof(LOGFONTA) );
    
    // translate the lfFaceName[] from A to W

    MultiByteToWideChar(GetACP(), 0, lfFontA.lfFaceName, LF_FACESIZE, lfFontW.lfFaceName, LF_FACESIZE);
    
    CopyMemory(lpvObject, &lfFontW, sizeof(LOGFONTW) );

    return iRetValue;

}

// StartDoc
int WINAPI StartDocWrapW(  HDC           hdc,      // handle to device context
                           CONST DOCINFO *lpdi )   // address of structure with file names
{
    
    int        iRetValue=0;
    DOCINFOA   diA;
    LPSTR      lpszDocName= NULL, lpszOutput= NULL, lpszDatatype= NULL;
    

    VALIDATE_PROTOTYPE(StartDoc);
    
    if (g_bRunningOnNT)
        return StartDocW(hdc,lpdi);

    diA.cbSize = sizeof(DOCINFOA);

    lpszDocName = ConvertWtoA( lpdi->lpszDocName );
    lpszOutput  = ConvertWtoA( lpdi->lpszOutput );
    lpszDatatype= ConvertWtoA( lpdi->lpszDatatype);

    diA.lpszDocName = lpszDocName;
    diA.lpszOutput = lpszOutput;
    diA.lpszDatatype = lpszDatatype;
    diA.fwType = lpdi->fwType;

    iRetValue = StartDocA( hdc, &diA );

    LocalFreeAndNull( &lpszDocName );
    LocalFreeAndNull( &lpszOutput );
    LocalFreeAndNull( &lpszDatatype );

    return iRetValue;

}

// CreateFontIndirect
HFONT WINAPI CreateFontIndirectWrapW (CONST LOGFONT *lplf )  // pointer to logical font structure
{

    HFONT     hRetValue;
    LOGFONTA  lfFontA;

    VALIDATE_PROTOTYPE(CreateFontIndirect);
    
    if (g_bRunningOnNT)
        return CreateFontIndirectW(lplf);

    // copy LOGFONTW 's fields except lfFaceName to lfFontA.

    CopyMemory(&lfFontA, lplf, sizeof(LOGFONTW) - LF_FACESIZE * sizeof(WCHAR) );

    WideCharToMultiByte(CP_ACP, 0, lplf->lfFaceName, LF_FACESIZE, lfFontA.lfFaceName, LF_FACESIZE, NULL, NULL );

    hRetValue = CreateFontIndirectA( &lfFontA );

    return hRetValue;

}

//KERNEL32.DLL

// GetLocaleInfo
int WINAPI GetLocaleInfoWrapW( LCID   Locale,       // locale identifier
                               LCTYPE LCType,       // type of information
                               LPTSTR lpLCData,     // address of buffer for information
                               int    cchData )     // size of buffer
{

    int    iRetValue=0;
    LPSTR  lpLCDataA= NULL;
    int    cchDataA=0;
    LPWSTR lpLCDataW= NULL;
    int    cchDataW=0;

    VALIDATE_PROTOTYPE(GetLocaleInfo);
    
    if (g_bRunningOnNT)
        return GetLocaleInfoW(Locale, LCType, lpLCData, cchData);

    
    iRetValue = GetLocaleInfoA(Locale, LCType, NULL, 0);

    if ( iRetValue == 0 ) return iRetValue;

    cchDataA = iRetValue;
    lpLCDataA = LocalAlloc(LMEM_ZEROINIT, cchDataA+1 );

    iRetValue = GetLocaleInfoA(Locale, LCType, lpLCDataA, cchDataA);
    lpLCDataA[cchDataA] = '\0';

    lpLCDataW = ConvertAtoW( lpLCDataA );
    cchDataW = My_wcslen( lpLCDataW );

    if ( (cchData == 0) || (lpLCData == NULL) ) {
        
        LocalFreeAndNull(&lpLCDataA);
        LocalFreeAndNull(&lpLCDataW);
        return cchDataW ;
    }

    CopyMemory(lpLCData, lpLCDataW, cchDataW * sizeof(WCHAR) );
    lpLCData[cchDataW] = '\0';

    LocalFreeAndNull(&lpLCDataA);
    LocalFreeAndNull(&lpLCDataW);
    return cchData;

}

// CreateDirectory
BOOL WINAPI CreateDirectoryWrapW(LPCTSTR               lpPathName,           // pointer to directory path string
                                 LPSECURITY_ATTRIBUTES lpSecurityAttributes)// pointer to security descriptor
{

    BOOL  bRetValue = FALSE;
    LPSTR lpPathNameA = NULL;

    VALIDATE_PROTOTYPE(CreateDirectory);
    
    if (g_bRunningOnNT)
        return CreateDirectoryW(lpPathName, lpSecurityAttributes);

    lpPathNameA = ConvertWtoA( lpPathName );

    bRetValue = CreateDirectoryA( lpPathNameA, lpSecurityAttributes );

    LocalFreeAndNull( &lpPathNameA );

    return bRetValue;

}

// GetWindowsDirectory
UINT WINAPI GetWindowsDirectoryWrapW( LPTSTR lpBuffer,  // address of buffer for Windows directory
                                      UINT   uSize )    // size of directory buffer
{

    UINT  uRetValue = 0;
    LPSTR lpBufferA = NULL;

    VALIDATE_PROTOTYPE(GetWindowsDirectory);
    
    if (g_bRunningOnNT)
        return GetWindowsDirectoryW(lpBuffer, uSize);

    lpBufferA = LocalAlloc( LMEM_ZEROINIT, uSize * sizeof(WCHAR) );

    uRetValue = GetWindowsDirectoryA( lpBufferA, uSize * sizeof(WCHAR) );

    uRetValue =MultiByteToWideChar(GetACP( ), 0, lpBufferA, -1, lpBuffer, uSize);

    LocalFreeAndNull( &lpBufferA );

    return uRetValue;

}

// GetSystemDirectory
UINT WINAPI GetSystemDirectoryWrapW( LPTSTR lpBuffer,  // address of buffer for system directory
                                     UINT   uSize )   // size of directory buffer
{
    UINT  uRetValue = 0;
    LPSTR lpBufferA = NULL;

    VALIDATE_PROTOTYPE(GetSystemDirectory);
    
    if (g_bRunningOnNT)
        return GetSystemDirectoryW(lpBuffer, uSize);

    lpBufferA = LocalAlloc( LMEM_ZEROINIT, uSize * sizeof(WCHAR) );

    uRetValue = GetSystemDirectoryA( lpBufferA, uSize * sizeof(WCHAR) );

    uRetValue =MultiByteToWideChar(GetACP( ), 0, lpBufferA, -1, lpBuffer, uSize);

    LocalFreeAndNull( &lpBufferA );

    return uRetValue;

}

// GetStringType   the parameters are not the same 


BOOL WINAPI GetStringTypeWrapW( DWORD   dwInfoType,   // information-type options
                                LPCTSTR lpSrcStr,     // pointer to the source string
                                int     cchSrc,       // size, in Characters, of the source string
                                LPWORD  lpCharType )  // pointer to the buffer for output

{
    BOOL  bRetValue = 0;
    LPSTR lpSrcStrA = NULL;
    
    VALIDATE_PROTOTYPE(GetStringType);
    
    if (g_bRunningOnNT)
       return GetStringTypeW(dwInfoType, lpSrcStr, cchSrc, lpCharType);

    lpSrcStrA = ConvertWtoA( lpSrcStr );

    bRetValue = GetStringTypeA( LOCALE_USER_DEFAULT, dwInfoType, lpSrcStrA, -1, lpCharType);
    
    LocalFreeAndNull( &lpSrcStrA );

    return bRetValue;
}



// GetProfileInt
UINT WINAPI GetProfileIntWrapW( LPCTSTR lpAppName,  // address of section name
                                LPCTSTR lpKeyName,  // address of key name
                                INT     nDefault )  // default value if key name is not found
{

    UINT  uRetValue = 0;
    LPSTR lpAppNameA = NULL;
    LPSTR lpKeyNameA = NULL;


    VALIDATE_PROTOTYPE(GetProfileInt);
    
    if (g_bRunningOnNT)
        return GetProfileIntW(lpAppName, lpKeyName, nDefault);

    lpAppNameA = ConvertWtoA( lpAppName );
    lpKeyNameA = ConvertWtoA( lpKeyName );

    uRetValue = GetProfileIntA( lpAppNameA, lpKeyNameA, nDefault);

    LocalFreeAndNull( &lpAppNameA );
    LocalFreeAndNull( &lpKeyNameA );

    return uRetValue;

}

// LCMapString
int WINAPI LCMapStringWrapW( LCID    Locale,      // locale identifier
                             DWORD   dwMapFlags,  // mapping transformation type
                             LPCTSTR lpSrcStr,    // address of source string
                             int     cchSrc,      // number of characters in source string
                             LPTSTR  lpDestStr,   // address of destination buffer
                             int     cchDest )    // size of destination buffer
{

    int    iRetValue =0;
    LPSTR  lpSrcStrA = NULL;
    LPSTR  lpDestStrA = NULL;
    LPWSTR lpDestStrW = NULL;
    int    cchSrcA, cchDestA, cchDestW;


    VALIDATE_PROTOTYPE(LCMapString);
    
    if (g_bRunningOnNT)
        return LCMapStringW(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);

    lpSrcStrA = ConvertWtoA( lpSrcStr );
    cchSrcA = lstrlenA(lpSrcStrA);

    lpDestStrA = LocalAlloc(LMEM_ZEROINIT, cchDest * sizeof(WCHAR) );
    cchDestA = cchDest * sizeof(WCHAR);

    iRetValue = LCMapStringA(Locale,dwMapFlags,lpSrcStrA,cchSrcA,lpDestStrA,cchDestA);

    // [PaulHi] 6/8/99  Don't fill the buffer if the pointer is NULL.
    if (lpDestStr && iRetValue != 0)
    {
        lpDestStrW = ConvertAtoW(lpDestStrA);

        iRetValue = My_wcslen(lpDestStrW) + 1;

        // Ensure that we don't overwrite the output buffer
        iRetValue = (iRetValue <= cchDest) ? iRetValue : cchDest;

        CopyMemory( lpDestStr, lpDestStrW, iRetValue * sizeof(WCHAR) );

        LocalFreeAndNull( &lpDestStrW );
    }
       
    LocalFreeAndNull( &lpDestStrA );
    LocalFreeAndNull( &lpSrcStrA );
        
    return iRetValue;
    
}

// GetFileAttributes
DWORD WINAPI GetFileAttributesWrapW( LPCTSTR lpFileName )  // pointer to the name of a file or directory
{


    DWORD  dRetValue =0;
    LPSTR  lpFileNameA = NULL;

    VALIDATE_PROTOTYPE(GetFileAttributes);
    
    if (g_bRunningOnNT)
        return GetFileAttributes(lpFileName);

    lpFileNameA = ConvertWtoA( lpFileName );

    dRetValue = GetFileAttributesA(lpFileNameA );

    LocalFreeAndNull ( &lpFileNameA );

    return dRetValue;


}

// CompareString
int WINAPI CompareStringWrapW( LCID    Locale,        // locale identifier
                               DWORD   dwCmpFlags,    // comparison-style options
                               LPCWSTR lpString1,     // pointer to first string
                               int     cchCount1,     // size, in bytes or characters, of first string
                               LPCWSTR lpString2,     // pointer to second string
                               int     cchCount2 )    // size, in bytes or characters, of second string
{
    int    iRetValue =0;
    LPSTR   lpString1A = NULL,
            lpString2A = NULL;
    LPWSTR  pszString1 = NULL,
            pszString2 = NULL;
            

    VALIDATE_PROTOTYPE(CompareString);
    
    if (g_bRunningOnNT)
        return CompareStringW(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);

    // [PaulHi] 4/1/99  Raid 75303  If the character count value(s) are -1 then the
    // input string(s) are already zero terminated and can be converted to ANSI directly.
    Assert(lpString1);
    Assert(lpString2);
    if (cchCount1 == -1)
    {
        // Already zero terminated string
        // Not great to cast const to non-const, but we don't modify the string
        pszString1 = (LPWSTR)lpString1;
    }
    else
    {
        // Convert to zero terminated string
        pszString1 = LocalAlloc(LMEM_FIXED, (cchCount1+1)*sizeof(WCHAR));
        if (!pszString1)
            goto exit;

        // Zero inited buffer
        lstrcpynWrapW(pszString1, lpString1, cchCount1+1);
    }

    if (cchCount2 == -1)
    {
        // Already zero terminated string
        // Not great to cast const to non-const, but we don't modify the string
        pszString2 = (LPWSTR)lpString2;
    }
    else
    {
        // Convert to zero terminated string
        pszString2 = LocalAlloc(LMEM_FIXED, (cchCount2+1)*sizeof(WCHAR));
        if (!pszString2)
            goto exit;

        // Zero inited buffer
        lstrcpynWrapW(pszString2, lpString2, cchCount2+1);
    }

    // Convert to ANSI, statistically improve our odds by checking that there
    // wasn't data loss on the first character.  It's too expensive to do a
    // full test every time.
    lpString1A = ConvertWtoA( pszString1 );
    if (!lpString1A || (lpString1A[0]=='?' && pszString1[0]!=L'?'))
        goto exit;

    lpString2A = ConvertWtoA( pszString2 );
    if (!lpString2A || (lpString2A[0]=='?' && pszString2[0]!=L'?'))
        goto exit;

    iRetValue = CompareStringA(Locale,dwCmpFlags,lpString1A,lstrlenA(lpString1A),lpString2A,lstrlenA(lpString2A));

exit:
    LocalFreeAndNull( &lpString1A );
    LocalFreeAndNull( &lpString2A );

    // Only deallocate if allocated locally
    if (pszString1 != (LPWSTR)lpString1)
        LocalFreeAndNull( &pszString1 );
    if (pszString2 != (LPWSTR)lpString2)
        LocalFreeAndNull( &pszString2 );

    return iRetValue;

}

//  lstrcpy
LPTSTR WINAPI lstrcpyWrapW( LPTSTR  lpString1,     // pointer to buffer
                            LPCTSTR lpString2 )    // pointer to string to copy
{

    VALIDATE_PROTOTYPE(lstrcpy);
    
    if (g_bRunningOnNT)
        return lstrcpyW(lpString1, lpString2);

    CopyMemory(lpString1, lpString2, (My_wcslen(lpString2) + 1) * sizeof(WCHAR) );

    return lpString1;
}

// lstrcmpi
int WINAPI lstrcmpiWrapW( LPCTSTR lpString1,    // pointer to first string
                          LPCTSTR lpString2 )   // pointer to second string
{
    int     iRetValue = 0;
    LPSTR   lpString1A = NULL ;
    LPSTR   lpString2A = NULL ;


    VALIDATE_PROTOTYPE(lstrcmpi);
    
    if (g_bRunningOnNT)
        return lstrcmpiW(lpString1, lpString2);

    lpString1A = ConvertWtoA( lpString1 );
    lpString2A = ConvertWtoA( lpString2 );

    iRetValue = lstrcmpiA(lpString1A, lpString2A );

    LocalFreeAndNull( &lpString1A );
    LocalFreeAndNull( &lpString2A );

    return iRetValue;
}

// LoadLibrary
HINSTANCE WINAPI LoadLibraryWrapW( LPCTSTR lpLibFileName )  // address of filename of executable module
{

    HINSTANCE  hRetValue =0;
    LPSTR      lpLibFileNameA = NULL;

    VALIDATE_PROTOTYPE(LoadLibrary);
    
    if (g_bRunningOnNT)
        return LoadLibraryW(lpLibFileName);

    lpLibFileNameA = ConvertWtoA(lpLibFileName);

    hRetValue = LoadLibraryA( lpLibFileNameA );

    LocalFreeAndNull( &lpLibFileNameA );

    return hRetValue;

}

// GetTextExtentPoint32
BOOL WINAPI GetTextExtentPoint32WrapW(HDC     hdc,
                                      LPCWSTR pwszBuf,
                                      int     nLen,
                                      LPSIZE  psize)
{
    LPSTR   pszBuf = NULL;
    BOOL    bRtn = FALSE;

    VALIDATE_PROTOTYPE(GetTextExtentPoint32);

    if (g_bRunningOnNT)
        return GetTextExtentPoint32W(hdc, pwszBuf, nLen, psize);

    pszBuf = ConvertWtoA(pwszBuf);
    if (pszBuf)
    {
        nLen = lstrlenA(pszBuf);
        bRtn = GetTextExtentPoint32A(hdc, pszBuf, nLen, psize);
        LocalFreeAndNull(&pszBuf);
    }
    else
    {
        psize->cx = 0;
        psize->cy = 0;
    }

    return bRtn;
}

// GetTimeFormat
int WINAPI GetTimeFormatWrapW( LCID    Locale,            // locale for which time is to be formatted
                               DWORD   dwFlags,           // flags specifying function options
                               CONST SYSTEMTIME *lpTime,  // time to be formatted
                               LPCTSTR lpFormat,          // time format string
                               LPTSTR  lpTimeStr,         // buffer for storing formatted string
                               int     cchTime  )         // size, in bytes or characters, of the buffer
{
    int    iRetValue =0;
    LPSTR  lpFormatA = NULL;
    LPWSTR lpTimeStrW = NULL;
    LPSTR  lpTimeStrA = NULL;
    int    cchTimeA=0, cchTimeW=0;

    VALIDATE_PROTOTYPE(GetTimeFormat);
    
    if (g_bRunningOnNT)
        return GetTimeFormatW(Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime);

    lpFormatA = ConvertWtoA( lpFormat );

    cchTimeA = GetTimeFormatA(Locale, dwFlags, lpTime,  lpFormatA, NULL, 0);

    lpTimeStrA = LocalAlloc(LMEM_ZEROINIT, cchTimeA );

    iRetValue = GetTimeFormatA(Locale, dwFlags, lpTime, lpFormatA, lpTimeStrA, cchTimeA );

    if ( iRetValue != 0 ) {
        
        lpTimeStrW = ConvertAtoW( lpTimeStrA );
        cchTimeW = My_wcslen( lpTimeStrW ) + 1;
        iRetValue = cchTimeW;

        if ( (cchTime !=0) && ( lpTimeStr != NULL ) ) {
              
              CopyMemory(lpTimeStr, lpTimeStrW, cchTimeW * sizeof(WCHAR) );
        }

        LocalFreeAndNull( &lpTimeStrW );

    }

    LocalFreeAndNull( &lpFormatA );
    LocalFreeAndNull( &lpTimeStrA );

    return iRetValue;

}

// GetDateFormat
int WINAPI GetDateFormatWrapW( LCID    Locale,             // locale for which date is to be formatted
                               DWORD   dwFlags,            // flags specifying function options
                               CONST SYSTEMTIME *lpDate,   // date to be formatted
                               LPCTSTR lpFormat,           // date format string
                               LPTSTR  lpDateStr,          // buffer for storing formatted string
                               int     cchDate )          // size of buffer
{

    int    iRetValue = 0;
    LPSTR  lpFormatA = NULL;
    LPWSTR lpDateStrW = NULL;
    LPSTR  lpDateStrA = NULL;
    int    cchDateA, cchDateW;

    VALIDATE_PROTOTYPE(GetDateFormat);
    
    if (g_bRunningOnNT)
        return GetDateFormatW(Locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate);

    lpFormatA = ConvertWtoA( lpFormat );

    cchDateA = GetDateFormatA(Locale, dwFlags, lpDate,  lpFormatA, NULL, 0);

    lpDateStrA = LocalAlloc(LMEM_ZEROINIT, cchDateA );

    iRetValue = GetDateFormatA(Locale, dwFlags, lpDate, lpFormatA, lpDateStrA, cchDateA );

    if ( iRetValue != 0 ) {
        
        lpDateStrW = ConvertAtoW( lpDateStrA );
        cchDateW = My_wcslen( lpDateStrW ) + 1;
        iRetValue = cchDateW;

        if ( (cchDate !=0) && ( lpDateStr != NULL ) ) {
              
              CopyMemory(lpDateStr, lpDateStrW, cchDateW * sizeof(WCHAR) );
        }

        LocalFreeAndNull( &lpDateStrW );

    }

    LocalFreeAndNull( &lpFormatA );
    LocalFreeAndNull( &lpDateStrA );

    return iRetValue;




}


// lstrcpyn
LPTSTR WINAPI lstrcpynWrapW( LPTSTR  lpString1,     // pointer to target buffer
                             LPCTSTR lpString2,     // pointer to source string
                             int     iMaxLength )   // number of bytes or characters to copy

{
    int  iLength = 0;

    VALIDATE_PROTOTYPE(lstrcpyn);
    
    if (g_bRunningOnNT)
        return lstrcpynW(lpString1, lpString2, iMaxLength);

    iLength = My_wcslen(lpString2);

    if ( iLength >= iMaxLength )
        iLength = iMaxLength-1;

    CopyMemory(lpString1, lpString2, iLength * sizeof(WCHAR) );

    lpString1[iLength] = 0x0000;

    return lpString1;

}

// CreateFile
HANDLE WINAPI CreateFileWrapW( LPCTSTR lpFileName,             // pointer to name of the file
                               DWORD   dwDesiredAccess,        // access (read-write) mode
                               DWORD   dwShareMode,            // share mode
                               LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                               // pointer to security attributes
                               DWORD   dwCreationDisposition,  // how to create
                               DWORD   dwFlagsAndAttributes,   // file attributes
                               HANDLE  hTemplateFile )        // handle to file with attributes to copy
                               
{

    LPSTR lpFileA = NULL;
    HANDLE hFile = NULL;

    VALIDATE_PROTOTYPE(CreateFile);
    
    if (g_bRunningOnNT)
        return CreateFileW( lpFileName, 
                            dwDesiredAccess, 
                            dwShareMode, 
                            lpSecurityAttributes, 
                            dwCreationDisposition, 
                            dwFlagsAndAttributes, 
                            hTemplateFile);

    lpFileA = ConvertWtoA(lpFileName);

    hFile = CreateFileA(lpFileA, 
                        dwDesiredAccess, 
                        dwShareMode, 
                        lpSecurityAttributes, 
                        dwCreationDisposition, 
                        dwFlagsAndAttributes, 
                        hTemplateFile);

    LocalFreeAndNull(&lpFileA);

    return (hFile);


}

// OutputDebugString
VOID WINAPI OutputDebugStringWrapW(LPCTSTR lpOutputString )   // pointer to string to be displayed
{
    LPSTR lpOutputStringA = NULL;

    VALIDATE_PROTOTYPE(OutputDebugString);
    
    if (g_bRunningOnNT) {
        OutputDebugStringW(lpOutputString);
        return;
    }

    lpOutputStringA = ConvertWtoA( lpOutputString );

    OutputDebugStringA( lpOutputStringA );

    LocalFreeAndNull( &lpOutputStringA );

}

// lstrcat
LPTSTR WINAPI lstrcatWrapW( LPTSTR  lpString1,     // pointer to buffer for concatenated strings
                            LPCTSTR lpString2 )    // pointer to string to add to string1
{

    LPWSTR  lpwStr = NULL;

    VALIDATE_PROTOTYPE(lstrcat);
    
    if (g_bRunningOnNT)
        return lstrcatW(lpString1, lpString2);

    lpwStr = lpString1 + My_wcslen(lpString1);

    CopyMemory(lpwStr, lpString2, (My_wcslen(lpString2)+1) * sizeof(WCHAR)  );

    return lpString1;
}


// FormatMessage  with va_list 
//
// Since it's hard to muck with the Argument List, instead, we'll go throught 
// the source string and explicitly turn any %x to %x!ws! indicating that the
// arguments have Wide Strings in them.
//
//  For sanity we assume we won't ever get more than 9 arguments <BUGBUG>
//
static const LPWSTR  lpWideFormat = TEXT("!ws!");

DWORD WINAPI FormatMessageWrapW( DWORD    dwFlags,       // source and processing options
                                 LPCVOID  lpSource,      // pointer to  message source
                                 DWORD    dwMessageId,   // requested message identifier
                                 DWORD    dwLanguageId,  // language identifier for requested message
                                 LPTSTR   lpBuffer,      // pointer to message buffer
                                 DWORD    nSize,         // maximum size of message buffer
                                 va_list *Arguments )    // pointer to array of message inserts
{
    DWORD   dwResult=0, iNumArg, iNum;
    LPSTR   lpSourceA = NULL;
    LPSTR   pszBuffer = NULL;
    LPWSTR  lpTemp1=NULL, lpTemp2=NULL;

    VALIDATE_PROTOTYPE(FormatMessage);
    
    if (g_bRunningOnNT)
        return FormatMessageW(dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);

    //  FORMAT_MESSAGE_FROM_STRING means that the source is a string.
    //  Otherwise, it's an opaque LPVOID (aka, an atom).
    //
    if ( !(dwFlags & FORMAT_MESSAGE_FROM_STRING) || !(dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER) )  {
        return 0;
        // we don't handle these cases
    }

    if ( !(dwFlags & FORMAT_MESSAGE_ARGUMENT_ARRAY) )
    {
        LPWSTR lpModifiedSource;

        DebugTrace(TEXT("WARNING: FormatMessageWrap() is being called in Win9X with wide char argument strings.  DBCS characters may not be converted correctly!"));

        if(!(lpModifiedSource = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpSource)+1)*4))) // Four times is big enough
            goto exit;

        lpTemp1 = (LPWSTR)lpSource;
        My_wcscpy(lpModifiedSource, lpSource);
        lpTemp2 = lpModifiedSource;

        while(lpTemp1 && *lpTemp1)
        {
            if( *lpTemp1 == '%' && 
                (*(lpTemp1+1) >= '1' && *(lpTemp1+1) <= '9') &&
                *(lpTemp1+2) != '!') //if there isn't a hard-coded printf format specified here
            {
                lpTemp2 += 2; //skip 2 to get past the %9
                lpTemp1 += 2;
                My_wcscpy(lpTemp2, lpWideFormat);
                My_wcscat(lpTemp2, lpTemp1);
                lpTemp2 += My_wcslen(lpWideFormat);
            }
            else
            {
                lpTemp1++;
                lpTemp2++;
            }
        }

        lpSourceA = ConvertWtoA( lpModifiedSource );
        FormatMessageA(
                dwFlags,
                lpSourceA,
                dwMessageId,
                dwLanguageId,
                (LPSTR)&pszBuffer,
                0,
                Arguments);

        LocalFreeAndNull(&lpModifiedSource);
    }
    else
    {
        // We have an argument array.  Convert wide strings to DBCS
        // Create a new argument array and fill with converted (wide to DBCS)
        // strings to ensure International DBCS conversion occurs correctly.
        int      n, nArgCount = 0, nBytes = 0;
        LPVOID * pvArgArray = NULL;

        lpTemp1 = (LPWSTR)lpSource;
        while (*lpTemp1)
        {
            if (*lpTemp1 == '%')
            {
                if ( *(lpTemp1+1) == '%')
                    ++lpTemp1;      // "%%" not valid argument, step passed
                else
                    ++nArgCount;    // valid argument
            }
            ++lpTemp1;
        }

        pvArgArray = LocalAlloc(LMEM_ZEROINIT, (nArgCount * sizeof(LPVOID)));
        if (!pvArgArray)
            goto exit;

        lpTemp1 = (LPWSTR)lpSource;
        n = 0;
        while (*lpTemp1)
        {
            if (*lpTemp1 == '%')
            {
                if (*(lpTemp1+1) == '%')    // Skip "%%"
                    ++lpTemp1;
                else
                {
                    if ( *(lpTemp1+1) >= '1' && *(lpTemp1+1) <= '9' &&
                         *(lpTemp1+2) != '!' )     // Default Unicode string arg
                    {
                        pvArgArray[n] = (LPVOID)ConvertWtoA( (LPWSTR) ((LPVOID *)Arguments)[n] );
                        nBytes += lstrlenA(pvArgArray[n]);
                    }
                    else
                        pvArgArray[n] = ((LPVOID *)Arguments)[n];   // unknown arg type

                    ++n;
                    Assert(n <= nArgCount);
                }
            }

            ++lpTemp1;
        }

        // Check if known argument string lengths exceed 1023 bytes. If it does
        // abort because Win9X will overrun a buffer and crash.
        if (nBytes <= 1000)
        {
            lpSourceA = ConvertWtoA((LPWSTR)lpSource);
            FormatMessageA(
                    dwFlags,
                    lpSourceA,
                    dwMessageId,
                    dwLanguageId,
                    (LPSTR)&pszBuffer,
                    0,
                    (va_list *)pvArgArray);
        }

        // Clean up
        lpTemp1 = (LPWSTR)lpSource;
        n = 0;
        while (*lpTemp1)
        {
            if (*lpTemp1 == '%')
            {
                if (*(lpTemp1+1) == '%')    // Skip "%%"
                    ++lpTemp1;
                else
                {
                    if ( *(lpTemp1+1) >= '1' && *(lpTemp1+1) <= '9' &&
                         *(lpTemp1+2) != '!' )
                    {
                        LocalFree(pvArgArray[n]);
                        ++n;
                        Assert(n <= nArgCount);
                    }
                }
            }

            ++lpTemp1;
        }
        LocalFree(pvArgArray);
    }

    if (pszBuffer)
    {

        LPWSTR   *lpwBuffer;

        lpwBuffer =(LPWSTR *)(lpBuffer);
        *lpwBuffer = ConvertAtoW(pszBuffer);
        dwResult = My_wcslen(*lpwBuffer);

        LocalFree( pszBuffer );
    }

exit:
    LocalFreeAndNull(&lpSourceA);

    return dwResult;    
}

// GetModuleFileName
DWORD WINAPI GetModuleFileNameWrapW( HMODULE hModule,    // handle to module to find filename for
                                     LPTSTR  lpFileName, // pointer to buffer to receive module path
                                     DWORD   nSize )     // size of buffer, in characters
{

    DWORD  dRetValue =0;
    CHAR   FileNameA[MAX_PATH];
    LPWSTR lpFileNameW = NULL;
    
    VALIDATE_PROTOTYPE(GetModuleFileName);
    
    if (g_bRunningOnNT)
        return GetModuleFileNameW(hModule, lpFileName, nSize);

    dRetValue = GetModuleFileNameA(hModule, FileNameA, MAX_PATH);

    if ( dRetValue == 0 )  return 0;

    lpFileNameW = ConvertAtoW( FileNameA );

    dRetValue = My_wcslen( lpFileNameW );

    if ( dRetValue > nSize )
        dRetValue = nSize;

    CopyMemory(lpFileName, lpFileNameW, (dRetValue+1) * sizeof(WCHAR) );

    LocalFreeAndNull( &lpFileNameW );

    return dRetValue;

}

// GetPrivateProfileInt
UINT WINAPI GetPrivateProfileIntWrapW( LPCTSTR  lpAppName,    // address of section name
                                       LPCTSTR  lpKeyName,    // address of key name
                                       INT      nDefault,     // return value if key name is not found
                                       LPCTSTR  lpFileName )  // address of initialization filename
{
    UINT   uRetValue = 0;
    LPSTR  lpAppNameA = NULL;
    LPSTR  lpKeyNameA = NULL;
    LPSTR  lpFileNameA = NULL;

    VALIDATE_PROTOTYPE(GetPrivateProfileInt);
    
    if (g_bRunningOnNT)
        return GetPrivateProfileIntW(lpAppName, lpKeyName, nDefault, lpFileName);

    lpAppNameA = ConvertWtoA( lpAppName );
    lpKeyNameA = ConvertWtoA( lpKeyName );
    lpFileNameA= ConvertWtoA( lpFileName);

    uRetValue = GetPrivateProfileIntA( lpAppNameA, lpKeyNameA, nDefault, lpFileNameA);

    LocalFreeAndNull( &lpAppNameA );
    LocalFreeAndNull( &lpKeyNameA );
    LocalFreeAndNull( &lpFileNameA);

    return uRetValue;

}

// IsBadStringPtr
BOOL WINAPI IsBadStringPtrWrapW( LPCTSTR lpsz,       // address of string
                                 UINT_PTR    ucchMax )  // maximum size of string
{
    
    VALIDATE_PROTOTYPE(IsBadStringPtr);
    
    if (g_bRunningOnNT)
        return IsBadStringPtrW(lpsz, ucchMax);

    return IsBadStringPtrA( (LPSTR)lpsz, ucchMax * sizeof(WCHAR) );

}

// GetPrivateProfileString
DWORD WINAPI GetPrivateProfileStringWrapW( LPCTSTR lpAppName,          // points to section name
                                           LPCTSTR lpKeyName,          // points to key name
                                           LPCTSTR lpDefault,          // points to default string
                                           LPTSTR  lpReturnedString,   // points to destination buffer
                                           DWORD   nSize,              // size of destination buffer
                                           LPCTSTR lpFileName  )       // points to initialization filename
{

    DWORD  dRetValue = 0;
    LPSTR  lpAppNameA = NULL;
    LPSTR  lpKeyNameA = NULL;
    LPSTR  lpDefaultA = NULL;
    LPSTR  lpReturnedStringA = NULL;
    LPWSTR lpReturnedStringW = NULL;
    LPSTR  lpFileNameA = NULL;
    DWORD  nSizeA = 0;


    VALIDATE_PROTOTYPE(GetPrivateProfileString);
    
    if (g_bRunningOnNT)
        return GetPrivateProfileStringW(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);


    lpAppNameA = ConvertWtoA( lpAppName );
    lpKeyNameA = ConvertWtoA( lpKeyName );
    lpDefaultA = ConvertWtoA( lpDefault );
    lpFileNameA= ConvertWtoA( lpFileName );

    nSizeA = nSize * sizeof(WCHAR)+1;
    lpReturnedStringA = LocalAlloc( LMEM_ZEROINIT,  nSizeA );

    nSizeA = GetPrivateProfileStringA(lpAppNameA,lpKeyNameA,lpDefaultA,lpReturnedStringA,nSizeA,lpFileNameA);

    lpReturnedStringW = ConvertAtoW( lpReturnedStringA );

    dRetValue = My_wcslen( lpReturnedStringW );

    My_wcscpy(lpReturnedString, lpReturnedStringW);

    LocalFreeAndNull( &lpAppNameA );
    LocalFreeAndNull( &lpKeyNameA );
    LocalFreeAndNull( &lpDefaultA );
    LocalFreeAndNull( &lpReturnedStringA );
    LocalFreeAndNull( &lpReturnedStringW );
    LocalFreeAndNull( &lpFileNameA );

    return dRetValue;

}


// lstrcmp
int WINAPI lstrcmpWrapW( LPCTSTR lpString1,    // pointer to first string
                         LPCTSTR lpString2 )   // pointer to second string
{

    int     iRetValue = 0;
    LPSTR   lpString1A = NULL ;
    LPSTR   lpString2A = NULL ;


    VALIDATE_PROTOTYPE(lstrcmp);
    
    if (g_bRunningOnNT)
        return lstrcmpW(lpString1, lpString2);

    lpString1A = ConvertWtoA( lpString1 );
    lpString2A = ConvertWtoA( lpString2 );

    iRetValue = lstrcmpA(lpString1A, lpString2A );

    LocalFreeAndNull( &lpString1A );
    LocalFreeAndNull( &lpString2A );

    return iRetValue;


}

HANDLE WINAPI CreateMutexWrapW( LPSECURITY_ATTRIBUTES lpMutexAttributes,
                                                                       // pointer to security attributes
                                BOOL                  bInitialOwner,   // flag for initial ownership
                                LPCTSTR               lpName )        // pointer to mutex-object name
{

    LPSTR lpNameA = NULL;
    HANDLE hMutex = NULL;

    VALIDATE_PROTOTYPE(CreateMutex);

    if (g_bRunningOnNT)
        return CreateMutexW(lpMutexAttributes, bInitialOwner, lpName);

    lpNameA = ConvertWtoA(lpName);

    hMutex = CreateMutexA(lpMutexAttributes, bInitialOwner, lpNameA);

    LocalFreeAndNull(&lpNameA);

    return hMutex;

}

// GetTempPath
DWORD WINAPI GetTempPathWrapW( DWORD   nBufferLength,  // size, in characters, of the buffer
                               LPTSTR  lpBuffer )      // pointer to buffer for temp. path
{

    DWORD  nRequired = 0;
    CHAR   lpBufferA[MAX_PATH];
    LPWSTR lpBufferW = NULL;

    VALIDATE_PROTOTYPE(GetTempPath);
    
    if (g_bRunningOnNT)
        return GetTempPathW(nBufferLength, lpBuffer);

    nRequired = GetTempPathA(MAX_PATH, lpBufferA);

    lpBufferW = ConvertAtoW(lpBufferA);

    nRequired = My_wcslen(lpBufferW);

    if ( nRequired < nBufferLength) 
        CopyMemory(lpBuffer, lpBufferW, (nRequired+1)*sizeof(WCHAR) );

    return nRequired;
}

// ExpandEnvironmentStrings
DWORD WINAPI ExpandEnvironmentStringsWrapW( LPCTSTR lpSrc,     // pointer to string with environment variables
                                            LPTSTR  lpDst,     // pointer to string with expanded environment 
                                                               // variables
                                            DWORD   nSize )   // maximum characters in expanded string
{


    DWORD   dRetValue = 0;
    LPSTR   lpSrcA = NULL;
    LPSTR   lpDstA = NULL;
    LPWSTR  lpDstW = NULL;
    DWORD   nSizeA = 0;

    VALIDATE_PROTOTYPE(ExpandEnvironmentStrings);
    
    if (g_bRunningOnNT)
        return ExpandEnvironmentStringsW(lpSrc, lpDst, nSize);


    nSizeA = nSize * sizeof(WCHAR);

    lpDstA = LocalAlloc( LMEM_ZEROINIT, nSizeA );

    lpSrcA = ConvertWtoA( lpSrc );

    dRetValue = ExpandEnvironmentStringsA( lpSrcA, lpDstA, nSizeA );

    lpDstW = ConvertAtoW( lpDstA );

    dRetValue = My_wcslen( lpDstW );

    if ( dRetValue < nSize ) 
        My_wcscpy(lpDst, lpDstW);

    LocalFreeAndNull( &lpSrcA );
    LocalFreeAndNull( &lpDstA );
    LocalFreeAndNull( &lpDstW );

    return dRetValue;
}

// GetTempFileName
UINT WINAPI GetTempFileNameWrapW( LPCTSTR lpPathName,        // pointer to directory name for temporary file
                                  LPCTSTR lpPrefixString,    // pointer to filename prefix
                                  UINT    uUnique,           // number used to create temporary filename
                                  LPTSTR  lpTempFileName  ) // pointer to buffer that receives the new filename                                                           
{

    UINT     uRetValue = 0;
    LPSTR    lpPathNameA = NULL;
    LPSTR    lpPrefixStringA = NULL;
    CHAR     lpTempFileNameA[MAX_PATH];
    LPWSTR   lpTempFileNameW = NULL;

    VALIDATE_PROTOTYPE(GetTempFileName);
    
    if (g_bRunningOnNT)
        return GetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpTempFileName);

    lpPathNameA = ConvertWtoA( lpPathName );
    lpPrefixStringA = ConvertWtoA( lpPrefixString );

    uRetValue = GetTempFileNameA(lpPathNameA, lpPrefixStringA, uUnique, lpTempFileNameA);

    if ( uRetValue != 0 ) {

        lpTempFileNameW = ConvertAtoW( lpTempFileNameA );
        My_wcscpy( lpTempFileName, lpTempFileNameW );
        LocalFreeAndNull( &lpTempFileNameW );
    }

    LocalFreeAndNull( &lpPathNameA );
    LocalFreeAndNull( &lpPrefixStringA );
    
    return uRetValue;

}

// BOOL WINAPI ReleaseMutexWrapW( HANDLE hMutex )  // handle to mutex object

// DeleteFile                                                        
BOOL WINAPI DeleteFileWrapW( LPCTSTR lpFileName  ) // pointer to name of file to delete
{
    BOOL    bRetValue ;
    LPSTR   lpFileNameA = NULL;

    VALIDATE_PROTOTYPE(DeleteFile);
    
    if (g_bRunningOnNT)
        return DeleteFileW(lpFileName);


    lpFileNameA = ConvertWtoA( lpFileName );

    bRetValue = DeleteFileA( lpFileNameA );

    LocalFreeAndNull( &lpFileNameA );

    return bRetValue;

}

// CopyFile
BOOL WINAPI CopyFileWrapW( LPCTSTR lpExistingFileName, // pointer to name of an existing file
                           LPCTSTR lpNewFileName,      // pointer to filename to copy to
                           BOOL    bFailIfExists )     // flag for operation if file exists
{

    BOOL    bRetValue;
    LPSTR   lpExistingFileNameA = NULL;
    LPSTR   lpNewFileNameA = NULL;

    VALIDATE_PROTOTYPE(CopyFile);
    
    if (g_bRunningOnNT)
        return CopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);


    lpExistingFileNameA = ConvertWtoA( lpExistingFileName );
    lpNewFileNameA = ConvertWtoA( lpNewFileName );

    bRetValue = CopyFileA( lpExistingFileNameA, lpNewFileNameA, bFailIfExists);

    LocalFreeAndNull( & lpExistingFileNameA );
    LocalFreeAndNull( & lpNewFileNameA );

    return bRetValue;
}


// FindFirstChangeNotification
HANDLE WINAPI FindFirstChangeNotificationWrapW(LPCTSTR  lpcwszFilePath, // Directory path of file to watch
                                           BOOL     bWatchSubtree,      // Monitor entire tree
                                           DWORD    dwNotifyFilter)     // Conditions to watch for
{
    HANDLE  hRet;
    LPSTR   lpszFilePath;

    VALIDATE_PROTOTYPE(FindFirstChangeNotification);

    Assert(lpcwszFilePath);

    if (g_bRunningOnNT)
        return FindFirstChangeNotification(lpcwszFilePath, bWatchSubtree, dwNotifyFilter);

    lpszFilePath = ConvertWtoA(lpcwszFilePath);
    hRet = FindFirstChangeNotificationA(lpszFilePath, bWatchSubtree, dwNotifyFilter);
    LocalFreeAndNull(&lpszFilePath);

    return hRet;
}


// FindFirstFile
HANDLE WINAPI FindFirstFileWrapW( LPCTSTR           lpFileName,       // pointer to name of file to search for
                                  LPWIN32_FIND_DATA lpFindFileData )  // pointer to returned information
                       
{
    HANDLE            hRetValue;
    LPSTR             lpFileNameA = NULL;
    WIN32_FIND_DATAA  FindFileDataA;
    WIN32_FIND_DATAW  FindFileDataW;


    VALIDATE_PROTOTYPE(FindFirstFile);
    
    if (g_bRunningOnNT)
        return FindFirstFileW(lpFileName, lpFindFileData);


    lpFileNameA = ConvertWtoA(lpFileName);
    
    hRetValue = FindFirstFileA( lpFileNameA, &FindFileDataA );

    if ( hRetValue != INVALID_HANDLE_VALUE ) {
        
        CopyMemory( &FindFileDataW, &FindFileDataA,  sizeof(WIN32_FIND_DATAA)-MAX_PATH-14 );

        MultiByteToWideChar(GetACP(),0,FindFileDataA.cFileName,MAX_PATH,FindFileDataW.cFileName,MAX_PATH); 
        MultiByteToWideChar(GetACP(),0,FindFileDataA.cAlternateFileName,14,FindFileDataW.cAlternateFileName,14); 

        CopyMemory( lpFindFileData, &FindFileDataW, sizeof(WIN32_FIND_DATAW) );
    }

    LocalFreeAndNull( &lpFileNameA );

    return hRetValue;

}

// GetDiskFreeSpace
BOOL WINAPI GetDiskFreeSpaceWrapW( LPCTSTR lpRootPathName,       // pointer to root path
                                   LPDWORD lpSectorsPerCluster,  // pointer to sectors per cluster
                                   LPDWORD lpBytesPerSector,     // pointer to bytes per sector
                                   LPDWORD lpNumberOfFreeClusters,
                                                                 // pointer to number of free clusters
                                   LPDWORD lpTotalNumberOfClusters )
                                                                 // pointer to total number of clusters
{
    BOOL   bRetValue;
    LPSTR  lpRootPathNameA = NULL;

    VALIDATE_PROTOTYPE(GetDiskFreeSpace);
    
    if (g_bRunningOnNT)
        return GetDiskFreeSpaceW(lpRootPathName, 
                                 lpSectorsPerCluster, 
                                 lpBytesPerSector, 
                                 lpNumberOfFreeClusters,
                                 lpTotalNumberOfClusters);

    lpRootPathNameA = ConvertWtoA( lpRootPathName );

    bRetValue = GetDiskFreeSpaceA(lpRootPathNameA, 
                                 lpSectorsPerCluster, 
                                 lpBytesPerSector, 
                                 lpNumberOfFreeClusters,
                                 lpTotalNumberOfClusters);

    LocalFreeAndNull( & lpRootPathNameA );

    return bRetValue;

}

// MoveFile
BOOL WINAPI MoveFileWrapW( LPCTSTR lpExistingFileName,   // pointer to the name of the existing file
                           LPCTSTR lpNewFileName )       // pointer to the new name for the file

{

    BOOL  bRetValue;
    LPSTR lpExistingFileNameA = NULL;
    LPSTR lpNewFileNameA = NULL;

    VALIDATE_PROTOTYPE(MoveFile);
    
    if (g_bRunningOnNT)
        return MoveFileW(lpExistingFileName, lpNewFileName);


    lpExistingFileNameA = ConvertWtoA( lpExistingFileName );
    lpNewFileNameA = ConvertWtoA( lpNewFileName );

    bRetValue = MoveFileA( lpExistingFileNameA, lpNewFileNameA );

    LocalFreeAndNull( &lpExistingFileNameA );
    LocalFreeAndNull( &lpNewFileNameA );

    return bRetValue;

}

// CreateEvent
HANDLE WINAPI CreateEventWrapW(LPSECURITY_ATTRIBUTES lpEventAttributes, // pointer to security attributes
                               BOOL bManualReset,     // flag for manual-reset event
                               BOOL bInitialState,    // flag for initial state
                               LPCTSTR lpcwszName)    // pointer to event-object name
{
    HANDLE  hRet;
    LPSTR   lpszName;

    VALIDATE_PROTOTYPE(CreateEvent);

    if (g_bRunningOnNT)
        return CreateEventW(lpEventAttributes, bManualReset, bInitialState, lpcwszName);

    lpszName = ConvertWtoA(lpcwszName);     // Handles NULL lpcwszName case
    hRet = CreateEventA(lpEventAttributes, bManualReset, bInitialState, lpszName);
    LocalFreeAndNull(&lpszName);

    return hRet;
}


//SHELL32.DLL


HINSTANCE WINAPI ShellExecuteWrapW( HWND     hwnd, 
                                    LPCTSTR  lpOperation,
                                    LPCTSTR  lpFile, 
                                    LPCTSTR  lpParameters, 
                                    LPCTSTR  lpDirectory,
                                    INT      nShowCmd )
	
{
    HINSTANCE  hRetValue;
    LPSTR      lpOperationA = NULL;
    LPSTR      lpFileA = NULL; 
    LPSTR      lpParametersA = NULL; 
    LPSTR      lpDirectoryA = NULL;

    VALIDATE_PROTOTYPE(ShellExecute);
    
    if (g_bRunningOnNT)
        return ShellExecuteW(hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd);


    lpOperationA = ConvertWtoA( lpOperation );
    lpFileA      = ConvertWtoA( lpFile );
    lpParametersA= ConvertWtoA( lpParameters );
    lpDirectoryA = ConvertWtoA( lpDirectory );

    hRetValue = ShellExecuteA(hwnd, lpOperationA, lpFileA, lpParametersA, lpDirectoryA, nShowCmd);

    LocalFreeAndNull( &lpOperationA);
    LocalFreeAndNull( &lpFileA );
    LocalFreeAndNull( &lpParametersA );
    LocalFreeAndNull( &lpDirectoryA );

    return hRetValue;

}

// DragQueryFile
UINT WINAPI DragQueryFileWrapW( HDROP   hDrop,
                                UINT    iFile,
                                LPTSTR  lpszFile,
                                UINT    cch )


{
    UINT   uRetValue = 0;
    LPSTR  lpszFileA = NULL;
    LPWSTR lpszFileW = NULL;
    UINT   cchA, cchW =0;

    VALIDATE_PROTOTYPE(DragQueryFile);
    
    if (g_bRunningOnNT)
        return DragQueryFileW(hDrop, iFile, lpszFile, cch);

    cchA = DragQueryFileA( hDrop, iFile, NULL, 0 );

    lpszFileA = LocalAlloc(LMEM_ZEROINIT, cchA+1 );

    uRetValue = DragQueryFileA(hDrop, iFile, lpszFileA, cchA+1);

    lpszFileW = ConvertAtoW( lpszFileA );
    cchW = My_wcslen( lpszFileW );

    if ( lpszFile )

        CopyMemory( lpszFile, lpszFileW, (cchW+1)*sizeof(WCHAR) );

    LocalFreeAndNull( &lpszFileA );
    LocalFreeAndNull( &lpszFileW );

    return cchW;

}

//USER32.DLL
// CharPrev
LPTSTR WINAPI CharPrevWrapW( LPCTSTR lpszStart,      // pointer to first character
                             LPCTSTR lpszCurrent )   // pointer to current character
{

    LPWSTR lpszReturn = NULL;

    VALIDATE_PROTOTYPE(CharPrev);
    
    if (g_bRunningOnNT)
        return CharPrevW(lpszStart, lpszCurrent);

    if (lpszCurrent == lpszStart)
         lpszReturn = (LPWSTR)lpszStart;

    lpszReturn = (LPWSTR)lpszCurrent - 1;

    return lpszReturn;

}

// DrawText
int WINAPI DrawTextWrapW( HDC     hDC,          // handle to device context
                          LPCTSTR lpString,     // pointer to string to draw
                          int     nCount,       // string length, in characters
                          LPRECT  lpRect,       // pointer to struct with formatting dimensions
                          UINT    uFormat )     // text-drawing flags
{
    int    iRetValue = 0;
    LPSTR  lpStringA = NULL;

    VALIDATE_PROTOTYPE(DrawText);
    
    if (g_bRunningOnNT)
        return DrawTextW(hDC, lpString, nCount, lpRect, uFormat);

    lpStringA = ConvertWtoA( lpString );

    iRetValue = DrawTextA(hDC, lpStringA, nCount, lpRect, uFormat);

    LocalFreeAndNull( &lpStringA );

    return iRetValue;

}

// ModifyMenu
BOOL WINAPI ModifyMenuWrapW( HMENU   hMenu,         // handle to menu
                             UINT    uPosition,    // menu item to modify
                             UINT    uFlags,       // menu item flags
                             UINT_PTR    uIDNewItem,   // menu item identifier or handle to drop-down 
                                                   // menu or submenu
                             LPCTSTR lpNewItem )   // menu item content
{

    BOOL   bRetValue;
    LPSTR  lpNewItemA = NULL;

    VALIDATE_PROTOTYPE(ModifyMenu);
    
    if (g_bRunningOnNT)
        return ModifyMenuW(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);

    Assert(lpNewItem);

    // [PaulHi] 4/5/99 Raid 75428  MF_STRING is defined to be 0x00000000.  Need
    // to check alternative interpretations of lpNewItem.
    // MF_BITMAP = 0x00000004L
    // MF_OWNERDRAW = 0x00000100L
    // If this Assert fires then it implies that a new bit defining lpNewItem may have
    // been added to this API!!!  If so add this definition to the uFlags if statement.
    Assert( !(uFlags & ~(MF_BITMAP|MF_BYCOMMAND|MF_BYPOSITION|MF_CHECKED|MF_DISABLED|MF_GRAYED|MF_MENUBARBREAK|MF_MENUBREAK|MF_OWNERDRAW|MF_POPUP|MF_SEPARATOR|MF_UNCHECKED)));
    if (uFlags  & (MF_BITMAP | MF_OWNERDRAW))   // lpNewItem is NOT a string pointer
        return ModifyMenuA(hMenu, uPosition, uFlags, uIDNewItem, (LPCSTR)lpNewItem);

    lpNewItemA = ConvertWtoA( lpNewItem );

    bRetValue = ModifyMenuA(hMenu, uPosition, uFlags, uIDNewItem, lpNewItemA);

    LocalFreeAndNull( &lpNewItemA );

    return bRetValue;
}

// InsertMenu
BOOL WINAPI InsertMenuWrapW( HMENU   hMenu,       // handle to menu
                             UINT    uPosition,   // menu item that new menu item precedes
                             UINT    uFlags,      // menu item flags
                             UINT_PTR    uIDNewItem,  // menu item identifier or handle to drop-down 
                                                  // menu or submenu
                             LPCTSTR lpNewItem ) // menu item content
{
    BOOL   bRetValue;
    LPSTR  lpNewItemA = NULL;

    VALIDATE_PROTOTYPE(InsertMenu);
    
    if (g_bRunningOnNT)
        return InsertMenuW(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);

   if (uFlags & MF_BITMAP || uFlags & MF_OWNERDRAW) // if anything but MF_STRING .. note: MF_STRING = 0x00000000
        return InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, (LPCSTR)lpNewItem);

    lpNewItemA = ConvertWtoA( lpNewItem );

    bRetValue = InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, lpNewItemA);

    LocalFreeAndNull( &lpNewItemA );

    return bRetValue;

}

// LoadImage
HANDLE WINAPI LoadImageWrapW( HINSTANCE hinst,      // handle of the instance containing the image
                              LPCTSTR   lpszName,   // name or identifier of image
                              UINT      uType,      // type of image
                              int       cxDesired,  // desired width
                              int       cyDesired,  // desired height
                              UINT      fuLoad )    // load flags
{
    HANDLE hRetValue;
    LPSTR  lpszNameA = NULL;

    VALIDATE_PROTOTYPE(LoadImage);
    
    if (g_bRunningOnNT)
        return LoadImageW(hinst, lpszName, uType, cxDesired, cyDesired, fuLoad);


    lpszNameA = ConvertWtoA( lpszName );

    hRetValue = LoadImageA(hinst, lpszNameA, uType, cxDesired, cyDesired, fuLoad);

    LocalFreeAndNull( & lpszNameA );

    return hRetValue;

}

// GetClassInfoEx
BOOL WINAPI GetClassInfoExWrapW( HINSTANCE    hinst,      // handle of application instance
                                 LPCTSTR      lpszClass,  // address of class name string
                                 LPWNDCLASSEX lpwcx )    // address of structure for class data
{

    BOOL        bRetValue;
    LPSTR       lpszClassA = NULL;
    WNDCLASSEXA wcxA;
    WNDCLASSEXW wcxW;

    VALIDATE_PROTOTYPE(GetClassInfoEx);
    
    if (g_bRunningOnNT)
        return GetClassInfoExW(hinst, lpszClass, lpwcx);

    lpszClassA = ConvertWtoA( lpszClass );

    wcxA.cbSize = sizeof( WNDCLASSEXA );

    bRetValue = GetClassInfoExA( hinst, lpszClassA, &wcxA );

    if ( bRetValue == FALSE ) {
        LocalFreeAndNull( &lpszClassA );
        return bRetValue;
    }

    CopyMemory( &wcxW, &wcxA, sizeof(WNDCLASSEXA) );
    wcxW.cbSize = sizeof(WNDCLASSEXW);

    if ( wcxA.lpszMenuName && !IS_INTRESOURCE(wcxA.lpszMenuName) ) 
       wcxW.lpszMenuName = ConvertAtoW( wcxA.lpszMenuName );

    if ( wcxA.lpszClassName && !IS_INTRESOURCE(wcxA.lpszClassName) ) // lpszClassName can be an atom, high word is null
       wcxW.lpszClassName = ConvertAtoW( wcxA.lpszClassName );

    CopyMemory(lpwcx, &wcxW, sizeof(WNDCLASSEXW) );

    LocalFreeAndNull( &lpszClassA );

    return bRetValue;
}

// LoadString
int WINAPI LoadStringWrapW( HINSTANCE hInstance,     // handle to module containing string resource
                            UINT      uID,           // resource identifier
                            LPTSTR    lpBuffer,      // pointer to buffer for resource
                            int       nBufferMax  ) // size of buffer
{
    int    iRetValue = 0;
    LPSTR  lpBufferA = NULL;
    int    nBuffer = 0;
    LPWSTR lpBufferW= NULL;

    VALIDATE_PROTOTYPE(LoadString);
    
    if (g_bRunningOnNT)
        return LoadStringW(hInstance, uID, lpBuffer, nBufferMax);

    nBuffer = nBufferMax * sizeof(WCHAR);
    lpBufferA = LocalAlloc(LMEM_ZEROINIT, nBuffer );

    iRetValue = LoadStringA(hInstance, uID, lpBufferA, nBuffer);

    lpBufferW = ConvertAtoW( lpBufferA );
    nBuffer = My_wcslen( lpBufferW );

    if ( nBuffer >= nBufferMax )
        nBuffer = nBufferMax - 1;

    CopyMemory(lpBuffer, lpBufferW, nBuffer * sizeof( WCHAR) );

    lpBuffer[nBuffer] = 0x0000;

    LocalFreeAndNull( &lpBufferA );
    LocalFreeAndNull( &lpBufferW );

    return nBuffer;
}

// CharNext
LPTSTR WINAPI CharNextWrapW( LPCTSTR lpsz )  // pointer to current character
{

    LPWSTR  lpwsz = NULL;

    VALIDATE_PROTOTYPE(CharNext);
    
    if (g_bRunningOnNT)
        return CharNextW(lpsz);

    if ( *lpsz == 0x0000 )
        lpwsz = (LPWSTR)lpsz;
    else
        lpwsz = (LPWSTR)lpsz + 1;

    return  lpwsz;

}



LRESULT WINAPI ListView_GetItemTextA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam) 
{
    LRESULT     lRetValue;
    LVITEMA     lviA;
    LPLVITEMW   lplviW;
    LPSTR       lpszText;
    LPWSTR      lpszTextW;
    DWORD       iMinLen;

    lplviW = (LPLVITEMW) lParam;

    CopyMemory( &lviA, lplviW, sizeof( LVITEMA ) );

    iMinLen = lplviW->cchTextMax * sizeof( WCHAR );
    lpszText = LocalAlloc( LMEM_ZEROINIT, iMinLen  );

    lviA.cchTextMax = iMinLen ;
    lviA.pszText = lpszText;

    lRetValue = SendMessageA(hWnd, LVM_GETITEMTEXTA, wParam, (LPARAM)(LVITEMA FAR *)&lviA );

    lpszTextW = ConvertAtoW( lviA.pszText );

    if ( iMinLen > (lstrlenW( lpszTextW ) + 1) * sizeof( WCHAR)  )
        iMinLen = (lstrlenW( lpszTextW ) + 1) * sizeof( WCHAR) ;

    CopyMemory( lplviW->pszText, lpszTextW, iMinLen );

    LocalFreeAndNull( &lpszText );
    LocalFreeAndNull( &lpszTextW );

    return lRetValue;

}


LRESULT WINAPI ListView_GetItemA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam) 
{
    LRESULT     lRetValue;
    LVITEMA     lviA;
    LPLVITEMW   lplviW = NULL;
    LPSTR       lpszText = NULL;
    LPWSTR      lpszTextW = NULL;
    DWORD       iMinLen;

    lplviW = (LPLVITEMW) lParam;

    CopyMemory( &lviA, lplviW, sizeof( LVITEMA ) );

    iMinLen = 0;

    if ( lplviW->mask & LVIF_TEXT ) {
    
       iMinLen = lplviW->cchTextMax * sizeof( WCHAR );
       lpszText = LocalAlloc( LMEM_ZEROINIT, iMinLen  );
       lviA.cchTextMax = iMinLen ;
       lviA.pszText = lpszText;
    }


    lRetValue = SendMessageA(hWnd, LVM_GETITEMA, wParam, (LPARAM)(LVITEMA FAR *)&lviA );

 
    lplviW->mask      = lviA.mask;
    lplviW->iItem     = lviA.iItem;
    lplviW->iSubItem  = lviA.iSubItem;
    lplviW->state     = lviA.state;
    lplviW->stateMask = lviA.stateMask;
    lplviW->iImage    = lviA.iImage;
    lplviW->lParam    = lviA.lParam;

#if (_WIN32_IE >= 0x0300)
    lplviW->iIndent   = lviA.iIndent;
#endif

    if ( lplviW->mask & LVIF_TEXT ) {

       lpszTextW = ConvertAtoW( lviA.pszText );

       if ( iMinLen > (lstrlenW( lpszTextW ) + 1) * sizeof( WCHAR)  )
           iMinLen = (lstrlenW( lpszTextW ) + 1) * sizeof( WCHAR) ;

       CopyMemory( lplviW->pszText, lpszTextW, iMinLen );
    }

   
   LocalFreeAndNull( &lpszText );

   LocalFreeAndNull( &lpszTextW );

    return lRetValue;

}



LRESULT WINAPI ListView_InsertItemA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{

    LRESULT     lRetValue;
    LVITEMA     lviA;
    LPLVITEMW   lplviW;
    LPSTR       lpszText = NULL;
    
    lplviW = (LPLVITEMW) lParam;

    CopyMemory( &lviA, lplviW, sizeof( LVITEMA ) );

    if ( (lplviW->mask & LVIF_TEXT) && (lplviW->pszText != NULL)  ) {
       lpszText = ConvertWtoA( lplviW->pszText );
       lviA.cchTextMax = lstrlenA( lpszText ) + 1 ;
    }

    lviA.pszText = lpszText;

    lRetValue = SendMessageA(hWnd, LVM_INSERTITEMA, wParam, (LPARAM)(LVITEMA FAR *)&lviA );

    LocalFreeAndNull( &lpszText );
    

    return lRetValue;

}



LRESULT WINAPI ListView_SetItemA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{

    LRESULT     lRetValue;
    LVITEMA     lviA;
    LPLVITEMW   lplviW;
    LPSTR       lpszText = NULL;
    
    lplviW = (LPLVITEMW) lParam;

    CopyMemory( &lviA, lplviW, sizeof( LVITEMA ) );

    if ( (lplviW->mask & LVIF_TEXT ) && (lplviW->pszText != NULL) ) {
       lpszText = ConvertWtoA( lplviW->pszText );
       lviA.cchTextMax = lstrlenA( lpszText ) + 1 ;
       lviA.pszText = lpszText;

    }


    lRetValue = SendMessageA(hWnd, LVM_SETITEMA, wParam, (LPARAM)(LVITEMA FAR *)&lviA );

   LocalFreeAndNull( &lpszText );
    

    return lRetValue;

}



LRESULT WINAPI ListView_SetItemTextA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{

    LRESULT     lRetValue;
    LVITEMA     lviA;
    LPLVITEMW   lplviW;
    LPSTR       lpszText;
    
    lplviW = (LPLVITEMW) lParam;

    CopyMemory( &lviA, lplviW, sizeof( LVITEMA ) );

    lpszText = ConvertWtoA( lplviW->pszText );
    lviA.cchTextMax = lstrlenA( lpszText ) + 1 ;
    lviA.pszText = lpszText;

    lRetValue = SendMessageA(hWnd, LVM_SETITEMTEXTA, wParam, (LPARAM)(LVITEMA FAR *)&lviA );

    LocalFreeAndNull( &lpszText );
    

    return lRetValue;

}



LRESULT WINAPI ListView_SetColumnA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{

    LRESULT     lRetValue;
    LVCOLUMNA   lvcA;
    LPLVCOLUMNW lplvcW;
    LPSTR       lpszText = NULL;
    
    lplvcW = (LPLVCOLUMNW) lParam;

    CopyMemory( &lvcA, lplvcW, sizeof( LVCOLUMNA ) );

    if ( (lplvcW->mask & LVCF_TEXT ) && (lplvcW->pszText != NULL) ) {
       lpszText = ConvertWtoA( lplvcW->pszText );
       lvcA.cchTextMax = lstrlenA( lpszText ) + 1 ;
    }

    lvcA.pszText = lpszText;

    lRetValue = SendMessageA(hWnd, LVM_SETCOLUMNA, wParam, (LPARAM)(LPLVCOLUMNA)&lvcA );

   LocalFreeAndNull( &lpszText );
    

    return lRetValue;


}



LRESULT WINAPI ListView_InsertColumnA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{

    LRESULT     lRetValue;
    LVCOLUMNA   lvcA;
    LPLVCOLUMNW lplvcW;
    LPSTR       lpszText = NULL;
    
    lplvcW = (LPLVCOLUMNW) lParam;

    CopyMemory( &lvcA, lplvcW, sizeof( LVCOLUMNA ) );

    if ( (lplvcW->mask & LVCF_TEXT ) && (lplvcW->pszText != NULL)  ) {
       lpszText = ConvertWtoA( lplvcW->pszText );
       lvcA.cchTextMax = lstrlenA( lpszText ) + 1 ;
    }

    lvcA.pszText = lpszText;

    lRetValue = SendMessageA(hWnd, LVM_INSERTCOLUMNA, wParam, (LPARAM)(LPLVCOLUMNA)&lvcA );

   LocalFreeAndNull( &lpszText );
    

    return lRetValue;

}


LRESULT WINAPI ListView_FindItemA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{

    LRESULT        lRetValue;
    LPSTR          lpsz = NULL;
    LVFINDINFOA    lvfiA;
    LPFINDINFOW    lplvfiW;
    
    lplvfiW = (LPFINDINFOW) lParam;

    CopyMemory( &lvfiA, lplvfiW, sizeof(LVFINDINFOA ) );

    if ( (lplvfiW->flags & LVFI_PARTIAL) ||  (lplvfiW->flags & LVFI_STRING) ) {

        if ( lplvfiW->psz != NULL ) {
           lpsz = ConvertWtoA( lplvfiW->psz );
        }

    }

    lvfiA.psz = lpsz;

    if ( lplvfiW->flags  & LVFI_PARAM ) {
        // we must convert field lParam, but this is not the case in our current code 
        // so ignore it.

        if ( lplvfiW->lParam )
            lvfiA.lParam = lplvfiW->lParam;

    }

    lRetValue = SendMessageA(hWnd, LVM_FINDITEMA, wParam, (LPARAM)(LVFINDINFOA FAR *)&lvfiA );

   LocalFreeAndNull( &lpsz );
    

    return lRetValue;

}



LRESULT WINAPI ListView_SortItemsA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{


    // not implement yet.

    return SendMessageA( hWnd, Msg, wParam, lParam );
}


LRESULT WINAPI ListView_EditLabelA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{
        return SendMessageA(hWnd, LVM_EDITLABELA, wParam, lParam );
}


LRESULT WINAPI ToolBar_AddString(HWND hWnd, LPARAM lParam)
{

    LRESULT lRetValue;
    LPSTR   pStringA = NULL;
    LPWSTR  pStringW = NULL;
    LPSTR   pStringA_T = NULL, pStringAA = NULL;
    DWORD   dwLen;
    WPARAM  wParam = 0;

   // get the total length of pStringW       
    if (g_bRunningOnNT)
       return SendMessageW(hWnd, TB_ADDSTRINGW, wParam, lParam );

   dwLen = 0;

   pStringW = (LPWSTR)(lParam);

   while ( *pStringW != TEXT('\0') ) {
        dwLen += lstrlenW(pStringW) + 1;
        pStringW += lstrlenW(pStringW) + 1;
   }

   dwLen += 1;  // for the last null terminator

   pStringW = (LPWSTR)( lParam );
   pStringA = LocalAlloc( LMEM_ZEROINIT, dwLen * sizeof(WCHAR) );
   
   pStringA_T = pStringA;

   while ( *pStringW != TEXT('\0') ) { 
         pStringAA = ConvertWtoA(pStringW );
         pStringW += lstrlenW(pStringW) + 1;
         strcpy(pStringA_T, pStringAA );
         LocalFreeAndNull( &pStringAA );
         pStringA_T += lstrlenA( pStringA_T ) + 1;
   }

   pStringA_T[lstrlenA(pStringA_T)+1] = '\0';


   lRetValue = SendMessageA(hWnd, TB_ADDSTRINGA, wParam, (LPARAM)pStringA );

   LocalFreeAndNull( &pStringA );

   return lRetValue;

}


LRESULT WINAPI ToolBar_AddButtons(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    if (g_bRunningOnNT)
       return SendMessageW( hWnd, TB_ADDBUTTONSW, wParam, lParam );

   return SendMessageA( hWnd, TB_ADDBUTTONSA, wParam, lParam );

}

LRESULT WINAPI TreeView_GetItemA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{

    LRESULT    lRetValue;
    TVITEMA    tviA;
    LPTVITEMW  lptviW;
    LPWSTR     lpszTextW = NULL;
    LPSTR      lpszTextA = NULL;



    lptviW = (LPTVITEMW) lParam;

    CopyMemory( &tviA, lptviW, sizeof( TVITEMA ) );

    if ( lptviW->mask & TVIF_TEXT ) {

        lpszTextA = ConvertWtoA( lptviW->pszText ) ;
        tviA.pszText = lpszTextA;
        tviA.cchTextMax = lstrlenA( lpszTextA ) + 1;
    }

    lRetValue = SendMessageA( hWnd, TVM_GETITEMA, wParam, (LPARAM)(LPTVITEMA)&tviA );

    if ( lptviW->mask & TVIF_TEXT ) 
        lpszTextW = ConvertAtoW( tviA.pszText );

    lptviW->mask = tviA.mask;
    lptviW->hItem = tviA.hItem;
    lptviW->state = tviA.state;
    lptviW->stateMask = tviA.stateMask;
    if ( lpszTextW ) {
       CopyMemory(lptviW->pszText, lpszTextW, (lstrlenW(lpszTextW)+1) * sizeof(WCHAR) );
       lptviW->cchTextMax = lstrlenW( lpszTextW ) + 1;
    }
    
    lptviW->iImage = tviA.iImage;
    lptviW->iSelectedImage = tviA.iSelectedImage;
    lptviW->cChildren = tviA.cChildren;
    lptviW->lParam = tviA.lParam;


    LocalFreeAndNull( &lpszTextA );

    LocalFreeAndNull( &lpszTextW );

    return lRetValue;

}


LRESULT WINAPI TreeView_SetItemA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{

    LRESULT     lRetValue;
    TVITEMA     tviA;
    LPTVITEMW   lptviW;
    LPSTR       pszTextA = NULL;


    lptviW = (LPTVITEMW) lParam;
    CopyMemory( &tviA, lptviW, sizeof( TVITEMA ) );

    if ( (lptviW->mask & TVIF_TEXT)  && (lptviW->pszText != NULL) ) {
        pszTextA = ConvertWtoA( lptviW->pszText );
        tviA.cchTextMax = lstrlenA( pszTextA );
    }

    tviA.pszText = pszTextA;

    lRetValue = SendMessageA( hWnd, TVM_SETITEMA, wParam, (LPARAM)(const TV_ITEM FAR*)&tviA );
    
    LocalFreeAndNull( &pszTextA );

    return lRetValue;

}


LRESULT WINAPI TreeView_InsertItemA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{

    LRESULT            lRetValue;
    LPSTR              pszTextA = NULL;
    TVINSERTSTRUCTA    tvisA;
    LPTVINSERTSTRUCTW  lptvisW;

    lptvisW = (LPTVINSERTSTRUCTW)lParam;
    CopyMemory( &tvisA, lptvisW, sizeof( TVINSERTSTRUCTA ) );

    if ( ((lptvisW->item).mask & TVIF_TEXT) && ((lptvisW->item).pszText != NULL)  ) {
        
        pszTextA = ConvertWtoA( (lptvisW->item).pszText );
        tvisA.item.cchTextMax = lstrlenA( pszTextA );
        tvisA.item.pszText = pszTextA;
    }

  
    lRetValue = SendMessageA( hWnd, TVM_INSERTITEMA, wParam, (LPARAM)(LPTVINSERTSTRUCTA)&tvisA );
    
    LocalFreeAndNull( &pszTextA );

    return lRetValue;

}


// Tab Control Message Wrapper

LRESULT  WINAPI TabCtrl_InsertItemA( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam )
{

    LRESULT     lRetValue;
    TCITEMA     tciA;
    LPTCITEMW   lptciW = NULL;
    LPSTR       pszText = NULL;

    lptciW = (LPTCITEMW) lParam;

    CopyMemory( &tciA, lptciW,  sizeof(TCITEMA ) );

    if ( lptciW->mask & TCIF_TEXT ) {
        pszText = ConvertWtoA( lptciW->pszText );
        tciA.pszText = pszText;
        tciA.cchTextMax = lstrlenA( pszText ) + 1;
    }

    lRetValue = SendMessageA( hWnd, TCM_INSERTITEMA, wParam, (LPARAM)(LPTCITEMA)&tciA);

    LocalFreeAndNull( &pszText );

    return lRetValue;

}


// List Box Control Message wrapper

LRESULT WINAPI ListBox_AddStringA(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRetValue;
    LPSTR   lpszStrA = NULL;
    LPWSTR  lpszStrW = NULL;

    lpszStrW = (LPWSTR)lParam;
    lpszStrA = ConvertWtoA(lpszStrW);
    lRetValue = SendMessageA(hWnd, LB_ADDSTRING, wParam, (LPARAM)lpszStrA);

    LocalFreeAndNull(&lpszStrA);
    return lRetValue;
}


// Combo List Control Message wrapper

LRESULT WINAPI Combo_AddStringA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{

   LRESULT  lRetValue;
   LPSTR    lpszStrA = NULL;
   LPWSTR   lpszStrW = NULL;

   lpszStrW = (LPWSTR)lParam;

   lpszStrA = ConvertWtoA( lpszStrW );

   lRetValue = SendMessageA(hWnd, CB_ADDSTRING, wParam, (LPARAM)lpszStrA );

   LocalFreeAndNull( &lpszStrA );

   return lRetValue;

}

LRESULT WINAPI Combo_GetLBTextA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRetValue;
    LPSTR   lpszStrA = NULL;
    LPWSTR  lpszStrW = NULL;
    int     nBytes;

    Assert(lParam);
    *((LPWSTR)lParam) = '\0';

    // Allocate the single byte char buffer to the correct size
    nBytes = (int) SendMessageA(hWnd, CB_GETLBTEXTLEN, wParam, 0) + 1;
    lpszStrA = LocalAlloc(LMEM_FIXED, nBytes);
    if (!lpszStrA)
    {
        Assert(0);
        return 0;
    }
    *lpszStrA = '\0';
    lRetValue = SendMessageA(hWnd, CB_GETLBTEXT, wParam, (LPARAM)(lpszStrA));

    if ( lRetValue == CB_ERR )
        return CB_ERR;

    // lRetValue is the length of string lpszStrA, in Bytes.
    // to make sure lpszStrA is Null-terminated.

    lpszStrA[lRetValue] = '\0';

    lpszStrW = ConvertAtoW( lpszStrA );

    lRetValue = lstrlenW( lpszStrW ) * sizeof(WCHAR);

    CopyMemory( (LPWSTR)lParam,  lpszStrW, lRetValue + sizeof(WCHAR) );

    LocalFreeAndNull(&lpszStrW);
    LocalFreeAndNull(&lpszStrA);

    return (LRESULT)lRetValue;
}

LRESULT WINAPI Combo_InsertStringA(HWND hWnd,UINT Msg, WPARAM wParam,LPARAM lParam)
{

   LRESULT  lRetValue;
   LPSTR    lpszStrA = NULL;
   LPWSTR   lpszStrW = NULL;

   lpszStrW = (LPWSTR)lParam;

   lpszStrA = ConvertWtoA( lpszStrW );

   lRetValue = SendMessageA(hWnd, CB_INSERTSTRING, wParam, (LPARAM)lpszStrA );

   LocalFreeAndNull( &lpszStrA );

   return lRetValue;


}

LRESULT WINAPI Combo_FindStringA(HWND hWnd,UINT Msg, WPARAM wParam,LPARAM lParam)
{

   LRESULT  lRetValue;
   LPSTR    lpszStrA = NULL;
   LPWSTR   lpszStrW = NULL;

   lpszStrW = (LPWSTR)lParam;

   lpszStrA = ConvertWtoA( lpszStrW );

   lRetValue = SendMessageA(hWnd, CB_FINDSTRING, wParam, (LPARAM)lpszStrA );

   LocalFreeAndNull( &lpszStrA );

   return lRetValue;

}


// Animation Control wrappers

LRESULT WINAPI Animate_OpenA( HWND hWnd,UINT Msg, WPARAM wParam,LPARAM lParam)
{
    
  LRESULT  lRetValue;
  

  // lParam pointers to a string or resource String ID, 
  // in our codes, only Resources IDs are passed to this function
  // so we don't want to convert value for this parameter

  lRetValue = SendMessageA( hWnd, ACM_OPENA, wParam, lParam );

  return lRetValue;

}


// Tooltip Wrappers
LRESULT WINAPI ToolTip_AddTool(HWND hWnd,LPARAM lParam)
{

    LRESULT  lRetValue;
    LPSTR    lpszStrA = NULL;
    LPWSTR   lpszStrW = NULL;
    TOOLINFOA TIA = {0}; 
    LPTOOLINFOW lpTIW = (LPTOOLINFOW)lParam;
    WPARAM wParam = 0;

    if (g_bRunningOnNT)
        return SendMessageW(hWnd, TTM_ADDTOOLW, wParam, lParam);

    if(!lpTIW)
        return 0;

    CopyMemory(&TIA, lpTIW, sizeof(TOOLINFOA));

    TIA.lpszText = ConvertWtoA(lpTIW->lpszText); 

    lRetValue = SendMessageA(hWnd, TTM_ADDTOOLA, wParam, (LPARAM)&TIA );

    LocalFreeAndNull( &TIA.lpszText );

    return lRetValue;

}

//
// Guess what TTM_UPDATETIPTEXT is the same as EM_FORMATRANGE .. therefore can't use it 
// through the SendMessage wrapper .. need our own function for this 
LRESULT WINAPI ToolTip_UpdateTipText(HWND hWnd,LPARAM lParam)
{

    LRESULT  lRetValue;
    LPSTR    lpszStrA = NULL;
    LPWSTR   lpszStrW = NULL;
    TOOLINFOA TIA = {0}; 
    LPTOOLINFOW lpTIW = (LPTOOLINFOW)lParam;
    WPARAM wParam = 0;

    if (g_bRunningOnNT)
        return SendMessageW(hWnd, TTM_UPDATETIPTEXTW, wParam, lParam);

    if(!lpTIW)
        return 0;

    CopyMemory(&TIA, lpTIW, sizeof(TOOLINFOA));

    TIA.lpszText = ConvertWtoA(lpTIW->lpszText); 

    lRetValue = SendMessageA(hWnd, TTM_UPDATETIPTEXTA, wParam, (LPARAM)&TIA );

    LocalFreeAndNull( &TIA.lpszText );

    return lRetValue;

}

// SendMessage WM_SETTEXT
LRESULT WINAPI WM_SetTextA( HWND   hWnd,  UINT   Msg,       // message to send
                                 WPARAM wParam,    // first message parameter
                                 LPARAM lParam )  // second message parameter
{
    LRESULT lRetValue = 0;
    LPSTR lpA = ConvertWtoA((LPCWSTR)lParam);
    lRetValue = SendMessageA(hWnd, WM_SETTEXT, wParam, (LPARAM)lpA);
    LocalFreeAndNull(&lpA);
    return lRetValue;
}


// SendMessage
//
// There is a big potential problem with this function .. since we
// are passing ALL the messages through this function, if there are any over-lapping
// message ids (e.g. TTM_UPDATETIPTEXT for tooltips is the same as EM_FORMATRANGE
// for the RichEdit control) with the result that we may route the wrong message to the
// wrong handler.. need to be careful about handling any messages in the WM_USER range ..
// This is specially true for a bunch of CommCtrls.
//  
LRESULT WINAPI SendMessageWrapW( HWND   hWnd,      // handle of destination window
                                 UINT   Msg,       // message to send
                                 WPARAM wParam,    // first message parameter
                                 LPARAM lParam )  // second message parameter
{


    VALIDATE_PROTOTYPE(SendMessage);
    
    if (g_bRunningOnNT)
        return SendMessageW(hWnd, Msg, wParam, lParam);


    switch (Msg) {
        
    case WM_SETTEXT:
                            return WM_SetTextA(hWnd, Msg, wParam, lParam);

 // for ListView Message
    case LVM_GETITEMTEXT :
                            return ListView_GetItemTextA(hWnd, Msg, wParam, lParam);
    case LVM_GETITEM :
                            return ListView_GetItemA(hWnd, Msg, wParam, lParam);
    case LVM_INSERTCOLUMN :
                            return ListView_InsertColumnA( hWnd, Msg, wParam, lParam);
    case LVM_INSERTITEM :
                            return ListView_InsertItemA(hWnd, Msg, wParam, lParam);
    case LVM_SETITEM :
                            return ListView_SetItemA(hWnd, Msg, wParam, lParam);
    case LVM_SETITEMTEXT :   
                            return ListView_SetItemTextA(hWnd, Msg, wParam, lParam);
    case LVM_SETCOLUMN :    
                            return ListView_SetColumnA(hWnd, Msg, wParam, lParam);
    case LVM_FINDITEM :     
                            return ListView_FindItemA(hWnd, Msg, wParam, lParam);
    case LVM_SORTITEMS :    
                            return ListView_SortItemsA(hWnd, Msg, wParam, lParam);
    case LVM_EDITLABEL :    
                            return ListView_EditLabelA(hWnd, Msg, wParam, lParam);

// For TreeView Message
    case TVM_GETITEM :
                            return TreeView_GetItemA(hWnd, Msg, wParam, lParam);
    case TVM_SETITEM :
                            return TreeView_SetItemA(hWnd, Msg, wParam, lParam);
    case TVM_INSERTITEM :
                            return TreeView_InsertItemA(hWnd, Msg, wParam, lParam);

// For TabCtrl Message
    case TCM_INSERTITEM :
                            return TabCtrl_InsertItemA( hWnd, Msg, wParam, lParam);


// For ComBo List Control
    case CB_ADDSTRING :
                            return Combo_AddStringA(hWnd, Msg, wParam, lParam);
    case CB_GETLBTEXT :
                            return Combo_GetLBTextA(hWnd, Msg, wParam, lParam);
    case CB_INSERTSTRING :
                            return Combo_InsertStringA(hWnd, Msg, wParam, lParam);
    case CB_FINDSTRING :
                            return Combo_FindStringA(hWnd, Msg, wParam, lParam);

// For ListBox Control
    case LB_ADDSTRING:
                            return ListBox_AddStringA(hWnd, Msg, wParam, lParam);

// For Animation Control 
    case ACM_OPEN :
                            return Animate_OpenA( hWnd, Msg, wParam, lParam);

// For Others
    default :
                            return SendMessageA(hWnd, Msg, wParam, lParam);
    }

}

// DefWindowProc
LRESULT WINAPI DefWindowProcWrapW( HWND   hWnd,      // handle to window
                                   UINT   Msg,       // message identifier
                                   WPARAM wParam,    // first message parameter
                                   LPARAM lParam )  // second message parameter
{


    VALIDATE_PROTOTYPE(DefWindowProc);
    
    if (g_bRunningOnNT)
        return DefWindowProcW(hWnd, Msg, wParam, lParam);


    return DefWindowProcA(hWnd, Msg, wParam, lParam);
}

// wsprintf

int WINAPI wsprintfWrapW( LPTSTR lpOut,      // pointer to buffer for output
                          LPCTSTR lpFmt,     // pointer to format-control string
                          ...            )  // optional arguments
{
    va_list ArgList;
    va_start(ArgList, lpFmt);

    return wvsprintfWrapW(lpOut, lpFmt, ArgList);
/*
    LPSTR lpFmtA = NULL, lpTemp = NULL;
    char szOut[1024]; //wsprintf has a 1k limit
    int nRet = 0;
    LPWSTR lpOutW = NULL;

    VALIDATE_PROTOTYPE(wsprintf);
    
    if (g_bRunningOnNT)
        return wsprintfW(lpOut, lpFmt, ... );

    // The argument list can have variable number of LPWSTR parameters which would
    // be too hard to check individually .. instead we can do one of 2 things:
    //  - we can change every %s to %S in the format string .. %S will tell the wsprintfA
    //      that the argument is a wide string
    //  - if this doesn't work then we can try making sure the input format string uses %ws always
    //
    lpFmtA = ConvertWtoA((LPWSTR)lpFmt);

    lpTemp = lpFmtA;

    while(lpTemp && *lpTemp)
    {
        if(*lpTemp == '%' && *(lpTemp+1) == 's')
            *(lpTemp+1) = 'S';
        lpTemp++;
    }

    nRet = wsprintfA(szOut,lpFmtA, ...);

    lpOutW = ConvertAtoW(szOut);

    My_wcscpy(lpOut, lpOutW);
    
    LocalFreeAndNull(&lpOutW);
    LocalFreeAndNull(&lpFmtA);

    return nRet;
*/
}

// wvsprintf
int WINAPI wvsprintfWrapW( LPTSTR lpOut,    // pointer to buffer for output
                           LPCTSTR lpFmt,   // pointer to format-control string
                           va_list arglist )  // variable list of format-control arguments
{
    LPSTR lpFmtA = NULL, lpTemp = NULL;
    char szOut[1024]; 
    int nRet = 0;
    LPWSTR lpOutW = NULL;

    VALIDATE_PROTOTYPE(wvsprintf);
    
    if (g_bRunningOnNT)
        return wvsprintfW(lpOut, lpFmt, arglist);

    // The argument list can have variable number of LPWSTR parameters which would
    // be too hard to check individually .. instead we can do one of 2 things:
    //  - we can change every %s to %S in the format string .. %S will tell the wsprintfA
    //      that the argument is a wide string
    //  - if this doesn't work then we can try making sure the input format string uses %ws always
    //
    lpFmtA = ConvertWtoA((LPWSTR)lpFmt);

    lpTemp = lpFmtA;

    while(lpTemp && *lpTemp)
    {
        if(*lpTemp == '%' && *(lpTemp+1) == 's')
            *(lpTemp+1) = 'S';
        lpTemp++;
    }

    nRet = wvsprintfA(szOut,lpFmtA, arglist);

    lpOutW = ConvertAtoW(szOut);

    My_wcscpy(lpOut, lpOutW);
    
    LocalFreeAndNull(&lpOutW);
    LocalFreeAndNull(&lpFmtA);

    return nRet;

}


// DialogBoxParam
INT_PTR WINAPI DialogBoxParamWrapW( HINSTANCE hInstance,       // handle to application instance
                                LPCTSTR   lpTemplateName,  // identifies dialog box template
                                HWND      hWndParent,      // handle to owner window
                                DLGPROC   lpDialogFunc,    // pointer to dialog box procedure
                                LPARAM    dwInitParam )   // initialization value
{
    INT_PTR    iRetValue = 0;
 //   LPSTR  lpTemplateNameA = NULL;

    VALIDATE_PROTOTYPE(DialogBoxParam);
    
    if (g_bRunningOnNT)
        return DialogBoxParamW(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);


    // all templateName passed in our current codes are just IDD.
    // so don't do A/W conversion.

    // lpTemplateNameA = ConvertWtoA( lpTemplateName );

    iRetValue = DialogBoxParamA(hInstance, (LPCSTR)lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);

 //   LocalFreeAndNull( &lpTemplateNameA );
    if(iRetValue == -1)
        DebugTrace(TEXT("Error creating dialog: %d\n"), GetLastError());

    return iRetValue;

}


// SendDlgItemMessage
LRESULT WINAPI SendDlgItemMessageWrapW( HWND   hDlg,        // handle of dialog box
                                     int    nIDDlgItem,  // identifier of control
                                     UINT   Msg,         // message to send
                                     WPARAM wParam,      // first message parameter
                                     LPARAM lParam  )    // second message parameter
{
    VALIDATE_PROTOTYPE(SendDlgItemMessage);
    
    if (g_bRunningOnNT)
        return SendDlgItemMessageW(hDlg, nIDDlgItem, Msg, wParam, lParam);

    // [PaulHi] 1/19/99  Raid 66195
    // Must special case Win9X wrapper failures, just like with SendMessage
    // command
    {
        LPWSTR  lpszStrW = NULL;
        LPSTR   lpszStrA = NULL;
        LRESULT lRetValue = 0;

        switch (Msg)
        {
        case LB_GETTEXT:
        case CB_GETLBTEXT:
        case WM_GETTEXT:
            // Wrapper function returns single byte string instead of double byte.
            // Note that caller should be expecting double byte and should set lParam
            // size accordingly.
            lRetValue = SendDlgItemMessageA(hDlg, nIDDlgItem, Msg, wParam, lParam);
            lpszStrW = ConvertAtoW((LPSTR)lParam);
            lstrcpyWrapW((LPTSTR)lParam, lpszStrW);
            LocalFreeAndNull(&lpszStrW);
            break;

        case CB_ADDSTRING:
            Assert(lParam);
            lpszStrA = ConvertWtoA((LPCWSTR)lParam);
            lRetValue = SendDlgItemMessageA(hDlg, nIDDlgItem, Msg, wParam, (LPARAM)lpszStrA);
            LocalFreeAndNull(&lpszStrA);
            break;

        default:
            lRetValue = SendDlgItemMessageA(hDlg, nIDDlgItem, Msg, wParam, lParam);
        }

        return lRetValue;
    }
}

// SetWindowLong
LONG WINAPI SetWindowLongWrapW( HWND hWnd,         // handle of window
                                int  nIndex,       // offset of value to set
                                LONG dwNewLong )  // new value
{

    VALIDATE_PROTOTYPE(SetWindowLong);
    
    if (g_bRunningOnNT)
        return SetWindowLongW(hWnd, nIndex, dwNewLong);

    return SetWindowLongA(hWnd, nIndex, dwNewLong);

}


// GetWindowLong
LONG WINAPI GetWindowLongWrapW( HWND hWnd,    // handle of window
                                int  nIndex ) // offset of value to retrieve
{


    VALIDATE_PROTOTYPE(GetWindowLong);
    
    if (g_bRunningOnNT)
        return GetWindowLongW(hWnd, nIndex);

    return GetWindowLongA(hWnd, nIndex);

}

// SetWindowLong
LONG_PTR WINAPI SetWindowLongPtrWrapW( HWND hWnd,         // handle of window
                                int  nIndex,       // offset of value to set
                                LONG_PTR dwNewLong )  // new value
{

    VALIDATE_PROTOTYPE(SetWindowLongPtr);
    
    if (g_bRunningOnNT)
        return SetWindowLongPtrW(hWnd, nIndex, dwNewLong);

    return SetWindowLongPtrA(hWnd, nIndex, dwNewLong);

}


// GetWindowLong
LONG_PTR WINAPI GetWindowLongPtrWrapW( HWND hWnd,    // handle of window
                                int  nIndex ) // offset of value to retrieve
{


    VALIDATE_PROTOTYPE(GetWindowLongPtr);
    
    if (g_bRunningOnNT)
        return GetWindowLongPtrW(hWnd, nIndex);

    return GetWindowLongPtrA(hWnd, nIndex);

}


// CreateWindowEx
HWND WINAPI CreateWindowExWrapW( DWORD     dwExStyle,    // extended window style
                                 LPCTSTR   lpClassName,  // pointer to registered class name
                                 LPCTSTR   lpWindowName, // pointer to window name
                                 DWORD     dwStyle,      // window style
                                 int       x,            // horizontal position of window
                                 int       y,            // vertical position of window
                                 int       nWidth,       // window width
                                 int       nHeight,      // window height
                                 HWND      hWndParent,   // handle to parent or owner window
                                 HMENU     hMenu,        // handle to menu, or child-window identifier
                                 HINSTANCE hInstance,    // handle to application instance
                                 LPVOID    lpParam  )    // pointer to window-creation data

{

    HWND    hRetValue = NULL;
    LPSTR   lpClassNameA = NULL;
    LPSTR   lpWindowNameA = NULL;

    VALIDATE_PROTOTYPE(CreateWindowEx);
    
    if (g_bRunningOnNT)
        return CreateWindowExW(dwExStyle, lpClassName, lpWindowName, dwStyle, x, y, 
                               nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);

    lpClassNameA  = ConvertWtoA( lpClassName );
    lpWindowNameA = ConvertWtoA( lpWindowName );

    hRetValue = CreateWindowExA(dwExStyle, lpClassNameA, lpWindowNameA, dwStyle, x, y, 
                                nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);

    LocalFreeAndNull( &lpClassNameA );
    LocalFreeAndNull( &lpWindowNameA );

    return hRetValue;

}

// UnregisterClass
BOOL WINAPI UnregisterClassWrapW( LPCTSTR    lpClassName,  // address of class name string
                                  HINSTANCE  hInstance )   // handle of application instance
{
    BOOL  bRetValue;
    LPSTR lpClassNameA = NULL;

    VALIDATE_PROTOTYPE(UnregisterClass);
    
    if (g_bRunningOnNT)
        return UnregisterClassW(lpClassName, hInstance);

    lpClassNameA = ConvertWtoA( lpClassName );

    bRetValue = UnregisterClassA(lpClassNameA, hInstance);

    LocalFreeAndNull( &lpClassNameA );

    return bRetValue;

}

// RegisterClass
ATOM WINAPI RegisterClassWrapW(CONST WNDCLASS *lpWndClass )  // address of structure with class date
{
    ATOM        aRetValue;
    WNDCLASSA   CLassA;
    LPSTR       lpszMenuName = NULL;
    LPSTR       lpszClassName = NULL;


    VALIDATE_PROTOTYPE(RegisterClass);
    
    if (g_bRunningOnNT)
        return RegisterClassW(lpWndClass);

    CLassA.style         = lpWndClass->style;
    CLassA.lpfnWndProc   = lpWndClass->lpfnWndProc;
    CLassA.cbClsExtra    = lpWndClass->cbClsExtra;
    CLassA.cbWndExtra    = lpWndClass->cbWndExtra;
    CLassA.hInstance     = lpWndClass->hInstance;
    CLassA.hIcon         = lpWndClass->hIcon;
    CLassA.hCursor       = lpWndClass->hCursor;
    CLassA.hbrBackground = lpWndClass->hbrBackground;
    CLassA.lpszMenuName  = NULL;
    CLassA.lpszClassName = NULL;

    if ( lpWndClass->lpszMenuName) {
       lpszMenuName  = ConvertWtoA(lpWndClass->lpszMenuName);
       CLassA.lpszMenuName  = lpszMenuName;

    }

    if ( lpWndClass->lpszClassName ) {
       lpszClassName = ConvertWtoA(lpWndClass->lpszClassName);
       CLassA.lpszClassName = lpszClassName;
    }

    aRetValue = RegisterClassA(&CLassA);

    LocalFreeAndNull( &lpszMenuName );
    LocalFreeAndNull( &lpszClassName );

    return aRetValue;

}

// LoadCursor
HCURSOR WINAPI LoadCursorWrapW( HINSTANCE hInstance,      // handle to application instance
                                LPCTSTR   lpCursorName )  // name string or cursor resource identifier
{


    VALIDATE_PROTOTYPE(LoadCursor);
    
    if (g_bRunningOnNT)
        return LoadCursorW(hInstance, lpCursorName);

    return LoadCursorA(hInstance, (LPSTR)lpCursorName);

}

// RegisterWindowMessage
UINT WINAPI RegisterWindowMessageWrapW( LPCTSTR lpString )  // address of message string
{
    UINT  uRetValue = 0;
    LPSTR lpStringA = NULL;

    VALIDATE_PROTOTYPE(RegisterWindowMessage);
    
    if (g_bRunningOnNT)
        return RegisterWindowMessageW(lpString);


    lpStringA = ConvertWtoA( lpString );

    uRetValue = RegisterWindowMessageA( lpStringA );

    LocalFreeAndNull( &lpStringA );

    return uRetValue;
}


// SystemParametersInfo
BOOL WINAPI SystemParametersInfoWrapW( UINT  uiAction,   // system parameter to query or set
                                       UINT  uiParam,    // depends on action to be taken
                                       PVOID pvParam,    // depends on action to be taken
                                       UINT  fWinIni )   // user profile update flag

{
    BOOL      bRetValue;
    LOGFONTA  lfFontA;
    LOGFONTW  lfFontW;
    
    VALIDATE_PROTOTYPE(SystemParametersInfo);
    
    if (g_bRunningOnNT)
        return SystemParametersInfoW(uiAction, uiParam, pvParam, fWinIni);

    if ( uiAction != SPI_GETICONTITLELOGFONT )

        return SystemParametersInfoA(uiAction, uiParam, pvParam, fWinIni);

    // we handle SPI_GETICONTITLELOGFONT only for our special requirement. ...

    bRetValue = SystemParametersInfoA(uiAction, uiParam, &lfFontA, fWinIni);

    if ( bRetValue == FALSE )  return FALSE;

  // copy all the fields except lfFaceName from lfFontA to lfFontW
    CopyMemory(&lfFontW,&lfFontA, sizeof(LOGFONTA) );
    
    // translate the lfFaceName[] from A to W

    MultiByteToWideChar(GetACP(), 0, lfFontA.lfFaceName, LF_FACESIZE, lfFontW.lfFaceName, LF_FACESIZE);
    
    CopyMemory(pvParam, &lfFontW, sizeof(LOGFONTW) );

    return bRetValue;
}                                                         
/*
// No A & W version.

BOOL WINAPI ShowWindow( HWND hWnd,       // handle to window
                        int nCmdShow )  // show state of window
*/

// CreateDialogParam
HWND WINAPI CreateDialogParamWrapW( HINSTANCE hInstance,      // handle to application instance
                                    LPCTSTR   lpTemplateName, // identifies dialog box template
                                    HWND      hWndParent,     // handle to owner window
                                    DLGPROC   lpDialogFunc,   // pointer to dialog box procedure
                                    LPARAM    dwInitParam )  // initialization value
{
    VALIDATE_PROTOTYPE(CreateDialogParam);
    
    if (g_bRunningOnNT)
        return CreateDialogParamW(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);

    return CreateDialogParamA(hInstance, (LPCSTR) lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
}

// SetWindowText
BOOL WINAPI SetWindowTextWrapW( HWND    hWnd,         // handle to window or control
                                LPCTSTR lpString )   // address of string
{
    BOOL  bRetValue;
    LPSTR lpStringA = NULL;

    VALIDATE_PROTOTYPE(SetWindowText);
    
    if (g_bRunningOnNT)
        return SetWindowTextW(hWnd, lpString);


    lpStringA = ConvertWtoA( lpString );

    bRetValue = SetWindowTextA( hWnd, lpStringA);

    LocalFreeAndNull( &lpStringA );

    return bRetValue;
}

// PostMessage
BOOL WINAPI PostMessageWrapW( HWND   hWnd,      // handle of destination window
                              UINT   Msg,       // message to post
                              WPARAM wParam,    // first message parameter
                              LPARAM lParam  ) // second message parameter
{


    VALIDATE_PROTOTYPE(PostMessage);
    
    if (g_bRunningOnNT)
        return PostMessageW(hWnd, Msg, wParam, lParam);

    return PostMessageA(hWnd, Msg, wParam, lParam);
 
}

// GetMenuItemInfo
BOOL WINAPI GetMenuItemInfoWrapW( HMENU          hMenu,          
                                  UINT           uItem,           
                                  BOOL           fByPosition,     
                                  LPMENUITEMINFO lpmii        )
{

    BOOL           bRetValue;
    MENUITEMINFOA  miiA = {0};
    LPSTR           lpA = NULL;    
    LPWSTR          lpW = NULL;
    LPWSTR          lpOld = NULL;

    VALIDATE_PROTOTYPE(GetMenuItemInfo);
    
    if (g_bRunningOnNT)
        return GetMenuItemInfoW(hMenu, uItem, fByPosition, lpmii);

    CopyMemory(&miiA, lpmii, sizeof(MENUITEMINFOA) );
    miiA.cbSize = sizeof (MENUITEMINFOA);

    if(miiA.fMask & MIIM_TYPE)
    {
        lpA = LocalAlloc(LMEM_ZEROINIT, lpmii->cch+1);

        miiA.dwTypeData = lpA;
        miiA.cch = lpmii->cch;
    }

    bRetValue = GetMenuItemInfoA(hMenu, uItem, fByPosition, &miiA);

    if(bRetValue)
    {
        lpOld = lpmii->dwTypeData;
        CopyMemory(lpmii, &miiA, sizeof(MENUITEMINFOA) );
        lpmii->dwTypeData = lpOld;

        if ( miiA.fMask & MIIM_TYPE ) 
        {
            lpW = ConvertAtoW(miiA.dwTypeData);
            lstrcpyWrapW(lpmii->dwTypeData,lpW);
            lpmii->cch = My_wcslen( lpmii->dwTypeData );
        }
    }

    LocalFreeAndNull(&lpA);
    LocalFreeAndNull(&lpW);
    
    return bRetValue;
}

// GetClassInfo
BOOL WINAPI GetClassInfoWrapW( HINSTANCE   hInstance,     // handle of application instance
                               LPCTSTR     lpClassName,   // address of class name string
                               LPWNDCLASS  lpWndClass )   // address of structure for class data
{
    
    BOOL       bRetValue;
    LPSTR      lpClassNameA = NULL;
    WNDCLASSA  ClassA;

    VALIDATE_PROTOTYPE(GetClassInfo);
    
    if (g_bRunningOnNT)
        return GetClassInfoW(hInstance, lpClassName, lpWndClass);

    lpClassNameA = ConvertWtoA( lpClassName );

    bRetValue = GetClassInfoA(hInstance, lpClassNameA, &ClassA );

    if (bRetValue == FALSE) {
         LocalFreeAndNull( & lpClassNameA );
         return FALSE;
    }

    CopyMemory(lpWndClass, &ClassA, sizeof(WNDCLASSA)-2*sizeof(LPSTR) );

    if ( ClassA.lpszMenuName && !IS_INTRESOURCE(ClassA.lpszMenuName) )
        lpWndClass->lpszMenuName = ConvertAtoW( ClassA.lpszMenuName );
    else
        lpWndClass->lpszMenuName = NULL;

    if ( ClassA.lpszClassName && !IS_INTRESOURCE(ClassA.lpszClassName) ) // lpszClassName can be an atom, high word is null
        lpWndClass->lpszClassName = ConvertAtoW( ClassA.lpszClassName);
    else
        lpWndClass->lpszClassName = NULL;

    LocalFreeAndNull( & lpClassNameA );
    return bRetValue;
    
}

//----------------------------------------------------------------------
//
// function:    CharLowerWrapW( LPWSTR pch )
//
// purpose:     Converts character to lowercase.  Takes either a pointer
//              to a string, or a character masquerading as a pointer.
//              In the later case, the HIWORD must be zero.  This is
//              as spec'd for Win32.
//
// returns:     Lowercased character or string.  In the string case,
//              the lowercasing is done inplace.
//
//----------------------------------------------------------------------
LPWSTR WINAPI
CharLowerWrapW( LPWSTR pch )
{
    VALIDATE_PROTOTYPE(CharLower);

    if (g_bRunningOnNT)
    {
        return CharLowerW( pch );
    }

    if (!HIWORD(pch))
    {
        WCHAR ch = (WCHAR)(LONG_PTR)pch;

        CharLowerBuffWrapW( &ch, 1 );

        pch = (LPWSTR)MAKEINTATOM(ch);
    }
    else
    {
        CharLowerBuffWrapW( pch, lstrlenW(pch) );
    }

    return pch;
}


//----------------------------------------------------------------------
//
// function:    CharLowerBuffWrapW( LPWSTR pch, DWORD cch )
//
// purpose:     Converts a string to lowercase.  String must be cch
//              characters in length.
//
// returns:     Character count (cch).  The lowercasing is done inplace.
//
//----------------------------------------------------------------------
DWORD WINAPI
CharLowerBuffWrapW( LPWSTR pch, DWORD cchLength )
{
    DWORD cch;

    VALIDATE_PROTOTYPE(CharLowerBuff);

    if (g_bRunningOnNT)
    {
        return CharLowerBuffW( pch, cchLength );
    }

    for ( cch = cchLength; cch-- ; pch++ )
    {
        WCHAR ch = *pch;

        if (IsCharUpperWrapW(ch))
        {
            if (ch < 0x0100)
            {
                *pch += 32;             // Get Latin-1 out of the way first
            }
            else if (ch < 0x0531)
            {
                if (ch < 0x0391)
                {
                    if (ch < 0x01cd)
                    {
                        if (ch <= 0x178)
                        {
                            if (ch < 0x0178)
                            {
                                *pch += (ch == 0x0130) ? 0 : 1;
                            }
                            else
                            {
                                *pch -= 121;
                            }
                        }
                        else
                        {
                            static const BYTE abLookup[] =
                            {  // 0/8  1/9  2/a  3/b  4/c  5/d  6/e  7/f
            /* 0x0179-0x17f */           1,   0,   1,   0,   1,   0,   0,
            /* 0x0180-0x187 */      0, 210,   1,   0,   1,   0, 206,   1,
            /* 0x0188-0x18f */      0, 205, 205,   1,   0,   0,  79, 202,
            /* 0x0190-0x197 */    203,   1,   0, 205, 207,   0, 211, 209,
            /* 0x0198-0x19f */      1,   0,   0,   0, 211, 213,   0, 214,
            /* 0x01a0-0x1a7 */      1,   0,   1,   0,   1,   0,   0,   1,
            /* 0x01a8-0x1af */      0, 218,   0,   0,   1,   0, 218,   1,
            /* 0x01b0-0x1b7 */      0, 217, 217,   1,   0,   1,   0, 219,
            /* 0x01b8-0x1bf */      1,   0,   0,   0,   1,   0,   0,   0,
            /* 0x01c0-0x1c7 */      0,   0,   0,   0,   2,   0,   0,   2,
            /* 0x01c8-0x1cb */      0,   0,   2,   0
                            };

                            *pch += abLookup[ch-0x0179];
                        }
                    }
                    else if (ch < 0x0386)
                    {
                        switch (ch)
                        {
                            case 0x01f1: *pch += 2; break;
                            case 0x01f2: break;
                            default: *pch += 1;
                        }
                    }
                    else
                    {
                        static const BYTE abLookup[] =
                            { 38, 0, 37, 37, 37, 0, 64, 0, 63, 63 };

                        *pch += abLookup[ch-0x0386];
                    }
                }
                else
                {
                    if (ch < 0x0410)
                    {
                        if (ch < 0x0401)
                        {
                            if (ch < 0x03e2)
                            {
                                if (!InRange(ch, 0x03d2, 0x03d4) &&
                                    !(InRange(ch, 0x3da, 0x03e0) & !(ch & 1)))
                                {
                                    *pch += 32;
                                }
                            }
                            else
                            {
                                *pch += 1;
                            }
                        }
                        else
                        {
                            *pch += 80;
                        }
                    }
                    else
                    {
                        if (ch < 0x0460)
                        {
                            *pch += 32;
                        }
                        else
                        {
                            *pch += 1;
                        }
                    }
                }
            }
            else
            {
                if (ch < 0x2160)
                {
                    if (ch < 0x1fba)
                    {
                        if (ch < 0x1f08)
                        {
                            if (ch < 0x1e00)
                            {
                                *pch += 48;
                            }
                            else
                            {
                                *pch += 1;
                            }
                        }
                        else if (!(InRange(ch, 0x1f88, 0x1faf) && (ch & 15)>7))
                        {
                            *pch -= 8;
                        }
                    }
                    else
                    {
                        static const BYTE abLookup[] =
                        {  // 8    9    a    b    c    d    e    f
                              0,   0,  74,  74,   0,   0,   0,   0,
                             86,  86,  86,  86,   0,   0,   0,   0,
                              8,   8, 100, 100,   0,   0,   0,   0,
                              8,   8, 112, 112,   7,   0,   0,   0,
                            128, 128, 126, 126,   0,   0,   0,   0
                        };
                        int i = (ch-0x1fb0);

                        *pch -= (int)abLookup[((i>>1) & ~7) | (i & 7)];
                    }
                }
                else
                {
                    if (ch < 0xff21)
                    {
                        if (ch < 0x24b6)
                        {
                            *pch += 16;
                        }
                        else
                        {
                            *pch += 26;
                        }
                    }
                    else
                    {
                        *pch += 32;
                    }
                }
            }
        }
        else
        {
            // These are Unicode Number Forms.  They have lowercase counter-
            // parts, but are not considered uppercase.  Why, I don't know.

            if (InRange(ch, 0x2160, 0x216f))
            {
                *pch += 16;
            }
        }
    }

    return cchLength;
}

//----------------------------------------------------------------------
//
// function:    CharUpperBuffWrapW( LPWSTR pch, DWORD cch )
//
// purpose:     Converts a string to uppercase.  String must be cch
//              characters in length.  Note that this function is
//              is messier that CharLowerBuffWrap, and the reason for
//              this is many Unicode characters are considered uppercase,
//              even when they don't have an uppercase counterpart.
//
// returns:     Character count (cch).  The uppercasing is done inplace.
//
//----------------------------------------------------------------------
DWORD WINAPI
CharUpperBuffWrapW( LPWSTR pch, DWORD cchLength )
{
    DWORD cch;

    VALIDATE_PROTOTYPE(CharUpperBuff);

    if (g_bRunningOnNT)
    {
        return CharUpperBuffW( pch, cchLength );
    }

    for ( cch = cchLength; cch-- ; pch++ )
    {
        WCHAR ch = *pch;

        if (IsCharLowerWrapW(ch))
        {
            if (ch < 0x00ff)
            {
                *pch -= ((ch != 0xdf) << 5);
            }
            else if (ch < 0x03b1)
            {
                if (ch < 0x01f5)
                {
                    if (ch < 0x01ce)
                    {
                        if (ch < 0x017f)
                        {
                            if (ch < 0x0101)
                            {
                                *pch += 121;
                            }
                            else
                            {
                                *pch -= (ch != 0x0131 &&
                                         ch != 0x0138 &&
                                         ch != 0x0149);
                            }
                        }
                        else if (ch < 0x01c9)
                        {
                            static const BYTE abMask[] =
                            {                       // 6543210f edcba987
                                0xfc, 0xbf,         // 11111100 10111111
                                0xbf, 0x67,         // 10111111 01100111
                                0xff, 0xef,         // 11111111 11101111
                                0xff, 0xf7,         // 11111111 11110111
                                0xbf, 0xfd          // 10111111 11111101
                            };

                            int i = ch - 0x017f;

                            *pch -= ((abMask[i>>3] >> (i&7)) & 1) +
                                    (ch == 0x01c6);
                        }
                        else
                        {
                            *pch -= ((ch != 0x01cb)<<1);
                        }
                    }
                    else
                    {
                        if (ch < 0x01df)
                        {
                            if (ch < 0x01dd)
                            {
                                *pch -= 1;
                            }
                            else
                            {
                                *pch -= 79;
                            }
                        }
                        else
                        {
                            *pch -= 1 + (ch == 0x01f3) -
                                    InRange(ch,0x01f0,0x01f2);
                        }
                    }
                }
                else if (ch < 0x0253)
                {
                    *pch -= (ch < 0x0250);
                }
                else if (ch < 0x03ac)
                {
                    static const BYTE abLookup[] =
                    {// 0/8  1/9  2/a  3/b  4/c  5/d  6/e  7/f
    /* 0x0253-0x0257 */                210, 206,   0, 205, 205,
    /* 0x0258-0x025f */   0, 202,   0, 203,   0,   0,   0,   0,
    /* 0x0260-0x0267 */ 205,   0,   0, 207,   0,   0,   0,   0,
    /* 0x0268-0x026f */ 209, 211,   0,   0,   0,   0,   0, 211,
    /* 0x0270-0x0277 */   0,   0, 213,   0,   0, 214,   0,   0,
    /* 0x0278-0x027f */   0,   0,   0,   0,   0,   0,   0,   0,
    /* 0x0280-0x0287 */   0,   0,   0, 218,   0,   0,   0,   0,
    /* 0x0288-0x028f */ 218,   0, 217, 217,   0,   0,   0,   0,
    /* 0x0290-0x0297 */   0,   0, 219
                    };

                    if (ch <= 0x0292)
                    {
                        *pch -= abLookup[ch - 0x0253];
                    }
                }
                else
                {
                    *pch -= (ch == 0x03b0) ? 0 : (37 + (ch == 0x03ac));
                }
            }
            else
            {
                if (ch < 0x0561)
                {
                    if (ch < 0x0451)
                    {
                        if (ch < 0x03e3)
                        {
                            if (ch < 0x03cc)
                            {
                                *pch -= 32 - (ch == 0x03c2);
                            }
                            else
                            {
                                int i = (ch < 0x03d0);
                                *pch -= (i<<6) - i + (ch == 0x03cc);
                            }
                        }
                        else if (ch < 0x0430)
                        {
                            *pch -= (ch < 0x03f0);
                        }
                        else
                        {
                            *pch -= 32;
                        }
                    }
                    else if (ch < 0x0461)
                    {
                        *pch -= 80;
                    }
                    else
                    {
                        *pch -= 1;
                    }
                }
                else
                {
                    if (ch < 0x1fb0)
                    {
                        if (ch < 0x1f70)
                        {
                            if (ch < 0x1e01)
                            {
                                int i = ch != 0x0587 && ch < 0x10d0;
                                *pch -= ((i<<5)+(i<<4)); /* 48 */
                            }
                            else if (ch < 0x1f00)
                            {
                                *pch -= !InRange(ch, 0x1e96, 0x1e9a);
                            }
                            else
                            {
                                int i = !InRange(ch, 0x1f50, 0x1f56)||(ch & 1);
                                *pch += (i<<3);
                            }
                        }
                        else
                        {
                            static const BYTE abLookup[] =
                                { 74, 86, 86, 100, 128, 112, 126 };

                            if ( ch <= 0x1f7d )
                            {
                                *pch += abLookup[(ch-0x1f70)>>1];
                            }
                        }
                    }
                    else
                    {
                        if (ch < 0x24d0)
                        {
                            if (ch < 0x1fe5)
                            {
                                *pch += (0x0023 & (1<<(ch&15))) ? 8 : 0;
                            }
                            else if (ch < 0x2170)
                            {
                                *pch += (0x0023 & (1<<(ch&15))) ? 7 : 0;
                            }
                            else
                            {
                                *pch -= ((ch > 0x24b5)<<4);
                            }
                        }
                        else if (ch < 0xff41)
                        {
                            int i = !InRange(ch, 0xfb00, 0xfb17);
                            *pch -= (i<<4)+(i<<3)+(i<<1); /* 26 */
                        }
                        else
                        {
                            *pch -= 32;
                        }
                    }
                }
            }
        }
        else
        {
            int i = InRange(ch, 0x2170, 0x217f);
            *pch -= (i<<4);
        }
    }

    return cchLength;
}

// CharUpper
//----------------------------------------------------------------------
//
// function:    CharUpperWrapW( LPWSTR pch )
//
// purpose:     Converts character to uppercase.  Takes either a pointer
//              to a string, or a character masquerading as a pointer.
//              In the later case, the HIWORD must be zero.  This is
//              as spec'd for Win32.
//
// returns:     Uppercased character or string.  In the string case,
//              the uppercasing is done inplace.
//
//----------------------------------------------------------------------
LPWSTR WINAPI
CharUpperWrapW( LPWSTR pch )
{
    VALIDATE_PROTOTYPE(CharUpper);

    if (g_bRunningOnNT)
    {
        return CharUpperW( pch );
    }

    if (!HIWORD(pch))
    {
        WCHAR ch = (WCHAR)(LONG_PTR)pch;

        CharUpperBuffWrapW( &ch, 1 );

        pch = (LPWSTR)MAKEINTATOM(ch);
    }
    else
    {
        CharUpperBuffWrapW( pch, lstrlenW(pch) );
    }

    return pch;
}

/*
LPTSTR WINAPI CharUpperWrapW( LPTSTR lpsz )    // single character or pointer to string
{

    LPWSTR  lpszW = NULL;
    LPSTR   lpszA = NULL;
    LPSTR   lpszUpperA = NULL;


    VALIDATE_PROTOTYPE(CharUpper);
    
    if (g_bRunningOnNT)
        return CharUpperW(lpsz);

    lpszA = ConvertWtoA( lpsz );

    lpszUpperA = CharUpperA( lpszA );

    lpszW = ConvertAtoW( lpszUpperA );

    CopyMemory( lpsz, lpszW, My_wcslen(lpszW) * sizeof(WCHAR) );

    LocalFreeAndNull( &lpszW );
    LocalFreeAndNull( &lpszA );

    return lpsz;
}
*/

// RegisterClipboardFormat
UINT WINAPI RegisterClipboardFormatWrapW( LPCTSTR lpszFormat )  // address of name string
{
    UINT   uRetValue =0;
    LPSTR  lpszFormatA = NULL;

    VALIDATE_PROTOTYPE(RegisterClipboardFormat);
    
    if (g_bRunningOnNT)
        return RegisterClipboardFormatW(lpszFormat);

    lpszFormatA = ConvertWtoA( lpszFormat );

    uRetValue = RegisterClipboardFormatA( lpszFormatA );

    LocalFreeAndNull( &lpszFormatA );

    return uRetValue;

}

// DispatchMessage
LRESULT WINAPI DispatchMessageWrapW( CONST MSG *lpmsg )  // pointer to structure with message
{


    VALIDATE_PROTOTYPE(DispatchMessage);
    
    if (g_bRunningOnNT)
        return DispatchMessageW(lpmsg);

    return DispatchMessageA(lpmsg);

}
/* No A & W version
BOOL WINAPI TranslateMessage( IN CONST MSG *lpMsg)
*/

// IsDialogMessage
BOOL WINAPI IsDialogMessageWrapW( HWND  hDlg,    // handle of dialog box
                                  LPMSG lpMsg ) // address of structure with message
{


    VALIDATE_PROTOTYPE(IsDialogMessage);
    
    if (g_bRunningOnNT)
        return IsDialogMessageW(hDlg, lpMsg);

    return IsDialogMessageA(hDlg, lpMsg);

}

// GetMessage
BOOL WINAPI GetMessageWrapW( LPMSG lpMsg,            // address of structure with message
                             HWND  hWnd,             // handle of window
                             UINT  wMsgFilterMin,    // first message
                             UINT  wMsgFilterMax )  // last message
{


    VALIDATE_PROTOTYPE(GetMessage);
    
    if (g_bRunningOnNT)
        return GetMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);

    return GetMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);

}

// SetDlgItemText
BOOL WINAPI SetDlgItemTextWrapW( HWND    hDlg,        // handle of dialog box
                                 int     nIDDlgItem,  // identifier of control
                                 LPCTSTR lpString )  // text to set
{

    BOOL  bRetValue;
    LPSTR lpStringA = NULL;

    VALIDATE_PROTOTYPE(SetDlgItemText);
    
    if (g_bRunningOnNT)
        return SetDlgItemTextW(hDlg, nIDDlgItem, lpString);

    lpStringA = ConvertWtoA( lpString );

    bRetValue = SetDlgItemTextA(hDlg, nIDDlgItem, lpStringA);

    LocalFreeAndNull( &lpStringA );

    return bRetValue;

}

// RegisterClassEx
ATOM WINAPI RegisterClassExWrapW( CONST WNDCLASSEX *lpwcx )  // address of structure with class data
{

    ATOM        aReturn;
    WNDCLASSEXA wcxA;
    PSTR       lpszClassName = NULL;
    PSTR       lpszMenuName = NULL;

    VALIDATE_PROTOTYPE(RegisterClassEx);
    
    if (g_bRunningOnNT)
        return RegisterClassExW(lpwcx);

    wcxA.cbSize        = sizeof(WNDCLASSEXA);
    wcxA.style         = lpwcx->style; 
    wcxA.lpfnWndProc   = lpwcx->lpfnWndProc; 
    wcxA.cbClsExtra    = lpwcx->cbClsExtra; 
    wcxA.cbWndExtra    = lpwcx->cbWndExtra; 
    wcxA.hInstance     = lpwcx->hInstance;
    wcxA.hIcon         = lpwcx->hIcon; 
    wcxA.hCursor       = lpwcx->hCursor; 
    wcxA.hbrBackground = lpwcx->hbrBackground; 
    wcxA.hIconSm       = lpwcx->hIconSm;
    
    if ( lpwcx->lpszMenuName) {
       lpszMenuName  = ConvertWtoA(lpwcx->lpszMenuName);
       wcxA.lpszMenuName  = lpszMenuName; 
    }

    if (lpwcx->lpszClassName) {
       lpszClassName = ConvertWtoA(lpwcx->lpszClassName);
       wcxA.lpszClassName = lpszClassName;
    } 

    aReturn = RegisterClassExA( &wcxA );

    if ( wcxA.lpszMenuName)
       LocalFreeAndNull( &lpszMenuName ); 

    if (wcxA.lpszClassName)
       LocalFreeAndNull( &lpszClassName ); 
    
    return aReturn;

}


// LoadAccelerators
HACCEL WINAPI LoadAcceleratorsWrapW( HINSTANCE hInstance,    // handle to application instance
                                     LPCTSTR lpTableName )  // address of table-name string
{

    HACCEL  hRetValue = NULL;
    LPSTR   lpTableNameA = NULL;

    VALIDATE_PROTOTYPE(LoadAccelerators);
    
    if (g_bRunningOnNT)
        return LoadAcceleratorsW(hInstance, lpTableName);

    lpTableNameA = ConvertWtoA( lpTableName );

    hRetValue = LoadAcceleratorsA( hInstance, lpTableNameA );

    LocalFreeAndNull( &lpTableNameA );

    return hRetValue;


}

// LoadMenu
HMENU WINAPI LoadMenuWrapW( HINSTANCE hInstance,      // handle to application instance
                            LPCTSTR   lpMenuName )   // menu name string or menu-resource identifier
                        
{
    HMENU  hRetValue = NULL;
    LPSTR  lpMenuNameA = NULL;

    VALIDATE_PROTOTYPE(LoadMenu);
    
    if (g_bRunningOnNT)
        return LoadMenuW(hInstance, lpMenuName);

    // becuause all the calling to this functions in our project just pass 
    // and Resource ID as lpMenuName. so don't need to covert like a string

    lpMenuNameA = MAKEINTRESOURCEA(lpMenuName);

    hRetValue = LoadMenuA(hInstance,lpMenuNameA);

    return hRetValue;
}

//LoadIcon
HICON WINAPI LoadIconWrapW( HINSTANCE hInstance,     // handle to application instance
                           LPCTSTR    lpIconName )  // icon-name string or icon resource identifier
                       
{
    HICON  hRetValue = NULL;
    LPSTR  lpIconNameA = NULL;

    VALIDATE_PROTOTYPE(LoadIcon);
    
    if (g_bRunningOnNT)
        return LoadIconW(hInstance, lpIconName);

    // becuause all the calling to this functions in our project just pass 
    // and Resource ID as lpMenuName. so don't need to covert like a string

    lpIconNameA = MAKEINTRESOURCEA(lpIconName );

    hRetValue = LoadIconA(hInstance, lpIconNameA);

    return hRetValue;
}

// GetWindowText
int WINAPI GetWindowTextWrapW( HWND   hWnd,         // handle to window or control with text
                               LPTSTR lpString,     // address of buffer for text
                               int    nMaxCount  ) // maximum number of characters to copy
{
    int     iRetValue =0;
    LPSTR   lpStringA = NULL;
    LPWSTR  lpStringW = NULL;
    int     nCount =0;

    VALIDATE_PROTOTYPE(GetWindowText);
    
	*lpString = '\0';

    if (g_bRunningOnNT)
        return GetWindowTextW(hWnd, lpString, nMaxCount);


    nCount = nMaxCount * sizeof( WCHAR );
    lpStringA = LocalAlloc( LMEM_ZEROINIT, nCount );

    iRetValue = GetWindowTextA(hWnd, lpStringA, nCount);

    if ( iRetValue == 0 ) {
        LocalFreeAndNull( &lpStringA );
        return iRetValue;
    }

    lpStringW = ConvertAtoW( lpStringA );
    nCount = My_wcslen( lpStringW );

    if ( nCount >= nMaxCount )
        nCount = nMaxCount - 1;

    CopyMemory( lpString, lpStringW,  nCount * sizeof(WCHAR) );

    lpString[nCount] = 0x0000;

    iRetValue = nCount;

    LocalFreeAndNull( &lpStringA );
    LocalFreeAndNull( &lpStringW );

    return iRetValue;
}

// CallWindowProcWrap
LRESULT WINAPI CallWindowProcWrapW( WNDPROC lpPrevWndFunc,   // pointer to previous procedure
                                    HWND    hWnd,            // handle to window
                                    UINT    Msg,             // message
                                    WPARAM  wParam,          // first message parameter
                                    LPARAM  lParam  )       // second message parameter
{


    VALIDATE_PROTOTYPE(CallWindowProc);
    
    if (g_bRunningOnNT)
        return CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam);


    return CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam);


}

// GetClassName
int WINAPI GetClassNameWrapW( HWND   hWnd,           // handle of window
                              LPTSTR lpClassName,    // address of buffer for class name
                              int    nMaxCount )    // size of buffer, in characters
{

    int     iRetValue =0;
    LPSTR   lpClassNameA = NULL;
    LPWSTR  lpClassNameW = NULL;
    int     nCount =0;

    VALIDATE_PROTOTYPE(GetClassName);
    
    if (g_bRunningOnNT)
        return GetClassNameW(hWnd, lpClassName, nMaxCount);


    nCount = nMaxCount * sizeof( WCHAR );
    lpClassNameA = LocalAlloc( LMEM_ZEROINIT, nCount );

    iRetValue = GetClassNameA(hWnd, lpClassNameA, nCount);

    if ( iRetValue == 0 ) {
        LocalFreeAndNull( &lpClassNameA );
        return iRetValue;
    }

    lpClassNameW = ConvertAtoW( lpClassNameA );
    nCount = My_wcslen( lpClassNameW );

    if ( nCount >= nMaxCount )
        nCount = nMaxCount - 1;

    CopyMemory( lpClassName, lpClassNameW,  nCount * sizeof(WCHAR) );

    lpClassName[nCount] = 0x0000;

    iRetValue = nCount;

    LocalFreeAndNull( &lpClassNameA );
    LocalFreeAndNull( &lpClassNameW );

    return iRetValue;


}

// TranslateAccelerator
int WINAPI TranslateAcceleratorWrapW( HWND   hWnd,        // handle to destination window
                                      HACCEL hAccTable,   // handle to accelerator table
                                      LPMSG  lpMsg )     // address of structure with message
{


    VALIDATE_PROTOTYPE(TranslateAccelerator);
    
    if (g_bRunningOnNT)
        return TranslateAcceleratorW(hWnd, hAccTable, lpMsg);

    
    return TranslateAcceleratorA(hWnd, hAccTable, lpMsg);

}


// GetDlgItemText
UINT WINAPI GetDlgItemTextWrapW( HWND   hDlg,        // handle of dialog box
                                 int    nIDDlgItem,  // identifier of control
                                 LPTSTR lpString,    // address of buffer for text
                                 int    nMaxCount ) // maximum size of string
{

    int     iRetValue = 0;
    LPSTR   lpStringA = NULL;
    LPWSTR  lpStringW = NULL;
    int     nCount =0;

    VALIDATE_PROTOTYPE(GetDlgItemText);

    *lpString = '\0';

    if (g_bRunningOnNT)
        return GetDlgItemTextW(hDlg, nIDDlgItem, lpString, nMaxCount);


    nCount = nMaxCount * sizeof( WCHAR );
    lpStringA = LocalAlloc( LMEM_ZEROINIT, nCount );

    iRetValue = GetDlgItemTextA(hDlg, nIDDlgItem, lpStringA, nMaxCount);

    if ( iRetValue == 0 ) {
        LocalFreeAndNull( &lpStringA );
        return iRetValue;
    }

    lpStringW = ConvertAtoW( lpStringA );
    nCount = My_wcslen( lpStringW );

    if ( nCount >= nMaxCount )
        nCount = nMaxCount - 1;

    CopyMemory( lpString, lpStringW,  nCount * sizeof(WCHAR) );

    lpString[nCount] = 0x0000;

    iRetValue = nCount;

    LocalFreeAndNull( &lpStringA );
    LocalFreeAndNull( &lpStringW );

    return iRetValue;
}

// SetMenuItemInfo
BOOL WINAPI SetMenuItemInfoWrapW( HMENU hMenu,          
                                  UINT  uItem,           
                                  BOOL  fByPosition,     
                                  LPMENUITEMINFO lpmii  )
{

    BOOL             bRetValue;
    MENUITEMINFOA    miiA;

//    VALIDATE_PROTOTYPE(SetMenuItemInfo);
    
    if (g_bRunningOnNT)
        return SetMenuItemInfoW(hMenu, uItem, fByPosition, lpmii);

    // Bug 1723 WinSE: MFT_STRING is defined as 0. So lpmii->fType can never have MFT_STRING bit set
    //if ( ((lpmii->fMask & MIIM_TYPE) == 0 ) || ((lpmii->fType & MFT_STRING) == 0 ) )
    if ( ((lpmii->fMask & MIIM_TYPE) == 0 ) || lpmii->fType != MFT_STRING )
    {
        return SetMenuItemInfoA(hMenu, uItem, fByPosition, (MENUITEMINFOA *)lpmii );
    }

    CopyMemory(&miiA, lpmii, sizeof(MENUITEMINFOA) );

    miiA.cbSize = sizeof(MENUITEMINFOA);
    miiA.dwTypeData = ConvertWtoA( lpmii->dwTypeData );
    miiA.cch = lstrlenA( miiA.dwTypeData );

    bRetValue = SetMenuItemInfoA(hMenu, uItem, fByPosition, &miiA );

    LocalFreeAndNull( &miiA.dwTypeData );

    return bRetValue;
}

// PeekMessage
BOOL WINAPI PeekMessageWrapW( LPMSG lpMsg,          // pointer to structure for message
                              HWND  hWnd,           // handle to window
                              UINT  wMsgFilterMin,  // first message
                              UINT  wMsgFilterMax,  // last message
                              UINT  wRemoveMsg )   // removal flags
{

    VALIDATE_PROTOTYPE(PeekMessage);
    
    if (g_bRunningOnNT)
        return PeekMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);

    return PeekMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);

}

// run time loaded APIs in Comctl32.dll

extern LPIMAGELIST_LOADIMAGE_A      gpfnImageList_LoadImageA;
extern LPPROPERTYSHEET_A            gpfnPropertySheetA;
extern LP_CREATEPROPERTYSHEETPAGE_A gpfnCreatePropertySheetPageA;
extern LPIMAGELIST_LOADIMAGE_W      gpfnImageList_LoadImageW;
extern LPPROPERTYSHEET_W            gpfnPropertySheetW;
extern LP_CREATEPROPERTYSHEETPAGE_W gpfnCreatePropertySheetPageW;


HIMAGELIST  WINAPI gpfnImageList_LoadImageWrapW(HINSTANCE hi,
                                                LPCWSTR lpbmp,
                                                int cx,
                                                int cGrow,
                                                COLORREF crMask,
                                                UINT uType,
                                                UINT uFlags)
{

    WORD   rID;


    VALIDATE_PROTOTYPE( gpfnImageList_LoadImage );

    if (g_bRunningOnNT)
       return gpfnImageList_LoadImageW(hi, lpbmp, cx, cGrow, crMask, uType, uFlags) ;

    // in our case, all the calling functions pass resources ID to lpbmp, 
    // so we don't want to convert this arguement.

    rID = (WORD)lpbmp;

    return gpfnImageList_LoadImageA(hi,(LPCSTR)((DWORD_PTR)(rID)), cx, cGrow, crMask, uType, uFlags) ; 

}


INT_PTR     WINAPI gpfnPropertySheetWrapW(LPCPROPSHEETHEADERW lppsh)
{

    INT_PTR           iRetValue;
    PROPSHEETHEADERA  pshA;
    LPSTR             pszCaption = NULL;

    VALIDATE_PROTOTYPE( gpfnPropertySheet );

    if (g_bRunningOnNT)
       return gpfnPropertySheetW( lppsh );

    CopyMemory( &pshA, lppsh, sizeof( PROPSHEETHEADERA ) );
    pshA.dwSize = sizeof(PROPSHEETHEADERA);

    pszCaption = ConvertWtoA( lppsh->pszCaption );
    pshA.pszCaption = pszCaption;

    iRetValue = gpfnPropertySheetA( &pshA );

    LocalFreeAndNull( &pszCaption );

    return iRetValue;

}

HPROPSHEETPAGE WINAPI gpfnCreatePropertySheetPageWrapW(LPCPROPSHEETPAGEW lppsp) 
{

    PROPSHEETPAGEA  pspA;
    HPROPSHEETPAGE  hRetValue;
    LPSTR           lpTitle = NULL;


    VALIDATE_PROTOTYPE( gpfnCreatePropertySheetPage );

    if (g_bRunningOnNT)
       return gpfnCreatePropertySheetPageW( lppsp );

    
    CopyMemory( &pspA, lppsp, sizeof(PROPSHEETPAGEA) ); 
    pspA.dwSize = sizeof( PROPSHEETPAGEA );
    lpTitle = ConvertWtoA( lppsp->pszTitle );
    pspA.pszTitle  = lpTitle;
    hRetValue = gpfnCreatePropertySheetPageA( &pspA );
    LocalFreeAndNull( &lpTitle );
    return hRetValue; 
    
}

// APIs in Commdlg32.dll


extern BOOL (*pfnGetOpenFileNameA)(LPOPENFILENAMEA pof);
extern BOOL (*pfnGetOpenFileNameW)(LPOPENFILENAMEW pof);

BOOL  WINAPI  pfnGetOpenFileNameWrapW(LPOPENFILENAMEW lpOf) 
{

   BOOL           bRetValue;
   OPENFILENAMEA  ofA;
   LPSTR          lpstrFilterA = NULL;
   LPSTR          lpstrFilterA_T = NULL,lpstrFilterAA=NULL ;
   LPWSTR         lpstrFilterW = NULL;
   CHAR           lpstrFileA[MAX_PATH+1] ="";
   LPSTR          lpstrFileTitleA = NULL;
   LPSTR          lpstrTitleA = NULL;
   LPSTR          lpstrDefExtA= NULL;
   LPSTR          lpTemplateNameA = NULL;
   LPSTR          lpstrInitialDirA = NULL;
   
   LPWSTR         lpstrFileW = NULL;
   DWORD          dwLen;

   VALIDATE_PROTOTYPE(pfnGetOpenFileName);

   if (g_bRunningOnNT)
      return pfnGetOpenFileNameW( lpOf );

   
   CopyMemory( &ofA,  lpOf, sizeof( OPENFILENAMEA ) );

   ofA.lStructSize = sizeof( OPENFILENAMEA );

   if ( lpOf->lpTemplateName )  {
      lpTemplateNameA = ConvertWtoA( lpOf->lpTemplateName );
      ofA.lpTemplateName = lpTemplateNameA;
   } 
   else 
      ofA.lpTemplateName =  NULL;

   if ( lpOf->lpstrDefExt ) {
      lpstrDefExtA = ConvertWtoA( lpOf->lpstrDefExt );
      ofA.lpstrDefExt = lpstrDefExtA;
   }
   else
      ofA.lpstrDefExt = NULL;

   if ( lpOf->lpstrTitle )  {
      lpstrTitleA = ConvertWtoA( lpOf->lpstrTitle );
      ofA.lpstrTitle = lpstrTitleA;
   }
   else
       ofA.lpstrTitle = NULL;

   if ( lpOf->lpstrFileTitle ) {
      lpstrFileTitleA = ConvertWtoA( lpOf->lpstrFileTitle );
      ofA.lpstrFileTitle = lpstrFileTitleA;
   }
   else
       ofA.lpstrFileTitle = NULL;

   if ( lpOf->lpstrInitialDir ) {
      lpstrInitialDirA = ConvertWtoA( lpOf->lpstrInitialDir );
      ofA.lpstrInitialDir = lpstrInitialDirA;
   }
   else
       ofA.lpstrInitialDir = NULL;

   ofA.lpstrCustomFilter = NULL;

   // get the total length of lpOf->lpstrFilter       

   dwLen = 0;
   lpstrFilterW = (LPWSTR)(lpOf->lpstrFilter);

   while ( *lpstrFilterW != TEXT('\0') ) {
        dwLen += lstrlenW(lpstrFilterW) + 1;
        lpstrFilterW += lstrlenW(lpstrFilterW) + 1;
   }

   dwLen += 1;  // for the last null terminator

   lpstrFilterW = (LPWSTR)( lpOf->lpstrFilter );
   lpstrFilterA = LocalAlloc( LMEM_ZEROINIT, dwLen * sizeof(WCHAR) );
   
   lpstrFilterA_T = lpstrFilterA;

   while ( *lpstrFilterW != TEXT('\0') ) { 
         lpstrFilterAA = ConvertWtoA(lpstrFilterW );
         lpstrFilterW += lstrlenW(lpstrFilterW) + 1;
         strcpy(lpstrFilterA_T, lpstrFilterAA );
         LocalFreeAndNull( &lpstrFilterAA );
         lpstrFilterA_T += lstrlenA( lpstrFilterA_T ) + 1;
   }

   lpstrFilterA_T[lstrlenA(lpstrFilterA_T)+1] = '\0';


   ofA.lpstrFilter = lpstrFilterA;
   ofA.lpstrFile   = lpstrFileA;
   ofA.nMaxFile = MAX_PATH + 1;

   bRetValue = pfnGetOpenFileNameA( &ofA );

    LocalFreeAndNull( &lpTemplateNameA );

    LocalFreeAndNull( &lpstrDefExtA );


    LocalFreeAndNull( &lpstrTitleA );


    LocalFreeAndNull( &lpstrFileTitleA );


    LocalFreeAndNull( &lpstrInitialDirA );
  
  LocalFreeAndNull( &lpstrFilterA );

   if ( bRetValue != FALSE ) {
      lpstrFileW = ConvertAtoW( lpstrFileA );
      CopyMemory( lpOf->lpstrFile, lpstrFileW, (lstrlenW(lpstrFileW)+1) * sizeof( WCHAR) ); 
      LocalFreeAndNull( &lpstrFileW );
   }

   return bRetValue; 
      
}

extern BOOL (*pfnGetSaveFileNameA)(LPOPENFILENAMEA pof);
extern BOOL (*pfnGetSaveFileNameW)(LPOPENFILENAMEW pof);

BOOL  WINAPI  pfnGetSaveFileNameWrapW(LPOPENFILENAMEW lpOf) 
{

   BOOL           bRetValue;
   OPENFILENAMEA  ofA;
   LPSTR          lpstrFilterA = NULL;
   LPSTR          lpstrFilterA_T = NULL,lpstrFilterAA=NULL ;
   LPWSTR         lpstrFilterW = NULL;
   CHAR           lpstrFileA[MAX_PATH+1] ="";
   LPSTR          lpFileA = NULL;
   LPSTR          lpstrFileTitleA = NULL;
   LPSTR          lpstrTitleA = NULL;
   LPSTR          lpstrDefExtA= NULL;
   LPSTR          lpTemplateNameA = NULL;
   LPSTR          lpstrInitialDirA = NULL;
   
   LPWSTR         lpstrFileW = NULL;
   DWORD          dwLen;

   VALIDATE_PROTOTYPE(pfnGetOpenFileName);

   if (g_bRunningOnNT)
      return pfnGetSaveFileNameW( lpOf );

   
   CopyMemory( &ofA,  lpOf, sizeof( OPENFILENAMEA ) );

   ofA.lStructSize = sizeof( OPENFILENAMEA );

   if ( lpOf->lpTemplateName )  {
      lpTemplateNameA = ConvertWtoA( lpOf->lpTemplateName );
      ofA.lpTemplateName = lpTemplateNameA;
   } 
   else 
      ofA.lpTemplateName =  NULL;

   if ( lpOf->lpstrDefExt ) {
      lpstrDefExtA = ConvertWtoA( lpOf->lpstrDefExt );
      ofA.lpstrDefExt = lpstrDefExtA;
   }
   else
      ofA.lpstrDefExt = NULL;

   if ( lpOf->lpstrTitle )  {
      lpstrTitleA = ConvertWtoA( lpOf->lpstrTitle );
      ofA.lpstrTitle = lpstrTitleA;
   }
   else
       ofA.lpstrTitle = NULL;

   if ( lpOf->lpstrFileTitle ) {
      lpstrFileTitleA = ConvertWtoA( lpOf->lpstrFileTitle );
      ofA.lpstrFileTitle = lpstrFileTitleA;
   }
   else
       ofA.lpstrFileTitle = NULL;

   if ( lpOf->lpstrFile ) {
      lpFileA = ConvertWtoA( lpOf->lpstrFile );
      lstrcpyA(lpstrFileA, lpFileA);
      ofA.lpstrFile = lpstrFileA;
       ofA.nMaxFile = MAX_PATH + 1;
   }
   else
       ofA.lpstrFile = NULL;

   if ( lpOf->lpstrInitialDir ) {
      lpstrInitialDirA = ConvertWtoA( lpOf->lpstrInitialDir );
      ofA.lpstrInitialDir = lpstrInitialDirA;
   }
   else
       ofA.lpstrInitialDir = NULL;

   ofA.lpstrCustomFilter = NULL;

   // get the total length of lpOf->lpstrFilter       

   dwLen = 0;
   lpstrFilterW = (LPWSTR)(lpOf->lpstrFilter);

   while ( *lpstrFilterW != TEXT('\0') ) {
        dwLen += lstrlenW(lpstrFilterW) + 1;
        lpstrFilterW += lstrlenW(lpstrFilterW) + 1;
   }

   dwLen += 1;  // for the last null terminator

   lpstrFilterW = (LPWSTR)( lpOf->lpstrFilter );
   lpstrFilterA = LocalAlloc( LMEM_ZEROINIT, dwLen * sizeof(WCHAR) );
   
   lpstrFilterA_T = lpstrFilterA;

   while ( *lpstrFilterW != TEXT('\0') ) { 
         lpstrFilterAA = ConvertWtoA(lpstrFilterW );
         lpstrFilterW += lstrlenW(lpstrFilterW) + 1;
         strcpy(lpstrFilterA_T, lpstrFilterAA );
         LocalFreeAndNull( &lpstrFilterAA );
         lpstrFilterA_T += lstrlenA( lpstrFilterA_T ) + 1;
   }

   lpstrFilterA_T[lstrlenA(lpstrFilterA_T)+1] = '\0';


   ofA.lpstrFilter = lpstrFilterA;

   bRetValue = pfnGetSaveFileNameA( &ofA );

  LocalFreeAndNull( &lpTemplateNameA );

  LocalFreeAndNull( &lpstrDefExtA );
   
  LocalFreeAndNull( &lpstrTitleA );
   
  LocalFreeAndNull( &lpstrFileTitleA );
   
  LocalFreeAndNull( &lpstrInitialDirA );
  
  LocalFreeAndNull( &lpstrFilterA );

  LocalFreeAndNull( &lpFileA );

   if ( bRetValue != FALSE ) {
      lpstrFileW = ConvertAtoW( lpstrFileA );
      CopyMemory( lpOf->lpstrFile, lpstrFileW, (lstrlenW(lpstrFileW)+1) * sizeof( WCHAR) ); 
      LocalFreeAndNull( &lpstrFileW );
   }

   return bRetValue; 
      
}

extern BOOL (*pfnPrintDlgA)(LPPRINTDLGA lppd);
extern BOOL (*pfnPrintDlgW)(LPPRINTDLGW lppd);

BOOL    WINAPI   pfnPrintDlgWrapW(LPPRINTDLGW lppd)
{

    BOOL        bRetValue;
    PRINTDLGA   pdA;

    VALIDATE_PROTOTYPE(pfnPrintDlg);

    if (g_bRunningOnNT)
      return pfnPrintDlgW( lppd );


    CopyMemory( &pdA, lppd, sizeof( PRINTDLGA ) );

    pdA.lStructSize = sizeof( PRINTDLGA );

    // Only lpPrintTemplateName and lpSetupTemplateName has STR type, 
    // but in our case, only IDD of Resources are passed to these two parameters.

    // so don't do conversion.

    pdA.lpPrintTemplateName = (LPCSTR)(lppd->lpPrintTemplateName);
    pdA.lpSetupTemplateName = (LPCSTR)(lppd->lpSetupTemplateName);

    bRetValue = pfnPrintDlgA ( &pdA );

    lppd->hDC = pdA.hDC;
    lppd->Flags = pdA.Flags;

    lppd->nFromPage = pdA.nFromPage;
    lppd->nToPage =  pdA.nToPage;
    lppd->nMinPage = pdA.nMinPage;
    lppd->nMaxPage = pdA.nMaxPage;
    
    lppd->nCopies = pdA.nCopies;

    return bRetValue;
}


extern HRESULT (*pfnPrintDlgExA)(LPPRINTDLGEXA lppdex);
extern HRESULT (*pfnPrintDlgExW)(LPPRINTDLGEXW lppdex);

HRESULT WINAPI   pfnPrintDlgExWrapW(LPPRINTDLGEXW lppdex)
{

    HRESULT      hRetValue;
    PRINTDLGEXA  pdexA;

    VALIDATE_PROTOTYPE(pfnPrintDlgEx);

    if (g_bRunningOnNT)
       return pfnPrintDlgExW( lppdex );


    CopyMemory( &pdexA, lppdex, sizeof( PRINTDLGEXA ) );

    pdexA.lStructSize = sizeof( PRINTDLGEXA );

    // Only lpPrintTemplateName and lpSetupTemplateName has STR type, 
    // but in our case, only IDD of Resources are passed to these two parameters.

    // so don't do conversion.

    hRetValue = pfnPrintDlgExA( &pdexA );

    lppdex->dwResultAction = pdexA.dwResultAction;
    lppdex->hDC = pdexA.hDC;

    lppdex->lpPageRanges = pdexA.lpPageRanges;
    lppdex->nCopies = pdexA.nCopies;
    lppdex->nMaxPage = pdexA.nMaxPage;

    lppdex->nMaxPageRanges = pdexA.nMaxPageRanges;
    lppdex->nMinPage = pdexA.nMinPage;

    lppdex->nPageRanges = pdexA.nPageRanges;
    lppdex->nPropertyPages = pdexA.nPropertyPages;

    lppdex->nStartPage = pdexA.nStartPage;

    return hRetValue;

}

// GetWindowTextLength
int WINAPI GetWindowTextLengthWrapW( HWND hWnd)
{
    VALIDATE_PROTOTYPE(GetWindowTextLength);

    if (g_bRunningOnNT)
        return GetWindowTextLengthW(hWnd);
    else
        return GetWindowTextLengthA(hWnd);

}


// GetFileVersionInfoSize
DWORD GetFileVersionInfoSizeWrapW( LPTSTR lptstrFilename, LPDWORD lpdwHandle )
{
    LPSTR lpFileA = NULL;
    DWORD dwRet = 0;

    VALIDATE_PROTOTYPE(GetFileVersionInfoSize);

    if (g_bRunningOnNT)
        return GetFileVersionInfoSizeW(lptstrFilename, lpdwHandle);

    lpFileA = ConvertWtoA(lptstrFilename);
    dwRet = GetFileVersionInfoSizeA(lpFileA, lpdwHandle);
    LocalFreeAndNull(&lpFileA);
    return dwRet;
}

// GetFileVersionInfo
BOOL GetFileVersionInfoWrapW( LPTSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
{
    LPSTR lpFileA = NULL;
    BOOL bRet = FALSE;

    VALIDATE_PROTOTYPE(GetFileVersionInfo);

    if (g_bRunningOnNT)
        return GetFileVersionInfoW(lptstrFilename, dwHandle, dwLen, lpData);

    // Note this is assuming that the dwLen and dwHandle are the same as those returned by 
    // GetFileVersionInfoSize ..

    lpFileA = ConvertWtoA(lptstrFilename);
    bRet = GetFileVersionInfoA(lpFileA, dwHandle, dwLen, lpData);
    LocalFreeAndNull(&lpFileA);
    return bRet;
}

// VerQueryValue 
// This one assumes that pBlock etc are all returned by GetFileVersionInfo and GetFileVersionInfoSize etc
BOOL VerQueryValueWrapW( const LPVOID pBlock, LPTSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
{
    LPSTR lpBlockA = NULL;
    BOOL bRet = FALSE;

    VALIDATE_PROTOTYPE(GetFileVersionInfo);

    if (g_bRunningOnNT)
        return VerQueryValueW(pBlock, lpSubBlock, lplpBuffer, puLen);

    // Note this is assuming that the dwLen and dwHandle are the same as those returned by 
    // GetFileVersionInfoSize ..

    lpBlockA = ConvertWtoA(lpSubBlock);
    bRet = VerQueryValueA(pBlock, lpBlockA, lplpBuffer, puLen);
    LocalFreeAndNull(&lpBlockA);
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\certs.h ===
//*******************************************************************
//
//  Copyright(c) Microsoft Corporation, 1996
//
//  FILE: CERT.H
//
//  PURPOSE:  Header file for certificate functions in cert.c.
//
//  HISTORY:
//  96/09/23  vikramm Created.
//  96/11/14  markdu  BUG 10132 Updated to post-SDR CAPI.
//  96/11/14  markdu  BUG 10267 Remove static link to functions in advapi32.dll
//
//*******************************************************************

#ifndef __CERT_H
#define __CERT_H

#ifndef IN
#define IN
#endif
#ifndef OUT
#define OUT
#endif
#ifndef OPTIONAL
#define OPTIONAL
#endif

// Note:
// Some data types  are assumed and may need to be changed
//

// other defines
#define MAX_STR                 256       // Sting buffer size
#define NUM_CHARS_PER_SN_BYTE   3         // Number of characters needed to display
                                          // each byte of the serial number

// This struct and tags will be published by the exchange group -- this is temporary.
#define NUM_CERT_TAGS           4
#define CERT_TAG_DEFAULT        0x20
#define CERT_TAG_THUMBPRINT     0x22
#define CERT_TAG_BINCERT        0x03
#define CERT_TAG_SYMCAPS        0x02
#define CERT_TAG_SIGNING_TIME   0x0D
#define CERT_TAG_SMIMECERT      0x30
// SIZE_CERTTAGS is the size of the structure excluding the byte array.
#define SIZE_CERTTAGS       (2 * sizeof(WORD))

// useless warning, should probably just remove the []
#pragma warning (disable:4200)
typedef struct _CertTag
{
  WORD  tag;
  WORD  cbData;
  BYTE  rgbData[];
} CERTTAGS, FAR * LPCERTTAGS;
#pragma warning (default:4200)

/************************************************************************************/
// Bare minimum info needed for each cert in the details certificate pane
//
typedef struct _CertDisplayInfo
{
	LPTSTR lpszDisplayString;   // String to display for this certificate
    LPTSTR lpszEmailAddress;
	DWORD   dwTrust;            // One of above trust flags
	BOOL bIsDefault;            // Is this the default cert
	BOOL bIsRevoked;            // Has this been revoked
    BOOL bIsExpired;            // Is this expired
    BOOL bIsTrusted;            // Is this a trusted certificate
    PCCERT_CONTEXT      pccert; // THis is the actual cert
	BLOB blobSymCaps;            // Symetric Capabilities
   FILETIME ftSigningTime;      // Signing Time
  struct _CertDisplayInfo * lpNext;
  struct _CertDisplayInfo * lpPrev;
} CERT_DISPLAY_INFO, * LPCERT_DISPLAY_INFO;
/************************************************************************************/


/************************************************************************************/
// Details needed to display properties
//
typedef struct _CertDisplayProps
{
	BOOL    bIsRevoked;         // Has this been revoked
    BOOL    bIsExpired;         // Is this expired
	DWORD   dwTrust;            // One of above trust flags
    BOOL    bIsTrusted;         // Whether its trusted or not
  LPTSTR  lpszSerialNumber;   // Serial Number for the cert
  LPTSTR  lpszValidFromTo;    // Valid from XXX to XXX
  LPTSTR  lpszSubjectName;    // Subject's name (same as display name in CERT_DISPLAY_INFO)
  LPTSTR  lpszIssuerName;     // Issuer's name - NULL if no name (self-issued)
  CRYPT_DIGEST_BLOB blobIssuerCertThumbPrint; // The actual certificate thumbprint of the issuer cert
  int     nFieldCount;        // Number of fields for which data exists (other that what we already have)
  LPTSTR* lppszFieldCount;    // LPTSTR array of field names
  LPTSTR* lppszDetails;       // LPTSTR array of details with one to one correspondence with field names
  struct _CertDisplayProps * lpIssuer;  // Next cert up in the issuer chain.
  struct _CertDisplayProps * lpPrev;    // previous cert in the issuer chain.
} CERT_DISPLAY_PROPS, * LPCERT_DISPLAY_PROPS;
/************************************************************************************/


/************************************************************************************/
// This is used by Cert UI elements
typedef struct _CertItem
{
    LPCERT_DISPLAY_INFO lpCDI;
    PCCERT_CONTEXT  pcCert;
    TCHAR szDisplayText[MAX_PATH]; //should really be MAX_UI_STR
    struct _CertItem * lpNext;
    struct _CertItem * lpPrev;
} CERT_ITEM, * LPCERT_ITEM;
/************************************************************************************/


// Function prototypes

//*******************************************************************
//
//  FUNCTION:   HrGetCertsDisplayInfo
//
//  PURPOSE:    Takes an input array of certs in a SPropValue structure
//              and outputs a list of cert data structures by parsing through
//              the array and looking up the cert data in the store.
//
//  PARAMETERS: hwndParent - any UI is modal to this
//              lpPropValue - PR_USER_X509_CERTIFICATE property array
//              lppCDI - recieves an allocated structure  containing
//              the cert data.  Must be freed by calling FreeCertdisplayinfo.
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//
//*******************************************************************

HRESULT HrGetCertsDisplayInfo(
  IN  HWND hwndParent,
  IN  LPSPropValue lpPropValue,
  OUT LPCERT_DISPLAY_INFO * lppCDI);


//*******************************************************************
//
//  FUNCTION:   HrSetCertsFromDisplayInfo
//
//  PURPOSE:    Takes a linked list of cert data structures and outputs
//              an SPropValue array of PR_USER_X509_CERTIFICATE properties.
//
//  PARAMETERS: lpCDI - linked list of input structures to convert to
//              SPropValue array
//              lpulcPropCount - receives the number of SPropValue's returned
//              Note that this will always be one.
//              lppPropValue - receives a MAPI-allocated SPropValue structure
//              containing an X509_USER_CERTIFICATE property
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//
//*******************************************************************

HRESULT HrSetCertsFromDisplayInfo(
  IN  LPCERT_ITEM lpCItem,
  OUT ULONG * lpulcPropCount,
  OUT LPSPropValue * lppPropValue);


//*******************************************************************
//
//  FUNCTION:   HrGetCertDisplayProps
//
//  PURPOSE:    Get displayable properties and other data for a certificate.
//
//  PARAMETERS: pblobCertThumbPrint - thumb print of certificate to look up
//              hcsCertStore - the store that holds the cert.  Use NULL to
//              open the WAB store.
//              hCryptProvider - the provider to use for store access.  Use
//              zero to get the provider.
//              dwTrust - trust flags for this cert.
//              bIsTrusted - trusted or not ...
//              lppCDP - recieves an allocated structure  containing
//              the cert data.  Must be freed by calling FreeCertdisplayprops.
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//
//*******************************************************************

HRESULT HrGetCertDisplayProps(
  IN  PCRYPT_DIGEST_BLOB  pblobCertThumbPrint,
  IN  HCERTSTORE hcsCertStore,
  IN  HCRYPTPROV hCryptProvider,
  IN  DWORD dwTrust,
  IN  BOOL  bIsTrusted,
  OUT LPCERT_DISPLAY_PROPS * lppCDP);


//*******************************************************************
//
//  FUNCTION:   HrImportCertFromFile
//
//  PURPOSE:    Import a cert from a file.
//
//  PARAMETERS: lpszFileName - name of file containing the cert.
//              lppCDI - recieves an allocated structure  containing
//              the cert data.  Must be freed by calling FreeCertdisplayinfo.
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//
//*******************************************************************

HRESULT HrImportCertFromFile(
  IN  LPTSTR  lpszFileName,
  OUT LPCERT_DISPLAY_INFO * lppCDI);


//*******************************************************************
//
//  FUNCTION:   HrExportCertToFile
//
//  PURPOSE:    Export a cert to a file.
//
//  PARAMETERS: lpszFileName - name of file in which to store the cert.
//              If the file exists, it will be overwritten, so the caller
//              must verify that this is OK first if so desired.
//              pblobCertThumbPrint - thumb print of certificate to export.
//              lpCertDataBuffer - buffer to write cert data to instead of file 
//              fWriteDataToBuffer - flag indicating where cert data should be written
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//  98/07/22  t-jstaj updated to take 3 add'l parameters, a data buffer, its length 
//                    and flag which will indicate whether or not to 
//                    write data to buffer or file.  The memory allocated to 
//                    to the buffer needs to be freed by caller.
//
//*******************************************************************

HRESULT HrExportCertToFile(
  IN  LPTSTR  lpszFileName,
  IN  PCCERT_CONTEXT pccert,
  OUT LPBYTE *lpCertDataBuffer,
  OUT PULONG  lpcbBufLen,
  IN  BOOL    fWriteDataToBuffer );


//*******************************************************************
//
//  FUNCTION:   FreeCertdisplayinfo
//
//  PURPOSE:    Release memory allocated for a CERT_DISPLAY_INFO structure.
//              Assumes all info in the structure was LocalAlloced
//
//  PARAMETERS: lpCDI - structure to free.
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//
//*******************************************************************

void FreeCertdisplayinfo(LPCERT_DISPLAY_INFO lpCDI);


//*******************************************************************
//
//  FUNCTION:   FreeCertdisplayprops
//
//  PURPOSE:    Release memory allocated for a CERT_DISPLAY_PROPS structure.
//              THIS INCLUDES the entire linked list below this sturcture,
//              so an entire list can be free by passing in the head of the list.
//              Assumes all info in the structure was LocalAlloced
//
//  PARAMETERS: lpCDP - structure (list) to free.
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//
//*******************************************************************

void FreeCertdisplayprops(LPCERT_DISPLAY_PROPS lpCDP);


//*******************************************************************
//
//  FUNCTION:   InitCryptoLib
//
//  PURPOSE:    Load the Crypto API libray and get the proc addrs.
//
//  PARAMETERS: None.
//
//  RETURNS:    TRUE if successful, FALSE otherwise.
//
//  HISTORY:
//  96/10/01  markdu  Created.
//  96/11/19  markdu  No longer keep a ref count, just use the global
//            library handles.
//
//*******************************************************************

BOOL InitCryptoLib(void);


//*******************************************************************
//
//  FUNCTION:   DeinitCryptoLib
//
//  PURPOSE:    Release the Crypto API libraries.
//
//  PARAMETERS: None.
//
//  RETURNS:    None.
//
//  HISTORY:
//  96/10/01  markdu  Created.
//  96/11/19  markdu  No longer keep a ref count, just call this in
//            DLL_PROCESS_DETACH.
//
//*******************************************************************

void DeinitCryptoLib(void);


//*******************************************************************
//
//  FUNCTION:   HrLDAPCertToMAPICert
//
//  PURPOSE:    Convert cert(s) returned from LDAP server to MAPI props.
//              Two properties are required.  The certs are placed in the
//              WAB store, and all necessary indexing data is placed in
//              PR_USER_X509_CERTIFICATE property.  If this certificate
//              didn't already exist in the WAB store, it's thumbprint is
//              added to PR_WAB_TEMP_CERT_HASH so that these certs can
//              be deleted from the store if the user cancels the add.
//
//  PARAMETERS: lpPropArray - the prop array where the 2 props are stored
//              ulX509Index - the index to the PR_USER_X509_CERTIFICATE prop
//              ulTempCertIndex - the index to the PR_WAB_TEMP_CERT_HASH prop
//              lpCert, cbCert, - cert from LDAP ppberval struct
//              ulcCerts - the number of certs from the LDAP server
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/12/12  markdu  Created.
//
//*******************************************************************

HRESULT HrLDAPCertToMAPICert(
  LPSPropValue    lpPropArray,
  ULONG           ulX509Index,
  ULONG           ulTempCertIndex,
  ULONG           cbCert,
  PBYTE           lpCert,
  ULONG           ulcCerts);


//*******************************************************************
//
//  FUNCTION:   HrRemoveCertsFromWABStore
//
//  PURPOSE:    Remove the certs whose thumbprints are in the supplied
//              PR_WAB_TEMP_CERT_HASH property.
//
//  PARAMETERS: lpPropValue - the PR_WAB_TEMP_CERT_HASH property
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/12/13  markdu  Created.
//
//*******************************************************************

HRESULT HrRemoveCertsFromWABStore(
  LPSPropValue    lpPropValue);



//*******************************************************************
//
//  FUNCTION:   DeinitPStore
//
//  PURPOSE:    Release the protected store.
//
//  PARAMETERS: None.
//
//  RETURNS:    None.
//
//  HISTORY:
//  97/02/17  t-erikne  Created.
//
//*******************************************************************

void DeinitPStore(void);

//*******************************************************************
//
//  FUNCTION:   DeleteCertStuff
//
//  PURPOSE:    Remove trust from the pstore and (later) certs from
//              the CAPI store
//
//  PARAMETERS:
//              LPADRBOOK lpIAB - container to use
//              LPENTRYID lpEntryID - eid of item to clean up
//              ULONG cbEntryID - cb of above
//
//  RETURNS:    I promise it does.
//
//  HISTORY:
//  97/03/19  t-erikne  Created.
//
//*******************************************************************
HRESULT DeleteCertStuff(LPADRBOOK lpIAB,
                        LPENTRYID lpEntryID,
                        ULONG cbEntryID);


//*******************************************************************
//
//  FUNCTION:   WabGetCertFromThumbprint
//
//  PURPOSE:    Opens the WAB's cert store and tries to find the cert
//              the CAPI store
//
//  PARAMETERS:
//              CRYPT_DIGEST_BLOB thumbprint - the thumbprint to
//              search on.
//
//  RETURNS:    the cert.  NULL if not found
//
//  HISTORY:
//  97/06/27  t-erikne  Created.
//
//*******************************************************************
PCCERT_CONTEXT WabGetCertFromThumbprint(CRYPT_DIGEST_BLOB thumbprint);


//************************************************************************************
// Crypto function typedefs

//
// Updated as of 2/3
// (t-erikne)
//

// CertAddEncodedCertificateToStore
typedef BOOL (WINAPI * LPCERTADDENCODEDCERTIFICATETOSTORE) (
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbCertEncoded,
    IN DWORD cbCertEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCERT_CONTEXT *ppCertContext
    );

// CertCloseStore
typedef BOOL (WINAPI * LPCERTCLOSESTORE) (
  IN HCERTSTORE hCertStore,
  DWORD dwFlags
  );

// CertCreateCertificateContext
typedef PCCERT_CONTEXT (WINAPI * LPCERTCREATECERTIFICATECONTEXT) (
  IN DWORD dwCertEncodingType,
  IN const BYTE *pbCertEncoded,
  IN DWORD cbCertEncoded
  );

// CertDeleteCertificateFromStore
typedef BOOL (WINAPI * LPCERTDELETECERTIFICATEFROMSTORE) (
  IN PCCERT_CONTEXT pCertContext
  );

// CertFindCertificateInStore
typedef PCCERT_CONTEXT (WINAPI * LPCERTFINDCERTIFICATEINSTORE) (
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCERT_CONTEXT pPrevCertContext
    );

// CertFreeCertificateContext
typedef BOOL (WINAPI * LPCERTFREECERTIFICATECONTEXT) (
    IN PCCERT_CONTEXT pCertContext
    );

// CertGetCertificateContextProperty
typedef BOOL (WINAPI * LPCERTGETCERTIFICATECONTEXTPROPERTY) (
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    );

// CertGetIssuerCertificateFromStore
typedef PCCERT_CONTEXT (WINAPI * LPCERTGETISSUERCERTIFICATEFROMSTORE) (
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pSubjectContext,
    IN OPTIONAL PCCERT_CONTEXT pPrevIssuerContext,
    IN OUT DWORD *pdwFlags
    );

// CertOpenSystemStore
typedef HCERTSTORE (WINAPI * LPCERTOPENSYSTEMSTORE) (
  HCRYPTPROV      hProv,
  LPTSTR		szSubsystemProtocol
  );

// CertOpenStore
typedef HCERTSTORE (WINAPI * LPCERTOPENSTORE) (
  IN DWORD         dwStoreProvType,
  IN DWORD         dwCertEncodingType,
  IN HCRYPTPROV    hCryptProv,
  IN DWORD         dwFlags,
  IN void *        pvPara
);

// CertEnumCertificatesInStore
typedef PCCERT_CONTEXT (WINAPI * LPCERTENUMCERTIFICATESINSTORE) (
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pPrevCertContext
);

// CertGetSubjectCertificateFromStore
typedef PCCERT_CONTEXT (WINAPI * LPCERTGETSUBJECTCERTIFICATEFROMSTORE) (
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertId
);


// CertCompareCertificate
typedef BOOL (WINAPI * LPCERTCOMPARECERTIFICATE) (
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertId1,
    IN PCERT_INFO pCertId2
);

// CertDuplicateCertificateContext
typedef PCCERT_CONTEXT (WINAPI * LPCERTDUPLICATECERTIFICATECONTEXT) (
    IN PCCERT_CONTEXT pCertContext
);

// CertNameToStrA
//N the right thing to do is use WINCRYPT32API
//N and fixt the import stuff
typedef DWORD (WINAPI * LPCERTNAMETOSTR) (
  IN DWORD dwCertEncodingType,
  IN PCERT_NAME_BLOB pName,
  IN DWORD dwStrType,
  OUT OPTIONAL LPTSTR psz,
  IN DWORD csz
  );

// CryptAcquireContext
typedef BOOL (WINAPI * LPCRYPTACQUIRECONTEXT) (
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);

// CryptDecodeObject
typedef BOOL (WINAPI * LPCRYPTDECODEOBJECT) (
    IN DWORD        dwCertEncodingType,
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    IN DWORD        dwFlags,
    OUT void        *pvStructInfo,
    IN OUT DWORD    *pcbStructInfo
    );

// CryptMsgClose
typedef BOOL (WINAPI * LPCRYPTMSGCLOSE) (
    IN HCRYPTMSG hCryptMsg
    );

// CryptMsgGetParam
typedef BOOL (WINAPI * LPCRYPTMSGGETPARAM) (
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    );

// CryptMsgOpenToDecode
typedef HCRYPTMSG (WINAPI * LPCRYPTMSGOPENTODECODE) (
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN HCRYPTPROV hCryptProv,
    IN OPTIONAL PCERT_INFO pRecipientInfo,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo
    );

// CryptMsgUpdate
typedef BOOL (WINAPI * LPCRYPTMSGUPDATE) (
    IN HCRYPTMSG hCryptMsg,
    IN const BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal
    );

// CryptReleaseContext
typedef BOOL (WINAPI * LPCRYPTRELEASECONTEXT) (
    HCRYPTPROV hProv,
    DWORD dwFlags);


typedef PCERT_RDN_ATTR (WINAPI * LPCERTFINDRDNATTR) (
    IN LPCSTR pszObjId,
    IN PCERT_NAME_INFO pName
    );

// CertRDNValueToStr
typedef DWORD (WINAPI * LPCERTRDNVALUETOSTR) (
    IN DWORD dwValueType,
    IN PCERT_RDN_VALUE_BLOB pValue,
    OUT LPTSTR pszValueString,
    IN DWORD cszValueString);

// CertVerifyTimeValidity
typedef LONG (WINAPI * LPCERTVERIFYTIMEVALIDITY) (
  IN LPFILETIME pTimeToVerify,
  IN PCERT_INFO pCertInfo);


#endif // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\ansiwrap.h ===
/*
-
-
-	AnsiWrap.h
*
*	Contains the declarations for the Win9x Thunkers implemented in 
*	ansiwrap.c
*
*/

extern BOOL g_bRunningOnNT; //set in entry.c


// ADVAPI32.DLL

LONG WINAPI RegOpenKeyExWrapW(  HKEY       hKey,         // handle to open key
                                LPCTSTR    lpSubKey,     // address of name of subkey to open
                                DWORD      ulOptions,    // reserved
                                REGSAM     samDesired,   // security access mask
                                PHKEY      phkResult);   // address of handle to open key

                            
LONG WINAPI RegQueryValueWrapW(  HKEY       hKey,         // handle to key to query
                                 LPCTSTR    lpSubKey,     // name of subkey to query
                                 LPTSTR     lpValue,      // buffer for returned string
                                 PLONG      lpcbValue);   // receives size of returned string

LONG WINAPI RegEnumKeyExWrapW(   HKEY      hKey,          // handle to key to enumerate
                                 DWORD     dwIndex,       // index of subkey to enumerate
                                 LPTSTR    lpName,        // address of buffer for subkey name
                                 LPDWORD   lpcbName,      // address for size of subkey buffer
                                 LPDWORD   lpReserved,    // reserved
                                 LPTSTR    lpClass,       // address of buffer for class string
                                 LPDWORD   lpcbClass,     // address for size of class buffer
                                 PFILETIME lpftLastWriteTime );
                                                          // address for time key last written to

LONG WINAPI RegSetValueWrapW(    HKEY    hKey,        // handle to key to set value for
                                 LPCTSTR lpSubKey,    // address of subkey name
                                 DWORD   dwType,      // type of value
                                 LPCTSTR lpData,      // address of value data
                                 DWORD   cbData );    // size of value data

LONG WINAPI RegDeleteKeyWrapW(   HKEY    hKey,        // handle to open key
                                 LPCTSTR lpSubKey);   // address of name of subkey to delete

BOOL WINAPI GetUserNameWrapW(    LPTSTR  lpBuffer,    // address of name buffer
                                 LPDWORD nSize );     // address of size of name buffer

LONG WINAPI RegEnumValueWrapW(   HKEY    hKey,           // handle to key to query
                                 DWORD   dwIndex,        // index of value to query
                                 LPTSTR  lpValueName,    // address of buffer for value string
                                 LPDWORD lpcbValueName,  // address for size of value buffer
                                 LPDWORD lpReserved,     // reserved
                                 LPDWORD lpType,         // address of buffer for type code
                                 LPBYTE  lpData,         // address of buffer for value data
                                 LPDWORD lpcbData );     // address for size of data buffer

LONG WINAPI RegDeleteValueWrapW( HKEY    hKey,           // handle to key
                                 LPCTSTR lpValueName );  // address of value name

LONG WINAPI RegCreateKeyWrapW(   HKEY    hKey,          // handle to an open key
                                 LPCTSTR lpSubKey,      // address of name of subkey to open
                                 PHKEY   phkResult  );  // address of buffer for opened handle


// in header file wincrypt.h
BOOL WINAPI CryptAcquireContextWrapW( HCRYPTPROV *phProv,      // out
                                      LPCTSTR    pszContainer, // in
                                      LPCTSTR    pszProvider,  // in
                                      DWORD      dwProvType,   // in
                                      DWORD      dwFlags );    // in

LONG WINAPI RegQueryValueExWrapW( HKEY     hKey,           // handle to key to query
                                  LPCTSTR  lpValueName,    // address of name of value to query
                                  LPDWORD  lpReserved,     // reserved
                                  LPDWORD  lpType,         // address of buffer for value type
                                  LPBYTE   lpData,         // address of data buffer
                                  LPDWORD  lpcbData );     // address of data buffer size

LONG WINAPI RegCreateKeyExWrapW(  HKEY    hKey,                // handle to an open key
                                  LPCTSTR lpSubKey,            // address of subkey name
                                  DWORD   Reserved,            // reserved
                                  LPTSTR  lpClass,             // address of class string
                                  DWORD   dwOptions,           // special options flag
                                  REGSAM  samDesired,          // desired security access
                                  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                              // address of key security structure
                                  PHKEY   phkResult,          // address of buffer for opened handle
                                  LPDWORD lpdwDisposition );  // address of disposition value buffer

LONG WINAPI RegSetValueExWrapW(   HKEY    hKey,           // handle to key to set value for
                                  LPCTSTR lpValueName,    // name of the value to set
                                  DWORD   Reserved,       // reserved
                                  DWORD   dwType,         // flag for value type
                                  CONST BYTE *lpData,     // address of value data
                                  DWORD   cbData );       // size of value data

LONG WINAPI RegQueryInfoKeyWrapW( HKEY    hKey,                  // handle to key to query
                                  LPTSTR  lpClass,               // address of buffer for class string
                                  LPDWORD lpcbClass,             // address of size of class string buffer
                                  LPDWORD lpReserved,            // reserved
                                  LPDWORD lpcSubKeys,            // address of buffer for number of subkeys
                                  LPDWORD lpcbMaxSubKeyLen,      // address of buffer for longest subkey 
                                                                 // name length
                                  LPDWORD lpcbMaxClassLen,       // address of buffer for longest class 
                                                                 // string length
                                  LPDWORD lpcValues,             // address of buffer for number of value 
                                                                 // entries
                                  LPDWORD lpcbMaxValueNameLen,   // address of buffer for longest 
                                                                 // value name length
                                  LPDWORD lpcbMaxValueLen,       // address of buffer for longest value 
                                                                 // data length
                                  LPDWORD lpcbSecurityDescriptor,
                                                                 // address of buffer for security 
                                                                 // descriptor length
                                  PFILETIME lpftLastWriteTime);  // address of buffer for last write time
                                                             


//GDI32.DLL

int WINAPI GetObjectWrapW( HGDIOBJ hgdiobj,      // handle to graphics object of interest
                           int     cbBuffer,     // size of buffer for object information
                           LPVOID  lpvObject );  // pointer to buffer for object information

int WINAPI StartDocWrapW(  HDC           hdc,      // handle to device context
                           CONST DOCINFO *lpdi );  // address of structure with file names

HFONT WINAPI CreateFontIndirectWrapW (CONST LOGFONT *lplf );  // pointer to logical font structure


//KERNEL32.DLL

int WINAPI GetLocaleInfoWrapW( LCID   Locale,       // locale identifier
                               LCTYPE LCType,       // type of information
                               LPTSTR lpLCData,     // address of buffer for information
                               int    cchData );    // size of buffer

BOOL WINAPI CreateDirectoryWrapW(LPCTSTR               lpPathName,           // pointer to directory path string
                                 LPSECURITY_ATTRIBUTES lpSecurityAttributes);// pointer to security descriptor

UINT WINAPI GetWindowsDirectoryWrapW( LPTSTR lpBuffer,  // address of buffer for Windows directory
                                      UINT   uSize );   // size of directory buffer

UINT WINAPI GetSystemDirectoryWrapW( LPTSTR lpBuffer,  // address of buffer for system directory
                                     UINT   uSize );   // size of directory buffer

BOOL WINAPI GetStringTypeWrapW( DWORD    dwInfoType,
                                LPCWSTR  lpSrcStr,
                                int      cchSrc,
                                LPWORD   lpCharType);

UINT WINAPI GetProfileIntWrapW( LPCTSTR lpAppName,  // address of section name
                                LPCTSTR lpKeyName,  // address of key name
                                INT     nDefault ); // default value if key name is not found

int WINAPI LCMapStringWrapW( LCID    Locale,      // locale identifier
                             DWORD   dwMapFlags,  // mapping transformation type
                             LPCTSTR lpSrcStr,    // address of source string
                             int     cchSrc,      // number of characters in source string
                             LPTSTR  lpDestStr,   // address of destination buffer
                             int     cchDest );   // size of destination buffer

DWORD WINAPI GetFileAttributesWrapW( LPCTSTR lpFileName );  // pointer to the name of a file or directory

int WINAPI CompareStringWrapW( LCID    Locale,        // locale identifier
                               DWORD   dwCmpFlags,    // comparison-style options
                               LPCTSTR lpString1,     // pointer to first string
                               int     cchCount1,     // size, in bytes or characters, of first string
                               LPCTSTR lpString2,     // pointer to second string
                               int     cchCount2 );   // size, in bytes or characters, of second string

HANDLE WINAPI CreateEventWrapW(LPSECURITY_ATTRIBUTES lpEventAttributes, // pointer to security attributes
                               BOOL bManualReset,     // flag for manual-reset event
                               BOOL bInitialState,    // flag for initial state
                               LPCTSTR lpcwszName);   // pointer to event-object name


//  CompareStringA
LPTSTR WINAPI lstrcpyWrapW( LPTSTR  lpString1,     // pointer to buffer
                            LPCTSTR lpString2 );   // pointer to string to copy

int WINAPI lstrcmpiWrapW( LPCTSTR lpString1,    // pointer to first string
                          LPCTSTR lpString2 );  // pointer to second string

HINSTANCE WINAPI LoadLibraryWrapW( LPCTSTR lpLibFileName );  // address of filename of executable module

int WINAPI GetTimeFormatWrapW( LCID    Locale,            // locale for which time is to be formatted
                               DWORD   dwFlags,           // flags specifying function options
                               CONST SYSTEMTIME *lpTime,  // time to be formatted
                               LPCTSTR lpFormat,          // time format string
                               LPTSTR  lpTimeStr,         // buffer for storing formatted string
                               int     cchTime  );        // size, in bytes or characters, of the buffer

BOOL WINAPI GetTextExtentPoint32WrapW(HDC     hdc,
                                      LPCWSTR pwszBuf,
                                      int     nLen,
                                      LPSIZE  psize);

int WINAPI GetDateFormatWrapW( LCID    Locale,             // locale for which date is to be formatted
                               DWORD   dwFlags,            // flags specifying function options
                               CONST SYSTEMTIME *lpDate,   // date to be formatted
                               LPCTSTR lpFormat,           // date format string
                               LPTSTR  lpDateStr,          // buffer for storing formatted string
                               int     cchDate );          // size of buffer


LPTSTR WINAPI lstrcpynWrapW( LPTSTR  lpString1,     // pointer to target buffer
                             LPCTSTR lpString2,     // pointer to source string
                             int     iMaxLength );  // number of bytes or characters to copy


HANDLE WINAPI CreateFileWrapW( LPCTSTR lpFileName,             // pointer to name of the file
                               DWORD   dwDesiredAccess,        // access (read-write) mode
                               DWORD   dwShareMode,            // share mode
                               LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                               // pointer to security attributes
                               DWORD   dwCreationDisposition,  // how to create
                               DWORD   dwFlagsAndAttributes,   // file attributes
                               HANDLE  hTemplateFile );        // handle to file with attributes to copy
                               

VOID WINAPI OutputDebugStringWrapW(LPCTSTR lpOutputString );   // pointer to string to be displayed

LPTSTR WINAPI lstrcatWrapW( LPTSTR  lpString1,     // pointer to buffer for concatenated strings
                            LPCTSTR lpString2 );   // pointer to string to add to string1

DWORD WINAPI FormatMessageWrapW( DWORD    dwFlags,       // source and processing options
                                 LPCVOID  lpSource,      // pointer to  message source
                                 DWORD    dwMessageId,   // requested message identifier
                                 DWORD    dwLanguageId,  // language identifier for requested message
                                 LPTSTR   lpBuffer,      // pointer to message buffer
                                 DWORD    nSize,         // maximum size of message buffer
                                 va_list *Arguments );   // pointer to array of message inserts

DWORD WINAPI GetModuleFileNameWrapW( HMODULE hModule,    // handle to module to find filename for
                                     LPTSTR  lpFilename, // pointer to buffer to receive module path
                                     DWORD   nSize );    // size of buffer, in characters

UINT WINAPI GetPrivateProfileIntWrapW( LPCTSTR  lpAppName,    // address of section name
                                       LPCTSTR  lpKeyName,    // address of key name
                                       INT      nDefault,     // return value if key name is not found
                                       LPCTSTR  lpFileName ); // address of initialization filename

BOOL WINAPI IsBadStringPtrWrapW( LPCTSTR lpsz,       // address of string
                                 UINT_PTR    ucchMax );  // maximum size of string

DWORD WINAPI GetPrivateProfileStringWrapW( LPCTSTR lpAppName,          // points to section name
                                           LPCTSTR lpKeyName,          // points to key name
                                           LPCTSTR lpDefault,          // points to default string
                                           LPTSTR  lpReturnedString,   // points to destination buffer
                                           DWORD   nSize,              // size of destination buffer
                                           LPCTSTR lpFileName  );      // points to initialization filename

int WINAPI lstrcmpWrapW( LPCTSTR lpString1,    // pointer to first string
                         LPCTSTR lpString2 );  // pointer to second string

HANDLE WINAPI CreateMutexWrapW( LPSECURITY_ATTRIBUTES lpMutexAttributes,
                                                                       // pointer to security attributes
                                BOOL                  bInitialOwner,   // flag for initial ownership
                                LPCTSTR               lpName );        // pointer to mutex-object name

DWORD WINAPI GetTempPathWrapW( DWORD   nBufferLength,   // size, in characters, of the buffer
                               LPTSTR  lpBuffer );      // pointer to buffer for temp. path

DWORD WINAPI ExpandEnvironmentStringsWrapW( LPCTSTR lpSrc,     // pointer to string with environment variables
                                            LPTSTR  lpDst,     // pointer to string with expanded environment 
                                                               // variables
                                            DWORD   nSize );   // maximum characters in expanded string

UINT WINAPI GetTempFileNameWrapW( LPCTSTR lpPathName,        // pointer to directory name for temporary file
                                  LPCTSTR lpPrefixString,    // pointer to filename prefix
                                  UINT    uUnique,           // number used to create temporary filename
                                  LPTSTR  lpTempFileName  ); // pointer to buffer that receives the new filename                                                           

// BOOL WINAPI ReleaseMutexWrapW( HANDLE hMutex );  // handle to mutex object

                                                        
BOOL WINAPI DeleteFileWrapW( LPCTSTR lpFileName  ); // pointer to name of file to delete

BOOL WINAPI CopyFileWrapW( LPCTSTR lpExistingFileName, // pointer to name of an existing file
                           LPCTSTR lpNewFileName,      // pointer to filename to copy to
                           BOOL    bFailIfExists );    // flag for operation if file exists

HANDLE WINAPI FindFirstChangeNotificationWrapW(LPCTSTR lpcwszFilePath,  // Directory path of file to watch
                                               BOOL    bWatchSubtree,   // Monitor entire tree
                                               DWORD   dwNotifyFilter); // Conditions to watch for


HANDLE WINAPI FindFirstFileWrapW( LPCTSTR           lpFileName,       // pointer to name of file to search for
                                  LPWIN32_FIND_DATA lpFindFileData ); // pointer to returned information
                       

BOOL WINAPI GetDiskFreeSpaceWrapW( LPCTSTR lpRootPathName,       // pointer to root path
                                   LPDWORD lpSectorsPerCluster,  // pointer to sectors per cluster
                                   LPDWORD lpBytesPerSector,     // pointer to bytes per sector
                                   LPDWORD lpNumberOfFreeClusters,
                                                                 // pointer to number of free clusters
                                   LPDWORD lpTotalNumberOfClusters );
                                                                 // pointer to total number of clusters

BOOL WINAPI MoveFileWrapW( LPCTSTR lpExistingFileName,   // pointer to the name of the existing file
                           LPCTSTR lpNewFileName );      // pointer to the new name for the file


//SHELL32.DLL


HINSTANCE WINAPI ShellExecuteWrapW( HWND     hwnd, 
                                    LPCTSTR  lpOperation,
                                    LPCTSTR  lpFile, 
                                    LPCTSTR  lpParameters, 
                                    LPCTSTR  lpDirectory,
                                    INT      nShowCmd );
	

UINT WINAPI DragQueryFileWrapW( HDROP   hDrop,
                                UINT    iFile,
                                LPTSTR  lpszFile,
                                UINT    cch );



//USER32.DLL
LPTSTR WINAPI CharPrevWrapW( LPCTSTR lpszStart,      // pointer to first character
                             LPCTSTR lpszCurrent );  // pointer to current character

int WINAPI DrawTextWrapW( HDC     hDC,          // handle to device context
                          LPCTSTR lpString,     // pointer to string to draw
                          int     nCount,       // string length, in characters
                          LPRECT  lpRect,       // pointer to struct with formatting dimensions
                          UINT    uFormat );    // text-drawing flags

BOOL WINAPI ModifyMenuWrapW( HMENU   hMnu,         // handle to menu
                             UINT    uPosition,    // menu item to modify
                             UINT    uFlags,       // menu item flags
                             UINT_PTR    uIDNewItem,   // menu item identifier or handle to drop-down 
                                                   // menu or submenu
                             LPCTSTR lpNewItem );  // menu item content

BOOL WINAPI InsertMenuWrapW( HMENU   hMenu,       // handle to menu
                             UINT    uPosition,   // menu item that new menu item precedes
                             UINT    uFlags,      // menu item flags
                             UINT_PTR    uIDNewItem,  // menu item identifier or handle to drop-down 
                                                  // menu or submenu
                             LPCTSTR lpNewItem ); // menu item content

HANDLE WINAPI LoadImageWrapW( HINSTANCE hinst,      // handle of the instance containing the image
                              LPCTSTR   lpszName,   // name or identifier of image
                              UINT      uType,      // type of image
                              int       cxDesired,  // desired width
                              int       cyDesired,  // desired height
                              UINT      fuLoad );   // load flags

BOOL WINAPI GetClassInfoExWrapW( HINSTANCE    hinst,      // handle of application instance
                                 LPCTSTR      lpszClass,  // address of class name string
                                 LPWNDCLASSEX lpwcx );    // address of structure for class data

int WINAPI LoadStringWrapW( HINSTANCE hInstance,     // handle to module containing string resource
                            UINT      uID,           // resource identifier
                            LPTSTR    lpBuffer,      // pointer to buffer for resource
                            int       nBufferMax  ); // size of buffer

LPTSTR WINAPI CharNextWrapW( LPCTSTR lpsz );  // pointer to current character

LRESULT WINAPI SendMessageWrapW( HWND   hWnd,      // handle of destination window
                                 UINT   Msg,       // message to send
                                 WPARAM wParam,    // first message parameter
                                 LPARAM lParam );  // second message parameter

LRESULT WINAPI DefWindowProcWrapW( HWND   hWnd,      // handle to window
                                   UINT   Msg,       // message identifier
                                   WPARAM wParam,    // first message parameter
                                   LPARAM lParam );  // second message parameter

int WINAPI wsprintfWrapW( LPTSTR lpOut,      // pointer to buffer for output
                          LPCTSTR lpFmt,     // pointer to format-control string
                          ...            );  // optional arguments

int WINAPI wvsprintfWrapW( LPTSTR lpOutput,    // pointer to buffer for output
                           LPCTSTR lpFormat,   // pointer to format-control string
                           va_list arglist );  // variable list of format-control arguments

INT_PTR WINAPI DialogBoxParamWrapW( HINSTANCE hInstance,       // handle to application instance
                                LPCTSTR   lpTemplateName,  // identifies dialog box template
                                HWND      hWndParent,      // handle to owner window
                                DLGPROC   lpDialogFunc,    // pointer to dialog box procedure
                                LPARAM    dwInitParam );   // initialization value

LRESULT WINAPI SendDlgItemMessageWrapW( HWND   hDlg,        // handle of dialog box
                                     int    nIDDlgItem,  // identifier of control
                                     UINT   Msg,         // message to send
                                     WPARAM wParam,      // first message parameter
                                     LPARAM lParam  );   // second message parameter

LONG WINAPI SetWindowLongWrapW( HWND hWnd,         // handle of window
                                int  nIndex,       // offset of value to set
                                LONG dwNewLong );  // new value

LONG WINAPI GetWindowLongWrapW( HWND hWnd,    // handle of window
                                int  nIndex ); // offset of value to retrieve

LONG_PTR WINAPI SetWindowLongPtrWrapW( HWND hWnd,         // handle of window
                                int  nIndex,       // offset of value to set
                                LONG_PTR dwNewLong );  // new value

LONG_PTR WINAPI GetWindowLongPtrWrapW( HWND hWnd,    // handle of window
                                int  nIndex ); // offset of value to retrieve

HWND WINAPI CreateWindowExWrapW( DWORD     dwExStyle,    // extended window style
                                 LPCTSTR   lpClassName,  // pointer to registered class name
                                 LPCTSTR   lpWindowName, // pointer to window name
                                 DWORD     dwStyle,      // window style
                                 int       x,            // horizontal position of window
                                 int       y,            // vertical position of window
                                 int       nWidth,       // window width
                                 int       nHeight,      // window height
                                 HWND      hWndParent,   // handle to parent or owner window
                                 HMENU     hMenu,        // handle to menu, or child-window identifier
                                 HINSTANCE hInstance,    // handle to application instance
                                 LPVOID    lpParam  );   // pointer to window-creation data


BOOL WINAPI UnregisterClassWrapW( LPCTSTR    lpClassName,  // address of class name string
                                  HINSTANCE  hInstance );  // handle of application instance

ATOM WINAPI RegisterClassWrapW(CONST WNDCLASS *lpWndClass );  // address of structure with class date

HCURSOR WINAPI LoadCursorWrapW( HINSTANCE hInstance,      // handle to application instance
                                LPCTSTR   lpCursorName ); // name string or cursor resource identifier

UINT WINAPI RegisterWindowMessageWrapW( LPCTSTR lpString );  // address of message string

BOOL WINAPI SystemParametersInfoWrapW( UINT  uiAction,   // system parameter to query or set
                                       UINT  uiParam,    // depends on action to be taken
                                       PVOID pvParam,    // depends on action to be taken
                                       UINT  fWinIni );  // user profile update flag
/*
// No A & W version.

BOOL WINAPI ShowWindow( HWND hWnd,       // handle to window
                        int nCmdShow );  // show state of window
*/

HWND WINAPI CreateDialogParamWrapW( HINSTANCE hInstance,      // handle to application instance
                                    LPCTSTR   lpTemplateName, // identifies dialog box template
                                    HWND      hWndParent,     // handle to owner window
                                    DLGPROC   lpDialogFunc,   // pointer to dialog box procedure
                                    LPARAM    dwInitParam );  // initialization value

BOOL WINAPI SetWindowTextWrapW( HWND    hWnd,         // handle to window or control
                                LPCTSTR lpString );   // address of string

BOOL WINAPI PostMessageWrapW( HWND   hWnd,      // handle of destination window
                              UINT   Msg,       // message to post
                              WPARAM wParam,    // first message parameter
                              LPARAM lParam  ); // second message parameter

BOOL WINAPI GetMenuItemInfoWrapW( HMENU          hMenu,          
                                  UINT           uItem,           
                                  BOOL           fByPosition,     
                                  LPMENUITEMINFO lpmii        );

BOOL WINAPI GetClassInfoWrapW( HINSTANCE   hInstance,     // handle of application instance
                               LPCTSTR     lpClassName,   // address of class name string
                               LPWNDCLASS  lpWndClass );  // address of structure for class data

LPTSTR WINAPI CharUpperWrapW( LPTSTR lpsz );    // single character or pointer to string

UINT WINAPI RegisterClipboardFormatWrapW( LPCTSTR lpszFormat );  // address of name string

LRESULT WINAPI DispatchMessageWrapW( CONST MSG *lpmsg );  // pointer to structure with message

/* No A & W version
BOOL WINAPI TranslateMessage( IN CONST MSG *lpMsg);
*/

BOOL WINAPI IsDialogMessageWrapW( HWND  hDlg,    // handle of dialog box
                                  LPMSG lpMsg ); // address of structure with message

BOOL WINAPI GetMessageWrapW( LPMSG lpMsg,            // address of structure with message
                             HWND  hWnd,             // handle of window
                             UINT  wMsgFilterMin,    // first message
                             UINT  wMsgFilterMax );  // last message

BOOL WINAPI SetDlgItemTextWrapW( HWND    hDlg,        // handle of dialog box
                                 int     nIDDlgItem,  // identifier of control
                                 LPCTSTR lpString );  // text to set

ATOM WINAPI RegisterClassExWrapW( CONST WNDCLASSEX *lpwcx );  // address of structure with class data

HACCEL WINAPI LoadAcceleratorsWrapW( HINSTANCE hInstance,    // handle to application instance
                                     LPCTSTR lpTableName );  // address of table-name string

HMENU WINAPI LoadMenuWrapW( HINSTANCE hInstance,      // handle to application instance
                            LPCTSTR   lpMenuName );   // menu name string or menu-resource identifier
                        

HICON WINAPI LoadIconWrapW( HINSTANCE hInstance,     // handle to application instance
                           LPCTSTR    lpIconName );  // icon-name string or icon resource identifier
                       

int WINAPI GetWindowTextWrapW( HWND   hWnd,         // handle to window or control with text
                               LPTSTR lpString,     // address of buffer for text
                               int    nMaxCount  ); // maximum number of characters to copy

LRESULT WINAPI CallWindowProcWrapW( WNDPROC lpPrevWndFunc,   // pointer to previous procedure
                                    HWND    hWnd,            // handle to window
                                    UINT    Msg,             // message
                                    WPARAM  wParam,          // first message parameter
                                    LPARAM  lParam  );       // second message parameter

int WINAPI GetClassNameWrapW( HWND   hWnd,           // handle of window
                              LPTSTR lpClassName,    // address of buffer for class name
                              int    nMaxCount );    // size of buffer, in characters

int WINAPI TranslateAcceleratorWrapW( HWND   hWnd,        // handle to destination window
                                      HACCEL hAccTable,   // handle to accelerator table
                                      LPMSG  lpMsg );     // address of structure with message

UINT WINAPI GetDlgItemTextWrapW( HWND   hDlg,        // handle of dialog box
                                 int    nIDDlgItem,  // identifier of control
                                 LPTSTR lpString,    // address of buffer for text
                                 int    nMaxCount ); // maximum size of string

BOOL WINAPI SetMenuItemInfoWrapW( HMENU hMenu,          
                                  UINT  uItem,           
                                  BOOL  fByPosition,     
                                  LPMENUITEMINFO lpmii  );

BOOL WINAPI PeekMessageWrapW( LPMSG lpMsg,          // pointer to structure for message
                              HWND  hWnd,           // handle to window
                              UINT  wMsgFilterMin,  // first message
                              UINT  wMsgFilterMax,  // last message
                              UINT  wRemoveMsg );   // removal flags


// in APIs in ComDlg32.dll


BOOL  WINAPI  pfnGetOpenFileNameWrapW(LPOPENFILENAMEW);
BOOL  WINAPI  pfnGetSaveFileNameWrapW(LPOPENFILENAMEW lpOf);

BOOL    WINAPI   pfnPrintDlgWrapW(LPPRINTDLGW lppd);
HRESULT WINAPI   pfnPrintDlgExWrapW(LPPRINTDLGEXW lppdex);

// run time loaded APIs in Comctl32.dll

INT_PTR     WINAPI gpfnPropertySheetWrapW(LPCPROPSHEETHEADERW lppsh);

HPROPSHEETPAGE WINAPI gpfnCreatePropertySheetPageWrapW(LPCPROPSHEETPAGEW lppsp);

HIMAGELIST WINAPI gpfnImageList_LoadImageWrapW( HINSTANCE hi, LPCWSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags );


DWORD WINAPI CharLowerBuffWrapW( LPWSTR pch, DWORD cchLength );
DWORD WINAPI CharLowerBuffWrapW( LPWSTR pch, DWORD cchLength );
LPWSTR WINAPI CharLowerWrapW( LPWSTR pch );
LPWSTR WINAPI CharUpperWrapW( LPWSTR pch );
BOOL IsCharUpperWrapW(WCHAR wch);
BOOL IsCharLowerWrapW(WCHAR wch);

int WINAPI GetWindowTextLengthWrapW( HWND hWnd);
LRESULT WINAPI ToolTip_UpdateTipText(HWND hWnd,LPARAM lParam);
LRESULT WINAPI ToolTip_AddTool(HWND hWnd,LPARAM lParam);
LRESULT WINAPI ToolBar_AddString(HWND hWnd, LPARAM lParam);
LRESULT WINAPI ToolBar_AddButtons(HWND hWnd, WPARAM wParam, LPARAM lParam);

DWORD GetFileVersionInfoSizeWrapW( LPTSTR lptstrFilename, LPDWORD lpdwHandle );
BOOL GetFileVersionInfoWrapW( LPTSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
BOOL VerQueryValueWrapW( const LPVOID pBlock, LPTSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\certs.c ===
//*******************************************************************
//
//  Copyright(c) Microsoft Corporation, 1996
//
//  FILE: CERT.C
//
//  PURPOSE:  Certificate functions for WAB.
//
//  HISTORY:
//  96/09/23  vikramm Created.
//  96/11/14  markdu  BUG 10132 Updated to post-SDR CAPI.
//  96/11/14  markdu  BUG 10267 Remove static link to functions in advapi32.dll
//  96/11/14  markdu  BUG 10741 Call DeinitCryptoLib in DLL_PROCESS_DETACH
//            only, so don't bother ref counting.
//  96/11/20  markdu  Set a global flag if we fail to load the crypto library.
//            Then, check this flag before we try to load again, and if the flag
//            is set, skip the load.
//            Also, now we only zero the APIFCN arrays if the associated library
//            was just freed.
//  96/12/14  markdu  Clean up for code review.
//  96/12/19  markdu  Post- code review clean up.
//  96/12/20  markdu  Allow BuildCertSBinaryData to do MAPIAllocateMore
//            on a passed-in object instead of LocalAlloc if desired.
//  96/12/20  markdu  Move some strings into resource.
//  96/12/21  markdu  Added support for getting UNICODE strings from certs.
//  97/02/07  t-erikne  Updated to new CAPI functions and fixed bugs.
//  97/02/15  t-erikne  Moved trust from MAPI to PStore
//  97/07/02  t-erikne  Moved trust from PSTore to CTLs
//
//*******************************************************************

#include "_apipch.h"
#define _WIN32_OE 0x0501
#undef CHARFORMAT
#undef GetProp
#undef SetProp
#include <mimeole.h>
#define CHARFORMAT CHARFORMATW
#define GetProp GetPropW
#define SetProp SetPropW

// Global handles for Crypto  DLLs
HINSTANCE       ghCryptoDLLInst = NULL;
HINSTANCE       ghAdvApiDLLInst = NULL;
BOOL            gfPrevCryptoLoadFailed = FALSE;

// Name of cert stores
static const LPTSTR cszWABCertStore       = TEXT("AddressBook");
static const LPTSTR cszCACertStore        = TEXT("CA");
static const LPTSTR cszROOTCertStore      = TEXT("ROOT");

// Crypto function names
static const LPTSTR cszCryptoDLL                          = TEXT("CRYPT32.DLL");
static const LPTSTR cszAdvApiDLL                        = TEXT("ADVAPI32.DLL");
static const char cszCertAddEncodedCertificateToStore[]   =  "CertAddEncodedCertificateToStore";
static const char cszCertCreateCertificateContext[]       =  "CertCreateCertificateContext";
static const char cszCertDeleteCertificateFromStore[]     =  "CertDeleteCertificateFromStore";
static const char cszCertFindCertificateInStore[]         =  "CertFindCertificateInStore";
static const char cszCertFreeCertificateContext[]         =  "CertFreeCertificateContext";
static const char cszCertGetCertificateContextProperty[]  =  "CertGetCertificateContextProperty";
static const char cszCertGetIssuerCertificateFromStore[]  =  "CertGetIssuerCertificateFromStore";
static const char cszCertOpenSystemStore[]                =  "CertOpenSystemStoreW";
static const char cszCryptDecodeObject[]                  =  "CryptDecodeObject";
static const char cszCryptMsgClose[]                      =  "CryptMsgClose";
static const char cszCryptMsgGetParam[]                   =  "CryptMsgGetParam";
static const char cszCryptMsgOpenToDecode[]               =  "CryptMsgOpenToDecode";
static const char cszCryptMsgUpdate[]                     =  "CryptMsgUpdate";
static const char cszCertNameToStr[]                      =  "CertNameToStrW";
static const char cszCertFindRDNAttr[]                    =  "CertFindRDNAttr";
static const char cszCertEnumCertificatesInStore[]        =  "CertEnumCertificatesInStore";
static const char cszCertCompareCertificate[]             =  "CertCompareCertificate";
static const char cszCertRDNValueToStr[]                  =  "CertRDNValueToStrW";
static const char cszCertVerifyTimeValidity[]             =  "CertVerifyTimeValidity";

// Global function pointers for Crypto API
LPCERTADDENCODEDCERTIFICATETOSTORE  gpfnCertAddEncodedCertificateToStore  = NULL;
LPCERTCREATECERTIFICATECONTEXT      gpfnCertCreateCertificateContext      = NULL;
LPCERTDELETECERTIFICATEFROMSTORE    gpfnCertDeleteCertificateFromStore    = NULL;
LPCERTFINDCERTIFICATEINSTORE        gpfnCertFindCertificateInStore        = NULL;
LPCERTFREECERTIFICATECONTEXT        gpfnCertFreeCertificateContext        = NULL;
LPCERTGETCERTIFICATECONTEXTPROPERTY gpfnCertGetCertificateContextProperty = NULL;
LPCERTGETISSUERCERTIFICATEFROMSTORE gpfnCertGetIssuerCertificateFromStore = NULL;
LPCERTOPENSYSTEMSTORE               gpfnCertOpenSystemStore               = NULL;
LPCRYPTDECODEOBJECT                 gpfnCryptDecodeObject                 = NULL;
LPCERTNAMETOSTR                     gpfnCertNameToStr                     = NULL;
LPCRYPTMSGCLOSE                     gpfnCryptMsgClose                     = NULL;
LPCRYPTMSGGETPARAM                  gpfnCryptMsgGetParam                  = NULL;
LPCRYPTMSGOPENTODECODE              gpfnCryptMsgOpenToDecode              = NULL;
LPCRYPTMSGUPDATE                    gpfnCryptMsgUpdate                    = NULL;
LPCERTFINDRDNATTR                   gpfnCertFindRDNAttr                   = NULL;
LPCERTRDNVALUETOSTR                 gpfnCertRDNValueToStr                 = NULL;
LPCERTENUMCERTIFICATESINSTORE       gpfnCertEnumCertificatesInStore       = NULL;
LPCERTCOMPARECERTIFICATE            gpfnCertCompareCertificate            = NULL;
LPCERTVERIFYTIMEVALIDITY            gpfnCertVerifyTimeValidity            = NULL;

// API table for Crypto function addresses in crypt32.dll
// BUGBUG this global array should go away
#define NUM_CRYPT32_CRYPTOAPI_PROCS   19
APIFCN Crypt32CryptoAPIList[NUM_CRYPT32_CRYPTOAPI_PROCS] =
{
  { (PVOID *) &gpfnCertAddEncodedCertificateToStore,  cszCertAddEncodedCertificateToStore   },
  { (PVOID *) &gpfnCertCreateCertificateContext,      cszCertCreateCertificateContext       },
  { (PVOID *) &gpfnCertDeleteCertificateFromStore,    cszCertDeleteCertificateFromStore     },
  { (PVOID *) &gpfnCertFindCertificateInStore,        cszCertFindCertificateInStore         },
  { (PVOID *) &gpfnCertFreeCertificateContext,        cszCertFreeCertificateContext         },
  { (PVOID *) &gpfnCertGetCertificateContextProperty, cszCertGetCertificateContextProperty  },
  { (PVOID *) &gpfnCertGetIssuerCertificateFromStore, cszCertGetIssuerCertificateFromStore  },
  { (PVOID *) &gpfnCertOpenSystemStore,               cszCertOpenSystemStore                },
  { (PVOID *) &gpfnCryptDecodeObject,                 cszCryptDecodeObject                  },
  { (PVOID *) &gpfnCertNameToStr,                     cszCertNameToStr                      },
  { (PVOID *) &gpfnCryptMsgClose,                     cszCryptMsgClose                      },
  { (PVOID *) &gpfnCryptMsgGetParam,                  cszCryptMsgGetParam                   },
  { (PVOID *) &gpfnCryptMsgOpenToDecode,              cszCryptMsgOpenToDecode               },
  { (PVOID *) &gpfnCryptMsgUpdate,                    cszCryptMsgUpdate                     },
  { (PVOID *) &gpfnCertFindRDNAttr,                   cszCertFindRDNAttr                    },
  { (PVOID *) &gpfnCertRDNValueToStr,                 cszCertRDNValueToStr                  },
  { (PVOID *) &gpfnCertEnumCertificatesInStore,       cszCertEnumCertificatesInStore        },
  { (PVOID *) &gpfnCertCompareCertificate,            cszCertCompareCertificate             },
  { (PVOID *) &gpfnCertVerifyTimeValidity,            cszCertVerifyTimeValidity             },
};

// Local function prototypes
HRESULT OpenSysCertStore(
    HCERTSTORE* phcsSysCertStore,
    HCRYPTPROV* phCryptProvider,
    LPTSTR      lpszCertStore);

HRESULT CloseCertStore(
    HCERTSTORE hcsWABCertStore,
    HCRYPTPROV hCryptProvider);

HRESULT FileTimeToDateTimeString(
    IN  LPFILETIME   lpft,
    IN  LPTSTR FAR*  lplpszBuf);

HRESULT GetNameString(
    LPTSTR FAR * lplpszName,
    DWORD dwEncoding,
    PCERT_NAME_BLOB pNameBlob,
    DWORD dwType);

HRESULT GetIssuerName(
    LPTSTR FAR * lplpszIssuerName,
    PCERT_INFO pCertInfo);

HRESULT GetAttributeString(
    LPTSTR FAR * lplpszDisplayName,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    LPSTR lpszObjID);

HRESULT GetCertsDisplayInfoFromContext(
    HWND                hwndParent,
    PCCERT_CONTEXT      pccCertContext,
    LPCERT_DISPLAY_INFO lpCDI);

HRESULT ReadMessageFromFile(
    LPTSTR      lpszFileName,
    HCRYPTPROV  hCryptProvider,
    PBYTE*      ppbEncoded,
    PDWORD      pcbEncoded);

HRESULT WriteDERToFile(
    LPTSTR  lpszFileName,
    PBYTE   pbEncoded,
    DWORD   cbEncoded);

HRESULT GetCertThumbPrint(
    PCCERT_CONTEXT      pccCertContext,
    PCRYPT_DIGEST_BLOB  pblobCertThumbPrint);

HRESULT GetIssuerContextAndStore(
    PCCERT_CONTEXT      pccCertContext,
    PCCERT_CONTEXT*     ppccIssuerCertContext,
    HCRYPTPROV          hCryptProvider,
    HCERTSTORE*         phcsIssuerStore);

HRESULT HrBuildCertSBinaryData(
  BOOL                  bIsDefault,
  BOOL                  fIsThumbprint,
  PCRYPT_DIGEST_BLOB    pPrint,
  BLOB *                pSymCaps,
  FILETIME              ftSigningTime,
  LPVOID                lpObject,
  LPBYTE FAR*           lplpbData,
  ULONG FAR*            lpcbData);

HRESULT IsCertExpired(
    PCERT_INFO            pCertInfo);

HRESULT IsCertRevoked(
    PCERT_INFO            pCertInfo);

HRESULT ReadDataFromFile(
    LPTSTR      lpszFileName,
    PBYTE*      ppbData,
    PDWORD      pcbData);

HRESULT HrGetTrustState(HWND hwndParent, PCCERT_CONTEXT pcCert, DWORD *pdwTrust);

LPTSTR SzConvertRDNString(PCERT_RDN_ATTR pRdnAttr);


/*  HrGetLastError
**
**  Purpose:
**      Convert a GetLastError value to an HRESULT
**      A failure HRESULT must have the high bit set.
**
**  Takes:
**      none
**
**  Returns:
**      HRESULT
*/
HRESULT HrGetLastError(void)
{
    DWORD error;
    HRESULT hr;

    error = GetLastError();

    if (error && ! (error & 0x80000000)) {
        hr = error | 0x80070000;    // system error
    } else {
        hr = (HRESULT)error;
    }

    return(hr);
}

//*******************************************************************
//
//  FUNCTION:   HrUserSMimeToCDI
//
//  PURPOSE:    Convert the data contained in a CMS message for the userSMimeCertificate
//              property and place into the display info structure.
//
//  PARAMETERS: pbIn - data bytes for the CMS message
//              cbIn - size of pbIn
//              lpCDI - structure to receive the cert data.
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  98/10/23  jimsch  Created.
//
//*******************************************************************

HRESULT HrUserSMimeToCDI(LPBYTE pbIn, DWORD cbIn, LPCERT_DISPLAY_INFO lpCDI)
{
    DWORD                       cb;
    DWORD                       cbCert;
    DWORD                       cbMax;
    DWORD                       cbSMimeCaps;
    DWORD                       cCerts;
    CERT_INFO                   certInfo;
    DWORD                       cSigners;
    DWORD                       cval;
    DWORD                       dwDefaults;
    DWORD                       dwNortelAlg;
    BOOL                        f;
    BOOL                        fSMime = TRUE;
    HCRYPTMSG                   hmsg;
    HRESULT                     hr = S_OK;
    ULONG                       i;
    DWORD                       ival;
    PCRYPT_ATTRIBUTE            pattr;
    LPBYTE                      pbCert;
    LPBYTE                      pbData;
    LPBYTE                      pbSMimeCaps;
    PCCERT_CONTEXT              pccert;
    PCMSG_SIGNER_INFO           pinfo;
    PCRYPT_RECIPIENT_ID         prid = NULL;

    // Parse out and verify the signature on the message.  If that operation fails, then
    //  this is a bad record

    hmsg = CryptMsgOpenToDecode(PKCS_7_ASN_ENCODING, 0, 0, 0,
                                NULL, NULL);
    if (hmsg == 0) {
      return E_FAIL; // HrCryptError();
    }

    if (!CryptMsgUpdate(hmsg, pbIn, cbIn, TRUE)) {
        return E_FAIL; //HrCryptError();
    }

    cb = sizeof(cSigners);
    if (!CryptMsgGetParam(hmsg, CMSG_SIGNER_COUNT_PARAM, 0, &cSigners, &cb) ||
        (cSigners == 0)) {
        return E_FAIL; //HrCryptError();
    }
    Assert(cSigners == 1);

    if (!CryptMsgGetParam(hmsg, CMSG_SIGNER_INFO_PARAM, 0, NULL, &cb)) {
        goto CryptError;
    }

    pinfo = (PCMSG_SIGNER_INFO) LocalAlloc(0, cb);
    f = CryptMsgGetParam(hmsg, CMSG_SIGNER_INFO_PARAM, 0, pinfo, &cb);
    Assert(f);

    // M00BUG -- verify signature on message

    for (i=0; i<pinfo->AuthAttrs.cAttr; i++) {
      pattr = &pinfo->AuthAttrs.rgAttr[i];
        if (strcmp(pattr->pszObjId, szOID_RSA_SMIMECapabilities) == 0) {
          Assert(pattr->cValue == 1);
          lpCDI->blobSymCaps.pBlobData = LocalAlloc(LMEM_ZEROINIT,
            pattr->rgValue[0].cbData);
          if (NULL == lpCDI->blobSymCaps.pBlobData)
            return E_OUTOFMEMORY;
          lpCDI->blobSymCaps.cbSize = pattr->rgValue[0].cbData;
          memcpy(lpCDI->blobSymCaps.pBlobData, pattr->rgValue[0].pbData,
            pattr->rgValue[0].cbData);
        }
//        else if (strcmp(pattr->pszObjId, szOID_Microsoft_Encryption_Cert) == 0) {
//          Assert(pattr->cValue == 1);
//          Assert(pattr->rgValue[0].cbData == 3);
//          lpCDI->bIsDefault = pattr->rgValue[0].pbData[2];
//        }
        else if (strcmp(pattr->pszObjId, szOID_Microsoft_Encryption_Cert) == 0) {
            Assert(pattr->cValue == 1);
            f = CryptDecodeObjectEx(X509_ASN_ENCODING,
              szOID_Microsoft_Encryption_Cert,
              pattr->rgValue[0].pbData,
              pattr->rgValue[0].cbData, CRYPT_DECODE_ALLOC_FLAG, 0,
              (LPVOID *) &prid, &cb);
            Assert(f);
        }
    }

    //

    if (prid == NULL)
        goto Exit;
    certInfo.SerialNumber = prid->SerialNumber;
    certInfo.Issuer = prid->Issuer;

    //  Enumerate all certs and pack into the structure

    cbCert = sizeof(cCerts);
    if (!CryptMsgGetParam(hmsg, CMSG_CERT_COUNT_PARAM, 0, &cCerts, &cbCert)) {
        goto CryptError;
    }

    for (i=0, cbMax = 0; i<cCerts; i++)
    {
      if (!CryptMsgGetParam(hmsg, CMSG_CERT_PARAM, i, NULL, &cbCert))
        goto CryptError;

      if (cbMax < cbCert)
        cbMax = cbCert;
    }


    pbCert = (LPBYTE) LocalAlloc(0, cbCert);
    for (i=0; i<cCerts; i++) {
        cbCert = cbMax;
        if (!CryptMsgGetParam(hmsg, CMSG_CERT_PARAM, i, pbCert, &cbCert))
            goto CryptError;

        pccert = gpfnCertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCert);
        if (pccert == NULL)
            continue;

        if (CertCompareCertificate(X509_ASN_ENCODING, pccert->pCertInfo,
                                   &certInfo)) {
            lpCDI->pccert = CertDuplicateCertificateContext(pccert);
        }
    }


    hr = S_OK;

Exit:
    if (prid != NULL) LocalFree(prid);
    if (pinfo != NULL)  LocalFree(pinfo);
    if (hmsg != NULL)   CryptMsgClose(hmsg);
    return hr;

CryptError:
    hr = E_FAIL;
    goto Exit;
}

//*******************************************************************
//
//  FUNCTION:   HrGetCertsDisplayInfo
//
//  PURPOSE:    Takes an input array of certs in a SPropValue structure
//              and outputs a list of cert data structures by parsing through
//              the array and looking up the cert data in the store.
//
//  PARAMETERS: lpPropValue - PR_USER_X509_CERTIFICATE property array
//              lppCDI - recieves an allocated structure  containing
//              the cert data.  Must be freed by calling FreeCertdisplayinfo.
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//
//*******************************************************************

HRESULT HrGetCertsDisplayInfo(
  IN  HWND hwndParent,
  IN  LPSPropValue lpPropValue,
  OUT LPCERT_DISPLAY_INFO * lppCDI)
{
  CRYPT_HASH_BLOB     blob;
  HRESULT             hr = hrSuccess;
  HRESULT             hrOut = hrSuccess;
  ULONG               i;
  ULONG               ulcCerts;
  LPCERTTAGS          lpCurrentTag;
  LPCERT_DISPLAY_INFO lpHead=NULL;
  LPCERT_DISPLAY_INFO lpTemp=NULL;
  HCERTSTORE          hcsWABCertStore = NULL;
  HCRYPTPROV          hCryptProvider = 0;
  LPBYTE              lpbTagEnd;

#ifdef  PARAMETER_VALIDATION
  if (IsBadReadPtr(lpPropValue, sizeof(SPropValue)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
  if (IsBadWritePtr(lppCDI, sizeof(LPCERT_DISPLAY_INFO)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
#endif  // PARAMETER_VALIDATION

  // Make sure we have the right kind of proparray.
  if ((NULL == lpPropValue) || (PR_USER_X509_CERTIFICATE != lpPropValue->ulPropTag))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }

  // See if we really have any certs
  ulcCerts = lpPropValue->Value.MVbin.cValues;
  if (0 == ulcCerts)
  {
    goto out;
  }

  // Load the crypto functions
  if (FALSE == InitCryptoLib())
  {
    hr = ResultFromScode(MAPI_E_UNCONFIGURED);
    return hr;
  }

  // Open the store since we need to lookup certs
  hr = OpenSysCertStore(&hcsWABCertStore, &hCryptProvider, cszWABCertStore);
  if (hrSuccess != hr)
  {
    goto out;
  }

  // Create a structure for each certificate in the array.
  for (i=0;i<ulcCerts;i++)
  {
    // Allocate memory for the structure, and initialize pointers
    LPCERT_DISPLAY_INFO lpCDI = LocalAlloc(LMEM_ZEROINIT, sizeof(CERT_DISPLAY_INFO));
    if (NULL == lpCDI)
    {
      hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
      goto out;
    }

    if(NULL == lpHead)
    {
      lpHead = lpCDI;
    }

    lpCDI->lpPrev = lpTemp;
    lpCDI->lpNext = NULL;
    if(NULL != lpTemp)
    {
      lpTemp->lpNext = lpCDI;
    }
    lpTemp = lpCDI;

    if (CERT_TAG_SMIMECERT == lpPropValue->Value.MVbin.lpbin[i].lpb[0]) {
        hr = HrUserSMimeToCDI(lpPropValue->Value.MVbin.lpbin[i].lpb,
                              lpPropValue->Value.MVbin.lpbin[i].cb,
                              lpCDI);
        if (FAILED(hr))
            goto out;
    }
    else
    {
    // Loop through the tags for this certificate and extract the data we want
    lpCurrentTag = (LPCERTTAGS)lpPropValue->Value.MVbin.lpbin[i].lpb;
    lpbTagEnd = (LPBYTE)lpCurrentTag + lpPropValue->Value.MVbin.lpbin[i].cb;
    while ((LPBYTE)lpCurrentTag < lpbTagEnd)
    {
      LPCERTTAGS lpTempTag = lpCurrentTag;

      // Check if this is the tag that indicates whether this is the default cert
      if (CERT_TAG_DEFAULT == lpCurrentTag->tag)
      {
        memcpy((void*)&lpCDI->bIsDefault,
          &lpCurrentTag->rgbData,
          sizeof(lpCDI->bIsDefault));
      }

      // Check if this is just the raw cert itself
      else if (CERT_TAG_BINCERT == lpCurrentTag->tag)
      {
        AssertSz(lpCDI->pccert == NULL, TEXT("Two certs in a single record"));
        lpCDI->pccert = gpfnCertCreateCertificateContext(
          X509_ASN_ENCODING,
          lpCurrentTag->rgbData,
          lpCurrentTag->cbData);
      }

      // Check if this is the tag that contains the thumbprint
      else if (CERT_TAG_THUMBPRINT == lpCurrentTag->tag)
      {
        AssertSz(lpCDI->pccert == NULL, TEXT("Two certs in a single record"));
        blob.cbData = lpCurrentTag->cbData - sizeof(DWORD);
        blob.pbData = lpCurrentTag->rgbData;

        // Get the certificate from the WAB store using the thumbprint
        lpCDI->pccert = CertFindCertificateInStore(
          hcsWABCertStore,
          X509_ASN_ENCODING,
          0,
          CERT_FIND_HASH,
          (void *)&blob,
          NULL);
      }

      // Check if this is the tag that contains the symcaps
      else if (CERT_TAG_SYMCAPS == lpCurrentTag->tag)
      {
        lpCDI->blobSymCaps.pBlobData = LocalAlloc(LMEM_ZEROINIT,
          lpCurrentTag->cbData - SIZE_CERTTAGS);
        if (NULL == lpCDI->blobSymCaps.pBlobData)
        {
          hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
          goto out;
        }

        lpCDI->blobSymCaps.cbSize = lpCurrentTag->cbData - SIZE_CERTTAGS;
        memcpy(lpCDI->blobSymCaps.pBlobData,
          &lpCurrentTag->rgbData,
          lpCurrentTag->cbData - SIZE_CERTTAGS);
      }

      // Check if this is the tag that contains the signing time
      else if (CERT_TAG_SIGNING_TIME == lpCurrentTag->tag)
      {
        memcpy(&lpCDI->ftSigningTime,
          &lpCurrentTag->rgbData,
          min(lpCurrentTag->cbData - SIZE_CERTTAGS, sizeof(FILETIME)));
      }

      lpCurrentTag = (LPCERTTAGS)((BYTE*)lpCurrentTag + LcbAlignLcb(lpCurrentTag->cbData));
      if (lpCurrentTag == lpTempTag) {
          AssertSz(FALSE, TEXT("Bad CertTag in PR_USER_X509_CERTIFICATE\n"));
          break;        // Safety valve, prevent infinite loop if bad data
      }
    }
    }

    // If we can't get the cert, delete this node of the linked list.
    if (NULL == lpCDI->pccert)
    {
      if(lpHead == lpCDI)
      {
        lpHead = NULL;
      }

      lpTemp = lpCDI->lpPrev;
      if (NULL != lpTemp)
      {
        lpTemp->lpNext = NULL;
      }

      FreeCertdisplayinfo(lpCDI);
    }
    else
    {
      // Get the context-specific display info from the cert.
      hr = GetCertsDisplayInfoFromContext(hwndParent, lpCDI->pccert, lpCDI);
      if (hrSuccess != hr)
      {
        goto out;
      }
    }
  }

out:
  // Close the cert store.
  hrOut = CloseCertStore(hcsWABCertStore, hCryptProvider);

  // If an error occurred in the function body, return that instead of
  // any errors that occurred here in cleanup.
  if (hrSuccess == hr)
  {
    hr = hrOut;
  }

  if ((hrSuccess == hr) && (NULL != lppCDI))
  {
    *lppCDI = lpHead;
  }
  else
  {
    // Free the list of structures we allocated.
    while (NULL != lpHead)
    {
      lpTemp = lpHead->lpNext;
      FreeCertdisplayinfo(lpHead);
      lpHead = lpTemp;
    }
  }

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   HrSetCertsFromDisplayInfo
//
//  PURPOSE:    Takes a linked list of cert data structures and outputs
//              an SPropValue array of PR_USER_X509_CERTIFICATE properties.
//
//  PARAMETERS: lpCDI - linked list of input structures to convert to
//              SPropValue array
//              lpulcPropCount - receives the number of SPropValue's returned
//              Note that this will always be one.
//              lppPropValue - receives a MAPI-allocated SPropValue structure
//              containing an X509_USER_CERTIFICATE property
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//
//*******************************************************************

HRESULT HrSetCertsFromDisplayInfo(
  IN  LPCERT_ITEM lpCItem,
  OUT ULONG * lpulcPropCount,
  OUT LPSPropValue * lppPropValue)
{
  CRYPT_DIGEST_BLOB   blob;
  HRESULT             hr = hrSuccess;
  HCERTSTORE          hcertstore = NULL;
  LPCERT_ITEM         lpTemp;
  LPSPropValue        lpPropValue = NULL;
  ULONG               ulcCerts = 0;
  ULONG               ulCert = 0;
  ULONG               cbData = 0;
  LPBYTE              lpbData;
  SCODE               sc;

#ifdef  PARAMETER_VALIDATION
  if (IsBadReadPtr(lpCItem, sizeof(CERT_ITEM)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
  if (IsBadWritePtr(lpulcPropCount, sizeof(ULONG)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
  if (IsBadWritePtr(lppPropValue, sizeof(LPSPropValue)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
#endif  // PARAMETER_VALIDATION

  // Find out how many certs there are in the list
  lpTemp = lpCItem;
  while (NULL != lpTemp)
  {
    ulcCerts++;
    lpTemp = lpTemp->lpNext;
  }
  Assert(ulcCerts);

  // Allocate a new buffer for the MAPI property structure
  sc = MAPIAllocateBuffer(sizeof(SPropValue),
    (LPVOID *)&lpPropValue);
  if (sc)
  {
    hr = ResultFromScode(sc);
    goto out;
  }
  lpPropValue->ulPropTag = PR_USER_X509_CERTIFICATE;
  lpPropValue->dwAlignPad = 0;

  // Allocate more space for the SBinaryArray.  We need SBinary's for
  // each of the certs
  lpPropValue->Value.MVbin.cValues = ulcCerts;
  sc = MAPIAllocateMore(ulcCerts * sizeof(SBinary), lpPropValue,
    (LPVOID *)&(lpPropValue->Value.MVbin.lpbin));
  if (sc)
  {
    hr = ResultFromScode(sc);
    goto out;
  }

  hr = OpenSysCertStore(&hcertstore, NULL, cszWABCertStore);
  if (hrSuccess != hr)
    goto out;

  // Create the SPropValue entries by walking the list
  while (NULL != lpCItem)
  {
    hr = GetCertThumbPrint(lpCItem->lpCDI->pccert, &blob);
    if (hr != hrSuccess)
      goto out;

    if (!CertAddCertificateContextToStore(hcertstore, lpCItem->lpCDI->pccert,
                                          CERT_STORE_ADD_USE_EXISTING, NULL))
    {
        hr = E_FAIL;
        goto out;
    }

    // Pack up all the cert data and stuff it in the property
    hr = HrBuildCertSBinaryData(
      lpCItem->lpCDI->bIsDefault,
      TRUE,
      (PCRYPT_DIGEST_BLOB ) &blob,
      (BLOB * ) &(lpCItem->lpCDI->blobSymCaps),
      lpCItem->lpCDI->ftSigningTime,
      lpPropValue,
      (LPBYTE FAR*) &(lpPropValue->Value.MVbin.lpbin[ulCert].lpb),
      (ULONG FAR* ) &(lpPropValue->Value.MVbin.lpbin[ulCert].cb));

    LocalFree(blob.pbData);
    if (hrSuccess != hr)
    {
      goto out;
    }

    // Next certificate
    ulCert++;
    lpCItem = lpCItem->lpNext;
  }

out:
  if (hcertstore != NULL)       
    CloseCertStore(hcertstore, 0);
  if ((hrSuccess == hr) && (NULL != lppPropValue) && (NULL != lpulcPropCount))
  {
    *lppPropValue = lpPropValue;
    *lpulcPropCount = 1;
  }
  else
  {
    // Free the list of structures we allocated.
    MAPIFreeBuffer(lpPropValue);
  }

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   HrImportCertFromFile
//
//  PURPOSE:    Import a cert from a file.
//
//  PARAMETERS: lpszFileName - name of file containing the cert.
//              lppCDI - recieves an allocated structure  containing
//              the cert data.  Must be freed by calling FreeCertdisplayinfo.
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//
//*******************************************************************

HRESULT HrImportCertFromFile(
  IN  LPTSTR  lpszFileName,
  OUT LPCERT_DISPLAY_INFO * lppCDI)
{
  HRESULT             hr = hrSuccess;
  HRESULT             hrOut = hrSuccess;
  HCERTSTORE          hcsWABCertStore = NULL;
  HCRYPTPROV          hCryptProvider = 0;
  PCCERT_CONTEXT      pccCertContext = NULL;
  LPCERT_DISPLAY_INFO lpCDI=NULL;
  BYTE*               pbEncoded = NULL;
  DWORD               cbEncoded = 0;
  BOOL                fRet;

#ifdef  PARAMETER_VALIDATION
  if (IsBadReadPtr(lpszFileName, sizeof(TCHAR)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
  if (IsBadWritePtr(lppCDI, sizeof(CERT_DISPLAY_INFO)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
#endif  // PARAMETER_VALIDATION

  // Load the crypto functions
  if (FALSE == InitCryptoLib())
  {
    hr = ResultFromScode(MAPI_E_UNCONFIGURED);
    return hr;
  }

  // Open the store
  hr = OpenSysCertStore(&hcsWABCertStore, &hCryptProvider, cszWABCertStore);
  if (hrSuccess != hr)
  {
    DebugTrace(TEXT("OpenSysCertStore -> 0x%08x\n"), GetScode(hr));
    goto out;
  }

  // Import the cert into a CERT_CONTEXT structure
#ifndef WIN16
  hr = ReadMessageFromFile(
    lpszFileName,
    hCryptProvider,
    &pbEncoded,
    &cbEncoded);
#else  // !WIN16
  hr = ReadMessageFromFile(
    lpszFileName,
    hCryptProvider,
    (PBYTE *)&pbEncoded,
    (PDWORD)&cbEncoded);
#endif // !WIN16
  if (hrSuccess != hr)
  {
    // Try reading it as just a DER encoded blob
#ifndef WIN16
    hr = ReadDataFromFile(
      lpszFileName,
      &pbEncoded,
      &cbEncoded);
#else  // !WIN16
    hr = ReadDataFromFile(
      lpszFileName,
      (PBYTE *)&pbEncoded,
      (PDWORD)&cbEncoded);
#endif // !WIN16
    if (hrSuccess != hr)
    {
      goto out;
    }
  }

  // Add the cert to the store
  fRet = gpfnCertAddEncodedCertificateToStore(
    hcsWABCertStore,
    X509_ASN_ENCODING,
    pbEncoded,
    cbEncoded,
    CERT_STORE_ADD_USE_EXISTING,
    &pccCertContext);
  if (FALSE == fRet)
  {
    hr = HrGetLastError();
    DebugTrace(TEXT("CertAddEncodedCertificateToStore -> 0x%08x\n"), GetScode(hr));
    goto out;
  }

  // Allocate memory for the structure, and initialize pointers
  // Since we read only one cert, there are no more entries in the linked list
  lpCDI = LocalAlloc(LMEM_ZEROINIT, sizeof(CERT_DISPLAY_INFO));
  if (NULL == lpCDI)
  {
    hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
    goto out;
  }
  lpCDI->lpNext = NULL;
  lpCDI->lpPrev = NULL;

  // Fill in the defaults for info we don't know
  lpCDI->bIsDefault = FALSE;

  // Get the certificate
  lpCDI->pccert = CertDuplicateCertificateContext(pccCertContext);

  // Get the context-specific display info from the cert.
  hr = GetCertsDisplayInfoFromContext(GetDesktopWindow(), pccCertContext, lpCDI);
  if (hrSuccess != hr)
  {
    DebugTrace(TEXT("GetCertsDisplayInfoFromContext -> 0x%08x\n"), GetScode(hr));
    goto out;
  }

out:
  // Free the cert context.  Ignore errors since there is nothing we can do.
  if (NULL != pccCertContext)
  {
    gpfnCertFreeCertificateContext(pccCertContext);
  }

  // Close the cert store if we were able to free the cert context.
  if (hrSuccess == hrOut)
  {
    hrOut = CloseCertStore(hcsWABCertStore, hCryptProvider);
  }

  // If an error occurred in the function body, return that instead of
  // any errors that occurred here in cleanup.
  if (hrSuccess == hr)
  {
    hr = hrOut;
  }

  if ((hrSuccess == hr) && (NULL != lppCDI))
  {
    *lppCDI = lpCDI;
  }
  else
  {
    LocalFreeAndNull(&lpCDI);
  }

  LocalFreeAndNull(&pbEncoded);

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   HrExportCertToFile
//
//  PURPOSE:    Export a cert to a file.
//
//  PARAMETERS: lpszFileName - name of file in which to store the cert.
//              If the file exists, it will be overwritten, so the caller
//              must verify that this is OK first if so desired.
//              pblobCertThumbPrint - thumb print of certificate to export.
//              lpCertDataBuffer - needs to be freed by caller, data is 
//              filled here when flag is true.
//              lpcbBufLen - how long the buffer is
//              fWriteDataToBuffer - flag indicating where to write data
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//  98/07/22  t-jstaj updated to take 3 add'l parameters, a data buffer, its length 
//                    and flag which will indicate whether or not to 
//                    write data to buffer or file.  The memory allocated to 
//                    to the buffer needs to be freed by caller.
//
//
//*******************************************************************

HRESULT HrExportCertToFile(
  IN  LPTSTR  lpszFileName,
  IN  PCCERT_CONTEXT pccert,
  OUT LPBYTE *lppCertDataBuffer,
  OUT PULONG  lpcbBufLen,
  IN  BOOL    fWriteDataToBuffer)
{
  HRESULT             hr = hrSuccess;
  HRESULT             hrOut = hrSuccess;

#ifdef  PARAMETER_VALIDATION
  if( !fWriteDataToBuffer )
  {  
      if (IsBadReadPtr(lpszFileName, sizeof(TCHAR)))
      {
          return ResultFromScode(MAPI_E_INVALID_PARAMETER);
      }
  }
  if (IsBadReadPtr(pccert, sizeof(*pccert)))
  {
      return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
#endif  // PARAMETER_VALIDATION

  // Load the crypto functions
  if (FALSE == InitCryptoLib())
  {
    hr = ResultFromScode(MAPI_E_UNCONFIGURED);
    return hr;
  }

  // Export the cert to the file
  if( !fWriteDataToBuffer )
  {
      hr = WriteDERToFile(
          lpszFileName,
          (PBYTE)pccert->pbCertEncoded,
          pccert->cbCertEncoded);
      if (hrSuccess != hr)
      {
          goto out;
      }
  }
// write cert to buffer
  else
  {
      *lppCertDataBuffer = LocalAlloc( LMEM_ZEROINIT, /*sizeof( BYTE ) **/ pccert->cbCertEncoded);
      if( *lppCertDataBuffer )
        CopyMemory( *lppCertDataBuffer, pccert->pbCertEncoded, pccert->cbCertEncoded);
      else
      {
          hr = MAPI_E_NOT_ENOUGH_MEMORY;
          goto out;
      }
      *lpcbBufLen = pccert->cbCertEncoded;
  }
out:
  // If an error occurred in the function body, return that instead of
  // any errors that occurred here in cleanup.
  if (hrSuccess == hr)
  {
    hr = hrOut;
  }

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   FreeCertdisplayinfo
//
//  PURPOSE:    Release memory allocated for a CERT_DISPLAY_INFO structure.
//              Assumes all info in the structure was LocalAlloced
//
//  PARAMETERS: lpCDI - structure to free.
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//
//*******************************************************************

void FreeCertdisplayinfo(LPCERT_DISPLAY_INFO lpCDI)
{
    if (lpCDI)
    {
        if (lpCDI->lpszDisplayString != lpCDI->lpszEmailAddress)
        {
            LocalFreeAndNull(&lpCDI->lpszDisplayString);
        }
        if (lpCDI->pccert != NULL)
        {
          CertFreeCertificateContext(lpCDI->pccert);
          lpCDI->pccert = NULL;
        }
        LocalFreeAndNull(&lpCDI->lpszEmailAddress);
        LocalFreeAndNull(&lpCDI->blobSymCaps.pBlobData);
        LocalFreeAndNull(&lpCDI);
    }
}


//*******************************************************************
//
//  FUNCTION:   InitCryptoLib
//
//  PURPOSE:    Load the Crypto API libray and get the proc addrs.
//
//  PARAMETERS: None.
//
//  RETURNS:    TRUE if successful, FALSE otherwise.
//
//  HISTORY:
//  96/10/01  markdu  Created.
//  96/11/19  markdu  No longer keep a ref count, just use the global
//            library handles.
//
//*******************************************************************

BOOL InitCryptoLib(void)
{

#ifndef WIN16 // Disable until we get crypt16.dll
  // See if we already tried to load and failed.
  if (TRUE == gfPrevCryptoLoadFailed)
  {
    return FALSE;
  }

  // See if we already initialized.
  if ((NULL == ghCryptoDLLInst) && (NULL == ghAdvApiDLLInst))
  {
    // open Crypto API library
    ghCryptoDLLInst = LoadLibrary(cszCryptoDLL);
    if (!ghCryptoDLLInst)
    {
      DebugTrace(TEXT("InitCryptoLib: Failed to LoadLibrary CRYPT32.DLL.\n"));
      goto error;
    }

    // cycle through the API table and get proc addresses for all the APIs we
    // need
    if (!GetApiProcAddresses(ghCryptoDLLInst,Crypt32CryptoAPIList,NUM_CRYPT32_CRYPTOAPI_PROCS))
    {
      DebugTrace(TEXT("InitCryptoLib: Failed to load Crypto API from CRYPT32.DLL.\n"));
      goto error;
    }

    // open AdvApi32 library
    ghAdvApiDLLInst = LoadLibrary(cszAdvApiDLL);
    if (!ghAdvApiDLLInst)
    {
      DebugTrace(TEXT("InitCryptoLib: Failed to LoadLibrary ADVAPI32.DLL.\n"));
      goto error;
    }
  }

  // Make sure both libraries are loaded
  if ((NULL != ghCryptoDLLInst) && (NULL != ghAdvApiDLLInst))
  {
    return TRUE;
  }


error:
  // Unload the libraries we just loaded and indicate that we should not try to
  // load again this session.
  gfPrevCryptoLoadFailed = TRUE;
  DeinitCryptoLib();
#endif // !WIN16

  return FALSE;
}


//*******************************************************************
//
//  FUNCTION:   DeinitCryptoLib
//
//  PURPOSE:    Release the Crypto API libraries.
//
//  PARAMETERS: None.
//
//  RETURNS:    None.
//
//  HISTORY:
//  96/10/01  markdu  Created.
//  96/11/19  markdu  No longer keep a ref count, just call this in
//            DLL_PROCESS_DETACH.
//
//*******************************************************************

void DeinitCryptoLib(void)
{
  UINT nIndex;

  // No clients using the Crypto API library.  Release it.
  if (ghCryptoDLLInst)
  {
    FreeLibrary(ghCryptoDLLInst);
    ghCryptoDLLInst = NULL;

    // cycle through the API table and NULL proc addresses for all the APIs
    for (nIndex = 0; nIndex < NUM_CRYPT32_CRYPTOAPI_PROCS; nIndex++)
    {
      *Crypt32CryptoAPIList[nIndex].ppFcnPtr = NULL;
    }
  }

  // Now releaes the crypto functions in advapi32.dll
  if (ghAdvApiDLLInst)
  {
    FreeLibrary(ghAdvApiDLLInst);
    ghAdvApiDLLInst = NULL;
  }

  return;
}


//*******************************************************************
//
//  FUNCTION:   FileTimeToDateTimeString
//
//  PURPOSE:    Convert a filetime structure to displayable text.
//
//  PARAMETERS: lpft - FILETIME to convert to a string
//              lplpszBuf - receives buffer to hold the string
//
//  RETURNS:    HRESULT
//
//  HISTORY:
//  96/10/02  markdu  Copied from shdocvw code
//  96/12/16  markdu  Made more robust, and LocalAlloc the buffer here
//
//*******************************************************************

HRESULT FileTimeToDateTimeString(
  IN  LPFILETIME   lpft,
  IN  LPTSTR FAR*  lplpszBuf)
{
  HRESULT hr = hrSuccess;
  SYSTEMTIME st;
  LPTSTR     szBuf;
  int cbBuf = 0;
  int cb = 0;

  FileTimeToLocalFileTime(lpft, lpft);
  FileTimeToSystemTime(lpft, &st);

  // Figure out how much space we need, then allocate 2 times that just
  // in case it's DBCS.
  cbBuf += GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, NULL, 0);
  cbBuf += GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st, NULL, NULL, 0);
  cbBuf *= 2;

  szBuf = LocalAlloc(LMEM_ZEROINIT, cbBuf);
  if (NULL == szBuf)
  {
    hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
    goto out;
  }
  *lplpszBuf = szBuf;

  // First fill in the date portion.
  GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, szBuf, cbBuf);
  cb = lstrlen(szBuf);
  szBuf += cb;
  cbBuf -= cb;

  // Separate the time and date with a space. and null terminate this
  // (in case GetTimeFormat doesn't add anything).
  *szBuf = TEXT(' ');
  szBuf = CharNext(szBuf);
  *szBuf = TEXT('\0');
  cbBuf-=2;

  GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st, NULL, szBuf, cbBuf);

out:
  return hr;
}


//*******************************************************************
//
//  FUNCTION:   OpenSysCertStore
//
//  PURPOSE:    Open the specified system cert store.
//
//  PARAMETERS: phcsSysCertStore - receives handle to the cert store
//              phCryptProvider - If this points to a valid handle,
//              this handle is used as the provider to open the store.
//              otherwise, it receives a handle to the store provider
//              lpszCertStore - name of the store to open
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/10/03  markdu  Created.
//
//*******************************************************************

HRESULT OpenSysCertStore(
  HCERTSTORE* phcsSysCertStore,
  HCRYPTPROV* phCryptProvider,
  LPTSTR      lpszCertStore)
{
  HRESULT hr = hrSuccess;
  BOOL    fRet;
  BOOL    fWeAcquiredContext = FALSE;

  if (phCryptProvider != NULL)
  {
    // Get a handle to the crypto provider if we need one
    if (0 == *phCryptProvider)
    {
      fRet = CryptAcquireContextWrapW(
        phCryptProvider,
        NULL,
        NULL,
        PROV_RSA_FULL,
        CRYPT_VERIFYCONTEXT);
      if (FALSE == fRet)
      {
        hr = HrGetLastError();
        goto out;
      }
      fWeAcquiredContext = TRUE;
    }
  }

  // Open the store
  *phcsSysCertStore = gpfnCertOpenSystemStore(
    ((phCryptProvider == NULL) ? (HCRYPTPROV) NULL : (*phCryptProvider)),
    lpszCertStore);
  if (NULL == *phcsSysCertStore)
  {
    hr = HrGetLastError();

    // Release the crypto provider if we were unable to open the store.
    if (TRUE == fWeAcquiredContext)
    {
      CryptReleaseContext(*phCryptProvider, 0);
      *phCryptProvider = 0;
    }

    goto out;
  }

out:
  return hr;
}


//*******************************************************************
//
//  FUNCTION:   CloseCertStore
//
//  PURPOSE:    Close the specified cert store.
//
//  PARAMETERS: hcsCertStore - handle to the cert store
//              hCryptProvider - handle to the store provider.  The
//              provider will be closed as well, unless 0 is passed.
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/10/03  markdu  Created.
//
//*******************************************************************

HRESULT CloseCertStore(
  HCERTSTORE hcsCertStore,
  HCRYPTPROV hCryptProvider)
{
  HRESULT hr = hrSuccess;
  BOOL    fRet;

  if (NULL != hcsCertStore)
  {
    fRet = CertCloseStore(hcsCertStore, 0);
    if (FALSE == fRet)
    {
      hr = HrGetLastError();
    }
  }

  // Release the crypto provider if we were able to close the store.
  if ((0 != hCryptProvider) && (hrSuccess == hr))
  {
    fRet = CryptReleaseContext(hCryptProvider, 0);
    if (FALSE == fRet)
    {
      hr = HrGetLastError();
    }
  }

  return hr;
}

//*******************************************************************
//
//  FUNCTION:   GetNameString
//
//  PURPOSE:    Get the string associated with the given attribute
//
//  PARAMETERS: lplpszName - pointer that will be
//                  allocated to hold the string
//              dwEncoding - certificate's encoding
//              pNameBlob - the encoded blob
//              dwType    - type of string, e.g. CERT_SIMPLE_NAME_STR
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  97/02/03  t-erikne  Copied and revamped from GetAttributeString
//  96/10/03  markdu    Created.
//
//*******************************************************************
HRESULT GetNameString(
  LPTSTR FAR * lplpszName,
  DWORD dwEncoding,
  PCERT_NAME_BLOB pNameBlob,
  DWORD dwType)
{
  DWORD     cch;
  HRESULT   hr = hrSuccess;

  Assert(lplpszName && pNameBlob);

  // Initialize so we know if any data was copied in.
  *lplpszName = NULL;

  cch = gpfnCertNameToStr(
    dwEncoding,                 // indicates X509 encoding
    pNameBlob,                  // name_blob to decode
    dwType,                     // style for output
    NULL,                       // NULL used when just getting length
    0);                         // length of buffer

  *lplpszName = (LPTSTR) LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cch);
  if (NULL == lplpszName)
  {
    hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
    goto out;
  }

  gpfnCertNameToStr(dwEncoding, pNameBlob,
      dwType, *lplpszName, cch);

out:
  return hr;
}

//*******************************************************************
//
//  FUNCTION:   GetAttributeString
//
//  PURPOSE:    Get the string associated with the given attribute
//              by parsing through the relative
//              distinguished names in the object.
//
//  PARAMETERS: lplpszAttributeString - pointer that will be allocated to
//                hold the string
//              pbEncoded - the encoded blob
//              cbEncoded - size of the encoded blob
//              lpszObjID - object ID of attribute to retrieve
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/10/03  markdu  Created.
//
//*******************************************************************

HRESULT GetAttributeString(
  LPTSTR FAR * lplpszAttributeString,
  BYTE *pbEncoded,
  DWORD cbEncoded,
  LPSTR lpszObjID)
{
  HRESULT             hr = hrSuccess;
  BOOL                fRet;
  PCERT_RDN_ATTR      pRdnAttr;
  PCERT_NAME_INFO     pNameInfo = NULL;
  DWORD               cbInfo;
  DWORD               cbData;  //N need both?

  // Initialize so we know if any data was copied in.
  *lplpszAttributeString = NULL;

  // Get the size of the subject name data
  cbInfo = 0;
  gpfnCryptDecodeObject(
    X509_ASN_ENCODING,    // indicates X509 encoding
    (LPCSTR)X509_NAME,    // flag indicating a name blob is to be decoded
    pbEncoded,            // pointer to a buffer holding the encoded name
    cbEncoded,            // length in bytes of the encoded name
    //N maybe can use nocopy flag
    0,                    // flags
    NULL,                 // NULL used when just geting length
    &cbInfo);             // length in bytes of the decoded name
  if (0 == cbInfo)
  {
    hr = HrGetLastError();
    goto out;
  }

  // Allocate space for the decoded name
  pNameInfo = (PCERT_NAME_INFO) LocalAlloc(LMEM_ZEROINIT, cbInfo);
  if (NULL == pNameInfo)
  {
    hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
    goto out;
  }

  // Get the subject name
  fRet = gpfnCryptDecodeObject(
    X509_ASN_ENCODING,    // indicates X509 encoding
    (LPCSTR)X509_NAME,    // flag indicating a name blob is to be decoded
    pbEncoded,            // pointer to a buffer holding the encoded name
    cbEncoded,            // length in bytes of the encoded name
    0,                    // flags
    pNameInfo,            // the buffer where the decoded name is written to
    &cbInfo);             // length in bytes of the decoded name
  if (FALSE == fRet)
  {
    hr = HrGetLastError();
    goto out;
  }

  // Now we have a decoded name RDN array, so find the oid we want
  pRdnAttr = gpfnCertFindRDNAttr(lpszObjID, pNameInfo);

  if (!pRdnAttr)
    {
    hr = MAPI_E_NOT_FOUND;
    goto out;
    }

   *lplpszAttributeString = SzConvertRDNString(pRdnAttr);

out:
  if (NULL != pNameInfo)
  {
    LocalFreeAndNull(&pNameInfo);
  }
  return hr;
}


//*******************************************************************
//
//  FUNCTION:   GetCertThumbPrint
//
//  PURPOSE:    Gets the thumbprint of the cert.
//
//  PARAMETERS: pccCertContext - cert whose thumbprint to get
//              pblobCertThumbPrint - receives thumb print
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/10/13  markdu  Created.
//
//*******************************************************************

HRESULT GetCertThumbPrint(
  PCCERT_CONTEXT      pccCertContext,
  PCRYPT_DIGEST_BLOB  pblobCertThumbPrint)
{
  HRESULT             hr = hrSuccess;
  BOOL                fRet;

  // Get the size of the thumbprint data
  pblobCertThumbPrint->cbData = 0;
  fRet = gpfnCertGetCertificateContextProperty(
    pccCertContext,
    CERT_HASH_PROP_ID,
    NULL,
    &pblobCertThumbPrint->cbData);
  if (FALSE == fRet)
  {
    hr = HrGetLastError();
    goto out;
  }

  // Allocate memory for the thumbprint data
  pblobCertThumbPrint->pbData = LocalAlloc(LMEM_ZEROINIT,
    pblobCertThumbPrint->cbData);
  if (NULL == pblobCertThumbPrint->pbData)
  {
    hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
    goto out;
  }

  // Get the thumbprint
  fRet = gpfnCertGetCertificateContextProperty(
    pccCertContext,
    CERT_HASH_PROP_ID,
    pblobCertThumbPrint->pbData,
    &pblobCertThumbPrint->cbData);
  if (FALSE == fRet)
  {
    hr = HrGetLastError();
    goto out;
  }

out:
  return hr;
}


/*  SzConvertRDNString
**
**  Purpose:
**      Figure out what kind of string data is in the RDN, allocate
**      a buffer and convert the string data to DBCS/ANSI.
**
**  Takes:
**      IN pRdnAttr - Certificate RDN atteribute
**  Returns:
**      A LocalAlloc'd buffer containing the string.
*/
LPTSTR SzConvertRDNString(PCERT_RDN_ATTR pRdnAttr) {
    LPTSTR szRet = NULL;
    ULONG cbData = 0;

    // We only handle certain types
    //N look to see if we should have a stack var for the ->
    if ((CERT_RDN_NUMERIC_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_PRINTABLE_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_IA5_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_VISIBLE_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_ISO646_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_UNIVERSAL_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_TELETEX_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_UNICODE_STRING != pRdnAttr->dwValueType)) {
        Assert((CERT_RDN_NUMERIC_STRING == pRdnAttr->dwValueType) ||
        (CERT_RDN_PRINTABLE_STRING == pRdnAttr->dwValueType) ||
        (CERT_RDN_IA5_STRING == pRdnAttr->dwValueType) ||
        (CERT_RDN_VISIBLE_STRING == pRdnAttr->dwValueType) ||
        (CERT_RDN_ISO646_STRING == pRdnAttr->dwValueType) ||
        (CERT_RDN_UNIVERSAL_STRING == pRdnAttr->dwValueType) ||
        (CERT_RDN_TELETEX_STRING == pRdnAttr->dwValueType) ||
        (CERT_RDN_UNICODE_STRING == pRdnAttr->dwValueType));
        return(NULL);
    }

    // Find out how much space to allocate.

    switch (pRdnAttr->dwValueType) {
        case CERT_RDN_UNICODE_STRING:
            cbData = WideCharToMultiByte(
              CP_ACP,
              0,
              (LPWSTR)pRdnAttr->Value.pbData,
              -1,
              NULL,
              0,
              NULL,
              NULL);
            break;

        case CERT_RDN_UNIVERSAL_STRING:
        case CERT_RDN_TELETEX_STRING:
            cbData = gpfnCertRDNValueToStr(pRdnAttr->dwValueType,
              (PCERT_RDN_VALUE_BLOB)&(pRdnAttr->Value),
              NULL,
              0);
            break;

        default:
            cbData = pRdnAttr->Value.cbData + 1;
        break;
    }

    // Allocate the space for the string.
    if (! (szRet = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cbData))) {
        Assert(szRet);
        return(NULL);
    }

    // Copy the string
    switch (pRdnAttr->dwValueType) {
        case CERT_RDN_UNICODE_STRING:
            lstrcpyn(szRet, (LPWSTR)pRdnAttr->Value.pbData, cbData);
            break;

        case CERT_RDN_UNIVERSAL_STRING:
        case CERT_RDN_TELETEX_STRING:
            gpfnCertRDNValueToStr(pRdnAttr->dwValueType,
              (PCERT_RDN_VALUE_BLOB)&(pRdnAttr->Value),
              szRet,
              cbData);
            break;

        default:
            ScAnsiToWCMore(NULL, NULL, pRdnAttr->Value.pbData, &szRet);
            szRet[cbData - 1] = '\0';
            break;
    }
    return(szRet);
}


/*  PVDecodeObject:
**
**  Purpose:
**      Combine the "how big? okay, here." double question to decode an
**      object.  Give it a thing to get and it will alloc the mem.
**  Takes:
**      IN pbEncoded        - encoded data
**      IN cbEncoded        - size of data in pbData
**      IN item             - X509_* ... the thing to get
**      OUT OPTIONAL cbOut  - (def value of NULL) size of the return
**  Notes:
**      pbEncoded can't be freed until return is freed.
**  Returns:
**      data that was obtained, NULL if failed.  Caller must LocalFree buffer.
*/
LPVOID PVDecodeObject(
    BYTE   *pbEncoded,
    DWORD   cbEncoded,
    LPCSTR  item,
    DWORD  *cbOut)
{
    DWORD cbData;
    void *pvData = NULL;

    if (!(pbEncoded && cbEncoded))
        {
        SetLastError((DWORD)E_INVALIDARG);
        goto ErrorReturn;
        }

    cbData = 0;
    gpfnCryptDecodeObject(
        X509_ASN_ENCODING,    // indicates X509 encoding
        item,                 // flag indicating type to be decoded
        pbEncoded,            // pointer to a buffer holding the encoded data
        cbEncoded,            // length in bytes of the encoded data
        CRYPT_DECODE_NOCOPY_FLAG,
        NULL,                 // NULL used when just geting length
        &cbData);             // length in bytes of the decoded data

    if (!cbData || ! (pvData = LocalAlloc(LPTR, cbData))) {
        goto ErrorReturn;
    }

    if (!gpfnCryptDecodeObject(
        X509_ASN_ENCODING,    // indicates X509 encoding
        item,                 // flag indicating type is to be decoded
        pbEncoded,            // pointer to a buffer holding the encoded data
        cbEncoded,            // length in bytes of the encoded name
        CRYPT_DECODE_NOCOPY_FLAG,
        pvData,               // out buffer
        &cbData))             // length in bytes of the decoded data
        goto ErrorReturn;

exit:
    if (cbOut)
        *cbOut = cbData;
    return pvData;

ErrorReturn:
    if (pvData)
        {
        IF_WIN32(LocalFree(pvData);)
        IF_WIN16(LocalFree((HLOCAL)pvData);)
        pvData = NULL;
        }
    cbData = 0;
    goto exit;
}


/*  SzGetAltNameEmail:
**
**  Input:
**      pCert -> certificate context
**      lpszOID -> OID or predefined id of alt name to look in.  ie, OID_SUBJECT_ALT_NAME or
**        X509_ALTERNATE_NAME.
**
**  Returns:
**      Buffer containing email name or NULL if not found.
**      Caller must LocalFree the buffer.
*/
LPTSTR SzGetAltNameEmail(
  const PCCERT_CONTEXT pCert,
  LPSTR lpszOID) {
    PCERT_INFO pCertInfo = pCert->pCertInfo;
    PCERT_ALT_NAME_ENTRY pAltNameEntry = NULL;
    PCERT_ALT_NAME_INFO pAltNameInfo = NULL;
    ULONG i, j, cbData;
    LPSTR szRet = NULL;
    LPTSTR sz = NULL;


    if (lpszOID == (LPCSTR)X509_ALTERNATE_NAME) {
        lpszOID = szOID_SUBJECT_ALT_NAME;
    }

    for (i = 0; i < pCertInfo->cExtension; i++) 
    {
        if (! lstrcmpA(pCertInfo->rgExtension[i].pszObjId, lpszOID)) 
        {
            // Found the OID.  Look for the email tag

            if (pAltNameInfo = (PCERT_ALT_NAME_INFO)PVDecodeObject(   pCertInfo->rgExtension[i].Value.pbData,
                                                                      pCertInfo->rgExtension[i].Value.cbData,
                                                                      lpszOID,
                                                                      NULL)) 
            {
                // Cycle through the alt name entries
                for (j = 0; j < pAltNameInfo->cAltEntry; j++) 
                {
                    if (pAltNameEntry = &pAltNameInfo->rgAltEntry[j]) 
                    {
                        if (pAltNameEntry->dwAltNameChoice == CERT_ALT_NAME_RFC822_NAME) 
                        {
                            // This is it, copy it out to a new allocation
                            if (pAltNameEntry->pwszRfc822Name)
                            {
                                if(sz = LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(pAltNameEntry->pwszRfc822Name)+1)))
                                {
                                    lstrcpy(sz, pAltNameEntry->pwszRfc822Name);
                                    break;
                                }
                            }
                        }
                    }
                }
                IF_WIN32(LocalFree(pAltNameInfo);)
                IF_WIN16(LocalFree((HLOCAL)pAltNameInfo);)
                pAltNameInfo = NULL;
            }

        }
    }
    LocalFreeAndNull(&pAltNameInfo);
    return(sz);
}

/*  SzGetCertificateEmailAddress:
**
**  Returns:
**      NULL if there is no email address
*/
LPTSTR SzGetCertificateEmailAddress(
    const PCCERT_CONTEXT    pCert)
{
    PCERT_NAME_INFO pNameInfo;
    PCERT_ALT_NAME_INFO pAltNameInfo = NULL;
    PCERT_RDN_ATTR  pRDNAttr;
    LPTSTR           szRet = NULL;

    Assert(pCert && pCert->pCertInfo);

    pNameInfo = (PCERT_NAME_INFO)PVDecodeObject(pCert->pCertInfo->Subject.pbData,
        pCert->pCertInfo->Subject.cbData, X509_NAME, 0);
    if (pNameInfo)
        {
        pRDNAttr = gpfnCertFindRDNAttr(szOID_RSA_emailAddr, pNameInfo);
        if (pRDNAttr)
            {
            Assert(0 == lstrcmpA(szOID_RSA_emailAddr, pRDNAttr->pszObjId));
            szRet = SzConvertRDNString(pRDNAttr);
            }
        IF_WIN32(LocalFree(pNameInfo);)
        IF_WIN16(LocalFree((HLOCAL)pNameInfo);)
        }

    if (! szRet)
        {
        if (! (szRet = SzGetAltNameEmail(pCert, szOID_SUBJECT_ALT_NAME)))
            {
            szRet = SzGetAltNameEmail(pCert, szOID_SUBJECT_ALT_NAME2);
            }
        }

    return(szRet);
}


//*******************************************************************
//
//  FUNCTION:   GetCertsDisplayInfoFromContext
//
//  PURPOSE:    Gets the display info that is available in the cert
//              context structure.
//
//  PARAMETERS: pccCertContext - cert data
//              lpCDI - structure to receive the cert data
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/10/04  markdu  Created.
//
//*******************************************************************

HRESULT GetCertsDisplayInfoFromContext(
  HWND                hwndParent,
  PCCERT_CONTEXT      pccCertContext,
  LPCERT_DISPLAY_INFO lpCDI)
{
  HRESULT             hr = hrSuccess;
  PCERT_INFO          pCertInfo;

  pCertInfo = pccCertContext->pCertInfo;
  lpCDI->lpszDisplayString = NULL,
  lpCDI->lpszEmailAddress = NULL;

  hr = GetAttributeString(
    &lpCDI->lpszDisplayString,
    pCertInfo->Subject.pbData,
    pCertInfo->Subject.cbData,
    szOID_COMMON_NAME);
  if (hrSuccess != hr)
  {
    DebugTrace(TEXT("Cert has no common name\n"));
  }

  lpCDI->lpszEmailAddress = SzGetCertificateEmailAddress(pccCertContext);

  // In case there is no common name (weird, but true)
  if (! lpCDI->lpszDisplayString) {
      lpCDI->lpszDisplayString = lpCDI->lpszEmailAddress;
  }
  if (! lpCDI->lpszDisplayString) {
      DebugTrace(TEXT("Certificate had no name or email!  What a pathetic cert!\n"));
  }

  // Some certificates won't have email addresses in them which means that
  //    Failure is not a (valid) option.
  //    just set it to empty
  if (hrSuccess != hr)
  {
    hr = S_OK;
  }

  DebugTrace(TEXT("Certificate for '%s'. Email: '%s'\n"), lpCDI->lpszDisplayString ? lpCDI->lpszDisplayString : NULL, (lpCDI->lpszEmailAddress ? lpCDI->lpszEmailAddress : szEmpty));

  // Determine if cert has expired
  lpCDI->bIsExpired = IsCertExpired(pCertInfo);

  // Determine if cert has been revoked
  lpCDI->bIsRevoked = IsCertRevoked(pCertInfo);

  // Determine if this certificate is trusted or not
  if (FAILED(HrGetTrustState(hwndParent, pccCertContext, &lpCDI->dwTrust)))
  {
    lpCDI->dwTrust = CERT_VALIDITY_NO_TRUST_DATA;
    hr = S_OK;      // we handled this
  }

  if (0 == lpCDI->dwTrust)
      lpCDI->bIsTrusted = TRUE;
  else
      lpCDI->bIsTrusted = FALSE;

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   DebugTraceCertContextName
//
//  PURPOSE:    Dump the subject name of a cert context
//
//  PARAMETERS: pcCertContext = cert context to dump
//              lpDescription = description text
//
//  RETURNS:    none
//
//*******************************************************************
void DebugTraceCertContextName(PCCERT_CONTEXT pcCertContext, LPTSTR lpDescription) {
#ifdef DEBUG
    LPTSTR lpName = NULL;
    PCERT_INFO pCertInfo = pcCertContext->pCertInfo;
    GetAttributeString(
      &lpName,
      pCertInfo->Subject.pbData,
      pCertInfo->Subject.cbData,
      szOID_COMMON_NAME);
    if (! lpName) {
        GetAttributeString(
          &lpName,
          pCertInfo->Subject.pbData,
          pCertInfo->Subject.cbData,
          szOID_ORGANIZATION_NAME);
    }

    DebugTrace(TEXT("%s %s\n"), lpDescription, lpName ? lpName : TEXT("<unknown>"));
    if (lpName) {
        IF_WIN32(LocalFree(lpName);)
        IF_WIN16(LocalFree((HLOCAL)lpName);)
    }
#endif
}


//*******************************************************************
//
//  FUNCTION:   ReadMessageFromFile
//
//  PURPOSE:    Reads a single cert from a PKCS7 message file
//
//  PARAMETERS: lpszFileName - name of file containing the PKCS7 encoded
//              message
//              hCryptProvider - handle to the store provider
//              ppbEncoded - receives the encoded cert blob
//              pcbEncoded - receives the size of the encoded cert blob
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/10/06  markdu  Created.
//
//*******************************************************************

HRESULT ReadMessageFromFile(
  LPTSTR        lpszFileName,
  HCRYPTPROV    hCryptProvider,
  PBYTE*        ppbEncoded,
  PDWORD        pcbEncoded)
{
    HRESULT         hr = hrSuccess;
    BOOL            fRet;
    DWORD           cCert, cbData;
    HCRYPTMSG       hMsg = NULL;
    PBYTE           lpBuf = 0;
    ULONG           i, j;
    DWORD           dwIssuerFlags = 0;
    BOOL            fFound = FALSE, fIssuer;
    PCERT_CONTEXT * rgpcCertContext = NULL;
    HCERTSTORE      hCertStoreMsg = NULL;
    PCCERT_CONTEXT  pcCertContextTarget = NULL, pcCertContextIssuer;
    PCERT_INFO      pCertInfoTarget = NULL;


    if ((NULL == ppbEncoded) || (NULL == pcbEncoded)) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
    *ppbEncoded = 0;
    *pcbEncoded = 0;

    // Read the data from the file.
    if (hr = ReadDataFromFile(lpszFileName, &lpBuf, (PDWORD)&cbData)) {
        goto out;
    }

    hMsg = gpfnCryptMsgOpenToDecode(
      PKCS_7_ASN_ENCODING,
      0,                          // dwFlags
      0,                          // dwMsgType
      hCryptProvider,
      NULL,                       // pRecipientInfo (not supported)
      NULL);                      // pStreamInfo (not supported)
    if (NULL == hMsg) {
        hr = HrGetLastError();
        DebugTrace(TEXT("CryptMsgOpenToDecode(PKCS_7_ASN_ENCODING) -> 0x%08x\n"), GetScode(hr));
        goto error;
    }

    fRet = gpfnCryptMsgUpdate(hMsg, lpBuf, cbData, TRUE);
    if (FALSE == fRet) {
        hr = HrGetLastError();
        DebugTrace(TEXT("CryptMsgUpdate -> 0x%08x\n"), GetScode(hr));
        goto error;
    }

    cbData = sizeof(cCert);
    fRet = gpfnCryptMsgGetParam(
      hMsg,
      CMSG_CERT_COUNT_PARAM,        // dwParamType
      0,                            // dwIndex
      (void *)&cCert,
      &cbData);                     // pcbData
    if (FALSE == fRet) {
        hr = HrGetLastError();
        DebugTrace(TEXT("CryptMsgGetParam(CMSG_CERT_COUNT_PARAM) -> 0x%08x\n"), GetScode(hr));
        goto error;
    }
    if (cbData != sizeof(cCert)) {
        hr = ResultFromScode(MAPI_E_CALL_FAILED);
        goto error;
    }

    if (cCert == 1) {
        // Just one cert.  No decisions to make.
        cbData = 0;
        fRet = gpfnCryptMsgGetParam(
          hMsg,
          CMSG_CERT_PARAM,
          0,                      // dwIndex
          NULL,                   // pvData
          &cbData
          );
        if ((!fRet) || (0 == cbData)) {
            hr = ResultFromScode(MAPI_E_CALL_FAILED);
            DebugTrace(TEXT("CryptMsgGetParam(CMSG_CERT_PARAM) -> 0x%08x\n"), GetScode(hr));
            goto error;
        }

        IF_WIN32(*ppbEncoded = (BYTE *)LocalAlloc(LMEM_ZEROINIT, cbData);)
        IF_WIN16(*ppbEncoded = (PBYTE)LocalAlloc(LMEM_ZEROINIT, cbData);)
        if (NULL == *ppbEncoded) {
            hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
            goto error;
        }

        fRet = gpfnCryptMsgGetParam(
          hMsg,
          CMSG_CERT_PARAM,
          0,
          *ppbEncoded,
          &cbData
          );
        if (FALSE == fRet) {
            hr = HrGetLastError();
            DebugTrace(TEXT("CryptMsgGetParam(CMSG_CERT_PARAM) -> 0x%08x\n"), GetScode(hr));
            IF_WIN32(LocalFreeAndNull(ppbEncoded);) IF_WIN16(LocalFreeAndNull((LPVOID *)ppbEncoded);)
            goto error;
        }
        *pcbEncoded = cbData;
    } else {
        // More than one cert in the message.  Which one is it?
        //
        // Look for one that's a "Leaf" node.
        // Unfortunately, there is no easy way to tell, so we'll have
        // to loop through each cert, checking to see if it is an issuer of any other cert
        // in the message.  If it is not an issuer of any other cert, it must be the leaf cert.
        //
        hCertStoreMsg = CertOpenStore(
          CERT_STORE_PROV_MSG,
          X509_ASN_ENCODING,
          hCryptProvider,
          CERT_STORE_NO_CRYPT_RELEASE_FLAG,
          hMsg);

        if (hCertStoreMsg == NULL) {
            hr = HrGetLastError();
            DebugTrace(TEXT("CertOpenStore(msg) -> %u\n"), hr);
        } else {
            if (! (rgpcCertContext = LocalAlloc(LPTR, cCert * sizeof(PCERT_CONTEXT)))) {
                DebugTrace(TEXT("LocalAlloc of cert table -> %u\n"), HrGetLastError());
                hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                goto error;
            }

            // Enumerate all certs on this message
            i = 0;
            while (pcCertContextTarget = gpfnCertEnumCertificatesInStore(hCertStoreMsg,
              pcCertContextTarget)) {

                if (! (rgpcCertContext[i] = (PCERT_CONTEXT)CertDuplicateCertificateContext(
                  pcCertContextTarget))) {
                    DebugTrace(TEXT("CertCertificateContext -> %x\n"), HrGetLastError());
                }

#ifdef DEBUG
                DebugTraceCertContextName(rgpcCertContext[i], TEXT("Found Cert:"));
#endif
                i++;
            };

            // Now we've got a table full of certs
            for (i = 0; i < cCert; i++) {
                pCertInfoTarget = rgpcCertContext[i]->pCertInfo;
                fIssuer = FALSE;

                for (j = 0; j < cCert; j++) {
                    if (i != j) {
                        dwIssuerFlags = 0;

                        if (pcCertContextIssuer = gpfnCertGetIssuerCertificateFromStore(hCertStoreMsg,
                          rgpcCertContext[j],
                          NULL,
                          &dwIssuerFlags)) {

                            // Found an issuer
                            // Is it the same as the target?
                            fIssuer = gpfnCertCompareCertificate(X509_ASN_ENCODING,
                              pCertInfoTarget,   // target
                              pcCertContextIssuer->pCertInfo);     // test issuer

                            gpfnCertFreeCertificateContext(pcCertContextIssuer);

                            if (fIssuer) {
                                // This test cert is issued by the target, so
                                // we know that Target is NOT a leaf cert
                                break;
                            } // else, loop back to the enumerate where the test cert context will be freed.
                        }
                    }
                }

                if (! fIssuer) {
                    DebugTrace(TEXT("Found a Cert which is not an issuer.\n"));
#ifdef DEBUG
                    DebugTraceCertContextName(rgpcCertContext[i],  TEXT("Non-issuer cert:"));
#endif
                    // Copy the cert encoded data to a seperate allocation
                    cbData = rgpcCertContext[i]->cbCertEncoded;
#ifndef WIN16
                    if (! (*ppbEncoded = (BYTE *)LocalAlloc(LPTR, cbData))) {
                        hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                        goto error;
                    }
#else
                    if (! (*ppbEncoded = (PBYTE)LocalAlloc(LPTR, cbData))) {
                        hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                        goto error;
                    }
#endif

                    CopyMemory(*ppbEncoded, rgpcCertContext[i]->pbCertEncoded, cbData);
                    *pcbEncoded = cbData;
                    fFound = TRUE;
                    break;  // done with loop
                }
            }

            // Free the table of certs
            for (i = 0; i < cCert; i++) {
                gpfnCertFreeCertificateContext(rgpcCertContext[i]);
            }
            IF_WIN32(LocalFree((LPVOID)rgpcCertContext);)
            IF_WIN16(LocalFree((HLOCAL)rgpcCertContext);)

            if (! fFound) {
                // Didn't find a cert that isn't an issuer.  Fail.
                hr = ResultFromScode(MAPI_E_NOT_FOUND);
                goto error;
            }
        }
    }

out:
    if (hCertStoreMsg) {
        CertCloseStore(hCertStoreMsg, 0);
    }

    if (hMsg) {
        gpfnCryptMsgClose(hMsg);
    }

    if (lpBuf) {
        IF_WIN32(LocalFreeAndNull(&lpBuf);) IF_WIN16(LocalFreeAndNull((LPVOID *)&lpBuf);)
    }

    return(hr);

error:
    // some of the GetLastError calls above may not have worked.
    if (hrSuccess == hr) {
        hr = ResultFromScode(MAPI_E_CALL_FAILED);
    }

    goto out;
}


//*******************************************************************
//
//  FUNCTION:   WriteDERToFile
//
//  PURPOSE:    Writes a single cert to a file as a DER encoded blob
//
//  PARAMETERS: lpszFileName - name of file to hold the encoded blob
//              pccCertContext - the cert to be written
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/10/29  markdu  Created.
//
//*******************************************************************

HRESULT WriteDERToFile(
  LPTSTR  lpszFileName,
  PBYTE   pbEncoded,
  DWORD   cbEncoded)
{
  HRESULT             hr = hrSuccess;
  BOOL                fRet;
  HANDLE              hFile = 0;
  DWORD               cbFile;

  // Open the file
  hFile = CreateFile(
    lpszFileName,
    GENERIC_READ | GENERIC_WRITE,
    0,
    NULL,
    CREATE_ALWAYS,
    0,
    NULL);
  if(INVALID_HANDLE_VALUE == hFile)
  {
    hr = ResultFromScode(MAPI_E_DISK_ERROR);
    goto out;
  }

  // Write the data to the file
  fRet = WriteFile(
    hFile,                      // handle of file to write
    pbEncoded,                  // address of buffer to write
    cbEncoded,                  // number of bytes to write
    &cbFile,                    // address of number of bytes written
    NULL                        // address of structure for data
    );
  if (FALSE == fRet)
  {
    hr = ResultFromScode(MAPI_E_DISK_ERROR);
    goto out;
  }
  if (cbEncoded != cbFile)
  {
    hr = ResultFromScode(MAPI_E_CALL_FAILED);
    goto out;
  }

out:
  if (hFile)
  {
    IF_WIN32(CloseHandle(hFile);) IF_WIN16(CloseFile(hFile);)
  }

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   GetIssuerContextAndStore
//
//  PURPOSE:    Get the context of the issuer by first looking in the
//              CA store, then the root store.
//
//  PARAMETERS: pccCertContext - cert whose issuer to find
//              ppccIssuerCertContext - receives context of issuer,
//              or NULL if no issuer cert found.
//              phcsIssuerStore - receives handle of store containing cert.
//              hCryptProvider - must be a valid provider
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/10/14  markdu  Created.
//
//*******************************************************************

HRESULT GetIssuerContextAndStore(
  PCCERT_CONTEXT      pccCertContext,
  PCCERT_CONTEXT*     ppccIssuerCertContext,
  HCRYPTPROV          hCryptProvider,
  HCERTSTORE*         phcsIssuerStore)
{
  HRESULT             hr = hrSuccess;
  DWORD               dwFlags;

  // Open the CA store to get the issuer data.
  hr = OpenSysCertStore(phcsIssuerStore, &hCryptProvider, cszCACertStore);
  if (hrSuccess == hr)
  {
    // Get the issuer cert context
    dwFlags = 0;
    *ppccIssuerCertContext = gpfnCertGetIssuerCertificateFromStore(
      *phcsIssuerStore,
      pccCertContext,
      NULL,
      &dwFlags);
    if (NULL != *ppccIssuerCertContext)
    {
      goto out;
    }
    else
    {
      // Close the store, but don't goto error, becuase we want to try again.
      CloseCertStore(*phcsIssuerStore, 0);
      *phcsIssuerStore = NULL;
      hr = ResultFromScode(MAPI_E_NOT_FOUND);
    }
  }

  // We didn't find the issuer, so try the root store
  hr = OpenSysCertStore(phcsIssuerStore, &hCryptProvider, cszROOTCertStore);
  if (hrSuccess == hr)
  {
    // Get the issuer cert context
    dwFlags = 0;
    *ppccIssuerCertContext = gpfnCertGetIssuerCertificateFromStore(
      *phcsIssuerStore,
      pccCertContext,
      NULL,
      &dwFlags);
    if (NULL != *ppccIssuerCertContext)
    {
      goto out;
    }
    else
    {
      goto error;
    }
  }

out:
  // Make sure we didn't get back the same cert (ie it was self-signed).
  if (hrSuccess == hr)
  {
    // First compare sizes since that is faster.
    if (pccCertContext->cbCertEncoded == (*ppccIssuerCertContext)->cbCertEncoded)
    {
      // Sizes are the same, now compare the encoded cert blobs
      if (0 == memcmp(
        pccCertContext->pbCertEncoded,
        (*ppccIssuerCertContext)->pbCertEncoded,
        pccCertContext->cbCertEncoded))
      {
        // Certs are identical.  There is no issuer.
        goto error;
      }
    }
  }

  return hr;

error:
  CloseCertStore(*phcsIssuerStore, 0);
  *phcsIssuerStore = NULL;
  return ResultFromScode(MAPI_E_NOT_FOUND);
}


/***************************************************************************

    Name      : HrBuildCertSBinaryData

    Purpose   : Takes as input all the data needed for a cert entry
                in PR_USER_X509_CERTIFICATE and returns a pointer to
                memory that contains all the input data in the correct
                format to be plugged in to the lpb member of an SBinary
                structure.  This memory should be Freed by the caller.


    Parameters: bIsDefault - TRUE if this is the default cert
                pblobCertThumbPrint - The actual certificate thumbprint
                pblobSymCaps - symcaps blob
                ftSigningTime - Signing time
                lpObject - object to alloc more onto, or NULL to LocalAlloc
                lplpbData - receives the buffer with the data
                lpcbData - receives size of the data

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT HrBuildCertSBinaryData(
  BOOL                  bIsDefault,
  BOOL                  fIsThumbprint,
  PCRYPT_DIGEST_BLOB    pPrint,
  BLOB *                pSymCaps,
  FILETIME              ftSigningTime,
  LPVOID                lpObject,
  LPBYTE FAR*           lplpbData,
  ULONG FAR*            lpcbData)
{
	WORD		cbDefault, cbPrint;
    DWORD       cbSymCaps;
    HRESULT     hr = S_OK;
    LPCERTTAGS  lpCurrentTag;
    ULONG       cbSize, cProps;
    LPBYTE      lpb = NULL;


    cbDefault   = sizeof(bIsDefault);
    cbPrint     = (WORD) pPrint->cbData;
    cbSymCaps   = pSymCaps ? pSymCaps->cbSize : 0;
    cProps      = 2;
    cbSize      = cbDefault + cbPrint;
    if (cbSymCaps) {
        cProps++;
        cbSize += cbSymCaps;
    }
    if (ftSigningTime.dwLowDateTime || ftSigningTime.dwHighDateTime) {
        cProps++;
        cbSize += sizeof(FILETIME);
    }
    cbSize += (cProps * SIZE_CERTTAGS);

    if (NULL == lpObject)
    {
      lpb = LocalAlloc(LMEM_ZEROINIT, cbSize);
      if (NULL == lpb)
      {
        hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
      }
    }
    else
    {
      SCODE sc;
      sc = MAPIAllocateMore(cbSize, lpObject, (LPVOID *)&lpb);
      if (sc)
      {
        hr = ResultFromScode(sc);
        goto exit;
      }
    }

    // Set the default property
    lpCurrentTag = (LPCERTTAGS)lpb;
    lpCurrentTag->tag       = CERT_TAG_DEFAULT;
    lpCurrentTag->cbData    = SIZE_CERTTAGS + cbDefault;
    memcpy(&lpCurrentTag->rgbData,
        &bIsDefault,
        cbDefault);

    // Set the thumbprint property
    lpCurrentTag = (LPCERTTAGS)((BYTE*)lpCurrentTag + lpCurrentTag->cbData);
    lpCurrentTag->tag       = fIsThumbprint ? CERT_TAG_THUMBPRINT : CERT_TAG_BINCERT;
    lpCurrentTag->cbData    = SIZE_CERTTAGS + cbPrint;
    memcpy(&lpCurrentTag->rgbData, pPrint->pbData, cbPrint);

    // Set the SymCaps property
    if (cbSymCaps) {
        lpCurrentTag = (LPCERTTAGS)((BYTE*)lpCurrentTag + lpCurrentTag->cbData);
        lpCurrentTag->tag       = CERT_TAG_SYMCAPS;
        lpCurrentTag->cbData    = (WORD) (SIZE_CERTTAGS + pSymCaps->cbSize);
        memcpy(&lpCurrentTag->rgbData, pSymCaps->pBlobData, cbSymCaps);
    }

    // Signing time property
    if (ftSigningTime.dwLowDateTime || ftSigningTime.dwHighDateTime) {
        lpCurrentTag = (LPCERTTAGS)((BYTE*)lpCurrentTag + lpCurrentTag->cbData);
        lpCurrentTag->tag       = CERT_TAG_SIGNING_TIME;
        lpCurrentTag->cbData    = SIZE_CERTTAGS + sizeof(FILETIME);
        memcpy(&lpCurrentTag->rgbData, &ftSigningTime, sizeof(FILETIME));
    }


    *lpcbData = cbSize;
    *lplpbData = lpb;
exit:
    return(hr);
}

//*******************************************************************
//
//  FUNCTION:   HrLDAPCertToMAPICert
//
//  PURPOSE:    Convert cert(s) returned from LDAP server to MAPI props.
//              Two properties are required.  The certs are placed in the
//              WAB store, and all necessary indexing data is placed in
//              PR_USER_X509_CERTIFICATE property.  If this certificate
//              didn't already exist in the WAB store, it's thumbprint is
//              added to PR_WAB_TEMP_CERT_HASH so that these certs can
//              be deleted from the store if the user cancels the add.
//
//  PARAMETERS: lpPropArray - the prop array where the 2 props are stored
//              ulX509Index - the index to the PR_USER_X509_CERTIFICATE prop
//              ulTempCertIndex - the index to the PR_WAB_TEMP_CERT_HASH prop
//              cbCert, lpCert - encoded cert data from the LDAP ppberval struct
//              ulcCerts - the number of certs from the LDAP server
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/12/12  markdu  Created.
//
//*******************************************************************

HRESULT HrLDAPCertToMAPICert(
                             LPSPropValue    lpPropArray,
                             ULONG           ulX509Index,
                             ULONG           ulTempCertIndex,
                             ULONG           cbCert,
                             PBYTE           lpCert,
                             ULONG           ulcCerts)
{
    HRESULT             hr = hrSuccess;
    HRESULT             hrOut = hrSuccess;
    CRYPT_DIGEST_BLOB   blobCertThumbPrint = {0};
    PCCERT_CONTEXT      pccCertToAdd;
    PCCERT_CONTEXT      pccCertFromStore;
    HCERTSTORE          hcsWABCertStore = NULL;
    HCRYPTPROV          hCryptProvider = 0;
    PBYTE               pbEncoded;
    DWORD               cbEncoded;
    ULONG               i;
    ULONG               cbData = 0;
    LPBYTE              lpbData = NULL;
    FILETIME            ftNull = {0, 0};
    
#ifdef  PARAMETER_VALIDATION
    ULONG ulcProps = max(ulX509Index, ulTempCertIndex);
    if (ulcProps && IsBadReadPtr(lpPropArray, ulcProps * sizeof(SPropValue)))
    {
        return ResultFromScode(MAPI_E_INVALID_PARAMETER);
    }
    /*  if (ulcCerts && IsBadReadPtr(ppberval, ulcCerts * sizeof(struct berval)))
    {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
    }
    */
#endif  // PARAMETER_VALIDATION
    
    // Make sure we have the right kind of proparray.
    if ((NULL == lpPropArray) ||
        (PR_USER_X509_CERTIFICATE != lpPropArray[ulX509Index].ulPropTag) ||
        (PR_WAB_TEMP_CERT_HASH != lpPropArray[ulTempCertIndex].ulPropTag))
    {
        return ResultFromScode(MAPI_E_INVALID_PARAMETER);
    }
    
    // Load the crypto functions
    if (FALSE == InitCryptoLib())
    {
        hr = ResultFromScode(MAPI_E_UNCONFIGURED);
        return hr;
    }
    
    // Open the store since we need to lookup certs
    hr = OpenSysCertStore(&hcsWABCertStore, &hCryptProvider, cszWABCertStore);
    if (hrSuccess != hr)
    {
        goto out;
    }
    
    // Add each cert to the props, unless it is a duplicate.
    for (i=0;i<ulcCerts;i++)
    {
        // Convert the cert into a form we can deal with.
        // BUGBUG this assumes the cert is DER encoded.
        pbEncoded = lpCert; //(PBYTE)ppberval[i]->bv_val;
        cbEncoded = cbCert; //(DWORD)ppberval[i]->bv_len;
        
        // Get a context for the cert so we can get the thumbprint
        pccCertToAdd = gpfnCertCreateCertificateContext(
            X509_ASN_ENCODING,
            pbEncoded,
            cbEncoded);
        if (NULL == pccCertToAdd)
        {
            hr = GetLastError();
            goto out;
        }
        
        // Get the thumbprint for this cert.
        hr = GetCertThumbPrint(
            pccCertToAdd,
            &blobCertThumbPrint);
        if (hrSuccess != hr)
        {
            goto out;
        }
        
        // See if this cert is in the store already.  If it is, we don't want to
        // add it to the temp property for deletion later.
        pccCertFromStore = gpfnCertFindCertificateInStore(
            hcsWABCertStore,
            X509_ASN_ENCODING,
            0,
            CERT_FIND_HASH,
            (void *)&blobCertThumbPrint,
            NULL);
        if (NULL == pccCertFromStore)
        {
            BOOL fRet;
            
            // Add the cert to the store
            fRet = gpfnCertAddEncodedCertificateToStore(
                hcsWABCertStore,
                X509_ASN_ENCODING,
                pbEncoded,
                cbEncoded,
                CERT_STORE_ADD_NEW,
                NULL);
            if (FALSE == fRet)
            {
                hr = GetLastError();
                goto out;
            }
            
            // Add the thumbprint to the temp prop so we can delete it later if the user cancels.
            hr = AddPropToMVPBin(
                lpPropArray,
                ulTempCertIndex,
                blobCertThumbPrint.pbData,
                blobCertThumbPrint.cbData,
                TRUE);
            if (hrSuccess != hr)
            {
                goto out;
            }
        }
        else
        {
            // We don't need to add this one to the store.
            gpfnCertFreeCertificateContext(pccCertFromStore);
        }
        
        // Pack up all the cert data
        cbData = 0;
        hr = HrBuildCertSBinaryData(
            FALSE,
            TRUE,
            &blobCertThumbPrint,
            NULL,         // SymCaps blob
            ftNull,       // Signing time
            NULL,         // This NULL means lpbData is allocated with LocalAlloc()
            &lpbData,
            &cbData);
        if ((hrSuccess != hr) || (0 == cbData))
        {
            goto out;
        }
        
        // Add the cert data to the real cert prop.
        hr = AddPropToMVPBin(
            lpPropArray,
            ulX509Index,
            lpbData,
            cbData,
            TRUE);
        if (hrSuccess != hr)
        {
            goto out;
        }
        
        // Add the trust for this LDAP cert to the pstore
        // (doesn't have to be done because we won't trust this
        //  certificate by default)
        // This is the way it was, wonder if that is correct
        // (t-erikne)
        
        // Free the cert context so we can do the next one.
        gpfnCertFreeCertificateContext(pccCertToAdd);
        pccCertToAdd = NULL;
        LocalFreeAndNull(&lpbData);
        cbData = 0;

        // Also free the blobCertThumbPrint.pbData which is allocated with LocalAlloc()
        LocalFreeAndNull(&(blobCertThumbPrint.pbData));
        blobCertThumbPrint.cbData = 0;
  }
  
out:
  // Both blobCertThumbPrint.pbData and lpbData above are allocated using LocalAlloc()
  // Be sure and free this memory.
  LocalFreeAndNull(&lpbData);
  LocalFreeAndNull(&(blobCertThumbPrint.pbData));

  // Destroy any data we created if the function failed.
  if (hrSuccess != hr)
  {
      lpPropArray[ulX509Index].ulPropTag = PR_NULL;
      lpPropArray[ulTempCertIndex].ulPropTag = PR_NULL;
  }
  
  // Free the cert context.  Ignore errors since there is nothing we can do.
  if (NULL != pccCertToAdd)
  {
      gpfnCertFreeCertificateContext(pccCertToAdd);
  }
  
  // Close the cert store.
  hrOut = CloseCertStore(hcsWABCertStore, hCryptProvider);
  
  // If an error occurred in the function body, return that instead of
  // any errors that occurred here in cleanup.
  if (hrSuccess == hr)
  {
      hr = hrOut;
  }
  
  return hr;
}

//*******************************************************************
//
//  FUNCTION:   HrRemoveCertsFromWABStore
//
//  PURPOSE:    Remove the certs whose thumbprints are in the supplied
//              PR_WAB_TEMP_CERT_HASH property.
//
//  PARAMETERS: lpPropValue - the PR_WAB_TEMP_CERT_HASH property
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/12/13  markdu  Created.
//
//*******************************************************************

HRESULT HrRemoveCertsFromWABStore(
  LPSPropValue    lpPropValue)
{
  HRESULT             hr = hrSuccess;
  HRESULT             hrOut = hrSuccess;
	CRYPT_DIGEST_BLOB   blobCertThumbPrint;
  PCCERT_CONTEXT      pccCertContext;
  HCERTSTORE          hcsWABCertStore = NULL;
  HCRYPTPROV          hCryptProvider = 0;
  ULONG               i;
  ULONG               ulcCerts;
  BOOL                fRet;

#ifdef  PARAMETER_VALIDATION
  if (IsBadReadPtr(lpPropValue, sizeof(SPropValue)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
#endif  // PARAMETER_VALIDATION

  // Make sure we have the right kind of proparray.
  if ((NULL == lpPropValue) ||
      (PR_WAB_TEMP_CERT_HASH != lpPropValue->ulPropTag))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }

  // Count the number of certs in the input.
  ulcCerts = lpPropValue->Value.MVbin.cValues;
  if (0 == ulcCerts)
  {
    return hr;
  }

  // Load the crypto functions
  if (FALSE == InitCryptoLib())
  {
    hr = ResultFromScode(MAPI_E_UNCONFIGURED);
    return hr;
  }

  // Open the store since we need to delete certs
  hr = OpenSysCertStore(&hcsWABCertStore, &hCryptProvider, cszWABCertStore);
  if (hrSuccess != hr)
  {
    return hr;
  }

  // Delete each cert.
  for (i=0;i<ulcCerts;i++)
  {
    // Get the thumbprint from the propval.
    blobCertThumbPrint.cbData = lpPropValue->Value.MVbin.lpbin[i].cb;
    blobCertThumbPrint.pbData = lpPropValue->Value.MVbin.lpbin[i].lpb;

    // Get the certificate from the WAB store using the thumbprint
    // If we don't find the cert, ignore it and go on to the next one.
    pccCertContext = gpfnCertFindCertificateInStore(
      hcsWABCertStore,
      X509_ASN_ENCODING,
      0,
      CERT_FIND_HASH,
      (void *)&blobCertThumbPrint,
      NULL);
    if (NULL != pccCertContext)
    {
      // Delete the cert
      fRet = gpfnCertDeleteCertificateFromStore(pccCertContext);
      if (FALSE == fRet)
      {
        hr = HrGetLastError();
        goto out;
      }
    }
  }

out:
  // Close the cert store.
  hrOut = CloseCertStore(hcsWABCertStore, hCryptProvider);

  // If an error occurred in the function body, return that instead of
  // any errors that occurred here in cleanup.
  if (hrSuccess == hr)
  {
    hr = hrOut;
  }

  return hr;
}



//*******************************************************************
//
//  FUNCTION:   IsCertExpired
//
//  PURPOSE:    Check the cert info to see if it is expired or not yet valid.
//
//  PARAMETERS: pCertInfo - Cert to verify
//
//  RETURNS:    TRUE if cert is expired, FALSE otherwise.
//
//  HISTORY:
//  96/12/16  markdu  Created.
//  98/03/225 brucek  Use CAPI fn and be a little lenient on the start time.
//
//*******************************************************************
#define TIME_DELTA_SECONDS 600          // 10 minutes in seconds
#define FILETIME_SECOND    10000000     // 100ns intervals per second
HRESULT IsCertExpired(
  PCERT_INFO            pCertInfo)
{
    LONG                lRet;
    FILETIME            ftDelta;
    __int64             i64Delta;
    __int64             i64Offset;
    FILETIME            ftNow;

    Assert(pCertInfo);

    lRet = gpfnCertVerifyTimeValidity(NULL, pCertInfo);

    if (lRet < 0) {
        // Get the current time in filetime format so we can add the offset
        GetSystemTimeAsFileTime(&ftNow);

        i64Delta = ftNow.dwHighDateTime;
        i64Delta = i64Delta << 32;
        i64Delta += ftNow.dwLowDateTime;

        // Add the offset into the original time to get us a new time to check
        i64Offset = FILETIME_SECOND;
        i64Offset *= TIME_DELTA_SECONDS;
        i64Delta += i64Offset;

        ftDelta.dwLowDateTime = (ULONG)i64Delta & 0xFFFFFFFF;
        ftDelta.dwHighDateTime = (ULONG)(i64Delta >> 32);

        lRet = gpfnCertVerifyTimeValidity(&ftDelta, pCertInfo);
    }

  return(lRet != 0);
}


//*******************************************************************
//
//  FUNCTION:   IsCertRevoked
//
//  PURPOSE:    Check the cert info to see if it is revoked.
//
//  PARAMETERS: pCertInfo - Cert to verify
//
//  RETURNS:    TRUE if cert is revoked, FALSE otherwise.
//
//  HISTORY:
//  96/12/16  markdu  Created.
//
//*******************************************************************

HRESULT IsCertRevoked(
  PCERT_INFO            pCertInfo)
{
  Assert(pCertInfo);

  // Determine if cert has been revoked
  // BUGBUG How to do this?
  return FALSE;
}


//*******************************************************************
//
//  FUNCTION:   ReadDataFromFile
//
//  PURPOSE:    Read data from a file.
//
//  PARAMETERS: lpszFileName - name of file containing the data to be read
//              ppbData - receives the data that is read
//              pcbData - receives the size of the data that is read
//
//  RETURNS:    HRESULT
//
//  HISTORY:
//  96/12/16  markdu  Created.
//
//*******************************************************************

HRESULT ReadDataFromFile(
  LPTSTR      lpszFileName,
  PBYTE*      ppbData,
  PDWORD      pcbData)
{
  HRESULT             hr = hrSuccess;
  BOOL                fRet;
  HANDLE              hFile = 0;
  DWORD               cbFile;
  DWORD               cbData;
  PBYTE               pbData = 0;

  if ((NULL == ppbData) || (NULL == pcbData))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }

  // Open the file and find out how big it is
  hFile = CreateFile(
    lpszFileName,
    GENERIC_READ,
    FILE_SHARE_READ | FILE_SHARE_WRITE,
    NULL,
    OPEN_EXISTING,
    0,
    NULL);
  if(INVALID_HANDLE_VALUE == hFile)
  {
    hr = ResultFromScode(MAPI_E_DISK_ERROR);
    goto error;
  }

  cbData = GetFileSize(hFile, NULL);
  if (0xFFFFFFFF == cbData)
  {
    hr = ResultFromScode(MAPI_E_DISK_ERROR);
    goto error;
  }

  IF_WIN32(pbData = (BYTE *)LocalAlloc(LMEM_ZEROINIT, cbData);)
  IF_WIN16(pbData = (PBYTE)LocalAlloc(LMEM_ZEROINIT, cbData);)
  if (NULL == pbData)
  {
    hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
    goto error;
  }

  fRet = ReadFile(
    hFile,                      // handle of file to read
    pbData,                      // address of buffer that receives data
    cbData,                     // number of bytes to read
    &cbFile,                    // address of number of bytes read
    NULL                        // address of structure for data
    );
  if (FALSE == fRet)
  {
    hr = ResultFromScode(MAPI_E_DISK_ERROR);
    goto error;
  }
  if (cbData != cbFile)
  {
    hr = ResultFromScode(MAPI_E_CALL_FAILED);
    goto error;
  }

  *ppbData = pbData;
  *pcbData = cbData;

out:
  if (hFile)
  {
    IF_WIN32(CloseHandle(hFile);) IF_WIN16(CloseFile(hFile);)
  }

  return hr;

error:
  // BUGBUG some of the GetLastError calls above may not have worked.
  if (hrSuccess == hr)
  {
    hr = ResultFromScode(MAPI_E_CALL_FAILED);
  }

  goto out;
}


//*******************************************************************
//
//  FUNCTION:   GetIssuerName
//
//  PURPOSE:    Wraps the several calls that one can make to try to
//              get a usable name from a certificate.  Esp in the
//              case of self-signed certs, the issuer may just have a
//              common name.
//
//  PARAMETERS: lplpszIssuerName - OUT, for the name, NULL on err
//              pCertInfo - IN, place from which to retrieve the data
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  97/02/04  t-erikne  Created.
//
//*******************************************************************

HRESULT GetIssuerName(
    LPTSTR FAR * lplpszIssuerName,
    PCERT_INFO pCertInfo)
{
  HRESULT hr;

  Assert(lplpszIssuerName);

  *lplpszIssuerName = '\000';

  hr = GetAttributeString(
    lplpszIssuerName,
    pCertInfo->Issuer.pbData,
    pCertInfo->Issuer.cbData,
    szOID_ORGANIZATION_NAME);

  if (hrSuccess != hr)
    if (MAPI_E_NOT_FOUND == hr)
      hr = GetAttributeString(
        lplpszIssuerName,
        pCertInfo->Issuer.pbData,
        pCertInfo->Issuer.cbData,
        szOID_COMMON_NAME);

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   HrGetTrustState
//
//  PURPOSE:    For newly imported certs, need to determine if an
//                  issuer exists for this cert or not ...
//
//  HISTORY:
//  2/17/97     t-erikne created
//  7/02/97     t-erikne updated to WinTrust
//
//*******************************************************************
HRESULT HrGetTrustState(
    HWND            hwndParent,
    PCCERT_CONTEXT  pcCert,
    DWORD *         pdwTrust)
{
    HRESULT     hr;
    DWORD       dwErr;
    GUID        guidAction = CERT_CERTIFICATE_ACTION_VERIFY;
    // CERT_VERIFY_CERTIFICATE_TRUST   cvct = {0};

    CERT_VERIFY_CERTIFICATE_TRUST       trust = {0};
    WINTRUST_BLOB_INFO                  blob = {0};
    WINTRUST_DATA                       data = {0};


    if (!(pcCert || pdwTrust))
        return E_INVALIDARG;

    data.cbStruct = sizeof(WINTRUST_DATA);
    data.pPolicyCallbackData = NULL;
    data.pSIPClientData = NULL;
    data.dwUIChoice = WTD_UI_NONE;
    data.fdwRevocationChecks = WTD_REVOKE_NONE;
    data.dwUnionChoice = WTD_CHOICE_BLOB;
    data.pBlob = &blob;

    blob.cbStruct = sizeof(WINTRUST_BLOB_INFO);
    blob.pcwszDisplayName = NULL;
    blob.cbMemObject = sizeof(trust);
    blob.pbMemObject = (LPBYTE)&trust;

    trust.cbSize = sizeof(trust);
    trust.pccert = pcCert;
    trust.pdwErrors = pdwTrust;
    trust.pszUsageOid = szOID_PKIX_KP_EMAIL_PROTECTION;
    trust.dwIgnoreErr =
      CERT_VALIDITY_NO_CRL_FOUND |
      CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION;

    return (0 <= WinVerifyTrust(hwndParent, &guidAction, &data))
        ? S_OK
        : E_FAIL;
}


HRESULT DeleteCertStuff(LPADRBOOK lpAdrBook,
                        LPENTRYID lpEntryID,
                        ULONG cbEntryID)
{
    SizedSPropTagArray(1, ptaCert)=
                    { 1, {PR_USER_X509_CERTIFICATE} };
    LPMAPIPROP      lpMailUser = NULL;
    HRESULT         hr = E_FAIL;
    LPSPropValue    ppv = NULL;
    ULONG           ul;
    BLOB            thumbprint;
    LPWSTR          szW = NULL;

    //N2 not sure what to do yet about trust removal
    goto out;

    if (HR_FAILED(hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                                    cbEntryID,    // cbEntryID
                                                    lpEntryID,    // entryid
                                                    NULL,         // interface
                                                    0,                // ulFlags
                                                    &ul,       // returned object type
                                                    (LPUNKNOWN *)&lpMailUser)))
    {
        // Failed!  Hmmm.
        DebugTraceResult( TEXT("DeleteCertStuff: IAB->OpenEntry:"), hr);
        goto out;
    }

    Assert(lpMailUser);

    if(MAPI_DISTLIST == ul)
        {
        hr = S_OK;
        goto out;
        }

    if (HR_FAILED(hr = lpMailUser->lpVtbl->GetProps(lpMailUser,
                                                    (LPSPropTagArray)&ptaCert,   // lpPropTagArray
                                                    MAPI_UNICODE,          // ulFlags
                                                    &ul,        // how many properties were there?
                                                    &ppv)))
    {
        DebugTraceResult( TEXT("DeleteCertStuff: IAB->GetProps:"), hr);
        goto out;
    }

    if (MAPI_W_ERRORS_RETURNED == hr)
        {
        if (PROP_TYPE(ppv->ulPropTag) == PT_ERROR)
            // the property doesn't exist, so we have no certs
            // for this entry
            hr = S_OK;  // cool
        goto out;
        }
    else if (1 != ul)
        {
        hr = E_FAIL;
        goto out;
        }
    else if (FAILED(hr))
        goto out;

    // Now need to loop over the SBinary structures to look at each cert
    for (ul = 0; ul < ppv->Value.MVbin.cValues; ul++)
        {
        LPCERTTAGS  lpCurrentTag, lpTempTag;
        LPBYTE      lpbTagEnd;

        lpCurrentTag = (LPCERTTAGS)ppv->Value.MVbin.lpbin[ul].lpb;
        lpbTagEnd = (LPBYTE)lpCurrentTag + ppv->Value.MVbin.lpbin[ul].cb;

        // either this is the last cert or it is the default, so get the data
        // scan for "thumbprint" tag
        while ((LPBYTE)lpCurrentTag < lpbTagEnd && (CERT_TAG_THUMBPRINT != lpCurrentTag->tag)) {
            lpTempTag = lpCurrentTag;
            lpCurrentTag = (LPCERTTAGS)((BYTE*)lpCurrentTag + lpCurrentTag->cbData);
            if (lpCurrentTag == lpTempTag) {
                AssertSz(FALSE,  TEXT("Bad CertTag in PR_USER_X509_CERTIFICATE\n"));
                break;        // Safety valve, prevent infinite loop if bad data
            }
        }
        if (CERT_TAG_THUMBPRINT == lpCurrentTag->tag)
            {
            // we need to remove the trust blob

#ifdef DEBUG
            if (SUCCEEDED(hr))
                DebugTraceResult( TEXT("DeleteCertStuff: trust blob deleted -- "), hr);
            else
                DebugTraceResult( TEXT("DeleteCertStuff: FAILED trust blob delete --"), hr);
#endif

            }
        else
            {
            // no data, so go to next cert
            DebugTrace(TEXT("DeleteCertStuff: odd... no data for the cert\n"));
            continue;
            }
        } // for loop over certs

out:
    if (ppv)
        MAPIFreeBuffer(ppv);
    if (lpMailUser)
        lpMailUser->lpVtbl->Release(lpMailUser);
    return hr;
}

PCCERT_CONTEXT WabGetCertFromThumbprint(CRYPT_DIGEST_BLOB thumbprint)
{
    HCERTSTORE      hcWAB;
    PCCERT_CONTEXT  pcRet;

    hcWAB = CertOpenStore(
#ifdef UNICODE
                            CERT_STORE_PROV_SYSTEM_W,
#else
                            CERT_STORE_PROV_SYSTEM_A,
#endif
                            X509_ASN_ENCODING, 0, CERT_SYSTEM_STORE_CURRENT_USER, cszWABCertStore);

    if (hcWAB)
    {
        pcRet =  CertFindCertificateInStore(
            hcWAB,
            X509_ASN_ENCODING,
            0,                  //dwFindFlags
            CERT_FIND_HASH,
            (void *)&thumbprint,
            NULL);
        CertCloseStore(hcWAB, 0);
    }
    else
    {
        pcRet = NULL;
    }

    return pcRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\common.h ===
#include <WINDOWS.H>
#include <genlib32.h>  // added in LAB02
#include <commctrl.h>
#include "resource.h"  // added in LAB05
#include "base32.h"
#include "fonts.h"
#include "thormsgs.h"
#include "image.h"
#include "btnbar.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\cntxtmnu.c ===
/**********************************************************************************
*
*
*   contxtmnu.c - contains functions for handling/creating context menu extension 
*
*   Created - 9/97 - vikramm
*
**********************************************************************************/
#include "_apipch.h"

static const TCHAR szActionPropsRegKey[] = TEXT("Software\\Microsoft\\WAB\\WAB4\\ExtContext");
BOOL fContextExtCoinit = FALSE;

//$$//////////////////////////////////////////////////////////////////////
//
// UninitContextExtInfo
//
//  OLE Unintialization
//
//////////////////////////////////////////////////////////////////////////
void UninitContextExtInfo()
{
    if(fContextExtCoinit)
    {
        CoUninitialize();
        fContextExtCoinit = FALSE;
    }
}

/*
 - FreeActionItemList
 -
 *  Frees up the Action Items list cached on the IAB object
 *
 */
void FreeActionItemList(LPIAB lpIAB)
{
    LPWABACTIONITEM lpItem = lpIAB->lpActionList;
    while(lpItem)
    {
        lpIAB->lpActionList = lpItem->lpNext;
        SafeRelease(lpItem->lpWABExtInit);
        SafeRelease(lpItem->lpContextMenu);
        LocalFree(lpItem);
        lpItem = lpIAB->lpActionList;
    }
    lpIAB->lpActionList = NULL;
}


/*
 - HrUpdateActionItemList
 -
 *  Apps can register with the WAB for rt-click and toolbar Action items
 *  We load a list of registered action items here upfront and cache it on
 *  the IAB object. 
 *
 */

HRESULT HrUpdateActionItemList(LPIAB lpIAB)
{
    HRESULT hr = E_FAIL;
    HKEY hKey = NULL;
    LPWABACTIONITEM lpList = NULL;
    DWORD dwIndex = 0, dwSize = 0;
    int nCmdID = IDM_EXTENDED_START, nActionItems = 0;

    EnterCriticalSection(&lpIAB->cs);

    if(lpIAB->lpActionList)
        FreeActionItemList(lpIAB);

    lpIAB->lpActionList = NULL;

    // 
    // We will look in the registry under HKLM\Software\Microsoft\WAB\WAB4\Actions
    // If this key exists, we get all the key values under it - these key values
    // are all GUIDs
    // The format for this key is
    //
    // HKLM\Software\Microsoft\WAB\WAB4\Action Extensions
    //              GUID1
    //              GUID2
    //              GUID3 etc
    //

    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                    szActionPropsRegKey,
                                    0, KEY_READ,&hKey))
    {
        goto out;
    }

    {
        // Enumerate the GUIDs under this key one by one
        //
        TCHAR szGUIDName[MAX_PATH];
        DWORD dwGUIDIndex = 0, dwGUIDSize = CharSizeOf(szGUIDName), dwType = 0;

        *szGUIDName = '\0';

        while(ERROR_SUCCESS == RegEnumValue(hKey, dwGUIDIndex, 
                                            szGUIDName, &dwGUIDSize, 
                                            0, &dwType, 
                                            NULL, NULL))
        {
            // The values under this entry are all GUIDs
            // Read the GUID string and translate it into a GUID
            //
            GUID guidTmp = {0};
            WCHAR szW[MAX_PATH];
            lstrcpy(szW, szGUIDName);
            if( !(HR_FAILED(hr = CLSIDFromString(szW, &guidTmp))) )
            {
                LPWABACTIONITEM lpTemp = LocalAlloc(LMEM_ZEROINIT, sizeof(WABACTIONITEM));
                if(!lpTemp)
                {
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                    goto out;
                }
                // Temporarily cache the GUID
                CopyMemory(&(lpTemp->guidContextMenu), &guidTmp, sizeof(GUID));
                lpTemp->lpNext = lpList;
                lpList = lpTemp;
            }

            dwGUIDIndex++;
            *szGUIDName = '\0';
            dwGUIDSize = CharSizeOf(szGUIDName);
        }
    }

    if(lpList)
    {
        // If we have a list of GUIDs from the registry, we now
        // need to open CoCreateInstance them one by one and get a handle
        // to their method pointers
        LPWABACTIONITEM lpItem = lpList;

        if (CoInitialize(NULL) == S_FALSE) 
            CoUninitialize(); // Already initialized, undo the extra.
        else
            fContextExtCoinit = TRUE;

        while(lpItem)
        {
            hr = CoCreateInstance(  &(lpItem->guidContextMenu), 
                                    NULL, 
                                    CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER,
                                    &IID_IContextMenu, 
                                    (LPVOID *)&(lpItem->lpContextMenu));
            if(lpItem->lpContextMenu && !HR_FAILED(hr))
            {
                // Found an IContextMenu object, aslo want a IWABExtInit object
                hr = lpItem->lpContextMenu->lpVtbl->QueryInterface(lpItem->lpContextMenu,
                                                        &IID_IWABExtInit,
                                                        (LPVOID *)&(lpItem->lpWABExtInit));
                if(HR_FAILED(hr) || !lpItem->lpWABExtInit)
                {
                    // Can't work without an IWABExtInit object
                    SafeRelease(lpItem->lpContextMenu);
                }
            }
            else
            {
                hr = S_OK; //ignore error
                lpItem->lpContextMenu = NULL;
            }
            lpItem = lpItem->lpNext;
        }
    }

    lpIAB->lpActionList = lpList;

    hr = S_OK;
out:
    if(hKey)
        RegCloseKey(hKey);

    LeaveCriticalSection(&lpIAB->cs);

    return hr;
}

/*
 - GetActionAdrList
 -
 *  Based on the parameters for a particular rt-click action,
 *  scans the entries in the list view and creates an adrlist
 *  for the entries
 *  
 *  If only one entry is selected and it is an LDAP entry, then
 *  also creates an LDAP URL representing that entry .. this way
 *  if we are displaying properties or doing actions on a single
 *  entry, the property sheet extenstions can determine if they 
 *  want to do anything extra for the entry. People most interested
 *  in this are the NTDS
 *  
 *  For now,we only look at the selected items in the list view
 *
    lpAdrBook   - IAB object
    hWndLV      - the list view on which this action was initiated
    *lppAdrList - created AdrList
    *lpURL      - returned URL
    *lpbIsNTDSEntry - flag NTDS entries so they can be special treated

  Note performance suffers for a large number of entries so we want to 
  really only return a list of entryids
 */
HRESULT HrGetActionAdrList(LPADRBOOK lpAdrBook,
                        HWND hWndLV,   
                        LPADRLIST * lppAdrList,
                        LPTSTR * lppURL, BOOL * lpbIsNTDSEntry)
{
    HRESULT hr = S_OK;
    LPADRLIST lpAdrList = NULL;
    int i = 0, iItemIndex  = 0, nIndex= 0;
    int nSel = ListView_GetSelectedCount(hWndLV);
    SCODE sc;
    if(!nSel)
        goto out;

    sc = MAPIAllocateBuffer(sizeof(ADRLIST) + nSel * sizeof(ADRENTRY), &lpAdrList);
    
    if(sc)
    {
        hr = ResultFromScode(sc);
        goto out;
    }

    // Get index of selected item
    iItemIndex = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);

    while(iItemIndex != -1)
    {
        LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);

        if(lpItem)
        {
            ULONG ulObjType = 0;
            LPSPropValue lpProps = NULL;
            LPMAILUSER lpEntry = NULL;
            ULONG cValues = 0;

            if(lpItem->cbEntryID && lpItem->lpEntryID)
            {
                if (hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                                  lpItem->cbEntryID,
                                                  lpItem->lpEntryID,
                                                  NULL,         // interface
                                                  0,            // flags
                                                  &ulObjType,
                                                  (LPUNKNOWN *)&lpEntry))
                {
                    goto out;
                }
                hr = lpEntry->lpVtbl->GetProps( lpEntry, NULL, MAPI_UNICODE, 
                                                &cValues, &lpProps);
                if(HR_FAILED(hr))
                {
                    UlRelease(lpEntry);
                    goto out;
                }
                lpAdrList->aEntries[nIndex].cValues = cValues;
                lpAdrList->aEntries[nIndex].rgPropVals = lpProps;
                nIndex++;

                UlRelease(lpEntry);

                if(nSel == 1 && lppURL)
                {
                    CreateLDAPURLFromEntryID(lpItem->cbEntryID, lpItem->lpEntryID, 
                                             lppURL, lpbIsNTDSEntry);
                }
            }
        }
        iItemIndex = ListView_GetNextItem(hWndLV,iItemIndex,LVNI_SELECTED);
    }

    lpAdrList->cEntries = nIndex;
    *lppAdrList = lpAdrList;
    hr = S_OK;
   
out:    
    return hr;
}

extern void MAILUSERAssociateContextData(LPMAILUSER lpMailUser, LPWABEXTDISPLAY lpWEC);
/*
-   HrCreateContextDataStruct
-
*   Creates the data necessary to initialize a ContextMenu implementor
*   This structure is passed into the IWABExtInit::Initialize call
*
    hWndLV      - ListView containing the WAB entries
    lppWABExt   - returned data
*/
HRESULT HrCreateContextDataStruct(  LPIAB lpIAB, 
                                    HWND hWndLV, 
                                    LPWABEXTDISPLAY * lppWABExt)
{
    LPADRLIST lpAdrList = NULL;
    LPWABEXTDISPLAY lpWEC = NULL;
    LPMAILUSER lpMailUser = NULL;
    LPTSTR lpURL = NULL;
    BOOL bIsNTDSEntry = FALSE;

    HRESULT hr = E_FAIL;

    // Get an AdrList Corresponding to the LV contents
    hr = HrGetActionAdrList((LPADRBOOK)lpIAB, hWndLV, &lpAdrList, &lpURL, &bIsNTDSEntry);
    if(HR_FAILED(hr) || !lpAdrList || !lpAdrList->cEntries)
        goto out; //dont bother invoking

    // Create a dummy mailuser so callers can call GetIDsFromNames
    // on this dummy mailuser - saves them the trouble of creating entries
    // just to call GetIDsFromNames
    hr = HrCreateNewObject((LPADRBOOK)lpIAB, NULL, MAPI_MAILUSER, CREATE_CHECK_DUP_STRICT, (LPMAPIPROP *) &lpMailUser);
    if(HR_FAILED(hr))
        goto out; //dont bother invoking

    lpWEC = LocalAlloc(LMEM_ZEROINIT, sizeof(WABEXTDISPLAY));
    if(!lpWEC)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    lpWEC->cbSize       = sizeof(WABEXTDISPLAY);
    lpWEC->ulFlags      = WAB_CONTEXT_ADRLIST; // indicates ADRLIST is valid and in the lpv member
    lpWEC->lpAdrBook    = (LPADRBOOK) lpIAB;
    lpWEC->lpWABObject  = (LPWABOBJECT) lpIAB->lpWABObject;
    lpWEC->lpPropObj    = (LPMAPIPROP) lpMailUser;
    lpWEC->lpv          = (LPVOID) lpAdrList;

    if(lpURL && lstrlen(lpURL))
    {
        lpWEC->lpsz = lpURL;
        lpWEC->ulFlags |= WAB_DISPLAY_LDAPURL;
        lpWEC->ulFlags |= MAPI_UNICODE;
        if(bIsNTDSEntry)
            lpWEC->ulFlags |= WAB_DISPLAY_ISNTDS;
    }

    // We associate this entire WABEXT structure with the mailuser
    // so that when we get the IMailUser release, we can go ahead and clean
    // up all the WABEXT memory .. since there is no other good time that we can
    // free the memory since we won't know who is doing what withthe structure.
    // Freeing it at IMailUser::Release time works out quite well
    MAILUSERAssociateContextData(lpMailUser, lpWEC);

    //
    // Cache this mailUser on the IAB object
    //
    // At any given point of time, we are going to cache one ContextMenu related MailUser
    // This is because we set this up before QueryCommandMenu and then we dont know whether
    // or not the user actually managed to select a menu item, or went off and did something new.
    // We set the data on a MailUser and we don't release the MailUser till the next time we are
    // here. If someone is currently using the MailUser, they will addref it - the memory attached
    // to the MailUser will be freed up with the last caller so we dont leak it ..
    // If we never come back here, the mailuser will be released at shutdown
    //
    UlRelease(lpIAB->lpCntxtMailUser);
    lpIAB->lpCntxtMailUser = lpMailUser;

    *lppWABExt = lpWEC;
    hr = S_OK;
out:

    if(HR_FAILED(hr))
    {
        UlRelease(lpMailUser);
        if(lpAdrList)
            FreePadrlist(lpAdrList);
        if(lpWEC)
            LocalFree(lpWEC);
    }
    return hr;
}

//$$////////////////////////////////////////////////////////////////////////////
//
//  AddExtendedMenuItems -  Creates a list of extension menu items and adds them 
//              to the specified menu
//
//  hMenuAction - menu on which to add this item
//  bUpdateStatus - if TRUE, means only find the existing item in the menu and update
//      its status - if FALSE, means add to the menu
//  bAddSendMailToItems - if TRUE, means attempt to modify the SendMailTo menu item
//
//////////////////////////////////////////////////////////////////////////////
void AddExtendedMenuItems(  LPADRBOOK lpAdrBook, 
                            HWND hWndLV, 
                            HMENU hMenuAction, 
                            BOOL bUpdateStatus, 
                            BOOL bAddSendMailToItems)
{
    HRESULT hr = S_OK;
    LPWABEXTDISPLAY lpWEC = NULL;
    LPIAB lpIAB = (LPIAB) lpAdrBook;

    // Intialize the context menu extensions
    if(!lpIAB->lpActionList)
        HrUpdateActionItemList(lpIAB);

    if(bUpdateStatus)
    {
        // This is only set to true from the call from ui_abook.c which means this
        // is the Tools Menu item we are talking about.
        // To update the status of the Tools menu item, we need to remove all the
        // items we added before and then re-add them
        // For indexing purposes, we will assume that the last pre-configured item in
        // this list is the Internet Call item (since this menu list is quite variable)

        // First get the position of the IDM_TOOLS_INTERNET_CALL item
        int i, nPos = -1, nId = 0;
        int nCmdCount = GetMenuItemCount(hMenuAction); // Append all items at end of this menu
        for(i=0;i<nCmdCount;i++)
        {
            if(GetMenuItemID(hMenuAction, i) == IDM_TOOLS_INTERNET_CALL)
            {
                nPos = i;
                break;
            }
        }
        if(nPos >= 0 && nPos < nCmdCount-1)
        {
            for(i=nPos+1;i<nCmdCount;i++)
            {
                DeleteMenu(hMenuAction, nPos+1, MF_BYPOSITION);
            }
        }
    }

    // Do any special treatment we need to do for SendMailTo
    AddExtendedSendMailToItems(lpAdrBook, hWndLV, hMenuAction, bAddSendMailToItems);


    // Before we can call QueryContextMenu - we must already have a list of all
    // the selected items from the ListView and provide such items to the ContextMenu
    // implementors so that they can decide how to handle the data being provided to them
    // (e.g. they may want to disable their item for multi-selections etc)...
    //
    HrCreateContextDataStruct(lpIAB, hWndLV, &lpWEC);
    
    if(lpIAB->lpActionList && lpWEC && lpWEC->lpv)
    {
        LPWABACTIONITEM lpItem = lpIAB->lpActionList;
        int nCmdIdPos = GetMenuItemCount(hMenuAction); // Append all items at end of this menu
        while(lpItem)
        {
            if(lpItem->lpContextMenu && lpItem->lpWABExtInit)// && !bUpdateStatus)
            {
                int nNumCmd = 0;
                // Get the menu item added to this menu
                hr = lpItem->lpWABExtInit->lpVtbl->Initialize(lpItem->lpWABExtInit, lpWEC);
                if(!HR_FAILED(hr))
                {
                    hr = lpItem->lpContextMenu->lpVtbl->QueryContextMenu(lpItem->lpContextMenu,
                                                                    hMenuAction,
                                                                    nCmdIdPos,
                                                                    lpItem->nCmdIdFirst ? lpItem->nCmdIdFirst : IDM_EXTENDED_START+nCmdIdPos,
                                                                    IDM_EXTENDED_END,
                                                                    CMF_NODEFAULT | CMF_NORMAL);
                    if(!HR_FAILED(hr))
                    {
                        nNumCmd = HRESULT_CODE(hr);
                        if(nNumCmd)
                        {
                            // Record the range of IDs taken up by this menu ext implementor
                            if(!lpItem->nCmdIdFirst)
                                lpItem->nCmdIdFirst = nCmdIdPos+IDM_EXTENDED_START;
                            if(!lpItem->nCmdIdLast)
                                lpItem->nCmdIdLast = lpItem->nCmdIdFirst + nNumCmd - 1;
                        }    
                        // Update the next available starting pos
                        nCmdIdPos = nCmdIdPos+nNumCmd;
                    }
                }
            }
            lpItem = lpItem->lpNext;
        }
    }
}




/*
 - ProcessActionCommands
 -
 *  Process a WM_COMMAND message to see if it matches any of the extended
 *  rt-click action items ...
 *
 *  Also process SendMailTo extended email-address mail processing here since
 *  this is a convenient place to do so ..
 *  
 */
LRESULT ProcessActionCommands(LPIAB lpIAB, HWND  hWndLV, HWND  hWnd,  
                              UINT  uMsg, WPARAM  wParam, LPARAM lParam)
{
    int nCmdID = GET_WM_COMMAND_ID(wParam, lParam);
    int i = 0;

    switch(nCmdID)
    {
    case IDM_DIALDLG_START:
        HrExecDialDlg(hWndLV, (LPADRBOOK)lpIAB);
        return 0;
        break;
    case IDM_LVCONTEXT_INTERNET_CALL:
    case IDM_TOOLS_INTERNET_CALL:
        HrShellExecInternetCall((LPADRBOOK)lpIAB, hWndLV);
        return 0;
        break;

    case IDM_LVCONTEXT_SENDMAIL:
	case IDM_FILE_SENDMAIL:
        HrSendMailToSelectedContacts(hWndLV, (LPADRBOOK)lpIAB, 0);
        break;
    }
        
    if( (nCmdID>=IDM_SENDMAILTO_START) && (nCmdID<=IDM_SENDMAILTO_START+IDM_SENDMAILTO_MAX))
    {
        HrSendMailToSelectedContacts(hWndLV, (LPADRBOOK)lpIAB, nCmdID - IDM_SENDMAILTO_START);
        return 0;
    }

    // Check if this is any of the context menu extensions ..
    if(lpIAB->lpActionList)
    {
        LPWABACTIONITEM lpListItem = lpIAB->lpActionList;
        while(lpListItem)
        {
            if(nCmdID >= lpListItem->nCmdIdFirst && nCmdID <= lpListItem->nCmdIdLast)
            {
                CMINVOKECOMMANDINFO cmici = {0};
                cmici.cbSize        = sizeof(CMINVOKECOMMANDINFO);
                cmici.fMask         = 0;
                cmici.hwnd          = hWnd;
                cmici.lpVerb        = (LPCSTR) IntToPtr(nCmdID - lpListItem->nCmdIdFirst);
                cmici.lpParameters  = NULL;
                cmici.lpDirectory   = NULL;
                cmici.nShow         = SW_SHOWNORMAL; 

                lpListItem->lpContextMenu->lpVtbl->InvokeCommand(lpListItem->lpContextMenu,
                                                                &cmici);
                return 0;
            }
            lpListItem = lpListItem->lpNext;
        }
    }
    return DefWindowProc(hWnd,uMsg,wParam,lParam);
}


/*
 - GetContextMenuExtCommandString
 -
 *  gets the status bar helptext for context menu extensions
 *  
 */
void GetContextMenuExtCommandString(LPIAB lpIAB, int nCmdId, LPTSTR sz, ULONG cbsz)
{
    int nStringID = 0;

    switch(nCmdId)
    {            
        case IDM_DIALDLG_START:
            nStringID = idsMenuDialer;    
            break;       
        case IDM_LVCONTEXT_INTERNET_CALL:
        case IDM_TOOLS_INTERNET_CALL:
            nStringID = idsMenuInternetCall;
            break;
        case IDM_LVCONTEXT_SENDMAIL:
        case IDM_FILE_SENDMAIL:
            nStringID = idsMenuSendMail;
            break;
    }
    if(nStringID)
    {
        LoadString(hinstMapiX, nStringID, sz, cbsz);
        return;
    }

    if(lpIAB->lpActionList)
    {
        LPWABACTIONITEM lpListItem = lpIAB->lpActionList;
        while(lpListItem)
        {
            if(nCmdId >= lpListItem->nCmdIdFirst && nCmdId <= lpListItem->nCmdIdLast)
            {
                char szC[MAX_PATH];
                ULONG cbszC = CharSizeOf(szC);
                lpListItem->lpContextMenu->lpVtbl->GetCommandString(lpListItem->lpContextMenu,
                                                                    nCmdId - lpListItem->nCmdIdFirst,
                                                                    GCS_HELPTEXT,
                                                                    NULL,
                                                                    szC,
                                                                    cbszC);
                {
                    LPTSTR lp = ConvertAtoW(szC);
                    if(lp)
                    {
                        lstrcpyn(sz, lp, cbsz);
                        LocalFreeAndNull(&lp);
                    }
                }
                break;
            }
            lpListItem = lpListItem->lpNext;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\debug.c ===
/*
 -  debug.c
 -
 *      Microsoft Internet Phone
 *		Debug functions
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		11.16.95	Yoram Yaacovi		Copied from the mstools tapicomm misc.c
 *		11.16.95	Yoram Yaacovi		Modified for iphone
 *		1.10.96		Yoram Yaacovi		Added conditional trace and file debug output
 *
 *	Functions:
 *    DebugPrintFileLine
 *    DebugPrintf
 *    DebugTrap
 *
 */

//#include "mpswab.h"
#include "_apipch.h"

#pragma warning(disable:4212)  // nonstd extension: ellipsis used

#if defined(DEBUG) || defined(TEST)

extern BOOL fTrace;							// Set TRUE if you want debug traces
extern BOOL fDebugTrap;						// Set TRUE to get int3's
extern TCHAR szDebugOutputFile[MAX_PATH];	// the name of the debug output file

/*
 *  FUNCTION: DebugPrintFileLine(..)
 *
 *  PURPOSE: Pretty print a trace or error message to the debugging output.
 *
 *  PARAMETERS:
 *    dwParam - One dword parameter (can be the error code)
 *    pszPrefix   - String to prepend to the printed message.
 *    szFileName  - Filename the error occured in.
 *    nLineNumber - Line number the error occured at.
 *
 *  RETURN VALUE:
 *    none
 *
 *  COMMENTS:
 *    If szFileName == NULL, then the File and Line are not printed.
 *
 */

void DebugPrintFileLine(
    DWORD dwParam, LPTSTR szPrefix,
    LPTSTR szFileName, DWORD nLineNumber)
{
    TCHAR szBuffer[256];

    if (szPrefix == NULL)
        szPrefix = szEmpty;

    // Pretty print the error message.
	// <not done yet>

    // If szFileName, then use it; else don't.
    if (szFileName != NULL)
    {
        wsprintf(szBuffer,
            TEXT("%s: \"%x\" in File \"%s\", Line %d\r\n"),
            szPrefix, dwParam, szFileName, nLineNumber);
    }
    else
    {
        wsprintf(szBuffer, TEXT("%s: \"%x\"\r\n"), szPrefix, dwParam);
    }

    // Print it!
    OutputDebugString(szBuffer);

    return;
}


/*
 *  FUNCTION: DebugPrintfError(LPTSTR, ...)
 *
 *  PURPOSE: a wrapper around DebugPrintf for error cases
 *
 *	PARAMETERS:
 *		lpszFormat - the same as printf		
 *
 *  RETURN VALUE:
 *    none.
 *
 *  COMMENTS:
 *
 */

void __cdecl DebugPrintfError(LPTSTR lpszFormat, ...)
{
    va_list v1;

    va_start(v1, lpszFormat);

	DebugPrintf(AVERROR, lpszFormat, v1);
}

/*
 *  FUNCTION: DebugPrintfTrace(LPTSTR, ...)
 *
 *  PURPOSE: a wrapper around DebugPrintf for the trace case
 *
 *	PARAMETERS:
 *		lpszFormat - the same as printf		
 *
 *  RETURN VALUE:
 *    none.
 *
 *  COMMENTS:
 *
 */

void __cdecl DebugPrintfTrace(LPTSTR lpszFormat, ...)
{
    va_list v1;

    va_start(v1, lpszFormat);

	DebugPrintf(AVTRACE, lpszFormat, v1);
}

/*
 *  FUNCTION: DebugPrintf(ULONG ulFlags, LPTSTR, va_list)
 *
 *  PURPOSE: wsprintfA to the debugging output.
 *
 *	PARAMETERS:
 *		ulFlags - trace, error, zone information
 *		lpszFormat - the same as printf		
 *
 *  RETURN VALUE:
 *    none.
 *
 *  COMMENTS:
 *
 */

#ifdef WIN16
void __cdecl DebugPrintf(ULONG ulFlags, LPTSTR lpszFormat, ...)
#else
void __cdecl DebugPrintf(ULONG ulFlags, LPTSTR lpszFormat, va_list v1)
#endif
{
    TCHAR szOutput[512];
	LPTSTR lpszOutput=szOutput;
    DWORD dwSize;
#ifdef WIN16
    va_list  v1;

    va_start(v1, lpszFormat);
#endif

	// if error, start the string with "ERROR:"
	if (ulFlags == AVERROR)
	{
		lstrcpy(lpszOutput, TEXT("ERROR: "));
		lpszOutput = lpszOutput+lstrlen(lpszOutput);
	}

	// if trace, and tracing not enabled, leave
	if ((ulFlags == AVTRACE) && !fTrace)
		goto out;

    dwSize = wvsprintf(lpszOutput, lpszFormat, v1);

	// Append carriage return, if necessary
    if ((szOutput[lstrlen(szOutput)-1] == '\n') &&
		(szOutput[lstrlen(szOutput)-2] != '\r'))
	{
        szOutput[lstrlen(szOutput)-1] = 0;
		lstrcat(szOutput, TEXT("\r\n"));
	}

    if (lstrlen(szDebugOutputFile))
    {
		HANDLE hLogFile=NULL;
		DWORD dwBytesWritten=0;
		BOOL bSuccess=FALSE;

		// open a log file for appending. create if does not exist
		if ((hLogFile = CreateFile(szDebugOutputFile,
			GENERIC_WRITE,
			0,	// not FILE_SHARED_READ or WRITE
			NULL,
			OPEN_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,
			(HANDLE)NULL)) != INVALID_HANDLE_VALUE)
		{
			// Write log string to file. Nothing I can do if this fails
			SetFilePointer(hLogFile, 0, NULL, FILE_END);   // seek to end
            bSuccess = WriteFile(hLogFile,
								szOutput,
								lstrlen(szOutput),
								&dwBytesWritten,
								NULL);
	        IF_WIN32(CloseHandle(hLogFile);) IF_WIN16(CloseFile(hLogFile);)
		}

    }
    else
    {
        OutputDebugString(szOutput);
    }

out:
	return;
}

#ifdef OLD_STUFF
/***************************************************************************

    Name      : DebugTrap

    Purpose   : depending on a registry setting, does the int3 equivalent

    Parameters: none

    Returns   :

	Notes	  :	

***************************************************************************/
void DebugTrapFn(void)
{
	if (fDebugTrap)
		DebugBreak();
  		// _asm { int 3};
}
#endif

#else	// no DEBUG

// need these to resolve def file exports
void DebugPrintFileLine(
    DWORD dwParam, LPTSTR szPrefix,
    LPTSTR szFileName, DWORD nLineNumber)
{}

void __cdecl DebugPrintf(ULONG ulFlags, LPTSTR lpszFormat, ...)
{}

#ifdef OLD_STUFF
void DebugTrapFn(void)
{}
#endif

void __cdecl DebugPrintfError(LPTSTR lpszFormat, ...)
{}

void __cdecl DebugPrintfTrace(LPTSTR lpszFormat, ...)
{}

#endif	// DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\contable.c ===
/*
 *	CONTABLE.C
 *
 *	Contents table implementation.
 *	
 */

#include "_apipch.h"


STDMETHODIMP
CONTVUE_SetColumns(
	LPVUE			lpvue,
	LPSPropTagArray	lpptaCols,
	ULONG			ulFlags );

// CONTVUE (table view class)
// Implementes in-memory IMAPITable class on top of TADs
// This is a copy of vtblVUE with FindRow overridden with the LDAP FindRow.
VUE_Vtbl vtblCONTVUE =
{
  VTABLE_FILL
  (VUE_QueryInterface_METHOD FAR *)    UNKOBJ_QueryInterface,
  (VUE_AddRef_METHOD FAR *)            UNKOBJ_AddRef,
  VUE_Release,
  (VUE_GetLastError_METHOD FAR *)      UNKOBJ_GetLastError,
  VUE_Advise,
  VUE_Unadvise,
  VUE_GetStatus,
  (VUE_SetColumns_METHOD FAR *)        CONTVUE_SetColumns,
  VUE_QueryColumns,
  VUE_GetRowCount,
  VUE_SeekRow,
  VUE_SeekRowApprox,
  VUE_QueryPosition,
  VUE_FindRow,
  VUE_Restrict,
  VUE_CreateBookmark,
  VUE_FreeBookmark,
  VUE_SortTable,
  VUE_QuerySortOrder,
  VUE_QueryRows,
  VUE_Abort,
  VUE_ExpandRow,
  VUE_CollapseRow,
  VUE_WaitForCompletion,
  VUE_GetCollapseState,
  VUE_SetCollapseState
};


//
//  Private functions
//



/***************************************************************************

    Name      : GetEntryProps

    Purpose   : Open the entry, get it's props, release the entry

    Parameters: lpContainer -> AB Container object
                cbEntryID = size of entryid
                lpEntryID -> entry id to open
                lpPropertyStore -> property store structure
                lpSPropTagArray -> prop tags to get
                lpAllocMoreHere = buffer to allocate more onto (or NULL for allocbuffer)
                ulFlags - 0 or MAPI_UNICODE
                lpulcProps -> return count of props here
                lppSPropValue -> return props here

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT GetEntryProps(
  LPABCONT lpContainer,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  LPSPropTagArray lpSPropTagArray,
  LPVOID lpAllocMoreHere,            // allocate more on here
  ULONG ulFlags,
  LPULONG lpulcProps,                      // return count here
  LPSPropValue * lppSPropValue) {          // return props here

    HRESULT hResult = hrSuccess;
    SCODE sc;
    ULONG ulObjType;
    LPMAPIPROP lpObject = NULL;
    LPSPropValue lpSPropValue = NULL;
    ULONG cb;


    if (HR_FAILED(hResult = lpContainer->lpVtbl->OpenEntry(lpContainer,
      cbEntryID,
      lpEntryID,
      NULL,
      0,        // read only is fine
      &ulObjType,
      (LPUNKNOWN *)&lpObject))) {
        DebugTrace(TEXT("GetEntryProps OpenEntry failed %x\n"), GetScode(hResult));
        return(hResult);
    }

    if (HR_FAILED(hResult = lpObject->lpVtbl->GetProps(lpObject,
      lpSPropTagArray,
      ulFlags,
      lpulcProps,
      &lpSPropValue))) {
        DebugTrace(TEXT("GetEntryProps GetProps failed %x\n"), GetScode(hResult));
        goto exit;
    }


    // Allocate more for our return buffer
    if (FAILED(sc = ScCountProps(*lpulcProps, lpSPropValue, &cb))) {
        hResult = ResultFromScode(sc);
        goto exit;
    }

    if (FAILED(sc = MAPIAllocateMore(cb, lpAllocMoreHere, lppSPropValue))) {
        hResult = ResultFromScode(sc);
        goto exit;
    }

    if (FAILED(sc = ScCopyProps(*lpulcProps, lpSPropValue, *lppSPropValue, NULL))) {
        hResult = ResultFromScode(sc);
        goto exit;
    }

exit:
    FreeBufferAndNull(&lpSPropValue);

    UlRelease(lpObject);

    return(hResult);
}


/***************************************************************************

    Name      : FillTableDataFromPropertyStore

    Purpose   : Fill in a TableData object from the property store

    Parameters: lpIAB
                lppta -> prop tags to get
                lpTableData

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT FillTableDataFromPropertyStore(LPIAB lpIAB, 
                                       LPSPropTagArray lppta, 
                                       LPTABLEDATA lpTableData) 
{
    HRESULT hResult = S_OK;
    SCODE sc;
    LPSRowSet lpSRowSet = NULL;
    LPSPropValue lpSPropValue = NULL;
    LPTSTR lpTemp = NULL;
    ULONG i, j, k;
    LPCONTENTLIST * lppContentList = NULL;
    LPCONTENTLIST lpContentList = NULL;
    ULONG ulContainers = 1;
    SPropertyRestriction PropRes = {0};
    ULONG nLen = 0;
    ULONG ulInvalidPropCount = 0;
    ULONG ulcPropCount;
    ULONG iToAdd;
    ULONG iPR_ENTRYID = (ULONG)-1;
    ULONG iPR_RECORD_KEY = (ULONG)-1;
    ULONG iPR_INSTANCE_KEY = (ULONG)-1;
    LPSPropTagArray lpptaNew = NULL;
    LPSPropTagArray lpptaRead;
    BOOL bUnicodeData = ((LPTAD)lpTableData)->bMAPIUnicodeTable;

    // Make certain that we have required properties:
    //   PR_ENTRYID
    //   PR_RECORD_KEY
    //   PR_INSTANCE_KEY

    // walk through pta looking for required props
    iToAdd = 3;
    for (i = 0; i < lppta->cValues; i++) {
        switch (lppta->aulPropTag[i]) {
            case PR_ENTRYID:
                iPR_ENTRYID = i;
                iToAdd--;
                break;

            case PR_RECORD_KEY:
                iPR_RECORD_KEY = i;
                iToAdd--;
                break;

            case PR_INSTANCE_KEY:
                iPR_INSTANCE_KEY = i;
                iToAdd--;
                break;
        }
    }

    if (iToAdd) {
        if (lpptaNew = LocalAlloc(LPTR, sizeof(SPropTagArray) + (lppta->cValues + iToAdd) * sizeof(DWORD))) {
            // Copy the caller's pta into our new one
            lpptaNew->cValues = lppta->cValues;
            CopyMemory(lpptaNew->aulPropTag, lppta->aulPropTag, lppta->cValues * sizeof(DWORD));

            // Add them on at the end.
            if (iPR_ENTRYID == (ULONG)-1) {
                iPR_ENTRYID = lpptaNew->cValues++;
                lpptaNew->aulPropTag[iPR_ENTRYID] = PR_NULL;
            }
            if (iPR_RECORD_KEY == (ULONG)-1) {
                iPR_RECORD_KEY = lpptaNew->cValues++;
                lpptaNew->aulPropTag[iPR_RECORD_KEY] = PR_NULL;
            }
            if (iPR_INSTANCE_KEY == (ULONG)-1) {
                iPR_INSTANCE_KEY = lpptaNew->cValues++;
                lpptaNew->aulPropTag[iPR_INSTANCE_KEY] = PR_NULL;
            }
            lpptaRead = lpptaNew;
        } else {
            hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
            goto exit;
        }
    } else {
        lpptaRead = lppta;
    }

    Assert(iPR_ENTRYID != (ULONG)-1);
    Assert(iPR_RECORD_KEY!= (ULONG)-1);
    Assert(iPR_INSTANCE_KEY != (ULONG)-1);

    //
    // Set filter criteria if none exists - we'll default to DisplayName
    //
    PropRes.ulPropTag = PR_DISPLAY_NAME;
    PropRes.relop = RELOP_EQ;
    PropRes.lpProp = NULL;

{
// The way we want GetContentsTable to behave is:
//
//  If no profilesAPI enabled and no override, then GetContentsTable works as before and returns
//      full set of contents for the current WAB [This is for the PAB container only]
// In cases where old clients dont know how to invoke the new API, the UI will have new stuff
// but the API should have the old stuff meaning that a GetContentsTable on the PAB 
// container should return full WAB contents. To make sure that the GetContentsTable on the
// PAB container doesn't contain full contents, caller can force this by passing in 
// WAB_ENABLE_PROFILES into the call to GetContentsTable...
//
//  If profilesAPI are enabled, then GetContentsTable only returns the contents of
//      the specified folder/container
//  unless the folder has a NULL entryid in which case we want to get ALL WAB contents
//      so we can pump them into the "All Contacts" ui item ..
// 
//  If ProfilesAPI and WAB_PROFILE_CONTENTS are specified and it's the PAB container
//      then we need to return all the contents pertaining to the current profile
//  
//
//
        SBinary sbEID = {0};
        LPSBinary lpsbEID = ((LPTAD)lpTableData)->pbinContEID;
        BOOL bProfileContents = FALSE;
        
        // Is this a 'new' WAB showing folders and stuff ?
        if(bIsWABSessionProfileAware(lpIAB))
        {
            // If this WAB is identity aware or we were asked to 
            // restrict the contents to a single container, then try to 
            // get the entryid for that container
            if( bAreWABAPIProfileAware(lpIAB) || 
                ((LPTAD)lpTableData)->bContainerContentsOnly)
            {
                if(!lpsbEID)
                    lpsbEID = &sbEID;
            }

            // if we earlier, during GetContentsTable specified that we
            // want the full contents for the current profile (which means
            // iterating through all the folders in this profile), we should
            // look into this ..
            if(((LPTAD)lpTableData)->bAllProfileContents)
            {
                ulContainers = lpIAB->cwabci;
                bProfileContents = TRUE;
            }
        }

        // Allocate a temporary list in which we will get each containers contents
        // seperately - later we will collate all these seperate content-lists 
        // together
        lppContentList = LocalAlloc(LMEM_ZEROINIT, sizeof(LPCONTENTLIST)*ulContainers);
        if(!lppContentList)
        {
            hResult = MAPI_E_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        //
        // Get the content list
        //
        if(!bProfileContents)
        {
            // if we don't care about profile and profile folders, 
            // just get the bunch'o'contents from the store
            if (HR_FAILED(hResult = ReadPropArray(lpIAB->lpPropertyStore->hPropertyStore,
                                            lpsbEID,
                                            &PropRes,
                                            AB_MATCH_PROP_ONLY | (bUnicodeData?AB_UNICODE:0),
                                            lpptaRead->cValues,
                                            (LPULONG)lpptaRead->aulPropTag,
                                            &(lppContentList[0])))) 
            {
                DebugTraceResult( TEXT("NewContentsTable:ReadPropArray"), hResult);
                goto exit;
            }
        }
        else
        {
            // We need to collate together all the contents of all the containers for this profile
            //
            // The first item is the Virtual PAB "Shared Contacts" folder .. we want the contents of this
            // item as part of this ContentsTable by default. This item has a special entryid of 0, NULL so we 
            // can diffrentiate it from the rest of the pack..
            //
            for(i=0;i<ulContainers;i++)
            {
                hResult = ReadPropArray(lpIAB->lpPropertyStore->hPropertyStore,
                                        lpIAB->rgwabci[i].lpEntryID ? lpIAB->rgwabci[i].lpEntryID : &sbEID,
                                        &PropRes,
                                        AB_MATCH_PROP_ONLY | (bUnicodeData?AB_UNICODE:0),
                                        lpptaRead->cValues,
                                        (LPULONG)lpptaRead->aulPropTag,
                                        &(lppContentList[i]));
                // ignore MAPI_E_NOT_FOUND errors here ...
                if(HR_FAILED(hResult))
                {
                    if(hResult == MAPI_E_NOT_FOUND)
                        hResult = S_OK;
                    else
                    {
                        DebugTraceResult( TEXT("NewContentsTable:ReadPropArray"), hResult);
                        goto exit;
                    }
                }
            }
        }
    }

    for(k=0;k<ulContainers;k++)
    {
        lpContentList = lppContentList[k];

        if(lpContentList)
        {
            // Now we need to move the information from the index to
            // the SRowSet.  In the process, we need to create a few computed
            // properties:
            //  PR_DISPLAY_TYPE ?
            //  PR_INSTANCE_KEY
            //  PR_RECORD_KEY
            // Allocate the SRowSet
            if (FAILED(sc = MAPIAllocateBuffer(sizeof(SRowSet) + lpContentList->cEntries * sizeof(SRow),
                                              &lpSRowSet))) 
            {
                DebugTrace(TEXT("Allocation of SRowSet failed\n"));
                hResult = ResultFromScode(sc);
                goto exit;
            }

            lpSRowSet->cRows = lpContentList->cEntries;

            for (i = 0; i < lpContentList->cEntries; i++) 
            {
                //
                // We look at each of the returned entries - if they dont have a prop
                // we set that prop to " "
                // (Assuming these are all string props)
                //
                lpSPropValue = lpContentList->aEntries[i].rgPropVals;
                ulcPropCount = lpContentList->aEntries[i].cValues;

                // DebugProperties(lpSPropValue, ulcPropCount, "Raw");
                for (j = 0; j < ulcPropCount; j++) 
                {
                    // Get rid of error valued properties
                    if (PROP_ERROR(lpSPropValue[j])) {
                        lpSPropValue[j].ulPropTag = PR_NULL;
                    }
                }

                // Make certain we have proper indicies.
                // For now, we will equate PR_INSTANCE_KEY and PR_RECORD_KEY to PR_ENTRYID.

                if(lpSPropValue[iPR_INSTANCE_KEY].ulPropTag != PR_INSTANCE_KEY)
                {
                    lpSPropValue[iPR_INSTANCE_KEY].ulPropTag = PR_INSTANCE_KEY;
                    SetSBinary( &lpSPropValue[iPR_INSTANCE_KEY].Value.bin,
                                lpSPropValue[iPR_ENTRYID].Value.bin.cb,
                                lpSPropValue[iPR_ENTRYID].Value.bin.lpb);
                }

                if(lpSPropValue[iPR_RECORD_KEY].ulPropTag != PR_RECORD_KEY)
                {
                    lpSPropValue[iPR_RECORD_KEY].ulPropTag = PR_RECORD_KEY;
                    SetSBinary( &lpSPropValue[iPR_RECORD_KEY].Value.bin,
                                lpSPropValue[iPR_ENTRYID].Value.bin.cb,
                                lpSPropValue[iPR_ENTRYID].Value.bin.lpb);
                }

                // Put it in the RowSet
                lpSRowSet->aRow[i].cValues = ulcPropCount;  // number of properties
                lpSRowSet->aRow[i].lpProps = lpSPropValue;  // LPSPropValue

            } //for i

            hResult = lpTableData->lpVtbl->HrModifyRows(lpTableData,0,lpSRowSet);

            FreeBufferAndNull(&lpSRowSet);
        } // for k
    }

exit:
    for(i=0;i<ulContainers;i++)
    {
        lpContentList = lppContentList[i];
        if (lpContentList) {
            FreePcontentlist(lpIAB->lpPropertyStore->hPropertyStore, lpContentList);
        }
    }

    if(lppContentList)
        LocalFree(lppContentList);

    if(lpptaNew)
        LocalFree(lpptaNew);

    return(hResult);
}


/***************************************************************************

    Name      : NewContentsTable

    Purpose   : Creates a new contents table

    Parameters:
                lpABContainer   - container being opened
                lpIAB           - AdrBook object
                ulFlags         - WAB_NO_CONTENTTABLE_DATA
                lpInteface ?
                lppTble         - returned table

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT NewContentsTable(LPABCONT lpABContainer,
  LPIAB lpIAB,
  ULONG ulFlags,
  LPCIID lpInterface,
  LPMAPITABLE * lppTable) {
    LPTABLEDATA lpTableData = NULL;
    HRESULT hResult = hrSuccess;
    SCODE sc;


#ifndef DONT_ADDREF_PROPSTORE
        if ((FAILED(sc = OpenAddRefPropertyStore(NULL, lpIAB->lpPropertyStore)))) {
            hResult = ResultFromScode(sc);
            goto exitNotAddRefed;
        }
#endif

    if (FAILED(sc = CreateTableData(
      NULL,                                 // LPCIID
      (ALLOCATEBUFFER FAR *) MAPIAllocateBuffer,
      (ALLOCATEMORE FAR *) MAPIAllocateMore,
      MAPIFreeBuffer,
      NULL,                                 // lpvReserved,
      TBLTYPE_DYNAMIC,                      // ulTableType,
      PR_RECORD_KEY,                        // ulPropTagIndexCol,
      (LPSPropTagArray)&ITableColumns,      // LPSPropTagArray lpptaCols,
      lpIAB,                                // lpvDataSource
      0,                                    // cbDataSource
      ((LPCONTAINER)lpABContainer)->pmbinOlk,
      ulFlags,
      &lpTableData))) {                     // LPTABLEATA FAR * lplptad
        DebugTrace(TEXT("CreateTable failed %x\n"), sc);
        hResult = ResultFromScode(sc);
        goto exit;
    }


    if (lpTableData) 
    {
        if(!(ulFlags & WAB_CONTENTTABLE_NODATA))
        {
            // Fill in the data from the property store
            if (hResult = FillTableDataFromPropertyStore(lpIAB,
              (LPSPropTagArray)&ITableColumns, lpTableData)) {
                DebugTraceResult( TEXT("NewContentsTable:FillTableFromPropertyStore"), hResult);
                goto exit;
            }
        }
    }

    if (hResult = lpTableData->lpVtbl->HrGetView(lpTableData,
      NULL,                     // LPSSortOrderSet lpsos,
      ContentsViewGone,         //  CALLERRELEASE FAR *	lpfReleaseCallback,
      0,                        //  ULONG				ulReleaseData,
      lppTable)) {              //  LPMAPITABLE FAR *	lplpmt)
        goto exit;
    }

    // Replace the vtable with our new one that overrides SetColumns
    (*lppTable)->lpVtbl = (IMAPITableVtbl FAR *)&vtblCONTVUE;


exit:
#ifndef DONT_ADDREF_PROPSTORE
    ReleasePropertyStore(lpIAB->lpPropertyStore);
exitNotAddRefed:
#endif

    // Cleanup table if failure
    if (HR_FAILED(hResult)) {
        if (lpTableData) {
            UlRelease(lpTableData);
        }
    }

    return(hResult);
}


/*
 *	This is a callback function, invoked by itable.dll when its
 *	caller does the last release on a view of the contents table. We
 *	use it to know when to release the underlying table data.
 */
void STDAPICALLTYPE
ContentsViewGone(ULONG ulContext, LPTABLEDATA lptad, LPMAPITABLE lpVue)
{

#ifdef OLD_STUFF
   LPISPAM pispam = (LPISPAM)ulContext;

	if (FBadUnknown((LPUNKNOWN) pispam)
		|| IsBadWritePtr(pispam, sizeof(ISPAM))
		|| pispam->cRefTad == 0
		|| FBadUnknown(pispam->ptad))
	{
		DebugTrace(TEXT("ContentsViewGone: contents table was apparently already released\n"));
		return;
	}

	if (pispam->ptad != lptad)
	{
		TrapSz( TEXT("ContentsViewGone: TAD mismatch on VUE release!"));
	}
	else if (--(pispam->cRefTad) == 0)
	{
		pispam->ptad = NULL;
		UlRelease(lptad);
	}
#endif // OLD_STUFF
    UlRelease(lptad);
    return;
    IF_WIN32(UNREFERENCED_PARAMETER(ulContext);)
    IF_WIN32(UNREFERENCED_PARAMETER(lpVue);)
}


/*============================================================================
 -	CONTVUE::SetColumns()
 -
 *		Replaces the current column set with a copy of the specified column set
 *		and frees the old column set.
 */

STDMETHODIMP
CONTVUE_SetColumns(
	LPVUE			lpvue,
	LPSPropTagArray	lpptaCols,
	ULONG			ulFlags )
{
    HRESULT        hResult = hrSuccess;


#if !defined(NO_VALIDATION)
    VALIDATE_OBJ(lpvue,CONTVUE_,SetColumns,lpVtbl);

//    Validate_IMAPITable_SetColumns( lpvue, lpptaCols, ulFlags );     // Commented by YST
#endif

    Assert(lpvue->lptadParent->lpvDataSource);

    // Re-read the table data
    if (lpvue->lptadParent && (hResult = FillTableDataFromPropertyStore(
      (LPIAB)lpvue->lptadParent->lpvDataSource,
      lpptaCols,
      (LPTABLEDATA)lpvue->lptadParent))) {
        DebugTraceResult( TEXT("CONTVUE_SetColumns:FillTableFromPropertyStore"), hResult);
        return(hResult);
    }

    return(VUE_SetColumns(lpvue, lpptaCols, ulFlags));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\distlist.c ===
/*
 *	DistList.C - Implement the IDistList object
 *	
 *	
 */

#include "_apipch.h"

STDMETHODIMP DISTLIST_OpenProperty(LPCONTAINER lpCONTAINER,
  ULONG ulPropTag,
  LPCIID lpiid,
  ULONG ulInterfaceOptions,
  ULONG ulFlags,
  LPUNKNOWN * lppUnk);
STDMETHODIMP DISTLIST_GetContentsTable(LPCONTAINER lpCONTAINER,
  ULONG ulFlags,
  LPMAPITABLE * lppTable);
STDMETHODIMP DISTLIST_GetHierarchyTable(LPCONTAINER lpCONTAINER,
  ULONG ulFlags,
  LPMAPITABLE * lppTable);
STDMETHODIMP DISTLIST_OpenEntry(LPCONTAINER lpCONTAINER,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  LPCIID lpInterface,
  ULONG ulFlags,
  ULONG * lpulObjType,
  LPUNKNOWN * lppUnk);
STDMETHODIMP DISTLIST_SetSearchCriteria(LPCONTAINER lpCONTAINER,
  LPSRestriction lpRestriction,
  LPENTRYLIST lpContainerList,
  ULONG ulSearchFlags);
STDMETHODIMP DISTLIST_GetSearchCriteria(LPCONTAINER lpCONTAINER,
  ULONG ulFlags,
  LPSRestriction FAR * lppRestriction,
  LPENTRYLIST FAR * lppContainerList,
  ULONG FAR * lpulSearchState);
STDMETHODIMP DISTLIST_CreateEntry(LPCONTAINER lpCONTAINER,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  ULONG ulCreateFlags,
  LPMAPIPROP FAR * lppMAPIPropEntry);
STDMETHODIMP DISTLIST_CopyEntries(LPCONTAINER lpCONTAINER,
  LPENTRYLIST lpEntries,
  ULONG ulUIParam,
  LPMAPIPROGRESS lpProgress,
  ULONG ulFlags);
STDMETHODIMP DISTLIST_DeleteEntries(LPCONTAINER lpCONTAINER,
  LPENTRYLIST lpEntries,
  ULONG ulFlags);
STDMETHODIMP DISTLIST_ResolveNames(LPCONTAINER lpCONTAINER,
  LPSPropTagArray lptagaColSet,
  ULONG ulFlags,
  LPADRLIST lpAdrList,
  LPFlagList lpFlagList);


HRESULT HrNewDLENTRY(LPCONTAINER lpCONTAINER,
  LPMAPIPROP lpOldEntry,    // Old entry to copy from
  ULONG ulCreateFlags,
  LPVOID *lppDLENTRY);

/*
 *  Root jump table is defined here...
 */

CONTAINER_Vtbl vtblDISTLIST =
{
    VTABLE_FILL
    (CONTAINER_QueryInterface_METHOD *)     IAB_QueryInterface,
    (CONTAINER_AddRef_METHOD *)             WRAP_AddRef,
    (CONTAINER_Release_METHOD *)            CONTAINER_Release,
    (CONTAINER_GetLastError_METHOD *)       IAB_GetLastError,
    (CONTAINER_SaveChanges_METHOD *)        MailUser_SaveChanges,
    (CONTAINER_GetProps_METHOD *)           WRAP_GetProps,
    (CONTAINER_GetPropList_METHOD *)        WRAP_GetPropList,
    (CONTAINER_OpenProperty_METHOD *)       DISTLIST_OpenProperty,
    (CONTAINER_SetProps_METHOD *)           WRAP_SetProps,
    (CONTAINER_DeleteProps_METHOD *)        WRAP_DeleteProps,
    (CONTAINER_CopyTo_METHOD *)             WRAP_CopyTo,
    (CONTAINER_CopyProps_METHOD *)          WRAP_CopyProps,
    (CONTAINER_GetNamesFromIDs_METHOD *)    MailUser_GetNamesFromIDs,
    (CONTAINER_GetIDsFromNames_METHOD *)    MailUser_GetIDsFromNames,
    (CONTAINER_GetContentsTable_METHOD *)   DISTLIST_GetContentsTable,
    (CONTAINER_GetHierarchyTable_METHOD *)  DISTLIST_GetHierarchyTable,
    (CONTAINER_OpenEntry_METHOD *)          DISTLIST_OpenEntry,
    (CONTAINER_SetSearchCriteria_METHOD *)  DISTLIST_SetSearchCriteria,
    (CONTAINER_GetSearchCriteria_METHOD *)  DISTLIST_GetSearchCriteria,
    (CONTAINER_CreateEntry_METHOD *)        DISTLIST_CreateEntry,
    (CONTAINER_CopyEntries_METHOD *)        DISTLIST_CopyEntries,
    (CONTAINER_DeleteEntries_METHOD *)      DISTLIST_DeleteEntries,
    (CONTAINER_ResolveNames_METHOD *)       DISTLIST_ResolveNames
};


enum {
    iwdePR_WAB_DL_ENTRIES, // Very important - keep DL_ENTRIES and DL_ONEOFFS togethor .. we use them as contiguous loop indexes somewhere
    iwdePR_WAB_DL_ONEOFFS,
    iwdePR_ENTRYID,
    iwdeMax
};

SizedSPropTagArray(iwdeMax, tagaWabDLEntries) =
{
    iwdeMax,
    {
        PR_WAB_DL_ENTRIES,
        PR_NULL, // should be PR_WAB_DL_ONEOFFS
        PR_ENTRYID,
    }
};



/***************************************************
 *
 *  The actual ABContainer methods
 */
/* ---------
 * IMAPIProp
 */


STDMETHODIMP
DISTLIST_OpenProperty(LPCONTAINER lpCONTAINER,
  ULONG ulPropTag,
  LPCIID lpiid,
  ULONG ulInterfaceOptions,
  ULONG ulFlags,
  LPUNKNOWN * lppUnk)
{
    LPIAB lpIAB;
    LPSTR lpszMessage = NULL;
    ULONG ulLowLevelError = 0;
    HRESULT hr;

#ifdef	PARAMETER_VALIDATION
    // Validate parameters

    // Check to see if it has a jump table
    if (IsBadReadPtr(lpCONTAINER, sizeof(LPVOID))) {
        // No jump table found
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if ((ulInterfaceOptions & ~(MAPI_UNICODE)) || (ulFlags & ~(MAPI_DEFERRED_ERRORS))) {
        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (FBadOpenProperty(lpRoot, ulPropTag, lpiid, ulInterfaceOptions, ulFlags, lppUnk)) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
#endif	// PARAMETER_VALIDATION


    EnterCriticalSection(&lpCONTAINER->cs);

    lpIAB = lpCONTAINER->lpIAB;

    //
    //  Check to see if I need a display table
    //

    if (ulPropTag == PR_CREATE_TEMPLATES) {
        Assert(FALSE);  // Not implemented
        hr = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
        goto err;

    } else if (ulPropTag == PR_CONTAINER_CONTENTS) {
        //
        //  Check to see if they're expecting a table interface
        //
        if (memcmp(lpiid, &IID_IMAPITable, sizeof(IID))) {
            hr = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
            goto err;
        }

        hr = DISTLIST_GetContentsTable(lpCONTAINER, ulInterfaceOptions, (LPMAPITABLE *)lppUnk);
        goto err;
    } else if (ulPropTag == PR_CONTAINER_HIERARCHY) {
        //
        //  Check to see if they're expecting a table interface
        //
        if (memcmp(lpiid, &IID_IMAPITable, sizeof(IID))) {
            hr = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
            goto err;
        }

        hr = DISTLIST_GetHierarchyTable(lpCONTAINER, ulInterfaceOptions, (LPMAPITABLE *) lppUnk);
        goto err;
    }

    //
    //  Don't recognize the property they want opened.
    //

    hr = ResultFromScode(MAPI_E_NO_SUPPORT);

err:
    LeaveCriticalSection(&lpCONTAINER->cs);

    DebugTraceResult(DISTLIST_OpenProperty, hr);
    return(hr);
}


/*************************************************************************
 *
 *
 -  DISTLIST_GetContentsTable
 -
 *
 *
 *  ulFlags - 0 or MAPI_UNICODE
 *
 */
STDMETHODIMP
DISTLIST_GetContentsTable(LPCONTAINER lpCONTAINER,
  ULONG ulFlags,
  LPMAPITABLE * lppTable)
{

   LPTABLEDATA lpTableData = NULL;
   HRESULT hResult = hrSuccess;
   SCODE sc;
   LPSRowSet lpSRowSet = NULL;
   LPSPropValue lpSPropValue = NULL;
   LPTSTR lpTemp = NULL;
   ULONG ulCount = 0;
   ULONG i,j;
   ULONG ulcProps;
   SBinaryArray MVbin;
   LPSPropValue lpspv = NULL;
   ULONG cbEID, cbNewKey;
   LPBYTE lpbNewKey;
   LPSPropTagArray lpTableColumnsTemplate;
	
#ifdef	PARAMETER_VALIDATION
    // Check to see if it has a jump table
    if (IsBadReadPtr(lpCONTAINER, sizeof(LPVOID))) {
        // No jump table found
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags & ~(MAPI_DEFERRED_ERRORS|MAPI_UNICODE)) {
        DebugTraceArg(DISTLIST_GetContentsTable,  TEXT("Unknown flags"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (IsBadWritePtr(lppTable, sizeof(LPMAPITABLE))) {
        DebugTraceArg(DISTLIST_GetContentsTable,  TEXT("Invalid Table parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
#endif	// PARAMETER_VALIDATION


    // [PaulHi] 2/25/99  Raid 73170  Honor the MAPI_UNICODE bit in 
    // ulFlags.  If this bit isn't set then use the ANSI version of
    // the ITableColumns so ANSI property strings are returned to 
    // the user.
    if (ulFlags & MAPI_UNICODE)
        lpTableColumnsTemplate = (LPSPropTagArray)&ITableColumns;
    else
        lpTableColumnsTemplate = (LPSPropTagArray)&ITableColumns_A;

    sc = CreateTableData(
            NULL,                           // LPIID
            (ALLOCATEBUFFER FAR *) MAPIAllocateBuffer,
            (ALLOCATEMORE FAR *) MAPIAllocateMore,
            MAPIFreeBuffer,
            NULL,                           // lpvReserved
            TBLTYPE_DYNAMIC,                // ulTableType
            PR_RECORD_KEY,                  // ulPropTagIndexCol
            lpTableColumnsTemplate,         // LPSPropTagArray lpptaCols
            NULL,                           // lpvDataSource
            0,                              // cbDataSource
            NULL,                           // pbinContEID
            ulFlags,                        // ulFlags
            &lpTableData);                  // lplptad

    if ( FAILED(sc) )
    {
        DebugTrace(TEXT("DISTLIST_GetContentsTable:CreateTableData -> %x\n"), sc);
        hResult = ResultFromScode(sc);
        goto exit;
    }

    if (lpTableData) 
    {
        tagaWabDLEntries.aulPropTag[iwdePR_WAB_DL_ONEOFFS] = PR_WAB_DL_ONEOFFS;

        // Get the index to the distribution list from PR_WAB_DL_ENTRIES
        if (HR_FAILED(hResult = lpCONTAINER->lpPropData->lpVtbl->GetProps(lpCONTAINER->lpPropData,
                                                                          (LPSPropTagArray)&tagaWabDLEntries,
                                                                          MAPI_UNICODE, &ulcProps, &lpspv))) 
        {
            DebugTraceResult( TEXT("DISTLIST_GetContentsTable:GetProps"), hResult);
            goto exit;
        }

        if (lpspv[iwdePR_WAB_DL_ENTRIES].ulPropTag == PR_WAB_DL_ENTRIES)
            ulCount += lpspv[iwdePR_WAB_DL_ENTRIES].Value.MVbin.cValues;

        if (lpspv[iwdePR_WAB_DL_ONEOFFS].ulPropTag == PR_WAB_DL_ONEOFFS) 
            ulCount += lpspv[iwdePR_WAB_DL_ONEOFFS].Value.MVbin.cValues;

        if(ulCount)
        {
            // DL has contents.
            // Now we need to move the information from the DL to
            // the SRowSet.  In the process, we need to create a few computed
            // properties:
            //  PR_INSTANCE_KEY
            //  PR_RECORD_KEY
            
            // Allocate the SRowSet
            if (FAILED(sc = MAPIAllocateBuffer(sizeof(SRowSet) + ulCount * sizeof(SRow), &lpSRowSet))) 
            {
                DebugTrace(TEXT("Allocation of SRowSet failed\n"));
                hResult = ResultFromScode(sc);
                goto exit;
            }

            lpSRowSet->cRows = 0;

            // Look at each entry in the PR_WAB_DL_ENTRIES
            for(j=iwdePR_WAB_DL_ENTRIES;j<=iwdePR_WAB_DL_ONEOFFS;j++)
            {
                if( (lpspv[j].ulPropTag != PR_WAB_DL_ENTRIES &&  lpspv[j].ulPropTag != PR_WAB_DL_ONEOFFS) ||
                    lpspv[j].Value.MVbin.cValues == 0)
                    continue;

                MVbin = lpspv[j].Value.MVbin;

                for (i = 0; i < MVbin.cValues; i++) 
                {
                    if (HR_FAILED(hResult = GetEntryProps((LPABCONT)lpCONTAINER,  // container object
                                                          MVbin.lpbin[i].cb,
                                                          (LPENTRYID)MVbin.lpbin[i].lpb,
                                                          lpTableColumnsTemplate,                   // default columns
                                                          lpSRowSet,                                // allocate more on here
                                                          ulFlags,                                  // 0 or MAPI_UNICODE
                                                          &ulcProps,                                // return count here
                                                          &lpSPropValue)))                          // return props here
                    {
                        DebugTraceResult( TEXT("DISTLIST_GetContentsTable:GetEntryProps\n"), hResult);
                        hResult = hrSuccess;
                        continue;
                    }

                    Assert(ulcProps == itcMax);

                    // Make certain we have proper indicies.
                    // PR_INSTANCE_KEY and PR_RECORD_KEY must be unique within the table!
                    // They can be the same, though.
                    // Append the index onto the entryid.
                    cbEID = lpSPropValue[itcPR_ENTRYID].Value.bin.cb;
                    cbNewKey = cbEID + sizeof(i);

                    if (FAILED(sc = MAPIAllocateMore(cbNewKey, lpSRowSet, &lpbNewKey))) {
                        hResult = ResultFromScode(sc);
                        DebugTrace(TEXT("GetContentsTable:MAPIAllocMore -> %x"), sc);
                        goto exit;
                    }
                    memcpy(lpbNewKey, lpSPropValue[itcPR_ENTRYID].Value.bin.lpb, cbEID);
                    memcpy(lpbNewKey + cbEID, &i, sizeof(i));

                    lpSPropValue[itcPR_INSTANCE_KEY].ulPropTag = PR_INSTANCE_KEY;
                    lpSPropValue[itcPR_INSTANCE_KEY].Value.bin.cb = cbNewKey;
                    lpSPropValue[itcPR_INSTANCE_KEY].Value.bin.lpb = lpbNewKey;

                    lpSPropValue[itcPR_RECORD_KEY].ulPropTag = PR_RECORD_KEY;
                    lpSPropValue[itcPR_RECORD_KEY].Value.bin.cb = cbNewKey;
                    lpSPropValue[itcPR_RECORD_KEY].Value.bin.lpb = lpbNewKey;


                    // Put it in the RowSet
                    lpSRowSet->aRow[lpSRowSet->cRows].cValues = ulcProps;      // number of properties
                    lpSRowSet->aRow[lpSRowSet->cRows].lpProps = lpSPropValue;  // LPSPropValue
                    lpSRowSet->cRows++;

                } // i
            }// j

            hResult = lpTableData->lpVtbl->HrModifyRows(lpTableData, 0, lpSRowSet);
        }

        hResult = lpTableData->lpVtbl->HrGetView(lpTableData,
                                                  NULL,                     // LPSSortOrderSet lpsos,
                                                  ContentsViewGone,         //  CALLERRELEASE FAR *	lpfReleaseCallback,
                                                  0,                        //  ULONG				ulReleaseData,
                                                  lppTable);                //  LPMAPITABLE FAR *	lplpmt)
    }
exit:
    FreeBufferAndNull(&lpspv);
    FreeBufferAndNull(&lpSRowSet);

    // Cleanup table if failure
    if (HR_FAILED(hResult)) {
        UlRelease(lpTableData);
    }

    return(hResult);
}

/*************************************************************************
 *
 *
 -	DISTLIST_GetHierarchyTable
 -
 *  Returns the merge of all the root hierarchy tables
 *
 *
 *
 */

STDMETHODIMP
DISTLIST_GetHierarchyTable (LPCONTAINER lpCONTAINER,
  ULONG ulFlags,
  LPMAPITABLE * lppTable)
{
    LPTSTR lpszMessage = NULL;
    ULONG ulLowLevelError = 0;
    HRESULT hr = hrSuccess;

#ifdef OLD_STUFF
#ifdef	PARAMETER_VALIDATION
    // Validate parameters
    // Check to see if it has a jump table
    if (IsBadReadPtr(lpCONTAINER, sizeof(LPVOID))) {
        // No jump table found
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }


    // See if I can set the return variable
    if (IsBadWritePtr (lppTable, sizeof (LPMAPITABLE))) {
        hr = ResultFromScode(MAPI_E_INVALID_PARAMETER);
        return(hr);
    }

    // Check flags:
    // The only valid flags are CONVENIENT_DEPTH and MAPI_DEFERRED_ERRORS
    if (ulFlags & ~(CONVENIENT_DEPTH | MAPI_DEFERRED_ERRORS | MAPI_UNICODE)) {
        DebugTraceArg(DISTLIST_GetHierarchyTable ,  TEXT("Unknown flags used"));
//        return ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
    }

#endif

    EnterCriticalSection(&lpCONTAINER->cs);

    if (lpCONTAINER->ulType != AB_DL) {
        //
        //  Wrong version of this object.  Pretend this object doesn't exist.
        //
        hr = ResultFromScode(MAPI_E_NO_SUPPORT);
        SetMAPIError(lpCONTAINER, hr, IDS_NO_HIERARCHY_TABLE, NULL, 0,
          0, 0, NULL);

        goto out;
    }

    //
    //  Check to see if we already have a table
    //
    EnterCriticalSection(&lpCONTAINER->lpIAB->cs);

    if (! lpCONTAINER->lpIAB->lpTableData) {
        //
        //  Open all the root level containers and merge their
        //  root level hierarchies.
        hr = MergeHierarchy(lpCONTAINER, lpCONTAINER->lpIAB, ulFlags);
        if (hr != hrSuccess) {
            LeaveCriticalSection(&lpCONTAINER->lpIAB->cs);
            goto out;
        }
    }
    LeaveCriticalSection(&lpCONTAINER->lpIAB->cs);

    //
    //  Get a view from the TAD
    //
    if (HR_FAILED(hr = lpCONTAINER->lpIAB->lpTableData->lpVtbl->HrGetView(
      lpCONTAINER->lpIAB->lpTableData,
      (LPSSortOrderSet)&sosPR_ROWID,
      NULL,
      0,
      lppTable))) {
        DebugTrace(TEXT("IAB_GetHierarchyTable Get Tad View failed\n"));
        goto out;
    }

#ifdef DEBUG
    if (hr == hrSuccess) {
        MAPISetBufferName(*lppTable,  TEXT("MergeHier VUE Object"));
    }
#endif

    // If the convenient depth flag was not specified we restrict on
    // PR_DEPTH == 1.

    if (! (ulFlags & CONVENIENT_DEPTH)) {
        SRestriction restrictDepth;
        SPropValue spvDepth;

        spvDepth.ulPropTag = PR_DEPTH;
        spvDepth.Value.l = 0;

        restrictDepth.rt = RES_PROPERTY;
        restrictDepth.res.resProperty.relop = RELOP_EQ;
        restrictDepth.res.resProperty.ulPropTag = PR_DEPTH;
        restrictDepth.res.resProperty.lpProp = &spvDepth;

        if (HR_FAILED(hr = (*lppTable)->lpVtbl->Restrict(*lppTable, &restrictDepth, 0))) {
            DebugTrace(TEXT("IAB_GetHierarchyTable restriction failed\n"));
            goto out;
        }
    }
out:
    LeaveCriticalSection(&lpCONTAINER->cs);

#endif // OLD_STUFF

    hr = ResultFromScode(MAPI_E_NO_SUPPORT);

    DebugTraceResult(DISTLIST_GetHierarchyTable, hr);
    return(hr);
}


/*************************************************************************
 *
 *
 -  DISTLIST_OpenEntry
 -
 *  Just call ABP_OpenEntry
 *
 *
 *
 */
STDMETHODIMP
DISTLIST_OpenEntry(LPCONTAINER lpCONTAINER,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  LPCIID lpInterface,
  ULONG ulFlags,
  ULONG * lpulObjType,
  LPUNKNOWN * lppUnk)
{
#ifdef	PARAMETER_VALIDATION
    //  Validate the object.
    if (BAD_STANDARD_OBJ(lpCONTAINER, DISTLIST_, OpenEntry, lpVtbl)) {
        // jump table not large enough to support this method
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check the entryid parameter. It needs to be big enough to hold an entryid.
    // Null entryids are valid
/*
    if (lpEntryID) {
        if (cbEntryID < offsetof(ENTRYID, ab) || IsBadReadPtr((LPVOID)lpEntryID, (UINT)cbEntryID)) {
            DebugTraceArg(DISTLIST_OpenEntry,  TEXT("lpEntryID fails address check"));
            return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
        }

        //NFAssertSz(FValidEntryIDFlags(lpEntryID->abFlags),
        //  "Undefined bits set in EntryID flags\n");
    }
*/
    // Don't check the interface parameter unless the entry is something
    // MAPI itself handles. The provider should return an error if this
    // parameter is something that it doesn't understand.
    // At this point, we just make sure it's readable.

    if (lpInterface && IsBadReadPtr(lpInterface, sizeof(IID))) {
        DebugTraceArg(DISTLIST_OpenEntry,  TEXT("lpInterface fails address check"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }	

    if (ulFlags & ~(MAPI_MODIFY | MAPI_DEFERRED_ERRORS | MAPI_BEST_ACCESS)) {
        DebugTraceArg(DISTLIST_OpenEntry,  TEXT("Unknown flags used"));
///        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (IsBadWritePtr((LPVOID)lpulObjType, sizeof(ULONG))) {
        DebugTraceArg(DISTLIST_OpenEntry,  TEXT("lpulObjType"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (IsBadWritePtr((LPVOID)lppUnk, sizeof(LPUNKNOWN))) {
        DebugTraceArg(DISTLIST_OpenEntry,  TEXT("lppUnk"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif	// PARAMETER_VALIDATION

    // Should just call IAB::OpenEntry()...
    return lpCONTAINER->lpIAB->lpVtbl->OpenEntry(lpCONTAINER->lpIAB,
      cbEntryID,
      lpEntryID,
      lpInterface,
      ulFlags,
      lpulObjType,
      lppUnk);
}


STDMETHODIMP
DISTLIST_SetSearchCriteria(LPCONTAINER lpCONTAINER,
  LPSRestriction lpRestriction,
  LPENTRYLIST lpContainerList,
  ULONG ulSearchFlags)
{
    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


STDMETHODIMP
DISTLIST_GetSearchCriteria(LPCONTAINER lpCONTAINER,
  ULONG ulFlags,
  LPSRestriction FAR * lppRestriction,
  LPENTRYLIST FAR * lppContainerList,
  ULONG FAR * lpulSearchState)
{
	return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


/***************************************************************************

    Name      : DISTLIST_CreateEntry

    Purpose   : Add an entry in this Distribution List container

    Parameters: cbEntryID = size of lpEntryID
                lpEntryID -> EntryID to add to distribution list.
                ulCreateFlags = {CREATE_CHECK_DUP_STRICT,
                                CREATE_CHECK_DUP_LOOSE,
                                CREATE_REPLACE,
                                CREATE_MERGE}
                lppEntry -> Returned lpMAPIPROP object containing
                  the properties of the added entry.

    Returns   : HRESULT

    Comment   : Caller MUST SaveChanges on the returned IMAPIPROP object before
                this change will be saved.

                Caller has no ability to SetProps the properties in the returned
                object.

                Caller must Release the returned object.

                Unlike the PAB, the WAB stores Distribution Lists by reference.
                The contents of the container are stored in PR_WAB_DL_ENTRIES.

***************************************************************************/
STDMETHODIMP
DISTLIST_CreateEntry(LPCONTAINER lpCONTAINER,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  ULONG ulCreateFlags,
  LPMAPIPROP FAR * lppEntry)
{
    HRESULT hResult;
    LPMAILUSER lpOldEntry = NULL;
    ULONG ulObjectType;

#ifdef PARAMETER_VALIDATION

    // Validate the object.
    if (BAD_STANDARD_OBJ(lpCONTAINER, DISTLIST_, CreateEntry, lpVtbl)) {
        // jump table not large enough to support this method
        DebugTraceArg(DISTLIST_CreateEntry,  TEXT("Bad object/Vtbl"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check the entryid parameter. It needs to be big enough to hold an entryid.
    // Null entryid are bad
/*
    if (lpEntryID) {
        if (cbEntryID < offsetof(ENTRYID, ab) || IsBadReadPtr((LPVOID)lpEntryID, (UINT)cbEntryID)) {
            DebugTraceArg(DISTLIST_CreateEntry,  TEXT("lpEntryID fails address check"));
            return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
        }

        //NFAssertSz(FValidEntryIDFlags(lpEntryID->abFlags),
        //  "Undefined bits set in EntryID flags\n");
    } else {
        DebugTraceArg(DISTLIST_CreateEntry,  TEXT("lpEntryID NULL"));
        return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
    }
*/
    if (ulCreateFlags & ~(CREATE_CHECK_DUP_STRICT | CREATE_CHECK_DUP_LOOSE | CREATE_REPLACE | CREATE_MERGE)) {
        DebugTraceArg(DISTLIST_CreateEntry,  TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (IsBadWritePtr(lppEntry, sizeof(LPMAPIPROP))) {
        DebugTraceArg(DISTLIST_CreateEntry,  TEXT("Bad MAPI Property write parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
				
#endif	// PARAMETER_VALIDATION
    *lppEntry = NULL;

    if (cbEntryID == 0 || lpEntryID == NULL) {
        DebugTrace(TEXT("DISTLIST_CreateEntry: NULL EntryID passed in\n"));
        hResult = ResultFromScode(MAPI_E_INVALID_ENTRYID);
        goto exit;
    }

    // Open and validate the entry.  Should NOT allow default entryid's,
    // root entryid, etc.  Must be a one-off, mailuser or distlist.
    if (hResult = lpCONTAINER->lpVtbl->OpenEntry(lpCONTAINER,
      cbEntryID,
      lpEntryID,
      NULL,
      0,                // ulFlags: Read only
      &ulObjectType,
      (LPUNKNOWN *)&lpOldEntry)) {
        DebugTrace(TEXT("DISTLIST_CreateEntry: OpenEntry -> %x\n"), GetScode(hResult));
        goto exit;
    }

    if (ulObjectType != MAPI_MAILUSER && ulObjectType != MAPI_DISTLIST) {
        DebugTrace(TEXT("DISTLIST_CreateEntry: bad object type passed in\n"));
        hResult = ResultFromScode(MAPI_E_INVALID_ENTRYID);
        goto exit;
    }

    if (hResult = HrNewDLENTRY(lpCONTAINER,
      (LPMAPIPROP)lpOldEntry,           // Old entry to copy from
      ulCreateFlags,
      (LPVOID *)lppEntry)) {
        goto exit;
    }

exit:
    UlRelease(lpOldEntry);

    if (HR_FAILED(hResult) && *lppEntry) {
        UlRelease(*lppEntry);
        *lppEntry = NULL;
    }

    return(hResult);
}


/*
 -	CopyEntries
 -
 *	Copies a list of entries into this container...  Since you can't
 *	do that with this container we just return not supported.
 */

STDMETHODIMP
DISTLIST_CopyEntries(LPCONTAINER lpCONTAINER,
  LPENTRYLIST lpEntries,
  ULONG ulUIParam,
  LPMAPIPROGRESS lpProgress,
  ULONG ulFlags)
{
	return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


/*
 -  DeleteEntries
 -
 *
 *  Deletes entries within this container.
 */
STDMETHODIMP
DISTLIST_DeleteEntries(LPCONTAINER lpCONTAINER,
  LPENTRYLIST lpEntries,
  ULONG ulFlags)
{
    ULONG i, iEntries = (ULONG)-1, iOneOffs = (ULONG)-1;
    HRESULT hResult = hrSuccess;
    ULONG cDeleted = 0;
    ULONG cToDelete;
    ULONG cValues;
    LPSPropValue lpspv = NULL;

    SizedSPropTagArray(1, tagaDLOneOffsProp) =
    {
        1, PR_WAB_DL_ONEOFFS,
    };


#ifdef PARAMETER_VALIDATION

    if (BAD_STANDARD_OBJ(lpCONTAINER, DISTLIST_, DeleteEntries, lpVtbl)) {
        //  jump table not large enough to support this method
        DebugTraceArg(DISTLIST_DeleteEntries,  TEXT("Bad object/vtbl"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // ensure we can read the container list
    if (FBadEntryList(lpEntries)) {
        DebugTraceArg(DISTLIST_DeleteEntries,  TEXT("Bad Entrylist parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags) {
        DebugTraceArg(DISTLIST_CreateEntry,  TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }
	
#endif	// PARAMETER_VALIDATION

    // List of entryids is in lpEntries.  This is a counted array of
    // entryid SBinary structs.

    if (! (cToDelete = lpEntries->cValues)) {
        goto exit;                              // nothing to delete
    }

    if (HR_FAILED(hResult = lpCONTAINER->lpPropData->lpVtbl->GetProps(lpCONTAINER->lpPropData,
      NULL,
      MAPI_UNICODE,
      &cValues,
      &lpspv))) {
        DebugTraceResult( TEXT("DISTLIST_DeleteEntries:GetProps"), hResult);
        goto exit;
    }

    // Find the PR_WAB_DL_ENTRIES
    for (i = 0; i < cValues; i++) 
    {
        if (lpspv[i].ulPropTag == PR_WAB_DL_ENTRIES) 
            iEntries = i;
        else if(lpspv[i].ulPropTag == PR_WAB_DL_ONEOFFS) 
            iOneOffs = i;
    }

    // If there is no PR_WAB_DL_ENTRIES, then this DL contains no entries and we can't delete them.
    if (iEntries == (ULONG)-1 && iOneOffs == (ULONG)-1) 
    {
        hResult = ResultFromScode(MAPI_W_PARTIAL_COMPLETION);
        goto exit;
    }

    // Delete each entry
    if(iEntries != (ULONG)-1)
    {
        for (i = 0; i < cToDelete; i++) 
        {
            if (! RemovePropFromMVBin(lpspv, cValues, iEntries, lpEntries->lpbin[i].lpb, lpEntries->lpbin[i].cb)) 
            {
                cDeleted++;
                if (lpspv[iEntries].ulPropTag == PR_NULL) 
                {
                    // remove the property
                    if (HR_FAILED(hResult = lpCONTAINER->lpPropData->lpVtbl->DeleteProps(lpCONTAINER->lpPropData, (LPSPropTagArray)&tagaDLEntriesProp, NULL))) 
                    {
                        DebugTraceResult( TEXT("DISTLIST_DeleteEntries: DeleteProps on IProp"), hResult);
                        goto exit;
                    }
                    break;
                }
            }
        }
    }

    if(iOneOffs != (ULONG)-1)
    {
        for (i = 0; i < cToDelete; i++) 
        {
            if (! RemovePropFromMVBin(lpspv, cValues, iOneOffs, lpEntries->lpbin[i].lpb, lpEntries->lpbin[i].cb)) 
            {
                cDeleted++;
                if (lpspv[iOneOffs].ulPropTag == PR_NULL) 
                {
                    // remove the property
                    if (HR_FAILED(hResult = lpCONTAINER->lpPropData->lpVtbl->DeleteProps(lpCONTAINER->lpPropData, (LPSPropTagArray)&tagaDLOneOffsProp, NULL))) 
                    {
                        DebugTraceResult( TEXT("DISTLIST_DeleteEntries: DeleteProps on IProp"), hResult);
                        goto exit;
                    }
                    break;
                }
            }
        }
    }


    // Set the properties back
    if (HR_FAILED(hResult = lpCONTAINER->lpPropData->lpVtbl->SetProps(lpCONTAINER->lpPropData, cValues, lpspv, NULL))) 
    {
        DebugTraceResult( TEXT("DISTLIST_DeleteEntries: SetProps on IProp"), hResult);
        goto exit;
    }

    // Save the Distribution list to disk
    if (hResult = lpCONTAINER->lpVtbl->SaveChanges(lpCONTAINER, KEEP_OPEN_READWRITE)) 
    {
        DebugTraceResult( TEXT("DISTLIST_DeleteEntries:SaveChanges"), hResult);
    }

    if (! hResult) 
    {
        if (cDeleted != cToDelete) 
        {
            hResult = ResultFromScode(MAPI_W_PARTIAL_COMPLETION);
            DebugTrace(TEXT("DeleteEntries deleted %u of requested %u\n"), cDeleted, cToDelete);
        }
    }

exit:
    FreeBufferAndNull(&lpspv);
    return(hResult);
}


STDMETHODIMP
DISTLIST_ResolveNames(LPCONTAINER lpCONTAINER,
  LPSPropTagArray lptagaColSet,
  ULONG ulFlags,
  LPADRLIST lpAdrList,
  LPFlagList lpFlagList)
{
    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}



//
//
//  DLENTRY Object - Distribution List entry.
//
//  Returned by CreateEntry in Distribution List.
//
//  Most of this object is implemented by the MailUser object.
//
//

DLENTRY_Vtbl vtblDLENTRY= {
    VTABLE_FILL
    DLENTRY_QueryInterface,
    (DLENTRY_AddRef_METHOD *)           WRAP_AddRef,
    DLENTRY_Release,
    (DLENTRY_GetLastError_METHOD *)     IAB_GetLastError,
    DLENTRY_SaveChanges,
    (DLENTRY_GetProps_METHOD *)         MailUser_GetProps,
    (DLENTRY_GetPropList_METHOD *)      MailUser_GetPropList,
    (DLENTRY_OpenProperty_METHOD *)     MailUser_OpenProperty,
    DLENTRY_SetProps,
    DLENTRY_DeleteProps,
    (DLENTRY_CopyTo_METHOD *)           MailUser_CopyTo,
    (DLENTRY_CopyProps_METHOD *)        MailUser_CopyProps,
    (DLENTRY_GetNamesFromIDs_METHOD *)  MailUser_GetNamesFromIDs,
    (DLENTRY_GetIDsFromNames_METHOD *)  MailUser_GetIDsFromNames
};


//
//  Interfaces supported by this object
//
#define DLENTRY_cInterfaces 1

LPIID DLENTRY_LPIID[DLENTRY_cInterfaces] =
{
	(LPIID) &IID_IMAPIProp
};


/***************************************************************************

    Name      : HrNewDLENTRY

    Purpose   : Creates a new DLENTRY object

    Parameters: lpCONTAINER -> DL Container
                ulCreateFlags = CreateEntry flags
                lppDLENTRY -> Returned DLENTRY object.

    Returns   : HRESULT

    Comment   :
***************************************************************************/
HRESULT HrNewDLENTRY(LPCONTAINER lpCONTAINER,
  LPMAPIPROP lpOldEntry,    // Old entry to copy from
  ULONG ulCreateFlags,
  LPVOID *lppDLENTRY)
{
    LPDLENTRY   lpDLENTRY       = NULL;
    SCODE       sc;
    HRESULT     hResult         = hrSuccess;
    LPPROPDATA  lpPropData      = NULL;
    ULONG       cValues;
    LPSPropValue lpspv          = NULL;


    //
    //  Allocate space for the DLENTRY structure
    //
    if (FAILED(sc = MAPIAllocateBuffer(sizeof(DLENTRY), (LPVOID *) &lpDLENTRY))) {
        hResult = ResultFromScode(sc);
        goto exit;
    }

    ZeroMemory(lpDLENTRY, sizeof(DLENTRY));

    lpDLENTRY->cIID = DLENTRY_cInterfaces;
    lpDLENTRY->rglpIID = DLENTRY_LPIID;
    lpDLENTRY->lpVtbl = &vtblDLENTRY;
    lpDLENTRY->lcInit = 1;     // Caller is a reference
    lpDLENTRY->hLastError = hrSuccess;
    lpDLENTRY->idsLastError = 0;
    lpDLENTRY->lpszComponent = NULL;
    lpDLENTRY->ulContext = 0;
    lpDLENTRY->ulLowLevelError = 0;
    lpDLENTRY->ulErrorFlags = 0;
    lpDLENTRY->ulCreateFlags = ulCreateFlags;
    lpDLENTRY->lpMAPIError = NULL;
    lpDLENTRY->ulObjAccess = IPROP_READWRITE;
    lpDLENTRY->lpEntryID = NULL;
    lpDLENTRY->lpIAB = lpCONTAINER->lpIAB;
    lpDLENTRY->lpCONTAINER = lpCONTAINER;

    //
    //  Create IPropData
    //
    if (FAILED(sc = CreateIProp((LPIID)&IID_IMAPIPropData,
      (ALLOCATEBUFFER FAR *) MAPIAllocateBuffer,
      (ALLOCATEMORE FAR *) MAPIAllocateMore,
      MAPIFreeBuffer,
      NULL,
      &lpPropData))) {
        hResult = ResultFromScode(sc);
        goto exit;
    }

    //
    //  Copy the properties from the entry into the DLENTRY.
    //
    if (hResult = lpOldEntry->lpVtbl->GetProps(lpOldEntry,
      NULL,     // lpPropTagArray
      MAPI_UNICODE,        // ulFlags
      &cValues,
      &lpspv)) {
        DebugTrace(TEXT("HrNewDLENTRY: GetProps on old object -> %x\n"), GetScode(hResult));
        goto exit;
    }

    if (hResult = lpPropData->lpVtbl->SetProps(lpPropData,
      cValues,
      lpspv,
      NULL)) {
        DebugTrace(TEXT("HrNewDLENTRY: SetProps on IProp -> %x\n"), GetScode(hResult));
        goto exit;
    }

    // Done setting props, now make it read only.
    lpPropData->lpVtbl->HrSetObjAccess(lpPropData, IPROP_READONLY);

    lpDLENTRY->lpPropData = lpPropData;

    // Keep this container open since we need it in SaveChanges.  Will Release in DLENTRY_Release.
    UlAddRef(lpCONTAINER);

    // initialize the DLENTRYs critical section
    InitializeCriticalSection(&lpDLENTRY->cs);

    *lppDLENTRY = (LPVOID)lpDLENTRY;
exit:
    FreeBufferAndNull(&lpspv);

    if (HR_FAILED(hResult)) {
        FreeBufferAndNull(&lpDLENTRY);
        UlRelease(lpPropData);
        *lppDLENTRY = (LPVOID)NULL;
    }
    return(hResult);
}


/***************************************************************************

    Name      : CheckForCycle

    Purpose   : Does adding this entry to a DL generate a cycle?

    Parameters: lpAdrBook -> ADRBOOK object
                lpEIDChild -> EntryID of entry to be added to DL
                cbEIDChild = sizeof lpEIDChild
                lpEIDParent -> EntryID of distribution list that is being added to.
                cbEIDParent = sizeof lpEIDParent

    Returns   : TRUE if a cycle is detected.

    Comment   : This is a recursive routine.

***************************************************************************/
BOOL CheckForCycle(LPADRBOOK lpAdrBook,
  LPENTRYID lpEIDChild,
  ULONG cbEIDChild,
  LPENTRYID lpEIDParent,
  ULONG cbEIDParent)
{
    BOOL fCycle = FALSE;
    LPMAPIPROP lpDistList = NULL;
    ULONG ulcPropsDL;
    ULONG ulObjType;
    ULONG i;
    LPSPropValue lpPropArrayDL = NULL;

    if (cbEIDChild == cbEIDParent && ! memcmp(lpEIDChild, lpEIDParent, cbEIDChild))
    {
        return(TRUE);   // This is a cycle
    }

    if (lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
            cbEIDChild,
            lpEIDChild,
            NULL,
            0,
            &ulObjType,
            (LPUNKNOWN *)&lpDistList))
    {
        goto exit;  // Can't open child, it must not be a DL
    }

    if (ulObjType == MAPI_DISTLIST) {
        // Get the DL property
        if ( FAILED(lpDistList->lpVtbl->GetProps(
                        lpDistList,
                        (LPSPropTagArray)&tagaWabDLEntries,
                        MAPI_UNICODE,    // ulFlags,
                        &ulcPropsDL,
                        &lpPropArrayDL)) )
        {
            // No property, no entries in this DL.
            goto exit;
        }

        // Note we don't need to look for PR_WAB_DL_ONEOFFS since they won't be cycling ..
        if (lpPropArrayDL[iwdePR_WAB_DL_ENTRIES].ulPropTag != PR_WAB_DL_ENTRIES)
        {
            goto exit;
        }

        // Look at each entry in the PR_WAB_DL_ENTRIES and recursively check it.
        for (i = 0; i < lpPropArrayDL[iwdePR_WAB_DL_ENTRIES].Value.MVbin.cValues; i++)
        {
            if ( fCycle = CheckForCycle(lpAdrBook,
                    (LPENTRYID)lpPropArrayDL[iwdePR_WAB_DL_ENTRIES].Value.MVbin.lpbin[i].lpb,
                    lpPropArrayDL[iwdePR_WAB_DL_ENTRIES].Value.MVbin.lpbin[i].cb,
                    (LPENTRYID)lpEIDParent,
                    cbEIDParent) )
            {
                DebugTrace(TEXT("CheckForCycle found cycle\n"));
                goto exit;
            }
        }
    }
exit:
    FreeBufferAndNull(&lpPropArrayDL);
    UlRelease(lpDistList);

    return(fCycle);
}


// --------
// IUnknown

STDMETHODIMP
DLENTRY_QueryInterface(LPDLENTRY lpDLENTRY,
  REFIID lpiid,
  LPVOID * lppNewObj)
{
	ULONG iIID;

#ifdef PARAMETER_VALIDATION
	// Check to see if it has a jump table
	if (IsBadReadPtr(lpDLENTRY, sizeof(LPVOID))) {
		// No jump table found
		return(ResultFromScode(E_INVALIDARG));
	}

	// Check to see if the jump table has at least sizeof IUnknown
	if (IsBadReadPtr(lpDLENTRY->lpVtbl, 3 * sizeof(LPVOID))) {
		// Jump table not derived from IUnknown
		return(ResultFromScode(E_INVALIDARG));
	}

	// Check to see that it's DLENTRY_QueryInterface
	if (lpDLENTRY->lpVtbl->QueryInterface != DLENTRY_QueryInterface) {
		// Not my jump table
		return(ResultFromScode(E_INVALIDARG));
	}

	// Is there enough there for an interface ID?

	if (IsBadReadPtr(lpiid, sizeof(IID))) {
		DebugTraceSc(DLENTRY_QueryInterface, E_INVALIDARG);
		return(ResultFromScode(E_INVALIDARG));
	}

	// Is there enough there for a new object?
	if (IsBadWritePtr(lppNewObj, sizeof(LPDLENTRY))) {
		DebugTraceSc(DLENTRY_QueryInterface, E_INVALIDARG);
		return(ResultFromScode(E_INVALIDARG));
	}

#endif // PARAMETER_VALIDATION

	EnterCriticalSection(&lpDLENTRY->cs);

	// See if the requested interface is one of ours

	//  First check with IUnknown, since we all have to support that one...
	if (! memcmp(lpiid, &IID_IUnknown, sizeof(IID))) {
		goto goodiid;        // GROSS!  Jump into a for loop!
   }

	//  Now look through all the iids associated with this object, see if any match
	for(iIID = 0; iIID < lpDLENTRY->cIID; iIID++)
		if (! memcmp(lpDLENTRY->rglpIID[iIID], lpiid, sizeof(IID))) {
goodiid:
			//
			//  It's a match of interfaces, we support this one then...
			//
			++lpDLENTRY->lcInit;
			*lppNewObj = lpDLENTRY;

			LeaveCriticalSection(&lpDLENTRY->cs);

			return(0);
		}

	//
	//  No interface we've heard of...
	//
	LeaveCriticalSection(&lpDLENTRY->cs);

	*lppNewObj = NULL;	// OLE requires NULLing out parm on failure
	DebugTraceSc(DLENTRY_QueryInterface, E_NOINTERFACE);
	return(ResultFromScode(E_NOINTERFACE));
}


STDMETHODIMP_(ULONG)
DLENTRY_Release(LPDLENTRY lpDLENTRY)
{

#if	!defined(NO_VALIDATION)
    //
    // Make sure the object is valid.
    //
    if (BAD_STANDARD_OBJ(lpDLENTRY, DLENTRY_, Release, lpVtbl)) {
        return(1);
    }
#endif

    EnterCriticalSection(&lpDLENTRY->cs);

    --lpDLENTRY->lcInit;

    if (lpDLENTRY->lcInit == 0) {
        UlRelease(lpDLENTRY->lpPropData);

        UlRelease(lpDLENTRY->lpCONTAINER);  // parent DL container

        //
        //  Need to free the object
        //
        LeaveCriticalSection(&lpDLENTRY->cs);
        DeleteCriticalSection(&lpDLENTRY->cs);
        FreeBufferAndNull(&lpDLENTRY);
        return(0);
    }

    LeaveCriticalSection(&lpDLENTRY->cs);
    return(lpDLENTRY->lcInit);
}


//
// IProperty
//


STDMETHODIMP
DLENTRY_SaveChanges(LPDLENTRY lpDLENTRY,
  ULONG ulFlags)
{
    HRESULT         hResult = hrSuccess;
    LPSPropValue    lpPropArrayDL = NULL;
    LPSPropValue    lpPropArrayEntry = NULL;
    ULONG           ulcPropsDL, ulcPropsEntry;
    LPCONTAINER     lpCONTAINER = NULL;
    LPENTRYID lpEIDAdd;
    ULONG cbEIDAdd;
    BOOL            bUseOneOffProp = FALSE;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

#if	!defined(NO_VALIDATION)
    // Make sure the object is valid.
    if (BAD_STANDARD_OBJ(lpDLENTRY, DLENTRY_, SaveChanges, lpVtbl)) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
#endif
    //
    // check read write access ...
    //
    if (lpDLENTRY->ulObjAccess == IPROP_READONLY) {
        // error - cant save changes
        hResult = MAPI_E_NO_ACCESS;
        goto exit;
    }


    // Get the ENTRYID of this entry
    if (hResult = lpDLENTRY->lpPropData->lpVtbl->GetProps(lpDLENTRY->lpPropData,
                                                          (LPSPropTagArray)&ptaEid,    // also include PR_DISPLAYNAME
                                                          MAPI_UNICODE,    // ulFlags,
                                                          &ulcPropsEntry,
                                                          &lpPropArrayEntry)) 
    {
        DebugTrace(TEXT("DLENTRY_SaveChanges: GetProps(DLENTRY) -> %x\n"), GetScode(hResult));
        goto exit;
    }

    Assert(lpPropArrayEntry && lpPropArrayEntry[ieidPR_ENTRYID].ulPropTag == PR_ENTRYID);

    cbEIDAdd = lpPropArrayEntry[ieidPR_ENTRYID].Value.bin.cb;
    lpEIDAdd = (LPENTRYID)lpPropArrayEntry[ieidPR_ENTRYID].Value.bin.lpb;

    lpCONTAINER = lpDLENTRY->lpCONTAINER;

    // Merge it into PR_WAB_DL_ENTRIES of the DL unless it's a ONEOFF in which case merge it into the OneOffs
    tagaWabDLEntries.aulPropTag[iwdePR_WAB_DL_ONEOFFS] = PR_WAB_DL_ONEOFFS;

    if (hResult = lpCONTAINER->lpVtbl->GetProps(lpCONTAINER,
                                                  (LPSPropTagArray)&tagaWabDLEntries,
                                                  MAPI_UNICODE,    // ulFlags,
                                                  &ulcPropsDL,
                                                  &lpPropArrayDL)) 
    {
        DebugTrace(TEXT("DLENTRY_SaveChanges: GetProps(DL) -> %x\n"), GetScode(hResult));
        // No property, not fatal.
    } 
    else 
    {
        // Check for duplicates.  In DISTLIST, we only support duplicate ENTRYID checking,
        // so CREATE_CHECK_DUP_STRICT is the same as CREATE_CHECK_DUP_LOOSE.
        if (lpDLENTRY->ulCreateFlags & (CREATE_CHECK_DUP_STRICT | CREATE_CHECK_DUP_LOOSE)) 
        {
            SBinaryArray MVbin;
            ULONG ulCount;
            ULONG i,j;

            for(j=iwdePR_WAB_DL_ENTRIES;j<=iwdePR_WAB_DL_ONEOFFS;j++)
            {

                if(lpPropArrayDL[j].ulPropTag == PR_NULL || !lpPropArrayDL[j].Value.MVbin.cValues)
                    continue;

                // Yes, check for duplicates
                MVbin = lpPropArrayDL[j].Value.MVbin;
                ulCount = MVbin.cValues;

                for (i = 0; i < ulCount; i++) 
                {

                    if ((cbEIDAdd == MVbin.lpbin[i].cb) &&
                        !memcmp(lpEIDAdd, MVbin.lpbin[i].lpb, cbEIDAdd)) 
                    {
                        // This EntryID is already in the list.
                        // Handle duplicate.

                        // Since we are only checking against ENTRYID, we don't have to
                        // actually REPLACE.  We just pretend we did something and don't fail.
                        if (! (lpDLENTRY->ulCreateFlags & CREATE_REPLACE)) 
                        {
                            hResult = ResultFromScode(MAPI_E_COLLISION);
                            goto exit;
                        }
                        goto nosave;
                    }
                } // i
            }// j
        }
    }

    if (CheckForCycle((LPADRBOOK)lpDLENTRY->lpCONTAINER->lpIAB,
                      lpEIDAdd, cbEIDAdd,
                      (LPENTRYID)lpPropArrayDL[iwdePR_ENTRYID].Value.bin.lpb,
                      lpPropArrayDL[iwdePR_ENTRYID].Value.bin.cb)) 
    {
        DebugTrace(TEXT("DLENTRY_SaveChanges found cycle\n"));
        hResult = ResultFromScode(MAPI_E_FOLDER_CYCLE);
        goto exit;
    }

    if(WAB_ONEOFF == IsWABEntryID(cbEIDAdd, lpEIDAdd, NULL, NULL, NULL, NULL, NULL))
        bUseOneOffProp = TRUE;
    if(pt_bIsWABOpenExSession)
        bUseOneOffProp = FALSE;

    if (hResult = AddPropToMVPBin(lpPropArrayDL,
                                (bUseOneOffProp ? iwdePR_WAB_DL_ONEOFFS : iwdePR_WAB_DL_ENTRIES),
                                (LPBYTE)lpEIDAdd,
                                cbEIDAdd,
                                TRUE))         // no duplicates
    {
        DebugTrace(TEXT("DLENTRY_SaveChanges: AddPropToMVPBin -> %x\n"), GetScode(hResult));
        goto exit;
    }

    if (hResult = lpCONTAINER->lpVtbl->SetProps(lpCONTAINER, ulcPropsDL, lpPropArrayDL, NULL)) 
    {
        DebugTrace(TEXT("DLENTRY_SaveChanges: SetProps(DL) -> %x\n"), GetScode(hResult));
        goto exit;
    }

    // Save the modified DL, keeping it open/writable.
    if (HR_FAILED(hResult = lpCONTAINER->lpVtbl->SaveChanges(lpCONTAINER, FORCE_SAVE | KEEP_OPEN_READWRITE))) 
    {
        DebugTrace(TEXT("DLENTRY_SaveChanges: container SaveChanges -> %x\n"), GetScode(hResult));
        goto exit;
    }

nosave:
    if (ulFlags & KEEP_OPEN_READWRITE) {
        lpDLENTRY->ulObjAccess = IPROP_READWRITE;
    } else {
        //$REVIEW
        // whether the flag was READONLY or there was no flag,
        // we'll make the future access now READONLY
        //
        lpDLENTRY->ulObjAccess = IPROP_READONLY;
    }

exit:
    FreeBufferAndNull(&lpPropArrayDL);
    FreeBufferAndNull(&lpPropArrayEntry);

    if ((HR_FAILED(hResult)) && (ulFlags & MAPI_DEFERRED_ERRORS)) {
        //$REVIEW : this is a grossly trivial handling of MAPI_DEFERRED_ERRORS ..
        // BUGBUG: In fact, it isn't handling the errors at all!
        //
        hResult = hrSuccess;
    }

    return(hResult);
}


STDMETHODIMP
DLENTRY_SetProps(LPDLENTRY lpDLENTRY,
  ULONG cValues,
  LPSPropValue lpPropArray,
  LPSPropProblemArray * lppProblems)
{
    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


STDMETHODIMP
DLENTRY_DeleteProps(LPDLENTRY lpDLENTRY,
  LPSPropTagArray lpPropTagArray,
  LPSPropProblemArray * lppProblems)
{
    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\dial.h ===
#ifndef _DIALER_H_
#define _DIALER_H_
#include <tapi.h>

#ifdef _NT50_TAPI30
#include <oleauto.h>
#include <objbase.h>
#endif //#ifdef _NT50_TAPI30


HRESULT HrExecDialDlg(HWND, LPADRBOOK);

#ifdef _NT50_TAPI30

DEFINE_GUID(IID_ITRequest, 0xAC48FFDF, 0xF8C4, 0x11d1, 0xA0, 0x30, 0x0, 0xC0, 0x4F, 0xB6, 0x80, 0x9F);
DEFINE_GUID(CLSID_RequestMakeCall, 0xAC48FFE0, 0xF8C4, 0x11d1, 0xA0, 0x30, 0x0, 0xC0, 0x4F, 0xB6, 0x80, 0x9F);

//from tapi3if.h
#ifndef __ITRequest_FWD_DEFINED__
#define __ITRequest_FWD_DEFINED__
typedef interface ITRequest ITRequest;
#endif 	/* __ITRequest_FWD_DEFINED__ */

#ifndef __ITRequest_INTERFACE_DEFINED__
#define __ITRequest_INTERFACE_DEFINED__

/* interface ITRequest */
/* [object][oleautomation][helpstring][uuid] */ 

EXTERN_C const IID IID_ITRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AC48FFDF-F8C4-11d1-A030-00C04FB6809F")
    ITRequest : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MakeCall( 
            /* [in] */ BSTR pDestAddress,
            /* [in] */ BSTR pAppName,
            /* [in] */ BSTR pCalledParty,
            /* [in] */ BSTR pComment) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITRequest __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITRequest __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITRequest __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITRequest __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITRequest __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MakeCall )( 
            ITRequest __RPC_FAR * This,
            /* [in] */ BSTR pDestAddress,
            /* [in] */ BSTR pAppName,
            /* [in] */ BSTR pCalledParty,
            /* [in] */ BSTR pComment);
        
        END_INTERFACE
    } ITRequestVtbl;

    interface ITRequest
    {
        CONST_VTBL struct ITRequestVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITRequest_MakeCall(This,pDestAddress,pAppName,pCalledParty,pComment)	\
    (This)->lpVtbl -> MakeCall(This,pDestAddress,pAppName,pCalledParty,pComment)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITRequest_MakeCall_Proxy( 
    ITRequest __RPC_FAR * This,
    /* [in] */ BSTR pDestAddress,
    /* [in] */ BSTR pAppName,
    /* [in] */ BSTR pCalledParty,
    /* [in] */ BSTR pComment);


void __RPC_STUB ITRequest_MakeCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __ITRequest_INTERFACE_DEFINED__ */


// from tapi3.h
EXTERN_C const CLSID CLSID_RequestMakeCall;

#ifdef __cplusplus

class DECLSPEC_UUID("AC48FFE0-F8C4-11d1-A030-00C04FB6809F")
RequestMakeCall;
#endif

//end from tapi3.h

#endif //#ifdef _NT50_TAPI30


#endif /* _DIALER_H_ defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\dial.c ===
/**********************************************************************************
*
*       dial.c - autodialer functionality for the wab
*       created on 7/1/98 by t-jstaj
*
*       Note: The reason for having this dialog in teh WAB was to integrate with
*           the NT TAPI team .. we tried using TAPI3.0 which is debuting in 
*           NT5 but found it too unstable, subject to change, and hard to include
*           in our standard headers .. hence the NT5_TAPI3.0 support is currently
*           #ifdefed out _NT50_TAPI30 .. if you reenable that support you should 
*           test it since we havent been able to test the code much - vikramm
**********************************************************************************/

#include "_apipch.h"
#define MAX_PHONE_NUMS  10
#define MAX_PHONE_LEN   32


static DWORD rgDLDialHelpIDs[] = 
{        
    // these are dummy for now, need to change at some point
    IDC_NEWCALL_STATIC_CONTACT,         IDH_WAB_DIALER_CONTACT,
    IDC_NEWCALL_COMBO_CONTACT,          IDH_WAB_DIALER_CONTACT,
    IDC_NEWCALL_STATIC_PHNUM,           IDH_WAB_DIALER_PHONE,
    IDC_NEWCALL_COMBO_PHNUM,            IDH_WAB_DIALER_PHONE,
    IDC_NEWCALL_BUTTON_CALL,            IDH_WAB_DIALER_CALL,
    IDC_NEWCALL_BUTTON_PROPERTIES,      IDH_WAB_DIALER_PROPERTIES,        
    IDC_NEWCALL_BUTTON_DIALPROP,        IDH_WAB_DIALING_PROPERTIES,
    IDC_NEWCALL_GROUP_DIALNUM,          IDH_WAB_COMM_GROUPBOX,
    IDC_NEWCALL_BUTTON_CLOSE,           IDH_WAB_FIND_CLOSE,
    0,0
};

// prototypes
#ifdef _NT50_TAPI30
HRESULT HrLPSZToBSTR(LPTSTR lpsz, BSTR *pbstr);
#endif //#ifdef _NT50_TAPI30

HRESULT HrConfigDialog( HWND );
UINT GetPhoneNumData( HWND , LPTSTR );
BOOL RetrieveData( HWND, LPTSTR szDestAddr, LPTSTR szAppName, 
                  LPTSTR szCalledParty, LPTSTR szComment);
HRESULT HrSetComboText( HWND );
void SetNumbers( HWND, LPSBinary );
INT_PTR CALLBACK ShowNewCallDlg(HWND, UINT, WPARAM, LPARAM);
LONG HrStartCall(LPTSTR, LPTSTR, LPTSTR, LPTSTR);
void UpdateNewCall(HWND, BOOL);
void DisableCallBtnOnEmptyPhoneField(HWND);
HRESULT HrInitDialog(HWND);
HRESULT HrCallButtonActivate( HWND );
HRESULT HrPropButtonActivate( HWND );
HRESULT HrCloseBtnActivate  ( HWND );
VOID FAR PASCAL lineCallbackFunc(  DWORD, DWORD, DWORD_PTR, DWORD_PTR, DWORD_PTR, DWORD_PTR);
BOOL fContextExtCoinitForDial = FALSE;
typedef struct _IABSB
{
    LPADRBOOK lpIAB;
    LPSBinary lpSB;
    
} IABSB, * LPIABSB;

/**
HrExecDialog: entry point to Dialer Dialog
[IN] hWndLV         - handle to the WAB's ListView
[IN] lpAdrBook      - pointer to the IAdrBook object 
*/
HRESULT HrExecDialDlg(HWND hWndLV, LPADRBOOK lpAdrBook )
{
    HRESULT             hr = E_FAIL;
    LPRECIPIENT_INFO    lpItem = NULL;
    LPSPropValue        lpPropArray  = NULL;
    ULONG               ulcProps = 0;
    UINT                iItemIndex;
    LPSBinary           lpSB = NULL;
    IABSB               ptr_store;
    int                 rVal, nCount = ListView_GetSelectedCount(hWndLV);        
    TCHAR               szBuf[MAX_PATH*2];
    ptr_store.lpIAB = lpAdrBook;
    ptr_store.lpSB = NULL;

    if( !lpAdrBook )
        DebugTrace(TEXT("lpAdrbook is null in ExecDialDlg\n"));

    if(nCount == 1)
    {
        iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);   
        lpItem = GetItemFromLV(hWndLV, iItemIndex);
        if(lpItem && lpItem->cbEntryID != 0)
        {
            ListView_GetItemText( hWndLV, iItemIndex, 0, szBuf, CharSizeOf( szBuf ));
            // what does this allocate space for SBinary
            MAPIAllocateBuffer( sizeof(SBinary), (LPVOID *) &lpSB);
            if( lpSB )
            {
                // allocate more space for lpb                        
                MAPIAllocateMore(lpItem->cbEntryID, lpSB, (LPVOID *) &(lpSB->lpb) );
            }
            if( !lpSB->lpb)
            {
                MAPIFreeBuffer(lpSB);
                goto out;
            }
            CopyMemory(lpSB->lpb, lpItem->lpEntryID, lpItem->cbEntryID);
            lpSB->cb = lpItem->cbEntryID;
            ptr_store.lpSB = lpSB;
        }
        else
        {
            DebugTrace(TEXT("Bad WAB info will not display\n"));
            goto out;
        }
    }
    // display the dialog box to prompt user to make call    
    if(!DialogBoxParam(hinstMapiX, MAKEINTRESOURCE(IDD_NEWCALL),
        GetParent(hWndLV), ShowNewCallDlg, (LPARAM)&ptr_store) )
    {
        hr = S_OK;
    }
    else
    {
        DebugTrace(TEXT("Dialer dialog creation failed:%d\n"), GetLastError());
    }
    
out: 
    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);
    
    if( lpSB )
        MAPIFreeBuffer(lpSB);
    return hr;    
}   

/**
ShowNewCallDlg: process events
*/

INT_PTR CALLBACK ShowNewCallDlg(HWND     hDlg,
                             UINT     uMsg,
                             WPARAM   wParam,
                             LPARAM   lParam)
{
    switch (uMsg)
    {    
    case WM_INITDIALOG:
        {
            HRESULT hr;
            SetWindowLongPtr( hDlg, DWLP_USER, lParam ); 
            hr = HrInitDialog(hDlg);
            // [PaulHi] 12/3/98  Raid #56045
            // Set up child window fonts with default GUI font
            EnumChildWindows(hDlg, SetChildDefaultGUIFont, (LPARAM) 0);
            return HR_FAILED( hr );
        }
    case WM_COMMAND:
        switch (LOWORD(wParam) )
        {
        case IDC_NEWCALL_COMBO_CONTACT:   
            /** only want to make a change if the user actually chooses a new contact
            */
            if( HIWORD(wParam) == CBN_SELENDOK )   
            {
                HRESULT hr;
                UpdateNewCall(hDlg, TRUE);
                hr = HrSetComboText( GetDlgItem(hDlg, IDC_NEWCALL_COMBO_PHNUM) );                
                if( HR_FAILED( hr ) )
                {
                    DebugTrace(TEXT("unable to set text\n"));
                    SendMessage(hDlg, IDCANCEL, 0, 0);
                }
            }            
            return FALSE;
        case IDC_NEWCALL_COMBO_PHNUM:
            // want to set the text of the selected item when the box closes
            if(  HIWORD(wParam) == CBN_CLOSEUP )
            {   
                HRESULT hr = HrSetComboText( GetDlgItem(hDlg, IDC_NEWCALL_COMBO_PHNUM) );
                if( HR_FAILED( hr ) )
                {
                    DebugTrace(TEXT("unable to set text in PHNUM closeup or selchange\n"));
                    SendMessage(hDlg, IDCANCEL, 0, 0);
                }
                return FALSE;
            }
            // reset all the values of the combobox before display since they
            // were altered from the last time a selection was made.
            else if( HIWORD(wParam) == CBN_DROPDOWN )
            {
                UpdateNewCall(hDlg, FALSE);
            }
            else if (HIWORD(wParam) == CBN_EDITUPDATE )
            {
                DisableCallBtnOnEmptyPhoneField(hDlg);
            }
            else if ( HIWORD(wParam) == CBN_SELCHANGE )
            {
                if( !SendDlgItemMessage( hDlg, IDC_NEWCALL_COMBO_PHNUM, CB_GETDROPPEDSTATE, (WPARAM)(0), (LPARAM)(0) ) )
                {
                    HRESULT hr = HrSetComboText( GetDlgItem(hDlg, IDC_NEWCALL_COMBO_PHNUM) );
                    if( HR_FAILED( hr ) )
                    {
                        DebugTrace(TEXT("unable to set text in PHNUM closeup or selchange\n"));
                        SendMessage(hDlg, IDCANCEL, 0, 0);
                    }
                    return FALSE;
                }
            }
            return FALSE;
        case IDC_NEWCALL_BUTTON_DIALPROP:
            {
                HRESULT hr = HrConfigDialog( hDlg );
                if( HR_FAILED(hr) )
                {
                    DebugTrace(TEXT("config dlg failed"));
                    DebugTrace(TEXT(" error was %x\n"), HRESULT_CODE(hr));
                    SendMessage(hDlg, IDCANCEL, 0, 0);
                }
                return FALSE;
            }
            
        case IDC_NEWCALL_BUTTON_CALL:
            {
                HRESULT hr = HrCallButtonActivate( hDlg );
                if( HR_FAILED(hr) )
                {
                    DebugTrace(TEXT("Unable to make call\n"));
                    SendMessage( hDlg, IDCANCEL, (WPARAM)(0), (LPARAM)(0) );
                }
            }
            return FALSE;
        case IDC_NEWCALL_BUTTON_PROPERTIES:
            {
                HRESULT hr = HrPropButtonActivate( hDlg );
                if( HR_FAILED(hr) )
                {
                    DebugTrace(TEXT("Unable to show properties\n"));
                    SendMessage( hDlg, IDCANCEL, (WPARAM)(0), (LPARAM)(0) );
                }
                return FALSE;
            }
        case IDCANCEL:
        case IDC_NEWCALL_BUTTON_CLOSE:
            {
               HRESULT hr = HrCloseBtnActivate(hDlg);
               return FALSE;
            }
        default:
            return TRUE;        
        }

        case WM_HELP:
            WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                    g_szWABHelpFileName,
                    HELP_WM_HELP,
                    (DWORD_PTR)(LPSTR) rgDLDialHelpIDs );
            break;
    }
    return FALSE;
}

/**
HrInitDialog: initializes the dialer dialog
*/
HRESULT HrInitDialog( HWND hDlg )
{
    HRESULT     hr = E_FAIL, hr2;
    HWND        hComboContact = GetDlgItem( hDlg, IDC_NEWCALL_COMBO_CONTACT);
    ULONG       lpcbEID, ulObjType = 0, ulResult;
    LPENTRYID   lpEID       = NULL;
    LPMAPITABLE lpAB        = NULL;
    LPSRowSet   lpRow       = NULL;
    LPSRowSet   lpRowAB     = NULL;
    LPABCONT    lpContainer = NULL;
    UINT        cNumRows    = 0;
    UINT        nRows       = 0;
    UINT        i, cEntries = 0;
    LPSBinary   tVal;
    LPIABSB     lpPtrStore = (LPIABSB)GetWindowLongPtr( hDlg, DWLP_USER );
    LPADRBOOK   lpAdrBook = lpPtrStore->lpIAB;
    AssertSz( (lpAdrBook != NULL),  TEXT("lpAdrBook is NULL in shownewcall!\n"));
    
    hr = (HRESULT) SendDlgItemMessage( hDlg, IDC_NEWCALL_COMBO_PHNUM, EM_SETLIMITTEXT, (WPARAM)(TAPIMAXDESTADDRESSSIZE), (LPARAM)(0) );
    if( HR_FAILED(hr) )
    {
        DebugTrace(TEXT("unable to set text len in PHNUM\n"));
    }
    // get the default Container
    hr = lpAdrBook->lpVtbl->GetPAB(lpAdrBook, &lpcbEID, &lpEID);
    if( HR_FAILED(hr) )
    {
        DebugTrace(TEXT("Unable to get PAB\n"));
        goto cleanup;
    }
    // open the entry
    hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
        lpcbEID,					    		
        (LPENTRYID)lpEID,
        NULL,
        0,
        &ulObjType,
        (LPUNKNOWN *)&lpContainer);
    
    MAPIFreeBuffer(lpEID);
    lpEID = NULL;
    if( HR_FAILED(hr) )
    {
        DebugTrace(TEXT("Unable to open contents\n"));
        goto cleanup;
    }
    // get the contents
    hr = lpContainer->lpVtbl->GetContentsTable(lpContainer, 
                                                MAPI_UNICODE | WAB_PROFILE_CONTENTS | WAB_CONTENTTABLE_NODATA, 
                                                &lpAB );
    
    if( HR_FAILED(hr) )
    {
        DebugTrace(TEXT("Unable to get contents table\n"));
        goto cleanup;
    }
    
    // order the columns in the Table
    // order will be displayname, entryid
    // table MUST set columns in order requested
    hr = lpAB->lpVtbl->SetColumns( lpAB, (LPSPropTagArray)&irnColumns, 0);
    
    if( HR_FAILED(hr) )
    {
        DebugTrace(TEXT("Unable to set contents table\n"));
        goto cleanup;
    }
    
    hr = lpAB->lpVtbl->SeekRow(lpAB, BOOKMARK_BEGINNING, 0, NULL);
    
    if( HR_FAILED(hr) )
    {
        DebugTrace(TEXT("Unable to seekRow \n"));
        goto cleanup;
    }
    
    do{
        //loop over all the info in the selected rows
        hr = lpAB->lpVtbl->QueryRows(lpAB, 1, 0, &lpRowAB);
        if( HR_FAILED(hr) )
        {
            DebugTrace(TEXT("Unable to Query Rows\n"));
            goto cleanup;
        }
        cNumRows = lpRowAB->cRows;
        if( lpRowAB && cNumRows > 0)  // temp fix to check for cNumRows
        {   
            UINT recentIndex;
            // store the name
            LPTSTR lpsz = lpRowAB->aRow[0].lpProps[irnPR_DISPLAY_NAME].Value.LPSZ;
            // store the entryID info
            LPENTRYID lpEID = (LPENTRYID) lpRowAB->aRow[0].lpProps[irnPR_ENTRYID].Value.bin.lpb;
            ULONG cbEID = lpRowAB->aRow[0].lpProps[irnPR_ENTRYID].Value.bin.cb;
            LPSBinary lpSB = NULL;
            // we can ignore non mail-users  for our purposes 
            // since they won't have ph numbers
            
            // will add strings to the combo box, and will associate the entryid with
            // each entry with its entryID so that it will be easy to obtain the other entry fields
            
            // what does this allocate space for SBinary
            MAPIAllocateBuffer( sizeof(SBinary), (LPVOID *) &lpSB);
            if( lpSB )
            {
                // allocate more space for lpb
                MAPIAllocateMore(cbEID, lpSB, (LPVOID *) &(lpSB->lpb) );
            }
            
            if( !lpSB->lpb)
            {
                // because of memmangement in WAB this will free all 
                // the mem in SBinary( deep free )
                MAPIFreeBuffer(lpSB);
                continue;
            }
            CopyMemory(lpSB->lpb, lpEID, cbEID);
            lpSB->cb = cbEID;
            //  next entry, list is sorted                              
            recentIndex = (UINT) SendMessage( hComboContact, CB_ADDSTRING, (WPARAM)(0),
                (LPARAM)(lpsz) );
            // set the data as the pointer to entryid info for the item at that index
            SendMessage( hComboContact, CB_SETITEMDATA,
                (WPARAM)(recentIndex), (LPARAM)(lpSB));
            cEntries++;
        }                    
        FreeProws(lpRowAB);
    }while( SUCCEEDED(hr) && cNumRows && lpRowAB );
    
    if( (LPVOID)lpPtrStore->lpSB )
    {
        for( i = 0; i < cEntries; i++)
        {
            tVal = (LPSBinary)(PULONG)SendMessage( hComboContact, CB_GETITEMDATA, 
                (WPARAM)(i), (LPARAM)(0) );
                if( tVal && tVal->cb && tVal->cb == lpPtrStore->lpSB->cb )
                {
                   if( memcmp((LPVOID)tVal->lpb, 
                       (LPVOID)lpPtrStore->lpSB->lpb, (size_t)tVal->cb) == 0) 
                    {
                        SendMessage(hComboContact, CB_SETCURSEL, 
                            (WPARAM)(i), (LPARAM)(0) );                
                        break;
                    }
            }
        }
    }
    else
        SendMessage(hComboContact, CB_SETCURSEL, (WPARAM)(0), (LPARAM)(0) );
    
cleanup:           
    if( lpContainer )
        lpContainer->lpVtbl->Release(lpContainer);
    if( lpAB)
        lpAB->lpVtbl->Release(lpAB);
    
    UpdateNewCall(hDlg, TRUE);
    hr2 = HrSetComboText( GetDlgItem(hDlg, IDC_NEWCALL_COMBO_PHNUM) );
    DisableCallBtnOnEmptyPhoneField(hDlg);

    if( HR_SUCCEEDED(hr) && HR_FAILED(hr2))
        return hr2;
    return hr;
}

/**
    HrCallButtonActivate: initiates the dialing procedures for the dialer Dlg
  */
HRESULT HrCallButtonActivate( HWND hDlg )
{
    HRESULT hr = E_FAIL;
    TCHAR szDestAddr[TAPIMAXDESTADDRESSSIZE];
    TCHAR szAppName[TAPIMAXAPPNAMESIZE];
    TCHAR szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    TCHAR szComment[TAPIMAXCOMMENTSIZE]; 
    BOOL fGotNum = RetrieveData( hDlg, szDestAddr, szAppName, szCalledParty, szComment);
    if( !fGotNum )
    {
        ShowMessageBox( hDlg, idsNoDialerDataMsg, MB_OK | MB_ICONEXCLAMATION );
    }
    else
    {
        hr = HrStartCall(szDestAddr, szAppName, szCalledParty, szComment);
        /** make call spawns it's own thread so hr only reflects
        whether or not it was able to find the phone device and 
        initiate the calling sequence, not the status of the call.
        */
    }
    return hr;
}

/**
    HrPropButtonActivate: displays the properties for the selected contact in the dialer Dlg
*/
HRESULT HrPropButtonActivate( HWND hDlg )
{    
    HRESULT		hr = E_FAIL;
    LONG		iCurContactSel;
    LPIABSB     lpPtrStore = (LPIABSB)GetWindowLongPtr( hDlg, DWLP_USER );
    LPADRBOOK   lpAdrBook = lpPtrStore->lpIAB;          
    AssertSz((lpAdrBook != NULL),  TEXT("lpAdrBook is NULL in SetNumbers\n"));
    
    // first get the cached data for the contact currently selected
    iCurContactSel = (LONG) SendDlgItemMessage( hDlg, IDC_NEWCALL_COMBO_CONTACT,
        CB_GETCURSEL,(WPARAM)(0), (LPARAM)(0));
    
    // if something is selected
    if( iCurContactSel >= 0 )
    {
        LRESULT lpdata = SendDlgItemMessage( hDlg, IDC_NEWCALL_COMBO_CONTACT, 
            CB_GETITEMDATA, (WPARAM)(iCurContactSel), (LPARAM)(LPTSTR)(0));                   
        // if we have a specially cached entryid ..
        //
        if( lpdata != CB_ERR && ((LPSBinary)lpdata)->cb && ((LPSBinary)lpdata)->lpb)
        {
            LPSBinary lpSB = (LPSBinary)lpdata;
            hr = lpAdrBook->lpVtbl->Details(lpAdrBook, (PULONG_PTR) &hDlg,
                NULL, NULL,
                lpSB->cb,
                (LPENTRYID) lpSB->lpb,
                NULL, NULL,
                NULL, 0); 
        }
    }
    return hr;
}

/** 
    HrCloseBtnActivate: Handles freeing memory from the combo boxes
*/
HRESULT HrCloseBtnActivate( HWND hDlg )
{
    HRESULT hr = S_OK;  
    UINT i, nComboSize;
    PULONG nData;
    LPTSTR lpData;
    HWND hComboItem = GetDlgItem (hDlg, IDC_NEWCALL_COMBO_CONTACT);
    // loop through all the items in the box and free the address pointed 
    // to by the data item    
    nComboSize = (UINT) SendMessage( hComboItem, CB_GETCOUNT, (WPARAM) (0), (LPARAM) (0) );
    for( i = 0; i < nComboSize; i++)
    {
        nData = (PULONG)SendMessage(hComboItem, CB_GETITEMDATA, (WPARAM)(i), (LPARAM)(0) );
        if ((LRESULT)nData != CB_ERR && nData != NULL)
        {
            if( nData )
                MAPIFreeBuffer( (LPSBinary)nData );
        }
        else 
            hr = E_FAIL;
    }
    SendMessage( hComboItem, CB_RESETCONTENT, (WPARAM)(0), (LPARAM)(0));
    hComboItem = GetDlgItem( hDlg, IDC_NEWCALL_COMBO_PHNUM);
    nComboSize = (UINT) SendMessage( hComboItem, CB_GETCOUNT, (WPARAM)(0), (LPARAM)(0) );
    for(i = 0; i < nComboSize; i++)
    {
        lpData = (LPTSTR)SendMessage(hComboItem, CB_GETITEMDATA, (WPARAM)(i), (LPARAM)(0) );
        if( (LRESULT)lpData != CB_ERR && lpData != NULL )
        {
            if( lpData )
                LocalFree( lpData );
                
        }
        else 
            hr = E_FAIL;
    }
//    SendMessage( hComboItem, CB_RESETCONTENT, (WPARAM)(0), (LPARAM)(0));
    EndDialog(hDlg, HR_SUCCEEDED(hr) );
    return hr;
}

/**
    HrStartCall: handles the TAPI calls required to dial a telephone number
    [IN] szDestAddr     - the destination telephone number to call
    [IN] szAppName      - (not used) the application to use in the dialing procedure
    [IN] szCalledParty  - the name of the person called (will be displayed by the TAPI UI)
    [IN] szComment      - (not used) a comment associated with this number 
*/
HRESULT HrStartCall(LPTSTR szDestAddr, LPTSTR szAppName, LPTSTR szCalledParty, LPTSTR szComment)
{
    typedef LONG (CALLBACK* LPFNTAPISTARTCALL)(LPSTR,LPSTR,LPSTR,LPSTR);
    HINSTANCE           hDLL;
    LPFNTAPISTARTCALL   lpfnTapi;    // Function pointer
    HRESULT             lRetCode;
    HRESULT             hr = E_FAIL;
    
#ifdef _NT50_TAPI30
    ITRequest *         pRequest = NULL;
    // begin NT5 code  
    if( CoInitialize(NULL) == S_FALSE )
        CoUninitialize();
    else    
        fContextExtCoinitForDial = TRUE;
    hr = CoCreateInstance(
        &CLSID_RequestMakeCall,
        NULL,
        CLSCTX_INPROC_SERVER,
        &IID_ITRequest,
        (LPVOID *)&pRequest
        );
    
    if( HR_SUCCEEDED(hr) )
    {
        BSTR pDestAdr, pAppName, pCalledParty, pComment; 
        HrLPSZToBSTR(szDestAddr, &pDestAdr);
        HrLPSZToBSTR(szAppName, &pAppName);
        HrLPSZToBSTR(szCalledParty, &pCalledParty);
        HrLPSZToBSTR(szComment, &pComment);
        
        hr  = pRequest->lpVtbl->MakeCall(pRequest, pDestAdr, pAppName, pCalledParty, pComment );
        DebugTrace(TEXT("COM Environment\n"));
        
        LocalFreeAndNull(&pDestAdr);
        LocalFreeAndNull(&pAppName);
        LocalFreeAndNull(&pCalledParty);
        LocalFreeAndNull(&pComment);
        
        if(fContextExtCoinitForDial)
        {
            CoUninitialize();
            fContextExtCoinitForDial = FALSE;
        }
        return hr;
    }
    else 
    {
        if( hr == REGDB_E_CLASSNOTREG )
        {
            DebugTrace(TEXT("Class not registered\n"));
        }
        else if ( hr == CLASS_E_NOAGGREGATION )
        {
            DebugTrace(TEXT("Not able to create class as part of aggregate"));
        }
        else
        {
            DebugTrace(TEXT("Undetermined error = %d"), hr);
        }
        // end NT 5 code
#endif // _NT50_TAPI30
        
        //start making the call using TAPI            
        hDLL = LoadLibrary( TEXT("tapi32.dll"));
        if (hDLL != NULL)
        {
            lpfnTapi = (LPFNTAPISTARTCALL)GetProcAddress(hDLL,
                "tapiRequestMakeCall");       
            if (!lpfnTapi)   
            {      
                // handle the error      
                FreeLibrary(hDLL);           
                DebugTrace(TEXT("getprocaddr tapirequestmakecall failed\n"));
            }
            else                 
            {
                // call the function
                // [PaulHi] 2/23/99  Raid 295116.  The tapi32.dll, tapiRequestMakeCall()
                // function takes single byte char strings, not double byte.
                LPSTR   pszDestAddr = ConvertWtoA(szDestAddr);
                LPSTR   pszCalledParty = ConvertWtoA(szCalledParty);

                hr = lpfnTapi( pszDestAddr, NULL, 
                    pszCalledParty, NULL);
                if( HR_FAILED(hr) )
                {
                    DebugTrace(TEXT("make call returned error of %x\n"), hr );
                }
                
                LocalFreeAndNull(&pszDestAddr);
                LocalFreeAndNull(&pszCalledParty);

                // free the resource 
                FreeLibrary(hDLL); 
            }
        }
#ifdef _NT50_TAPI30
    }
#endif // _NT50_TAPI30
    return hr;
}
/**
    UpdateNewCall:  Updates the phone combo info (removing the description string)
    [IN] fContactChanged    - indicates whether or not it is necessary to select the first
                              entry in the PHNUM combo. 
*/
void UpdateNewCall(HWND hDlg, BOOL fContactChanged)
{
    HWND hContactCombo = GetDlgItem( hDlg, IDC_NEWCALL_COMBO_CONTACT);
    LONG iCurContactSel, iCurPhSel;
    iCurContactSel = (LONG) SendMessage( hContactCombo, CB_GETCURSEL,(WPARAM)(0), (LPARAM)(0));
    // if something is selected
    if( iCurContactSel >= 0 )
    {
        PULONG lpdata;
        lpdata = (PULONG)SendMessage( hContactCombo, CB_GETITEMDATA, 
            (WPARAM)(iCurContactSel), (LPARAM)(LPTSTR)(0));
        
        iCurPhSel = (LONG) SendDlgItemMessage( hDlg, IDC_NEWCALL_COMBO_PHNUM, 
            CB_GETCURSEL, (WPARAM)(0), (LPARAM)(0) );
        // set the data in the combo boxes
        AssertSz( (LRESULT)lpdata != CB_ERR,  TEXT("No data cached for this entry\n") );
        SetNumbers( hDlg, (LPSBinary)lpdata ); 
        
        if( iCurPhSel < 0 || fContactChanged) iCurPhSel = 0;
        SendDlgItemMessage( hDlg, IDC_NEWCALL_COMBO_PHNUM, CB_SETCURSEL, (WPARAM)(iCurPhSel), (LPARAM)(0));
    }
    DisableCallBtnOnEmptyPhoneField(hDlg);
}

/**
RetrieveData: retrieves dialing information from the NEWCALL dialog,
memory must have been allocated for the character buffers
[OUT] szDestAddr    - the phone number to call, retrieved from the PHNUM combo
[OUT] szAppName     - (not used) empty string returned
[OUT] szCalledParty - the contact to call, retrieved from the CONTACT combo
[OUT] szComment     - (not used) empty string returned

  returns TRUE if success, FALSE if failure
*/
BOOL RetrieveData( HWND hDlg, LPTSTR szDestAddr, LPTSTR szAppName, 
                  LPTSTR szCalledParty, LPTSTR szComment)
{
    LPARAM cchGetText;

    // get the Contact name data
    cchGetText = SendDlgItemMessage( hDlg, IDC_NEWCALL_COMBO_CONTACT, WM_GETTEXT, 
        (WPARAM)(TAPIMAXCALLEDPARTYSIZE), (LPARAM)(LPTSTR)(szCalledParty));
    
    // store a default string in case there is no Party Name;
    if( cchGetText == 0 )
        lstrcpy(szCalledParty, TEXT("No Contact Name"));
    //get the Phone number data
    cchGetText = GetPhoneNumData( hDlg, szDestAddr );
    lstrcpy(szAppName,szEmpty);
    lstrcpy(szComment,szEmpty);     
    
    // return whether or not there was a phone number to dial
    return ( cchGetText > 0 );
}

/**
HrConfigDialog: initiates the dialog to change phone settings
*/
HRESULT HrConfigDialog( HWND hWnd )
{
    typedef LONG(CALLBACK* LPFNTAPIPHCONFIG)(HLINEAPP, DWORD, DWORD, HWND, LPTSTR);
//    typedef LONG(CALLBACK* LPFNTAPILINEINIT)(LPHLINEAPP, HINSTANCE, LINECALLBACK, 
//        LPTSTR, LPDWORD, LPDWORD, LPLINEINITIALIZEEXPARAMS);
    typedef LONG(CALLBACK* LPFNTAPILINEINIT)(LPHLINEAPP, HINSTANCE, LINECALLBACK, LPTSTR, LPDWORD);
    typedef LONG(CALLBACK* LPFNTAPILINESHUTDOWN)(HLINEAPP);    
    HLINEAPP hLineApp = 0;
    HINSTANCE hDLL;
    LPFNTAPIPHCONFIG lpfnConfig;    // Function pointer
    LPFNTAPILINEINIT lpfnLineInit;
    LPFNTAPILINESHUTDOWN lpfnLineShutdown;
    LONG lRetCode;
    DWORD dwDeviceID = 0X0; 
    DWORD dwAPIVersion = 0X00010004;
    LPTSTR lpszDeviceClass = NULL;
    //start config       
    HRESULT hr = E_FAIL;
    hDLL = LoadLibrary( TEXT("tapi32.dll"));
    if (!hDLL )
    {
        DebugTrace(TEXT("loading tapi32.lib failed\n"));        
        return hr;
    }
    
    lpfnConfig = (LPFNTAPIPHCONFIG)GetProcAddress(hDLL,
        "lineTranslateDialog");
    
    if (!lpfnConfig )   
    {      
        // handle the error
        DebugTrace(TEXT("getprocaddr phoneConfigDialog failed\n"));
        DebugTrace(TEXT("last error was %x\n"), GetLastError() );        
    }
    else
    {
        lRetCode = lpfnConfig( 0, dwDeviceID, dwAPIVersion, 
            hWnd, lpszDeviceClass);
        
        switch( lRetCode )
        {
            hr = HRESULT_FROM_WIN32(lRetCode);
        case 0:
            hr = S_OK;
            break;
#ifdef DEBUG
        case LINEERR_REINIT:
            DebugTrace(TEXT("reeinitialize\n"));
            break;
        case LINEERR_INVALAPPNAME:
            DebugTrace(TEXT("invalid app name\n"));
            break;                    
        case LINEERR_BADDEVICEID: 
            DebugTrace(TEXT("bad device id\n"));
            break;
        case LINEERR_INVALPARAM: 
            DebugTrace(TEXT("invalid param\n"));
            break;
        case LINEERR_INCOMPATIBLEAPIVERSION: 
            DebugTrace(TEXT("incompatible api ver\n"));
            break;
        case LINEERR_INVALPOINTER: 
            DebugTrace(TEXT("invalid ptr\n"));
            break;
        case LINEERR_INIFILECORRUPT: 
            DebugTrace(TEXT("ini file corrupt\n"));
            break;
        case LINEERR_NODRIVER: 
            DebugTrace(TEXT("no driver\n"));
            break;
        case LINEERR_INUSE: 
            DebugTrace(TEXT("in use\n"));
            break;
        case LINEERR_NOMEM:
            DebugTrace(TEXT("no mem\n"));
            break;
        case LINEERR_INVALADDRESS:
            DebugTrace(TEXT("invalid address\n"));
            break;
        case LINEERR_INVALAPPHANDLE:
            DebugTrace(TEXT("invalid phone handle\n"));
            break;
        case LINEERR_OPERATIONFAILED:
            DebugTrace(TEXT("op failed\n"));
            break;
#endif // DEBUG
        default:
            DebugTrace(TEXT("(1)lpfnConfig returned a value of %x\n"), lRetCode);
            // this had better be Win95!!
            lpfnLineInit = (LPFNTAPILINEINIT)GetProcAddress(hDLL,
                "lineInitialize");
            if( !lpfnLineInit )
            {
                // handle the error      
                DebugTrace(TEXT("getprocaddr lineInitialize failed\n"));
                DebugTrace(TEXT("last error was %x\n"), GetLastError() );
            }
            else               
            {      
                DWORD dwNumDevs = 0;
                // call the function
                lRetCode = lpfnLineInit( 
                    &hLineApp, 
                    hinstMapiX, 
                    lineCallbackFunc, 
                    NULL, 
                    &dwNumDevs);
                    
                switch( lRetCode )
                {
                    hr = HRESULT_FROM_WIN32(lRetCode);
                case 0:
                    // shows config
                    lRetCode = lpfnConfig( hLineApp, dwDeviceID, dwAPIVersion, 
                        hWnd, lpszDeviceClass);
                    switch( lRetCode )
                    {
                        hr = HRESULT_FROM_WIN32(lRetCode);
                    case 0:
                        // now shutdown line
                        lpfnLineShutdown = (LPFNTAPILINESHUTDOWN)GetProcAddress(hDLL,                
                            "lineShutdown");

                        if( lpfnLineShutdown)
                        {
                            lpfnLineShutdown(hLineApp);
                        }
                        hr = S_OK;
                        break;                            
                    default:
                        DebugTrace(TEXT("(2)lpfnConfig returned a value of %x\n"), lRetCode);
                        break;
                    }
                    break;
                    // end shows config
#ifdef DEBUG
                case LINEERR_REINIT:
                    DebugTrace(TEXT("reeinitialize\n"));
                    break;
                case LINEERR_INVALAPPNAME:
                    DebugTrace(TEXT("invalid app name\n"));
                    break;
                case LINEERR_BADDEVICEID: 
                    DebugTrace(TEXT("bad device id\n"));
                    break;
                case LINEERR_INVALPARAM: 
                    DebugTrace(TEXT("invalid param\n"));
                    break;
                case LINEERR_INCOMPATIBLEAPIVERSION: 
                    DebugTrace(TEXT("incompatible api ver\n"));
                    break;
                case LINEERR_INVALPOINTER: 
                    DebugTrace(TEXT("invalid ptr\n"));
                    break;
                case LINEERR_INIFILECORRUPT: 
                    DebugTrace(TEXT("ini file corrupt\n"));
                    break;
                case LINEERR_NODRIVER: 
                    DebugTrace(TEXT("no driver\n"));
                    break;
                case LINEERR_INUSE: 
                    DebugTrace(TEXT("in use\n"));
                    break;
                case LINEERR_NOMEM:
                    DebugTrace(TEXT("no mem\n"));
                    break;
                case LINEERR_INVALADDRESS:
                    DebugTrace(TEXT("invalid address\n"));
                    break;
                case LINEERR_INVALAPPHANDLE:
                    DebugTrace(TEXT("invalid phone handle\n"));
                    break;
                case LINEERR_OPERATIONFAILED:
                    DebugTrace(TEXT("op failed\n"));
                    break;
#endif // DEBUG
                default:
                    DebugTrace(TEXT("Initialize returned a value of %x\n"), GetLastError());
                    break;
                }
               }
            }        
        }
        // free the resource 
        FreeLibrary(hDLL); 
        return hr;
        
}
/**
SetNumbers: updates the phone numbers in the PHNUM combo based on the selection
in the CONTACT combo
[IN] lpdata     - LPSBinary that points to the data stored for the currently 
selected contact
*/
void SetNumbers( HWND hWnd, LPSBinary lpdata)
{
    ULONG           ulObjType   = 0;
    UINT            i, nLen;
    LPMAILUSER      lpMailUser  = NULL;
    HRESULT         hr;
    LPTSTR          hData;
    LPIABSB         lpPtrStore  = (LPIABSB)GetWindowLongPtr( hWnd, DWLP_USER );
    LPADRBOOK       lpAdrBook   = lpPtrStore->lpIAB;
    HWND            hCombo      = GetDlgItem(hWnd, IDC_NEWCALL_COMBO_PHNUM);
    
    AssertSz((lpAdrBook != NULL), TEXT("lpAdrBook is NULL in SetNumbers\n"));
    // clear all the data in the phnum combo
    nLen = (UINT) SendMessage( hCombo, CB_GETCOUNT, (WPARAM)(0), (LPARAM)(0));
    for( i = 0; i < nLen; i++)
    {
        hData = (LPTSTR)(PULONG)SendMessage( hCombo, CB_GETITEMDATA, (WPARAM)(i), (LPARAM)(0));
        if( (LRESULT)hData != CB_ERR && hData != NULL)
            LocalFree( hData );
    }
    SendMessage( hCombo, CB_RESETCONTENT, (WPARAM)(0), (LPARAM)(0));
    // get the ph num             
    hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook, 
        lpdata->cb, 
        (LPENTRYID) lpdata->lpb, 
        NULL,
        0,
        &ulObjType,
        (LPUNKNOWN *)&lpMailUser);
    if( HR_SUCCEEDED(hr) && lpMailUser )    
    {
        LPSPropValue    lpPropArray;
        ULONG           ulcValues;
        ULONG           i;
        ULONG           ulTempProptag;
        TCHAR           szStr[MAX_PATH];
        LONG            cCopied = 0;
        
        hr = lpMailUser->lpVtbl->GetProps(lpMailUser,NULL, MAPI_UNICODE, &ulcValues, &lpPropArray);        
        if ( HR_SUCCEEDED(hr) )
        {
            
            for(i=0;i<ulcValues;i++)
            {
                cCopied = 0;
                ulTempProptag = lpPropArray[i].ulPropTag;
                switch( lpPropArray[i].ulPropTag )
                {
                case PR_HOME_TELEPHONE_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelHome, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_OFFICE_TELEPHONE_NUMBER:  
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelBus, 
                        szStr, CharSizeOf(szStr) );                
                    break;
                case PR_BUSINESS2_TELEPHONE_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelBus2, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_MOBILE_TELEPHONE_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelMobile, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_RADIO_TELEPHONE_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelRadio, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_CAR_TELEPHONE_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelCar, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_OTHER_TELEPHONE_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelOther, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_PAGER_TELEPHONE_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelPager, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_ASSISTANT_TELEPHONE_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelAst, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_HOME2_TELEPHONE_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelHome2, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_COMPANY_MAIN_PHONE_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelCompMain, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_BUSINESS_FAX_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelFaxBus, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_HOME_FAX_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelFaxHome, 
                        szStr, CharSizeOf(szStr) );
                    break;
                default:
                    if(lpPropArray[i].ulPropTag == PR_WAB_IPPHONE)
                        cCopied = LoadString( hinstMapiX, idsPhoneLabelIPPhone, szStr, CharSizeOf(szStr) );
                    break;
                }
                if( cCopied > 0 )
                {
                    LRESULT iItem;
                    LPTSTR lpCompletePhNum = NULL;
                    LPTSTR lpPhNum;
                    int len = lstrlen( lpPropArray[i].Value.LPSZ ) + 1;
                    lpPhNum = LocalAlloc(LMEM_ZEROINIT, sizeof( TCHAR ) * len );
                    if( !lpPhNum )
                    {
                        DebugTrace(TEXT("cannot allocate memory for lpPhNum\n"));
                        SendMessage(hWnd, IDCANCEL, (WPARAM)(0), (LPARAM)(0) );
                    }
                    lstrcpy(lpPhNum, lpPropArray[i].Value.LPSZ);
                    
                    FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        szStr, 0, 0, (LPTSTR)&lpCompletePhNum, 0, (va_list *)&lpPropArray[i].Value.LPSZ);
                    
                    if( lpCompletePhNum )
                    {
                        iItem = SendDlgItemMessage( hWnd, IDC_NEWCALL_COMBO_PHNUM, 
                            CB_ADDSTRING, (WPARAM)(0), (LPARAM)(LPCTSTR)(lpCompletePhNum));
                    }
                    else 
                        iItem = CB_ERR;
                    
                    if( iItem == CB_ERR )
                    {
                        DebugTrace(TEXT("ERROR adding string %s"), lpCompletePhNum);
                    }
                    
                    SendDlgItemMessage( hWnd, IDC_NEWCALL_COMBO_PHNUM, 
                        CB_SETITEMDATA, (WPARAM)(iItem), (LPARAM)(lpPhNum) );                
                    LocalFree(lpCompletePhNum);
                }
            }
            MAPIFreeBuffer(lpPropArray);
        }
        lpMailUser->lpVtbl->Release(lpMailUser);
    }
}

/** 
    GetPhoneNumData: copies the data from the PHNUM combo to the szDestAddr buffer
                     memory must have been allocated for szDestAddr 

  [OUT] szDestAddr    - buffer to be filled with the data from the comboBox
    
    returns the number of characters copied from combo_box to szDestAddr buffer
*/
UINT GetPhoneNumData( HWND hDlg, LPTSTR szDestAddr)
{
    LRESULT iIndex, iData;
    UINT cch = 0;
    TCHAR szBuff[MAX_PATH];
    
    // determine which index was selected
    iIndex = SendDlgItemMessage( hDlg, IDC_NEWCALL_COMBO_PHNUM, 
        CB_GETCURSEL, (WPARAM)(0), (LPARAM)(0));
    
    // if nothing is selected then copy everything in the buffer
//    if( iIndex == CB_ERR)
//    {
        cch = (UINT) SendDlgItemMessage( hDlg, IDC_NEWCALL_COMBO_PHNUM, WM_GETTEXT,
            (WPARAM)(TAPIMAXDESTADDRESSSIZE), (LPARAM)(LPTSTR)(szDestAddr));        
/**    }
    else
    {
        // otherwise obtain the data for the selected item
        iData = SendDlgItemMessage( hDlg, IDC_NEWCALL_COMBO_PHNUM, 
            CB_GETITEMDATA, (WPARAM)(iIndex), (LPARAM)(0) );
        if( iData == CB_ERR )
        {
            cch = -1;
            DebugTrace(TEXT("Unable to obtain data from ComboBox entry that should have data associated\n"));
        }            
        else
        {
            // copy the item to a temp buffer
            lstrcpy( szDestAddr, (LPCTSTR)iData);
            DebugTrace(TEXT("String is %s\n"), szDestAddr );
            DebugTrace(TEXT("Index was %d\n"), iIndex );
        }
    }
    */
    // a character count of 0 indicates there was no data for a particular item
    return cch;
}

/**
    HrSetComboText: a helper function that will set the text entry of the PHNUM combo
                    with just the telephone number (removing the description)
    [IN] hCombo -   the combo box to update, this must be the PHNUM combo.
*/
HRESULT HrSetComboText(HWND hCombo)
{
    LRESULT iIndex;
    LPTSTR szData;
    HRESULT hr = S_OK;
    TCHAR szBuff[MAX_PATH], szDestAddr[TAPIMAXDESTADDRESSSIZE];
    // determine which index was selected
    iIndex = SendMessage( hCombo, CB_GETCURSEL, (WPARAM)(0), (LPARAM)(0));
    if( iIndex != CB_ERR)
    {
        // obtain the data for the selected item
        szData = (LPTSTR)SendMessage( hCombo, CB_GETITEMDATA, (WPARAM)(iIndex), (LPARAM)(0) );
        if( (LRESULT)szData == CB_ERR )
        {
            DebugTrace(TEXT("Unable to obtain data from ComboBox entry that should have data associated\n"));
            szData = szEmpty;
            hr = E_FAIL;
        }            
        else
        {
            LRESULT lr;
            LPVOID lpData;
            if( !szData )
                szData = szEmpty;
            // only copy the data after the offset stored for the item
            lr = SendMessage( hCombo, CB_INSERTSTRING, (WPARAM)(iIndex), (LPARAM)(LPTSTR)(szData));
            if( lr == CB_ERR || lr == CB_ERRSPACE)
            {
                DebugTrace(TEXT("unable to insert string = %s at index = %d \n"), szData, iIndex);
                hr = E_FAIL;
            }
            lpData = (LPVOID)SendMessage( hCombo, CB_GETITEMDATA, (WPARAM)(iIndex+1), (LPARAM)(0) );
            if( (LRESULT)lpData == CB_ERR )
            {
                DebugTrace(TEXT("unable to get data for %d"), iIndex+1);
                hr = E_FAIL;
            }
            lr = SendMessage( hCombo, CB_SETITEMDATA, (WPARAM)(iIndex), (LPARAM)(lpData) );
            if( lr == CB_ERR )
            {
                DebugTrace(TEXT("unable to set data at %d"), iIndex);
                hr = E_FAIL;
            }
            lr = SendMessage( hCombo, CB_DELETESTRING, (WPARAM)(iIndex+1), (LPARAM)(0) );
            if( lr == CB_ERR )
            {
                DebugTrace(TEXT("unable to delete string at %d"), iIndex+1);
                hr = E_FAIL;
            }
            lr = SendMessage( hCombo, CB_SETCURSEL, (WPARAM)(iIndex), (LPARAM)(0) );
            if( lr == CB_ERR )
            {
                DebugTrace(TEXT("unable to set selection at %d"), iIndex);
                hr = E_FAIL;
            }
        }
    }
    else
        hr = E_FAIL;

    if( HR_FAILED(hr) )
        DebugTrace(TEXT("settext failed\n"));
    return hr;
}

/**
    DisableCallBtnOnEmptyPhoneField:    Will disable the call button if there is no text in
                                        in the PHNUM combo box.  Will enable the button if 
                                        text is present.  Does not check to see if button is
                                        already enabled/disabled, but enabling an enabled btn
                                        should be fine.
*/
void DisableCallBtnOnEmptyPhoneField(HWND hDlg)
{
    HWND hComboItem = GetDlgItem( hDlg, IDC_NEWCALL_COMBO_PHNUM);
    LRESULT iCurSel, iCurContSel;
    iCurSel = SendMessage( hComboItem, CB_GETCURSEL, 0L, 0L );
    iCurContSel = SendDlgItemMessage(hDlg, IDC_NEWCALL_COMBO_CONTACT, CB_GETCURSEL, (WPARAM)(0), (LPARAM)(0) );
    if( iCurContSel < 0 || iCurContSel == CB_ERR)
        SendMessage(hComboItem, CB_RESETCONTENT, 0L, 0L);
    if( iCurSel < 0 || iCurSel == CB_ERR )     
    { 
        LRESULT cch;
        TCHAR szBuf[MAX_PATH];
        cch = SendMessage( hComboItem, WM_GETTEXT, (WPARAM)(CharSizeOf( szBuf) ), 
            (LPARAM)(szBuf) );
        
        
        if( (INT)cch <= 0 || cch == CB_ERR)
        {
            // content will be empty at this point so can safely add
            int cCopied;
            LRESULT iIndex;
            TCHAR szBuf[MAX_PATH];
            cCopied = LoadString( hinstMapiX, idsNoPhoneNumAvailable, 
                szBuf, CharSizeOf(szBuf) );
            iIndex = SendMessage(hComboItem, CB_ADDSTRING, (WPARAM)(0), (LPARAM)(szBuf));
            SendMessage(hComboItem, CB_SETITEMDATA, (WPARAM)(0), (LPARAM)(0));
            EnableWindow( GetDlgItem(hDlg, IDC_NEWCALL_BUTTON_CALL), FALSE);
            return;
        }
    }
    EnableWindow( GetDlgItem(hDlg, IDC_NEWCALL_BUTTON_CALL), TRUE);
}

VOID FAR PASCAL lineCallbackFunc(  DWORD a, DWORD b, DWORD_PTR c, DWORD_PTR d, DWORD_PTR e, DWORD_PTR f)
{}


#ifdef _NT50_TAPI30

/**
    HrLPSZCPToBSTR: (BSTR helper) helper to convert LPTSTR -> BST
*/
HRESULT HrLPSZCPToBSTR(UINT cp, LPTSTR lpsz, BSTR *pbstr)
{
    HRESULT hr = NOERROR;
    BSTR    bstr=0;
    ULONG   cch = 0, ccb,
        cchRet;
    
    if (!IsValidCodePage(cp))
        cp = GetACP();
    
    // get byte count
    ccb = lstrlen(lpsz);
    
    // get character count - DBCS string ccb may not equal to cch
    cch=MultiByteToWideChar(cp, 0, lpsz, ccb, NULL, 0);
    if(cch==0 && ccb!=0)        
    {
        AssertSz(cch,  TEXT("MultiByteToWideChar failed"));
        hr=E_FAIL;
        goto error;
    }
    // allocate a wide-string with enough character to hold string - use character count
    bstr = (BSTR)LocalFree(LMEM_ZEROINIT, sizeof( BSTR ) * cch + 1);
    
    if(!bstr)
    {
        hr=E_OUTOFMEMORY;
        goto error;
    }
    
    cchRet=MultiByteToWideChar(cp, 0, lpsz, ccb, (LPWSTR)bstr, cch);
    if(cchRet==0 && ccb!=0)
    {
        hr=E_FAIL;
        goto error;
    }
    
    *pbstr = bstr;
    bstr=0;             // freed by caller
    
error:
    if(bstr)
        LocalFree(bstr);
    
    return hr;
}

/**  
    HrLPSZToBSTR:   Converts a LPTSTR to a BSTR using a helper function
*/
HRESULT HrLPSZToBSTR(LPTSTR lpsz, BSTR *pbstr)
{
    // GetACP so that it works on non-US platform
    return HrLPSZCPToBSTR(GetACP(), lpsz, pbstr);
}

#endif //#ifdef _NT50_TAPI30
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\dllload.c ===
#include "_apipch.h"
#include <pstore.h>
#define _CRYPTDLG_
#include <cryptdlg.h>

#pragma hdrstop
#pragma warning(disable:4229)  // No warnings when modifiers used on data

// flags to enable selective def-loading of dlls.
#define DEFLOAD_PSTOREC
#define DEFLOAD_CRYPTDLG

#define ENSURE_LOADED(_hinst, _dll)   (_hinst ? TRUE : (BOOL)(_hinst = LoadLibrary(TEXT(#_dll))))
#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err)                    \
_ret __stdcall _fn _args                                                                \
{                                                                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;                                   \
    if (!ENSURE_LOADED(_hinst, _dll))                                                   \
    {                                                                                   \
        if(!_hinst) DebugTrace(TEXT("LoadLibrary failed on ") ## TEXT(#_dll));         \
        return (_ret)_err;                                                              \
    }                                                                                   \
    if (_pfn##_fn == NULL)                                                              \
    {                                                                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn);                         \
        if(!_pfn##_fn) DebugTrace(TEXT("GetProcAddress failed on ") ## TEXT(#_fn));    \
        if (_pfn##_fn == NULL)                                                          \
            return (_ret)_err;                                                          \
    }                                                                                   \
    return _pfn##_fn _nargs;                                                            \
}

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_BOOL(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, BOOL, _fn, _args, _nargs, FALSE)

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs)                               \
void __stdcall _fn _args                                                                \
{                                                                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;                                   \
    if (!ENSURE_LOADED(_hinst, _dll))                                                   \
    {                                                                                   \
        if(!_hinst) DebugTrace(TEXT("LoadLibrary failed on ") ## TEXT(#_dll));         \
        return;                                                                         \
    }                                                                                   \
    if (_pfn##_fn == NULL)                                                              \
    {                                                                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn);                         \
        if(!_pfn##_fn) DebugTrace(TEXT("GetProcAddress failed on ") ## TEXT(#_fn));    \
        if (_pfn##_fn == NULL)                                                          \
            return;                                                                     \
    }                                                                                   \
    _pfn##_fn _nargs;                                                                   \
}



// For private entrypoints exported by ordinal.
#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err)          \
_ret __stdcall _fn _args                                                                \
{                                                                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;                                   \
    if (!ENSURE_LOADED(_hinst, _dll))                                                   \
    {                                                                                   \
        if(!_hinst) DebugTrace(TEXT("LoadLibrary failed on ") ## TEXT(#_dll));         \
        return (_ret)_err;                                                              \
    }                                                                                   \
    if (_pfn##_fn == NULL)                                                              \
    {                                                                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord);                 \
        if(!_pfn##_fn) DebugTrace(TEXT("GetProcAddress failed on ") ## TEXT(#_fn));    \
        if (_pfn##_fn == NULL)                                                          \
            return (_ret)_err;                                                          \
    }                                                                                   \
    return _pfn##_fn _nargs;                                                            \
}

#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)


#define DELAY_LOAD_VOID_ORD(_hinst, _dll, _fn, _ord, _args, _nargs)                     \
void __stdcall _fn _args                                                                \
{                                                                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;                                   \
    if (!ENSURE_LOADED(_hinst, _dll))                                                   \
    {                                                                                   \
        if(!_hinst) DebugTrace(TEXT("LoadLibrary failed on ") ## TEXT(#_dll));         \
        return;                                                                         \
    }                                                                                   \
    if (_pfn##_fn == NULL)                                                              \
    {                                                                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, MAKEINTRESOURCE(_ord));        \
        if(!_pfn##_fn) DebugTrace(TEXT("GetProcAddress failed on ") ## TEXT(#_fn));    \
        if (_pfn##_fn == NULL)                                                          \
            return;                                                                     \
    }                                                                                   \
    _pfn##_fn _nargs;                                                                   \
}


#ifdef DEFLOAD_PSTOREC
// -------  pstorec.dll -------
HINSTANCE g_hinstPSTOREC = NULL;

#ifndef WIN16
DELAY_LOAD(g_hinstPSTOREC, PSTOREC.DLL, HRESULT, PStoreCreateInstance,
    (IPStore __RPC_FAR *__RPC_FAR *ppProvider, PST_PROVIDERID __RPC_FAR *pProviderID, void __RPC_FAR *pReserved, DWORD dwFlags),
    (ppProvider, pProviderID, pReserved, dwFlags));

DELAY_LOAD(g_hinstPSTOREC, PSTOREC.DLL, HRESULT, PStoreEnumProviders,
    (DWORD dwFlags, IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum),
    (dwFlags, ppenum));
#endif

#endif

#ifdef DEFLOAD_CRYPTDLG
// -------  cryptdlg.dll -------

HINSTANCE g_hinstCRYPTDLG = NULL;

#ifndef WIN16
DELAY_LOAD(g_hinstCRYPTDLG, CRYPTDLG.DLL, BOOL, CertViewPropertiesA,
    (PCERT_VIEWPROPERTIES_STRUCT_A pCertViewInfo),
    (pCertViewInfo));

DELAY_LOAD(g_hinstCRYPTDLG, CRYPTDLG.DLL, BOOL, CertViewPropertiesCryptUIA,
    (PCERT_VIEWPROPERTIESCRYPTUI_STRUCT_A pCertViewInfo),
    (pCertViewInfo));
#endif

#endif

void DefLoadFreeLibraries()
{
#ifdef DEFLOAD_PSTOREC
    if (g_hinstPSTOREC)
        {
        FreeLibrary(g_hinstPSTOREC);
        g_hinstPSTOREC=0;
        }
    if (g_hinstCRYPTDLG)
        {
        FreeLibrary(g_hinstCRYPTDLG);
        g_hinstCRYPTDLG=0;
        }
#endif
}

// --------------------------------------------
// these macros produce code that looks like
//
#if 0

BOOL GetOpenFileName(LPOPENFILENAME pof)
{
    static BOOL (*pfnGetOpenFileName)(LPOPENFILENAME pof);

    if (ENSURE_LOADED(g_hinstCOMDLG32, "COMDLG32.DLL"))
    {
        if (pfnGetOpenFileName == NULL)
            pfnGetOpenFileName = (BOOL (*)(LPOPENFILENAME))GetProcAddress(g_hinstCOMDLG32, "GetOpenFileNameW");

        if (pfnGetOpenFileName)
            return pfnGetOpenFileName(pof);
    }
    return -1;
}
#endif

#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\demand.c ===
/*
**	d e m a n d . c p p
**	
**	Purpose: implement the loader functions for defer/demand -loaded libraries
**
**  Creators: jimsch, brimo, t-erikne
**  Created: 5/15/97
**	
**	Copyright (C) Microsoft Corp. 1997
*/

#include "_apipch.h"

// W4 stuff
#pragma warning(disable: 4201)  // nameless struct/union
#pragma warning(disable: 4514)  // unreferenced inline function removed

#include <wincrypt.h>
#define IMPLEMENT_LOADER_FUNCTIONS
#include "demand.h"

////////////////////////////////////////////////////////////////////////////
//
//  Macros

#define CRIT_GET_PROC_ADDR(h, fn, temp)             \
        temp = (TYP_##fn) GetProcAddress(h, #fn);   \
        if (temp)                                   \
            VAR_##fn = temp;                        \
        else                                        \
            {                                       \
            AssertSz(VAR_##fn TEXT(" failed to load"));    \
            goto error;                             \
            }

#define RESET(fn)                                   \
        VAR_##fn = LOADER_##fn;

#define GET_PROC_ADDR(h, fn) \
        VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);  \
        Assert(VAR_##fn != NULL); \
        if(NULL == VAR_##fn ) { \
            VAR_##fn  = LOADER_##fn; \
        }

#define GET_PROC_ADDR3(h, fn, varname) \
        VAR_##varname = (TYP_##varname) GetProcAddress(h, #fn);  \
        Assert(VAR_##varname != NULL);

#define GET_PROC_ADDR_FLAG(h, fn, pflag) \
        VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);  \
        *pflag = (VAR_##fn != NULL);


////////////////////////////////////////////////////////////////////////////
//
//  Variables

static HMODULE          s_hCrypt = 0;
static HMODULE          s_hAdvApi = 0;
static HMODULE          s_hPstoreC = 0;
static HMODULE          s_hCryptDlg = 0;
static HMODULE          s_hWinTrust = 0;
static HMODULE          s_hVersion = 0;
static HMODULE          s_hImm32 = 0;
static HMODULE          s_hWininet = 0;
static HMODULE          s_hUrlmon = 0;
static HMODULE          s_hShlwapi = NULL;

#ifdef USE_CRITSEC
static CRITICAL_SECTION cs = {0};
#endif

#ifdef DEBUG
static BOOL             s_fInit = FALSE;
#endif

////////////////////////////////////////////////////////////////////////////
//
//  Management functions

void InitDemandLoadedLibs()
{
#ifdef USE_CRITSEC
    InitializeCriticalSection(&cs);
#endif
#ifdef DEBUG
    s_fInit = TRUE;
#endif
}

void FreeDemandLoadedLibs()
{
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif
    if (s_hCrypt)
        FreeLibrary(s_hCrypt);
    if (s_hAdvApi)
        FreeLibrary(s_hAdvApi);
    if (s_hPstoreC)
        FreeLibrary(s_hPstoreC);
    if (s_hCryptDlg)
        FreeLibrary(s_hCryptDlg);
    if (s_hWinTrust)
        FreeLibrary(s_hWinTrust);
    if (s_hVersion)
        FreeLibrary(s_hVersion);
    if (s_hImm32)
        FreeLibrary(s_hImm32);
    if (s_hWininet)
        FreeLibrary(s_hWininet);
    if (s_hUrlmon)
        FreeLibrary(s_hUrlmon);
    if (s_hShlwapi)
        FreeLibrary(s_hShlwapi);

#ifdef DEBUG
    s_fInit = FALSE;
#endif
#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
    DeleteCriticalSection(&cs);
#endif
}

////////////////////////////////////////////////////////////////////////////
//
//  Loader functions

/* sample loader with critical proc addrs
** but not thread-safe
BOOL DemandLoadFoo()
{
    FARPROC fp;

    if (0 == g_hFoo)
        {
        g_hFoo = LoadLibrary("FOO.DLL");

        if (0 == g_hFoo)
            return FALSE;

        CRIT_GET_PROC_ADDR(NeededFunction1, fp);
        CRIT_GET_PROC_ADDR(NeededFunction2, fp);
        GET_PROC_ADDR(OptionalFunction);
        }
    return TRUE;

error:
    FreeLibrary(g_hFoo);
    g_hFoo = NULL;
    RESET(NeededFunction1)
    RESET(NeededFunction2)
    RESET(OptionalFunction)
    return FALSE;
}
*/

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL DemandLoadCrypt32()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hCrypt)
        {
        s_hCrypt = LoadLibrary(TEXT("CRYPT32.DLL"));
        AssertSz((NULL != s_hCrypt), TEXT("LoadLibrary failed on CRYPT32.DLL"));

        if (0 == s_hCrypt)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hCrypt, CertFreeCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertDuplicateCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertFindCertificateInStore)
            GET_PROC_ADDR(s_hCrypt, CertVerifyTimeValidity)
            GET_PROC_ADDR(s_hCrypt, CertOpenSystemStoreA)
            GET_PROC_ADDR(s_hCrypt, CertCloseStore)
            GET_PROC_ADDR(s_hCrypt, CertGetCertificateContextProperty)
            GET_PROC_ADDR(s_hCrypt, CertOpenStore)
            GET_PROC_ADDR(s_hCrypt, CertCompareCertificate)
            GET_PROC_ADDR(s_hCrypt, CryptMsgClose)
            GET_PROC_ADDR(s_hCrypt, CryptDecodeObjectEx)
            GET_PROC_ADDR(s_hCrypt, CryptMsgGetParam)
            GET_PROC_ADDR(s_hCrypt, CryptMsgUpdate)
            GET_PROC_ADDR(s_hCrypt, CryptMsgOpenToDecode)
            GET_PROC_ADDR(s_hCrypt, CertAddCertificateContextToStore)
            }
        }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL DemandLoadAdvApi32()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hAdvApi)
        {
        s_hAdvApi = LoadLibrary(TEXT("ADVAPI32.DLL"));
        AssertSz((NULL != s_hAdvApi), TEXT("LoadLibrary failed on ADVAPI32.DLL"));

        if (0 == s_hAdvApi)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hAdvApi, CryptAcquireContextA)
            GET_PROC_ADDR(s_hAdvApi, CryptAcquireContextW)
            GET_PROC_ADDR(s_hAdvApi, CryptReleaseContext)
            }
        }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL DemandLoadPStoreC()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hPstoreC)
        {
        s_hPstoreC = LoadLibrary(TEXT("PSTOREC.DLL"));
        AssertSz((NULL != s_hPstoreC), TEXT("LoadLibrary failed on PSTOREC.DLL"));

        if (0 == s_hPstoreC)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hPstoreC, PStoreCreateInstance)
            GET_PROC_ADDR(s_hPstoreC, PStoreEnumProviders)
            }
        }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
static BOOL s_fCertViewPropertiesCryptUIA = FALSE;

BOOL DemandLoadCryptDlg()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hCryptDlg)
        {
        s_hCryptDlg = LoadLibrary(TEXT("CRYPTDLG.DLL"));
        AssertSz((NULL != s_hCryptDlg), TEXT("LoadLibrary failed on CRYPTDLG.DLL"));

        if (0 == s_hCryptDlg)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hCryptDlg, GetFriendlyNameOfCertA)
            GET_PROC_ADDR(s_hCryptDlg, CertViewPropertiesA)
            }
        }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

BOOL CryptUIAvailable(void) {
    DemandLoadCryptDlg();
    return(s_fCertViewPropertiesCryptUIA);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL DemandLoadWinTrust()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hWinTrust)
        {
        s_hWinTrust = LoadLibrary(TEXT("WINTRUST.DLL"));
        AssertSz((NULL != s_hWinTrust), TEXT("LoadLibrary failed on WINTRUST.DLL"));

        if (0 == s_hWinTrust)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hWinTrust, WinVerifyTrust)
            }
        }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL DemandLoadVersion()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hVersion)
        {
        s_hVersion = LoadLibrary(TEXT("VERSION.DLL"));
        AssertSz((NULL != s_hVersion), TEXT("LoadLibrary failed on VERSION.DLL"));

        if (0 == s_hVersion)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hVersion, GetFileVersionInfoSizeW)
            GET_PROC_ADDR(s_hVersion, GetFileVersionInfoW)
            GET_PROC_ADDR(s_hVersion, VerQueryValueW)
            GET_PROC_ADDR(s_hVersion, GetFileVersionInfoSizeA)
            GET_PROC_ADDR(s_hVersion, GetFileVersionInfoA)
            GET_PROC_ADDR(s_hVersion, VerQueryValueA)
            }
        }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

BOOL DemandLoadImm32()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hImm32)
        {
        s_hImm32 = LoadLibrary(TEXT("IMM32.DLL"));
        AssertSz((NULL != s_hImm32), TEXT("LoadLibrary failed on IMM32.DLL"));

        if (0 == s_hImm32)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hImm32, ImmAssociateContext)
            GET_PROC_ADDR(s_hImm32, ImmGetContext)
            GET_PROC_ADDR(s_hImm32, ImmGetCompositionStringW)
            GET_PROC_ADDR(s_hImm32, ImmReleaseContext)
            }
        }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

BOOL DemandLoadWininet()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hWininet)
        {
        s_hWininet = LoadLibrary(TEXT("wininet.dll"));
        AssertSz((NULL != s_hWininet), TEXT("LoadLibrary failed on Wininet.DLL"));

        if (0 == s_hWininet)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hWininet, InternetCanonicalizeUrlW)
            GET_PROC_ADDR(s_hWininet, InternetGetConnectedState)
            }
        }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}


BOOL DemandLoadURLMON(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hUrlmon)
        {
        s_hUrlmon = LoadLibrary(TEXT("URLMON.DLL"));
        AssertSz((NULL != s_hUrlmon), TEXT("LoadLibrary failed on Urlmon.DLL"));

        if (0 == s_hUrlmon)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hUrlmon, ObtainUserAgentString);
            }
        }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}


///////////////////////////////////////////////////////////////////////////////
//  DemandLoadShlwapi()
//
//  Only load version 5.0 or greater
///////////////////////////////////////////////////////////////////////////////
static const TCHAR c_szShlwapiDll[] = TEXT("shlwapi.dll");

HINSTANCE DemandLoadShlwapi()
{
    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (!s_hShlwapi)
        s_hShlwapi = LoadLibrary(c_szShlwapiDll);

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif

    return s_hShlwapi;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\demand.h ===
/*
**	d e m a n d . h
**	
**	Purpose: create an intelligent method of defer loading functions
**
**  Creators: jimsch, brimo, t-erikne
**  Created: 5/15/97
**	
**	Copyright (C) Microsoft Corp. 1997
*/


#if !defined(__DEMAND_H) || defined(IMPLEMENT_LOADER_FUNCTIONS)

#ifndef __DEMAND_H
#define __DEMAND_H
#endif


#ifdef IMPLEMENT_LOADER_FUNCTIONS

#define USE_CRITSEC

#undef LOADER_FUNCTION
#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret LOADER_##name args1                         \
        {                                               \
           DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return err; \
           return VAR_##name args2;                     \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#undef LOADER_FUNCTION_VOID
#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret LOADER_##name args1                         \
        {                                               \
           DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return;     \
           VAR_##name args2;                            \
           return;                                      \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#else  // !IMPLEMENT_LOADER_FUNCTIONS

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;

#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;

#endif // IMPLEMENT_LOADER_FUNCTIONS

void InitDemandLoadedLibs();
void FreeDemandLoadedLibs();

/////////////////////////////////////
// CRYPT32.DLL

BOOL DemandLoadCrypt32(void);

typedef void *HCERTSTORE;
typedef const struct _CERT_CONTEXT *PCCERT_CONTEXT;
typedef ULONG_PTR HCRYPTPROV;
typedef struct _CERT_INFO *PCERT_INFO;

LOADER_FUNCTION( BOOL, CertFreeCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext),
    FALSE, Crypt32)
#define CertFreeCertificateContext VAR_CertFreeCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertDuplicateCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext), NULL, Crypt32)
#define CertDuplicateCertificateContext VAR_CertDuplicateCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertFindCertificateInStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext),
    NULL, Crypt32)
#define CertFindCertificateInStore VAR_CertFindCertificateInStore

LOADER_FUNCTION( LONG, CertVerifyTimeValidity,
    (LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo),
    (pTimeToVerify, pCertInfo),
    1, Crypt32)
#define CertVerifyTimeValidity VAR_CertVerifyTimeValidity

LOADER_FUNCTION( BOOL, CertCloseStore,
    (HCERTSTORE hCertStore, DWORD dwFlags),
    (hCertStore, dwFlags),
    FALSE, Crypt32)
#define CertOpenSystemStoreA VAR_CertOpenSystemStoreA

LOADER_FUNCTION( HCERTSTORE, CertOpenSystemStoreA,
    (HCRYPTPROV hProv, LPCSTR szSubsystemProtocol),
    (hProv, szSubsystemProtocol),
    NULL, Crypt32)
#define CertCloseStore VAR_CertCloseStore

LOADER_FUNCTION( BOOL, CertGetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData),
    (pCertContext, dwPropId, pvData, pcbData),
    FALSE, Crypt32)
#define CertGetCertificateContextProperty VAR_CertGetCertificateContextProperty

LOADER_FUNCTION( HCERTSTORE, CertOpenStore,
    (LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV hCryptProv, DWORD dwFlags, const void *pvPara),
    (lpszStoreProvider, dwEncodingType, hCryptProv, dwFlags, pvPara),
    NULL, Crypt32)
#define CertOpenStore VAR_CertOpenStore

LOADER_FUNCTION( BOOL, CertCompareCertificate,
    (DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2),
    (dwCertEncodingType, pCertId1, pCertId2),
    FALSE, Crypt32)
#define CertCompareCertificate VAR_CertCompareCertificate

/////////////////////////////////////
// ADVAPI32.DLL

#ifndef ALGIDDEF
    #define ALGIDDEF
    typedef unsigned int ALG_ID;
#endif
typedef ULONG_PTR HCRYPTKEY;

BOOL DemandLoadAdvApi32(void);

LOADER_FUNCTION( BOOL, CryptAcquireContextA,
    (HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags),
    (phProv, pszContainer, pszProvider, dwProvType, dwFlags),
    FALSE, AdvApi32)
#define CryptAcquireContextA VAR_CryptAcquireContextA

LOADER_FUNCTION( BOOL, CryptAcquireContextW,
    (HCRYPTPROV *phProv, LPCTSTR pszContainer, LPCTSTR pszProvider, DWORD dwProvType, DWORD dwFlags),
    (phProv, pszContainer, pszProvider, dwProvType, dwFlags),
    FALSE, AdvApi32)
#define CryptAcquireContextW VAR_CryptAcquireContextW

LOADER_FUNCTION( BOOL, CryptReleaseContext,
    (HCRYPTPROV hProv, DWORD dwFlags),
    (hProv, dwFlags),
    FALSE, AdvApi32)
#define CryptReleaseContext VAR_CryptReleaseContext

LOADER_FUNCTION( BOOL, CryptMsgClose,
    (HCRYPTMSG hCryptMsg),
    (hCryptMsg),
    FALSE, Crypt32)
#define CryptMsgClose VAR_CryptMsgClose

LOADER_FUNCTION( BOOL, CryptDecodeObjectEx,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE * pbEncoded,
     DWORD cbEncoded, DWORD dwFlags, PCRYPT_DECODE_PARA pDecodePara,
     void * pvStructInfo, DWORD * pcbStructInfo),
    (dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags,
     pDecodePara, pvStructInfo, pcbStructInfo),
    FALSE, Crypt32)
#define CryptDecodeObjectEx VAR_CryptDecodeObjectEx

LOADER_FUNCTION( BOOL, CryptMsgGetParam,
    (HCRYPTMSG hCryptMsg, DWORD dwParamType, DWORD dwIndex, void *pvData, DWORD *pcbData),
    (hCryptMsg, dwParamType, dwIndex, pvData, pcbData),
    FALSE, Crypt32)
#define CryptMsgGetParam VAR_CryptMsgGetParam

LOADER_FUNCTION( BOOL, CryptMsgUpdate,
    (HCRYPTMSG hCryptMsg, const BYTE *pbData, DWORD cbData, BOOL fFinal),
    (hCryptMsg, pbData, cbData, fFinal),
    FALSE, Crypt32)
#define CryptMsgUpdate VAR_CryptMsgUpdate

LOADER_FUNCTION( HCRYPTMSG, CryptMsgOpenToDecode,
    (DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, HCRYPTPROV hCryptProv, PCERT_INFO pRecipientInfo, PCMSG_STREAM_INFO pStreamInfo),
    (dwMsgEncodingType, dwFlags, dwMsgType, hCryptProv, pRecipientInfo, pStreamInfo),
    NULL, Crypt32)
#define CryptMsgOpenToDecode VAR_CryptMsgOpenToDecode

LOADER_FUNCTION( BOOL, CertAddCertificateContextToStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext),
    (hCertStore, pCertContext, dwAddDisposition, ppStoreContext),
    FALSE, Crypt32)
#define CertAddCertificateContextToStore VAR_CertAddCertificateContextToStore

/////////////////////////////////////
// PSTOREC.DLL

#ifndef __IEnumPStoreProviders_FWD_DEFINED__
    #define __IEnumPStoreProviders_FWD_DEFINED__
    typedef interface IEnumPStoreProviders IEnumPStoreProviders;
#endif 	/* __IEnumPStoreProviders_FWD_DEFINED__ */
#ifndef __IPStore_FWD_DEFINED__
    #define __IPStore_FWD_DEFINED__
    typedef interface IPStore IPStore;
#endif 	/* __IPStore_FWD_DEFINED__ */
typedef GUID PST_PROVIDERID;

BOOL DemandLoadPStoreC();

LOADER_FUNCTION( HRESULT, PStoreCreateInstance,
    (IPStore __RPC_FAR *__RPC_FAR *ppProvider, PST_PROVIDERID __RPC_FAR *pProviderID, void __RPC_FAR *pReserved, DWORD dwFlags),
    (ppProvider, pProviderID, pReserved, dwFlags),
    E_FAIL, PStoreC)
#define PStoreCreateInstance VAR_PStoreCreateInstance

LOADER_FUNCTION( HRESULT, PStoreEnumProviders,
    (DWORD dwFlags, IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum),
    (dwFlags, ppenum),
    E_FAIL, PStoreC)
#define PStoreEnumProviders VAR_PStoreEnumProviders


/////////////////////////////////////
// CRYPTDLG.DLL

BOOL DemandLoadCryptDlg();

LOADER_FUNCTION( DWORD, GetFriendlyNameOfCertA,
    (PCCERT_CONTEXT pccert, LPSTR pchBuffer, DWORD cchBuffer),
    (pccert, pchBuffer, cchBuffer),
    0, CryptDlg)
#define GetFriendlyNameOfCertA VAR_GetFriendlyNameOfCertA

LOADER_FUNCTION( BOOL, CertViewPropertiesA,
    (PCERT_VIEWPROPERTIES_STRUCT_A pCertViewInfo),
    (pCertViewInfo),
    FALSE, CryptDlg)
#define CertViewPropertiesA VAR_CertViewPropertiesA

/////////////////////////////////////
// WINTRUST.DLL

BOOL DemandLoadWinTrust();

LOADER_FUNCTION( LONG, WinVerifyTrust,
    (HWND hwnd, GUID *ActionID, LPVOID ActionData),
    (hwnd, ActionID, ActionData),
    0, WinTrust)
#define WinVerifyTrust VAR_WinVerifyTrust

/////////////////////////////////////
// VERSION.DLL

BOOL DemandLoadVersion(void);

LOADER_FUNCTION( DWORD, GetFileVersionInfoSizeA,
    (LPSTR lptstrFileName, LPDWORD lpdwHandle),
    (lptstrFileName, lpdwHandle),
    0, Version)
#define GetFileVersionInfoSizeA VAR_GetFileVersionInfoSizeA

LOADER_FUNCTION( BOOL, GetFileVersionInfoA,
    (LPSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData),
    (lptstrFilename, dwHandle, dwLen, lpData),
    FALSE, Version)
#define GetFileVersionInfoA VAR_GetFileVersionInfoA

LOADER_FUNCTION( BOOL, VerQueryValueA,
    (const LPVOID pBlock, LPSTR lpSubBlock, LPVOID * lplpBuffer, PUINT puLen),
    (pBlock, lpSubBlock, lplpBuffer, puLen),
    FALSE, Version)
#define VerQueryValueA VAR_VerQueryValueA

LOADER_FUNCTION( DWORD, GetFileVersionInfoSizeW,
    (LPTSTR lptstrFileName, LPDWORD lpdwHandle),
    (lptstrFileName, lpdwHandle),
    0, Version)
#define GetFileVersionInfoSizeW VAR_GetFileVersionInfoSizeW

LOADER_FUNCTION( BOOL, GetFileVersionInfoW,
    (LPTSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData),
    (lptstrFilename, dwHandle, dwLen, lpData),
    FALSE, Version)
#define GetFileVersionInfoW VAR_GetFileVersionInfoW

LOADER_FUNCTION( BOOL, VerQueryValueW,
    (const LPVOID pBlock, LPTSTR lpSubBlock, LPVOID * lplpBuffer, PUINT puLen),
    (pBlock, lpSubBlock, lplpBuffer, puLen),
    FALSE, Version)
#define VerQueryValueW VAR_VerQueryValueW


/////////////////////////////////////
// URLMON.DLL

BOOL DemandLoadURLMON();

LOADER_FUNCTION( HRESULT, ObtainUserAgentString,
    (DWORD dwOption, LPSTR pszUAOut, DWORD* cbSize),
    (dwOption, pszUAOut, cbSize),
    E_FAIL, URLMON)
#define ObtainUserAgentString VAR_ObtainUserAgentString

// IMM32.DLL
BOOL DemandLoadImm32(void);

LOADER_FUNCTION(HIMC, ImmAssociateContext,
                (HWND hWnd,     HIMC hIMC),
                (hWnd, hIMC),
                0, Imm32)
#define ImmAssociateContext VAR_ImmAssociateContext

LOADER_FUNCTION(HIMC, ImmGetContext,
                (HWND hWnd),
                (hWnd),
                0, Imm32)
#define ImmGetContext VAR_ImmGetContext

LOADER_FUNCTION(LONG, ImmGetCompositionStringW,
                (HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen),
                (hIMC, dwIndex, lpBuf, dwBufLen),
                0, Imm32)
#define ImmGetCompositionStringW VAR_ImmGetCompositionStringW

LOADER_FUNCTION(BOOL, ImmReleaseContext,
                (HWND hWnd, HIMC hIMC),
                (hWnd, hIMC),
                0, Imm32)
#define ImmReleaseContext VAR_ImmReleaseContext

// Wininet.DLL
BOOL DemandLoadWininet(void);

LOADER_FUNCTION(BOOL, InternetCanonicalizeUrlW,
                (LPCWSTR lpszUrl, LPWSTR lpszBuffer, LPDWORD lpdwBufferLength, DWORD dwFlags),
                (lpszUrl, lpszBuffer, lpdwBufferLength, dwFlags),
                FALSE, Wininet)
#define InternetCanonicalizeUrlW VAR_InternetCanonicalizeUrlW

LOADER_FUNCTION(BOOL, InternetGetConnectedState,
                (LPDWORD lpdwFlags, DWORD dwReserved),
                (lpdwFlags, dwReserved),
                FALSE, Wininet)
#define InternetGetConnectedState VAR_InternetGetConnectedState


///////////////////////////////////////////////////////////////////////////////
//  SHLWAPI.DLL

HINSTANCE DemandLoadShlwapi();

///////////////////////////////////////////////////////////////////////////////
//  Plus UI wrapper functions for WinHelp and HtmlHelp functions.  If 5.0 (IE5)
//  version of Shlwapi.dll is available then its version of the functions are
//  used.  Default is to system versions.  If runnint WinNT5.0 or greater then
//  cross codepage is used.
//
//  Implementation of these functions are in the entry.c file
///////////////////////////////////////////////////////////////////////////////
BOOL WinHelpWrap(HWND hWndCaller, LPCTSTR pwszHelpFile, UINT uCommand, DWORD_PTR dwData);
#define WABWinHelp WinHelpWrap

HWND HtmlHelpWrap(HWND hWndCaller, LPCTSTR pwszHelpFile, UINT uCommand, DWORD_PTR dwData);
#define WABHtmlHelp HtmlHelpWrap

#endif // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\fonts.h ===
#ifndef _FONTS_H
#define _FONTS_H

#include <richedit.h>

enum {
    fntsSysIcon=0,
    fntsSysIconBold,
    //fntsSysIconItalic,
    //fntsSysIconBoldItalic,
    //fntsSysMenu,
    //fntsFolderNameHorz,
    //fntsFolderNameVert,
    fntsMax
    };

BOOL InitFonts(void);
HFONT GetFont(int ifont);
void DeleteFonts(void);

#endif      //_FONTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\dochost.c ===
/*********************************************************************************

    DocHost.c
       - This file contains the code for implementing a DOC Object COntainer
            which we will use to host trident

    Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.

    Revision History:

    When		 Who				 What
    --------	 ------------------  ---------------------------------------
    04/22/97    Vikram Madan        Ported from athenas dochost code

***********************************************************************************/

#include <_apipch.h>

LPTSTR c_szWABDocHostWndClass = TEXT("WAB_DocHost");

LPCREATEURLMONIKER lpfnCreateURLMoniker = NULL;

BOOL fTridentCoinit = FALSE;

//
// Function Prototypes
//
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
void WMSize(LPIWABDOCHOST lpIWABDocHost, int x, int y);
HRESULT HrCreateDocObj(LPIWABDOCHOST lpIWABDocHost, LPCLSID pCLSID);
HRESULT HrShow(LPIWABDOCHOST lpIWABDocHost);
HRESULT HrCloseDocObj(LPIWABDOCHOST lpIWABDocHost);
HRESULT HrDocHost_Init(LPIWABDOCHOST lpIWABDocHost, BOOL fInit);
HRESULT HrCreateDocView(LPIWABDOCHOST lpIWABDocHost, LPOLEDOCUMENTVIEW pViewToActivate);
HRESULT HrLoadTheURL(LPIWABDOCHOST lpWABDH, LPTSTR pszURL);
HRESULT HrLoadFromMoniker(LPIWABDOCHOST lpIWABDocHost, LPMONIKER pmk);



//
//  IWABDocHost jump tables is defined here...
//

IWABDOCHOST_Vtbl vtblIWABDOCHOST = {
    VTABLE_FILL
    IWABDOCHOST_QueryInterface,
    IWABDOCHOST_AddRef,
    IWABDOCHOST_Release,
};


IWDH_OLEWINDOW_Vtbl vtblIWDH_OLEWINDOW = {
    VTABLE_FILL
    (IWDH_OLEWINDOW_QueryInterface_METHOD *) IWABDOCHOST_QueryInterface,
    (IWDH_OLEWINDOW_AddRef_METHOD *)         IWABDOCHOST_AddRef,
    (IWDH_OLEWINDOW_Release_METHOD *)        IWABDOCHOST_Release,
    IWDH_OLEWINDOW_GetWindow,
    IWDH_OLEWINDOW_ContextSensitiveHelp,
};


IWDH_OLEINPLACEFRAME_Vtbl vtblIWDH_OLEINPLACEFRAME = {
    VTABLE_FILL
    (IWDH_OLEINPLACEFRAME_QueryInterface_METHOD *)   IWABDOCHOST_QueryInterface,
    (IWDH_OLEINPLACEFRAME_AddRef_METHOD *)           IWABDOCHOST_AddRef,
    (IWDH_OLEINPLACEFRAME_Release_METHOD *)          IWABDOCHOST_Release,
    (IWDH_OLEINPLACEFRAME_GetWindow_METHOD *)               IWDH_OLEWINDOW_GetWindow,
    (IWDH_OLEINPLACEFRAME_ContextSensitiveHelp_METHOD *)    IWDH_OLEWINDOW_ContextSensitiveHelp,
    IWDH_OLEINPLACEFRAME_GetBorder,
    IWDH_OLEINPLACEFRAME_RequestBorderSpace,
    IWDH_OLEINPLACEFRAME_SetBorderSpace,
    IWDH_OLEINPLACEFRAME_SetActiveObject,
    IWDH_OLEINPLACEFRAME_InsertMenus,
    IWDH_OLEINPLACEFRAME_SetMenu,
    IWDH_OLEINPLACEFRAME_RemoveMenus,
    IWDH_OLEINPLACEFRAME_SetStatusText,
    IWDH_OLEINPLACEFRAME_EnableModeless,
    IWDH_OLEINPLACEFRAME_TranslateAccelerator,
};


IWDH_OLEINPLACESITE_Vtbl vtblIWDH_OLEINPLACESITE = {
    VTABLE_FILL
    (IWDH_OLEINPLACESITE_QueryInterface_METHOD *)   IWABDOCHOST_QueryInterface,
    (IWDH_OLEINPLACESITE_AddRef_METHOD *)           IWABDOCHOST_AddRef,
    (IWDH_OLEINPLACESITE_Release_METHOD *)          IWABDOCHOST_Release,
    (IWDH_OLEINPLACESITE_GetWindow_METHOD *)               IWDH_OLEWINDOW_GetWindow,
    (IWDH_OLEINPLACESITE_ContextSensitiveHelp_METHOD *)    IWDH_OLEWINDOW_ContextSensitiveHelp,
    IWDH_OLEINPLACESITE_CanInPlaceActivate,
    IWDH_OLEINPLACESITE_OnInPlaceActivate,
    IWDH_OLEINPLACESITE_OnUIActivate,
    IWDH_OLEINPLACESITE_GetWindowContext,
    IWDH_OLEINPLACESITE_Scroll,
    IWDH_OLEINPLACESITE_OnUIDeactivate,
    IWDH_OLEINPLACESITE_OnInPlaceDeactivate,
    IWDH_OLEINPLACESITE_DiscardUndoState,
    IWDH_OLEINPLACESITE_DeactivateAndUndo,
    IWDH_OLEINPLACESITE_OnPosRectChange,
};

IWDH_OLECLIENTSITE_Vtbl vtblIWDH_OLECLIENTSITE = {
    VTABLE_FILL
    (IWDH_OLECLIENTSITE_QueryInterface_METHOD *)   IWABDOCHOST_QueryInterface,
    (IWDH_OLECLIENTSITE_AddRef_METHOD *)           IWABDOCHOST_AddRef,
    (IWDH_OLECLIENTSITE_Release_METHOD *)          IWABDOCHOST_Release,
    IWDH_OLECLIENTSITE_SaveObject,
    IWDH_OLECLIENTSITE_GetMoniker,
    IWDH_OLECLIENTSITE_GetContainer,
    IWDH_OLECLIENTSITE_ShowObject,
    IWDH_OLECLIENTSITE_OnShowWindow,
    IWDH_OLECLIENTSITE_RequestNewObjectLayout,
};


IWDH_OLEDOCUMENTSITE_Vtbl vtblIWDH_OLEDOCUMENTSITE = {
    VTABLE_FILL
    (IWDH_OLEDOCUMENTSITE_QueryInterface_METHOD *)   IWABDOCHOST_QueryInterface,
    (IWDH_OLEDOCUMENTSITE_AddRef_METHOD *)           IWABDOCHOST_AddRef,
    (IWDH_OLEDOCUMENTSITE_Release_METHOD *)          IWABDOCHOST_Release,
    IWDH_OLEDOCUMENTSITE_ActivateMe,
};



//
//  Interfaces supported by this object
//
#define WABDH_cInterfaces 6
LPIID WABDH_LPIID[WABDH_cInterfaces] = 
{
    (LPIID) &IID_IUnknown,
    (LPIID) &IID_IOleWindow,
    (LPIID) &IID_IOleInPlaceFrame,
    (LPIID) &IID_IOleInPlaceSite,
    (LPIID) &IID_IOleClientSite,
    (LPIID) &IID_IOleDocumentSite,
};

//$$
void UninitTrident()
{
    if(fTridentCoinit)
    {
        CoUninitialize();
        fTridentCoinit = FALSE;
    }
}


//$$//////////////////////////////////////////////////////////////////////////
//
// Release memory related to the IWABDocHost pointer
//
//////////////////////////////////////////////////////////////////////////////
void ReleaseDocHostObject(LPIWABDOCHOST lpIWABDocHost)
{
    HrCloseDocObj(lpIWABDocHost);
    SafeRelease(lpIWABDocHost->m_lpOleObj);
    SafeRelease(lpIWABDocHost->m_pDocView);
    SafeRelease(lpIWABDocHost->m_pInPlaceActiveObj);
    HrDocHost_Init(lpIWABDocHost, FALSE);

    DebugTrace(TEXT("IID_IWABDocHost refCount:      %d\n"),lpIWABDocHost->lcInit);
    DebugTrace(TEXT("IID_IOleWindow refCount:       %d\n"),lpIWABDocHost->lpIWDH_OleWindow->lcInit);
    DebugTrace(TEXT("IID_IOleInPlaceFrame refCount: %d\n"),lpIWABDocHost->lpIWDH_OleInPlaceFrame->lcInit);
    DebugTrace(TEXT("IID_IOleInPlaceSite refCount:  %d\n"),lpIWABDocHost->lpIWDH_OleInPlaceSite->lcInit);
    DebugTrace(TEXT("IID_IOleClientSite refCount:   %d\n"),lpIWABDocHost->lpIWDH_OleClientSite->lcInit);
    DebugTrace(TEXT("IID_IOleDocumentSite refCount: %d\n"),lpIWABDocHost->lpIWDH_OleDocumentSite->lcInit);

    MAPIFreeBuffer(lpIWABDocHost);

   return;
}



//$$//////////////////////////////////////////////////////////////////////////
//
// Creates a New IWABDocHost Object
//
//////////////////////////////////////////////////////////////////////////////
HRESULT HrNewWABDocHostObject(LPVOID * lppIWABDocHost)
{

    LPIWABDOCHOST   lpIWABDocHost = NULL;
    SCODE 		     sc;
    HRESULT 	     hr     		   = hrSuccess;

    //
    //  Allocate space for the IAB structure
    //
    if (FAILED(sc = MAPIAllocateBuffer(sizeof(IWABDOCHOST), (LPVOID *) &lpIWABDocHost))) {
        hr = ResultFromScode(sc);
        goto err;
    }

    MAPISetBufferName(lpIWABDocHost,  TEXT("WAB Doc Host Object"));

    ZeroMemory(lpIWABDocHost, sizeof(IWABDOCHOST));

    lpIWABDocHost->lpVtbl = &vtblIWABDOCHOST;

    lpIWABDocHost->cIID = WABDH_cInterfaces;
    lpIWABDocHost->rglpIID = WABDH_LPIID;

    InitializeCriticalSection(&lpIWABDocHost->cs);


    lpIWABDocHost->lpIWDH = lpIWABDocHost;


    sc = MAPIAllocateMore(sizeof(IWABDOCHOST_OLEWINDOW), lpIWABDocHost,  &(lpIWABDocHost->lpIWDH_OleWindow));
    if(sc)
        goto err;
    ZeroMemory(lpIWABDocHost->lpIWDH_OleWindow, sizeof(IWABDOCHOST_OLEWINDOW));
    lpIWABDocHost->lpIWDH_OleWindow->lpVtbl = &vtblIWDH_OLEWINDOW;
    lpIWABDocHost->lpIWDH_OleWindow->lpIWDH = lpIWABDocHost;


    sc = MAPIAllocateMore(sizeof(IWABDOCHOST_OLEINPLACEFRAME), lpIWABDocHost,  &(lpIWABDocHost->lpIWDH_OleInPlaceFrame));
    if(sc)
        goto err;
    ZeroMemory(lpIWABDocHost->lpIWDH_OleInPlaceFrame, sizeof(IWABDOCHOST_OLEINPLACEFRAME));
    lpIWABDocHost->lpIWDH_OleInPlaceFrame->lpVtbl = &vtblIWDH_OLEINPLACEFRAME;
    lpIWABDocHost->lpIWDH_OleInPlaceFrame->lpIWDH = lpIWABDocHost;

    
    sc = MAPIAllocateMore(sizeof(IWABDOCHOST_OLEINPLACESITE), lpIWABDocHost,  &(lpIWABDocHost->lpIWDH_OleInPlaceSite));
    if(sc)
        goto err;
    ZeroMemory(lpIWABDocHost->lpIWDH_OleInPlaceSite, sizeof(IWABDOCHOST_OLEINPLACESITE));
    lpIWABDocHost->lpIWDH_OleInPlaceSite->lpVtbl = &vtblIWDH_OLEINPLACESITE;
    lpIWABDocHost->lpIWDH_OleInPlaceSite->lpIWDH = lpIWABDocHost;


    sc = MAPIAllocateMore(sizeof(IWABDOCHOST_OLECLIENTSITE), lpIWABDocHost,  &(lpIWABDocHost->lpIWDH_OleClientSite));
    if(sc)
        goto err;
    ZeroMemory(lpIWABDocHost->lpIWDH_OleClientSite, sizeof(IWABDOCHOST_OLECLIENTSITE));
    lpIWABDocHost->lpIWDH_OleClientSite->lpVtbl = &vtblIWDH_OLECLIENTSITE;
    lpIWABDocHost->lpIWDH_OleClientSite->lpIWDH = lpIWABDocHost;


    sc = MAPIAllocateMore(sizeof(IWABDOCHOST_OLEDOCUMENTSITE), lpIWABDocHost,  &(lpIWABDocHost->lpIWDH_OleDocumentSite));
    if(sc)
        goto err;
    ZeroMemory(lpIWABDocHost->lpIWDH_OleDocumentSite, sizeof(IWABDOCHOST_OLEDOCUMENTSITE));
    lpIWABDocHost->lpIWDH_OleDocumentSite->lpVtbl = &vtblIWDH_OLEDOCUMENTSITE;
    lpIWABDocHost->lpIWDH_OleDocumentSite->lpIWDH = lpIWABDocHost;


    lpIWABDocHost->lpVtbl->AddRef(lpIWABDocHost);

    *lppIWABDocHost = (LPVOID)lpIWABDocHost;


    return(hrSuccess);

err:

    FreeBufferAndNull(&lpIWABDocHost);

    return(hr);
}




/**
*
* The Interface methods
*
*
***/

STDMETHODIMP_(ULONG)
IWABDOCHOST_AddRef(LPIWABDOCHOST lpIWABDocHost)
{
    //DebugTrace(TEXT(">>>>>AddRef: %x\trefCount: %d->%d\n"),lpIWABDocHost,lpIWABDocHost->lcInit,lpIWABDocHost->lcInit+1);
    return(++(lpIWABDocHost->lcInit));
}

STDMETHODIMP_(ULONG)
IWABDOCHOST_Release(LPIWABDOCHOST lpIWABDocHost)
{
    //DebugTrace(TEXT("<<<<<Release: %x\trefCount: %d->%d\n"),lpIWABDocHost,lpIWABDocHost->lcInit,lpIWABDocHost->lcInit-1);
    if(--(lpIWABDocHost->lcInit)==0 &&
       (lpIWABDocHost == lpIWABDocHost->lpIWDH))
    {
       ReleaseDocHostObject(lpIWABDocHost);
       return (0);
    }

    return(lpIWABDocHost->lcInit);
}


STDMETHODIMP
IWABDOCHOST_QueryInterface(LPIWABDOCHOST lpIWABDocHost,
                          REFIID lpiid,
                          LPVOID * lppNewObj)
{
    LPVOID lp = NULL;

    if(!lppNewObj)
        return MAPI_E_INVALID_PARAMETER;

    *lppNewObj = NULL;

    if(IsEqualIID(lpiid, &IID_IUnknown))
        lp = (LPVOID) lpIWABDocHost->lpIWDH;

    if(IsEqualIID(lpiid, &IID_IOleWindow))
    {
        DebugTrace(TEXT("WABDocHost:QI - IOleWindow\n"));
        lp = (LPVOID) (LPOLEWINDOW) lpIWABDocHost->lpIWDH->lpIWDH_OleWindow;
    }

    if(IsEqualIID(lpiid, &IID_IOleInPlaceUIWindow))
    {
        DebugTrace(TEXT("WABDocHost:QI - IOleInPlaceUIWindow\n"));
        lp = (LPVOID) (LPOLEINPLACEUIWINDOW) lpIWABDocHost->lpIWDH->lpIWDH_OleInPlaceFrame;
    }

    if(IsEqualIID(lpiid, &IID_IOleInPlaceFrame))
    {
        DebugTrace(TEXT("WABDocHost:QI - IOleInPlaceFrame\n"));
        lp = (LPVOID) (LPOLEINPLACEFRAME) lpIWABDocHost->lpIWDH->lpIWDH_OleInPlaceFrame;
    }

    if(IsEqualIID(lpiid, &IID_IOleInPlaceSite))
    {
        DebugTrace(TEXT("WABDocHost:QI - IOleInPlaceSite\n"));
        lp = (LPVOID) (LPOLEINPLACESITE) lpIWABDocHost->lpIWDH->lpIWDH_OleInPlaceSite;
    }

    if(IsEqualIID(lpiid, &IID_IOleClientSite))
    {
        DebugTrace(TEXT("WABDocHost:QI - IOleClientSite\n"));
        lp = (LPVOID) (LPOLECLIENTSITE) lpIWABDocHost->lpIWDH->lpIWDH_OleClientSite;
    }

    
    if(IsEqualIID(lpiid, &IID_IOleDocumentSite))
    {
        DebugTrace(TEXT("WABDocHost:QI - IOleDocumentSite\n"));
        lp = (LPVOID) (LPOLEDOCUMENTSITE) lpIWABDocHost->lpIWDH->lpIWDH_OleDocumentSite;
    }

    if(!lp)
    {
        return E_NOINTERFACE;
    }

    ((LPIWABDOCHOST) lp)->lpVtbl->AddRef((LPIWABDOCHOST) lp);

    *lppNewObj = lp;

    return S_OK;

}

/*** 
*
*
*    IOleWindowMethods 
*
*
****/

STDMETHODIMP
IWDH_OLEWINDOW_GetWindow(LPIWABDOCHOST_OLEWINDOW lpIWABDocHost,
                      HWND * phWnd)
{
    DebugTrace(TEXT("IOleWindowMethod: GetWindow\n"));
    if(phWnd)
    {
        *phWnd = lpIWABDocHost->lpIWDH->m_hwnd;
    }
    return S_OK;
}


STDMETHODIMP
IWDH_OLEWINDOW_ContextSensitiveHelp(LPIWABDOCHOST_OLEWINDOW lpWABDH,
                                 BOOL   fEnterMode)
{
    DebugTrace(TEXT("IOleWindowMethod: ContextSensitiveHelp\n"));
    return E_NOTIMPL;
}


/***
*
*
* IOleInPlaceUIWindow methods
*
*
***/

STDMETHODIMP
IWDH_OLEINPLACEFRAME_GetBorder(LPIWABDOCHOST_OLEINPLACEFRAME lpWABDH,
                      LPRECT lprc)
{
    DebugTrace(TEXT("IOleInPlaceFrame: GetBorder\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IWDH_OLEINPLACEFRAME_RequestBorderSpace(LPIWABDOCHOST_OLEINPLACEFRAME lpWABDH,
                               LPCBORDERWIDTHS pborderwidths)
{
    DebugTrace(TEXT("IOleInPlaceFrame: RequestBorderSpace\n"));
    return S_OK;
}

STDMETHODIMP
IWDH_OLEINPLACEFRAME_SetBorderSpace(LPIWABDOCHOST_OLEINPLACEFRAME lpWABDH,
                           LPCBORDERWIDTHS pborderwidths)
{
    DebugTrace(TEXT("IOleInPlaceFrame: SetBorderSpace\n"));
    return S_OK;
}

STDMETHODIMP
IWDH_OLEINPLACEFRAME_SetActiveObject(LPIWABDOCHOST_OLEINPLACEFRAME lpWABDH,
                            IOleInPlaceActiveObject * pActiveObject, 
                            LPCOLESTR lpszObjName)
{
    DebugTrace(TEXT("IOleInPlaceFrame: SetActiveObject\n"));
    SafeRelease(lpWABDH->lpIWDH->m_pInPlaceActiveObj);
    lpWABDH->lpIWDH->m_pInPlaceActiveObj = pActiveObject;
    if(lpWABDH->lpIWDH->m_pInPlaceActiveObj)
        lpWABDH->lpIWDH->m_pInPlaceActiveObj->lpVtbl->AddRef(lpWABDH->lpIWDH->m_pInPlaceActiveObj);
    return S_OK;
}


/***
*
*
* IOleInPlaceFrame Methods
*
*
*
***/
STDMETHODIMP
IWDH_OLEINPLACEFRAME_InsertMenus(LPIWABDOCHOST_OLEINPLACEFRAME lpWABDH,
                        HMENU  hMenu,
                        LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    DebugTrace(TEXT("IOleInPlaceFrame: InsertMenus\n"));
    return S_OK;
}

STDMETHODIMP
IWDH_OLEINPLACEFRAME_SetMenu(LPIWABDOCHOST_OLEINPLACEFRAME lpWABDH,
                    HMENU                   hMenu,                  
                    HOLEMENU                hOleMenu,               
                    HWND                    hWnd)
{
    DebugTrace(TEXT("IOleInPlaceFrame: SetMenu\n"));
    return S_OK;
}


STDMETHODIMP
IWDH_OLEINPLACEFRAME_RemoveMenus(LPIWABDOCHOST_OLEINPLACEFRAME lpWABDH,
                    HMENU                   hMenu)
{
    DebugTrace(TEXT("IOleInPlaceFrame: RemoveMenus\n"));
    return S_OK;
}


STDMETHODIMP
IWDH_OLEINPLACEFRAME_SetStatusText(  LPIWABDOCHOST_OLEINPLACEFRAME lpWABDH,
                            LPCOLESTR pszStatusText)
{
    DebugTrace(TEXT("IOleInPlaceFrame: SetStatusText\n"));
    return S_OK;
}


STDMETHODIMP
IWDH_OLEINPLACEFRAME_EnableModeless( LPIWABDOCHOST_OLEINPLACEFRAME lpWABDH,
                            BOOL fEnable)
{
    DebugTrace(TEXT("IOleInPlaceFrame: EnableModeless\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IWDH_OLEINPLACEFRAME_TranslateAccelerator( LPIWABDOCHOST_OLEINPLACEFRAME lpWABDH,
                                  MSG * lpmsg,
                                  WORD wID)
{
    DebugTrace(TEXT("IOleInPlaceFrame: TranslateAccelerator\n"));
    return E_NOTIMPL;
}


/***
*
*
*
* IOleInPlaceSite methods
*
*
***/

STDMETHODIMP
IWDH_OLEINPLACESITE_CanInPlaceActivate( LPIWABDOCHOST_OLEINPLACESITE lpWABDH)
{
    DebugTrace(TEXT("IOleInPlaceSite: CanInPlaceActivate\n"));
    return S_OK;
}


STDMETHODIMP
IWDH_OLEINPLACESITE_OnInPlaceActivate( LPIWABDOCHOST_OLEINPLACESITE lpWABDH)
{
    LPOLEINPLACEOBJECT pInPlaceObj = 0;
    
    DebugTrace(TEXT("IOleInPlaceSite: OnInPlaceActivate\n"));
/**/
    lpWABDH->lpIWDH->m_lpOleObj->lpVtbl->QueryInterface(  lpWABDH->lpIWDH->m_lpOleObj,
                                                        &IID_IOleInPlaceObject,
                                                        (LPVOID *) &pInPlaceObj);
    lpWABDH->lpIWDH->m_pIPObj = pInPlaceObj;

    if(pInPlaceObj)
    {
        pInPlaceObj->lpVtbl->GetWindow(pInPlaceObj,
                                      &(lpWABDH->lpIWDH->m_hwndDocObj));
        Assert(IsWindow(lpWABDH->lpIWDH->m_hwndDocObj));

    }
/**/
    return S_OK;
}



STDMETHODIMP
IWDH_OLEINPLACESITE_OnUIActivate( LPIWABDOCHOST_OLEINPLACESITE lpWABDH)
{
    DebugTrace(TEXT("IOleInPlaceSite: OnUIActivate\n"));
    return S_OK;
}


STDMETHODIMP
IWDH_OLEINPLACESITE_GetWindowContext(   LPIWABDOCHOST_OLEINPLACESITE           lpWABDH,
                                LPOLEINPLACEFRAME *     ppFrame,
                                LPOLEINPLACEUIWINDOW *  ppDoc,               
                                LPRECT                  lprcPosRect,         
                                LPRECT                  lprcClipRect,        
                                LPOLEINPLACEFRAMEINFO   lpFrameInfo)    
{

    DebugTrace(TEXT("IOleInPlaceSite: GetWindowContext\n"));
    
    *ppFrame = (LPOLEINPLACEFRAME)lpWABDH->lpIWDH->lpIWDH_OleInPlaceFrame;
    *ppDoc = NULL; // NULL means doc window is same as frame window
    (*ppFrame)->lpVtbl->AddRef(*ppFrame);   // for the inplace frame

    GetClientRect(lpWABDH->lpIWDH->m_hwnd, lprcClipRect);
    GetClientRect(lpWABDH->lpIWDH->m_hwnd, lprcPosRect);

    lpFrameInfo->fMDIApp = FALSE;
    lpFrameInfo->hwndFrame=lpWABDH->lpIWDH->m_hwnd;
    lpFrameInfo->haccel = NULL;
    lpFrameInfo->cAccelEntries = 0;

    return S_OK;
}


STDMETHODIMP
IWDH_OLEINPLACESITE_Scroll( LPIWABDOCHOST_OLEINPLACESITE lpWABDH,
                    SIZE scrollExtent)
{                   

    DebugTrace(TEXT("IOleInPlaceSite: Scroll\n"));
    return S_OK;
}


STDMETHODIMP
IWDH_OLEINPLACESITE_OnUIDeactivate(LPIWABDOCHOST_OLEINPLACESITE lpWABDH,
                           BOOL fUndoable)
{                   

    DebugTrace(TEXT("IOleInPlaceSite: OnUIDeactivate\n"));
    return S_OK;
}


STDMETHODIMP
IWDH_OLEINPLACESITE_OnInPlaceDeactivate(LPIWABDOCHOST_OLEINPLACESITE lpWABDH)
{                   

    DebugTrace(TEXT("IOleInPlaceSite: OnInPlaceDeactivate\n"));
    SafeRelease(lpWABDH->lpIWDH->m_pIPObj);
    return S_OK;
}


STDMETHODIMP
IWDH_OLEINPLACESITE_DiscardUndoState(LPIWABDOCHOST_OLEINPLACESITE lpWABDH)
{                   

    DebugTrace(TEXT("IOleInPlaceSite: DiscardUndoState\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IWDH_OLEINPLACESITE_DeactivateAndUndo(LPIWABDOCHOST_OLEINPLACESITE lpWABDH)
{                   

    DebugTrace(TEXT("IOleInPlaceSite: DeactivateAndUndo\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IWDH_OLEINPLACESITE_OnPosRectChange(LPIWABDOCHOST_OLEINPLACESITE lpWABDH,
                            LPCRECT lprcPosRect)
{                   

    DebugTrace(TEXT("IOleInPlaceSite: OnPosRectChange\n"));
    return E_NOTIMPL;
}

/****
*
* OLECLIENTSITE methods
*
***/
STDMETHODIMP
IWDH_OLECLIENTSITE_SaveObject(LPIWABDOCHOST_OLECLIENTSITE lpWABDH)
{                   

    DebugTrace(TEXT("IOleClientSite: SaveObject\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IWDH_OLECLIENTSITE_GetMoniker( LPIWABDOCHOST_OLECLIENTSITE lpWABDH,
                        DWORD dwAssign,
                        DWORD dwWhichMoniker, 
                        LPMONIKER * ppmnk)          
{                   

    DebugTrace(TEXT("IOleClientSite: GetMoniker\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IWDH_OLECLIENTSITE_GetContainer(LPIWABDOCHOST_OLECLIENTSITE lpWABDH,
                         LPOLECONTAINER * ppCont)          
{                   

    DebugTrace(TEXT("IOleClientSite: GetContainer\n"));
    if(ppCont)
        *ppCont = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP
IWDH_OLECLIENTSITE_ShowObject(LPIWABDOCHOST_OLECLIENTSITE lpWABDH)        
{                   

    DebugTrace(TEXT("IOleClientSite: ShowObject\n"));
    return S_OK;
}


STDMETHODIMP
IWDH_OLECLIENTSITE_OnShowWindow(LPIWABDOCHOST_OLECLIENTSITE lpWABDH,
                         BOOL fShow)        
{                   

    DebugTrace(TEXT("IOleClientSite: OnShowWindow\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IWDH_OLECLIENTSITE_RequestNewObjectLayout(LPIWABDOCHOST_OLECLIENTSITE lpWABDH)
{                   

    DebugTrace(TEXT("IOleClientSite: RequestNewObjectLayout\n"));
    return E_NOTIMPL;
}



/***
*
*
*
* IOleDocumentSite Methods
*
*
***/

STDMETHODIMP
IWDH_OLEDOCUMENTSITE_ActivateMe(LPIWABDOCHOST_OLEDOCUMENTSITE lpWABDH,
                       LPOLEDOCUMENTVIEW       pViewToActivate)
{                   

    DebugTrace(TEXT("IOleDocumentSite: ActivateMe: %x\n"), pViewToActivate);
    return HrCreateDocView(lpWABDH->lpIWDH, pViewToActivate);
}




/******
*
*
*
* Non Interface functions
*
*
*
*
*******/



LRESULT CALLBACK_16 WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LPIWABDOCHOST lpWABDH;

    lpWABDH = (LPIWABDOCHOST) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch(msg)
    {
        case WM_CREATE:
            {
                LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam;
                lpWABDH = (LPIWABDOCHOST) lpcs->lpCreateParams;
                if(lpWABDH)
                {
                    lpWABDH->m_hwnd = hwnd;
                    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)lpWABDH);
                    lpWABDH->lpVtbl->AddRef(lpWABDH);
                }
                else
                    return -1;
            }
            break;

        case WM_SETFOCUS:
            if(lpWABDH->m_pDocView)
                lpWABDH->m_pDocView->lpVtbl->UIActivate(  lpWABDH->m_pDocView,
                                                                TRUE);
            break;

        case WM_SIZE:
            WMSize(lpWABDH, LOWORD(lParam), HIWORD(lParam));
            return 0;

        case WM_CLOSE:
            return 0;   // prevent alt-f4's

        case WM_NCDESTROY:
            {
                if(lpWABDH)
                {
                    SetWindowLongPtr(lpWABDH->m_hwnd, GWLP_USERDATA, (LPARAM) 0);
                    lpWABDH->m_hwnd = NULL;
                    lpWABDH->lpVtbl->Release(lpWABDH);
                }
            }
            break;
        }
    return DefWindowProc(hwnd, msg, wParam, lParam);
}


//$$
void WMSize(LPIWABDOCHOST lpWABDH, int cxBody, int cyBody)
{
    RECT rc={0};

    if(lpWABDH->m_pDocView)
    {
        rc.bottom=cyBody;
        rc.right=cxBody;

        lpWABDH->m_pDocView->lpVtbl->SetRect(lpWABDH->m_pDocView,
                                                    &rc);
    }
} 



//$$
HRESULT HrCreateDocObj(LPIWABDOCHOST lpWABDH, LPCLSID pCLSID)
{

    HRESULT hr = S_OK;

    if(!pCLSID)
        return MAPI_E_INVALID_PARAMETER;

    Assert(!lpWABDH->m_lpOleObj);
    Assert(!lpWABDH->m_pDocView);

    if (CoInitialize(NULL) == S_FALSE) 
    {
        // Already initialized, undo the extra.
        CoUninitialize();
    }
    else
        fTridentCoinit = TRUE;

    hr = CoCreateInstance(  pCLSID, 
                            NULL, 
                            CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER,
                            &IID_IOleObject, 
                            (LPVOID *)&(lpWABDH->m_lpOleObj));

    if (FAILED(hr))
    {
        DebugTrace(TEXT("!!!!ERROR: Unable to CoCreateInstance(Trident)\n"));
        goto error;
    }

    hr = lpWABDH->m_lpOleObj->lpVtbl->SetClientSite(  lpWABDH->m_lpOleObj,
                                                      (LPOLECLIENTSITE)lpWABDH->lpIWDH_OleClientSite);
    if (FAILED(hr))
        goto error;

error:
    return hr;
}



//$$
HRESULT HrShow(LPIWABDOCHOST lpWABDH)
{
    RECT                rc;
    HRESULT             hr;

    GetClientRect(lpWABDH->m_hwnd, &rc);
  
    hr=lpWABDH->m_lpOleObj->lpVtbl->DoVerb( lpWABDH->m_lpOleObj,
                                            OLEIVERB_SHOW, 
                                            NULL, 
                                            (LPOLECLIENTSITE)lpWABDH->lpIWDH_OleClientSite, 
                                            0, 
                                            lpWABDH->m_hwnd, 
                                            &rc);
    if(FAILED(hr))
        goto error;

error:
    return hr;
}


//$$
HRESULT HrCloseDocObj(LPIWABDOCHOST lpWABDH)
{

    LPOLEINPLACEOBJECT  pInPlaceObj=0;

    if(lpWABDH->lpIWDH->m_pIPObj)
        lpWABDH->lpIWDH->m_pIPObj->lpVtbl->InPlaceDeactivate(lpWABDH->lpIWDH->m_pIPObj);


    if(lpWABDH->m_pDocView)
    {
        lpWABDH->m_pDocView->lpVtbl->Show(lpWABDH->m_pDocView, FALSE);

        lpWABDH->m_pDocView->lpVtbl->UIActivate(lpWABDH->m_pDocView, FALSE);

        lpWABDH->m_pDocView->lpVtbl->CloseView( lpWABDH->m_pDocView, 0);

        lpWABDH->m_pDocView->lpVtbl->SetInPlaceSite(lpWABDH->m_pDocView, NULL);

        SafeRelease(lpWABDH->m_pDocView);
        
        lpWABDH->m_pDocView=NULL;
    }

    if (lpWABDH->m_lpOleObj)
    {

        lpWABDH->m_lpOleObj->lpVtbl->SetClientSite( lpWABDH->m_lpOleObj, NULL);

        // close the ole object, but blow off changes as we have either extracted 
        // them ourselves or don't care.
        lpWABDH->m_lpOleObj->lpVtbl->Close(lpWABDH->m_lpOleObj, OLECLOSE_NOSAVE);

        SafeRelease(lpWABDH->m_lpOleObj);
    }

    lpWABDH->m_pIPObj=NULL;
    
    return NOERROR;
}


//$$
HRESULT HrInit(LPIWABDOCHOST lpWABDH,
               HWND hwndParent, 
               int idDlgItem, 
               DWORD dhbBorder)
{
    HRESULT hr;
    HWND    hwnd;

    if(!IsWindow(hwndParent))
        return MAPI_E_INVALID_PARAMETER;

    hr=HrDocHost_Init(lpWABDH, TRUE);
    if(FAILED(hr))
        goto error;

    {
        RECT rc = {0};
        HWND hWndFrame = GetDlgItem(hwndParent, IDC_DETAILS_TRIDENT_STATIC);
        GetChildClientRect(hWndFrame, &rc);
        hwnd=CreateWindowEx(WS_EX_NOPARENTNOTIFY, //| WS_EX_CLIENTEDGE,
                            c_szWABDocHostWndClass, 
                            NULL,
                            WS_VISIBLE|WS_CLIPCHILDREN|WS_CLIPSIBLINGS|WS_CHILD|WS_TABSTOP,
                            rc.left,rc.top,
                            rc.right-rc.left,rc.bottom-rc.top, 
                            hwndParent, 
                            (HMENU)IntToPtr(idDlgItem), 
                            hinstMapiXWAB, 
                            (LPVOID)lpWABDH);
        if(!hwnd)
        {
            hr=MAPI_E_NOT_ENOUGH_MEMORY;
            goto error;
        }
    }


error:
    return hr;
}


//$$
HRESULT HrDocHost_Init(LPIWABDOCHOST lpWABDH, BOOL fInit)
{
    static BOOL fInited=FALSE;

    WNDCLASS    wc={0};

    if(fInit)
    {
        if(fInited)         // already regisered
            return NOERROR;

        wc.lpfnWndProc   = (WNDPROC)WndProc; //CDocHost::ExtWndProc;
        wc.hInstance     = hinstMapiXWAB;
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.lpszClassName = c_szWABDocHostWndClass;
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        wc.style = CS_DBLCLKS;

        if(!RegisterClass(&wc)) // This will fail if class is already registered in which case continue
        {
            DebugTrace(TEXT("RegisterClass: %s failed\n"), c_szWABDocHostWndClass);
            if(GetLastError() == ERROR_NOT_ENOUGH_MEMORY)
                return MAPI_E_NOT_ENOUGH_MEMORY;
        }

        fInited=TRUE;
    }
    else
    {
        if (fInited)
        {
            if(!UnregisterClass(c_szWABDocHostWndClass, hinstMapiXWAB))
            {
                DebugTrace(TEXT("Could not Unregister %s. GetLastError(): %d\n"),c_szWABDocHostWndClass, GetLastError());
            }
            fInited=FALSE;
        }
    }

    return S_OK;
}




//$$
HRESULT HrCreateDocView(LPIWABDOCHOST lpWABDH, LPOLEDOCUMENTVIEW pViewToActivate)
{
    HRESULT         hr;
    LPOLEDOCUMENT   pOleDoc=NULL;

    // if we weren't handed a DocumentView pointer, get one
    if(!pViewToActivate)
    {
        hr=OleRun((struct IUnknown *)(lpWABDH->m_lpOleObj));
        if(FAILED(hr))
            goto error;
    
        hr=lpWABDH->m_lpOleObj->lpVtbl->QueryInterface(lpWABDH->m_lpOleObj,
                                                             &IID_IOleDocument, 
                                                             (LPVOID*)&pOleDoc);
        if(FAILED(hr))
            goto error;

        hr=pOleDoc->lpVtbl->CreateView( pOleDoc,
                                        (LPOLEINPLACESITE) lpWABDH->lpIWDH_OleInPlaceSite, 
                                        NULL,
                                        0,
                                        &(lpWABDH->m_pDocView));
        if(FAILED(hr))
            goto error;
    }
    else
        lpWABDH->m_pDocView = pViewToActivate;

    hr=lpWABDH->m_pDocView->lpVtbl->SetInPlaceSite(lpWABDH->m_pDocView,
                                                         (LPOLEINPLACESITE)lpWABDH->lpIWDH_OleInPlaceSite);
    if(FAILED(hr))
        goto error;

    // if we were handed a document view pointer, addref it after calling SetInPlaceSite
    if(pViewToActivate)
        pViewToActivate->lpVtbl->AddRef(pViewToActivate);


    hr=lpWABDH->m_pDocView->lpVtbl->Show( lpWABDH->m_pDocView,
                                                TRUE);
    if(FAILED(hr))
        goto error;

error:
    if(pOleDoc)
        SafeRelease(pOleDoc);
    return hr;
}


//$$ 
HRESULT HrLoadTheURL(LPIWABDOCHOST lpWABDH, LPTSTR pszURL)
{
    WCHAR       wszURL[1024]; //INTERNET_MAX_URL_LENGTH + 1];
    LPMONIKER   pmk=0;
    HINSTANCE hInstURLMON = NULL;
    HRESULT hr = S_OK;
    lstrcpyn(wszURL,pszURL,CharSizeOf(wszURL));
    hInstURLMON = LoadLibrary( TEXT("urlmon.dll"));
    if(!hInstURLMON)
    {
        hr = MAPI_E_NOT_INITIALIZED;
        goto error;
    }
    lpfnCreateURLMoniker = (LPCREATEURLMONIKER) GetProcAddress( hInstURLMON,  "CreateURLMoniker");
    if(!lpfnCreateURLMoniker)
    {
        FreeLibrary(hInstURLMON);
        goto error;
    }

    hr = lpfnCreateURLMoniker(NULL, wszURL, &pmk);

    if(FAILED(hr))
        goto error;

    hr = HrLoadFromMoniker(lpWABDH, pmk);
    if(FAILED(hr))
        goto error;

error:
    if(pmk)
        SafeRelease(pmk); 

    if(lpfnCreateURLMoniker)
        FreeLibrary(hInstURLMON);

    return hr;

}

//$$
HRESULT HrLoadURL(LPIWABDOCHOST lpWABDH, LPTSTR pszURL)
{

    HRESULT     hr=S_OK;
    HCURSOR     hcur;

    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
  
    if(!pszURL)
    {
        hr=MAPI_E_INVALID_PARAMETER;
        goto error;
    }

    if (!lpWABDH->m_lpOleObj)
    {
        hr = HrCreateDocObj(lpWABDH,
                            (LPCLSID)&CLSID_HTMLDocument);
        if(FAILED(hr))
            goto error;

        hr = HrLoadTheURL(lpWABDH, pszURL);

        if(FAILED(hr))
            goto error;

        hr = HrShow(lpWABDH);

        if (FAILED(hr))
            goto error;
    }



error:

    if(hcur)
        SetCursor(hcur);

    return hr;

}




//$$
HRESULT HrLoadFromMoniker(LPIWABDOCHOST lpWABDH,
                          LPMONIKER pmk)
{
    HRESULT             hr=E_FAIL;
    LPPERSISTMONIKER    pPMoniker=0;
    LPBC                pbc=0;

    hr=lpWABDH->m_lpOleObj->lpVtbl->QueryInterface(lpWABDH->m_lpOleObj,
                                                        &IID_IPersistMoniker, 
                                                        (LPVOID *)&pPMoniker);
    if(FAILED(hr))
        goto error;

    hr=CreateBindCtx(0, &pbc);
    if(FAILED(hr))
        goto error;

    hr=pPMoniker->lpVtbl->Load( pPMoniker,
                                TRUE, 
                                pmk, 
                                pbc, 
                                STGM_READWRITE);
    if(FAILED(hr))
        goto error;

error:
    if(pbc)
        SafeRelease(pbc); 

    if(pPMoniker)
        SafeRelease(pPMoniker); 

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\glheap.h ===
/*
 * glheap.h
 *
 * Implementation of global and local heaps
 *
 * Copyright (C) 1994 Microsoft Corporation
 */

#ifndef __GLHEAP_H_
#define __GLHEAP_H_

#ifdef __cplusplus
extern "C" {
#endif

/* Windows 95 Implementation -------------------------------------------------- */

#ifdef CHICAGO

#define GH_POINTERS_VALID

typedef DWORD			GHNAME, * PGHNAME,	** PPGHNAME;
typedef DWORD			GHID,	* PGHID,	** PPGHID;
typedef struct GHDR		GHDR,	* PGHDR,	** PPGHDR;
typedef struct GH		GH,  	* PGH,		** PPGH;
typedef PGH				_HGH;
typedef HANDLE			_HLH;

struct GHDR {
	PGHDR			pghdrNext;		// Pointer to next heap
	HANDLE			hHeap;			// Handle to the heap
	GHNAME			ghname;			// Name of the heap
	GHID			ghidRoot;		// Client root heap block
	ULONG			cRef;			// Number of active clients
};

struct GH {
	HANDLE			hHeap;			// Handle to the heap
	HANDLE			hMutex;			// Handle to mutex for this heap
	PGHDR			pghdr;			// Pointer to the heap header block
	#ifdef DEBUG
	UINT			cMutex;			// Mutex entry count
	#endif
};

__inline void HeapFreeZ(HANDLE hHeap, LPVOID pv)
{
	if (pv)
		HeapFree(hHeap, 0, pv);
}

_HGH	_GH_Open(BOOL fCreate, GHNAME ghname, DWORD dwMaxHeap);
void	_GH_Close(_HGH hgh);
#define _GH_GetRoot(hgh)			((hgh)->pghdr->ghidRoot)
#define _GH_SetRoot(hgh, ghid)		((hgh)->pghdr->ghidRoot = (ghid))
#define _GH_GetName(hgh)			((hgh)->pghdr->ghname)
#define _GH_GetPv(hgh, ghid)		((LPVOID)(ghid))
#define _GH_GetId(hgh, pv)			((GHID)(pv))
#define _GH_GetSize(hgh, ghid)		HeapSize((hgh)->hHeap, 0, (LPVOID)(ghid))
#define _GH_Alloc(hgh, cb)			((GHID)HeapAlloc((hgh)->hHeap, 0, cb))
#define _GH_Realloc(hgh, ghid, cb)	((GHID)HeapReAlloc((hgh)->hHeap, 0, (LPVOID)(ghid), cb))
#define _GH_Free(hgh, ghid)			HeapFreeZ((hgh)->hHeap, (LPVOID)(ghid))

#ifdef DEBUG
BOOL	_GH_WaitForMutex(_HGH hgh, ULONG ulTimeout);
void	_GH_ReleaseMutex(_HGH hgh);
#else
#define	_GH_WaitForMutex(hgh, ulT)	GH_WaitForSingleObject(hgh->hMutex, ulT)
#ifdef __cplusplus
#define _GH_ReleaseMutex(hgh)		::ReleaseMutex((hgh)->hMutex)
#else
#define _GH_ReleaseMutex(hgh)		ReleaseMutex((hgh)->hMutex)
#endif
#endif

#define	_LH_Open(dwMaxHeap)			HeapCreate(0, 0, dwMaxHeap)
#define _LH_Close(hlh)				HeapDestroy(hlh)
#define _LH_Alloc(hlh, cb)			HeapAlloc(hlh, 0, cb)
#define _LH_Realloc(hlh, pv, cb)	HeapReAlloc(hlh, 0, pv, cb)
#define _LH_GetSize(hlh, pv)		HeapSize(hlh, 0, pv)
#define _LH_Free(hlh, pv)			HeapFreeZ(hlh, pv)

#endif

/* Win16 Implementation ---------------------------------------------------- */

#ifdef WIN16

#define GH_POINTERS_VALID

typedef __segment		HPH,	* PHPH,		** PPHPH;
typedef DWORD			HPID,	* PHPID,	** PPHPID;
typedef DWORD			GHNAME, * PGHNAME,	** PPGHNAME;
typedef HPID			GHID,	* PGHID,	** PPGHID;
typedef HPH				_HGH;
typedef HPH				_HLH;

typedef struct HP {
	HPH				hphRoot;		// Pointer to root heap
	HPH				hphPrev;		// Pointer to the previous heap (fShared)
	HPH				hphNext;		// Pointer to next heap (fShared)
	HPH				hphChild;		// Pointer to extended heaps
	BOOL			fShared;		// TRUE if heap is shared across processes
	GHNAME			ghname;			// Name of the shared heap (fShared)
	GHID			ghidRoot;		// Client root heap block
	DWORD			dwCurHeap;		// Current size of the heap
	DWORD			dwMaxHeap;		// Maximum size of the heap
	UINT			cRef;			// Number of active clients
	UINT			cbHeap;			// Size of this heap
	UINT			cbFree;			// Maximum contiguous free bytes in heap
} HP, * PHP;

#define HphToPhp(hph)				((PHP)((ULONG)(hph) << 16))
#define HP_CREATE					0x0001
#define HP_SHARED					0x0002

HPH		HP_Open(UINT uiFlags, GHNAME ghname, DWORD dwMaxHeap);
void	HP_Close(HPH hph);
HPID	HP_Alloc(HPH hph, UINT cb);
HPID	HP_Realloc(HPH hph, HPID hpid, UINT cb);
void	HP_Free(HPH hph, HPID hpid);
#define	HP_GetSize(hgh, hpid)		(*((UINT *)(hpid) - 2))

#define _GH_Open(fCreate, ghname, dwMaxHeap) \
			HP_Open(HP_SHARED | !!(fCreate), ghname, dwMaxHeap)
#define	_GH_Close(hgh)				HP_Close(hgh)
#define _GH_GetRoot(hgh)			(HphToPhp(hgh)->ghidRoot)
#define _GH_SetRoot(hgh, ghid)		(HphToPhp(hgh)->ghidRoot = (ghid))
#define _GH_GetName(hgh)			(HphToPhp(hgh)->ghname)
#define _GH_GetPv(hgh, ghid)		((LPVOID)(ghid))
#define _GH_GetId(hgh, pv)			((GHID)(pv))
#define _GH_GetSize(hgh, ghid)		HP_GetSize(hgh, ghid)
#define _GH_Alloc(hgh, cb)			((GHID)HP_Alloc(hgh, cb))
#define _GH_Realloc(hgh, ghid, cb)	((GHID)HP_Realloc(hgh, ghid, cb))
#define _GH_Free(hgh, ghid)			HP_Free(hgh, ghid)
#define _GH_WaitForMutex(hgh, ul)	(TRUE)
#define _GH_ReleaseMutex(hgh)

#define HeapFreeZ(hHeap, pv)           \
                   if (pv)             \
                        HeapFree(hHeap, 0, pv);

#define	_LH_Open(dwMaxHeap)		HeapCreate(0, 0, dwMaxHeap)
#define _LH_Close(_hlh)			HeapDestroy(_hlh)
#define _LH_Alloc(_hlh, cb)		HeapAlloc(_hlh, 0, cb)
#define _LH_Realloc(_hlh, pv, cb)	HeapReAlloc(_hlh, 0, pv, cb)
#define _LH_GetSize(_hlh, pv)		HeapSize(_hlh, 0, pv)
#define _LH_Free(_hlh, pv)		HeapFreeZ(_hlh, pv)

#endif

/* NT Implementation ------------------------------------------------------- */

#if defined(WIN32) && !defined(CHICAGO) && !defined(MAC) 

typedef DWORD			GHNAME, * PGHNAME,	** PPGHNAME;
typedef DWORD			GHID,	* PGHID,	** PPGHID;
typedef struct GROOT	GROOT,	* PGROOT,	** PPGROOT;
typedef struct GH		GH,		* PGH,		** PPGH;
typedef PGH				_HGH;
typedef HANDLE			_HLH;

struct GROOT
{
	DWORD			dwBLK;			// Block header
	GHNAME			ghname;			// Name of the heap
	GHID			ghidRoot;		// Client root heap block
	DWORD			dwCurHeap;		// Current size of the heap
	DWORD			dwMaxHeap;		// Maximum size of the heap
	WORD			rgcbFree[1];	// Maximum contiguous free bytes per page
};

struct GH
{
	PGROOT			pgroot;			// Pointer to the first byte of the heap
	HANDLE			hMutex;			// Handle to public mutex for this heap
	HANDLE			hMutexHeap;		// Handle to private mutex for this heap
	HANDLE			hMapping;		// Handle to file mapping object
};

typedef struct GH_SECURITY_ATTRIBUTES {
	SECURITY_ATTRIBUTES		sa;
	BYTE					rgbSd[SECURITY_DESCRIPTOR_MIN_LENGTH];
} GH_SECURITY_ATTRIBUTES, * PGH_SECURITY_ATTRIBUTES;

BOOL	GH_InitializeSecurityAttributes(PGH_SECURITY_ATTRIBUTES pghsa);

__inline void HeapFreeZ(HANDLE hHeap, LPVOID pv)
{
	if (pv)
		HeapFree(hHeap, 0, pv);
}

BOOL	_GH_WaitForMutex(_HGH hgh, ULONG ulTimeout);
_HGH	_GH_Open(BOOL fCreate, GHNAME ghname, DWORD dwMaxHeap);
void	_GH_Close(_HGH hgh);
GHID	_GH_Alloc(_HGH hgh, UINT cb);
GHID	_GH_Realloc(_HGH hgh, GHID ghid, UINT cb);
void	_GH_Free(_HGH hgh, GHID ghid);

#define _GH_GetPv(hgh, ghid)		((LPVOID)((BYTE *)(hgh)->pgroot + (ghid)))
#define _GH_GetId(hgh, pv)			((BYTE *)(pv) - (BYTE *)(hgh)->pgroot)
#define _GH_GetSize(hgh, ghid)		((UINT)*((WORD *)_GH_GetPv(hgh, ghid) - 2))
#define _GH_GetRoot(hgh)			((hgh)->pgroot->ghidRoot)
#define _GH_SetRoot(hgh, ghid)		((hgh)->pgroot->ghidRoot = (ghid))
#define _GH_GetName(hgh)			((hgh)->pgroot->ghname)
#define _GH_WaitForMutex(hgh, ul)	GH_WaitForSingleObject((hgh)->hMutex, ul)
#ifdef __cplusplus
#define _GH_ReleaseMutex(hgh)		::ReleaseMutex((hgh)->hMutex)
#else
#define _GH_ReleaseMutex(hgh)		ReleaseMutex((hgh)->hMutex)
#endif	/* __cplusplus */

#define	_LH_Open(dwMaxHeap)			HeapCreate(0, 0, dwMaxHeap)
#define _LH_Close(_hlh)				HeapDestroy(_hlh)
#define _LH_Alloc(_hlh, cb)			HeapAlloc(_hlh, 0, cb)
#define _LH_Realloc(_hlh, pv, cb)	HeapReAlloc(_hlh, 0, pv, cb)
#define _LH_GetSize(_hlh, pv)		HeapSize(_hlh, 0, pv)
#define _LH_Free(_hlh, pv)			HeapFreeZ(_hlh, pv)

#endif	/* WIN32 */

/* Mac Implementation ------------------------------------------------------ */

#ifdef MAC

#define GH_POINTERS_VALID

typedef DWORD			GHNAME, * PGHNAME,	** PPGHNAME;
typedef DWORD			GHID,	* PGHID,	** PPGHID;
typedef struct GROOT	GROOT,	* PGROOT,	** PPGROOT;
typedef struct GH		GH,		* PGH,		** PPGH;
typedef PGH				_HGH;
typedef HANDLE			_HLH;

struct GROOT
{
	GHID			ghidRoot;		// Root heap block
	GHNAME			ghname;			// Name of the heap
	DWORD			dwCurHeap;		// Current size of the heap
	DWORD			dwMaxHeap;		// Maximum size of the heap
	PGROOT			next;			// Pointer to next shared heap
};

struct GH
{
	LPMALLOC		lpMalloc;		// OLE shared heap allocator (IMalloc interface)
	PGROOT			pgroot;			// Pointer to the first byte of the heap
};

#define _GH_GetRoot(hgh)			((hgh)->pgroot->ghidRoot)
#define _GH_SetRoot(hgh, ghid)		((hgh)->pgroot->ghidRoot = (ghid))
#define _GH_GetName(hgh)			((hgh)->pgroot->ghname)
#define	_GH_WaitForMutex(hgh, ul)	(TRUE)
#define _GH_ReleaseMutex(hgh)
#define _GH_GetPv(hgh, ghid)		((LPVOID)(ghid))
#define _GH_GetId(hgh, pv)			((GHID)(pv))
#define _GH_Close(hgh)				((void)0)

_HGH	_GH_Open(BOOL fCreate, GHNAME ghname, DWORD dwMaxHeap);

__inline GHID _GH_Alloc(_HGH hgh, UINT cb)
{
#ifdef __cplusplus
	return((GHID)hgh->lpMalloc->Alloc(cb));
#else
	return((GHID)hgh->lpMalloc->lpVtbl->Alloc(hgh->lpMalloc, cb));
#endif
}

__inline GHID _GH_Realloc(_HGH hgh, GHID ghid, UINT cb)
{
#ifdef __cplusplus
	return((GHID)hgh->lpMalloc->Realloc((LPVOID)ghid, cb));
#else
	return((GHID)hgh->lpMalloc->lpVtbl->Realloc(hgh->lpMalloc, (LPVOID)ghid, cb));
#endif	
}

__inline UINT _GH_GetSize(_HGH hgh, GHID ghid)
{
#ifdef __cplusplus
	return((UINT)hgh->lpMalloc->GetSize((PVOID)ghid));
#else
	return((UINT)hgh->lpMalloc->lpVtbl->GetSize(hgh->lpMalloc, (PVOID)ghid));
#endif
}

__inline void _GH_Free(_HGH hgh, GHID ghid)
{
#ifdef __cplusplus
	hgh->lpMalloc->Free((LPVOID)ghid);
#else
	hgh->lpMalloc->lpVtbl->Free(hgh->lpMalloc, (LPVOID)ghid);
#endif
}

// -----------

__inline LPVOID _LH_Open(DWORD dwMaxHeap)
{
	LPMALLOC		lpMalloc;
	
	(void) CoGetMalloc(MEMCTX_TASK, &lpMalloc);
	return (void *)lpMalloc;
}

#define _LH_Close(hlh)	((void)0)

__inline LPVOID _LH_Alloc(LPMALLOC hlh, UINT cb)
{
#ifdef __cplusplus
	return((hlh)->Alloc(cb));
#else
	return((hlh)->lpVtbl->Alloc(hlh, cb));
#endif
}

__inline LPVOID _LH_Realloc(LPMALLOC hlh, LPVOID pv, UINT cb)
{
#ifdef __cplusplus
	return(hlh->Realloc(pv, cb));
#else
	return(hlh->lpVtbl->Realloc(hlh, pv, cb));
#endif	
}

__inline UINT _LH_GetSize(LPMALLOC hlh, LPVOID pv)
{
#ifdef __cplusplus
	return((UINT)hlh->GetSize(pv));
#else
	return((UINT)hlh->lpVtbl->GetSize(hlh, pv));
#endif
}

__inline void _LH_Free(LPMALLOC hlh, LPVOID pv)
{
#ifdef __cplusplus
	hlh->Free(pv);
#else
	hlh->lpVtbl->Free(hlh, pv);
#endif
}

#endif /* MAC */

/* DOS Implementation ------------------------------------------------------ */

#ifdef DOS

typedef DWORD			GHID,	* PGHID,	** PPGHID;
typedef LPMALLOC		_HLH;

__inline LPVOID _LH_Alloc(_HLH hlh, UINT cb)
{
#ifdef __cplusplus
	return((hlh)->Alloc(cb));
#else
	return((hlh)->lpVtbl->Alloc(hlh, cb));
#endif
}

__inline LPVOID _LH_Realloc(_HLH hlh, LPVOID pv, UINT cb)
{
#ifdef __cplusplus
	return(hlh->Realloc(pv, cb));
#else
	return(hlh->lpVtbl->Realloc(hlh, pv, cb));
#endif	
}

__inline void _LH_Free(_HLH hlh, LPVOID pv)
{
#ifdef __cplusplus
	hlh->Free(pv);
#else
	hlh->lpVtbl->Free(hlh, pv);
#endif
}

__inline UINT _LH_GetSize(_HLH hlh, LPVOID pv)
{
#ifdef __cplusplus
	return((UINT)hlh->GetSize(pv));
#else
	return((UINT)hlh->lpVtbl->GetSize(hlh, pv));
#endif
}

#endif

// LH External API ------------------------------------------------------------

#if defined(DEBUG) && (defined(WIN16) || defined(WIN32))
#define	IFHEAPNAME(x)	x

typedef struct LH *	HLH;

HLH	WINAPI LH_Open(DWORD dwMaxHeap);
void	WINAPI LH_Close(HLH hlh);
LPVOID	WINAPI LH_Alloc(HLH hlh, UINT cb);
LPVOID	WINAPI LH_Realloc(HLH hlh, LPVOID pv, UINT cb);
UINT	WINAPI LH_GetSize(HLH hlh, LPVOID pv);
void	WINAPI LH_Free(HLH hlh, LPVOID pv);
BOOL
#ifdef MAC
WINAPI
#endif
LH_DidAlloc(HLH hlh, LPVOID pv);

void __cdecl LH_SetHeapNameFn(HLH hlh, TCHAR *pszFormat, ...);
void __cdecl LH_SetNameFn(HLH hlh, LPVOID pv, TCHAR *pszFormat, ...);

TCHAR *	LH_GetName(HLH hlh, LPVOID pv);

#else
#define	IFHEAPNAME(x)	0

typedef _HLH	HLH;

#define	LH_Open(dwMaxHeap)						_LH_Open(dwMaxHeap)
#define LH_Close(hlh)							_LH_Close(hlh)
#define LH_Alloc(hlh, cb)						_LH_Alloc(hlh, cb)
#define LH_Realloc(hlh, pv, cb)					_LH_Realloc(hlh, pv, cb)
#define LH_GetSize(hlh, pv)						_LH_GetSize(hlh, pv)
#define LH_Free(hlh, pv)						_LH_Free(hlh, pv)

#endif

#define LH_SetHeapName(hlh,psz)					IFHEAPNAME(LH_SetHeapNameFn(hlh,psz))
#define LH_SetHeapName1(hlh,psz,a1)				IFHEAPNAME(LH_SetHeapNameFn(hlh,psz,a1))
#define LH_SetHeapName2(hlh,psz,a1,a2)			IFHEAPNAME(LH_SetHeapNameFn(hlh,psz,a1,a2))
#define LH_SetHeapName3(hlh,psz,a1,a2,a3)		IFHEAPNAME(LH_SetHeapNameFn(hlh,psz,a1,a2,a3))
#define LH_SetHeapName4(hlh,psz,a1,a2,a3,a4)	IFHEAPNAME(LH_SetHeapNameFn(hlh,psz,a1,a2,a3,a4))
#define LH_SetHeapName5(hlh,psz,a1,a2,a3,a4,a5)	IFHEAPNAME(LH_SetHeapNameFn(hlh,psz,a1,a2,a3,a4,a5))

#define LH_SetName(hlh,pv,psz)					IFHEAPNAME(LH_SetNameFn(hlh,pv,psz))
#define LH_SetName1(hlh,pv,psz,a1)				IFHEAPNAME(LH_SetNameFn(hlh,pv,psz,a1))
#define LH_SetName2(hlh,pv,psz,a1,a2)			IFHEAPNAME(LH_SetNameFn(hlh,pv,psz,a1,a2))
#define LH_SetName3(hlh,pv,psz,a1,a2,a3)		IFHEAPNAME(LH_SetNameFn(hlh,pv,psz,a1,a2,a3))
#define LH_SetName4(hlh,pv,psz,a1,a2,a3,a4)		IFHEAPNAME(LH_SetNameFn(hlh,pv,psz,a1,a2,a3,a4))
#define LH_SetName5(hlh,pv,psz,a1,a2,a3,a4,a5)	IFHEAPNAME(LH_SetNameFn(hlh,pv,psz,a1,a2,a3,a4,a5))


// GH External API ------------------------------------------------------------

#if !defined(DOS)

typedef _HGH	HGH;

#define	GH_Open(fCreate, ghname, dwMaxHeap)		_GH_Open(fCreate, ghname, \
															dwMaxHeap)
#define	GH_Close(hgh)							_GH_Close(hgh)
#define GH_GetRoot(hgh)							_GH_GetRoot(hgh)
#define GH_SetRoot(hgh, ghid)					_GH_SetRoot(hgh, ghid)
#define GH_GetName(hgh)							_GH_GetName(hgh)
#define GH_GetPv(hgh, ghid)						_GH_GetPv(hgh, ghid)
#define GH_GetId(hgh, pv)						_GH_GetId(hgh, pv)
#define GH_GetSize(hgh, ghid)					_GH_GetSize(hgh, ghid)
#define GH_Alloc(hgh, cb)						_GH_Alloc(hgh, cb)
#define GH_Realloc(hgh, ghid, cb)				_GH_Realloc(hgh, ghid, cb)
#define GH_Free(hgh, ghid)						_GH_Free(hgh, ghid)
#define	GH_WaitForMutex(hgh, ulT)				_GH_WaitForMutex(hgh, ulT)
#define GH_ReleaseMutex(hgh)					_GH_ReleaseMutex(hgh)
#define GH_GetObjectName(pszName, ghname, bTag) _GH_GetObjectName(pszName, \
														ghname, bTag);
#define GH_WaitForSingleObject(hMutex, ulTO)	_GH_WaitForSingleObject(hMutex,\
														ulTO)
#endif

#ifdef	WIN32
#define GH_NAME_CCH			17
#define GH_NAME_MUTEX_1		'*'		/* reserved for internal use */
#define GH_NAME_MUTEX_2		'+'		/* reserved for internal use */
#define GH_NAME_MUTEX_3		'^'
#define GH_NAME_FILE_MAPPING	'!'
void	_GH_GetObjectName(CHAR *pszName, GHNAME ghname, BYTE bTag);

BOOL	_GH_WaitForSingleObject(HANDLE hMutex, ULONG ulTimeout);
#endif


// ----------------------------------------------------------------------------

#ifdef __cplusplus
}
#endif

#endif	// __GLHEAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\entry.c ===
/*
 *	ENTRY.C
 *	
 *	DLL entry functions for extended MAPI. Mostly for debugging
 *	purposes.
 */

#include <_apipch.h>
#include <advpub.h>
#include "htmlhelp.h"


#define _ENTRY_C

#ifdef MAC
#include <utilmac.h>

#define	PvGetInstanceGlobals()		PvGetInstanceGlobalsMac(kInstMAPIX)
#endif

#ifndef MB_SETFOREGROUND
#define MB_SETFOREGROUND 0
#endif

#ifdef	DEBUG

void	ExitCheckInstance(LPINST pinst);
void	ExitCheckInstUtil(LPINSTUTIL pinstUtil);

#endif	

HINSTANCE	hinstMapiX = NULL;      // Instance to the WAB resources module (wab32res.dll)
HINSTANCE	hinstMapiXWAB = NULL;   // Instance of the WAB32.dll module (this dll)

#if 0
// @todo [PaulHi] DLL Leak.  Remove this or implement
extern CRITICAL_SECTION csOMIUnload;
#endif

BOOL fGlobalCSValid = FALSE;

// Global handle for CommCtrl DLL
HINSTANCE       ghCommCtrlDLLInst = NULL;
ULONG           gulCommCtrlDLLRefCount = 0;

extern void DeinitCommDlgLib();

// Global fontinit for UI
BOOL bInitFonts = FALSE;

BOOL g_bRunningOnNT = TRUE; // Checks the OS we run on so Unicode calls can be thunked to Win9x

BOOL bDNisByLN = FALSE;  // Language dependent flag that tells us if the default
                         // display name should be by first name or last name.
TCHAR szResourceDNByLN[32]; // cache the formatting strings so we load them only once
TCHAR szResourceDNByFN[32];
TCHAR szResourceDNByCommaLN[32];

BOOL bPrintingOn = TRUE;// Locale dependent flag that tells us to remove printing entirely
                         // from the UI

// When running against Outlook, we need a way for Outlook
// to signal us about store changes so we can refresh the UI. There are 2
// events we are interested in - 1. to update the list of contact folders
// and 2 to update the list of contacts - we will use 2 events for this
//
HANDLE ghEventOlkRefreshContacts = NULL;
HANDLE ghEventOlkRefreshFolders = NULL;
static const char cszEventOlkRefreshContacts[]  = "WAB_Outlook_Event_Refresh_Contacts";
static const char cszEventOlkRefreshFolders[]  = "WAB_Outlook_Event_Refresh_Folders";

typedef HRESULT (CALLBACK* SHDLLGETVERSIONPROC)(DLLVERSIONINFO *);
typedef HINSTANCE (STDAPICALLTYPE *PFNMLLOADLIBARY)(LPCTSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);
typedef int (STDAPICALLTYPE *PFNMLWINHELP)(HWND hWndCaller, LPCTSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);
typedef HWND (STDAPICALLTYPE *PFNMLHTMLHELP)(HWND hWndCaller, LPCTSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage);



///////////////////////////////////////////////////////////////////////////////
//  bCheckifRunningOnWinNT5
///////////////////////////////////////////////////////////////////////////////
BOOL bCheckifRunningOnWinNT5()
{
    OSVERSIONINFO   osvi = {0};
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&osvi);

    return (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) && (osvi.dwMajorVersion >= 5);
}

///////////////////////////////////////////////////////////////////////////////
//  Load the WAB resource DLL.  This is done every time the WAB32.DLL is loaded.
//  If we have a version 5 or greater SHLWAPI.DLL then we should use the load
//  library function API there.  If we are running NT5 or greater then we
//  use the special cross codepage support.  
//  Also use the new PlugUI version of WinHelp and HtmlHelp APIs in SHLWAPI.DLL
///////////////////////////////////////////////////////////////////////////////

// Copied from shlwapip.h, yuck.
#define ML_NO_CROSSCODEPAGE     0
#define ML_CROSSCODEPAGE_NT     1

static const TCHAR c_szShlwapiDll[] = TEXT("shlwapi.dll");
static const char c_szDllGetVersion[] = "DllGetVersion";
static const TCHAR c_szWABResourceDLL[] = TEXT("wab32res.dll");
static const TCHAR c_szWABDLL[] = TEXT("wab32.dll");


///////////////////////////////////////////////////////////////////////////////
//  LoadWABResourceDLL
//
//  Load the WAB resource DLL using the IE5 or greater Shlwapi.dll LoadLibrary
//  function if available.  Otherwise use the system LoadLibrary function.
//
//  Input Params: hInstWAB32     - handle to WAB DLL
//
//  Returns handle to the loaded resource DLL
///////////////////////////////////////////////////////////////////////////////
HINSTANCE LoadWABResourceDLL(HINSTANCE hInstWAB32)
{
    TCHAR       szPath[MAX_PATH];
    HINSTANCE   hInst = NULL;
    HINSTANCE   hinstShlwapi = LoadLibrary(c_szShlwapiDll);
    PFNMLLOADLIBARY pfnLoadLibrary = NULL;
    
    if (hinstShlwapi)
    {
        SHDLLGETVERSIONPROC pfnVersion;
        DLLVERSIONINFO      info = {0};

        pfnVersion = (SHDLLGETVERSIONPROC)GetProcAddress(hinstShlwapi, c_szDllGetVersion);
        if (pfnVersion)
        {
            info.cbSize = sizeof(DLLVERSIONINFO);
            if (SUCCEEDED(pfnVersion(&info)))
            {
                if (info.dwMajorVersion >= 5)
                    pfnLoadLibrary = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, (LPCSTR)378); // UNICODE ordinal
            }
        }
    }

    // We have special cross codepage support on NT5 and on.
    if (pfnLoadLibrary)
    {
        hInst = pfnLoadLibrary(c_szWABResourceDLL, hInstWAB32, 
                               bCheckifRunningOnWinNT5() ? ML_CROSSCODEPAGE_NT : ML_NO_CROSSCODEPAGE);
    }
    if (!hInst)
        hInst = LoadLibrary(c_szWABResourceDLL);

    // Try full path name for resource DLL
    if ( !hInst && (GetModuleFileName(hInstWAB32, szPath, CharSizeOf(szPath))) )
    {
        int iEnd;

        iEnd = lstrlen(szPath) - lstrlen(c_szWABDLL);
        lstrcpyn(&szPath[iEnd], c_szWABResourceDLL, CharSizeOf(szPath)-iEnd);
        if (pfnLoadLibrary)
        {
            hInst = pfnLoadLibrary(szPath, hInstWAB32, 
                                   bCheckifRunningOnWinNT5() ? ML_CROSSCODEPAGE_NT : ML_NO_CROSSCODEPAGE);
        }
        if (!hInst)
            hInst = LoadLibrary(szPath);
    }

    if (hinstShlwapi)
        FreeLibrary(hinstShlwapi);

    AssertSz(hInst, TEXT("Failed to LoadLibrary Lang Dll"));

    return(hInst);
}

// PlugUI version of WinHelp
BOOL WinHelpWrap(HWND hWndCaller, LPCTSTR pwszHelpFile, UINT uCommand, DWORD_PTR dwData)
{
    static s_fChecked = FALSE;      // Only look for s_pfnWinHelp once
    static PFNMLWINHELP  s_pfnWinHelp = NULL;

    if (!s_pfnWinHelp && !s_fChecked)
    {
        HINSTANCE   hShlwapi = DemandLoadShlwapi();
        s_fChecked = TRUE;
        if (hShlwapi)
        {
            // Check version of the shlwapi.dll
            SHDLLGETVERSIONPROC pfnVersion;
            DLLVERSIONINFO      info = {0};

            pfnVersion = (SHDLLGETVERSIONPROC)GetProcAddress(hShlwapi, c_szDllGetVersion);
            if (pfnVersion)
            {
                info.cbSize = sizeof(DLLVERSIONINFO);

                if (SUCCEEDED(pfnVersion(&info)))
                {
                    if (info.dwMajorVersion >= 5)
                        s_pfnWinHelp = (PFNMLWINHELP)GetProcAddress(hShlwapi, (LPCSTR)397);   // UNICODE ordinal
                }
            }
        }
    }

    if (s_pfnWinHelp)
        return s_pfnWinHelp(hWndCaller, pwszHelpFile, uCommand, dwData);

    // [PaulHi] Win9X version of WinHelpW doesn't work
    if (g_bRunningOnNT)
        return WinHelp(hWndCaller, pwszHelpFile, uCommand, dwData);
    else
    {
        LPSTR   pszHelpFile = ConvertWtoA(pwszHelpFile);
        BOOL    bRtn = WinHelpA(hWndCaller, (LPCSTR)pszHelpFile, uCommand, dwData);

        LocalFreeAndNull(&pszHelpFile);
        return bRtn;
    }
}

// PlugUI version of HtmlHelp
HWND HtmlHelpWrap(HWND hWndCaller, LPCTSTR pwszHelpFile, UINT uCommand, DWORD_PTR dwData)
{
    static s_fChecked = FALSE;      // Only look for s_pfnHtmlHelp once
    static PFNMLHTMLHELP s_pfnHtmlHelp = NULL;

    if (!s_pfnHtmlHelp && !s_fChecked)
    {
        HINSTANCE   hShlwapi = DemandLoadShlwapi();
        s_fChecked = TRUE;
        if (hShlwapi)
        {
            // Check version of the shlwapi.dll
            SHDLLGETVERSIONPROC pfnVersion;
            DLLVERSIONINFO      info = {0};

            pfnVersion = (SHDLLGETVERSIONPROC)GetProcAddress(hShlwapi, c_szDllGetVersion);
            if (pfnVersion)
            {
                info.cbSize = sizeof(DLLVERSIONINFO);

                if (SUCCEEDED(pfnVersion(&info)))
                {
                    if (info.dwMajorVersion >= 5)
                        s_pfnHtmlHelp = (PFNMLHTMLHELP)GetProcAddress(hShlwapi, (LPCSTR)398); // UNICODE ordinal
                }
            }
        }
    }

    if (s_pfnHtmlHelp)
        return s_pfnHtmlHelp(hWndCaller, pwszHelpFile, uCommand, dwData, 
                             bCheckifRunningOnWinNT5() ? ML_CROSSCODEPAGE_NT : ML_NO_CROSSCODEPAGE);

    // [PaulHi] Wide chars work Ok on Win9X
    return HtmlHelp(hWndCaller, pwszHelpFile, uCommand, dwData);
}


/*
-
-   CheckifRunningOnWinNT
*
*   Checks the OS we are running on and returns TRUE for WinNT
*   False for Win9x
*/
BOOL bCheckifRunningOnWinNT()
{
    OSVERSIONINFO osvi = {0};
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&osvi);

    return (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT);
}

#if defined(WIN32) && !defined(MAC)

/*
 *	DLL entry point for Win32
 */

BOOL WINAPI
DllEntryPoint(HINSTANCE hinst, DWORD dwReason, LPVOID lpvReserved)
{
    LPPTGDATA lpPTGData=NULL;

	switch ((short)dwReason)
	{

	case DLL_PROCESS_ATTACH:
		// allocate a TLS index

        g_bRunningOnNT = bCheckifRunningOnWinNT();

		if ((dwTlsIndex = TlsAlloc()) == 0xfffffff)
			return FALSE;

		hinstMapiXWAB = hinst;
        hinstMapiX = LoadWABResourceDLL(hinstMapiXWAB);

        Assert(hinstMapiX);

		if(!hinstMapiX)
		{
			DWORD dwCode = GetLastError();
			DebugTrace(TEXT("WAB32 Resource load failed: %d\n"), dwCode);
		}
        g_msgMSWheel = RegisterWindowMessage(MSH_MOUSEWHEEL);

        bInitFonts = InitFonts();

        // The WAB does a lot of DisplayName formatting and DisplayName parsing
        // For western names we can always assume thathe the First Name comes
        // first in the display name. However for FE and some locales like Hungarian,
        // this is not true so the WAB needs to know when it can assume the 
        // First Name comes first and when it can Assume that the first name
        // comes last ... so localizers set a flag  .. if the string
        // idsLangDisplayNameisByLastName is set to "1" then we know that the
        // default names for this language start with the last name
        // The localizers also set the format templates for defining how a name
        // should be created from the First/Middle/Last names .. for example,
        // in Japanese it is "L F" (no comma) while elsewhere it could be "L,F"
        // All these things are set in localization...
        {
            TCHAR szBuf[32];
            const LPTSTR lpszOne = TEXT("1");
            const LPTSTR lpszDefFormatName = TEXT("%1% %2% %3");

            LoadString(hinstMapiX, idsLangDisplayNameIsByLastName, szBuf, CharSizeOf(szBuf));
            // if szBuf == "1" then Yes, its by last name .. else its not
            TrimSpaces(szBuf);
            if (!lstrcmpi(szBuf,lpszOne))
                bDNisByLN = TRUE;
            else
                bDNisByLN = FALSE;
            DebugTrace(TEXT("bDNisByLN: %d\n"),bDNisByLN);

            // The DNbyLN can be formed using a comma for western and without a comma for most FE and hungarian ..
            // So if the localizers set the lang default to be by LN, then we use the version without the comma,
            // else we use the version with the comma ..
            LoadString( hinstMapiX,idsDisplayNameByLastName,szResourceDNByLN,CharSizeOf(szResourceDNByLN));
            if(!lstrlen(szResourceDNByLN)) //for whatever reason .. cant afford to fail here
                lstrcpy(szResourceDNByLN, lpszDefFormatName);

            LoadString( hinstMapiX,idsDisplayNameByCommaLastName,szResourceDNByCommaLN,CharSizeOf(szResourceDNByCommaLN));
            if(!lstrlen(szResourceDNByCommaLN)) //for whatever reason .. cant afford to fail here
                lstrcpy(szResourceDNByCommaLN, lpszDefFormatName);

            LoadString(hinstMapiX,idsDisplayNameByFirstName,szResourceDNByFN,CharSizeOf(szResourceDNByFN));
            if(!lstrlen(szResourceDNByFN)) //for whatever reason .. cant afford to fail here
                lstrcpy(szResourceDNByFN, lpszDefFormatName);

            LoadString(hinstMapiX, idsLangPrintingOn, szBuf, CharSizeOf(szBuf));
            // if szBuf == "1" then Yes, its by last name .. else its not
            TrimSpaces(szBuf);
            if (!lstrcmpi(szBuf,lpszOne))
                bPrintingOn = TRUE;
            else
                bPrintingOn = FALSE;
            DebugTrace(TEXT("bPrintingOn: %d\n"),bPrintingOn);
        }
        {
            // Create the events needed for synchronizing with the outlook store
            ghEventOlkRefreshContacts = CreateEventA(NULL,   // security attributes
                                                    TRUE,   // Manual reset
                                                    FALSE,  // initial state
                                                    cszEventOlkRefreshContacts);

            ghEventOlkRefreshFolders  = CreateEventA(NULL,   // security attributes
                                                    TRUE,   // Manual reset
                                                    FALSE,  // initial state
                                                    cszEventOlkRefreshFolders);

        }

        // Check for commoncontrol presence for UI
        InitCommonControlLib();

        InitializeCriticalSection(&csUnkobjInit);
		InitializeCriticalSection(&csMapiInit);
		InitializeCriticalSection(&csHeap);
#if 0
        // @todo [PaulHi] DLL Leak.  Remove this or implement
        InitializeCriticalSection(&csOMIUnload);
#endif

		//	Critical section to protect the Address Book's SearchPathCache
		//	This hack is used because we can't enter the IAB's critical
		//	section from ABProviders call to our AdviseSink::OnNotify for
		//	the Merged One-off and Hierarchy tables.
       InitializeCriticalSection(&csMapiSearchPath);
       InitDemandLoadedLibs();

		//  All the CSs have been initialized
		fGlobalCSValid = TRUE;

		// We don't need these, so tell the OS to stop 'em
        // [PaulHi] 3/8/99  Raid 73731  We DO need these calls.  This is the
        // only way thread local storage is deallocated.  Allocation are performed
        // on demand through the WAB GetThreadStoragePointer() function.
#if 0
		DisableThreadLibraryCalls(hinst);
#endif

        ScInitMapiUtil(0);


        // No Break here - fall through to DLL_THREAD_ATTACH
        // for thread initialization

	case DLL_THREAD_ATTACH:

        DebugTrace(TEXT("DllEntryPoint: 0x%.8x THREAD_ATTACH\n"), GetCurrentThreadId());

        // [PaulHi] 3/9/99  There is no need to allocate the thread global data here
        // since the WAB will allocate whenever it needs the data through the
        // GetThreadStoragePointer(), i.e., on demand.
        // Memory leak mentioned below should now be fixed.
#if 0
        lpPTGData = GetThreadStoragePointer();
        // Note the above ThreadStoragePointer seems to leak in every process
        // so avoid using it for anything more...
        if(!lpPTGData)
	    {
		    DebugPrintError((TEXT("DoThreadAttach: LocalAlloc() failed for thread 0x%.8x\n"), GetCurrentThreadId()));
			lpPTGData = NULL;
			return FALSE;
	    }
#endif

        break;


	case DLL_PROCESS_DETACH:
        DebugTrace(TEXT("LibMain: 0x%.8x PROCESS_DETACH\n"), GetCurrentThreadId());
        /*
        if (hMuidMutex) {
            CloseHandle(hMuidMutex);
            hMuidMutex = NULL;
        }
        */
        if(ghEventOlkRefreshContacts)
        {
            CloseHandle(ghEventOlkRefreshContacts);
            ghEventOlkRefreshContacts = NULL;
        }
        if(ghEventOlkRefreshFolders)
        {
            CloseHandle(ghEventOlkRefreshFolders);
            ghEventOlkRefreshFolders = NULL;
        }

        if (bInitFonts)
            DeleteFonts();
        
        if(hinstMapiX)
            FreeLibrary(hinstMapiX);

        // Fall into DLL_THREAD_DETACH to detach last thread
	case DLL_THREAD_DETACH:

        DebugTrace(TEXT("LibMain: 0x%.8x THREAD_DETACH\n"), GetCurrentThreadId());
       
        // get the thread data
		lpPTGData = TlsGetValue(dwTlsIndex);
		if (!lpPTGData)
		{
			// the thread that detaches, did not attach to the DLL. This is allowed.
			DebugTrace(TEXT("LibMain: thread %x didn't attach\n"),GetCurrentThreadId());
			// if this is a PROCESS_DETACH, I still want to go through the process
			// detach stuff, but if it a thread detach, I'm done
		    if (dwReason == DLL_PROCESS_DETACH)
			    goto do_process_detach;
            else
    			break;
		}

        if(pt_hDefFont)
            DeleteObject(pt_hDefFont);
        if(pt_hDlgFont)
            DeleteObject(pt_hDlgFont);

        // For some reason code never hits this point a lot of times
        // and the threadlocalstorage data leaks.
        // [PaulHi] This was because the DLL_TRHEAD_DETACH calls were turned off above,
        // through DisableThreadLibraryCalls().  The leak should be fixed now.
#ifdef HM_GROUP_SYNCING
        LocalFreeAndNull(&(lpPTGData->lptszHMAccountId));
#endif
	    LocalFreeAndNull(&lpPTGData);

		// if this is THREAD_DETACH, we're done
		if (dwReason == DLL_THREAD_DETACH)
			break;


        //N clean up jump stuff in detach
do_process_detach:

        // do process detach stuff here ...
        DeinitMapiUtil();

#ifdef	DEBUG
		{
			// Don't allow asserts to spin a thread
			extern BOOL fInhibitTrapThread;
			fInhibitTrapThread = TRUE;

			ExitCheckInstance((LPINST)PvGetInstanceGlobals());
			ExitCheckInstUtil((LPINSTUTIL)PvGetInstanceGlobalsEx(lpInstUtil));
		}
#endif	/* DEBUG */


        // Unload Common control dll
        if (ghCommCtrlDLLInst != NULL)
            DeinitCommCtrlClientLib();
        DeinitCommDlgLib();

		//  Tearing down all the global CSs
		fGlobalCSValid = FALSE;

		DeleteCriticalSection(&csUnkobjInit);
		DeleteCriticalSection(&csMapiInit);
		DeleteCriticalSection(&csHeap);
#if 0
        // @todo [PaulHi] DLL Leak.  Remove this or implement
        DeleteCriticalSection(&csOMIUnload);
#endif
		DeleteCriticalSection(&csMapiSearchPath);

		// release the TLS index
		TlsFree(dwTlsIndex);

        DeinitCryptoLib();
        FreeDemandLoadedLibs();

		break;



    default:
		DebugTrace(TEXT("MAPIX FInitMapiDll: bad dwReason %ld\n"), dwReason);
        break;


	}

	return TRUE;
}

#endif	/* WIN32  && !MAC */


#ifdef	DEBUG

void
ExitCheckInstance(LPINST pinst)
{
	TCHAR   rgch[MAX_PATH];
	TCHAR   rgchTitle[128];
	BOOL		fAssertLeaks;

	if (!pinst)
		return;

	if (pinst->szModName[0])
		wsprintf(rgchTitle,  TEXT("MAPIX exit checks for '%s'"), pinst->szModName);
	else
		lstrcpy(rgchTitle,  TEXT("MAPIX exit checks"));
	DebugTrace(TEXT("%s\n"), rgchTitle);

	fAssertLeaks = GetPrivateProfileInt( TEXT("General"),  TEXT("AssertLeaks"), 0,  TEXT("wabdbg.ini"));

	//	Check for Init/Deinit imbalance
	if (pinst->cRef)
	{
		wsprintf(rgch,  TEXT("MAPIX: leaked %ld references"), pinst->cRef);
		TraceSz1( TEXT("%s\n"), rgch);
		if (fAssertLeaks)
			TrapSz(rgch);
	}


	//	Generate memory leak reports.
#if 0	//	LH_DumpLeaks is not exported
//	if (pinst->hlhClient)
//		LH_DumpLeaks(pinst->hlhClient);
	if (pinst->hlhProvider)
		LH_DumpLeaks(pinst->hlhProvider);
	if (pinst->hlhInternal)
		LH_DumpLeaks(pinst->hlhInternal);
#else
{
	HLH	hlh;

	if (pinst->hlhProvider)
		LH_Close(pinst->hlhProvider);
	hlh = pinst->hlhInternal;
	if (hlh)
	{
		LH_Free(hlh, pinst);
		LH_Close(hlh);
	}
}
#endif
}

void
ExitCheckInstUtil(LPINSTUTIL pinstUtil)
{
	HLH		hlh;

	if (!pinstUtil)
		return;

	hlh = pinstUtil->hlhClient;
	if (hlh)
	{
		LH_Free(hlh, pinstUtil);
		LH_Close(hlh);
	}
}


#endif	/* DEBUG */

#ifndef WIN16
static const char c_szReg[]         = "Reg";
static const char c_szRegHandlers[] = "RegisterHandlers";
static const char c_szUnReg[]       = "UnReg";
static const char c_szAdvPackDll[]  = "ADVPACK.DLL";
static const TCHAR c_szWabPath[]    =  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\wab.exe");
static const TCHAR c_szRegWABVerInfo[] = TEXT("Software\\Microsoft\\WAB\\Version Info");
static const TCHAR c_szIEInstallMode[] = TEXT("InstallMode");
static char c_szWAB_EXE[]           = "WAB_EXE";

BOOL FRedistMode()
{
    HKEY hkey;
    DWORD cb;
    DWORD dwInstallMode=0;
    BOOL fRedist = FALSE;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegWABVerInfo, 0, KEY_READ, &hkey))
    {
        cb = sizeof(dwInstallMode);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szIEInstallMode, 0, NULL, (LPBYTE)&dwInstallMode, &cb))
        {
            fRedist = (dwInstallMode > 0);
        }

        RegCloseKey(hkey);
    }
    return fRedist;
}


HRESULT CallRegInstall(LPCSTR szSection)
{
    HRESULT     hr;
    HINSTANCE   hAdvPack;
    REGINSTALL  pfnri;
    TCHAR       szExe[MAX_PATH];
    STRENTRY    seReg;
    STRTABLE    stReg;
    DWORD       cb;

    hr = E_FAIL;

    hAdvPack = LoadLibraryA(c_szAdvPackDll);
    if (hAdvPack != NULL)
        {
        // Get Proc Address for registration util
        pfnri = (REGINSTALL)GetProcAddress(hAdvPack, achREGINSTALL);
        if (pfnri != NULL)
            {
            cb = CharSizeOf(szExe);
            if (ERROR_SUCCESS == RegQueryValue(HKEY_LOCAL_MACHINE, c_szWabPath, szExe, &cb))
                {
                seReg.pszName = c_szWAB_EXE;
                seReg.pszValue = ConvertWtoA(szExe);
                stReg.cEntries = 1;
                stReg.pse = &seReg;

                // Call the self-reg routine
                hr = pfnri(hinstMapiXWAB, szSection, &stReg);
                LocalFreeAndNull(&seReg.pszValue);
                }
            }

        FreeLibrary(hAdvPack);
        }

    return(hr);
}

STDAPI DllRegisterServer(void)
{
    HRESULT hr = E_FAIL;
    TCHAR szWABPath[MAX_PATH];

    // Set the wab32.dll path in the registry under
    // HKLM/Software/Microsoft/WAB/WAB4/DLLPath
    //
    if( hinstMapiXWAB &&
        GetModuleFileName(hinstMapiXWAB, szWABPath, CharSizeOf(szWABPath)))
    {
        HKEY hSubKey = NULL;
        DWORD dwDisp = 0;
        if(ERROR_SUCCESS == RegCreateKeyEx( HKEY_LOCAL_MACHINE, WAB_DLL_PATH_KEY,
                                            0, NULL, 0, KEY_ALL_ACCESS, NULL, &hSubKey, &dwDisp))
        {
            RegSetValueEx(hSubKey,szEmpty,0,REG_SZ, (LPBYTE)szWABPath, (lstrlen(szWABPath)+1) * sizeof(TCHAR) );
            RegCloseKey(hSubKey);
            hr = S_OK;
        }
    }

    if(HR_FAILED(hr))
        goto out;

    // OE Bug 67540
    // For some reason, need to do handlers then regular else
    // default contact handler won't be taken

    if (!FRedistMode())
        // Try to register handlers as we are not in redist mode
        CallRegInstall(c_szRegHandlers);
     
    // Register things that are always registered
    hr = CallRegInstall(c_szReg);

out:
    return(hr);
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    hr = CallRegInstall(c_szUnReg);

    return(hr);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\gllocal.c ===
/*
 * gllocal.c
 *
 * Implementation of global and local heaps
 *
 * Copyright (C) 1994 Microsoft Corporation
 */
#include "_apipch.h"

#define _GLLOCAL_C

#ifdef MAC
#include "ole2ui.h"
#include <utilmac.h>
#include <mapiprof.h>

#ifdef GetPrivateProfileInt
#undef GetPrivateProfileInt
#undef GetPrivateProfileString
#endif
#define	GetPrivateProfileInt		MAPIGetPrivateProfileInt
#define	GetPrivateProfileString		MAPIGetPrivateProfileString
#endif	// MAC

// #include "glheap.h"

#ifdef MAC
#pragma code_seg("glheap", "fixed, preload")
#else
#ifdef OLD_STUFF
#pragma SEGMENT(glheap)
#endif // OLD_STUFF
#endif

#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#endif

// Local Heap Debug Implementation --------------------------------------------

#ifdef DEBUG

static TCHAR szDebugIni[]		=  TEXT("WABDBG.INI");
static TCHAR szSectionHeap[]		=  TEXT("Memory Management");
static TCHAR szKeyUseVirtual[]	=  TEXT("VirtualMemory");
static TCHAR szKeyAssertLeaks[]	=  TEXT("AssertLeaks");
static TCHAR szKeyDumpLeaks[]	=  TEXT("DumpLeaks");
static TCHAR szKeyFillMem[]		=  TEXT("FillMemory");
static TCHAR szKeyFillByte[]		=  TEXT("FillByte");

// Artificial Errors for local heaps
BOOL FForceFailure(HLH hlh, UINT cb);

static TCHAR szAESectionHeap[]		=  TEXT("Local Heap Failures");
static TCHAR szAEKeyFailStart[]		=  TEXT("AllocsToFirstFailure");
static TCHAR szAEKeyFailInterval[]	=  TEXT("FailureInterval");
static TCHAR szAEKeyFailBufSize[]	=  TEXT("FailureSize");

#ifdef HEAPMON
static TCHAR szKeyHeapMon[]		=  TEXT("MonitorHeap");
#ifdef MAC
static TCHAR szHeapMonDLL[]		=  TEXT("GLHM");
#else
static TCHAR szHeapMonDLL[]		=  TEXT("GLHMON32.DLL");
#endif
static char szHeapMonEntry[]	=  "HeapMonitor";
static char szGetSymNameEntry[]	=  "GetSymbolName";
#endif

// Virtual Memory Support --------------------------------------------
//
//  The VM Allocators do not currently work on:
//      AMD64
//      MAC
//
#if defined(MAC) || defined(_AMD64_) || defined(_IA64_)
#define VMAlloc(cb)				0
#define VMAllocEx(cb, ul)		0
#define VMRealloc(pv, cb)		0
#define VMReallocEx(pv, cb, ul)	0
#define VMFree(pv)
#define VMFreeEx(pv, ul)
#define VMGetSize(pv)			0
#define VMGetSizeEx(pv, ul)		0
#endif

#if defined(WIN32) && !defined(MAC)
#define LH_EnterCriticalSection(hlh)	EnterCriticalSection(&hlh->cs)
#define LH_LeaveCriticalSection(hlh)	LeaveCriticalSection(&hlh->cs)
#else
#define LH_EnterCriticalSection(hlh)
#define LH_LeaveCriticalSection(hlh)
#endif

#ifdef HEAPMON
/*
 -	FRegisterHeap
 -
 *	Purpose:
 *		If the user wants to monitor the Heap, then load the DLL with
 *		the HeapMonitor UI.
 */

BOOL FRegisterHeap(PLH plh)
{
	HINSTANCE			hInst;
	LPHEAPMONPROC		pfnHeapMon;
	LPGETSYMNAMEPROC	pfnGetSymName;
	
	plh->hInstHeapMon = 0;
	plh->pfnGetSymName = NULL;

	hInst = LoadLibrary(szHeapMonDLL);
	
	if (!hInst)
	{
		DebugTrace(TEXT("FRegisterHeap: Failed to LoadLibrary GLHMON32.DLL.\n"));
		goto ret;
	}

	pfnHeapMon = (LPHEAPMONPROC)GetProcAddress(hInst, szHeapMonEntry);
		
	if (!pfnHeapMon)
	{
		DebugTrace(TEXT("FRegisterHeap: Failed to GetProcAddress of HeapMonitor.\n"));
		FreeLibrary(hInst);
		goto ret;
	}
	
	pfnGetSymName = (LPGETSYMNAMEPROC)GetProcAddress(hInst, szGetSymNameEntry);
		
	if (!pfnGetSymName)
	{
		DebugTrace(TEXT("FRegisterHeap: Failed to GetProcAddress of GetSymName.\n"));
	}
	
 	plh->hInstHeapMon = hInst;
	
	if (!pfnHeapMon(plh, HEAPMON_LOAD))
	{
		DebugTrace(TEXT("FRegisterHeap: Call to HeapMonitor failed.\n"));
		plh->hInstHeapMon = 0;
		goto ret;
	}
	
 	plh->pfnHeapMon		= pfnHeapMon;
	plh->pfnGetSymName  = pfnGetSymName;
	
ret:
	return (plh->hInstHeapMon ? TRUE : FALSE);
}


void UnRegisterHeap(HLH hlh)
{
	if (hlh->pfnHeapMon)
		hlh->pfnHeapMon(hlh, HEAPMON_UNLOAD);
}
#endif	// HEAPMON


/*
 -	LH_ReportLeak
 -
 *	Purpose:
 *		To report individual memory leaks through DebugTrace and the
 *		LH_LeakHook breakpoint function.
 */

void LH_ReportLeak(HLH hlh, PLHBLK plhblk)
{
	DebugTrace(TEXT("Memory leak '%s' in %s @ %08lX, Allocation #%ld, Size: %ld\n"),
		plhblk->szName[0] ? plhblk->szName :  TEXT("NONAME"),
		hlh->szHeapName, PlhblkToPv(plhblk),
		plhblk->ulAllocNum, CbPlhblkClient(plhblk));
	
#if defined(WIN32) && defined(_X86_) && defined(LEAK_TEST)
{
	int	i;
		for (i = 0; i < NCALLERS && plhblk->pfnCallers[i]; i++)
	{
		char			szSymbol[256];
		char			szModule[64];
		DWORD			dwDisp;
		BOOL			fGotSym = FALSE;
			
		szSymbol[0] = 0;
		szModule[0] = 0;

		if (hlh->pfnGetSymName)
			if (hlh->pfnGetSymName((DWORD) plhblk->pfnCallers[i], szModule,
								   szSymbol, &dwDisp))
				fGotSym = TRUE;

		if (fGotSym)
		{	
			DebugTrace(TEXT("[%d] %s %s"), i, szModule, szSymbol);
			if (dwDisp)
				DebugTrace(TEXT("+%ld"), dwDisp);
			DebugTrace(TEXT("\n"));
		}
		else
			DebugTrace(TEXT("[%d] %s %08lX \n"), i, szModule, plhblk->pfnCallers[i]);
		DBGMEM_LeakHook(plhblk->pfnCallers[i]);
	}
}
#endif
}


/*
 -	LH_DumpLeaks
 -
 *	Purpose:
 *		Gets called at LH_Close time to report any memory leaks against
 *		this heap.  There are 3 reporting fascilities used by this routine:
 *
 *			=> Breakpoint hooking (via LH_LeakHook)
 *			=> Asserts (via TrapSz)
 *			=> Debug trace tags (via DebugTrace)
 *
 *		The Debug Trace is the default method if no others are specified
 *		or if the others are in-appropriate for the given platform.
 */

void LH_DumpLeaks(HLH hlh)
{
	PLHBLK	plhblk;
	BOOL	fDump = !!(hlh->ulFlags & HEAP_DUMP_LEAKS);
	BOOL	fAssert = !!(hlh->ulFlags & HEAP_ASSERT_LEAKS);
	int		cLeaks = 0;
	
	for (plhblk = hlh->plhblkHead; plhblk; plhblk = plhblk->plhblkNext)
	{
		if (fDump)
			LH_ReportLeak(hlh, plhblk);
		cLeaks++;
	}

	if (cLeaks)
	{
#if defined(WIN16) || (defined(WIN32) && defined(_X86_))
		if (fAssert)
		{
			TrapSz3( TEXT("GLHEAP detected %d memory leak%s in Heap: %s"),
					cLeaks, (cLeaks == 1 ? szEmpty :  TEXT("s")), hlh->szHeapName);
		}
		else
			DebugTrace(TEXT("GLHEAP detected %d memory leak%s in Heap: %s\n"),
					cLeaks, (cLeaks == 1 ? szEmpty :  TEXT("s")), hlh->szHeapName);
#else
		DebugTrace(TEXT("GLHEAP detected %d memory leak%s in Heap: %s\n"),
				cLeaks, (cLeaks == 1 ? szEmpty :  TEXT("s")), hlh->szHeapName);
#endif		
	}
}


BOOL LH_ValidatePlhblk(HLH hlh, PLHBLK plhblk, char ** pszReason)
{
	if (IsBadWritePtr(plhblk, sizeof(LHBLK)))
	{
		*pszReason = "Block header cannot be written to";
		goto err;
	}

	if (plhblk->hlh != hlh)
	{
		*pszReason = "Block header does not have correct pointer back to heap";
		goto err;
	}

	if (plhblk->plhblkNext)
	{
		if (IsBadWritePtr(plhblk->plhblkNext, sizeof(LHBLK)))
		{
			*pszReason = "Block header has invalid next link pointer";
			goto err;
		}

		if (plhblk->plhblkNext->plhblkPrev != plhblk)
		{
			*pszReason = "Block header points to a next block which doesn't "
				"point back to it";
			goto err;
		}
	}

	if (plhblk->plhblkPrev)
	{
		if (IsBadWritePtr(plhblk->plhblkPrev, sizeof(LHBLK))) {
			*pszReason = "Block header has invalid prev link pointer";
			goto err;
		}

		if (plhblk->plhblkPrev->plhblkNext != plhblk)
		{
			*pszReason = "Block header points to a prev block which doesn't "
				"point back to it";
			goto err;
		}
	}
	else if (hlh->plhblkHead != plhblk)
	{
		*pszReason = "Block header has a zero prev link but the heap doesn't "
			"believe it is the first block";
		goto err;
	}

	if (plhblk->ulAllocNum > hlh->ulAllocNum)
	{
		*pszReason = "Block header has an invalid internal allocation number";
		goto err;
	}

	return TRUE;

err:
	return FALSE;
}


// $MAC - Need WINAPI

BOOL
#ifdef MAC
WINAPI
#endif
LH_DidAlloc(HLH hlh, LPVOID pv)
{
	PLHBLK	plhblk;
	char *	pszReason;
	BOOL	fDidAlloc = FALSE;

	for (plhblk = hlh->plhblkHead; plhblk; plhblk = plhblk->plhblkNext)
	{
		AssertSz2(LH_ValidatePlhblk(hlh, plhblk, &pszReason),
			  TEXT("Block header (plhblk=%08lX) is invalid\n%s"),
			 plhblk, pszReason);

		if (PlhblkToPv(plhblk) == pv)
		{
			fDidAlloc = TRUE;
			break;
		}
	}

	return fDidAlloc;
}


BOOL LH_ValidatePv(HLH hlh, LPVOID pv, char * pszFunc)
{
	PLHBLK	plhblk;
	char *	pszReason;

	plhblk = PvToPlhblk(hlh, pv);
	
	if (!plhblk)
	{
		TrapSz3( TEXT("%s detected a memory block (%08lX) which was either not ")
			 TEXT("allocated in heap '%s' or has already been freed."),
			pszFunc, pv, hlh->szHeapName);
		return(FALSE);
	}

	if (LH_ValidatePlhblk(hlh, plhblk, &pszReason))
		return(TRUE);

	TrapSz4( TEXT("%s detected an invalid memory block (%08lX) in heap '%s'.  %s."),
		pszFunc, pv, hlh->szHeapName, pszReason);

	return FALSE;
}


/*
 -	PlhblkEnqueue
 -
 *	Purpose:
 *		To add a newly allocated block to the allocation list hanging
 *		off the heap.  We do an InsertSorted because the HeapMonitor
 *		will need to reference the allocations ordered by their
 *		location in the heap.  Since the monitor will walk the heap
 *		often, it is more efficient to do the sort up front.
 */

void PlhblkEnqueue(PLHBLK plhblk)
{
	PLHBLK	plhblkCurr = NULL;
	PLHBLK	plhblkNext = plhblk->hlh->plhblkHead;
	
	while (plhblkNext)
	{
		if (plhblkNext > plhblk)
			break;
		
		plhblkCurr = plhblkNext;
		plhblkNext = plhblkCurr->plhblkNext;
	}
	
	if (plhblkNext)
	{
		plhblk->plhblkNext		= plhblkNext;
		plhblk->plhblkPrev		= plhblkCurr;
		plhblkNext->plhblkPrev	= plhblk;
	}
	else
	{
		plhblk->plhblkNext = NULL;
		plhblk->plhblkPrev = plhblkCurr;
	}

	if (plhblkCurr)
		plhblkCurr->plhblkNext = plhblk;
	else
		plhblk->hlh->plhblkHead = plhblk;
}


/*
 -	PlhblkDequeue
 -
 *	Purpose:
 *		To remove a freed block from the list of allocations hanging
 *		off the heap.
 */

void PlhblkDequeue(PLHBLK plhblk)
{
	if (plhblk->plhblkNext)
		plhblk->plhblkNext->plhblkPrev = plhblk->plhblkPrev;
	
	if (plhblk->plhblkPrev)
		plhblk->plhblkPrev->plhblkNext = plhblk->plhblkNext;
	else
		plhblk->hlh->plhblkHead = plhblk->plhblkNext;
}


/*
 -	HexByteToBin
 -
 *	Purpose:
 *		Takes a hex string and converts the 2 msd's to a byte, ignoring
 *		the remaining digits.  This function assumes the string is
 *		formatted as: 0xnn, otherwise it simply returns 0x00.
 */

BYTE HexByteToBin(LPSTR sz)
{
	int i, n[2], nT;

	if (*sz++ != '0')
		return 0x00;

	nT = *sz++;

	if (nT != 'x' && nT != 'X')
		return 0x00;

	for (i = 0; i < 2; i++)
	{
		nT = *sz++;
		
		if (nT >= '0' && nT <= '9')
			n[i] = nT - '0';
		else if (nT >= 'A' && nT <= 'F')
			n[i] = nT - 'A' + 10;
		else if (nT >= 'a' && nT <= 'f')
			n[i] = nT - 'a' + 10;
		else
			return (BYTE)0x00;
	}	

	n[0] <<= 4;
	return (BYTE)((BYTE)n[0] | (BYTE)n[1]);
}


HLH WINAPI LH_Open(DWORD dwMaxHeap)
{
	_HLH	_hlhData = 0;
	_HLH	_hlhBlks = 0;
	PLH		plh = NULL;
	UINT	cch = 0;
	UINT	uiT = 0;
	TCHAR	szFillByte[8];
    LPSTR   lpFillByte = NULL;
	ULONG	cbVirtual = 0;
	
	//	The first thing we must do is create a heap that we will
	//	allocate our Allocation Blocks on.  We also allocate our
	//	debug Heap object on this heap.

	_hlhBlks = _LH_Open(dwMaxHeap);
	
	if (!_hlhBlks)
	{
		DebugTrace(TEXT("LH_Open: Failed to create new heap!\n"));
		goto ret;
	}
	
	//	Allocate the thing we hand back to the caller on this new heap.
	
	plh = _LH_Alloc(_hlhBlks, sizeof(LH));
	
	if (!plh)
	{
		DebugTrace(TEXT("LH_Alloc: Failed to allocate heap handle!\n"));
		_LH_Close(_hlhBlks);
		_hlhBlks = 0;
		goto ret;
	}
	
	//	Initialize all the goodies we store in this thing.
	//	Hook this heap into the global list of heaps we've
	//	created in this context.
	
	memset(plh, 0, sizeof(LH));

	plh->pfnSetName = (LPLHSETNAME)LH_SetNameFn;
	plh->_hlhBlks	= _hlhBlks;
	plh->ulFlags	= HEAP_LOCAL;

#if defined(WIN32) && !defined(MAC)
	InitializeCriticalSection(&plh->cs);
#endif
	
	// VirtualMemory default is FALSE

	cbVirtual = GetPrivateProfileInt(szSectionHeap, szKeyUseVirtual, 0,
		szDebugIni);

	if (cbVirtual)
	{
		plh->ulFlags |= HEAP_USE_VIRTUAL;

		// We always want virtual allocations on MIPS and PPC to be 4-byte
		// aligned, because all our code assumes that the beginning of an
		// allocation is aligned on machine word boundaries.  On other
		// platforms, changing this behavior is non-fatal, but on MIPS and
		// PPC we'll get alignment faults everywhere.
		
#if !defined(_MIPS_) && !defined(_PPC_)
		if (cbVirtual == 4)
#endif
			plh->ulFlags |= HEAP_USE_VIRTUAL_4;
	}
		
	// DumpLeaks default is TRUE

	if (GetPrivateProfileInt(szSectionHeap, szKeyDumpLeaks, 1, szDebugIni))
		plh->ulFlags |= HEAP_DUMP_LEAKS;
	
	// AssertLeaks default is FALSE

	if (GetPrivateProfileInt(szSectionHeap, szKeyAssertLeaks, 0, szDebugIni))
		plh->ulFlags |= HEAP_ASSERT_LEAKS;
	
	// FillMem default is TRUE

	if (GetPrivateProfileInt(szSectionHeap, szKeyFillMem, 1, szDebugIni))
		plh->ulFlags |= HEAP_FILL_MEM;
	
	if (plh->ulFlags & HEAP_FILL_MEM)
	{
		cch	= GetPrivateProfileString(
				szSectionHeap,
				szKeyFillByte,
				szEmpty,
               szFillByte,
				CharSizeOf(szFillByte)-1,
				szDebugIni);
	}

	//	Set the memory fill character.
    lpFillByte = ConvertWtoA(szFillByte);
	plh->chFill = (BYTE)(cch ? HexByteToBin(lpFillByte) : chDefaultFill);
    LocalFreeAndNull(&lpFillByte);

	//
	//  Set up artificial failures.  If anything is set in our ini file, then
	//  HEAP_FAILURES_ENABLED gets set.
	//
	uiT = GetPrivateProfileInt(szAESectionHeap, szAEKeyFailStart, 0, szDebugIni);
	if (uiT)
	{
		plh->ulFlags |= HEAP_FAILURES_ENABLED;
		plh->ulFailStart = (ULONG) uiT;
		
		plh->ulFailInterval =
			(ULONG) GetPrivateProfileInt(szAESectionHeap, szAEKeyFailInterval, 0, szDebugIni);

		plh->uiFailBufSize =
			GetPrivateProfileInt(szAESectionHeap, szAEKeyFailBufSize, 0, szDebugIni);
	}


#ifdef HEAPMON
	//	If the user wants Heap Monitor UI, the spin a thread to manage a
	//	DialogBox that can display the status of the heap at all times.

	if (GetPrivateProfileInt(szSectionHeap, szKeyHeapMon, 0, szDebugIni))
		if (FRegisterHeap(plh))
			plh->ulFlags |= HEAP_HEAP_MONITOR;
#endif

	//	If we are not using virtual memory allocators, then we
	//	create another heap to allocate the users data in.
	
	if (!(plh->ulFlags & HEAP_USE_VIRTUAL))
	{
		_hlhData = _LH_Open(dwMaxHeap);

		if (!_hlhData)
		{
			DebugTrace(TEXT("LH_Alloc: Failed to allocate heap handle!\n"));
			_LH_Close(_hlhBlks);
			plh = NULL;
			goto ret;
		}
		
		plh->_hlhData	= _hlhData;
	}
#ifndef _WIN64
	LH_SetHeapName1(plh,  TEXT("LH %08lX"), plh);
#else
	LH_SetHeapName1(plh,  TEXT("LH %p"), plh);
#endif // _WIN64

ret:
	return (HLH)plh;
}


void WINAPI LH_Close(HLH hlh)
{
	_HLH _hlhData = hlh->_hlhData;
	_HLH _hlhBlks = hlh->_hlhBlks;
	
	//	Dump memory leaks if we're supposed to.
	
	if (hlh->ulFlags & HEAP_DUMP_LEAKS)
		LH_DumpLeaks(hlh);
	
	//	Destroy the HeapMonitor thread and un-load the DLL
	
#ifdef HEAPMON
	UnRegisterHeap(hlh);
	
	if ((hlh->ulFlags & HEAP_HEAP_MONITOR) && hlh->hInstHeapMon)
		FreeLibrary(hlh->hInstHeapMon);
#endif
	
#if defined(WIN32) && !defined(MAC)
	DeleteCriticalSection(&hlh->cs);
#endif
	
	//	Clean-up and leave.  Closing frees leaks, so we're cool!
	
	if (!(hlh->ulFlags & HEAP_USE_VIRTUAL) && _hlhData)
		_LH_Close(_hlhData);
		
	if (_hlhBlks)
	{
		_LH_Free (_hlhBlks, hlh);
		_LH_Close(_hlhBlks);
	}
}


LPVOID WINAPI LH_Alloc(HLH hlh, UINT cb)
{
	PLHBLK	plhblk = NULL;
	LPVOID	pvAlloc = NULL;
	
	// Note:  To be consistent with other (e.g. system) allocators,
	// we have to return a valid allocation if cb == 0.  So, we
	// allow a cb of 0 to actually be allocated.  (See bug 3556 in
	// the sqlguest:exchange database.)

	LH_EnterCriticalSection(hlh);

	if (hlh->ulFlags & HEAP_FAILURES_ENABLED)
	{
		if (FForceFailure(hlh, cb))
		{
			DebugTrace(TEXT("LH_Alloc: Artificial Failure\n"));
			pvAlloc = NULL;
			hlh->ulAllocNum++;
			goto out;
		}
	}

	if (hlh->ulFlags & HEAP_USE_VIRTUAL_4)
		pvAlloc = VMAllocEx(cb, 4);
	else if (hlh->ulFlags & HEAP_USE_VIRTUAL)
		pvAlloc = VMAllocEx(cb, 1);
	else if (cb > UINT_MAX)
		plhblk = 0;
	else
#ifndef _WIN64
		pvAlloc = _LH_Alloc(hlh->_hlhData, (UINT)cb);
#else
	{
		Assert(hlh->_hlhData);
		Assert(cb);
		Assert(HeapValidate(hlh->_hlhData, 0, NULL));
		pvAlloc = _LH_Alloc(hlh->_hlhData, (UINT)cb);
	}	
#endif
	
	if (pvAlloc)
	{
		plhblk = (PLHBLK)_LH_Alloc(hlh->_hlhBlks, sizeof(LHBLK));
		
		if (plhblk)
		{
			plhblk->hlh			= hlh;
			plhblk->szName[0]	= 0;
			plhblk->ulSize		= cb;
			plhblk->ulAllocNum	= ++hlh->ulAllocNum;
			plhblk->pv			= pvAlloc;

			PlhblkEnqueue(plhblk);

#if defined(WIN32) && defined(_X86_) && defined(LEAK_TEST)
			GetCallStack((DWORD *)plhblk->pfnCallers, 0, NCALLERS);
#endif

			if (hlh->ulFlags & HEAP_FILL_MEM)
				memset(pvAlloc, hlh->chFill, (size_t)cb);
		}
		else
		{
			if (hlh->ulFlags & HEAP_USE_VIRTUAL_4)
				VMFreeEx(pvAlloc, 4);
			else if (hlh->ulFlags & HEAP_USE_VIRTUAL)
				VMFreeEx(pvAlloc, 1);
			else
				_LH_Free(hlh->_hlhData, pvAlloc);
			
			pvAlloc = NULL;	
		}
	}

out:

	LH_LeaveCriticalSection(hlh);
	
	return pvAlloc;
}


LPVOID WINAPI LH_Realloc(HLH hlh, LPVOID pv, UINT cb)
{
	LPVOID	pvNew = NULL;

	LH_EnterCriticalSection(hlh);

	if (pv == 0)
		pvNew = LH_Alloc(hlh, cb);
	else if (cb == 0)
		LH_Free(hlh, pv);
	else if (LH_ValidatePv(hlh, pv, "LH_Realloc"))
	{
		PLHBLK	plhblk	= PvToPlhblk(hlh, pv);
		UINT	cbOld	= (UINT)CbPlhblkClient(plhblk);

		PlhblkDequeue(plhblk);


		if (cb > cbOld &&
			((hlh->ulFlags & HEAP_FAILURES_ENABLED) && FForceFailure(hlh, cb)))
		{
			hlh->ulAllocNum++;
			pvNew = 0;
			DebugTrace(TEXT("LH_Realloc: Artificial Failure\n"));
		} else if (hlh->ulFlags & HEAP_USE_VIRTUAL_4)
			pvNew = VMReallocEx(pv, cb, 4);
		else if (hlh->ulFlags & HEAP_USE_VIRTUAL)
			pvNew = VMReallocEx(pv, cb, 1);
		else if (cb > UINT_MAX)
			pvNew = 0;
		else
			pvNew = _LH_Realloc(hlh->_hlhData, pv, (UINT)cb);

		PlhblkEnqueue(plhblk);


		if (pvNew)
		{
			hlh->ulAllocNum++;

			plhblk->pv = pvNew;
			plhblk->ulSize = cb;
			
			if (cb > cbOld)
				memset((LPBYTE)pvNew + cbOld, hlh->chFill, cb - cbOld);
		}
	}

	LH_LeaveCriticalSection(hlh);
	
	return pvNew;
}


void WINAPI LH_Free(HLH hlh, LPVOID pv)
{
	PLHBLK	plhblk;

	LH_EnterCriticalSection(hlh);

	if (pv && LH_ValidatePv(hlh, pv, "LH_Free"))
	{
		plhblk = PvToPlhblk(hlh, pv);
		
		PlhblkDequeue(plhblk);
		
		memset(pv, 0xDC, (size_t)CbPlhblkClient(plhblk));
		
		if (hlh->ulFlags & HEAP_USE_VIRTUAL_4)
			VMFreeEx(pv, 4);
		else if (hlh->ulFlags & HEAP_USE_VIRTUAL)
			VMFreeEx(pv, 1);
		else
			_LH_Free(hlh->_hlhData, pv);
		
		_LH_Free(hlh->_hlhBlks, plhblk);	
	}
	
	LH_LeaveCriticalSection(hlh);
}	


UINT WINAPI LH_GetSize(HLH hlh, LPVOID pv)
{
	UINT cb = 0;

	LH_EnterCriticalSection(hlh);

	if (LH_ValidatePv(hlh, pv, "LH_GetSize"))
	{
		if (hlh->ulFlags & HEAP_USE_VIRTUAL_4)
			cb = (UINT)VMGetSizeEx(pv, 4);
		else if (hlh->ulFlags & HEAP_USE_VIRTUAL)
			cb = (UINT)VMGetSizeEx(pv, 1);
		else	
			cb = (UINT) _LH_GetSize(hlh->_hlhData, pv);
	}

	LH_LeaveCriticalSection(hlh);

	return cb;
}


void __cdecl LH_SetHeapNameFn(HLH hlh, TCHAR *pszFormat, ...)
{
	TCHAR   sz[512];
	va_list	vl;

	va_start(vl, pszFormat);
	wvsprintf(sz, pszFormat, vl);
	va_end(vl);

	lstrcpyn(hlh->szHeapName,
            sz,
            CharSizeOf(hlh->szHeapName));
}

void __cdecl EXPORT_16 LH_SetNameFn(HLH hlh, LPVOID pv, TCHAR *pszFormat, ...)
{
	TCHAR	sz[512];
	PLHBLK	plhblk;
	va_list	vl;

	plhblk = PvToPlhblk(hlh, pv);

	if (plhblk)
	{
		va_start(vl, pszFormat);
		wvsprintf(sz, pszFormat, vl);
		va_end(vl);

		lstrcpyn(plhblk->szName, sz, CharSizeOf(plhblk->szName));
	}
}

// $MAC - Need WINAPI

TCHAR *
#ifdef MAC
WINAPI
#endif
LH_GetName(HLH hlh, LPVOID pv)
{
	PLHBLK	plhblk;

	plhblk = PvToPlhblk(hlh, pv);

	if (plhblk)
		return(plhblk->szName);

	return(szEmpty);
}


BOOL FForceFailure(HLH hlh, UINT cb)
{
	//
	//  First, see if we're past our start of failures point
	//
	if (hlh->ulFailStart && (hlh->ulFailStart <= hlh->ulAllocNum))
	{
		//
		//  If so, then are we at an interval where we should return errors?
		//
		
		if ((hlh->ulFailInterval)
			&& ((hlh->ulAllocNum - hlh->ulFailStart)%hlh->ulFailInterval) == 0)
		{
			//
			//  return that we should fail here
			//
			return TRUE;
		}

		//
		//  Check to see if the alloc size is greater than allowed
		//
		if (hlh->uiFailBufSize && cb >= hlh->uiFailBufSize)
			return TRUE;

	}


	//
	//  Otherwise, no error is returned for this alloc
	//

	return FALSE;
}



/*
 -	PvToPlhblk
 -
 *	Purpose:
 *		Finds the LHBLK for this allocation in the heap's active list.
 */

PLHBLK PvToPlhblk(HLH hlh, LPVOID pv)
{
	PLHBLK plhblk;

	LH_EnterCriticalSection(hlh);
	
	plhblk = hlh->plhblkHead;
	
	while (plhblk)
	{
		if (plhblk->pv == pv)
			break;
		
		plhblk = plhblk->plhblkNext;	
	}
	
	LH_LeaveCriticalSection(hlh);
	
	return plhblk;
}

#endif	/* DEBUG */


#ifdef MAC		// MAC!!

#if defined(DEBUG)
static TCHAR stMemErr[] =  TEXT("\pHad a memory error. See above for details");
#endif


LPVOID WINAPI _LH_Open(DWORD dwMaxHeap)
{
	Ptr			lp;

	lp = NewPtrClear(sizeof(LHeap));
	if (lp == NULL)
	{
#if defined(DEBUG)	
		DebugTrace(TEXT("_LH_Open had an error. MemError = %d"), MemError());
		DebugStr(stMemErr);
#endif /* DEBUG */
		return NULL;
	}
	return (LPVOID)lp;
}


void WINAPI _LH_Close(LPVOID plh)
{
	LBlkPtr		plb, plbNext;
#if defined(DEBUG)
	short		idx = 0;
#endif

	if (plh == NULL)
		return;

	// Walk the block list throwing out remaining mem as we go along.
	plb = ((LHeapPtr)plh)->plb;
	while (plb)
	{
		plbNext = plb->next;
		DisposePtr((Ptr)plb);
#if defined(DEBUG)
		if (MemError())
		{
			DebugTrace(TEXT("_LH_Close: Had a memory error."));
			DebugTrace(TEXT("Error number = %d"), MemError());
			DebugStr(stMemErr);
		}
		idx ++;
#endif
		plb = plbNext;
	}

	// Throw out the heap header.
	DisposePtr((Ptr)plh);
#if defined(DEBUG)
	if (MemError())
	{
		DebugTrace(TEXT("_LH_Close: Had error throwing out heap head."));
		DebugTrace(TEXT("MemError = %d"), MemError());
		DebugStr(stMemErr);
	}
	if (idx)
		DebugTrace(TEXT("Threw out %d left over local memory blocks\n"), idx);
#endif /* DEBUG */
}


LPVOID WINAPI _LH_Alloc(LPVOID plh, UINT cb)
{
	LBlkPtr		plbNew, plb;
	Ptr			lp;

	if (plh == NULL)
		return NULL;

	// Get memory for the linked list element. Mem requests are stored in a
	// linked list off a 'heap' head because real heap management is such a
	// pain on the Mac.
	plbNew = (LBlkPtr)NewPtr(sizeof(LBlock));
	if (plbNew == NULL)
		goto trouble;

	// Memory for the actual request.
	lp = NewPtrClear(cb);
	if (lp == NULL)
	{
		DisposePtr((Ptr)plbNew);
		goto trouble;
	}
	// All members of LBlock are filled in so there's no need to call
	// NewPtrclear() above.
	plbNew->ptr = lp;
	plbNew->next = NULL;

	// Find the end of the linked list and link this element in.
	if (plb = ((LHeapPtr)plh)->plb)
	{
		while (plb->next)
			plb = plb->next;
		plb->next = plbNew;
	}
	else
		((LHeapPtr)plh)->plb = plbNew;
	// Return the successfully allocated memory.
	return lp;

trouble:
	{
#if defined(DEBUG)	
		DebugTrace(TEXT("_LH_Alloc failed. MemError = %d"), MemError());
		DebugTrace(TEXT("The number of requested bytes = %d"), cb);
		DebugStr(stMemErr);
#endif /* DEBUG */
	}
	return NULL;
}


UINT WINAPI _LH_GetSize(LPVOID plh, LPVOID pv)
{
	long		cb;

	cb = GetPtrSize((Ptr)pv);
	if (MemError())
	{
#if defined(DEBUG)
		DebugTrace(TEXT("_LH_GetSize had an error. MemError = %d"), MemError());
		DebugStr(stMemErr);
#endif /* DEBUG */
		return 0;
	}
	return cb;
}


LPVOID WINAPI _LH_Realloc(LPVOID plh, LPVOID pv, UINT cb)
{
	Ptr		lp;
	UINT	cbOld;

	// Get rid of schizo cases.
	if (pv == NULL)
	{
		lp = _LH_Alloc(plh, cb);
		if (lp == NULL)
			goto err;
		return lp;
	}
	else if (cb == 0)
	{
		_LH_Free(plh, pv);
		return NULL;
	}

	// Get the size of the block the old ptr pointed to.
	cbOld = _LH_GetSize(plh, pv);
	if (cbOld == 0)
		goto err;

	// Get memory for the new pointer.
	lp = _LH_Alloc(plh, cb);
	if (lp == NULL)
		goto err;

	// Copy the old info into the new pointer, throw out the old mem and
	// return the result.
	BlockMove(pv, lp, cbOld <= cb ? cbOld : cb);
	_LH_Free(plh, pv);
	return lp;

err:
#if defined(DEBUG)
	DebugStr("\p_LH_Realloc failed");
#endif /* DEBUG */
	return 0;
}


void WINAPI _LH_Free(LPVOID plh, LPVOID pv)
{
	LBlkPtr		plb, plbPrev = NULL;

	if (pv == NULL)
		return;

	// Remove the memory from the linked list.
	plb = ((LHeapPtr)plh)->plb;
	while (plb)
	{
		if (plb->ptr == pv)
			break;
		plbPrev = plb;
		plb = plb->next;
	}
	if (plb)
	{
		if (plbPrev)
			plbPrev->next = plb->next;
		else
			((LHeapPtr)plh)->plb = plb->next;
	}
	else
	{
#if defined(DEBUG)
		DebugStr("\p_LH_Free: Did not find requested <plb> in linked list");
#endif /* DEBUG */
		return;
	}

	// Throw out the linked list element.
	DisposePtr((Ptr)plb);
#if defined(DEBUG)
		if (MemError())
			goto err;
#endif /* DEBUG */

	// Throw out the memory itself.
	DisposePtr((Ptr)pv);
#if defined(DEBUG)
	if (MemError())
err:
	{
		DebugTrace(TEXT("_LH_Free: Error disposing ptr. MemError = %d"), MemError());
		DebugStr(stMemErr);
	}
#endif /* DEBUG */
}

#endif /* MAC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\fonts.c ===
#include "_apipch.h"

/**
LOGFONT g_lfFolderNameHorz=
{
    0, // lfHeight
    0, // lfWidth
    0, // lfEscapement
    0, // lfOrientation
    400, // lfWeight
    0, // lfItalic
    0, // lfUnderline
    0, // lfStrikeout
    DEFAULT_CHARSET, // lfCharSet
    OUT_DEFAULT_PRECIS, // lfOutPrecision
    CLIP_DEFAULT_PRECIS, // lfClipPrecision
    DEFAULT_QUALITY, // lfQuality
    DEFAULT_PITCH | FF_DONTCARE, // lfPitchAndFamily
    "" // lfFaceName
};

LOGFONT g_lfFolderNameVert=
{
    0, // lfHeight
    0, // lfWidth
    2700, // lfEscapement
    0, // lfOrientation
    400, // lfWeight
    0, // lfItalic
    0, // lfUnderline
    0, // lfStrikeout
    DEFAULT_CHARSET, // lfCharSet
    OUT_DEFAULT_PRECIS, // lfOutPrecision
    CLIP_DEFAULT_PRECIS, // lfClipPrecision
    DEFAULT_QUALITY, // lfQuality
    DEFAULT_PITCH | FF_DONTCARE, // lfPitchAndFamily
    "" // lfFaceName
};
**/

LOGFONT g_lfSysIcon,
        g_lfSysIconBold;
//        g_lfSysIconItalic,
//        g_lfSysIconItalicBold,
//        g_lfSysMenu;

LOGFONT *g_rgplf[fntsMax]=
{
    &g_lfSysIcon,
    &g_lfSysIconBold,
//    &g_lfSysIconItalic,
//    &g_lfSysIconItalicBold,
//    &g_lfSysMenu,
//    &g_lfFolderNameHorz,
//    &g_lfFolderNameVert
};

HFONT g_rgFont[fntsMax] = {0};
static int  g_yPerInch=0;

HFONT GetFont(int ifont)
    {
    HFONT hfont;

    if (g_rgFont[ifont]==NULL)
    {
        hfont = CreateFontIndirect(g_rgplf[ifont]);
        g_rgFont[ifont] = hfont;
    }
    else
    {
        hfont = g_rgFont[ifont];
    }

    return(hfont);
    }


#define CCHMAX_STRINGRES 64

BOOL InitFonts(void)
{
    NONCLIENTMETRICS    ncm;
    ncm.cbSize = sizeof(ncm);
    if(SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &g_lfSysIcon, 0))
    {
        CopyMemory((LPBYTE)&g_lfSysIconBold, (LPBYTE)&g_lfSysIcon, sizeof(LOGFONT));
        //CopyMemory((LPBYTE)&g_lfSysIconItalic, (LPBYTE)&g_lfSysIcon, sizeof(LOGFONT));
        //CopyMemory((LPBYTE)&g_lfSysIconItalicBold, (LPBYTE)&g_lfSysIcon, sizeof(LOGFONT));
        g_lfSysIconBold.lfWeight = (g_lfSysIconBold.lfWeight < 700) ? 700 : 1000;
        //g_lfSysIconItalic.lfItalic=TRUE;
        //g_lfSysIconItalicBold.lfItalic=TRUE;
        //g_lfSysIconItalicBold.lfWeight = (g_lfSysIconItalicBold.lfWeight < 700) ? 700 : 1000;
    }

    //if(SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0))
    //    CopyMemory((LPBYTE)&g_lfSysMenu, (LPBYTE)&ncm.lfMenuFont, sizeof(LOGFONT));

    return(TRUE);
}


void DeleteFonts(void)
{
    int ifont;

    for (ifont = 0; ifont < fntsMax; ifont++)
    {
        if (g_rgFont[ifont] != NULL)
        {
            DeleteObject((HGDIOBJ)g_rgFont[ifont]);
            g_rgFont[ifont] = NULL;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\globals.c ===
/*
 *      GLOBALS.C
 *
 *      Global constant structures
 *
 */

#define _GLOBALS_C
#include "_apipch.h"

// Columns of the Root Contents Table
//
const SizedSPropTagArray(ircMax, ITableColumnsRoot) = {
    ircMax,                             // count of entries
    {
        PR_DISPLAY_NAME,
        PR_DISPLAY_TYPE,
        PR_ENTRYID,
        PR_INSTANCE_KEY,
        PR_OBJECT_TYPE,
        PR_RECORD_KEY,
        PR_ROWID,
        PR_DEPTH,
        PR_CONTAINER_FLAGS,
        PR_AB_PROVIDER_ID,
        PR_WAB_LDAP_SERVER,
        PR_WAB_RESOLVE_FLAG,
    }


};

//
// Default set of properties to return from a ResolveNames.
// May be overridden by passing in lptagaColSet to ResolveNames.
//
const SizedSPropTagArray(irdMax, ptaResolveDefaults)=
{
    irdMax,
    {
        PR_ADDRTYPE,
        PR_DISPLAY_NAME,
        PR_EMAIL_ADDRESS,
        PR_ENTRYID,
        PR_OBJECT_TYPE,
        PR_RECORD_KEY,
        PR_SEARCH_KEY,
        PR_SURNAME,
        PR_GIVEN_NAME,
        PR_INSTANCE_KEY,
        PR_SEND_INTERNET_ENCODING
    }
};

// default set of regular table columns
//
const SizedSPropTagArray(itcMax, ITableColumns) = {
    itcMax,                             // count of entries
    {
        PR_ADDRTYPE,
        PR_DISPLAY_NAME,
        PR_DISPLAY_TYPE,
        PR_ENTRYID,
        PR_INSTANCE_KEY,
        PR_OBJECT_TYPE,
        PR_EMAIL_ADDRESS,
        PR_RECORD_KEY,
        PR_NICKNAME,
        //PR_WAB_THISISME
    }
};

// [PaulHi] 2/25/99 ANSI version of ITableColumns
const SizedSPropTagArray(itcMax, ITableColumns_A) =
{
    itcMax,
    {
        PR_ADDRTYPE_A,
        PR_DISPLAY_NAME_A,
        PR_DISPLAY_TYPE,
        PR_ENTRYID,
        PR_INSTANCE_KEY,
        PR_OBJECT_TYPE,
        PR_EMAIL_ADDRESS_A,
        PR_RECORD_KEY,
        PR_NICKNAME_A,
        //PR_WAB_THISISME
    }
};


const SizedSPropTagArray(iwdesMax, tagaDLEntriesProp) =
{
    iwdesMax,
    {
        PR_WAB_DL_ENTRIES,
    }
};


const SizedSPropTagArray(ildapcMax, ptaLDAPCont) =
{
  ildapcMax,
  {
    PR_WAB_LDAP_SERVER
  }
};


//
// Properties to get for each container in a Resolve
//
const SizedSPropTagArray(irnMax, irnColumns) =
{
    irnMax,
    {
        PR_OBJECT_TYPE,
        PR_WAB_RESOLVE_FLAG,
        PR_ENTRYID,
        PR_DISPLAY_NAME,
    }
};

//
// container default properties
// Put essential props first
//
const SizedSPropTagArray(ivMax, tagaValidate) = {
	ivMax,
   {
       PR_DISPLAY_NAME,
       PR_SURNAME,
       PR_GIVEN_NAME,
       PR_OBJECT_TYPE,
       PR_EMAIL_ADDRESS,
       PR_ADDRTYPE,
       PR_CONTACT_EMAIL_ADDRESSES,
       PR_CONTACT_ADDRTYPES,
       PR_MIDDLE_NAME,
       PR_COMPANY_NAME,
       PR_NICKNAME
	}
};

// Default creation templates for the WAB
//
const SizedSPropTagArray(icrMax, ptaCreate)=
{
    icrMax,
    {
        PR_DEF_CREATE_MAILUSER,
        PR_DEF_CREATE_DL,
    }
};

const SizedSPropTagArray(ieidMax, ptaEid)=
{
    ieidMax,
    {
        PR_DISPLAY_NAME,
        PR_ENTRYID,
    }
};



//
// IMPORTANT NOTE: If you change this array, you must change
//  _IndexType in mpswab.h to match!
//
// This is the set of Indexes from the WAB Data store and is closely
//  tied to the physical layout of data in the WAB store - therefore 
//  *Do NOT* modify this array 
//
const ULONG rgIndexArray[indexMax] =
    {
        PR_ENTRYID,
        PR_DISPLAY_NAME,
        PR_SURNAME,
        PR_GIVEN_NAME,
        PR_EMAIL_ADDRESS,
        PR_NICKNAME,
    };


//
// IMPORTANT NOTE: If you change this, you must change _AddrBookColumns in uimisc.h!
//
const int lprgAddrBookColHeaderIDs[NUM_COLUMNS] =
{
    idsColDisplayName,
    idsColEmailAddress,
    idsColOfficePhone,
    idsColHomePhone
};


// External memory allocators (passed in on WABOpenEx)
int g_nExtMemAllocCount = 0;
ALLOCATEBUFFER * lpfnAllocateBufferExternal = NULL;
ALLOCATEMORE * lpfnAllocateMoreExternal = NULL;
FREEBUFFER * lpfnFreeBufferExternal = NULL;
LPUNKNOWN pmsessOutlookWabSPI = NULL;

LPWABOPENSTORAGEPROVIDER lpfnWABOpenStorageProvider = NULL;

// for registry property tags
LPTSTR szPropTag1 =  TEXT("PropTag1");
LPTSTR szPropTag2 =  TEXT("PropTag2");

// registry key constants
LPCTSTR lpNewWABRegKey = TEXT("Software\\Microsoft\\WAB\\WAB4");
LPCTSTR lpRegUseOutlookVal = TEXT("UseOutlook");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\entryid.c ===
/***********************************************************************
 *
 * ENTRYID.C
 *
 * Windows AB EntryID functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 05.13.96     Bruce Kelley        Created
 *
 ***********************************************************************/

#include <_apipch.h>

#define _WAB_ENTRYID_C

static UUID WABGUID = { /* d3ad91c0-9d51-11cf-a4a9-00aa0047faa4 */
    0xd3ad91c0,
    0x9d51,
    0x11cf,
    {0xa4, 0xa9, 0x00, 0xaa, 0x00, 0x47, 0xfa, 0xa4}
};

static UUID MAPIGUID = { /* a41f2b81-a3be-1910-9d6e-00dd010f5402 */
    0xa41f2b81,
    0xa3be,
    0x1910,
    {0x9d, 0x6e, 0x00, 0xdd, 0x01, 0x0f, 0x54, 0x02}
};
#ifdef _WIN64
#define	MYALIGN				((POINTER_64_INT) (sizeof(ALIGNTYPE) - 1))
// #define	MYALIGN				((ULONG) (sizeof(ALIGNTYPE) - 1))
// #define MyPbAlignPb(pb)		((LPBYTE) ((((DWORD) (pb)) + ALIGN) & ~ALIGN))
#define MyPbAlignPb(pb)		((LPBYTE) ((((POINTER_64_INT) (pb)) + MYALIGN) & ~MYALIGN))
#endif 

/***************************************************************************

    Name      : CreateWABEntryID

    Purpose   : Creates a WAB EntryID

    Parameters: bType = one of WAB_PAB, WAB_DEF_DL, WAB_DEF_MAILUSER,
                WAB_ONEOFF, WAB_LDAP_CONTAINER, WAB_LDAP_MAILUSER, WAB_PABSHARED

                lpData1, lpData2, lpData3 = data to be placed in entryid
                lpRoot = AllocMore root structure (NULL if we should
                  use AllocateBuffer instead of AllocateMore)
                lpcbEntryID -> returned size of lpEntryID.
                lpEntryID -> returned buffer containing entryid.  This buffer
                  is AllocMore'd onto the lpAllocMore buffer.  Caller is
                  responsible for MAPIFreeing this buffer.

    Returns   : HRESULT

    Comment   : WAB EID format is MAPI_ENTRYID:
                	BYTE	abFlags[4];
                	MAPIUID	mapiuid;     //  = WABONEOFFEID
                	BYTE	bData[];     // Contains BYTE type followed by type
                                        // specific data:
                                        // WAB_ONEOFF:
                                        //   szDisplayName, szAddrType and szAddress.
                                        //   the delimiter is the null between the strings.
                                        //

            4/21/97
            Outlook doesnt understand WAB One-Off EntryIDs. Outlook wants MAPI 
            One-off EntryIDs. What Outlook wants, Outlook gets. 
            MAPI EntryIDs have a slightly different format than WAB entryids.

***************************************************************************/
HRESULT CreateWABEntryID(
    BYTE bType,
    LPVOID lpData1,
    LPVOID lpData2,
    LPVOID lpData3,
    ULONG ulData1,
    ULONG ulData2,
    LPVOID lpRoot,
    LPULONG lpcbEntryID,
    LPENTRYID * lppEntryID) 
{
    // [PaulHi] 1/21/99  @review
    // I assume that the default WAB_ONEOFF EID we create is UNICODE.  If we want an ANSI
    // WAB_ONEOFF EID then the CreateWABEntryEx() function needs to be called instead of
    // this one, with the first parameter set to FALSE.
    return CreateWABEntryIDEx(TRUE, bType, lpData1, lpData2, lpData3, ulData1, ulData2, lpRoot, lpcbEntryID, lppEntryID);
}


////////////////////////////////////////////////////////////////////////////////
//  CreateWABEntryIDEx
//
//  Same as CreateWABEntryID except that this function also takes a bIsUnicode
//  parameter.  If this boolean is TRUE then a WAB_ONEOFF MAPI EID will have 
//  the MAPI_UNICODE bit set in the ulDataType flag, otherwise it this bit 
//  won't be set.
////////////////////////////////////////////////////////////////////////////////
HRESULT CreateWABEntryIDEx(
    BOOL bIsUnicode,
    BYTE bType,
    LPVOID lpData1,
    LPVOID lpData2,
    LPVOID lpData3,
    ULONG ulData1,
    ULONG ulData2,
    LPVOID lpRoot,
    LPULONG lpcbEntryID,
    LPENTRYID * lppEntryID)
{
    SCODE   sc = SUCCESS_SUCCESS;
    LPMAPI_ENTRYID lpeid;
    ULONG   ulSize = sizeof(MAPI_ENTRYID) + sizeof(bType);
    ULONG   cbData1, cbData2;
    UNALIGNED LPBYTE  *llpb;
    LPBYTE  lpb23;
    LPSTR   lpszData1 = NULL;
    LPSTR   lpszData2 = NULL;
    LPSTR   lpszData3 = NULL;

#ifdef _WIN64
    ulSize = LcbAlignLcb(ulSize);
#endif
    switch ((int)bType) {
        case WAB_PAB:
        case WAB_PABSHARED:
        case WAB_DEF_DL:
        case WAB_DEF_MAILUSER:
            break;

        case WAB_ONEOFF:
            if (! lpData1 || ! lpData2 || ! lpData3) {
                sc = MAPI_E_INVALID_PARAMETER;
                goto exit;
            }
            
///--- 4/22/97 - MAPI One Off stuff
            // No Type here 
            ulSize -= sizeof(bType);
            // Instead, add space for version and type
            ulSize += sizeof(DWORD);
///---

            // Need more space for data strings
            // [PaulHi] 1/21/99 Raid 64211 External clients may request non-UNICODE
            // MAPI EID strings.
            if (!bIsUnicode)
            {
                // First convert strings to ANSI to get accurate DBCS count
                lpszData1 = ConvertWtoA((LPTSTR)lpData1);
                lpszData2 = ConvertWtoA((LPTSTR)lpData2);
                lpszData3 = ConvertWtoA((LPTSTR)lpData3);

                if (!lpszData1 || !lpszData2 || !lpszData3)
                {
                    sc = E_OUTOFMEMORY;
                    goto exit;
                }

                // Compute size for single byte strings
#ifdef _WIN64
                ulSize += cbData1 = LcbAlignLcb((lstrlenA(lpszData1) + 1));
                ulSize += cbData2 = LcbAlignLcb((lstrlenA(lpszData2) + 1));
                ulSize += LcbAlignLcb((lstrlenA(lpszData3) + 1));
#else
                ulSize += cbData1 = (lstrlenA(lpszData1) + 1);
                ulSize += cbData2 = (lstrlenA(lpszData2) + 1);
                ulSize += (lstrlenA(lpszData3) + 1);
#endif // _WIN64

            }
            else
            {
                // Compute size for double byte strings
#ifdef _WIN64
                ulSize += cbData1 = LcbAlignLcb((sizeof(TCHAR)*(lstrlen((LPTSTR)lpData1) + 1)));
                ulSize += cbData2 = LcbAlignLcb((sizeof(TCHAR)*(lstrlen((LPTSTR)lpData2) + 1)));
                ulSize += LcbAlignLcb(sizeof(TCHAR)*(lstrlen((LPTSTR)lpData3) + 1));
#else
                ulSize += cbData1 = (sizeof(TCHAR)*(lstrlen((LPTSTR)lpData1) + 1));
                ulSize += cbData2 = (sizeof(TCHAR)*(lstrlen((LPTSTR)lpData2) + 1));
                ulSize += sizeof(TCHAR)*(lstrlen((LPTSTR)lpData3) + 1);
#endif // _WIN64
            }
            break;

        case WAB_ROOT:
            // NULL entryid
            *lppEntryID = NULL;
            *lpcbEntryID = 0;
            goto exit;

        case WAB_CONTAINER:
            if (! lpData1) {
                sc = MAPI_E_INVALID_PARAMETER;
                goto exit;
            }
            ulSize += sizeof(ULONG) + ulData1;
            break;

        case WAB_LDAP_CONTAINER:
            if (! lpData1) {
                sc = MAPI_E_INVALID_PARAMETER;
                goto exit;
            }
#ifdef _WIN64
            ulSize += cbData1 = LcbAlignLcb((sizeof(TCHAR)*(lstrlen((LPTSTR)lpData1) + 1)));
#else
            ulSize += cbData1 = (sizeof(TCHAR)*(lstrlen((LPTSTR)lpData1) + 1));
#endif // _WIN64
            break;

        case WAB_LDAP_MAILUSER:
            if (! lpData1 || ! lpData2) {
                sc = MAPI_E_INVALID_PARAMETER;
                goto exit;
            }
#ifdef _WIN64
            ulSize += cbData1 = LcbAlignLcb((sizeof(TCHAR)*(lstrlen((LPTSTR)lpData1) + 1)));
            ulSize += cbData2 = LcbAlignLcb((sizeof(TCHAR)*(lstrlen((LPTSTR)lpData2) + 1)));
            ulSize += LcbAlignLcb(sizeof(ULONG)) // this one stores the cached array count
                    + LcbAlignLcb(sizeof(ULONG)) // this one stores the cached array buf size
                    + LcbAlignLcb(ulData2);      // this one stores the cached array
#else
            ulSize += cbData1 = (sizeof(TCHAR)*(lstrlen((LPTSTR)lpData1) + 1));
            ulSize += cbData2 = (sizeof(TCHAR)*(lstrlen((LPTSTR)lpData2) + 1));
            ulSize += sizeof(ULONG) // this one stores the cached array count
                    + sizeof(ULONG) // this one stores the cached array buf size
                    + ulData2;      // this one stores the cached array
#endif // _WIN64
            break;

        default:
            Assert(FALSE);
            sc = MAPI_E_INVALID_PARAMETER;
            goto exit;
    }

    *lppEntryID = NULL;

#ifdef _WIN64
    ulSize = LcbAlignLcb(ulSize);
#endif

    if (lpRoot) {
        if (sc = MAPIAllocateMore(ulSize, lpRoot, lppEntryID)) {
            goto exit;
        }
    } else {
        if (sc = MAPIAllocateBuffer(ulSize, lppEntryID)) {
            goto exit;
        }
    }

    lpeid = (LPMAPI_ENTRYID)*lppEntryID;
    *lpcbEntryID = ulSize;

    lpeid->abFlags[0] = 0;
    lpeid->abFlags[1] = 0;
    lpeid->abFlags[2] = 0;
    lpeid->abFlags[3] = 0;

///--- 4/22/97 - MAPI One Off stuff
    lpb23 = lpeid->bData;
    llpb = &lpb23;

    // Mark this EID as WAB
    if(bType == WAB_ONEOFF)
    {
        MemCopy(&lpeid->mapiuid, &MAPIGUID, sizeof(MAPIGUID));
        /*
        // version and flag are 0
        // *((LPDWORD)lpb) = 0;
        // lpb += sizeof(DWORD);
        //
        // Bug 32101 dont set flag to 0 - this means always send rich info
        */
        // [PaulHi] 1/21/99  Raid 64211  Set MAPI_UNICODE flag as appropriate
        *((LPULONG)*llpb) = MAKELONG(0, MAPI_ONE_OFF_NO_RICH_INFO);
        if (bIsUnicode)
	        *((LPULONG)*llpb) += MAPI_UNICODE;
	    (*llpb) += sizeof(ULONG);
    }
    else
    {
        LPBYTE  lpb1 = *llpb;
        MemCopy(&lpeid->mapiuid, &WABGUID, sizeof(WABGUID));
        // Fill in the EntryID Data
        *lpb1 = bType;
        (*llpb)++;
    }
///---

    // Fill in any other data
    switch ((int)bType)
    {
        case WAB_ONEOFF:
            if (!bIsUnicode)
            {
                // single byte characters, converted above
#ifdef _WIN64
                LPBYTE lpb = *llpb;
                Assert(lpszData1 && lpszData2 && lpszData3);

                lpb = MyPbAlignPb(lpb);

                lstrcpyA((LPSTR)lpb, lpszData1);
                lpb += cbData1;

                lstrcpyA((LPSTR)lpb, lpszData2);
                lpb += cbData2;

                lstrcpyA((LPSTR)lpb, lpszData3);
                (*llpb) = lpb;
#else
                Assert(lpszData1 && lpszData2 && lpszData3);

                lstrcpyA((LPSTR)*llpb, lpszData1);
                (*llpb) += cbData1;
                lstrcpyA((LPSTR)*llpb, lpszData2);
                (*llpb) += cbData2;
                lstrcpyA((LPSTR)*llpb, lpszData3);
#endif //_WIN64
            }
            else
            {
                // double byte characters
                lstrcpy((LPTSTR)*llpb, (LPTSTR)lpData1);
                (*llpb) += cbData1;
                lstrcpy((LPTSTR)*llpb, (LPTSTR)lpData2);
                (*llpb) += cbData2;
                lstrcpy((LPTSTR)*llpb, (LPTSTR)lpData3);
            }
            break;

        case WAB_CONTAINER:
            CopyMemory(*llpb, &ulData1, sizeof(ULONG));
            (*llpb) += sizeof(ULONG);
            CopyMemory(*llpb, lpData1, ulData1);
            break;

        case WAB_LDAP_CONTAINER:
            {
                UNALIGNED WCHAR * lp2 = lpData1;
#ifdef _WIN64
                LPBYTE lpb = *llpb;

                lpb = MyPbAlignPb(lpb);
                lstrcpy((LPTSTR) lpb, (LPCTSTR) lp2);  // LDAP Server name
#else 
                lstrcpy((LPTSTR) *llpb, (LPCTSTR) lp2);  // LDAP Server name

#endif 
            }
            break;

        case WAB_LDAP_MAILUSER:
            {
            UNALIGNED WCHAR * lp2 = lpData1;
#ifdef _WIN64
            LPBYTE lpb = *llpb;
        
            lpb = MyPbAlignPb(lpb);
            lstrcpy((LPTSTR) lpb, (LPCTSTR) lp2);  // LDAP Server name
            lpb += cbData1;
#else 
            lstrcpy((LPTSTR)*llpb, (LPTSTR)lpData1);  // LDAP Server name
            (*llpb) += cbData1;
#endif

#ifdef _WIN64
//            lpb = *llpb;      
//            lpb = MyPbAlignPb(lpb);
            lstrcpy((LPTSTR) lpb, (LPCTSTR) lpData2);  // LDAP Server name
            (*llpb) = lpb;

            lpb += cbData2;
            CopyMemory(lpb, &ulData1, sizeof(ULONG));
            lpb += sizeof(ULONG);
            lpb = MyPbAlignPb(lpb);

            CopyMemory(lpb, &ulData2, sizeof(ULONG));
            lpb += sizeof(ULONG);
            lpb = MyPbAlignPb(lpb);
            CopyMemory(lpb, lpData3, ulData2);
            (*llpb) = lpb;

#else 
            lstrcpy((LPTSTR)*llpb, (LPTSTR)lpData2);  // LDAP search name

            (*llpb) += cbData2;
            CopyMemory(*llpb, &ulData1, sizeof(ULONG));
            (*llpb) += sizeof(ULONG);
            CopyMemory(*llpb, &ulData2, sizeof(ULONG));
            (*llpb) += sizeof(ULONG);
            CopyMemory(*llpb, lpData3, ulData2);
#endif
            }
            break;
    } // end switch

exit:
    // Clean up
    LocalFreeAndNull(&lpszData1);
    LocalFreeAndNull(&lpszData2);
    LocalFreeAndNull(&lpszData3);

    return(ResultFromScode(sc));
}


/***************************************************************************

    Name      : IsWABEntryID

    Purpose   : Validates a WAB EntryID

    Parameters: cbEntryID = size of lpEntryID.
                lpEntryID -> entryid to check.
                lppData1, lppData2 lppData3 = data from the entryid
                  These returned pointers are pointers WITHIN the input
                  lpEntryID and are not allocated seperately.  They should
                  not be freed.

                  If lpData1 is NULL, then these values will not be returned.

    Returns   : bType = one of WAB_PAB, WAB_DEF_DL, WAB_DEF_MAILUSER,
                WAB_ONEOFF, WAB_LDAP_CONTAINER, WAB_LDAP_MAILUSER, WAB_PABSHARED or 0 if
                this is not a WAB EntryID.

    Comment   :

***************************************************************************/
BYTE IsWABEntryID(
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  LPVOID * lppData1,
  LPVOID * lppData2,
  LPVOID * lppData3,
  LPVOID * lppData4,
  LPVOID * lppData5)
{
    BYTE bType;
    LPMAPI_ENTRYID lpeid;
    LPBYTE lpData1, lpData2, lpData3;
    ULONG cbData1, cbData2;
    UNALIGNED BYTE *lpb = NULL ;
    ULONG ulMapiDataType = 0;

    // First check... is it big enough?
    if (cbEntryID < sizeof(MAPI_ENTRYID) + sizeof(bType)) {
        return(0);
    }

    lpeid = (LPMAPI_ENTRYID)lpEntryID;

    // Next check... does it contain our GUID?

///--- 4/22/97 - MAPI One Off stuff
    if (!memcmp(&lpeid->mapiuid, &MAPIGUID, sizeof(MAPIGUID))) 
    {
        // [PaulHi] 1/21/99  The first ULONG in lpeid->bData is the MAPI datatype.  
        // This will indicate whether the EID strings are ANSI or UNICODE.
#ifdef _WIN64
		UNALIGNED ULONG * lpu;
        lpb = lpeid->bData;
		lpu = (UNALIGNED ULONG *)lpb;
        ulMapiDataType = *lpu;
#else
        lpb = lpeid->bData;
        ulMapiDataType = *((ULONG *)lpb);
#endif // _WIN64
        lpb += sizeof(ULONG);
        bType = WAB_ONEOFF;
    }
    else if (!memcmp(&lpeid->mapiuid, &WABGUID, sizeof(WABGUID))) 
    {
        lpb = lpeid->bData;
        bType = *lpb;
        lpb++;
    }
    else
    {
        return(0);  // No match
    }
///---

    switch ((int)bType) {
        case WAB_PABSHARED:
        case WAB_PAB:
        case WAB_DEF_DL:
        case WAB_DEF_MAILUSER:
            // No more data
            break;

        case WAB_CONTAINER:
            CopyMemory(&cbData1, lpb, sizeof(ULONG));
            lpb += sizeof(ULONG);
            lpData1 = lpb;
            if(lppData1)
            {
                *lppData1 = lpData1;
                *lppData2 = (LPVOID) IntToPtr(cbData1);
            }
            break;

        case WAB_ONEOFF:
            // Validate the data strings
            // [PaulHi] 1/20/99  Raid 64211
            // Outlook2K may pass in MAPI ANSI EIDs or EIDs with UNICODE strings.
            // OL2K will set the MAPI_UNICODE flag accordingly.
            if (ulMapiDataType & MAPI_UNICODE)
            {
                // Double byte strings
                lpData1 = lpb;
                if (IsBadStringPtr((LPTSTR)lpData1, 0xFFFFFFFF)) {
                    return(0);
                }
#ifdef _WIN64
                cbData1 = LcbAlignLcb((sizeof(TCHAR)*(lstrlen((LPTSTR)lpData1) + 1)));
#else
                cbData1 = (sizeof(TCHAR)*(lstrlen((LPTSTR)lpData1) + 1));
#endif //_WIN64

                lpData2 = lpData1 + cbData1;
                if (IsBadStringPtr((LPTSTR)lpData2, 0xFFFFFFFF)) {
                    return(0);
                }
#ifdef _WIN64
                cbData2 = LcbAlignLcb((sizeof(TCHAR)*(lstrlen((LPTSTR)lpData2) + 1)));
#else
                cbData2 = (sizeof(TCHAR)*(lstrlen((LPTSTR)lpData2) + 1));
#endif // _WIN64
                lpData3 = lpData2 + cbData2;
                if (IsBadStringPtr((LPTSTR)lpData3, 0xFFFFFFFF)) {
                    return(0);
                }
            }
            else
            {
                // Single byte strings
#ifdef _WIN64
                lpb = MyPbAlignPb(lpb);
                lpData1 = lpb;
                if (IsBadStringPtrA((LPSTR)lpData1, 0xFFFFFFFF)) {
                    return(0);
                }
                cbData1 = lstrlenA((LPSTR)lpData1) + 1;
                lpData2 = lpData1 + LcbAlignLcb(cbData1);
                if (IsBadStringPtrA((LPSTR)lpData2, 0xFFFFFFFF)) {
                    return(0);
                }
                cbData2 = lstrlenA((LPSTR)lpData2) + 1;
                lpData3 = lpData2 + LcbAlignLcb(cbData2);
                if (IsBadStringPtrA((LPSTR)lpData3, 0xFFFFFFFF)) {
                    return(0);
                }
#else
                lpData1 = lpb;
                if (IsBadStringPtrA((LPSTR)lpData1, 0xFFFFFFFF)) {
                    return(0);
                }
                cbData1 = lstrlenA((LPSTR)lpData1) + 1;
                lpData2 = lpData1 + cbData1;
                if (IsBadStringPtrA((LPSTR)lpData2, 0xFFFFFFFF)) {
                    return(0);
                }
                cbData2 = lstrlenA((LPSTR)lpData2) + 1;
                lpData3 = lpData2 + cbData2;
                if (IsBadStringPtrA((LPSTR)lpData3, 0xFFFFFFFF)) {
                    return(0);
                }
#endif // _WIN64
            }
            if (lppData1)
            {
                Assert(lppData2);
                Assert(lppData3);
                *lppData1 = lpData1;
                *lppData2 = lpData2;
                *lppData3 = lpData3;
                // [PaulHi] Also return the MAPI data type variable, if requested
                if (lppData4)
                    *((ULONG *)lppData4) = ulMapiDataType;
            }
            break;

        case WAB_LDAP_CONTAINER:
            // Validate the data strings
#ifdef _WIN64
            lpData1 = MyPbAlignPb(lpb);
#else
            lpData1 = lpb;
#endif // _WIN64
            if (IsBadStringPtr((LPTSTR)lpData1, 0xFFFFFFFF)) {
                return(0);
            }
            if (lppData1) {
                *lppData1 = lpData1;
            }
            break;

        case WAB_LDAP_MAILUSER:
            // Validate the data strings
            {
#ifdef _WIN64
            UNALIGNED BYTE * lp2 = lpb;
            lp2 = MyPbAlignPb(lp2);
            lpData1 = lp2;
#else
            lpData1 = lpb;
#endif              
            if (IsBadStringPtr((LPTSTR)lpData1, 0xFFFFFFFF)) 
            {
                return(0);
            }
#ifdef _WIN64
            cbData1 = LcbAlignLcb(sizeof(TCHAR)*(lstrlen((LPTSTR)lpData1) + 1));
#else
            cbData1 = sizeof(TCHAR)*(lstrlen((LPTSTR)lpData1) + 1);
#endif // _WIN64
            lpData2 = lpData1 + cbData1;

            if (IsBadStringPtr((LPTSTR)lpData2, 0xFFFFFFFF)) 
            {
                return(0);
            }
#ifdef _WIN64
            cbData2 = LcbAlignLcb(sizeof(TCHAR)*(lstrlen((LPTSTR)lpData2) + 1));
#else
            cbData2 = sizeof(TCHAR)*(lstrlen((LPTSTR)lpData2) + 1);
#endif // _WIN64

            lpData3 = lpData2 + cbData2;
            if (lppData4)
            {
                CopyMemory(lppData4, lpData3, sizeof(ULONG)); //Copy the # of props in cached buffer
            }
            lpData3 += sizeof(ULONG);
#ifdef _WIN64
            lpData3 = MyPbAlignPb(lpData3);
#endif //_WIN64
            if (lppData5)
            {
                CopyMemory(lppData5, lpData3, sizeof(ULONG)); //Copy the size of cached buffer
            }
            lpData3 += sizeof(ULONG);
#ifdef _WIN64
            lpData3 = MyPbAlignPb(lpData3);
#endif //_WIN64
            if (lppData1) 
                {
                *lppData1 = lpData1;
                if(lppData2)
                    *lppData2 = lpData2;
                if(lppData3)
                    *lppData3 = lpData3;
                }
            }
            break;

        default:
            return(0);  // Not a valid WAB EID
    }

    return(bType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\iadrbook.h ===
//	MAPI Address Book object
//$	It is somewhat bogus for this to be here, but since this object
//	is where the common implementations of QueryInterface, AddRef,
//	and GetLastError are, here it is.

#undef	INTERFACE
#define INTERFACE	struct _IAB

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, IAB_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
		MAPI_IADDRBOOK_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, IAB_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
		MAPI_IADDRBOOK_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IAB_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIPROP_METHODS(IMPL)
	MAPI_IADDRBOOK_METHODS(IMPL)
};


struct _IAB;
typedef struct _IAB *LPIAB;

typedef struct _AMBIGUOUS_TABLES {
    ULONG cEntries;
    LPMAPITABLE lpTable[];
} AMBIGUOUS_TABLES, * LPAMBIGUOUS_TABLES;


extern const TCHAR szSMTP[];

// Public functions
BOOL IsInternetAddress(LPTSTR lpAddress, LPTSTR * lppEmail);
void CountFlags(LPFlagList lpFlagList, LPULONG lpulResolved,
  LPULONG lpulAmbiguous, LPULONG lpulUnresolved);


HRESULT HrGetIDsFromNames(LPIAB lpIAB,  ULONG cPropNames,
                            LPMAPINAMEID * lppPropNames, ULONG ulFlags, LPSPropTagArray * lppPropTags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\hotsync.c ===
//  
//  HotSync.c
//
//  Contains code to synchronize addresses and groups with
//  HotMail servers
//

#define COBJMACROS
#include <_apipch.h>
#include <wab.h>
#define COBJMACROS
#include "HotSync.h"
#include "iso8601.h"
#include "uimisc.h"
#include "ui_cflct.h"
#include "ui_pwd.h"
#include "useragnt.h"

#define ARRAYSIZE(_rg)  (sizeof(_rg)/sizeof(_rg[0]))

typedef enum {
    CIS_STRING = 0,
    CIS_BOOL,
    CIS_DWORD
}CIS_TYPE;

typedef struct CONTACTINFO_STRUCTURE
{
    CIS_TYPE    tType;
    DWORD       dwOffset;
}CONTACTINFO_STRUCTURE;

enum {
    idcisHref = 0,
    idcisId,
    idcisType,
    idcisModified,
    idcisDisplayName,
    idcisGivenName,
    idcisSurname,
    idcisNickName,
    idcisEmail,
    idcisHomeStreet,
    idcisHomeCity, 
    idcisHomeState, 
    idcisHomePostalCode, 
    idcisHomeCountry, 
    idcisCompany, 
    idcisWorkStreet, 
    idcisWorkCity, 
    idcisWorkState, 
    idcisWorkPostalCode, 
    idcisWorkCountry, 
    idcisHomePhone, 
    idcisHomeFax, 
    idcisWorkPhone, 
    idcisWorkFax, 
    idcisMobilePhone, 
    idcisOtherPhone, 
    idcisBday,
    idcisPager
};

CONTACTINFO_STRUCTURE   g_ContactInfoStructure[] = 
{
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszHref)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszId)}, 
    {CIS_DWORD,  offsetof(HTTPCONTACTINFO, tyContact)},
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszModified)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszDisplayName)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszGivenName)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszSurname)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszNickname)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszEmail)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszHomeStreet)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszHomeCity)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszHomeState)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszHomePostalCode)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszHomeCountry)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszCompany)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszWorkStreet)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszWorkCity)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszWorkState)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszWorkPostalCode)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszWorkCountry)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszHomePhone)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszHomeFax)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszWorkPhone)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszWorkFax)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszMobilePhone)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszOtherPhone)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszBday)},
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszPager)}
};

#define CIS_FIRST_DATA_FIELD    5

#define CIS_GETSTRING(pci, i)  (*((char **)(&((char *)pci)[g_ContactInfoStructure[i].dwOffset])))
#define CIS_GETTYPE(i)         (g_ContactInfoStructure[i].tType)

IHTTPMailCallbackVtbl vtblIHTTPMAILCALLBACK = {
    VTABLE_FILL
    WABSync_QueryInterface,
    WABSync_AddRef,
    WABSync_Release,
    WABSync_OnTimeout,
    WABSync_OnLogonPrompt,
    WABSync_OnPrompt,
    WABSync_OnStatus,
    WABSync_OnError,
    WABSync_OnCommand,
    WABSync_OnResponse,
    WABSync_GetParentWindow
};



enum {
    ieid_PR_DISPLAY_NAME = 0,
    ieid_PR_OBJECT_TYPE,
    ieid_PR_ENTRYID,
	ieid_PR_LAST_MODIFICATION_TIME,
	ieid_PR_WAB_HOTMAIL_CONTACTIDS,
	ieid_PR_WAB_HOTMAIL_SERVERIDS,
	ieid_PR_WAB_HOTMAIL_MODTIMES,
    ieid_Max
};

static SizedSPropTagArray(ieid_Max, ptaEidSync)=
{
    ieid_Max,
    {
        PR_DISPLAY_NAME,
        PR_OBJECT_TYPE,
        PR_ENTRYID,
        PR_LAST_MODIFICATION_TIME,
        PR_ENTRYID,
        PR_ENTRYID,
        PR_ENTRYID
    }
};

enum {
    ieidc_PR_DISPLAY_NAME = 0,
    ieidc_PR_OBJECT_TYPE,
    ieidc_PR_ENTRYID,
	ieidc_PR_LAST_MODIFICATION_TIME,
    ieidc_PR_GIVEN_NAME,
    ieidc_PR_SURNAME,
    ieidc_PR_NICKNAME,
    ieidc_PR_EMAIL_ADDRESS,
    ieidc_PR_HOME_ADDRESS_STREET,
    ieidc_PR_HOME_ADDRESS_CITY,
    ieidc_PR_HOME_ADDRESS_STATE_OR_PROVINCE,
    ieidc_PR_HOME_ADDRESS_POSTAL_CODE,
    ieidc_PR_HOME_ADDRESS_COUNTRY,
    ieidc_PR_COMPANY_NAME,
    ieidc_PR_BUSINESS_ADDRESS_STREET,
    ieidc_PR_BUSINESS_ADDRESS_CITY,
    ieidc_PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE,
    ieidc_PR_BUSINESS_ADDRESS_POSTAL_CODE,
    ieidc_PR_BUSINESS_ADDRESS_COUNTRY,
    ieidc_PR_HOME_TELEPHONE_NUMBER,
    ieidc_PR_HOME_FAX_NUMBER,
    ieidc_PR_BUSINESS_TELEPHONE_NUMBER,
    ieidc_PR_BUSINESS_FAX_NUMBER,
    ieidc_PR_MOBILE_TELEPHONE_NUMBER,
    ieidc_PR_OTHER_TELEPHONE_NUMBER,
    ieidc_PR_BIRTHDAY,
    ieidc_PR_PAGER,
    ieidc_PR_CONTACT_EMAIL_ADDRESSES,
    ieidc_PR_CONTACT_DEFAULT_ADDRESS_INDEX,
#ifdef HM_GROUP_SYNCING
    ieidc_PR_WAB_DL_ENTRIES,
    ieidc_PR_WAB_DL_ONEOFFS,
#endif
	ieidc_PR_WAB_HOTMAIL_CONTACTIDS,
	ieidc_PR_WAB_HOTMAIL_SERVERIDS,
	ieidc_PR_WAB_HOTMAIL_MODTIMES,
    ieidc_Max
};

static SizedSPropTagArray(ieidc_Max, ptaEidCSync)=
{
    ieidc_Max,
    {
        PR_DISPLAY_NAME,
        PR_OBJECT_TYPE,
        PR_ENTRYID,
        PR_LAST_MODIFICATION_TIME,
        PR_GIVEN_NAME,
        PR_SURNAME,
        PR_NICKNAME,
        PR_EMAIL_ADDRESS,
        PR_HOME_ADDRESS_STREET,
        PR_HOME_ADDRESS_CITY,
        PR_HOME_ADDRESS_STATE_OR_PROVINCE,
        PR_HOME_ADDRESS_POSTAL_CODE,
        PR_HOME_ADDRESS_COUNTRY,
        PR_COMPANY_NAME,
        PR_BUSINESS_ADDRESS_STREET,
        PR_BUSINESS_ADDRESS_CITY,
        PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE,
        PR_BUSINESS_ADDRESS_POSTAL_CODE,
        PR_BUSINESS_ADDRESS_COUNTRY,
        PR_HOME_TELEPHONE_NUMBER,
        PR_HOME_FAX_NUMBER,
        PR_BUSINESS_TELEPHONE_NUMBER,
        PR_BUSINESS_FAX_NUMBER,
        PR_MOBILE_TELEPHONE_NUMBER,
        PR_OTHER_TELEPHONE_NUMBER,
        PR_BIRTHDAY,
        PR_PAGER_TELEPHONE_NUMBER,
        PR_CONTACT_EMAIL_ADDRESSES,
        PR_CONTACT_DEFAULT_ADDRESS_INDEX,
#ifdef HM_GROUP_SYNCING
        PR_WAB_DL_ENTRIES,
        PR_ENTRYID,
#endif
        PR_ENTRYID,
        PR_ENTRYID,
        PR_ENTRYID,
    }
};

// HM Nickname invalid characters
const ULONG MAX_INVALID_ARRAY_INDEX = 123;
static BOOL bInvalidCharArray[] = 
{
    TRUE,           // 0
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,           // 9
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,           // 19
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,           // 29
    TRUE,
    TRUE,
    TRUE,           // 32 (x20) Space
    TRUE,           //          !
    TRUE,           //          "
    TRUE,           //          #
    TRUE,           //          $
    TRUE,           //          %
    TRUE,           //          &
    TRUE,           //          '
    TRUE,           //          (
    TRUE,           //          )
    TRUE,           // 42       *
    TRUE,           //          +
    TRUE,           //          ,
    TRUE,           //          -
    TRUE,           //          .
    TRUE,           //          /
    FALSE,          //          0
    FALSE,          //          1
    FALSE,          //          2
    FALSE,          //          3
    FALSE,          // 52       4
    FALSE,          //          5
    FALSE,          //          6
    FALSE,          //          7
    FALSE,          //          8
    FALSE,          //          9
    TRUE,           //          :
    TRUE,           //          ;
    TRUE,           //          <
    TRUE,           //          =
    TRUE,           // 62       >
    TRUE,           //          ?
    TRUE,           //          @
    FALSE,          //          A
    FALSE,          //          B
    FALSE,          //          C
    FALSE,          //          D
    FALSE,          //          E
    FALSE,          //          F
    FALSE,          //          G
    FALSE,          // 72       H
    FALSE,          //          I
    FALSE,          //          J
    FALSE,          //          K
    FALSE,          //          L
    FALSE,          //          M
    FALSE,          //          N
    FALSE,          //          O
    FALSE,          //          P
    FALSE,          //          Q
    FALSE,          // 82       R
    FALSE,          //          S
    FALSE,          //          T
    FALSE,          //          U
    FALSE,          //          V
    FALSE,          //          W
    FALSE,          //          X
    FALSE,          //          Y
    FALSE,          //          Z
    TRUE,           //          [
    TRUE,           // 92       '\'
    TRUE,           //          ]
    TRUE,           //          ^
    FALSE,          //          _
    TRUE,           //          `
    FALSE,          //          a
    FALSE,          //          b
    FALSE,          //          c
    FALSE,          //          d
    FALSE,          //          e
    FALSE,          // 102      f
    FALSE,          //          g
    FALSE,          //          h
    FALSE,          //          i
    FALSE,          //          j
    FALSE,          //          k
    FALSE,          //          l
    FALSE,          //          m
    FALSE,          //          n
    FALSE,          //          o
    FALSE,          // 112      p
    FALSE,          //          q
    FALSE,          //          r
    FALSE,          //          s
    FALSE,          //          t
    FALSE,          //          u
    FALSE,          //          v
    FALSE,          //          w
    FALSE,          //          x
    FALSE,          //          y
    FALSE,          // 122      z
};

extern HRESULT InitUserIdentityManager(LPIAB lpIAB, IUserIdentityManager ** lppUserIdentityManager);

// Address Book Sync Window Class Name
LPTSTR g_lpszSyncKey = TEXT("Software\\Microsoft\\WAB\\Synchronization\\");

LPTSTR g_szSyncClass =  TEXT("WABSyncView");
extern VOID CenterDialog(HWND hwndDlg);

#define WM_SYNC_NEXTSTATE           (WM_USER + 4)
#define WM_SYNC_NEXTOP              (WM_USER + 5)
#define SafeCoMemFree(_pv) \
    if (_pv) { \
        CoTaskMemFree(_pv); \
        _pv = NULL; \
    } \
    else 


#ifdef HM_GROUP_SYNCING
HRESULT HrSynchronize(HWND hWnd, LPADRBOOK lpIAB, LPCTSTR pszAccountID, BOOL bSyncGroups)
#else
HRESULT HrSynchronize(HWND hWnd, LPADRBOOK lpIAB, LPCTSTR pszAccountID)
#endif
{
    HRESULT hr;
    LPWABSYNC   pWabSync;

//    if (!bIsThereACurrentUser((LPIAB)lpIAB))
//        return E_FAIL;

    // [PaulHi] Raid 62149  Check to see if user is connected
    {
        DWORD   dwConnectedState;
        TCHAR   tszCaption[256];
        TCHAR   tszMessage[256];

        if ( !InternetGetConnectedState(&dwConnectedState, 0) || (dwConnectedState & INTERNET_CONNECTION_OFFLINE) )
        {
            LoadString(hinstMapiX, idsSyncError, tszCaption, CharSizeOf(tszCaption));
            if (dwConnectedState & INTERNET_CONNECTION_OFFLINE)
                LoadString(hinstMapiX, idsOffline, tszMessage, CharSizeOf(tszMessage));
            else
                LoadString(hinstMapiX, idsNoInternetConnect, tszMessage, CharSizeOf(tszMessage));
            MessageBox(hWnd, tszMessage, tszCaption, MB_ICONEXCLAMATION | MB_OK);

            return E_FAIL;
        }
    }

    // Create the wab sync object
    hr = WABSync_Create(&pWabSync);
    if (FAILED(hr))
        goto exit;
    // initializing it kicks off the whole process
#ifdef HM_GROUP_SYNCING
    // [PaulHi] 2/22/99  Hotmail syncing is now done in two passes.  The first pass is
    // as before and synchronizes the normal email contacts.  The second pass synchronizes
    // the group contacts.  Group contacts contain references to email contacts so email
    // contacts must be completely synchronized before groups can be synchronized.
    hr = WABSync_Initialize(pWabSync, hWnd, lpIAB, pszAccountID, bSyncGroups);
#else
    hr = WABSync_Initialize(pWabSync, hWnd, lpIAB, pszAccountID);
#endif

exit:
    WABSync_Release((IHTTPMailCallback*)pWabSync);

    return hr;
}

static LPSTR _StrDup(LPCSTR pszStr)
{
  	LPMALLOC	lpMalloc;
    LPSTR       pszResult = NULL;
    
    if (!pszStr)
        return NULL;

    CoGetMalloc(MEMCTX_TASK, &lpMalloc);
    if (lpMalloc)
    {
        pszResult = (LPSTR) lpMalloc->lpVtbl->Alloc(lpMalloc, lstrlenA(pszStr) + 1);

        if (pszResult)
            lstrcpyA(pszResult, pszStr);
        lpMalloc->lpVtbl->Release(lpMalloc);
    }

    return pszResult;
}

void _FixHotmailDate(LPSTR pszDate)
{
    if (!pszDate)
        return;

    while (*pszDate)
    {
        if (*pszDate == 'T')
        {
            *pszDate = 0;
            break;
        }

        if (*pszDate == '.')
            *pszDate = '-';

        pszDate++;
    }
}

BOOL    LogTransactions(LPWABSYNC pWabSync)
{
    BOOL fInit = FALSE, fLogging = FALSE;
    LPTSTR  pszLogKey = TEXT("Software\\Microsoft\\Outlook Express\\5.0\\Mail");
    LPTSTR  pszLogValue = TEXT("Log HTTPMail (0/1)");
    IUserIdentityManager * lpUserIdentityManager = NULL;
    IUserIdentity * lpUserIdentity = NULL;
    HRESULT hr;
    HKEY hkeyIdentity = NULL, hkeyLog = NULL;
    DWORD   dwValue, dwType, dwSize;

    if(!bIsWABSessionProfileAware((LPIAB)(pWabSync->m_pAB)))
        goto exit;

    if(HR_FAILED(hr = InitUserIdentityManager((LPIAB)(pWabSync->m_pAB), &lpUserIdentityManager)))
        goto exit;
    
    fInit = TRUE;

    if(HR_FAILED(hr = lpUserIdentityManager->lpVtbl->GetIdentityByCookie(lpUserIdentityManager, 
                                                                        (GUID *)&UID_GIBC_CURRENT_USER,
                                                                        &lpUserIdentity)))
        goto exit;

    if (HR_FAILED(hr = lpUserIdentity->lpVtbl->OpenIdentityRegKey(lpUserIdentity, 
                                                                KEY_READ, &hkeyIdentity)))
        goto exit;
    
    if (RegOpenKeyEx(hkeyIdentity, pszLogKey, 0, KEY_READ, &hkeyLog) != ERROR_SUCCESS)
        goto exit;

    dwSize = sizeof(DWORD);

    if (RegQueryValueEx(hkeyLog, pszLogValue, NULL, &dwType, (LPBYTE) &dwValue, &dwSize) != ERROR_SUCCESS)
        goto exit;

    fLogging = (dwValue == 1);
exit:
    if(fInit)
        UninitUserIdentityManager((LPIAB)(pWabSync->m_pAB));

    if(lpUserIdentity)
        lpUserIdentity->lpVtbl->Release(lpUserIdentity);

    if (hkeyLog)
        RegCloseKey(hkeyLog);

    if (hkeyIdentity)
        RegCloseKey(hkeyIdentity);
    
    return fLogging;
}

DWORD   CountHTTPMailAccounts(LPIAB lpIAB)
{
    IImnAccountManager2 *lpAcctMgr;
    IImnEnumAccounts *pEnumAccts = NULL;
    DWORD dwCount = 0;
    HRESULT hr;

    if (FAILED(hr = InitAccountManager(lpIAB, &lpAcctMgr, NULL)) || NULL == lpAcctMgr)
        goto exit;

    if (FAILED(hr = lpAcctMgr->lpVtbl->Enumerate(lpAcctMgr, SRV_HTTPMAIL,&pEnumAccts)))
        goto exit;

    if (FAILED(hr = pEnumAccts->lpVtbl->GetCount(pEnumAccts, &dwCount)))
        dwCount = 0;

exit:
    if( pEnumAccts)
        pEnumAccts->lpVtbl->Release(pEnumAccts);

    return dwCount;
}

HRESULT _FindHTTPMailAccount(HWND hwnd, IImnAccountManager2 *lpAcctMgr, LPSTR pszAcctName, ULONG ccb)
{
    IImnEnumAccounts *pEnumAccts = NULL;
    DWORD dwCount = 0;
    IImnAccount *pAccount = NULL;
    HRESULT hr;

    Assert(lpAcctMgr);

    if (FAILED(hr = lpAcctMgr->lpVtbl->Enumerate(lpAcctMgr, SRV_HTTPMAIL,&pEnumAccts)))
        goto exit;

    if (FAILED(hr = pEnumAccts->lpVtbl->GetCount(pEnumAccts, &dwCount)) || dwCount == 0)
        goto exit;

    if (dwCount > 1)
    {
        if (!ChooseHotmailServer(hwnd, pEnumAccts, pszAcctName))
        {
            hr = E_UserCancel;
            goto exit;
        }
    }
    else
    {
        if (FAILED(hr = pEnumAccts->lpVtbl->GetNext(pEnumAccts, &pAccount)))
            goto exit;

        if (FAILED(hr = pAccount->lpVtbl->GetProp(pAccount, AP_ACCOUNT_ID, pszAcctName, &ccb)))
            goto exit;
    }
    
    hr = S_OK;
exit:
    if( pAccount)
        pAccount->lpVtbl->Release(pAccount);

    if( pEnumAccts)
        pEnumAccts->lpVtbl->Release(pEnumAccts);

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  HrMakeContactId
//
//  Helper function to convert ANSI strings and create UNICODE contact ID
//  string.
///////////////////////////////////////////////////////////////////////////////
HRESULT hrMakeContactId(
    LPTSTR  lptszContactId,     // [out]
    int     nCharNum,           // [in]
    LPCTSTR lptcszProfileId,    // [in]
    LPCSTR  lpcszAccountId,     // [in]
    LPCSTR  lpcszLoginName)     // [in]
{
    HRESULT hr = S_OK;
    LPWSTR  lpwszAccountId = NULL;
    LPWSTR  lpwszLoginName = NULL; 

    // Validate arguments
    if ( !lptszContactId ||
         !lptcszProfileId ||
         !lpcszAccountId ||
         !lpcszLoginName)
    {
        Assert(0);
        return ERROR_INVALID_PARAMETER;
    }

    // Check buffer size.  Account for the two extra '-' characters.
    if ( nCharNum <= (lstrlen(lptcszProfileId) + lstrlenA(lpcszAccountId) + lstrlenA(lpcszLoginName) + 2) )
    {
        Assert(0);
        return ERROR_INSUFFICIENT_BUFFER;
    }

    lpwszAccountId = ConvertAtoW(lpcszAccountId);
    lpwszLoginName = ConvertAtoW(lpcszLoginName);

    if (!lpwszAccountId || !lpwszLoginName)
    {
        Assert(0);
        hr = E_FAIL;
    }
    else
    {
        wsprintf(lptszContactId,  TEXT("%s-%s-%s"), lptcszProfileId, lpwszAccountId, lpwszLoginName);
    }
    
    LocalFreeAndNull(&lpwszAccountId);
    LocalFreeAndNull(&lpwszLoginName);

    return hr;
}


#ifdef HM_GROUP_SYNCING
///////////////////////////////////////////////////////////////////////////////
//  hrAppendName
//
//  Helper function to take a double byte name string, converts it to single
//  byte and appends it to the given name string, using ',' as the delimiter.
//  The name string pointer will be allocated and reallocated as needed.  The 
//  caller is responible for freeing the name string with CoTaskMemFree().
//
//  Parameters
//  [IN/OUT] lpszNameString - name string pointer
//  [IN]     ulCharCount - current name string size in char
//  [IN]     double byte character string to append
///////////////////////////////////////////////////////////////////////////////
LPCSTR lpszDelimiter = ",";

ULONG ulAppendName(
    LPSTR * lppszNameString,
    ULONG   ulCharCount,
    LPCTSTR lptszName)
{
    ULONG   ulLen = 0;
    ULONG   ulNewLen = 0;
    ULONG   ulNew = ulCharCount;
    LPSTR   lpszTemp = NULL;

    Assert(lppszNameString);
    Assert(lptszName);

    // Check size of new string
    ulNewLen = (ULONG)lstrlen(lptszName) + 2;  // Include delimiter character and termination
    if (*lppszNameString)
        ulLen = ulNewLen + (ULONG)lstrlenA(*lppszNameString);
    else
        ulLen = ulNewLen;
    if (ulLen > ulCharCount)
    {
        ulNew = (ulNewLen > MAX_PATH) ? (ulCharCount+ulNewLen+MAX_PATH) : (ulCharCount+MAX_PATH);
        lpszTemp = CoTaskMemAlloc(ulNew * sizeof(WCHAR));
        if (!lpszTemp)
        {
            Assert(0);
            goto error_out;
        }
        *lpszTemp = '\0';

        if (*lppszNameString)
        {
            lstrcpyA(lpszTemp, *lppszNameString);
            CoTaskMemFree(*lppszNameString);
        }
        *lppszNameString = lpszTemp;
    }

    // Append new string name
    {
        LPSTR   lptsz = ConvertWtoA(lptszName);
        if (**lppszNameString != '\0')
            lstrcatA(*lppszNameString, lpszDelimiter);
        lstrcatA(*lppszNameString, lptsz);
        LocalFreeAndNull(&lptsz);
    }

    return ulNew;

error_out:
    
    // Error, return NULL string pointer
    if (*lppszNameString)
    {
        CoTaskMemFree(*lppszNameString);
        *lppszNameString = NULL;
    }
            
    return 0;
}


///////////////////////////////////////////////////////////////////////////////
//  hrAppendGroupContact
//
//  Helper function to a group's PR_WAB_DL_ENTRIES and/or PR_WAB_DL_ONEOFFS
//  names and append to the given name string.  This name string is in the same
//  format as what is retrieved from a HotMail server, and is compared directly
//  with the corresponding HotMail group.  
//
//  a)  PR_WAB_DL_ENTRIES are WAB entry ID contacts that map to HM contacts
//      distinquished by nickname.
//  b)  PR_WAB_DL_ONEOFFS are WAB entry ID one-offs with user and email embedded
//      directly in the entry ID structure.
//
//  Parameters
//  [IN] pWabSync
//  [IN] ulPropTag
//  [IN] lpProp - Pointer to property struct
//  [IN/OUT] lppszHMEmailName - HM string with new names appended
//           !!NOTE that this needs to be freed by caller using CoMemTaskFree()!!
///////////////////////////////////////////////////////////////////////////////
HRESULT hrAppendGroupContact(
    LPWABSYNC    pWabSync,              // [IN]
    ULONG        ulPropTag,             // [IN]
    LPSPropValue lpProp,                // [IN]
    LPSTR *      lppszHMEmailName)      // [IN/OUT]
{
    HRESULT      hr = S_OK;
    LPSPropValue lpaProps = NULL;
    ULONG        ulcProps = 0;
    ULONG        ul;
    ULONG        ulCharSize = 0;

    Assert(pWabSync);
    Assert(lppszHMEmailName);
    Assert( (ulPropTag == PR_WAB_DL_ENTRIES) || (ulPropTag == PR_WAB_DL_ONEOFFS) );

    // Check each DL entry and check whether it is another WAB (mail user) contact
    // EID or a WAB One-Off email/name string EID.
    if (ulPropTag == PR_WAB_DL_ONEOFFS)
    {
        // Wab one-off is equivalent to a HM direct email name
        for (ul=0; ul<lpProp->Value.MVbin.cValues; ul++)
        {
            ULONG       cbEntryID = lpProp->Value.MVbin.lpbin[ul].cb;
            LPENTRYID   lpEntryID = (LPENTRYID)lpProp->Value.MVbin.lpbin[ul].lpb;
            BYTE        bType;
            LPTSTR      lptstrDisplayName, lptstrAddrType;
            LPTSTR      lptstrAddress = NULL;

            bType = IsWABEntryID(cbEntryID, lpEntryID, 
                        &lptstrDisplayName, 
                        &lptstrAddrType, 
                        &lptstrAddress, NULL, NULL);
            if (lptstrAddress)
            {
                // Append the one-off email name
                ulCharSize = ulAppendName(lppszHMEmailName, ulCharSize, lptstrAddress);
                if (ulCharSize == 0)
                {
                    hr = E_OUTOFMEMORY;
                    goto out;
                }
            }
            else
            {
                Assert(0);
            }
        }
    }
    else if (ulPropTag == PR_WAB_DL_ENTRIES)
    {
        // WAB mail user contact is equivalent to a HM contact
        for (ul=0; ul<lpProp->Value.MVbin.cValues; ul++)
        {
            HRESULT     hr;
            LPMAILUSER  lpMailUser;
            ULONG       ulObjectType;
            ULONG       cbEntryID = lpProp->Value.MVbin.lpbin[ul].cb;
            LPENTRYID   lpEntryID = (LPENTRYID)lpProp->Value.MVbin.lpbin[ul].lpb;

            hr = pWabSync->m_pAB->lpVtbl->OpenEntry(pWabSync->m_pAB, cbEntryID, lpEntryID, 
                NULL, 0, &ulObjectType, (LPUNKNOWN *)&lpMailUser);

            if (SUCCEEDED(hr))
            {
                LPSPropValue    lpaProps;
                ULONG           ulcProps;

                Assert(ulObjectType == MAPI_MAILUSER);

                // HM contacts are designated by the nickname field, so this is all
                // we need to append to the name string.
                hr = lpMailUser->lpVtbl->GetProps(lpMailUser, NULL, MAPI_UNICODE, &ulcProps, &lpaProps);
                if (SUCCEEDED(hr))
                {
                    ULONG   ulc;
                    LPCTSTR lptszNickname = NULL;
                    for (ulc=0; ulc<ulcProps; ulc++)
                    {
                        if (lpaProps[ulc].ulPropTag == PR_NICKNAME)
                            break;
                    }
                    if (ulc == ulcProps)
                    {
                        // No nickname.  This means that the preceeding contact sync has
                        // failed or not completed in some way.  Skip.
                        Assert(0);
                        continue;
                    }
                    else
                        lptszNickname = (LPCTSTR)lpaProps[ulc].Value.lpszW;

                    ulCharSize = ulAppendName(lppszHMEmailName, ulCharSize, lptszNickname);
                    if (ulCharSize == 0)
                    {
                        hr = E_OUTOFMEMORY;
                        goto out;
                    }
                }
            }
        }
    }
    else
    {
        // Trace("Unknown property tag type");
        Assert(0);
    }

out:

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  hrParseHMGroupEmail
//
//  Helper function to parse a HM group email string into nickname names 
//  (contacts) and email names (one-offs).  The name arrays are simply pointers
//  into the passed in email name string and so are valid as long at that 
//  input string is valid.  Note that this function modifies the input string
//  lptszEmailName.
//
//  Parameters
//  [IN]  lptszEmailName - email string to parse
//  [OUT] patszContacts - array of parsed contact (nickname) names if requested
//  [OUT] pcContacts - number of contact names
//  [OUT] patszOneOffs - array of parsed one-off (email) names if requested
//  [OUT] pcOneOffs - number of one-off names
///////////////////////////////////////////////////////////////////////////////
// It looks like HM allows four possible text delimiters: ' ', ',', ';', '+'
const TCHAR tszSpace[] = TEXT(" ");
const TCHAR tszComma[] = TEXT(",");
const TCHAR tszSemi[] = TEXT(";");
const TCHAR tszPlus[] = TEXT("+");
const TCHAR tszAt[] = TEXT("@");

HRESULT hrParseHMGroupEmail(
    LPTSTR     lptszEmailName,
    LPTSTR **  patszContacts,
    ULONG *    pcContacts,
    LPTSTR **  patszOneOffs,
    ULONG *    pcOneOffs)
{
    HRESULT     hr = S_OK;
    ULONG       cCount = 1;
    ULONG       ul;
    LPTSTR      lptszTemp = lptszEmailName;
    LPTSTR *    atszContacts = NULL;
    LPTSTR *    atszOneOffs = NULL;
    ULONG       cContacts = 0;
    ULONG       cOneOffs = 0;

    Assert( lptszEmailName && (pcContacts || pcOneOffs) );

    // Strip all leading and ending spaces
    TrimSpaces(lptszTemp);

    // Count
    while (*lptszTemp)
    {
        if ( ((*lptszTemp) == (*tszSpace)) ||
             ((*lptszTemp) == (*tszComma)) ||
             ((*lptszTemp) == (*tszSemi)) ||
             ((*lptszTemp) == (*tszPlus)) )
        {
            ++cCount;

            // Increment to next valid name
            ++lptszTemp;
            while ( ((*lptszTemp) == (*tszSpace)) ||
                    ((*lptszTemp) == (*tszComma)) ||
                    ((*lptszTemp) == (*tszSemi)) ||
                    ((*lptszTemp) == (*tszPlus)) )
            {
                ++lptszTemp;
            }
        }
        else
            ++lptszTemp;
    }

    // Create Contacts and One-Offs name pointer arrays
    atszContacts = LocalAlloc(LMEM_ZEROINIT, (cCount * sizeof(LPTSTR)));
    if (!atszContacts)
    {
        hr = E_OUTOFMEMORY;
        goto out;
    }
    atszOneOffs = LocalAlloc(LMEM_ZEROINIT, (cCount * sizeof(LPTSTR)));
    if (!atszOneOffs)
    {
        hr = E_OUTOFMEMORY;
        goto out;
    }

    // Fill the name pointer arrays and counts
    {
        LPTSTR  lptszName = lptszEmailName;
        BOOL    fIsEmail = FALSE;
        
        lptszTemp = lptszName;
        while(*lptszTemp)
        {
            // Determine whether this name is a nickname or email.  I am assuning
            // that all email names will have the '@' character.
            if ((*lptszTemp) == (*tszAt))
                fIsEmail = TRUE;

            if ( ((*lptszTemp) == (*tszSpace)) ||
                 ((*lptszTemp) == (*tszComma)) ||
                 ((*lptszTemp) == (*tszSemi)) ||
                 ((*lptszTemp) == (*tszPlus)) )
            {
                *lptszTemp = '\0';
                ++lptszTemp;

                if (fIsEmail)
                {
                    atszOneOffs[cOneOffs++] = lptszName;
                    Assert(cOneOffs <= cCount);
                    fIsEmail = FALSE;
                }
                else
                {
                    atszContacts[cContacts++] = lptszName;
                    Assert(cContacts <= cCount);
                }

                // Increment to next valid name
                while ( ((*lptszTemp) == (*tszSpace)) ||
                        ((*lptszTemp) == (*tszComma)) ||
                        ((*lptszTemp) == (*tszSemi)) ||
                        ((*lptszTemp) == (*tszPlus)) )
                {
                    ++lptszTemp;
                }

                lptszName = lptszTemp;
            }
            else
                ++lptszTemp;
        }
        // Pick up last item
        if (*lptszName)
        {
            if (fIsEmail)
            {
                atszOneOffs[cOneOffs++] = lptszName;
                Assert(cOneOffs <= cCount);
            }
            else
            {
                atszContacts[cContacts++] = lptszName;
                Assert(cContacts <= cCount);
            }
        }
    }

    // Pass back contact name array if requested
    if (cContacts && pcContacts)
    {
        *pcContacts = cContacts;
    }
    if (patszContacts)
        (*patszContacts) = atszContacts;

    // Pass back one-off name array if requested
    if (cOneOffs && pcOneOffs )
    {
        *pcOneOffs = cOneOffs;
    }
    if (patszOneOffs)
        (*patszOneOffs) = atszOneOffs;

out:

    if ( FAILED(hr) || !patszContacts )
        LocalFreeAndNull((LPVOID *)&atszContacts);

    if ( FAILED(hr) || !patszOneOffs )
        LocalFreeAndNull((LPVOID *)&atszOneOffs);

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  hrCreateGroupMVBin
//
//  Creates either a PR_WAB_DL_ENTRIES or PR_WAB_DL_ONEOFFS MVBin property and
//  adds it to the passed in property array.  
//
//  If the proptag is PR_WAB_DL_ENTRIES then the atszNames array is assumed to
//  contain valid WAB contact nicknames.  The first contact's (mail user) EID
//  with that nickname is added to the MVBin property.  It is assumed that 
//  nicknames are unique (after contact syncing which is performed first) as is
//  required by Hotmail.
//
//  If the proptag is PR_WAB_DL_ONEOFFS then the atszNames array is assumed to
//  contain valid email names.  WAB one-off EIDs are created from these and 
//  added to the MVBin property.
//
//  Parameters
//  [IN] pWabSync
//  [IN] ulPropTag
//  [IN] atszNames - Array of wide char names
//  [IN] cCount - Number of items in above array
//  [IN/OUT] lpPropArray
//  [IN/OUT] pdwLoc - Current lpPropArray index
///////////////////////////////////////////////////////////////////////////////
HRESULT hrCreateGroupMVBin(
    LPWABSYNC    pWabSync,
    ULONG        ulPropTag,
    LPTSTR *     atszNames,
    ULONG        cCount,
    LPSPropValue lpPropArray,
    DWORD *      pdwLoc)
{
    HRESULT hr = S_OK;
    ULONG   ul;

    Assert(atszNames);
    Assert(lpPropArray);
    Assert(pdwLoc);

    // Set up this property as error.  When the MVbin values are added via
    // AddPropToMVPBin() the tag type will change to valid PT_MV_BINARY type.
    lpPropArray[*pdwLoc].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(ulPropTag));
    lpPropArray[*pdwLoc].dwAlignPad = 0;
    lpPropArray[*pdwLoc].Value.MVbin.cValues = 0;
    lpPropArray[*pdwLoc].Value.MVbin.lpbin = NULL;
    
    if (ulPropTag == PR_WAB_DL_ENTRIES)
    {
        // Search for WAB mail users with these nicknames
        for (ul=0; ul<cCount; ul++)
        {
            SPropertyRestriction PropRes;
            SPropValue Prop = {0};
            LPSBinary rgsbEntryIDs = NULL;
            ULONG ulCount = 1;

            // Set up search restriction
            Prop.ulPropTag = PR_NICKNAME;
            Prop.Value.LPSZ = atszNames[ul];
            PropRes.lpProp = &Prop;
            PropRes.relop = RELOP_EQ;
            PropRes.ulPropTag = PR_NICKNAME;

            if (SUCCEEDED(FindRecords(((LPIAB)pWabSync->m_pAB)->lpPropertyStore->hPropertyStore,
	                                  NULL,			// pmbinFolder
                                      0,            // ulFlags
                                      TRUE,         // Always TRUE
                                      &PropRes,     // Propertyrestriction
                                      &ulCount,     // IN: number of matches to find, OUT: number found
                                      &rgsbEntryIDs)))
            {
                // Add EID property
                if (ulCount > 0)
                {
                    if ( FAILED(AddPropToMVPBin(
                            lpPropArray,
                            *pdwLoc,
                            rgsbEntryIDs[0].lpb,
                            rgsbEntryIDs[0].cb,
                            FALSE)) )                   // Don't add duplicates, not
                    {
                        Assert(0);
                    }
                }

                FreeEntryIDs(((LPIAB)pWabSync->m_pAB)->lpPropertyStore->hPropertyStore, ulCount, rgsbEntryIDs);
            }
            else
            {
                // All contacts should be in WAB unless the preceeding mail user contact
                // sync failed.
                DebugTrace(TEXT("hrCreateGroupMVBin - Failed to find HM group contact\n"));
            }
        }
    }
    else if (ulPropTag == PR_WAB_DL_ONEOFFS)
    {        
        for (ul=0; ul<cCount; ul++)
        {
            ULONG       cbEID = 0;
            LPENTRYID   lpEID = NULL;
            LPTSTR      lptszName = NULL;
            LPTSTR      lptszSMTP = TEXT("");
            LPTSTR      lptszEmail = atszNames[ul];
            LPTSTR      lptszTemp = NULL;
            int         nLen = lstrlen(atszNames[ul]) + 1;

            // A WAB DL OneOff must have a valid display name.  Take the first
            // part of the email name for this.
            lptszName = LocalAlloc(LMEM_ZEROINIT, (nLen * sizeof(WCHAR)));
            if (!lptszName)
            {
                hr = E_OUTOFMEMORY;
                goto out;
            }
            lstrcpy(lptszName, lptszEmail);
            lptszTemp = lptszName;
            while ( *lptszTemp &&
                    (*lptszTemp) != (*tszAt) )
            {
                ++lptszTemp;
            }
            (*lptszTemp) = '\0';

            // Creates UNICODE string embedded WAB one-off EID
            if ( SUCCEEDED(CreateWABEntryID(WAB_ONEOFF,
                                            (LPVOID)lptszName,
                                            (LPVOID)lptszSMTP,
                                            (LPVOID)lptszEmail,
                                            0, 0, NULL,
                                            &cbEID,
                                            &lpEID)) )
            {
                if ( FAILED(AddPropToMVPBin(
                        lpPropArray,
                        *pdwLoc,
                        lpEID,
                        cbEID,
                        FALSE)) )                   // Don't add duplicates, not
                {
                    Assert(0);
                }
            }

            LocalFreeAndNull(&lptszName);
        }
    }
    else
    {
        Assert(0);
    }

out:

    ++(*pdwLoc);
    return hr;
}
#endif  // HM_GROUP_SYNCING


///////////////////////////////////////////////////////////////////////////////
//  hrStripInvalidChars
//
//  Helper function to remove disallowed characters.  HM only allows 
//  alphanumeric and '-' and '_' characters in a nickname.  All illegal chars
//  are removed from the string.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT hrStripInvalidChars(LPSTR lpszName)
{
    HRESULT hr = S_OK;
    LPSTR   lpszAddTo = NULL;

    Assert(lpszName);

    lpszAddTo = lpszName;
    while (*lpszName)
    {
        // @review  Currently the look up table only contains 122 characters.  Make
        // it full 256?  How will HM change when it adds intenational suppport?
        if ( ((UCHAR)(*lpszName) < MAX_INVALID_ARRAY_INDEX) && !bInvalidCharArray[*lpszName] )
        {
            *lpszAddTo = *lpszName;
            ++lpszAddTo;
        }
        ++lpszName;
    }
    *lpszAddTo = '\0';

    return hr;
}



// ****************************************************************************************************
//  C   H   O   T   S   Y   N   C          C   L   A   S   S   
//
//  Class to handle the synchronizing of WAB and Hotmail contacts
//

HRESULT     WABSync_Create(LPWABSYNC *ppWabSync)
{
    Assert(ppWabSync);

    *ppWabSync = LocalAlloc(LMEM_ZEROINIT, sizeof(WABSYNC));
   
    // fix up the prop tag array structure to take into account the variable values
    ptaEidSync.aulPropTag[ieid_PR_WAB_HOTMAIL_CONTACTIDS] = PR_WAB_HOTMAIL_CONTACTIDS;
    ptaEidSync.aulPropTag[ieid_PR_WAB_HOTMAIL_SERVERIDS] = PR_WAB_HOTMAIL_SERVERIDS;
    ptaEidSync.aulPropTag[ieid_PR_WAB_HOTMAIL_MODTIMES] = PR_WAB_HOTMAIL_MODTIMES;

    // fix up the other prop tag array structure to take into account the variable values
    ptaEidCSync.aulPropTag[ieidc_PR_WAB_HOTMAIL_CONTACTIDS] = PR_WAB_HOTMAIL_CONTACTIDS;
    ptaEidCSync.aulPropTag[ieidc_PR_WAB_HOTMAIL_SERVERIDS] = PR_WAB_HOTMAIL_SERVERIDS;
    ptaEidCSync.aulPropTag[ieidc_PR_WAB_HOTMAIL_MODTIMES] = PR_WAB_HOTMAIL_MODTIMES;
#ifdef HM_GROUP_SYNCING
    ptaEidCSync.aulPropTag[ieidc_PR_WAB_DL_ONEOFFS] = PR_WAB_DL_ONEOFFS;
#endif

    if (*ppWabSync)
    {
        (*ppWabSync)->vtbl = &vtblIHTTPMAILCALLBACK;
        (*ppWabSync)->m_cRef = 1;
        (*ppWabSync)->m_state = SYNC_STATE_INITIALIZING;
        (*ppWabSync)->m_ixpStatus = IXP_DISCONNECTED;
        ZeroMemory(&(*ppWabSync)->m_rInetServerInfo, sizeof(INETSERVER));
    }
    else
        return E_OUTOFMEMORY;

    return S_OK;
}


void        WABSync_Delete(LPWABSYNC pWabSync)
{
    Assert(pWabSync);

    if (pWabSync->m_pOps)
    {
        WABSync_FreeOps(pWabSync);
        Vector_Delete(pWabSync->m_pOps);
        pWabSync->m_pOps = NULL;
    }

    if (pWabSync->m_pWabItems)
    {
        WABSync_FreeItems(pWabSync);
        Vector_Delete(pWabSync->m_pWabItems);
    }

    if (pWabSync->m_pszAccountId)
        CoTaskMemFree(pWabSync->m_pszAccountId);

    if (pWabSync->m_pAB)
        pWabSync->m_pAB->lpVtbl->Release(pWabSync->m_pAB);

    if (pWabSync->m_pTransport)
        IHTTPMailTransport_Release(pWabSync->m_pTransport);

    if (pWabSync->m_pszRootUrl)
        CoTaskMemFree(pWabSync->m_pszRootUrl);

#ifdef HM_GROUP_SYNCING
    // [PaulHi] If we are ending a mail contact sync, kick off a second pass
    // to synchronize the group contacts.
    // @review - We may want to skip group syncing if an error occurs during the
    // first pass contact syncing.
    if (!pWabSync->m_fSyncGroups && pWabSync->m_hParentWnd)
        PostMessage(pWabSync->m_hParentWnd, WM_USER_SYNCGROUPS, 0, 0L);
#endif

    LocalFree(pWabSync);
}


//----------------------------------------------------------------------
// IUnknown Members
//----------------------------------------------------------------------
HRESULT WABSync_QueryInterface (IHTTPMailCallback __RPC_FAR *lpunkobj,
                                REFIID          riid,
                                LPVOID FAR *    lppUnk)
{
    SCODE       sc;
    LPWABSYNC   lpWabSync = (LPWABSYNC)lpunkobj;

    if (IsEqualGUID(riid, &IID_IUnknown) ||
        IsEqualGUID(riid, &IID_IHTTPMailCallback) ||
        IsEqualGUID(riid, &IID_ITransportCallback))
    {
        sc = S_OK;
    }
    else
    {
		*lppUnk = NULL;	// OLE requires zeroing [out] parameters
		sc = E_NOINTERFACE;
		goto error;
    }

	/* We found the requested interface so increment the reference count.
	 */
	lpWabSync ->m_cRef++;

	*lppUnk = lpunkobj;

	return hrSuccess;

error:
	return ResultFromScode(sc);
}


ULONG WABSync_AddRef(IHTTPMailCallback __RPC_FAR *This)
{
    LPWABSYNC pWabSync = (LPWABSYNC)This;
    return InterlockedIncrement(&pWabSync->m_cRef);
}

ULONG WABSync_Release(IHTTPMailCallback __RPC_FAR *This)
{
    LPWABSYNC pWabSync = (LPWABSYNC)This;
    LONG cRef = InterlockedDecrement(&pWabSync->m_cRef);
    
    Assert(cRef >= 0);

    if (0 == cRef)
        WABSync_Delete(pWabSync);

    return (ULONG)cRef;
}


//----------------------------------------------------------------------
// IHTTPMailCallback Members
//----------------------------------------------------------------------
STDMETHODIMP WABSync_OnTimeout (IHTTPMailCallback __RPC_FAR *This, DWORD *pdwTimeout, IInternetTransport *pTransport)
{
//    LPWABSYNC pWabSync = (LPWABSYNC)This;
    return E_NOTIMPL;
}

STDMETHODIMP WABSync_OnLogonPrompt (IHTTPMailCallback __RPC_FAR *This, LPINETSERVER pInetServer, IInternetTransport *pTransport)
{
    LPWABSYNC pWabSync = (LPWABSYNC)This;
    if (PromptUserForPassword(pInetServer, pWabSync->m_hWnd))
    {
        return S_OK;
    }
    return E_FAIL;
}

STDMETHODIMP_(INT) WABSync_OnPrompt (IHTTPMailCallback __RPC_FAR *This, HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, IInternetTransport *pTransport)
{
//    LPWABSYNC pWabSync = (LPWABSYNC)This;
    return E_NOTIMPL;
}

STDMETHODIMP WABSync_OnStatus (IHTTPMailCallback __RPC_FAR *This, IXPSTATUS ixpstatus, IInternetTransport *pTransport)
{
//    LPWABSYNC pWabSync = (LPWABSYNC)This;
    return E_NOTIMPL;
}

STDMETHODIMP WABSync_OnError (IHTTPMailCallback __RPC_FAR *This, IXPSTATUS ixpstatus, LPIXPRESULT pResult, IInternetTransport *pTransport)
{
//    LPWABSYNC pWabSync = (LPWABSYNC)This;
    return E_NOTIMPL;
}

STDMETHODIMP WABSync_OnCommand (IHTTPMailCallback __RPC_FAR *This, CMDTYPE cmdtype, LPSTR pszLine, HRESULT hrResponse, IInternetTransport *pTransport)
{
//    LPWABSYNC pWabSync = (LPWABSYNC)This;
    return E_NOTIMPL;
}

STDMETHODIMP WABSync_GetParentWindow (IHTTPMailCallback __RPC_FAR *This, HWND *pHwndParent)
{
    LPWABSYNC pWabSync = (LPWABSYNC)This;
    
    *pHwndParent = pWabSync->m_hWnd;
    return S_OK;
}

STDMETHODIMP WABSync_OnResponse (IHTTPMailCallback __RPC_FAR *This, LPHTTPMAILRESPONSE pResponse)
{
    LPWABSYNC pWabSync = (LPWABSYNC)This;
    HRESULT hr = S_OK;
    
    Assert(pWabSync);
    Assert(pResponse);

    if (FAILED(pResponse->rIxpResult.hrResult))
    {
        switch (pResponse->rIxpResult.hrResult)
        {
            case IXP_E_HTTP_INSUFFICIENT_STORAGE:
            case IXP_E_HTTP_ROOT_PROP_NOT_FOUND:
            case IXP_E_HTTP_NOT_IMPLEMENTED:
                WABSync_Abort(pWabSync, pResponse->rIxpResult.hrResult);
                break;
        }
    }

    if (pWabSync->m_fAborted)
        return E_FAIL;

    if (SYNC_STATE_SERVER_CONTACT_DISCOVERY == pWabSync->m_state)
    {
        if (pResponse->command == HTTPMAIL_GETPROP)
            hr = WABSync_HandleContactsRootResponse(pWabSync, pResponse);
        else
            hr = WABSync_HandleIDListResponse(pWabSync, pResponse);
    }    
    else if ((SYNC_STATE_PROCESS_OPS == pWabSync->m_state || SYNC_STATE_PROCESS_MERGED_CONFLICTS == pWabSync->m_state)
                && pWabSync->m_pOps)
    {   
        LPHOTSYNCOP pOp = (LPHOTSYNCOP)Vector_GetItem(pWabSync->m_pOps, 0);
        Assert(pOp);

        if (pOp)
            hr = Syncop_HandleResponse(pOp, pResponse);
        else
            hr = E_FAIL;

        if (FAILED(hr))
            WABSync_AbortOp(pWabSync, hr);
    }
    else
        hr = E_FAIL;

    return hr;
}

#ifdef HM_GROUP_SYNCING
STDMETHODIMP WABSync_Initialize(LPWABSYNC pWabSync, HWND hWnd, IAddrBook *pAB, LPCTSTR pszAccountID, BOOL bSyncGroups)
#else
STDMETHODIMP WABSync_Initialize(LPWABSYNC pWabSync, HWND hWnd, IAddrBook *pAB, LPCTSTR pszAccountID)
#endif
{
    IImnAccountManager2 *lpAcctMgr = NULL;
    IImnAccount        *pAccount = NULL;
    HRESULT             hr;
    char                szAcctName[CCHMAX_ACCOUNT_NAME+1];
    DWORD               ccb = CCHMAX_ACCOUNT_NAME;
    LPSTR               pszUserAgent = NULL;
#ifdef HM_GROUP_SYNCING
    LPPTGDATA           lpPTGData=GetThreadStoragePointer();
#endif

    Assert(pWabSync);
    Assert(pAB);

    pWabSync->m_hParentWnd = hWnd;
    pWabSync->m_pTransport = NULL;
    pWabSync->m_fSkipped = FALSE;
#ifdef HM_GROUP_SYNCING
    pWabSync->m_fSyncGroups = bSyncGroups;
#endif

    pWabSync->m_hWnd =  CreateDialogParam (hinstMapiX, MAKEINTRESOURCE (iddSyncProgress),
                        pWabSync->m_hParentWnd, (DLGPROC)SyncProgressDlgProc, (LPARAM)pWabSync);


    if (!pWabSync->m_hWnd)
    {
        hr = E_FAIL;
        goto exit;
    }
    ShowWindow(pWabSync->m_hWnd, SW_SHOW);
    if (pWabSync->m_hParentWnd)
        EnableWindow (pWabSync->m_hParentWnd, FALSE);

    WABSync_BeginSynchronize(pWabSync);
    
    InitWABUserAgent(TRUE);

    if (FAILED(hr = InitAccountManager(NULL, &lpAcctMgr, NULL)))
        goto exit;

    if (pszAccountID == NULL)
    {
        if (FAILED(hr = _FindHTTPMailAccount(pWabSync->m_hWnd, lpAcctMgr, szAcctName, CCHMAX_ACCOUNT_NAME)))
            goto exit;
#ifdef HM_GROUP_SYNCING
        // [PaulHi] We don't want the user to have to choose the HM account twice (once for contact and
        // then for group syncing).  So save the account ID here.
        LocalFreeAndNull(&(lpPTGData->lptszHMAccountId));
        lpPTGData->lptszHMAccountId = ConvertAtoW(szAcctName);
#endif
    }
    else
    {
        LPSTR lpAcctA = ConvertWtoA((LPWSTR)pszAccountID);
        lstrcpyA(szAcctName, lpAcctA);
        LocalFreeAndNull(&lpAcctA);
    }

    // Get the account
    hr = lpAcctMgr->lpVtbl->FindAccount(lpAcctMgr, AP_ACCOUNT_ID, szAcctName, &pAccount);
    if (FAILED(hr))
    {
        hr = lpAcctMgr->lpVtbl->FindAccount(lpAcctMgr, AP_ACCOUNT_NAME, szAcctName, &pAccount);
        if (FAILED(hr))
            goto exit;
    }

    if (SUCCEEDED(hr = pAccount->lpVtbl->GetProp(pAccount, AP_ACCOUNT_ID, szAcctName, &ccb)))
        pWabSync->m_pszAccountId = _StrDup(szAcctName);

    pWabSync->m_pAB = pAB;
    
    pWabSync->m_pAB->lpVtbl->AddRef(pWabSync->m_pAB);

    // Create the Transport
    hr = CoCreateInstance(  &CLSID_IHTTPMailTransport, 
                            NULL, 
                            CLSCTX_INPROC_SERVER,
                            &IID_IHTTPMailTransport, 
                            (LPVOID *)&(pWabSync->m_pTransport));
    
    if (FAILED(hr) || !pWabSync->m_pTransport)
        goto exit;

    pszUserAgent = GetWABUserAgentString();
    if (!pszUserAgent)
        goto exit;

    // Initialize the transport
    hr = IHTTPMailTransport_InitNew(pWabSync->m_pTransport, pszUserAgent, (LogTransactions(pWabSync) ? "C:\\WabSync.log" : NULL),(IHTTPMailCallback*)pWabSync);
    if (FAILED(hr))
        goto exit;

    // Create the SERVERINFO
    hr = IHTTPMailTransport_InetServerFromAccount(pWabSync->m_pTransport, pAccount, &pWabSync->m_rInetServerInfo);
    if (FAILED(hr))
        goto exit;
    
    lstrcpyA(pWabSync->m_szLoginName, pWabSync->m_rInetServerInfo.szUserName);

    // Check if I can connect
    hr = IHTTPMailTransport_Connect(pWabSync->m_pTransport,&pWabSync->m_rInetServerInfo,TRUE,TRUE);
    if (FAILED(hr))
        goto exit;

    hr = WABSync_LoadLastModInfo(pWabSync);
    if (FAILED(hr))
        goto exit;

    hr = WABSync_BuildWabContactList(pWabSync);
    if (FAILED(hr))
        goto exit;

    WABSync_NextState(pWabSync);

exit:
    if (pszUserAgent)
        LocalFree(pszUserAgent);

    if (FAILED(hr))
    {
        if (pWabSync->m_pTransport)
            IHTTPMailTransport_Release(pWabSync->m_pTransport);
        pWabSync->m_pTransport = NULL;
        WABSync_Abort(pWabSync, hr);

        if (pWabSync->m_pAB)
        {
            pWabSync->m_pAB->lpVtbl->Release(pWabSync->m_pAB);
            pWabSync->m_pAB = NULL;
        }
    }

    // don't release the lpAcctMgr since the WAB maintains a global reference.
        
    if (pAccount)
        pAccount->lpVtbl->Release(pAccount);

    return hr;
}


//
//    CHotSync::Abort
//
//    Blow away all of the pending items in the queue.
//
STDMETHODIMP WABSync_Abort(LPWABSYNC pWabSync, HRESULT hr)
{
    LPHOTSYNCOP         pOp;
    TCHAR   szMsg[512], szCaption[255], szRes[512];
    
    Assert(pWabSync);
    
    pWabSync->m_fAborted = TRUE;

    if (pWabSync->m_pOps)
    {
        DWORD   dwIndex, cOps = Vector_GetLength(pWabSync->m_pOps);

        for (dwIndex = 0; dwIndex < cOps; ++dwIndex)
        {
            pOp = (LPHOTSYNCOP)Vector_GetItem(pWabSync->m_pOps, 0);

            if (pOp)
            {
                Syncop_Abort(pOp);
                Syncop_Delete(pOp);
            }

            Vector_RemoveItem(pWabSync->m_pOps, 0);
        }
    }

    if (FAILED(hr) && hr != E_UserCancel)
    {
        switch (hr)
        {
            case IXP_E_HTTP_INSUFFICIENT_STORAGE:
                LoadString(hinstMapiX, idsOutOfServerSpace, szMsg, CharSizeOf(szMsg));
                break;

            case IXP_E_HTTP_ROOT_PROP_NOT_FOUND:
            case IXP_E_HTTP_NOT_IMPLEMENTED:
                LoadString(hinstMapiX, idsSyncNotHandled, szMsg, CharSizeOf(szMsg));
                break;
            
            default:
                LoadString(hinstMapiX, idsSyncAborted, szRes, CharSizeOf(szRes));
                wsprintf(szMsg, szRes, hr);
                break;
        }
        LoadString(hinstMapiX, idsSyncError, szCaption, CharSizeOf(szCaption));
        MessageBox(pWabSync->m_hWnd, szMsg, szCaption, MB_ICONEXCLAMATION | MB_OK);
    }

    WABSync_FinishSynchronize(pWabSync, hr);

    return S_OK;
}

//
//    CHotSync::AbortOp
//
//    Abort the current operation (for some reason)
//
STDMETHODIMP WABSync_AbortOp(LPWABSYNC pWabSync, HRESULT hr)
{
    LPHOTSYNCOP         pOp;
    
    Assert(pWabSync);
    
    pWabSync->m_cAborts++;

    // do something with the knowledge of this abort (log to whatever)
    if (!WABSync_NextOp(pWabSync, TRUE))
        WABSync_NextState(pWabSync);

    return S_OK;
}

int __cdecl CompareOpTypes(const void* lpvA, const void* lpvB)
{
    LPHOTSYNCOP pSyncOpA;
    LPHOTSYNCOP pSyncOpB;

    pSyncOpA = *((LPHOTSYNCOP*)lpvA);
    pSyncOpB = *((LPHOTSYNCOP*)lpvB);

    return (pSyncOpA->m_bOpType - pSyncOpB->m_bOpType);
}


STDMETHODIMP WABSync_RequestContactsRootProperty(LPWABSYNC pWabSync)
{
    HRESULT hr;

    Assert(pWabSync);
    Assert(pWabSync->m_pTransport);

    hr = pWabSync->m_pTransport->lpVtbl->GetProperty(pWabSync->m_pTransport, HTTPMAIL_PROP_CONTACTS, &pWabSync->m_pszRootUrl);
    
    if(hr == E_PENDING)
        hr = S_OK;
    else if (SUCCEEDED(hr) && pWabSync->m_pszRootUrl)
        WABSync_RequestServerIDList(pWabSync);
    else
        WABSync_Abort(pWabSync, hr);    //something went terribly wrong

    return S_OK;
}

STDMETHODIMP WABSync_HandleContactsRootResponse(LPWABSYNC pWabSync, LPHTTPMAILRESPONSE pResponse)
{
    Assert(pWabSync);

    pWabSync->m_pszRootUrl = NULL;
    if (SUCCEEDED(pResponse->rIxpResult.hrResult))
    {
        if (pResponse->rGetPropInfo.type == HTTPMAIL_PROP_CONTACTS)
        {
            pWabSync->m_pszRootUrl = pResponse->rGetPropInfo.pszProp;
            pResponse->rGetPropInfo.pszProp = NULL;
        }            
    }

    if (pWabSync->m_pszRootUrl)
        WABSync_RequestServerIDList(pWabSync);
    else
        WABSync_Abort(pWabSync, pResponse->rIxpResult.hrResult);


    return S_OK;
}

STDMETHODIMP WABSync_RequestServerIDList(LPWABSYNC pWabSync)
{
    HRESULT             hr;

    Assert(pWabSync);
    Assert(pWabSync->m_pTransport);
    Assert(pWabSync->m_pszRootUrl && *pWabSync->m_pszRootUrl);

    WABSync_Progress(pWabSync, idsSyncGathering, -1);

    hr = pWabSync->m_pTransport->lpVtbl->ListContactInfos(pWabSync->m_pTransport, pWabSync->m_pszRootUrl, 0);

    if FAILED(hr)
        WABSync_Abort(pWabSync, hr);

    return hr;
}

STDMETHODIMP WABSync_FindContactByServerId(LPWABSYNC pWabSync, LPSTR pszServerId, LPWABCONTACTINFO *ppContact, DWORD *pdwIndex)
{
    DWORD               cItems, dwIndex;
    LPWABCONTACTINFO    pContact;

    Assert(pWabSync);
    Assert(pWabSync->m_pWabItems);

    cItems = Vector_GetLength(pWabSync->m_pWabItems);

    for (dwIndex = 0; dwIndex < cItems; dwIndex++)
    {
        pContact = (LPWABCONTACTINFO)Vector_GetItem(pWabSync->m_pWabItems, dwIndex);

        if (pContact && pContact->pszHotmailId && lstrcmpA(pContact->pszHotmailId, pszServerId) == 0)
        {
            *ppContact = pContact;
            *pdwIndex = dwIndex;
            return S_OK;
        }
    }
    return E_FAIL;
}
 
STDMETHODIMP WABSync_HandleIDListResponse(LPWABSYNC pWabSync, LPHTTPMAILRESPONSE pResponse)
{
    HRESULT hr;
    LPHOTSYNCOP      pNewOp;

    if (SUCCEEDED(pResponse->rIxpResult.hrResult))
    {
        ULONG   cItems = pResponse->rContactInfoList.cContactInfo;
        LPHTTPCONTACTINFO prgId = pResponse->rContactInfoList.prgContactInfo;
        DWORD   dwItem;

        for (dwItem = 0; dwItem < cItems; dwItem++)
        {
#ifdef HM_GROUP_SYNCING
            // [PaulHi] We synchronize contacts and groups separately
            if ( (!pWabSync->m_fSyncGroups && (prgId[dwItem].tyContact == HTTPMAIL_CT_CONTACT)) ||
                 (pWabSync->m_fSyncGroups && (prgId[dwItem].tyContact == HTTPMAIL_CT_GROUP)) )
#else
            if (HTTPMAIL_CT_GROUP == prgId[dwItem].tyContact)
            {
                // ignore groups for now
                continue;
            }
            else
#endif
            {
                LPWABCONTACTINFO pContact;
                DWORD            dwIndex;
                FILETIME         ftModTime = {0,0};

                pNewOp = NULL;
                // [PaulHi] 12/17/98  Raid #61548
                // The Exchange server will pass in contacts with no file mod time, 
                // which really hoses the sync process.  We could just skip these 
                // contacts but to keep things simple we abort the sync process here.
                // Note that HotMail servers work correctly.
                //
                // @todo [PaulHi]
                // After IE5 ship of WAB, fix this by creating a conflict op code and
                // let user straighten out any differences.  Also time stamp so future
                // syncs will work.
                hr = iso8601ToFileTime(prgId[dwItem].pszModified, &ftModTime, TRUE, TRUE);
                if (FAILED(hr))
                {
                    WABSync_Abort(pWabSync, hr);
                    return hr;
                }

                if (SUCCEEDED(WABSync_FindContactByServerId(pWabSync, prgId[dwItem].pszId, &pContact, &dwIndex)))
                {
                    if (pContact->fDelete)
                    {
                        // it has been deleted from the wab.  Now delete it from the server.
                        pContact->pszHotmailHref = prgId[dwItem].pszHref;
                        prgId[dwItem].pszHref = NULL;

                        pContact->pszModHotmail = prgId[dwItem].pszModified;
                        prgId[dwItem].pszModified = NULL;

                        pNewOp = Syncop_CreateServerDelete(pContact);
                    }
                    else
                    {
                        LONG lLocalCompare = CompareFileTime(&pWabSync->m_ftLastSync, &pContact->ftModWab);
                        LONG lServerCompare = pContact->pszModHotmail && prgId[dwItem].pszModified ? lstrcmpA(pContact->pszModHotmail, prgId[dwItem].pszModified) : -1;

                        SafeCoMemFree(pContact->pszHotmailHref);
                        pContact->pszHotmailHref = prgId[dwItem].pszHref;
                        prgId[dwItem].pszHref = NULL;

                        SafeCoMemFree(pContact->pszHotmailId);
                        pContact->pszHotmailId = prgId[dwItem].pszId;
                        prgId[dwItem].pszId = NULL;

                        SafeCoMemFree(pContact->pszModHotmail);
                        pContact->pszModHotmail = prgId[dwItem].pszModified;
                        prgId[dwItem].pszModified = NULL;
                    
                        if (lLocalCompare >= 0)
                        {
                            // hasn't changed locally since last sync
                        
                            if (lServerCompare)
                            {
                                // has changed on server, just update here
                                pNewOp = Syncop_CreateClientChange(pContact);
                                Assert(pNewOp);
                                Syncop_SetServerContactInfo(pNewOp, pContact, &prgId[dwItem]);
                            }
                            else
                            {
                                // hasn't changed anywhere.  do nothing.
                                WABContact_Delete(pContact);
                                pContact = NULL;
                            }
                        }   
                        else 
                        {
                            // has changed locally.

                            if (lServerCompare)
                            {
                                // has changed on server, CONFLICT
                                pNewOp = Syncop_CreateConflict(pContact);
                                Assert(pNewOp);
                                Syncop_SetServerContactInfo(pNewOp, pContact, &prgId[dwItem]);
                            }
                            else
                            {
                                // Local change only, upload changes
                                pNewOp = Syncop_CreateServerChange(pContact);
                                Assert(pNewOp);
                                Syncop_SetServerContactInfo(pNewOp, pContact, &prgId[dwItem]);
                            }
                        }
                    }
                    
                    //remove the contact from the list of local contacts
                    Vector_RemoveItem(pWabSync->m_pWabItems, dwIndex);   
                }
                else
                {
                    // its not in the WAB, we need to add it there.
                    pContact = LocalAlloc(LMEM_ZEROINIT, sizeof(WABCONTACTINFO));
                    Assert(pContact);

                    if (pContact)
                    {
                        pContact->pszHotmailHref = prgId[dwItem].pszHref;
                        prgId[dwItem].pszHref = NULL;

                        pContact->pszHotmailId = prgId[dwItem].pszId;
                        prgId[dwItem].pszId = NULL;

                        pContact->pszModHotmail = prgId[dwItem].pszModified;
                        prgId[dwItem].pszModified = NULL;

                        pNewOp = Syncop_CreateClientAdd(pContact);
                        Assert(pNewOp);
                        Syncop_SetServerContactInfo(pNewOp, pContact, &prgId[dwItem]);
                    }
                }

                if (pNewOp)
                {
                    Syncop_Init(pNewOp, (IHTTPMailCallback *)pWabSync, pWabSync->m_pTransport);
                    hr = Vector_AddItem(pWabSync->m_pOps, pNewOp);
                }
                else
                {
                    if (pContact)
                        WABContact_Delete(pContact);
                }
            }
        }


        if (pResponse->fDone)
        {
            //everything left in the contact list needs to either
            //be added to the server or deleted locally.
            LONG                cItems, dwIndex;
            LPWABCONTACTINFO    pContact;

            Assert(pWabSync->m_pWabItems);

            cItems = Vector_GetLength(pWabSync->m_pWabItems);

            if (cItems > 0)
            {
                for (dwIndex = cItems - 1; dwIndex >= 0; dwIndex--)
                {
                    pNewOp = NULL;
                    pContact = (LPWABCONTACTINFO)Vector_GetItem(pWabSync->m_pWabItems, dwIndex);

                    if (pContact && pContact->pszHotmailId)
                    {
                        if (pContact->fDelete)
                        {
                            TCHAR   tszServerId[MAX_PATH];
                            TCHAR   tszKey[MAX_PATH];
                            HKEY    hkey;
                            // now that the delete has completed, delete the tombstone from the registry.
                            hr = hrMakeContactId(
                                tszServerId,
                                MAX_PATH,
                                ((LPIAB)(pWabSync->m_pAB))->szProfileID,
                                pWabSync->m_pszAccountId,
                                pWabSync->m_szLoginName);
                            if (FAILED(hr))
                                return hr;
                            wsprintf(tszKey, TEXT("%s%s"), g_lpszSyncKey, tszServerId);

                            if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, tszKey, 0, KEY_SET_VALUE, &hkey))
                            {
                                LPTSTR lpKey =
                                    ConvertAtoW(pContact->pszHotmailId);
                                RegDeleteValue(hkey, lpKey);
                                LocalFreeAndNull(&lpKey);
                                RegCloseKey(hkey);
                            }
                        }
                        else
                        {
                            //needs to be deleted locally
                            pNewOp = Syncop_CreateClientDelete(pContact);
                        }
                    }
                    else if (pContact)
                    {
                        //needs to be added remotely
                        pNewOp = Syncop_CreateServerAdd(pContact);
                    }

                    if (pNewOp)
                    {
                        //remove the contact from the list of local contacts
                        Vector_RemoveItem(pWabSync->m_pWabItems, dwIndex);   
                        Syncop_Init(pNewOp, (IHTTPMailCallback *)pWabSync, pWabSync->m_pTransport);
                        hr = Vector_AddItem(pWabSync->m_pOps, pNewOp);
                    }
                }

            }

            WABSync_MergeAddsToConflicts(pWabSync);

            pWabSync->m_cTotalOps = Vector_GetLength(pWabSync->m_pOps);
            
            Vector_Sort(pWabSync->m_pOps, CompareOpTypes); 

            //Now go on to handling the operations
            WABSync_NextState(pWabSync);
        }
    }
    else
        WABSync_Abort(pWabSync, pResponse->rIxpResult.hrResult);

    return S_OK;
}

STDMETHODIMP WABSync_OperationCompleted(LPWABSYNC pWabSync, LPHOTSYNCOP pOp)
{
    Assert(pWabSync->m_pOps);
    Assert(pOp == Vector_GetItem(pWabSync->m_pOps, 0));  //completing op should be first op in the list

    Syncop_Delete(pOp);
    Vector_RemoveItem(pWabSync->m_pOps, 0);

    // get the next operation and start it running.
    // if there are no more operations, go to the next state
    pOp = (LPHOTSYNCOP)Vector_GetItem(pWabSync->m_pOps, 0);
    if (pOp)
        Syncop_Begin(pOp);
    else
        WABSync_NextState(pWabSync);

    return S_OK;
}


STDMETHODIMP WABSync_BeginSynchronize(LPWABSYNC pWabSync)
{
    //Keep a reference to ourself while the UI is shown
    WABSync_AddRef((IHTTPMailCallback *)pWabSync); 

    // begin ui
    
    return S_OK;
}

STDMETHODIMP WABSync_FinishSynchronize(LPWABSYNC pWabSync, HRESULT hr)
{
    // if there were any failures or the user didn't resolve all of the 
    // conflicts, then don't update the mod info so we have to do it again.
#ifdef HM_GROUP_SYNCING
    // [PaulHi]  Don't store the current mod time until the synchronization
    // process is completely through, meaning that we are ending the second
    // group contact syncing pass
    if (SUCCEEDED(hr) && !pWabSync->m_fSkipped && pWabSync->m_fSyncGroups)
#else
    if (SUCCEEDED(hr) && !pWabSync->m_fSkipped)
#endif
        WABSync_SaveCurrentModInfo(pWabSync);
    else if (!pWabSync->m_fAborted && FAILED(hr))
    {
        TCHAR   szMsg[512], szCaption[255];

        LoadString(hinstMapiX, idsSyncFailed, szMsg, CharSizeOf(szMsg));
        LoadString(hinstMapiX, idsSyncError, szCaption, CharSizeOf(szCaption));
        
        MessageBox(pWabSync->m_hWnd, szMsg, szCaption, MB_ICONEXCLAMATION | MB_OK);
    }

    if (pWabSync->m_pTransport)
    {
        IHTTPMailTransport_Release(pWabSync->m_pTransport);
        pWabSync->m_pTransport = NULL;
    }

    if (pWabSync->m_hWnd)
    {
        if (pWabSync->m_hParentWnd)
            EnableWindow (pWabSync->m_hParentWnd, TRUE);

        DestroyWindow(pWabSync->m_hWnd);
        pWabSync->m_hWnd = NULL;
    }
    InitWABUserAgent(FALSE);

    WABSync_Release((IHTTPMailCallback *)pWabSync);
 
    return S_OK;  
}


void    WABSync_CheckForLocalDeletions(LPWABSYNC pWabSync)
{
    TCHAR   tszKey[MAX_PATH], tszId[MAX_PATH];
    TCHAR   tszServerId[MAX_PATH];
    DWORD   dwType = 0;
    DWORD   dwValue = 0;
    HKEY    hkey = NULL;
    DWORD   dwSize;
    HRESULT hr = E_FAIL;
    DWORD   cRecords, i, cb, lResult;

    Assert(pWabSync);
    Assert(*pWabSync->m_szLoginName);

    // [PaulHi]  Assemble the contact ID string
    if ( FAILED(hrMakeContactId(
        tszServerId,
        MAX_PATH,
        ((LPIAB)(pWabSync->m_pAB))->szProfileID,
        pWabSync->m_pszAccountId,
        pWabSync->m_szLoginName)) )
    {
        return;
    }
    wsprintf(tszKey,  TEXT("%s%s"), g_lpszSyncKey, tszServerId);

    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, tszKey, 0, KEY_READ, &hkey))
    {
        if (ERROR_SUCCESS == RegQueryInfoKey(hkey, NULL, NULL, 0, NULL, NULL, NULL, &cRecords, NULL, NULL, NULL, NULL) &&
            cRecords > 0)
        {
            // Start Enumerating the keys
            for (i = 0; i < cRecords; i++)
            {
                // Enumerate Friendly Names
                cb = CharSizeOf(tszId);
                lResult = RegEnumValue(hkey, i, tszId, &cb, 0, NULL, NULL, NULL);

                if (ERROR_SUCCESS == lResult && *tszId)
                {
                    WABCONTACTINFO *lpWCI;

                    lpWCI = LocalAlloc(LMEM_ZEROINIT, sizeof(WABCONTACTINFO));

                    if (!lpWCI)
                    {
                        hr = E_OUTOFMEMORY;
                        DebugPrintError(( TEXT("WABCONTACTINFO Alloc Failed\n")));
                        goto out;
                    }
                    
                    lpWCI->fDelete = TRUE;

                    {
                        LPSTR lpID = 
                            ConvertWtoA(tszId);
                        lpWCI->pszHotmailId = _StrDup(lpID);
                        LocalFreeAndNull(&lpID);
                    }
                    if (FAILED(Vector_AddItem(pWabSync->m_pWabItems, lpWCI)))
                        goto out;

                }
            }        

        }
out:
        RegCloseKey(hkey);
    }

        
}

STDMETHODIMP WABSync_BuildWabContactList(LPWABSYNC pWabSync)
{
    HRESULT hr = S_OK;
    ULONG   ulObjType;
    LPENTRYID   pEntryID = NULL;
    ULONG       cbEntryID = 0;
    LPABCONT    lpContainer = NULL;
    ULONG       ulObjectType;
    LPMAPITABLE lpABTable =  NULL;
    LPSRowSet   lpRowAB =   NULL;
	int cNumRows = 0;
    int nRows=0;

    Assert(pWabSync->m_pAB);

    Vector_Create(&pWabSync->m_pOps);
    if (pWabSync->m_pOps == NULL)
    {
        WABSync_Abort(pWabSync, E_OUTOFMEMORY);

        return E_OUTOFMEMORY;
    }

    Vector_Create(&pWabSync->m_pWabItems);
    if (pWabSync->m_pWabItems == NULL)
    {
        WABSync_Abort(pWabSync, E_OUTOFMEMORY);

        return E_OUTOFMEMORY;
    }

    WABSync_CheckForLocalDeletions(pWabSync);

    if (HR_FAILED(hr = pWabSync->m_pAB->lpVtbl->GetPAB(pWabSync->m_pAB, &cbEntryID, &pEntryID)))
    {
        DebugPrintError(( TEXT("GetPAB Failed\n")));
        goto out;
    }
   
    hr = pWabSync->m_pAB->lpVtbl->OpenEntry(pWabSync->m_pAB, cbEntryID,     // size of EntryID to open
                                                pEntryID,     // EntryID to open
                                                NULL,         // interface
                                                0,            // flags
                                                &ulObjType,
                                                (LPUNKNOWN *)&lpContainer);

	MAPIFreeBuffer(pEntryID);

	pEntryID = NULL;
    
    if (HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("OpenEntry Failed\n")));
        goto out;
    }

    if (HR_FAILED(hr = lpContainer->lpVtbl->GetContentsTable(lpContainer, MAPI_UNICODE | WAB_PROFILE_CONTENTS, &lpABTable)))
    {
        DebugPrintError(( TEXT("GetContentsTable Failed\n")));
        goto out;
    }

	hr = lpABTable->lpVtbl->SetColumns(lpABTable, (LPSPropTagArray)&ptaEidSync, 0 );

    if(HR_FAILED(hr))
        goto out;

    // Reset to the beginning of the table
    //
	hr = lpABTable->lpVtbl->SeekRow(lpABTable, BOOKMARK_BEGINNING, 0, NULL );

    if(HR_FAILED(hr))
        goto out;

    // Read all the rows of the table one by one
    //
	do {

        hr = lpABTable->lpVtbl->QueryRows(lpABTable, 1, 0, &lpRowAB);

        if(HR_FAILED(hr))
            break;

        if(lpRowAB)
        {
            cNumRows = lpRowAB->cRows;

            if (cNumRows)
            {
                LPTSTR lpsz = lpRowAB->aRow[0].lpProps[ieid_PR_DISPLAY_NAME].Value.LPSZ;
                LPENTRYID lpEID = (LPENTRYID) lpRowAB->aRow[0].lpProps[ieid_PR_ENTRYID].Value.bin.lpb;
                ULONG cbEID = lpRowAB->aRow[0].lpProps[ieid_PR_ENTRYID].Value.bin.cb;
                
                //
                // There are 2 kinds of objects - the MAPI_MAILUSER contact object
                // and the MAPI_DISTLIST contact object
                //
#ifdef HM_GROUP_SYNCING
                if( (!pWabSync->m_fSyncGroups && (lpRowAB->aRow[0].lpProps[ieid_PR_OBJECT_TYPE].Value.l == MAPI_MAILUSER)) ||
                    (pWabSync->m_fSyncGroups && (lpRowAB->aRow[0].lpProps[ieid_PR_OBJECT_TYPE].Value.l == MAPI_DISTLIST)) )
#else
                // Only consider MAILUSER objects
                if (lpRowAB->aRow[0].lpProps[ieid_PR_OBJECT_TYPE].Value.l == MAPI_MAILUSER)
#endif
                {
                    WABCONTACTINFO *lpWCI;
                    HTTPCONTACTINFO hci;

                    lpWCI = LocalAlloc(LMEM_ZEROINIT, sizeof(WABCONTACTINFO));

                    if (!lpWCI)
                    {
                        hr = E_OUTOFMEMORY;
                        DebugPrintError(( TEXT("WABCONTACTINFO Alloc Failed\n")));
                        goto out;
                    }

                    lpWCI->lpEID = LocalAlloc(LMEM_ZEROINIT, cbEID);

                    if (!lpWCI->lpEID)
                    {
                        hr = E_OUTOFMEMORY;
                        DebugPrintError(( TEXT("WABCONTACTINFO.ENTRYID Alloc Failed\n")));
                        goto out;
                    }

                    lpWCI->cbEID = cbEID;
                    CopyMemory(lpWCI->lpEID, lpEID, cbEID);
                    
                    lpWCI->ftModWab = lpRowAB->aRow[0].lpProps[ieid_PR_LAST_MODIFICATION_TIME].Value.ft;
                    
                    lpWCI->pszHotmailId = NULL;
                    lpWCI->pszModHotmail = NULL;
                    
                    if (SUCCEEDED(ContactInfo_LoadFromWAB(pWabSync, &hci, lpWCI, lpEID, cbEID)))
                    {
                        lpWCI->pszHotmailId = _StrDup(hci.pszId);
                        lpWCI->pszModHotmail = _StrDup(hci.pszModified);
                        ContactInfo_Free(&hci);
                    }

                    // search the multi value list of longs for the proper server id.  If found,
                    // then get the appropriate hotmail id and mod id.

                    if (FAILED(Vector_AddItem(pWabSync->m_pWabItems, lpWCI)))
                        goto out;
                }
		    }
		    FreeProws(lpRowAB );		
        }

	}while ( SUCCEEDED(hr) && cNumRows && lpRowAB)  ;

    
out:
    if (HR_FAILED(hr))
    {
        if (pWabSync->m_pWabItems)
            WABSync_FreeItems(pWabSync);
        if (lpContainer)
            lpContainer->lpVtbl->Release(lpContainer);
        if (lpABTable)
            lpABTable->lpVtbl->Release(lpABTable);
    }


    return hr;
}


HRESULT WABSync_LoadLastModInfo(LPWABSYNC pWabSync)
{
    TCHAR szKey[MAX_PATH];
    DWORD dwType = 0;
    DWORD dwValue = 0;
    HKEY hKey = NULL;
    DWORD dwSize;
    HRESULT hr = E_FAIL;
    FILETIME    ftValue;
    
    Assert(pWabSync);
    Assert(*pWabSync->m_szLoginName);

    lstrcpy(szKey, g_lpszSyncKey);
#ifndef UNICODE
    lstrcat(szKey, pWabSync->m_szLoginName);
#else
    {
        LPTSTR lpName = ConvertAtoW(pWabSync->m_szLoginName);
        lstrcat(szKey, lpName);
        LocalFreeAndNull(&lpName);
    }
#endif

    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szKey, 0, KEY_READ, &hKey))
    {
        dwSize = sizeof(DWORD);
        hr = RegQueryValueEx( hKey,  TEXT("Server ID"), NULL, &dwType, (LPBYTE) &dwValue, &dwSize);
        if (dwValue && ERROR_SUCCESS == hr)
        {
            pWabSync->m_dwServerID = dwValue;
        }
        else
            goto fail;

        dwSize = sizeof(FILETIME);
        if (ERROR_SUCCESS == (hr = RegQueryValueEx( hKey,  TEXT("Server Last Sync"), NULL, &dwType, (LPBYTE) &ftValue, &dwSize)))
        {
            pWabSync->m_ftLastSync = ftValue;
        }
        else
            goto fail;
    }
    else    
    {
        // the key for this user account isn't there.  
        // create a new one and return default values.

        // a random number would be nice here, instead we will
        // use the low DWORD of a date time....
        GetSystemTimeAsFileTime(&ftValue);
        pWabSync->m_dwServerID = ftValue.dwLowDateTime;

        // NULL filetime since we haven't synced yet, everything is after the last sync
        ZeroMemory(&pWabSync->m_ftLastSync, sizeof(FILETIME));

        hr = WABSync_SaveCurrentModInfo(pWabSync);
    }

fail:
    if (hKey)
        RegCloseKey(hKey);

    return hr;
}


HRESULT      WABSync_SaveCurrentModInfo(LPWABSYNC pWabSync)
{
    TCHAR szKey[MAX_PATH];
    HKEY hKey = NULL;
    HRESULT hr = E_FAIL;
    
    Assert(pWabSync);
    Assert(*pWabSync->m_szLoginName);

    lstrcpy(szKey, g_lpszSyncKey);

    {
        LPTSTR lpName = ConvertAtoW(pWabSync->m_szLoginName);
        lstrcat(szKey, lpName);
        LocalFreeAndNull(&lpName);
    }

    
    if(ERROR_SUCCESS == ( hr = RegCreateKey(HKEY_CURRENT_USER, szKey, &hKey)))
    {
        GetSystemTimeAsFileTime(&pWabSync->m_ftLastSync);

        hr = RegSetValueEx( hKey,  TEXT("Server ID"), 0, REG_DWORD, (BYTE *)&pWabSync->m_dwServerID, sizeof(DWORD));
        hr = RegSetValueEx( hKey,  TEXT("Server Last Sync"), 0, REG_BINARY, (BYTE *)&pWabSync->m_ftLastSync, sizeof(FILETIME));
    
        RegCloseKey(hKey);
    }
    
    return hr;
}

void WABSync_Progress(LPWABSYNC pWabSync, DWORD dwResId, DWORD dwCount)
{
    TCHAR   szRes[MAX_PATH], szMsg[MAX_PATH];
    HWND    hwndText;

    LoadString(hinstMapiX, dwResId, szRes, CharSizeOf(szRes));
    if (dwCount != -1)
        wsprintf(szMsg, szRes, dwCount);
    else
        lstrcpy(szMsg, szRes);

    hwndText = GetDlgItem(pWabSync->m_hWnd, IDC_SYNC_MSG);
    if (hwndText)
    {
        SetWindowText(hwndText, szMsg);
    }

    SendDlgItemMessage(pWabSync->m_hWnd, IDC_SYNC_PROGBAR, PBM_SETRANGE, 0, MAKELPARAM(0, pWabSync->m_cTotalOps));
    SendDlgItemMessage(pWabSync->m_hWnd, IDC_SYNC_PROGBAR, PBM_SETPOS, pWabSync->m_cTotalOps - dwCount, 0);
}

void    WABSync_NextState(LPWABSYNC pWabSync)
{
    PostMessage(pWabSync->m_hWnd, WM_SYNC_NEXTSTATE, 0, (LPARAM)pWabSync);
}

void    _WABSync_NextState(LPWABSYNC pWabSync)
{
    HRESULT hr;

    Assert(pWabSync);

    pWabSync->m_state++;

    switch(pWabSync->m_state)
    {
        case SYNC_STATE_SERVER_CONTACT_DISCOVERY:
            WABSync_Progress(pWabSync, idsSyncConnecting, -1);
            hr = WABSync_RequestContactsRootProperty(pWabSync);
            break;

        case SYNC_STATE_PROCESS_OPS:
            WABSync_Progress(pWabSync, idsSyncSynchronizing, Vector_GetLength(pWabSync->m_pOps));
            if (pWabSync->m_pOps && Vector_GetLength(pWabSync->m_pOps) > 0)
            {
                if (WABSync_NextOp(pWabSync, FALSE))
                    return;
            }
            // fall through if there are no ops
            pWabSync->m_state++;

        case SYNC_STATE_PROCESS_CONFLICTS:
            WABSync_Progress(pWabSync, idsSyncConflicts, Vector_GetLength(pWabSync->m_pOps));
            if (pWabSync->m_pOps && Vector_GetLength(pWabSync->m_pOps) > 0)
            {
                if(SUCCEEDED(WABSync_DoConflicts(pWabSync)))
                    return;
            }
            // fall through if there are no ops
            pWabSync->m_state++;
            if (pWabSync->m_fAborted)
                return;

        case SYNC_STATE_PROCESS_MERGED_CONFLICTS:
            WABSync_Progress(pWabSync, idsSyncFinishing, Vector_GetLength(pWabSync->m_pOps));
            if (pWabSync->m_pOps && Vector_GetLength(pWabSync->m_pOps) > 0)
            {
                if (WABSync_NextOp(pWabSync, FALSE))
                    return;
            }
            // fall through if there are no ops
            pWabSync->m_state++;

        case SYNC_STATE_DONE:
            WABSync_FinishSynchronize(pWabSync, (pWabSync->m_cAborts == 0 ? S_OK : E_FAIL));
            break;
    }
}

BOOL  _WABSync_NextOp(LPWABSYNC pWabSync, BOOL fPopFirst)
{
    HRESULT hr = E_FAIL;
    LPHOTSYNCOP pOp = (LPHOTSYNCOP)Vector_GetItem(pWabSync->m_pOps, 0);

    Assert(pWabSync->m_state == SYNC_STATE_PROCESS_OPS || pWabSync->m_state == SYNC_STATE_PROCESS_MERGED_CONFLICTS);
    Assert(pOp);

    if (pOp && fPopFirst)
    {
        LPVECTOR  pVector;
        pVector = pWabSync->m_pOps;
        Assert(pVector);
        Vector_Remove(pVector, pOp);
        Syncop_Delete(pOp);
        pOp = (LPHOTSYNCOP)Vector_GetItem(pWabSync->m_pOps, 0);
    }

    if (pWabSync->m_state == SYNC_STATE_PROCESS_OPS)
        WABSync_Progress(pWabSync, idsSyncSynchronizing, Vector_GetLength(pWabSync->m_pOps));
    else if (pWabSync->m_state == SYNC_STATE_PROCESS_MERGED_CONFLICTS)
        WABSync_Progress(pWabSync, idsSyncFinishing, Vector_GetLength(pWabSync->m_pOps));

    if (pOp)
        hr = Syncop_Begin(pOp);  
    
    return (SUCCEEDED(hr));
}

BOOL WABSync_NextOp(LPWABSYNC pWabSync, BOOL fPopFirst)
{
    HRESULT hr = E_FAIL;
    LPHOTSYNCOP pOp = (LPHOTSYNCOP)Vector_GetItem(pWabSync->m_pOps, 0);

    if (!pOp)
        return FALSE;
    PostMessage(pWabSync->m_hWnd, WM_SYNC_NEXTOP, fPopFirst, (LPARAM)pWabSync);
    return TRUE;
}

void         WABSync_FreeOps(LPWABSYNC pWabSync)
{
    LPHOTSYNCOP    pOp;

    if (pWabSync->m_pOps)
    {
        LONG   dwIndex, cItems = Vector_GetLength(pWabSync->m_pOps);

        for (dwIndex = cItems - 1; dwIndex >= 0; --dwIndex)
        {
            pOp = (LPHOTSYNCOP)Vector_GetItem(pWabSync->m_pOps, dwIndex);

            if (pOp)
            {
                Vector_RemoveItem(pWabSync->m_pOps, dwIndex);
                Syncop_Abort(pOp);
                Syncop_Delete(pOp);
            }

            if (dwIndex == 0)
                break;
        }
    }
}

void         WABSync_FreeItems(LPWABSYNC pWabSync)
{
    LPWABCONTACTINFO    lprWCI;

    if (pWabSync->m_pWabItems)
    {
        LONG   dwIndex, cItems = Vector_GetLength(pWabSync->m_pWabItems);

        for (dwIndex = cItems - 1; dwIndex >= 0; --dwIndex)
        {
            lprWCI = (LPWABCONTACTINFO)Vector_GetItem(pWabSync->m_pWabItems, dwIndex);

            if (lprWCI)
            {
                if (lprWCI->lpEID)
                    LocalFree(lprWCI->lpEID);
                LocalFree(lprWCI);
            }

            Vector_RemoveItem(pWabSync->m_pWabItems, dwIndex);
            
            if (dwIndex == 0)
                break;
        }
    }

}

HRESULT WABSync_DoConflicts(LPWABSYNC pWabSync)
{
    LONG                dwIndex, cConflicts = 0, cItems = Vector_GetLength(pWabSync->m_pOps);
    LPHOTSYNCOP         pOp;
    LPHTTPCONFLICTINFO  pConflicts = NULL;
    if (cItems == 0)
    {
        WABSync_NextState(pWabSync);
        return S_OK;
    }

    pConflicts = LocalAlloc(LMEM_ZEROINIT, sizeof(HTTPCONFLICTINFO) * cItems);
    if (!pConflicts)
        return E_OUTOFMEMORY;

    for (dwIndex = 0; dwIndex < cItems; dwIndex++)
    {
        pOp = Vector_GetItem(pWabSync->m_pOps, dwIndex);
        Assert(pOp->m_bOpType == SYNCOP_CONFLICT);
        
        if (!pOp || pOp->m_bOpType != SYNCOP_CONFLICT)
           continue;

        Assert(pOp->m_pServerContact);
        Assert(pOp->m_pClientContact);

        pConflicts[dwIndex].pciServer = pOp->m_pServerContact;
        pConflicts[dwIndex].pciClient = pOp->m_pClientContact;
        cConflicts++;
    }

    if (ResolveConflicts(pWabSync->m_hParentWnd, pConflicts, cConflicts))
    {
        HRESULT hr = S_OK;
        for (dwIndex = 0; dwIndex < cConflicts; dwIndex++)
        {
            BOOL    fChanged = FALSE;
            DWORD   dw;

            pOp = Vector_GetItem(pWabSync->m_pOps, dwIndex);
            Assert(pOp->m_bOpType == SYNCOP_CONFLICT);
        
            Assert(pOp->m_pServerContact);
            Assert(pOp->m_pClientContact);
            
            for (dw = 0; dw < CONFLICT_DECISION_COUNT; dw++)
            {
                if (pConflicts[dwIndex].rgcd[dw] != 0)
                {
                    fChanged = TRUE;
                    break;
                }
            }

            if (fChanged)
            {
                hr = ContactInfo_BlendResults(pOp->m_pServerContact, pOp->m_pClientContact, (CONFLICT_DECISION *)&(pConflicts[dwIndex].rgcd));
                pOp->m_bState = OP_STATE_MERGED;
            }
            else
            {
                // toss out the conflict since they didn't want to change anything
                pOp->m_bState = OP_STATE_DONE;
            }

            // if any of it was skipped, we need to remember this and not update the timestamps.
            if (pConflicts[dwIndex].fContainsSkip)
            {
                pOp->m_fPartialSkip = TRUE;
                pWabSync->m_fSkipped = TRUE;
            }
        }
        //reset progress to new total ops
        pWabSync->m_cTotalOps = Vector_GetLength(pWabSync->m_pOps);

        // HACK to get back into processing ops
        WABSync_NextState(pWabSync);
        return hr;
    }
    else
        WABSync_Abort(pWabSync, E_UserCancel);

    if (pConflicts)
        LocalFree(pConflicts);

    return E_FAIL;
}


void WABSync_MergeAddsToConflicts(LPWABSYNC pWabSync)
{
    DWORD       dwOpCount;
    DWORD       dwCliAddIndex, dwSvrAddIndex;
    LPHOTSYNCOP pCliOp, pOp, pNewOp;
    BOOL        fMerged = FALSE;
    HRESULT     hr;

    dwOpCount = Vector_GetLength(pWabSync->m_pOps);

    // search for Client Adds.  If found, look for a server add for the 
    // same contact.
    for (dwCliAddIndex = 0; dwCliAddIndex < dwOpCount; dwCliAddIndex++)
    {
        fMerged = FALSE;
        pCliOp = Vector_GetItem(pWabSync->m_pOps, dwCliAddIndex);
        if (pCliOp && pCliOp->m_bOpType == SYNCOP_CLIENT_ADD)
        {
            for (dwSvrAddIndex = 0; dwSvrAddIndex < dwOpCount; dwSvrAddIndex++)
            {
                pOp = Vector_GetItem(pWabSync->m_pOps, dwSvrAddIndex);
                if (pOp && pOp->m_bOpType == SYNCOP_SERVER_ADD)
                {
                    if (pOp->m_pClientContact && pOp->m_pClientContact->pszEmail &&
                        pCliOp->m_pServerContact && pCliOp->m_pServerContact->pszEmail)
                    {
                        if (lstrcmpiA(pCliOp->m_pServerContact->pszEmail, pOp->m_pClientContact->pszEmail) == 0)
                        {
                            pNewOp = Syncop_CreateConflict(pCliOp->m_pContactInfo);
                            Assert(pNewOp);

                            if (pNewOp)
                            {
                                pNewOp->m_pContactInfo->lpEID = pOp->m_pContactInfo->lpEID;
                                pNewOp->m_pContactInfo->cbEID = pOp->m_pContactInfo->cbEID;
                                pNewOp->m_pContactInfo->pszaContactIds = pOp->m_pContactInfo->pszaContactIds;
                                pNewOp->m_pContactInfo->pszaServerIds = pOp->m_pContactInfo->pszaServerIds;
                                pNewOp->m_pContactInfo->pszaModtimes = pOp->m_pContactInfo->pszaModtimes;
                                pNewOp->m_pContactInfo->pszaEmails = pOp->m_pContactInfo->pszaEmails;
                                pOp->m_pContactInfo->pszaContactIds = NULL;
                                pOp->m_pContactInfo->pszaServerIds = NULL;
                                pOp->m_pContactInfo->pszaModtimes = NULL;
                                pOp->m_pContactInfo->pszaEmails = NULL;
                                pOp->m_pContactInfo->lpEID = NULL;
                                pOp->m_pContactInfo->cbEID = 0;

                                pCliOp->m_pContactInfo = NULL;
                                pNewOp->m_pServerContact = pCliOp->m_pServerContact;
                                pCliOp->m_pServerContact = NULL;

                                Syncop_Init(pNewOp, (IHTTPMailCallback *)pWabSync, pWabSync->m_pTransport);
                                hr = Vector_AddItem(pWabSync->m_pOps, pNewOp);

                                if (dwSvrAddIndex < dwCliAddIndex)
                                    --dwCliAddIndex;
                                Vector_Remove(pWabSync->m_pOps, pOp);

                                Vector_Remove(pWabSync->m_pOps, pCliOp);
                                
                                dwOpCount = Vector_GetLength(pWabSync->m_pOps);
                                fMerged = TRUE;
                            }
                            break;
                        }
                    }
                }
            }
        }
        if (fMerged)
            -- dwCliAddIndex;
    }
}


// ****************************************************************************************************
//  V   E   C   T   O   R       "C   L   A   S   S"   
//
//  Basic vector class (resizable / sortable array of LPVOIDs).
//


HRESULT    Vector_Create(LPVECTOR *ppVector)
{
    Assert(ppVector);

    *ppVector = LocalAlloc(LMEM_ZEROINIT, sizeof(VECTOR));

    if (*ppVector)
    {
        (*ppVector)->m_dwGrowBy = 4;
        return S_OK;
    }
    else
        return E_OUTOFMEMORY;
}

/*
    Vector_Delete

    Clean up any memory that was allocated in the Vector object
*/
void    Vector_Delete(LPVECTOR pVector)
{
    Assert(pVector);

    if (pVector->m_pItems)
        LocalFree(pVector->m_pItems);
    
    if (pVector)
        LocalFree(pVector);
}

/*
    Vector_GetLength

    Get the number of items in the vector.
*/
DWORD       Vector_GetLength(LPVECTOR pVector)
{
    Assert(pVector);

    return pVector->m_cItems;
}

/*
    Vector_AddItem

    Add a item to the end of the item list.
*/
HRESULT    Vector_AddItem(LPVECTOR pVector, LPVOID lpvItem)
{
    DWORD   dwNewIndex;
    DWORD   dw;

    Assert(pVector);

    // make more room for pointers, if necessary
    if (pVector->m_cSpaces == pVector->m_cItems)
    {
        LPVOID  pNewItems;
        DWORD   dwOldSize = pVector->m_cSpaces * sizeof(char *);

        pVector->m_cSpaces += pVector->m_dwGrowBy;
        
        pNewItems = LocalAlloc(LMEM_ZEROINIT, sizeof(char *) * pVector->m_cSpaces);

        if (!pNewItems)
        {
            pVector->m_cSpaces -= pVector->m_dwGrowBy;
            return E_OUTOFMEMORY;
        }
        else
        {
            if (pVector->m_pItems)
            {
                CopyMemory(pNewItems, pVector->m_pItems, dwOldSize);
                LocalFree(pVector->m_pItems);
            }
 
            pVector->m_pItems = (LPVOID *)pNewItems;
            pVector->m_dwGrowBy = pVector->m_dwGrowBy << 1;   // double the size for the next time we grow it.
        }
    }
    
    //now put the item in the next location
    dwNewIndex = pVector->m_cItems++;
    
    pVector->m_pItems[dwNewIndex] = lpvItem;
    
    return S_OK;
}

/*
    Vector_Remove
    
    Remove a given item from the vector
*/
void        Vector_Remove(LPVECTOR pVector, LPVOID lpvItem)
{
    DWORD   dw;

    for (dw = 0; dw < pVector->m_cItems; dw++)
    {
        if (pVector->m_pItems[dw] == lpvItem)
        {
            Vector_RemoveItem(pVector, dw);
            return;
        }
    }
}

/*
    Vector_RemoveItem
    
    Remove a item at zero based index iIndex 
*/

void    Vector_RemoveItem(LPVECTOR pVector, DWORD    dwIndex)
{
    int     iCopySize;
    DWORD   dw;

    Assert(pVector);
    Assert(dwIndex < pVector->m_cItems);
 
    // move the other pItems down
    for (dw = dwIndex+1; dw < pVector->m_cItems; dw ++)
        pVector->m_pItems[dw - 1] = pVector->m_pItems[dw];

    // null out the last item in the list and decrement the counter.
    pVector->m_pItems[--pVector->m_cItems] = NULL;
}

/*
    CVector::GetItem
    
    Return the pointer to the item at zero based index iIndex.

    Return the item at the given index.  Note that the char pointer
    is still owned by the item list and should not be deleted.
*/

LPVOID    Vector_GetItem(LPVECTOR pVector, DWORD   dwIndex)
{
    Assert(pVector);
    Assert(dwIndex < pVector->m_cItems || dwIndex == 0);

    if (dwIndex < pVector->m_cItems )
        return pVector->m_pItems[dwIndex];
    else
        return NULL;
}


void    Vector_Sort(LPVECTOR pVector, FnCompareFunc lpfnCompare)
{
    qsort(pVector->m_pItems, pVector->m_cItems, sizeof(LPVOID), lpfnCompare);
}

LPHOTSYNCOP Syncop_CreateServerAdd(LPWABCONTACTINFO pContactInfo)
{
    LPHOTSYNCOP pOp = LocalAlloc(LMEM_ZEROINIT, sizeof(HOTSYNCOP));
    
    if (pOp)
    {
        pOp->m_bOpType = SYNCOP_SERVER_ADD;
        pOp->m_pfnHandleResponse = Syncop_ServerAddResponse;
        pOp->m_pfnBegin = Syncop_ServerAddBegin;
        pOp->m_pContactInfo = pContactInfo;
    }

    return pOp;
}

LPHOTSYNCOP Syncop_CreateServerDelete(LPWABCONTACTINFO pContactInfo)
{
    LPHOTSYNCOP pOp = LocalAlloc(LMEM_ZEROINIT, sizeof(HOTSYNCOP));
    
    if (pOp)
    {
        pOp->m_bOpType = SYNCOP_SERVER_DELETE;
        pOp->m_pfnHandleResponse = Syncop_ServerDeleteResponse;
        pOp->m_pfnBegin = Syncop_ServerDeleteBegin;
        pOp->m_pContactInfo = pContactInfo;
    }

    return pOp;
}
    
LPHOTSYNCOP Syncop_CreateServerChange(LPWABCONTACTINFO pContactInfo)
{
    LPHOTSYNCOP pOp = LocalAlloc(LMEM_ZEROINIT, sizeof(HOTSYNCOP));
    
    if (pOp)
    {
        pOp->m_bOpType = SYNCOP_SERVER_CHANGE;
        pOp->m_pfnHandleResponse = Syncop_ServerChangeResponse;
        pOp->m_pfnBegin = Syncop_ServerChangeBegin;
        pOp->m_pContactInfo = pContactInfo;
    }

    return pOp;
}

LPHOTSYNCOP Syncop_CreateClientAdd(LPWABCONTACTINFO pContactInfo)
{
    LPHOTSYNCOP pOp = LocalAlloc(LMEM_ZEROINIT, sizeof(HOTSYNCOP));
    
    Assert(pContactInfo);
    Assert(pOp);

    if (pOp)
    {
        pOp->m_bOpType = SYNCOP_CLIENT_ADD;
        pOp->m_pfnHandleResponse = Syncop_ClientAddResponse;
        pOp->m_pfnBegin = Syncop_ClientAddBegin;
        pOp->m_pContactInfo = pContactInfo;
    }

    return pOp;
}

LPHOTSYNCOP Syncop_CreateClientDelete(LPWABCONTACTINFO pContactInfo)
{
    LPHOTSYNCOP pOp = LocalAlloc(LMEM_ZEROINIT, sizeof(HOTSYNCOP));
    
    if (pOp)
    {
        pOp->m_bOpType = SYNCOP_CLIENT_DELETE;
        pOp->m_pfnHandleResponse = Syncop_ClientDeleteResponse;
        pOp->m_pfnBegin = Syncop_ClientDeleteBegin;
        pOp->m_pContactInfo = pContactInfo;
    }

    return pOp;
}

LPHOTSYNCOP Syncop_CreateClientChange(LPWABCONTACTINFO pContactInfo)
{
    LPHOTSYNCOP pOp = LocalAlloc(LMEM_ZEROINIT, sizeof(HOTSYNCOP));
    
    if (pOp)
    {
        pOp->m_bOpType = SYNCOP_CLIENT_CHANGE;
        pOp->m_pfnHandleResponse = Syncop_ClientChangeResponse;
        pOp->m_pfnBegin = Syncop_ClientChangeBegin;
        pOp->m_pContactInfo = pContactInfo;
    }

    return pOp;
}

LPHOTSYNCOP Syncop_CreateConflict(LPWABCONTACTINFO pContactInfo)
{
    LPHOTSYNCOP pOp = LocalAlloc(LMEM_ZEROINIT, sizeof(HOTSYNCOP));
    
    if (pOp)
    {
        pOp->m_bOpType = SYNCOP_CONFLICT;
        pOp->m_pfnHandleResponse = Syncop_ConflictResponse;
        pOp->m_pfnBegin = Syncop_ConflictBegin;
        pOp->m_pContactInfo = pContactInfo;
    }

    return pOp;
}


HRESULT     Syncop_Init(LPHOTSYNCOP pSyncOp, IHTTPMailCallback *pHotSync, IHTTPMailTransport     *pTransport)
{
    HRESULT hr = S_OK;

    Assert(pSyncOp);
    Assert(pSyncOp->m_pHotSync == NULL);
    Assert(pSyncOp->m_pTransport == NULL);

    pSyncOp->m_pClientContact = NULL;
    pSyncOp->m_pHotSync = pHotSync;
    pSyncOp->m_pTransport = pTransport;
    pSyncOp->m_bState = OP_STATE_INITIALIZING;
    pSyncOp->m_fPartialSkip = FALSE;
    pSyncOp->m_dwRetries = 0;

    if (pSyncOp->m_pTransport)
        IHTTPMailTransport_AddRef(pSyncOp->m_pTransport);

    if (pSyncOp->m_pHotSync)
        IHTTPMailCallback_AddRef(pSyncOp->m_pHotSync);

    if (pSyncOp->m_bOpType == SYNCOP_SERVER_ADD ||
        pSyncOp->m_bOpType == SYNCOP_SERVER_CHANGE ||
        pSyncOp->m_bOpType == SYNCOP_CLIENT_CHANGE ||
        pSyncOp->m_bOpType == SYNCOP_CONFLICT )
    {
        pSyncOp->m_pClientContact = LocalAlloc(LMEM_ZEROINIT, sizeof(HTTPCONTACTINFO));
        if (pSyncOp->m_pClientContact)
            hr = ContactInfo_LoadFromWAB(((LPWABSYNC)pSyncOp->m_pHotSync), 
                                            pSyncOp->m_pClientContact, 
                                            pSyncOp->m_pContactInfo,
                                            pSyncOp->m_pContactInfo->lpEID, 
                                            pSyncOp->m_pContactInfo->cbEID);
    }

    return hr;
}

HRESULT     Syncop_Delete(LPHOTSYNCOP pSyncOp)
{
    Assert(pSyncOp);

    if (pSyncOp->m_pTransport)
        IHTTPMailTransport_Release(pSyncOp->m_pTransport);

    if (pSyncOp->m_pHotSync)
        IHTTPMailCallback_Release(pSyncOp->m_pHotSync);

    if (pSyncOp->m_pServerContact)
    {
        ContactInfo_Free(pSyncOp->m_pServerContact);
        LocalFree(pSyncOp->m_pServerContact);
    }
    
    if (pSyncOp->m_pClientContact)
    {
        ContactInfo_Free(pSyncOp->m_pClientContact);
        LocalFree(pSyncOp->m_pClientContact);
    }
    
    if (pSyncOp->m_pContactInfo)
    {
        WABContact_Delete(pSyncOp->m_pContactInfo);
    }

    LocalFree(pSyncOp);
    
    return S_OK;
}

HRESULT     Syncop_HandleResponse(LPHOTSYNCOP pSyncOp, LPHTTPMAILRESPONSE pResponse)
{
    Assert(pSyncOp);
    Assert(pSyncOp->m_pfnHandleResponse);
    Assert(pSyncOp->m_bOpType != SYNCOP_SERVER_INVALID);

    return (pSyncOp->m_pfnHandleResponse)(pSyncOp, pResponse);

}

HRESULT     Syncop_Begin(LPHOTSYNCOP pSyncOp)
{
    Assert(pSyncOp);
    Assert(pSyncOp->m_pfnBegin);
    Assert(pSyncOp->m_bOpType != SYNCOP_SERVER_INVALID);

    return (pSyncOp->m_pfnBegin)(pSyncOp);
}

HRESULT     Syncop_Abort(LPHOTSYNCOP pSyncOp)
{
    Assert(pSyncOp);

    return E_NOTIMPL;
}

HRESULT     Syncop_ServerAddResponse(LPHOTSYNCOP pSyncOp, LPHTTPMAILRESPONSE pResponse)
{
    HRESULT hr = S_OK;
    LPWABSYNC   pWabSync = (LPWABSYNC)(pSyncOp->m_pHotSync);

    Assert(pSyncOp);
    Assert(pWabSync);

    if (SUCCEEDED(pResponse->rIxpResult.hrResult) && pResponse->rPostContactInfo.pszHref)
    {
        pSyncOp->m_pClientContact->pszId = pResponse->rPostContactInfo.pszId;
        pResponse->rPostContactInfo.pszId = NULL;

        pSyncOp->m_pClientContact->pszModified = pResponse->rPostContactInfo.pszModified;
        pResponse->rPostContactInfo.pszModified = NULL;

        hr = ContactInfo_SaveToWAB(pWabSync, pSyncOp->m_pClientContact, pSyncOp->m_pContactInfo, 
                                        pSyncOp->m_pContactInfo->lpEID, pSyncOp->m_pContactInfo->cbEID, FALSE);

        if (!WABSync_NextOp(pWabSync, TRUE))
            WABSync_NextState(pWabSync);

    }
    else
    {
        if (IXP_E_HTTP_CONFLICT == pResponse->rIxpResult.hrResult)
        {
            // if we get a conflict, it is probably because the nickname we 
            // generated is not unique.  Lets try to generate a new one, but
            // don't try this more than twice.
            if (pSyncOp->m_dwRetries <= 2)
            {
                pSyncOp->m_dwRetries ++;
                if (SUCCEEDED(hr = ContactInfo_GenerateNickname(pSyncOp->m_pClientContact)))
                    hr = pSyncOp->m_pTransport->lpVtbl->PostContact(pSyncOp->m_pTransport, ((LPWABSYNC)pSyncOp->m_pHotSync)->m_pszRootUrl, pSyncOp->m_pClientContact, 0);
        
            }
            else
            {   // [PaulHi] 12/3/98  After trying three different nicknames, abort this
                // synchronization operation.
                hr = pResponse->rIxpResult.hrResult;
            }
        }
        else
        {
            if (pResponse->rPostContactInfo.pszHref)
            {
                // TODO : delete the server version here?

                // we have the reference, just not the timestamp or id. Guess the id, and 
                // throw in a crappy timestamp so that it will get fixed up next time
                char *pszId = NULL, *psz;

                psz = pResponse->rPostContactInfo.pszHref;
                while (*psz)
                {
                    if ('/' == *psz)
                    {
                        if (psz[1] == 0)
                            *psz = 0;
                        else
                            pszId = ++psz;
                    }
                    else    
                        psz++;
                }
            
                if (pszId)
                {
                    pSyncOp->m_pClientContact->pszId = _StrDup(pszId);
                    pResponse->rPostContactInfo.pszId = NULL;

                    pResponse->rPostContactInfo.pszModified = _StrDup( "1993-01-01T00:00");
                    hr = ContactInfo_SaveToWAB(pWabSync, pSyncOp->m_pClientContact,  pSyncOp->m_pContactInfo,
                                                    pSyncOp->m_pContactInfo->lpEID, pSyncOp->m_pContactInfo->cbEID, FALSE);

                    if (!WABSync_NextOp(pWabSync, TRUE))
                        WABSync_NextState(pWabSync);
                
                    return S_OK;
                }
            }
            hr = pResponse->rIxpResult.hrResult;
        }
    }
    return hr;
}


HRESULT     Syncop_ServerAddBegin(LPHOTSYNCOP pSyncOp)
{
    HRESULT hr;

    Assert(pSyncOp);

    if (!pSyncOp->m_pClientContact)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if (OP_STATE_INITIALIZING == pSyncOp->m_bState)
    {
        pSyncOp->m_bState = OP_STATE_SERVER_GET;

        if (pSyncOp->m_pClientContact->pszNickname ||  SUCCEEDED(hr = ContactInfo_GenerateNickname(pSyncOp->m_pClientContact)))
            hr = pSyncOp->m_pTransport->lpVtbl->PostContact(pSyncOp->m_pTransport, ((LPWABSYNC)pSyncOp->m_pHotSync)->m_pszRootUrl, pSyncOp->m_pClientContact, 0);
    }

exit:
    if (FAILED(hr))
    {
        if (pSyncOp->m_pClientContact)
        {
            ContactInfo_Free(pSyncOp->m_pClientContact);
            LocalFree(pSyncOp->m_pClientContact);
            pSyncOp->m_pClientContact = NULL;
        }
    }

    return hr;
}



HRESULT     Syncop_ServerDeleteResponse(LPHOTSYNCOP pSyncOp, LPHTTPMAILRESPONSE pResponse)
{
    HRESULT hr = pResponse->rIxpResult.hrResult;
    LPWABSYNC   pWabSync = (LPWABSYNC)pSyncOp->m_pHotSync;

    Assert(pSyncOp);
    
    if (SUCCEEDED(pResponse->rIxpResult.hrResult))
    {
        TCHAR   tszServerId[MAX_PATH];
        TCHAR   tszKey[MAX_PATH];
        HKEY    hkey = NULL;

        // now that the delete has completed, delete the tombstone from the registry.
        if ( FAILED(hrMakeContactId(
            tszServerId,
            MAX_PATH,
            ((LPIAB)(pWabSync->m_pAB))->szProfileID,
            pWabSync->m_pszAccountId,
            pWabSync->m_szLoginName)) )
        {
            return hr;
        }
        wsprintf(tszKey,  TEXT("%s%s"), g_lpszSyncKey, tszServerId);

        if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, tszKey, 0, KEY_SET_VALUE, &hkey))
        {
            LPTSTR lpKey =
                ConvertAtoW(pSyncOp->m_pContactInfo->pszHotmailId);
            RegDeleteValue(hkey, lpKey);
            LocalFreeAndNull(&lpKey);
            RegCloseKey(hkey);
        }

        if (!WABSync_NextOp(pWabSync, TRUE))
            WABSync_NextState(pWabSync);
    }

    return hr;
}


HRESULT     Syncop_ServerDeleteBegin(LPHOTSYNCOP pSyncOp)
{
    HRESULT hr;

    Assert(pSyncOp);
    Assert(pSyncOp->m_pContactInfo->pszHotmailHref);
    hr = pSyncOp->m_pTransport->lpVtbl->CommandDELETE(pSyncOp->m_pTransport, pSyncOp->m_pContactInfo->pszHotmailHref, 0);

    return hr;
}


HRESULT     Syncop_ServerChangeResponse(LPHOTSYNCOP pSyncOp, LPHTTPMAILRESPONSE pResponse)
{
    HRESULT hr = pResponse->rIxpResult.hrResult;
    LPWABSYNC pWabSync = (LPWABSYNC)pSyncOp->m_pHotSync;

    Assert(pSyncOp);

    if (OP_STATE_SERVER_GET == pSyncOp->m_bState)
    {
        if (SUCCEEDED(pResponse->rIxpResult.hrResult) && pResponse->rContactInfoList.prgContactInfo)
        {
            // assume the whole struct
            Assert(pResponse->rContactInfoList.prgContactInfo);
            Assert(pResponse->rContactInfoList.cContactInfo == 1);
            
            if (!pSyncOp->m_pServerContact)
                pSyncOp->m_pServerContact = LocalAlloc(LMEM_ZEROINIT, sizeof(HTTPCONTACTINFO));

            *pSyncOp->m_pServerContact = *pResponse->rContactInfoList.prgContactInfo;
            ContactInfo_Clear(pResponse->rContactInfoList.prgContactInfo);
            pSyncOp->m_bState = OP_STATE_LOADED;
            
            if (!ContactInfo_Match(pSyncOp->m_pServerContact, pSyncOp->m_pClientContact))
            {
                pSyncOp->m_bState = OP_STATE_SERVER_PUT;
                hr = ContactInfo_PreparePatch(pSyncOp->m_pServerContact, pSyncOp->m_pClientContact);
                hr = pSyncOp->m_pTransport->lpVtbl->PatchContact(pSyncOp->m_pTransport, pSyncOp->m_pContactInfo->pszHotmailHref, pSyncOp->m_pClientContact, 0);
            }
            else
                if (!WABSync_NextOp(pWabSync, TRUE))
                    WABSync_NextState(pWabSync);
        }
    }
    else if (OP_STATE_SERVER_PUT == pSyncOp->m_bState)
    {
        // if it succeeded, save the new values mod stamp, etc to the wab
        if (SUCCEEDED(pResponse->rIxpResult.hrResult) && pResponse->rContactInfoList.prgContactInfo)
        {
            SafeCoMemFree(pSyncOp->m_pClientContact->pszId);
            pSyncOp->m_pClientContact->pszId = pResponse->rPostContactInfo.pszId;
            pResponse->rPostContactInfo.pszId = NULL;

            SafeCoMemFree(pSyncOp->m_pClientContact->pszModified);
            pSyncOp->m_pClientContact->pszModified = pResponse->rPostContactInfo.pszModified;
            pResponse->rPostContactInfo.pszModified = NULL;

            hr = ContactInfo_SaveToWAB(pWabSync, pSyncOp->m_pClientContact, pSyncOp->m_pContactInfo, pSyncOp->m_pContactInfo->lpEID, pSyncOp->m_pContactInfo->cbEID, FALSE);

            if (!WABSync_NextOp(pWabSync, TRUE))
                WABSync_NextState(pWabSync);
        }
    }
    
    return hr;
}


HRESULT     Syncop_ServerChangeBegin(LPHOTSYNCOP pSyncOp)
{
    LPWABSYNC   pHotSync = (LPWABSYNC)pSyncOp->m_pHotSync;
    HRESULT     hr = S_OK;

    Assert(pSyncOp);
    Assert(pSyncOp->m_pTransport);
    Assert(pSyncOp->m_pContactInfo);
    Assert(pSyncOp->m_pContactInfo->pszHotmailHref);
    
    if (OP_STATE_INITIALIZING == pSyncOp->m_bState)
    {
        if (pSyncOp->m_pServerContact)
        {
            pSyncOp->m_bState = OP_STATE_LOADED;
            
            if (!ContactInfo_Match(pSyncOp->m_pServerContact, pSyncOp->m_pClientContact))
            {
                pSyncOp->m_bState = OP_STATE_SERVER_PUT;
                hr = ContactInfo_PreparePatch(pSyncOp->m_pServerContact, pSyncOp->m_pClientContact);

                hr = pSyncOp->m_pTransport->lpVtbl->PatchContact(pSyncOp->m_pTransport, pSyncOp->m_pContactInfo->pszHotmailHref, pSyncOp->m_pClientContact, 0);
            }
            else
                if (!WABSync_NextOp(pHotSync, TRUE))
                    WABSync_NextState(pHotSync);
        }
        else
        {
            pSyncOp->m_bState = OP_STATE_SERVER_GET;
            hr = pSyncOp->m_pTransport->lpVtbl->ContactInfo(pSyncOp->m_pTransport, pSyncOp->m_pContactInfo->pszHotmailHref, 0);
        }
    }

    return hr;
}



HRESULT     Syncop_ClientAddResponse(LPHOTSYNCOP pSyncOp, LPHTTPMAILRESPONSE pResponse)
{
    HRESULT hr = S_OK;
    LPWABSYNC pHotSync = (LPWABSYNC)pSyncOp->m_pHotSync;

    Assert(pSyncOp);

    if (OP_STATE_SERVER_GET == pSyncOp->m_bState)
    {
        if (SUCCEEDED(pResponse->rIxpResult.hrResult) && pResponse->rContactInfoList.prgContactInfo)
        {
            // assume the whole struct
            Assert(pResponse->rContactInfoList.prgContactInfo);
            Assert(pResponse->rContactInfoList.cContactInfo == 1);
            
            if (!pSyncOp->m_pServerContact)
                pSyncOp->m_pServerContact = LocalAlloc(LMEM_ZEROINIT, sizeof(HTTPCONTACTINFO));

            *pSyncOp->m_pServerContact = *pResponse->rContactInfoList.prgContactInfo;
            ContactInfo_Clear(pResponse->rContactInfoList.prgContactInfo);
            pSyncOp->m_bState = OP_STATE_LOADED;
            
            ContactInfo_SaveToWAB(pHotSync, pSyncOp->m_pServerContact, NULL, NULL, 0, FALSE);

            if (!WABSync_NextOp(pHotSync, TRUE))
                WABSync_NextState(pHotSync);
        }
        else
            hr = pResponse->rIxpResult.hrResult;
    }

    return hr;
}


HRESULT     Syncop_ClientAddBegin(LPHOTSYNCOP pSyncOp)
{
    HRESULT     hr = S_OK;
    LPWABSYNC   pHotSync = (LPWABSYNC)pSyncOp->m_pHotSync;

    Assert(pSyncOp);
    Assert(pSyncOp->m_pTransport);
    Assert(pSyncOp->m_pContactInfo);
    Assert(pSyncOp->m_pContactInfo->pszHotmailHref);
    
    if (OP_STATE_INITIALIZING == pSyncOp->m_bState)
    {
        if (pSyncOp->m_pServerContact)
        {
            pSyncOp->m_bState = OP_STATE_LOADED;
            
            ContactInfo_SaveToWAB(pHotSync, pSyncOp->m_pServerContact, NULL, NULL, 0, FALSE);

            if (!WABSync_NextOp(pHotSync, TRUE))
                WABSync_NextState(pHotSync);
        }
        else
        {
            pSyncOp->m_bState = OP_STATE_SERVER_GET;
            hr = pSyncOp->m_pTransport->lpVtbl->ContactInfo(pSyncOp->m_pTransport, pSyncOp->m_pContactInfo->pszHotmailHref, 0);
        }
    }

    return hr;
}



HRESULT     Syncop_ClientDeleteResponse(LPHOTSYNCOP pSyncOp, LPHTTPMAILRESPONSE pResponse)
{
    Assert(pSyncOp);

    return E_NOTIMPL;
}


HRESULT     Syncop_ClientDeleteBegin(LPHOTSYNCOP pSyncOp)
{
    LPABCONT        lpWABCont = NULL;
    LPWABSYNC       pWabSync = (LPWABSYNC)pSyncOp->m_pHotSync;
	HRESULT         hr = S_OK;
    ULONG           cbWABEID = 0;
    LPENTRYID       lpWABEID = NULL;
    ULONG           ulObjType;
    SBinaryArray    SBA = {0};

    Assert(pSyncOp);

    if(HR_FAILED(hr = pWabSync->m_pAB->lpVtbl->GetPAB(pWabSync->m_pAB, &cbWABEID, &lpWABEID)))
        goto exit;

    if(HR_FAILED(hr = pWabSync->m_pAB->lpVtbl->OpenEntry(pWabSync->m_pAB,
                                  cbWABEID,     // size of EntryID to open
                                  lpWABEID,     // EntryID to open
                                  NULL,         // interface
                                  0,            // flags
                                  &ulObjType,
                                  (LPUNKNOWN *)&lpWABCont)))
        goto exit;

    if(!(SBA.lpbin = LocalAlloc(LMEM_ZEROINIT, sizeof(SBinary))))
        goto exit;

    SetSBinary(&(SBA.lpbin[0]), pSyncOp->m_pContactInfo->cbEID, (LPBYTE)pSyncOp->m_pContactInfo->lpEID);

    SBA.cValues = 1;
    
    if(HR_FAILED(hr = lpWABCont->lpVtbl->DeleteEntries( lpWABCont, (LPENTRYLIST) &SBA, 0)))
    {
        hr = S_OK;
        goto exit;
    }
exit:
    if(SBA.lpbin && SBA.cValues)
    {
        LocalFreeAndNull((LPVOID *) (&(SBA.lpbin[0].lpb)));
        LocalFreeAndNull(&SBA.lpbin);
    }

    if(lpWABCont)
        UlRelease(lpWABCont);

    if(lpWABEID)
        FreeBufferAndNull(&lpWABEID);

    if (!WABSync_NextOp(pWabSync, TRUE))
        WABSync_NextState(pWabSync);

    return hr;
}



HRESULT     Syncop_ClientChangeResponse(LPHOTSYNCOP pSyncOp, LPHTTPMAILRESPONSE pResponse)
{
    HRESULT     hr = S_OK;
    LPWABSYNC   pHotSync = (LPWABSYNC)pSyncOp->m_pHotSync;

    Assert(pSyncOp);

    if (OP_STATE_SERVER_GET == pSyncOp->m_bState)
    {
        if (SUCCEEDED(pResponse->rIxpResult.hrResult) && pResponse->rContactInfoList.prgContactInfo)
        {
            // assume the whole struct
            Assert(pResponse->rContactInfoList.prgContactInfo);
            Assert(pResponse->rContactInfoList.cContactInfo == 1);
            
            if (!pSyncOp->m_pServerContact)
                pSyncOp->m_pServerContact = LocalAlloc(LMEM_ZEROINIT, sizeof(HTTPCONTACTINFO));

            *pSyncOp->m_pServerContact = *pResponse->rContactInfoList.prgContactInfo;
            ContactInfo_Clear(pResponse->rContactInfoList.prgContactInfo);
            pSyncOp->m_bState = OP_STATE_LOADED;
            
            ContactInfo_EmptyNullItems(pSyncOp->m_pServerContact);
            ContactInfo_SaveToWAB(pHotSync, pSyncOp->m_pServerContact, pSyncOp->m_pContactInfo, pSyncOp->m_pContactInfo->lpEID, pSyncOp->m_pContactInfo->cbEID, TRUE);

            if (!WABSync_NextOp(pHotSync, TRUE))
                WABSync_NextState(pHotSync);
        }
        else
            hr = pResponse->rIxpResult.hrResult;
    }

    return hr;
}


HRESULT     Syncop_ClientChangeBegin(LPHOTSYNCOP pSyncOp)
{
    HRESULT     hr = S_OK;
    LPWABSYNC   pHotSync = (LPWABSYNC)pSyncOp->m_pHotSync;

    Assert(pSyncOp);
    Assert(pSyncOp->m_pTransport);
    Assert(pSyncOp->m_pContactInfo);
    Assert(pSyncOp->m_pContactInfo->pszHotmailHref);
    
    if (OP_STATE_INITIALIZING == pSyncOp->m_bState)
    {
        if (pSyncOp->m_pServerContact)
        {
            pSyncOp->m_bState = OP_STATE_LOADED;
            
            ContactInfo_EmptyNullItems(pSyncOp->m_pServerContact);
            ContactInfo_SaveToWAB(pHotSync, pSyncOp->m_pServerContact, pSyncOp->m_pContactInfo, pSyncOp->m_pContactInfo->lpEID, pSyncOp->m_pContactInfo->cbEID, TRUE);

            if (!WABSync_NextOp(pHotSync, TRUE))
                WABSync_NextState(pHotSync);
        }
        else
        {
            pSyncOp->m_bState = OP_STATE_SERVER_GET;
            hr = pSyncOp->m_pTransport->lpVtbl->ContactInfo(pSyncOp->m_pTransport, pSyncOp->m_pContactInfo->pszHotmailHref, 0);
        }
    }

    return hr;
}



HRESULT     Syncop_ConflictResponse(LPHOTSYNCOP pSyncOp, LPHTTPMAILRESPONSE pResponse)
{
    HRESULT hr = S_OK;
    LPWABSYNC pHotSync = (LPWABSYNC)pSyncOp->m_pHotSync;

    Assert(pSyncOp);

    if (OP_STATE_SERVER_GET == pSyncOp->m_bState)
    {
        if (SUCCEEDED(pResponse->rIxpResult.hrResult) && pResponse->rContactInfoList.prgContactInfo)
        {
            // assume the whole struct
            Assert(pResponse->rContactInfoList.prgContactInfo);
            Assert(pResponse->rContactInfoList.cContactInfo == 1);
            
            if (!pSyncOp->m_pServerContact)
                pSyncOp->m_pServerContact = LocalAlloc(LMEM_ZEROINIT, sizeof(HTTPCONTACTINFO));

            *pSyncOp->m_pServerContact = *pResponse->rContactInfoList.prgContactInfo;
            ContactInfo_Clear(pResponse->rContactInfoList.prgContactInfo);
            pSyncOp->m_bState = OP_STATE_LOADED;
            
            // if the records match as far as we're concerned, we are done.
            if (ContactInfo_Match(pSyncOp->m_pServerContact, pSyncOp->m_pClientContact))
            {
                // update the timestamp so it isn't a conflict next time.
                ContactInfo_SaveToWAB(pHotSync, pSyncOp->m_pServerContact, pSyncOp->m_pContactInfo, pSyncOp->m_pContactInfo->lpEID, pSyncOp->m_pContactInfo->cbEID, TRUE);

                if (!WABSync_NextOp(pHotSync, TRUE))
                    WABSync_NextState(pHotSync);
            }
            else
            {
                // move this item to the end, once all conflicts are loaded, then we
                // will do the dialog
                Vector_Remove(pHotSync->m_pOps, pSyncOp);
                Vector_AddItem(pHotSync->m_pOps, pSyncOp);

                if (!WABSync_NextOp(pHotSync, FALSE))
                    WABSync_NextState(pHotSync);
            }
        }
        else
            hr = pResponse->rIxpResult.hrResult;
    }
    else if (OP_STATE_SERVER_PUT == pSyncOp->m_bState)
    {
        // if it succeeded, save the new values mod stamp, etc to the wab
        if (SUCCEEDED(pResponse->rIxpResult.hrResult) && pResponse->rContactInfoList.prgContactInfo)
        {
            SafeCoMemFree(pSyncOp->m_pClientContact->pszId);
            pSyncOp->m_pClientContact->pszId = pResponse->rPostContactInfo.pszId;
            pResponse->rPostContactInfo.pszId = NULL;

            SafeCoMemFree(pSyncOp->m_pClientContact->pszModified);
            pSyncOp->m_pClientContact->pszModified = pResponse->rPostContactInfo.pszModified;
            pResponse->rPostContactInfo.pszModified = NULL;

            if (!pSyncOp->m_fPartialSkip)
                hr = ContactInfo_SaveToWAB(pHotSync, pSyncOp->m_pClientContact, pSyncOp->m_pContactInfo, pSyncOp->m_pContactInfo->lpEID, pSyncOp->m_pContactInfo->cbEID, FALSE);

            if (!WABSync_NextOp(pHotSync, TRUE))
                WABSync_NextState(pHotSync);
        }
    }

    return hr;
}



HRESULT     Syncop_ConflictBegin(LPHOTSYNCOP pSyncOp)
{
    HRESULT     hr = S_OK;
    LPWABSYNC   pHotSync = (LPWABSYNC)pSyncOp->m_pHotSync;

    Assert(pSyncOp);
    Assert(pSyncOp->m_pTransport);
    Assert(pSyncOp->m_pContactInfo);
    Assert(pSyncOp->m_pContactInfo->pszHotmailHref);
    
    if (OP_STATE_INITIALIZING == pSyncOp->m_bState)
    {
        if (pSyncOp->m_pServerContact)
        {
            pSyncOp->m_bState = OP_STATE_LOADED;
            
            // if the records match as far as we're concerned, we are done.
            if (ContactInfo_Match(pSyncOp->m_pServerContact, pSyncOp->m_pClientContact))
            {
                // update the timestamp so it isn't a conflict next time.
                ContactInfo_SaveToWAB(pHotSync, pSyncOp->m_pServerContact, pSyncOp->m_pContactInfo, pSyncOp->m_pContactInfo->lpEID, pSyncOp->m_pContactInfo->cbEID, TRUE);

                if (!WABSync_NextOp(pHotSync, TRUE))
                    WABSync_NextState(pHotSync);
            }
            else
            {
                // move this item to the end, once all conflicts are loaded, then we
                // will do the dialog
                Vector_Remove(pHotSync->m_pOps, pSyncOp);
                Vector_AddItem(pHotSync->m_pOps, pSyncOp);

                if (!WABSync_NextOp(pHotSync, FALSE))
                    WABSync_NextState(pHotSync);
            }
        }
        else
        {
            pSyncOp->m_bState = OP_STATE_SERVER_GET;
			hr = pSyncOp->m_pTransport->lpVtbl->ContactInfo(pSyncOp->m_pTransport, pSyncOp->m_pContactInfo->pszHotmailHref, 0);
        }
    }
    else if (OP_STATE_LOADED == pSyncOp->m_bState)
        WABSync_NextState(pHotSync);
    else if (OP_STATE_MERGED == pSyncOp->m_bState)
    {
        hr = ContactInfo_SaveToWAB(pHotSync, pSyncOp->m_pClientContact, pSyncOp->m_pContactInfo, pSyncOp->m_pContactInfo->lpEID, pSyncOp->m_pContactInfo->cbEID, TRUE);
        if (FAILED(hr))
            return hr;

        pSyncOp->m_bState = OP_STATE_SERVER_PUT;
        hr = pSyncOp->m_pTransport->lpVtbl->PatchContact(pSyncOp->m_pTransport, pSyncOp->m_pContactInfo->pszHotmailHref, pSyncOp->m_pServerContact, 0);
    }
    else if (OP_STATE_DONE == pSyncOp->m_bState)
    {
        if (!WABSync_NextOp(pHotSync, TRUE))
            WABSync_NextState(pHotSync);
    }

    return hr;
}

void Syncop_SetServerContactInfo(LPHOTSYNCOP pSyncOp, LPWABCONTACTINFO pWabContactInfo, LPHTTPCONTACTINFO pContactInfo)
{
    if (!pSyncOp)
        return;

    if (!pSyncOp->m_pServerContact)
        pSyncOp->m_pServerContact = LocalAlloc(LMEM_ZEROINIT, sizeof(HTTPCONTACTINFO));

    if (!pSyncOp->m_pServerContact)
        return;

    *pSyncOp->m_pServerContact = *pContactInfo;
    ContactInfo_Clear(pContactInfo);
    pSyncOp->m_pServerContact->pszId = _StrDup(pWabContactInfo->pszHotmailId);
    pSyncOp->m_pServerContact->pszModified = _StrDup(pWabContactInfo->pszModHotmail);
}

void    WABContact_Delete(LPWABCONTACTINFO pContact)
{
    Assert(pContact);

    if (pContact->pszHotmailHref)
        CoTaskMemFree(pContact->pszHotmailHref);
    
    if (pContact->pszModHotmail)
        CoTaskMemFree(pContact->pszModHotmail);

    if (pContact->pszHotmailId)
        CoTaskMemFree(pContact->pszHotmailId);

    if (pContact->pszaContactIds)
        FreeMultiValueString(pContact->pszaContactIds);

    if (pContact->pszaServerIds)
        FreeMultiValueString(pContact->pszaServerIds);

    if (pContact->pszaModtimes)
        FreeMultiValueString(pContact->pszaModtimes);

    if (pContact->pszaEmails)
        FreeMultiValueString(pContact->pszaEmails);

    if (pContact->lpEID)
        LocalFree(pContact->lpEID);

    LocalFree(pContact);
}

void ContactInfo_Clear(LPHTTPCONTACTINFO pContactInfo)
{
    ZeroMemory(pContactInfo, sizeof(HTTPCONTACTINFO));
}

void ContactInfo_Free(LPHTTPCONTACTINFO pContactInfo)
{
    DWORD  i, dwSize = ARRAYSIZE(g_ContactInfoStructure);
    if (!pContactInfo)
        return;

    for (i = 0; i < dwSize; i++)
    {
        if (CIS_STRING == CIS_GETTYPE(i))
            SafeCoMemFree(CIS_GETSTRING(pContactInfo, i));
    }
}

ULONG rgPropMap[] = {
    PR_ENTRYID,     //href
    PR_ENTRYID,     //id
    PR_ENTRYID,     //type
    PR_ENTRYID,     //modified
    PR_DISPLAY_NAME,
    PR_GIVEN_NAME,
    PR_SURNAME,
    PR_NICKNAME,
    PR_EMAIL_ADDRESS,
    PR_HOME_ADDRESS_STREET,
    PR_HOME_ADDRESS_CITY,
    PR_HOME_ADDRESS_STATE_OR_PROVINCE,
    PR_HOME_ADDRESS_POSTAL_CODE,
    PR_HOME_ADDRESS_COUNTRY,
    PR_COMPANY_NAME,
    PR_BUSINESS_ADDRESS_STREET,
    PR_BUSINESS_ADDRESS_CITY,
    PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE,
    PR_BUSINESS_ADDRESS_POSTAL_CODE,
    PR_BUSINESS_ADDRESS_COUNTRY,
    PR_HOME_TELEPHONE_NUMBER,
    PR_HOME_FAX_NUMBER,
    PR_BUSINESS_TELEPHONE_NUMBER,
    PR_BUSINESS_FAX_NUMBER,
    PR_MOBILE_TELEPHONE_NUMBER,
    PR_OTHER_TELEPHONE_NUMBER,
    PR_BIRTHDAY,
    PR_PAGER_TELEPHONE_NUMBER
};

DWORD   ContactInfo_CountProperties(LPHTTPCONTACTINFO pContactInfo)
{
    DWORD cProps = 0;
    DWORD dwIndex, dwSize = ARRAYSIZE(g_ContactInfoStructure);

    // skip href
    for (dwIndex = 1; dwIndex < dwSize; dwIndex ++)
    {
#ifdef HM_GROUP_SYNCING
        // [PaulHi] Skip email name here if we are group syncing
        if ( (pContactInfo->tyContact == HTTPMAIL_CT_GROUP) && (dwIndex == idcisEmail) )
            continue;
#endif
        if (CIS_STRING == CIS_GETTYPE(dwIndex) && CIS_GETSTRING(pContactInfo, dwIndex) && *(CIS_GETSTRING(pContactInfo, dwIndex)))    
            cProps++;
    }

#ifdef HM_GROUP_SYNCING
    // [PaulHi] Group syncing
    if (pContactInfo->tyContact == HTTPMAIL_CT_GROUP)
    {
        LPTSTR   lptszEmailName = ConvertAtoW( CIS_GETSTRING(pContactInfo, idcisEmail) );
        if (lptszEmailName)
        {
            ULONG   cContacts = 0;
            ULONG   cOneOffs = 0;
            if ( SUCCEEDED(hrParseHMGroupEmail(lptszEmailName, NULL, &cContacts, NULL, &cOneOffs)) )
            {
                // One property for each set of mail user contacts or one-offs
                cProps += (cContacts != 0) ? 1 : 0;
                cProps += (cOneOffs != 0) ? 1 : 0;
            }

            LocalFreeAndNull(&lptszEmailName);
        }

        // A valid WAB DL must have a display name.  HM groups only have nicknames so we
        // need to reserve a PR_DISPLAY_NAME property.
        // [PaulHi]  Note, only do this if there is a valid Nickname field.  The ContactInfo_SaveToWAB()
        // function, which calls this function, is always in response to a server add or change.
        // The pContactInfo fields reflect whatever was changed on the server.  If there is a 
        // valid Nickname field then be sure we translate this to the WAB property DisplayName field.
        // The WAB group display name corresponds to a HM group nickname.
        if (pContactInfo->pszNickname)
            ++cProps;       // This gets translated to a DisplayName in ContactInfo_TranslateProps()
    }
    else
    {
#endif
        if (pContactInfo->pszEmail && *(pContactInfo->pszEmail))
            cProps++;       //need to make room for the PR_ADDRTYPE too
#ifdef HM_GROUP_SYNCING
    }
#endif
    return cProps;
}



HRESULT ContactInfo_SetProp(ULONG ulPropTag, LPTSTR pszValue, LPSPropValue lpPropArray, DWORD *pdwLoc)
{
    ULONG   ulLen;
    SCODE   sc;
    UNALIGNED LPTSTR  *lppszValues;
    HRESULT hr;
    LPSTR  lp = NULL;

    Assert(pszValue);

    switch (PROP_TYPE(ulPropTag))
    {
        // BUGBUG currently only works for PT_TSTRING or PT_MV_TSTRING properties
        case PT_TSTRING:
            // Get the value for this attribute
            if (ulLen = lstrlen(pszValue))
            {                
                lpPropArray[*pdwLoc].ulPropTag = ulPropTag;
                lpPropArray[*pdwLoc].dwAlignPad = 0;

                //  Allocate more space for the data
                ulLen = (ulLen + 1) * sizeof(TCHAR);
                sc = MAPIAllocateMore(ulLen, lpPropArray, (LPVOID *)&(lpPropArray[*pdwLoc].Value.LPSZ));
                if (sc)
                    goto error;
                lstrcpy(lpPropArray[*pdwLoc].Value.LPSZ, pszValue);

                // If this is PR_EMAIL_ADDRESS, create a PR_ADDRTYPE entry as well
                if (PR_EMAIL_ADDRESS == ulPropTag)
                {
                    // Remember where the email value was, so we can add it to
                    // PR_CONTACT_EMAIL_ADDRESSES later
//                    ulPrimaryEmailIndex = *pdwLoc;
                    (*pdwLoc)++;

                    lpPropArray[*pdwLoc].ulPropTag = PR_ADDRTYPE;
                    lpPropArray[*pdwLoc].dwAlignPad = 0;
                    lpPropArray[*pdwLoc].Value.LPSZ = (LPTSTR)szSMTP;
                }
                (*pdwLoc)++;
            }
            break;

        case PT_MV_TSTRING:
            lpPropArray[*pdwLoc].ulPropTag = ulPropTag;
            lpPropArray[*pdwLoc].dwAlignPad = 0;
            lpPropArray[*pdwLoc].Value.MVSZ.cValues = 1;
            sc = MAPIAllocateMore((2)*sizeof(LPTSTR), lpPropArray, 
                (LPVOID *)&(lpPropArray[*pdwLoc].Value.MVSZ.LPPSZ));
            if (sc)
                goto error;
            lppszValues = lpPropArray[*pdwLoc].Value.MVSZ.LPPSZ;

            ulLen = sizeof(TCHAR)*(lstrlen(pszValue) + 1);
            //  Allocate more space for the email address and copy it.
            sc = MAPIAllocateMore(ulLen, lpPropArray, (LPVOID *)&(lppszValues[0]));
            if (sc)
                goto error;
            lstrcpy(lppszValues[0], pszValue);
            lppszValues[1] = NULL;

            (*pdwLoc)++;
        
            break;
        case PT_SYSTIME:
            lp = ConvertWtoA(pszValue);
            hr = iso8601ToFileTime(lp, (FILETIME *) (&lpPropArray[*pdwLoc].Value.ft), TRUE, TRUE);
            if (SUCCEEDED(hr))
            {
                lpPropArray[*pdwLoc].ulPropTag = ulPropTag;
                lpPropArray[*pdwLoc].dwAlignPad = 0;
                (*pdwLoc)++;
            }
            LocalFreeAndNull(&lp);
            break;

        default:
            return E_INVALIDARG;
    }
    
    return S_OK;
error:

    return ResultFromScode(sc);
}

HRESULT ContactInfo_SetMVSZProp(ULONG ulPropTag, SLPSTRArray *pszaValue, LPSPropValue lpPropArray, DWORD *pdwLoc)
{
    ULONG   ulLen;
    ULONG   cbValue;
    SCODE   sc;
    UNALIGNED LPTSTR  *lppszValues;
    HRESULT hr;
    DWORD   i;
    LPTSTR  lpVal = NULL;

    Assert(pszaValue);

    switch (PROP_TYPE(ulPropTag))
    {
        case PT_MV_TSTRING:
            lpPropArray[*pdwLoc].ulPropTag = ulPropTag;
            lpPropArray[*pdwLoc].dwAlignPad = 0;
            lpPropArray[*pdwLoc].Value.MVSZ.cValues = pszaValue->cValues;
            sc = MAPIAllocateMore((pszaValue->cValues+1)*sizeof(LPTSTR), lpPropArray, 
                (LPVOID *)&(lpPropArray[*pdwLoc].Value.MVSZ.LPPSZ));
            if (sc)
                goto error;
            lppszValues = lpPropArray[*pdwLoc].Value.MVSZ.LPPSZ;

            for (i = 0; i < pszaValue->cValues; i ++)
            {
                ScAnsiToWCMore((LPALLOCATEMORE )(&MAPIAllocateMore), (LPVOID) lpPropArray, (LPSTR) (pszaValue->lppszA[i]), (LPWSTR *) (&(lppszValues[i])));
            }
            lppszValues[pszaValue->cValues] = NULL;

            (*pdwLoc)++;
        
            break;

        default:
            return E_INVALIDARG;
    }
    
    return S_OK;
error:

    return ResultFromScode(sc);
}


HRESULT ContactInfo_TranslateProps(LPWABSYNC pWabSync, LPHTTPCONTACTINFO pContactInfo, LPWABCONTACTINFO pWabContactInfo, LPSPropValue lpaProps)
{
    HRESULT hr = S_OK;
    DWORD   dwIndex, dwSize = ARRAYSIZE(rgPropMap);
    DWORD   dwPropIndex = 0, dwLoc = 0;
    TCHAR   szFullProfile[MAX_PATH];
    DWORD   dwStartIndex = 1;

    // [PaulHi]  Assemble the contact ID string
    hr = hrMakeContactId(
        szFullProfile,
        MAX_PATH,
        ((LPIAB)(pWabSync->m_pAB))->szProfileID,
        pWabSync->m_pszAccountId,
        pWabSync->m_szLoginName);
    if (FAILED(hr))
        return hr;
    
    // fix up the other prop tag array structure to take into account the variable values
    rgPropMap[1] = PR_WAB_HOTMAIL_SERVERIDS;
    rgPropMap[3] = PR_WAB_HOTMAIL_MODTIMES;


    if (pWabContactInfo && pWabContactInfo->pszaContactIds)
    {
        DWORD   i;
        BOOL    fFound = FALSE;

        // [PaulHi] 1/21/99  We are assuming that pszaModtimes and pszaServerIds 
        // pointers are valid too.  Check this.
        Assert(pWabContactInfo->pszaModtimes);
        Assert(pWabContactInfo->pszaServerIds);
        
        for (i = 0; i < pWabContactInfo->pszaContactIds->cValues; i++)
        {
            LPTSTR lpVal = 
                ConvertAtoW(pWabContactInfo->pszaContactIds->lppszA[i]);
            if (lstrcmp(szFullProfile, lpVal) == 0)
            {
                LocalFreeAndNull(&lpVal);
                fFound = TRUE;
                break;
            }
            LocalFreeAndNull(&lpVal);
        }

        if (fFound)
        {
            // update the mod time
            lstrcpyA(pWabContactInfo->pszaModtimes->lppszA[i], CIS_GETSTRING(pContactInfo, idcisModified));
        }
        else
        {
            if (CIS_GETSTRING(pContactInfo, idcisId) && CIS_GETSTRING(pContactInfo, idcisModified))
            {
                // add this one to the list at the end
                LPSTR lpValA = 
                    ConvertWtoA(szFullProfile);
                AppendToMultiValueString(pWabContactInfo->pszaContactIds, lpValA);
                LocalFreeAndNull(&lpValA);
                AppendToMultiValueString(pWabContactInfo->pszaServerIds, CIS_GETSTRING(pContactInfo, idcisId));
                AppendToMultiValueString(pWabContactInfo->pszaModtimes, CIS_GETSTRING(pContactInfo, idcisModified));
            }
        }
        
        ContactInfo_SetMVSZProp(PR_WAB_HOTMAIL_CONTACTIDS, pWabContactInfo->pszaContactIds, lpaProps, &dwLoc);
        ContactInfo_SetMVSZProp(PR_WAB_HOTMAIL_SERVERIDS, pWabContactInfo->pszaServerIds, lpaProps, &dwLoc);
        ContactInfo_SetMVSZProp(PR_WAB_HOTMAIL_MODTIMES, pWabContactInfo->pszaModtimes, lpaProps, &dwLoc);

        dwStartIndex = 4;
    }
    else
        hr = ContactInfo_SetProp(PR_WAB_HOTMAIL_CONTACTIDS, szFullProfile, lpaProps, &dwLoc);

#ifdef HM_GROUP_SYNCING
    if (!pWabSync->m_fSyncGroups)   
    {
        // [PaulHi] Normal contact email addresses
#endif
        // Set the other e-mail address fields
        if (pWabContactInfo && pWabContactInfo->pszaEmails && CIS_GETSTRING(pContactInfo, idcisEmail))
        {
            DWORD dw, cStrs;
            BOOL  fFound = FALSE;

            cStrs = pWabContactInfo->pszaEmails->cValues;

            for (dw = 0; dw < cStrs; dw ++)
            {
                if (lstrcmpiA(pWabContactInfo->pszaEmails->lppszA[dw], CIS_GETSTRING(pContactInfo, idcisEmail)) == 0)
                {
                    pWabContactInfo->dwEmailIndex = dw;
                    fFound = TRUE;
                    break;
                }
            }

            if (!fFound)
            {
                SetMultiValueStringValue(pWabContactInfo->pszaEmails, CIS_GETSTRING(pContactInfo, idcisEmail), pWabContactInfo->dwEmailIndex);
            }

            ContactInfo_SetMVSZProp(PR_CONTACT_EMAIL_ADDRESSES, pWabContactInfo->pszaEmails, lpaProps, &dwLoc);
            //set the index
            lpaProps[dwLoc].ulPropTag = PR_CONTACT_DEFAULT_ADDRESS_INDEX;
            lpaProps[dwLoc].dwAlignPad = 0;
            lpaProps[dwLoc].Value.ul = pWabContactInfo->dwEmailIndex;
            dwLoc ++;
        }
#ifdef HM_GROUP_SYNCING
    }
    else
    {
        // [PaulHi] Implement group syncing.  If we are synchronizing groups then the HM contact
        // email string is a series of contact nicknames and one-off email names.  Parse this
        // string and add each group contact.
        LPTSTR lptszEmailName = ConvertAtoW( CIS_GETSTRING(pContactInfo, idcisEmail) );
        if (lptszEmailName)
        {
            LPTSTR * atszContacts = NULL;
            LPTSTR * atszOneOffs = NULL;
            ULONG    cContacts = 0;
            ULONG    cOneOffs = 0;
            ULONG    ul;

            // The atszContacts and atszOneOffs arrays are just pointers into the lptszEmailName
            // buffer.  So these arrays are only valid as long as lptszEmailName is valid.
            hr = hrParseHMGroupEmail(lptszEmailName, &atszContacts, &cContacts, &atszOneOffs, &cOneOffs);
            if (FAILED(hr))
            {
                LocalFreeAndNull(&lptszEmailName);
                goto out;
            }

            // Add multi-value property tags as appropriate
            if (cContacts)
                hrCreateGroupMVBin(pWabSync, PR_WAB_DL_ENTRIES, atszContacts, cContacts, lpaProps, &dwLoc);
            if (cOneOffs)
                hrCreateGroupMVBin(pWabSync, PR_WAB_DL_ONEOFFS, atszOneOffs, cOneOffs, lpaProps, &dwLoc);

            // cleanup
            LocalFreeAndNull((LPVOID *)&atszContacts);
            LocalFreeAndNull((LPVOID *)&atszOneOffs);
            LocalFreeAndNull(&lptszEmailName);
        }
    }
#endif

    // skip the first ones since we just did them
    for (dwIndex = dwStartIndex; dwIndex < dwSize; dwIndex ++)
    {
        if (CIS_STRING == CIS_GETTYPE(dwIndex) && CIS_GETSTRING(pContactInfo, dwIndex))    
        {
            LPTSTR  lptsz = ConvertAtoW(CIS_GETSTRING(pContactInfo, dwIndex));

#ifdef HM_GROUP_SYNCING
            // [PaulHi] Special group syncing logic
            if (pContactInfo->tyContact == HTTPMAIL_CT_GROUP)
            {
                // Don't add email name for groups
                if (dwIndex == idcisEmail)
                    continue;

                // Copy the nickname to the display name property.  All WAB DL items
                // MUST have a PR_DISPLAY_NAME property.  Since HM groups only contain
                // a nickname use the nickname as the display name.
                if (dwIndex == idcisNickName)
                {
                    hr = ContactInfo_SetProp(PR_DISPLAY_NAME, lptsz, lpaProps, &dwLoc);
                    if (FAILED(hr))
                    {
                        LocalFreeAndNull(&lptsz);
                        break;
                    }
                }
            }
#endif

            hr = ContactInfo_SetProp(rgPropMap[dwIndex], lptsz, lpaProps, &dwLoc);
            LocalFreeAndNull(&lptsz);
            if (FAILED(hr))
                break;
        }
    }

#ifdef HM_GROUP_SYNCING
out:
#endif

    return hr;
}

static LONG   _FindPropTag(ULONG ulPropTag)
{
    LONG lIndex, lSize = ARRAYSIZE(rgPropMap);

    // skip href
    for (lIndex = 1; lIndex < lSize; lIndex ++)
    {
        if (rgPropMap[lIndex] == ulPropTag)
            return lIndex;
    }
    return -1;
}


HRESULT ContactInfo_DetermineDeleteProps(LPHTTPCONTACTINFO pContactInfo, LPSPropTagArray prgRemoveProps)
{
    LPSTR  *pProps = (LPSTR *)pContactInfo;
    LONG    lSize = ARRAYSIZE(rgPropMap);
    LONG    dwIndex;

    prgRemoveProps->cValues = 0;
    
    for (dwIndex = CIS_FIRST_DATA_FIELD; dwIndex < lSize; dwIndex ++)
    {
        if (CIS_STRING == CIS_GETTYPE(dwIndex) && CIS_GETSTRING(pContactInfo, dwIndex) && *(CIS_GETSTRING(pContactInfo, dwIndex)) == 0)
        {
            prgRemoveProps->aulPropTag[prgRemoveProps->cValues++] = rgPropMap[dwIndex];
        }
    }
    return S_OK;
}


HRESULT ContactInfo_PopulateProps(
    LPWABSYNC           pWabSync,
    LPHTTPCONTACTINFO   pContactInfo,
    LPWABCONTACTINFO    pWabContactInfo,
    LPSPropValue        lpaProps,
    ULONG               ulcProps,
    ULONG               ulObjectType)
{
    HRESULT     hr = S_OK;
    LONG        lSize = ARRAYSIZE(rgPropMap);
    DWORD       dwPropIndex = 0, dwLoc = 0;
    ULONG       i, ulPropTag;
    LONG        lIndex;
    char        szBuffer[255];
    ULONG       ulIndServerIDs = -1, ulIndContactIDs = -1, ulIndModtimes = -1, ulIndEmails = -1;
    LPSTR       lpszA = NULL;

    // fix up the other prop tag array structure to take into account the variable values
    // @todo [PaulHi] Instead of using explict numbers create an enum for the array
    // indices so we can remain consistent.
    rgPropMap[1] = PR_WAB_HOTMAIL_SERVERIDS;
    rgPropMap[3] = PR_WAB_HOTMAIL_MODTIMES;

    ZeroMemory(pContactInfo, sizeof(HTTPCONTACTINFO));

#ifdef HM_GROUP_SYNCING
    // [PaulHi] Set the contact type flag (mail user or group contact)
    if (ulObjectType == MAPI_DISTLIST)
    {
        // group contact
        pContactInfo->tyContact = HTTPMAIL_CT_GROUP;
        pWabContactInfo->ulContactType = HTTPMAIL_CT_GROUP;
    }
    else
    {
        // mail user contact
        pContactInfo->tyContact = HTTPMAIL_CT_CONTACT;
        pWabContactInfo->ulContactType = HTTPMAIL_CT_CONTACT;
    }
#endif

    for (i = 0; i < ulcProps; i++)
    {
        ulPropTag = lpaProps[i].ulPropTag;
        
        lIndex = _FindPropTag(ulPropTag);

#ifdef HM_GROUP_SYNCING
        if (lIndex >= 0 && lIndex != 2) // The index==2 array position is tyContact, which we set above.
#else
        if (lIndex >= 0)
#endif
        {
            Assert(lIndex < lSize);
            
            SafeCoMemFree(CIS_GETSTRING(pContactInfo, lIndex));

            switch (PROP_TYPE(ulPropTag))
            {
                case PT_TSTRING:
                    Assert(CIS_STRING == CIS_GETTYPE(lIndex));
                    if (CIS_GETSTRING(pContactInfo, lIndex))
                        SafeCoMemFree(CIS_GETSTRING(pContactInfo, lIndex));

                    lpszA = 
                        ConvertWtoA(lpaProps[i].Value.LPSZ);
                    CIS_GETSTRING(pContactInfo, lIndex) = _StrDup(lpszA);
                    LocalFreeAndNull(&lpszA);
                    if (!CIS_GETSTRING(pContactInfo, lIndex))
                    {
                        hr = E_OUTOFMEMORY;
                        goto exit;
                    }
                    break;

                case PT_SYSTIME:
                    Assert(CIS_STRING == CIS_GETTYPE(lIndex));
                    if (SUCCEEDED(FileTimeToiso8601((FILETIME *) (&lpaProps[i].Value.ft), szBuffer)))
                    {
                        CIS_GETSTRING(pContactInfo, lIndex) = _StrDup(szBuffer);
                        if (!CIS_GETSTRING(pContactInfo, lIndex))
                        {
                            hr = E_OUTOFMEMORY;
                            goto exit;
                        }
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                        goto exit;
                    }
                    if (PR_BIRTHDAY == ulPropTag && CIS_GETSTRING(pContactInfo, lIndex))
                    {
                        // fix it up to be a hotmail formatted date
                        _FixHotmailDate(CIS_GETSTRING(pContactInfo, lIndex));
                    }
                    break;

                case PT_MV_TSTRING:
                    if (ulPropTag == PR_WAB_HOTMAIL_SERVERIDS)
                        ulIndServerIDs = i;
                    else if (ulPropTag == PR_WAB_HOTMAIL_MODTIMES)
                        ulIndModtimes = i;
                    break;
            }
        }
        else
        {
            if (ulPropTag == PR_WAB_HOTMAIL_CONTACTIDS)
                ulIndContactIDs = i;
            else if (ulPropTag == PR_CONTACT_EMAIL_ADDRESSES)
                ulIndEmails = i;
            else if (ulPropTag == PR_CONTACT_DEFAULT_ADDRESS_INDEX)
                pWabContactInfo->dwEmailIndex = lpaProps[i].Value.ul;
#ifdef HM_GROUP_SYNCING
            else if ( (ulObjectType == MAPI_DISTLIST) && 
                      (ulPropTag == PR_WAB_DL_ENTRIES) || (ulPropTag == PR_WAB_DL_ONEOFFS) )
            {
                LPSTR   lpszNewEmailName = CIS_GETSTRING(pContactInfo, idcisEmail);
                hr = hrAppendGroupContact(pWabSync,
                                          ulPropTag,
                                          &lpaProps[i],
                                          &lpszNewEmailName);
                CIS_GETSTRING(pContactInfo, idcisEmail) = lpszNewEmailName;

                if (FAILED(hr))
                    goto exit;
            }
#endif
        }
    }

#ifdef HM_GROUP_SYNCING
    // [PaulHi] Group syncing.  HM group contact information consists only of an email and nickname.  
    // The WAB group display name becomes the HM group nickname.
    if (ulObjectType == MAPI_DISTLIST)
    {
        LPSTR   lpszDisplayName = CIS_GETSTRING(pContactInfo, idcisDisplayName);
        LPSTR   lpszNickName = CIS_GETSTRING(pContactInfo, idcisNickName);

        if (lpszDisplayName)
        {
            if (lpszNickName)
                CoTaskMemFree(lpszNickName);

            CIS_GETSTRING(pContactInfo, idcisDisplayName) = NULL;

            // [PaulHi]
            // A HM group nickname cannot contain certain characters.  So we remove all
            // invalid characters in the name string.  This change will be reflected 
            // in the WAB group name too (yuck).
            hrStripInvalidChars(lpszDisplayName);
            CIS_GETSTRING(pContactInfo,idcisNickName) = lpszDisplayName;
        }
    }
    else
#endif
    {
        // Likewise email contact nicknames cannot contain certain characters or
        // the post to HM server will fail.
        LPSTR   lpszNickName = CIS_GETSTRING(pContactInfo, idcisNickName);

        if (lpszNickName)
            hrStripInvalidChars(lpszNickName);
    }


    if (ulIndEmails != -1)
    {
        if (pWabContactInfo->pszaEmails)
            FreeMultiValueString(pWabContactInfo->pszaEmails);
        hr = CopyMultiValueString((SWStringArray *) (&lpaProps[ulIndEmails].Value.MVSZ), &pWabContactInfo->pszaEmails);
    }    

    // If we have the indexes to all of the multivalues that we care about,
    // try to get the appropriate values for the current identity.
    if (ulIndContactIDs != -1 && ulIndModtimes != -1 && ulIndServerIDs != -1)
    {
        ULONG   ulMVIndex = -1;
        UNALIGNED LPTSTR  *lppszValues;
        TCHAR   szFullProfile[MAX_PATH];

        // [PaulHi]  Assemble the contact ID string
        hr = hrMakeContactId(
            szFullProfile,
            MAX_PATH,
            ((LPIAB)(pWabSync->m_pAB))->szProfileID,
            pWabSync->m_pszAccountId,
            pWabSync->m_szLoginName);
        if (FAILED(hr))
            goto exit;

        // sanity check, all three multi values must contain the same number
        // of values.  If not they are out of sync and not to be trusted.

        if (lpaProps[ulIndContactIDs].Value.MVSZ.cValues != lpaProps[ulIndModtimes].Value.MVSZ.cValues ||
            lpaProps[ulIndModtimes].Value.MVSZ.cValues != lpaProps[ulIndServerIDs].Value.MVSZ.cValues)
        {
            Assert(FALSE);
            goto exit;
        }

        if (pWabContactInfo->pszaContactIds)
            FreeMultiValueString(pWabContactInfo->pszaContactIds);
        hr = CopyMultiValueString((SWStringArray *) (&lpaProps[ulIndContactIDs].Value.MVSZ), &pWabContactInfo->pszaContactIds);
        
        if (pWabContactInfo->pszaServerIds)
            FreeMultiValueString(pWabContactInfo->pszaServerIds);
        hr = CopyMultiValueString((SWStringArray *) (&lpaProps[ulIndServerIDs].Value.MVSZ), &pWabContactInfo->pszaServerIds);

        if (pWabContactInfo->pszaModtimes)
            FreeMultiValueString(pWabContactInfo->pszaModtimes);
        hr = CopyMultiValueString((SWStringArray *) (&lpaProps[ulIndModtimes].Value.MVSZ), &pWabContactInfo->pszaModtimes);

        if (PROP_TYPE(lpaProps[ulIndContactIDs].ulPropTag) == PT_MV_TSTRING)
        {
            lppszValues = lpaProps[ulIndContactIDs].Value.MVSZ.LPPSZ;
            
            // find the index for this identity
            for (i = 0; i < lpaProps[ulIndContactIDs].Value.MVSZ.cValues; i++)
            {
                if (lstrcmp(szFullProfile, lppszValues[i]) == 0)
                {
                    ulMVIndex = i;
                    break;
                }
            }

            if (ulMVIndex != -1)
            {
                ULONG ulLen;
                LPSTR lpVal = NULL;
                lpVal = ConvertWtoA(lpaProps[ulIndServerIDs].Value.MVSZ.LPPSZ[ulMVIndex]);
                //Copy the values for this identity to the structure
                pContactInfo->pszId = _StrDup(lpVal);
                LocalFreeAndNull(&lpVal);
                if (!pContactInfo->pszId)
                {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }

                lpVal = ConvertWtoA(lpaProps[ulIndModtimes].Value.MVSZ.LPPSZ[ulMVIndex]);
                pContactInfo->pszModified = _StrDup(lpVal);
                LocalFreeAndNull(&lpVal);
                if (!pContactInfo->pszModified)
                {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }
            }
        }
    }

exit:
    if (FAILED(hr))
    {
        ContactInfo_Free(pContactInfo);
    }

    return hr;
}



HRESULT ContactInfo_SaveToWAB(LPWABSYNC pWabSync, 
                              LPHTTPCONTACTINFO pContactInfo, 
                              LPWABCONTACTINFO pWabContactInfo,
                              LPENTRYID   lpEntryID, 
                              ULONG cbEntryID,
                              BOOL  fDeleteProps)
{
    LPENTRYID       pEntryID = NULL;
    ULONG           cbLocEntryID = 0;
    HRESULT         hr;
    LPMAILUSER      lpMailUser = NULL;   
    LPSPropValue    lpaProps = NULL;
    ULONG           ulcProps = 0;
    ULONG           ulObjectType;
    SCODE           sc;
    SBinary         sBinary;
    ULONG           uli;

    Assert(pWabSync);
    Assert(pContactInfo);
    Assert(pWabSync->m_pAB);

    if (HR_FAILED(hr = pWabSync->m_pAB->lpVtbl->GetPAB(pWabSync->m_pAB, &sBinary.cb, (LPENTRYID*)&sBinary.lpb)))
    {
        DebugPrintError(( TEXT("GetPAB Failed\n")));
        goto out;
    }
    
    Assert(sBinary.lpb);

    if (lpEntryID)
    {
        if (HR_FAILED(hr = pWabSync->m_pAB->lpVtbl->OpenEntry(pWabSync->m_pAB, cbEntryID,     // size of EntryID to open
                                                lpEntryID,    // EntryID to open
                                                NULL,         // interface
                                                MAPI_MODIFY,  // flags
                                                &ulObjectType,
                                                (LPUNKNOWN *) &lpMailUser)))
        {
            DebugPrintError(( TEXT("OpenEntry Failed\n")));
            goto out;
        }
    }
    else
    {
#ifdef HM_GROUP_SYNCING
        ULONG   ulObjectType = (pWabSync->m_fSyncGroups) ? MAPI_DISTLIST : MAPI_MAILUSER;
#else
        ULONG   ulObjectType = MAPI_MAILUSER;
#endif

        fDeleteProps = FALSE;
        if (HR_FAILED(hr = HrCreateNewObject(pWabSync->m_pAB, 
                                             &sBinary, 
                                             ulObjectType,
                                             CREATE_CHECK_DUP_STRICT, 
                                             (LPMAPIPROP *) &lpMailUser)))
        {
            DebugPrintError(( TEXT("HRCreateNewObject Failed\n")));
            goto out;
        }
    }

    Assert(lpMailUser);
        
    //Add one for the contact's identity id
    ulcProps = ContactInfo_CountProperties(pContactInfo) + 1;

    // make room for PR_CONTACT_DEFAULT_ADDRESS_INDEX and PR_CONTACT_EMAIL_ADDRESSES 
    // if we have the data to put in them
    if (pWabContactInfo && pWabContactInfo->pszaEmails && CIS_GETSTRING(pContactInfo, idcisEmail))
        ulcProps += 2;

    // [PaulHi] @review  1/21/99
    // make room for PR_WAB_HOTMAIL_SERVERIDS and PR_WAB_HOTMAIL_MODTIMES
    // This part is ugly - only if these have not already been accounted for in pContactInfo
    if (pWabContactInfo && pWabContactInfo->pszaContactIds)
    {
        if (!pContactInfo->pszModified)
            ulcProps += 1;
        if (!pContactInfo->pszId)
            ulcProps += 1;
    }

    // Allocate a new buffer for the MAPI property array.
    sc = MAPIAllocateBuffer(ulcProps * sizeof(SPropValue),
                            (LPVOID *)&lpaProps);
    if (sc)
    {
        hr = ResultFromScode(sc);
        goto out;
    }

    // Initialize the Property array
    ZeroMemory(lpaProps, (ulcProps*sizeof(SPropValue)));
    for (uli=0; uli<ulcProps; uli++)
        lpaProps[uli].ulPropTag = PR_NULL;

    if(HR_FAILED(hr = ContactInfo_TranslateProps(pWabSync, pContactInfo, pWabContactInfo, lpaProps)))
    {
        DebugPrintError(( TEXT("ContactInfo_TranslateProps Failed\n")));
        goto out;
    }

    // Set the old guys props on the new guy - note that this overwrites any common props on 
    // potential duplicates when calling savechanges
    if(HR_FAILED(hr = lpMailUser->lpVtbl->SetProps(lpMailUser, ulcProps, lpaProps, NULL)))
    {
        DebugPrintError(( TEXT("SetProps Failed\n")));
        goto out;
    }

    if (fDeleteProps)
    {
        SizedSPropTagArray(ARRAYSIZE(rgPropMap), rgRemoveProps) = {0};

        ContactInfo_DetermineDeleteProps(pContactInfo, (LPSPropTagArray)&rgRemoveProps);

        if (rgRemoveProps.cValues > 0)
            hr = lpMailUser->lpVtbl->DeleteProps(lpMailUser, (LPSPropTagArray)&rgRemoveProps, NULL);
    }

    // SaveChanges
    if(HR_FAILED(hr = lpMailUser->lpVtbl->SaveChanges(lpMailUser, KEEP_OPEN_READONLY)))
    {
        DebugPrintError(( TEXT("SaveChanges Failed\n")));

        if (!lpEntryID && HR_FAILED(hr = ContactInfo_BlendNewContact(pWabSync, pContactInfo)))
            DebugPrintError(( TEXT("ContactInfo_BlendNewContact Failed\n")));
        goto out;
    }

out:
    if (sBinary.lpb)
    	MAPIFreeBuffer(sBinary.lpb);

    if (lpMailUser)
        UlRelease(lpMailUser);

    if (lpaProps)
        MAPIFreeBuffer(lpaProps);

    return hr;
}

HRESULT ContactInfo_BlendNewContact(LPWABSYNC pWabSync, 
                                    LPHTTPCONTACTINFO pContactInfo)
{
    LPSPropValue    lpaProps = NULL;
    SizedADRLIST(1, rAdrList) = {0};
    SCODE           sc;
    HRESULT         hr = S_OK;
    DWORD           cbValue;
    DWORD           cCount = 0;
    ULONG           j = 0;

    if (pContactInfo->pszDisplayName)
        cCount++;

    if (pContactInfo->pszEmail)
        cCount++;

    if (!cCount)
        return MAPI_E_INVALID_PARAMETER;

    // Allocate a new buffer for the MAPI property array.
    sc = MAPIAllocateBuffer(cCount * sizeof(SPropValue),
                            (LPVOID *)&lpaProps);
    if (sc)
    {
        hr = ResultFromScode(sc);
        goto out;
    }

    cCount = 0;
    if (pContactInfo->pszDisplayName)
    {
        lpaProps[cCount].ulPropTag = PR_DISPLAY_NAME;
        lpaProps[cCount].dwAlignPad = 0;
        if(sc = ScAnsiToWCMore((LPALLOCATEMORE )(&MAPIAllocateMore),(LPVOID) lpaProps, (LPSTR) pContactInfo->pszDisplayName, (LPWSTR *) (&(lpaProps[cCount].Value.LPSZ))))
            goto out;
        cCount++;
    }
  
    if (pContactInfo->pszEmail)
    {
        lpaProps[cCount].ulPropTag = PR_EMAIL_ADDRESS;
        lpaProps[cCount].dwAlignPad = 0;
        if(sc = ScAnsiToWCMore((LPALLOCATEMORE )(&MAPIAllocateMore),(LPVOID) lpaProps, (LPSTR) pContactInfo->pszEmail,(LPWSTR *) (&(lpaProps[cCount].Value.LPSZ))))
            goto out;
        cCount++;
    }

    rAdrList.cEntries = 1;
    rAdrList.aEntries[0].cValues = cCount;
    rAdrList.aEntries[0].rgPropVals = lpaProps;

    hr = pWabSync->m_pAB->lpVtbl->ResolveName(pWabSync->m_pAB, (ULONG_PTR)pWabSync->m_hWnd, 
                WAB_RESOLVE_LOCAL_ONLY | WAB_RESOLVE_USE_CURRENT_PROFILE,
                 TEXT(""), (LPADRLIST)(&rAdrList));

    lpaProps = NULL;        //it was freed in ResolveName (!)

    if (HR_FAILED(hr))
        goto out;

    for(j=0; j<rAdrList.aEntries[0].cValues; j++)
    {
        if(rAdrList.aEntries[0].rgPropVals[j].ulPropTag == PR_ENTRYID && 
            rAdrList.aEntries[0].rgPropVals[j].Value.bin.lpb)
        {
            hr = ContactInfo_SaveToWAB(pWabSync, 
                                    pContactInfo, 
                                    NULL,
                                    (LPENTRYID)rAdrList.aEntries[0].rgPropVals[j].Value.bin.lpb, 
                                    rAdrList.aEntries[0].rgPropVals[j].Value.bin.cb,
                                    FALSE);
            break;
        }
    }

    for (j = 0; j < rAdrList.cEntries; j++)
        MAPIFreeBuffer(rAdrList.aEntries[j].rgPropVals);

out:

    if (lpaProps)
        MAPIFreeBuffer(lpaProps);
    
    return hr;
}

void UpdateSynchronizeMenus(HMENU hMenu, LPIAB lpIAB)
{
    DWORD           cItems, dwIndex;
    MENUITEMINFO    mii;
    TCHAR           szLogoffString[255];
    TCHAR           szRes[255];

    if (!IsHTTPMailEnabled(lpIAB))
    {
        // loop through the other menu items looking for logoff
        cItems = GetMenuItemCount(hMenu);
    
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID;

        for (dwIndex = cItems; dwIndex > 0; --dwIndex)
        {
            GetMenuItemInfo(hMenu, dwIndex, TRUE, &mii);

            // if this is the logoff item, delete it and the separator 
            // line that follows
            if (mii.wID == IDM_TOOLS_SYNCHRONIZE_NOW)
            {
                DeleteMenu(hMenu, dwIndex - 1, MF_BYPOSITION);
                DeleteMenu(hMenu, IDM_TOOLS_SYNCHRONIZE_NOW, MF_BYCOMMAND);
                break;
            }
        }
    }
    else
    {
        // if there are no http mail accounts, disable the menu item
        if (CountHTTPMailAccounts(lpIAB) == 0)
            EnableMenuItem(hMenu, IDM_TOOLS_SYNCHRONIZE_NOW, MF_BYCOMMAND | MF_GRAYED);
    }
}

HRESULT ContactInfo_LoadFromWAB(LPWABSYNC pWabSync, 
                              LPHTTPCONTACTINFO pContactInfo,
                              LPWABCONTACTINFO  pWabContact,
                              LPENTRYID   lpEntryID, 
                              ULONG cbEntryID)
{
    LPENTRYID       pEntryID = NULL;
    ULONG           cbLocEntryID = 0;
    HRESULT         hr;
    LPMAILUSER      lpMailUser = NULL;   
    LPSPropValue    lpaProps = NULL;
    ULONG           ulcProps = 0;
    ULONG           ulObjectType;
    SCODE           sc;

    Assert(pWabSync);
    Assert(pContactInfo);
    Assert(lpEntryID);
    Assert(pWabSync->m_pAB);

    if(HR_FAILED(hr = pWabSync->m_pAB->lpVtbl->OpenEntry(pWabSync->m_pAB, cbEntryID, lpEntryID, NULL, 0, &ulObjectType, (LPUNKNOWN *) &lpMailUser)))
    {
        DebugPrintError(( TEXT("OpenEntry Failed\n")));
        goto out;
    }
    
    if(HR_FAILED(hr = lpMailUser->lpVtbl->GetProps(lpMailUser, (LPSPropTagArray)(&ptaEidCSync), MAPI_UNICODE, 
        &ulcProps, &lpaProps)))
    {
        DebugPrintError(( TEXT("GetProps Failed\n")));
        goto out;
    }

    if (HR_FAILED(hr = ContactInfo_PopulateProps(pWabSync, pContactInfo, pWabContact, lpaProps, ulcProps, ulObjectType)))
    {
        DebugPrintError(( TEXT("ContactInfo_PopulateProps Failed\n")));
        goto out;
    }

#ifdef HM_GROUP_SYNCING
    // [PaulHi] Group sync.  Don't break out a group display name
    if ( (pContactInfo->tyContact == HTTPMAIL_CT_CONTACT) && pContactInfo->pszDisplayName && 
         (!pContactInfo->pszGivenName || !pContactInfo->pszSurname) )
#else
    if ( pContactInfo->pszDisplayName && (!pContactInfo->pszGivenName || !pContactInfo->pszSurname) )
#endif
    {
        LPVOID  pBuffer;
        LPTSTR  pszFirstName = NULL, pszLastName = NULL;
        LPTSTR  lpName = 
                    ConvertAtoW(pContactInfo->pszDisplayName);
        if (ParseDisplayName(lpName, &pszFirstName, &pszLastName, NULL, &pBuffer))
        {
            LPSTR lp = NULL;
            if (pszFirstName && !pContactInfo->pszGivenName)
            {
                lp = ConvertWtoA(pszFirstName);
                pContactInfo->pszGivenName = _StrDup(lp);
                LocalFreeAndNull(&lp);
            }
            if (pszLastName && !pContactInfo->pszSurname)
            {
                lp = ConvertWtoA(pszLastName);
                pContactInfo->pszSurname = _StrDup(lp);
                LocalFreeAndNull(&lp);
            }

            LocalFree(pBuffer);
        }
        LocalFreeAndNull(&lpName);
    }
            
out:
    if (lpMailUser)
        UlRelease(lpMailUser);

    if (lpaProps)
        MAPIFreeBuffer(lpaProps);

    return hr;
}


static BOOL _IsLegitNicknameChar(TCHAR ch)
{
    if (ch >= 'A' && ch <= 'Z')
        return TRUE;
    if (ch >= 'a' && ch <= 'z')
        return TRUE;
    if (ch >= '0' && ch <= '9')
        return TRUE;
    if (ch == '-' || ch == '_')
        return TRUE;
    return FALSE;
}

HRESULT ContactInfo_GenerateNickname(LPHTTPCONTACTINFO pContactInfo)
{
    HRESULT hr = S_OK;
    LPSTR   pszStr;

    if (NULL == pContactInfo->pszNickname)
    {
        if (pContactInfo->pszEmail)
        {
            pContactInfo->pszNickname = _StrDup(pContactInfo->pszEmail);
        }
        else if (pContactInfo->pszDisplayName)
        {
            pContactInfo->pszNickname = _StrDup(pContactInfo->pszDisplayName);
        }
        else 
        {
            char szNickname[25], szFmt[25];
            
            LoadStringA(hinstMapiX, idsNicknameFmt, szFmt, sizeof(szFmt));
            if (*szFmt == 0)
                lstrcpyA(szFmt,  "Nickname%d");

//            wsprintfA(szNickname, szFmt, ((DWORD)pContactInfo & 0x0000ffff));
            wsprintfA(szNickname, szFmt, ((DWORD)GetTickCount() & 0x0000FFFF));
            pContactInfo->pszNickname = _StrDup(szNickname);
        }

        if (!pContactInfo->pszNickname)
            return E_OUTOFMEMORY;

        pszStr = pContactInfo->pszNickname;
        while (*pszStr)
        {
            // e-mail address should be unique enough...(?)
            if (*pszStr == '@')
            {
                *pszStr = 0;
                break;
            }

            if (!_IsLegitNicknameChar(*pszStr))
                *pszStr = '_';
            
            pszStr++;
        }
    }
    else
    {
        char szNickname[25], szFmt[25];
        
        SafeCoMemFree(pContactInfo->pszNickname);
        LoadStringA(hinstMapiX, idsNicknameFmt, szFmt, sizeof(szFmt));
        if (*szFmt == 0)
            lstrcpyA(szFmt,  "Nickname%d");

//        wsprintfA(szNickname, szFmt, ((DWORD)pContactInfo & 0x0000ffff));
        wsprintfA(szNickname, szFmt, ((DWORD)GetTickCount() & 0x0000FFFF));
        pContactInfo->pszNickname = _StrDup(szNickname);
    }
    
    return hr;
}


BOOL ContactInfo_Match(LPHTTPCONTACTINFO pciServer, LPHTTPCONTACTINFO pciClient)
{
    LONG    i, lSize = ARRAYSIZE(g_ContactInfoStructure);
    BOOL    fResult = TRUE;

    if (!pciServer)
        return FALSE;

    if (!pciClient) 
        return FALSE;

    for (i = CIS_FIRST_DATA_FIELD; i < lSize; i ++)
    {
        if (CIS_GETSTRING(pciServer, i) && CIS_GETSTRING(pciClient, i))
        {
            if (lstrcmpA(CIS_GETSTRING(pciServer, i), CIS_GETSTRING(pciClient, i)))
                return FALSE;
        }
        else if (CIS_GETSTRING(pciServer, i) || CIS_GETSTRING(pciClient, i))
        {
            if (idcisNickName == i && CIS_GETSTRING(pciServer, i))
                fResult = FALSE;
            else
                return FALSE;
        }
    }

    // if the only reason they don't match is the lack of local nickname and 
    // there is a server one, just copy the nickname locally
    if (!fResult)
    {
        CIS_GETSTRING(pciClient, idcisNickName) = _StrDup(CIS_GETSTRING(pciServer, idcisNickName));
        fResult = TRUE;
    }
    return fResult;
}

HRESULT ContactInfo_PreparePatch(LPHTTPCONTACTINFO pciFrom, LPHTTPCONTACTINFO pciTo)
{
    HRESULT hr = S_OK;
    LONG    i, lSize = ARRAYSIZE(g_ContactInfoStructure);
    
    for (i = CIS_FIRST_DATA_FIELD; i < lSize; i ++)
    {
        if (CIS_GETSTRING(pciFrom, i) && !CIS_GETSTRING(pciTo, i))
        {
            CIS_GETSTRING(pciTo, i) = _StrDup("");
            if (!CIS_GETSTRING(pciTo, i))
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
        }

        if (CIS_GETSTRING(pciFrom, i) && CIS_GETSTRING(pciTo, i) && lstrcmpA(CIS_GETSTRING(pciFrom, i), CIS_GETSTRING(pciTo, i)) == 0)
            SafeCoMemFree(CIS_GETSTRING(pciTo, i));
    }
exit:
    return hr;
}

HRESULT ContactInfo_EmptyNullItems(LPHTTPCONTACTINFO pci)
{
    HRESULT hr = S_OK;
    LONG    i, lSize = ARRAYSIZE(g_ContactInfoStructure);

    for (i = CIS_FIRST_DATA_FIELD; i < lSize; i ++)
    {
        if (CIS_GETSTRING(pci, i) == NULL)
            CIS_GETSTRING(pci, i) = _StrDup("");
    }
    return S_OK;
}


HRESULT ContactInfo_BlendResults(LPHTTPCONTACTINFO pciServer, LPHTTPCONTACTINFO pciClient, CONFLICT_DECISION *prgDecisions)
{
    HRESULT hr = S_OK;
    LONG    i, lSize = ARRAYSIZE(g_ContactInfoStructure);
    
    for (i = CIS_FIRST_DATA_FIELD; i < lSize; i ++)
    {
        if (prgDecisions[i] == CONFLICT_SERVER)
        {
            SafeCoMemFree(CIS_GETSTRING(pciClient, i) );
            if (CIS_GETSTRING(pciServer, i))
            {
                CIS_GETSTRING(pciClient, i) = _StrDup(CIS_GETSTRING(pciServer, i));
                SafeCoMemFree(CIS_GETSTRING(pciServer, i));
            }
            else
                CIS_GETSTRING(pciClient, i) = _StrDup("");
        }
        else if (prgDecisions[i] == CONFLICT_CLIENT)
        {
            SafeCoMemFree(CIS_GETSTRING(pciServer, i));
            if (CIS_GETSTRING(pciClient, i))
                CIS_GETSTRING(pciServer, i) = _StrDup(CIS_GETSTRING(pciClient, i));
            else
                CIS_GETSTRING(pciServer, i) = _StrDup("");
        }
        else
        {
            SafeCoMemFree(CIS_GETSTRING(pciClient, i));
            SafeCoMemFree(CIS_GETSTRING(pciServer, i));
        }
    }

    return hr;
}





INT_PTR CALLBACK SyncProgressDlgProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    LPWABSYNC   pWabSync = (LPWABSYNC)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    switch (uMsg)
    {
        case WM_INITDIALOG:
            pWabSync = (LPWABSYNC)lParam;
            if (!pWabSync)
            {
                Assert (FALSE);
                return 1;
            }
#ifdef HM_GROUP_SYNCING
            // [PaulHi] Implement group syncing.  Identify what is currently
            // being synchronized, email contacts or groups.
            {
                TCHAR   rgtchCaption[MAX_PATH];
                UINT    uids = pWabSync->m_fSyncGroups ? idsSyncGroupsTitle : idsSyncContactsTitle;
                    
                rgtchCaption[0] = '\0';
                LoadString(hinstMapiX, uids, rgtchCaption, MAX_PATH-1);
                SetWindowText(hwnd, rgtchCaption);
            }
#endif
            CenterDialog (hwnd);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM) pWabSync);
            return 1;

        case WM_SYNC_NEXTSTATE:
            _WABSync_NextState(pWabSync);
            break;

        case WM_SYNC_NEXTOP:
            if (!_WABSync_NextOp(pWabSync, (0 != wParam)))
                WABSync_NextState(pWabSync);
            break;

        case WM_TIMER:
            break;

        case WM_COMMAND:
            switch(GET_WM_COMMAND_ID(wParam,lParam))
            {
                case IDCANCEL:
                    if (pWabSync)
                    {
                        EnableWindow ((HWND)lParam, FALSE);
                        WABSync_Abort(pWabSync, E_UserCancel);
                    }
                    return 1;
            }
            break;

        case WM_DESTROY:
//            KillTimer(hwnd, IDT_PROGRESS_DELAY);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM) NULL);
            break;
    }

    // Done
    return 0;
}

HRESULT CopyMultiValueString(
                             SWStringArray *pInArray,
                             SLPSTRArray **ppOutArray)
{
    SLPSTRArray    *pResult = NULL;
    SCODE           sc;
    HRESULT         hr;
    DWORD           i, cb;

    *ppOutArray = NULL;

    sc = MAPIAllocateBuffer(sizeof(SLPSTRArray),
                            (LPVOID *)&pResult);
    if (sc)
        goto fail;

    pResult->cValues = pInArray->cValues;
    
    sc = MAPIAllocateMore(sizeof(LPSTR) * pResult->cValues, pResult,
      (LPVOID *)&(pResult->lppszA));
    if (sc)
        goto fail;

    for (i = 0; i < pResult->cValues; i ++)
    {
        if(sc = ScWCToAnsiMore((LPALLOCATEMORE ) (&MAPIAllocateMore),(LPVOID) pResult, (LPWSTR) pInArray->LPPSZ[i], (LPSTR *) (&(pResult->lppszA[i]))))
            goto fail;
    }
    
    *ppOutArray = pResult;
    return S_OK;

fail:
    hr = ResultFromScode(sc);
    FreeMultiValueString(pResult);

    return hr;
}

HRESULT AppendToMultiValueString(SLPSTRArray *pInArray, LPSTR szStr)
{   
    LPSTR          *ppStrA;
    SCODE           sc;
    HRESULT         hr;
    DWORD           i, cb;

    ppStrA = pInArray->lppszA;
    sc = MAPIAllocateMore(sizeof(LPSTR) * (pInArray->cValues + 1), pInArray,
      (LPVOID *)&(pInArray->lppszA));
    if (sc)
    {   
        pInArray->lppszA = ppStrA;
        goto fail;
    }

    CopyMemory(pInArray->lppszA, ppStrA, pInArray->cValues * sizeof(LPSTR));

    cb = lstrlenA(szStr);

    sc = MAPIAllocateMore(cb + 1, pInArray,
      (LPVOID *)&(pInArray->lppszA[pInArray->cValues]));
    if (sc)
        goto fail;

    lstrcpyA(pInArray->lppszA[pInArray->cValues], szStr);
    pInArray->cValues++;
    return S_OK;

fail:
    hr = ResultFromScode(sc);
    return hr;
}

HRESULT SetMultiValueStringValue(SLPSTRArray *pInArray, LPSTR szStr, DWORD dwIndex)
{   
    LPSTR          *ppStrA;
    SCODE           sc;
    HRESULT         hr;
    DWORD           i, cb;

    if (dwIndex >= pInArray->cValues)
        return E_FAIL;

    ppStrA = pInArray->lppszA;

    cb = lstrlenA(szStr);

    sc = MAPIAllocateMore(cb + 1, pInArray,
      (LPVOID *)&(pInArray->lppszA[dwIndex]));
    if (sc)
        goto fail;

    lstrcpyA(pInArray->lppszA[dwIndex], szStr);
    return S_OK;

fail:
    hr = ResultFromScode(sc);
    return hr;
}


HRESULT FreeMultiValueString(SLPSTRArray *pInArray)
{
    if (pInArray)
        MAPIFreeBuffer(pInArray);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\image.h ===
#ifndef __image_h_
#define __image_h_

BOOL LoadBitmapAndPalette(int idbmp, HBITMAP *phbmp, HPALETTE *phpal);
HIMAGELIST InitImageList(int cx, int cy, LPSTR szbm, int cicon);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\globals.h ===
/*  
*   globals.h

    Various globals used everywhere in the WAB
    
*/


// Note most of the Enums below are closely tied to the static arrasy
// in globals.c
//

enum {
    ircPR_DISPLAY_NAME = 0,
    ircPR_DISPLAY_TYPE,
    ircPR_ENTRYID,
    ircPR_INSTANCE_KEY,
    ircPR_OBJECT_TYPE,
    ircPR_RECORD_KEY,
    ircPR_ROWID,
    ircPR_DEPTH,
    ircPR_CONTAINER_FLAGS,
    ircPR_WAB_LDAP_SERVER,
    ircPR_WAB_RESOLVE_FLAG,
    ircPR_AB_PROVIDER_ID,
    ircMax
};

//
// Default set of properties to return from a ResolveNames.
// May be overridden by passing in lptagaColSet to ResolveNames.
//
enum {
    irdPR_ADDRTYPE = 0,
    irdPR_DISPLAY_NAME,
    irdPR_EMAIL_ADDRESS,
    irdPR_ENTRYID,
    irdPR_OBJECT_TYPE,
    irdPR_SEARCH_KEY,
    irdPR_RECORD_KEY,
    irdPR_SURNAME,
    irdPR_GIVEN_NAME,
    irdPR_INSTANCE_KEY,
    irdPR_SEND_INTERNET_ENCODING,
    irdMax
};


//  PR_WAB_DL_ENTRIES proptag array
//
enum {
    iwdesPR_WAB_DL_ENTRIES,
    iwdesMax
};

//
// LDAP server name properties
//
enum {
    ildapcPR_WAB_LDAP_SERVER,
    ildapcMax
};


//
// Properties to get for each container in a Resolve
//
enum {
    irnPR_OBJECT_TYPE = 0,
    irnPR_WAB_RESOLVE_FLAG,
    irnPR_ENTRYID,
    irnPR_DISPLAY_NAME,
    irnMax
};

//
// container default properties
// Put essential props first
//
enum {
    ivPR_DISPLAY_NAME,
    ivPR_SURNAME,
    ivPR_GIVEN_NAME,
    ivPR_OBJECT_TYPE,
    ivPR_EMAIL_ADDRESS,
    ivPR_ADDRTYPE,
    ivPR_CONTACT_EMAIL_ADDRESSES,
    ivPR_CONTACT_ADDRTYPES,
    ivPR_MIDDLE_NAME,
    ivPR_COMPANY_NAME,
    ivPR_NICKNAME,
    ivMax
};


enum {
    icrPR_DEF_CREATE_MAILUSER = 0,
    icrPR_DEF_CREATE_DL,
    icrMax
};

// enum for getting the entryid of an entry
enum {
    ieidPR_DISPLAY_NAME = 0,
    ieidPR_ENTRYID,
    ieidMax
};


enum {
    itcPR_ADDRTYPE = 0,
    itcPR_DISPLAY_NAME,
    itcPR_DISPLAY_TYPE,
    itcPR_ENTRYID,
    itcPR_INSTANCE_KEY,
    itcPR_OBJECT_TYPE,
    itcPR_EMAIL_ADDRESS,
    itcPR_RECORD_KEY,
    itcPR_NICKNAME,
    //itcPR_WAB_THISISME,
    itcMax
};



#ifndef _GLOBALS_C
#define ExternSizedSPropTagArray(_ctag, _name) \
extern const struct _SPropTagArray_ ## _name \
{ \
    ULONG   cValues; \
    ULONG   aulPropTag[_ctag]; \
} _name


ExternSizedSPropTagArray(ircMax, ITableColumnsRoot);
ExternSizedSPropTagArray(irdMax, ptaResolveDefaults);
ExternSizedSPropTagArray(itcMax, ITableColumns);
ExternSizedSPropTagArray(iwdesMax, tagaDLEntriesProp);
ExternSizedSPropTagArray(ildapcMax, ptaLDAPCont);
ExternSizedSPropTagArray(irnMax, irnColumns);
ExternSizedSPropTagArray(ivMax, tagaValidate);
ExternSizedSPropTagArray(icrMax, ptaCreate);
ExternSizedSPropTagArray(ieidMax, ptaEid);

// [PaulHi] 2/25/99  ANSI versions
ExternSizedSPropTagArray(itcMax, ITableColumns_A);

#endif

extern const ULONG rgIndexArray[indexMax];
extern const int lprgAddrBookColHeaderIDs[NUM_COLUMNS];
//extern HANDLE hMuidMutex;

// External memory allocators (passed in on WABOpenEx)
extern int g_nExtMemAllocCount;
extern ALLOCATEBUFFER * lpfnAllocateBufferExternal;
extern ALLOCATEMORE * lpfnAllocateMoreExternal;
extern FREEBUFFER * lpfnFreeBufferExternal;
extern LPUNKNOWN pmsessOutlookWabSPI;
extern LPWABOPENSTORAGEPROVIDER lpfnWABOpenStorageProvider;

// registry key constants
extern LPCTSTR lpNewWABRegKey;
extern LPCTSTR lpRegUseOutlookVal;


/*
- The following IDs and tags are for the conferencing named properties
-
-   The GUID for these props is PS_Conferencing
-   This GUID is actually the same GUID used by outlook internally for 
-   it's named properties.
*/
DEFINE_OLEGUID(PS_Conferencing, 0x00062004, 0, 0);

enum _ConferencingTags
{
    prWABConfServers = 0,
    prWABConfDefaultIndex,
    prWABConfBackupIndex,
    prWABConfEmailIndex,
    prWABConfMax
};

#define CONF_SERVERS        0x8056
#define CONF_DEFAULT_INDEX  0x8057
#define CONF_SERVER_INDEX   0x8058
#define CONF_EMAIL_INDEX    0x8059

#define OLK_NAMEDPROPS_START CONF_SERVERS

ULONG PR_WAB_CONF_SERVERS;      // Multivalued String property that saves unique server related data
ULONG PR_WAB_CONF_DEFAULT_INDEX;// Points to which entry in the SERVERS prop is the default
ULONG PR_WAB_CONF_BACKUP_INDEX; // Points to which entry is the Backup
ULONG PR_WAB_CONF_EMAIL_INDEX;  // NOT USED anymore

SizedSPropTagArray(prWABConfMax, ptaUIDetlsPropsConferencing);

/*
- The following IDs and tags are for the Yomigana named properties
-
-   The GUID for these props is PS_YomiProps (which is again the same
-   guid as the one used by Outlook)
*/
#define PS_YomiProps    PS_Conferencing

#define dispidYomiFirstName     0x802C
#define dispidYomiLastName      0x802D
#define dispidYomiCompanyName   0x802E

#define OLK_YOMIPROPS_START dispidYomiFirstName

enum _YomiTags
{
    prWABYomiFirst = 0,
    prWABYomiLast,
    prWABYomiCompany,
    prWABYomiMax
};

ULONG PR_WAB_YOMI_FIRSTNAME;    // PT_TSTRING
ULONG PR_WAB_YOMI_LASTNAME;     // PT_TSTRING
ULONG PR_WAB_YOMI_COMPANYNAME;  // PT_TSTRING

/*
- The following IDs and tags are for defining the default Mailing Address
-
-   The GUID for these props is PS_PostalAddressID (which is the same as
-   the Outlook GUID)
*/
#define PS_PostalAddressID    PS_Conferencing

#define dispidPostalAddressId   0x8022

#define OLK_POSTALID_START dispidPostalAddressId

enum _PostalIDTags
{
    prWABPostalID = 0,
    prWABPostalMax
};

ULONG PR_WAB_POSTALID; // PT_LONG

// The values for the default Postal ID can only be one of the following
//
enum _PostalIDVal
{
    ADDRESS_NONE = 0, 
    ADDRESS_HOME, 
    ADDRESS_WORK, 
    ADDRESS_OTHER
};


/*
- The following IDs and tags are for the internally used WAB
-
-   The GUID for these props is MPSWab_GUID_V4
*/
ULONG PR_WAB_USER_PROFILEID;        // PT_TSTRING:  Profile ID of a user
ULONG PR_WAB_USER_SUBFOLDERS;       // PT_MVBINARY: List of subfolders that belong to a particular user
ULONG PR_WAB_HOTMAIL_CONTACTIDS;    // PT_MVTSTRING:IDs of Contacts as represented on the Hotmail Server 
ULONG PR_WAB_HOTMAIL_MODTIMES;      // PT_MV_TSTRING: Last modification time for the entry
ULONG PR_WAB_HOTMAIL_SERVERIDS;     // PT_MV_TSTRING: Identifies the Hotmail server
ULONG PR_WAB_DL_ONEOFFS;            // PT_MV_BINARY:Prop used for storing one-off entries as part of a DL
ULONG PR_WAB_IPPHONE;               // PT_TSTRING: Prop used for holding the IP_PHONE property (used to make TAPI happy)
ULONG PR_WAB_FOLDER_PARENT;         // PT_BINARY: EID of the Folder to which a contact belongs
ULONG PR_WAB_SHAREDFOLDER;          // PT_LONG:   BOOL that determines if a subfolder is shared or not
ULONG PR_WAB_FOLDEROWNER;           // PT_TSTRING: String containing GUID of user who creates a folder ..

#define FOLDER_PRIVATE          0x00000000 // values for PR_WAB_SHAREDFOLDER
#define FOLDER_SHARED           0x00000001

#define USER_PROFILEID          0X8001
#define USER_SUBFOLDERS         0x8002
#define HOTMAIL_CONTACTIDS      0x8003
#define HOTMAIL_MODTIMES        0x8004
#define HOTMAIL_SERVERIDS       0x8005
#define DL_ONEOFFS              0x8006
#define IPPHONE                 0x8007
#define FOLDERPARENT            0x8008
#define SHAREDFOLDER            0x8009
#define FOLDEROWNER             0x800a

#define WAB_NAMEDPROPS_START    USER_PROFILEID

enum _UserTags
{
    prWABUserProfileID = 0,
    prWABUserSubfolders,
    prWABHotmailContactIDs,
    prWABHotmailModTimes,
    prWABHotmailServerIDs,
    prWABDLOneOffs,
    prWABIPPhone,
    prWABFolderParent,
    prWABSharedFolder,
    prWABFolderOwner,
    prWABUserMax
};

/* MouseWheel support for Win95 */
UINT g_msgMSWheel;

/*
- These are used for customizing the WAB columns */
ULONG PR_WAB_CUSTOMPROP1;
ULONG PR_WAB_CUSTOMPROP2;
TCHAR szCustomProp1[MAX_PATH];
TCHAR szCustomProp2[MAX_PATH];
// registry names
extern LPTSTR szPropTag1;
extern LPTSTR szPropTag2;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\iadrbook.c ===
/*********************************************************************************

    IAdrBook.c
       - This file contains the code for implementing the IAdrBook object.

    Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.

    Revision History:

    03/01/96    Bruce Kelley        Copied MAPI code to WAB

***********************************************************************************/

#include <_apipch.h>

#ifdef WIN16
#undef GetLastError
#endif

extern MAPIUID muidOOP;
extern MAPIUID muidProviderSection;
extern SPropTagArray ptagaABSearchPath;
extern void UninitExtInfo();
extern void UninitContextExtInfo();
extern void UIOLEUninit();
extern void SetOutlookRefreshCountData(DWORD dwOlkRefreshCount,DWORD dwOlkFolderRefreshCount);
extern void GetOutlookRefreshCountData(LPDWORD lpdwOlkRefreshCount,LPDWORD lpdwOlkFolderRefreshCount);

extern void LocalFreeSBinary(LPSBinary lpsb);

// USed for cleaning up the IAB object
void IAB_Neuter (LPIAB lpIAB);

typedef enum {
    ENTERED_EMAIL_ADDRESS,
    RECEIVED_EMAIL_ADDRESS,
    AMBIGUOUS_EMAIL_ADDRESS
} RESOLVE_TYPE;

HRESULT HrResolveOneOffs(LPIAB lpIAB, LPADRLIST lpAdrList, LPFlagList lpFlagList, ULONG ulFlags,
  RESOLVE_TYPE ResolveType);


//
//  IAdrBook jump table is defined here...
//

IAB_Vtbl vtblIAB = {
    VTABLE_FILL
    IAB_QueryInterface,
    IAB_AddRef,
    IAB_Release,
    IAB_GetLastError,
    (IAB_SaveChanges_METHOD *)      WRAP_SaveChanges,
    (IAB_GetProps_METHOD *)         WRAP_GetProps,
    (IAB_GetPropList_METHOD *)      WRAP_GetPropList,
    (IAB_OpenProperty_METHOD *)     WRAP_OpenProperty,
    (IAB_SetProps_METHOD *)         WRAP_SetProps,
    (IAB_DeleteProps_METHOD *)      WRAP_DeleteProps,
    (IAB_CopyTo_METHOD *)           WRAP_CopyTo,
    (IAB_CopyProps_METHOD *)        WRAP_CopyProps,
    (IAB_GetNamesFromIDs_METHOD *)  WRAP_GetNamesFromIDs,
    IAB_GetIDsFromNames,
    IAB_OpenEntry,
    IAB_CompareEntryIDs,
    IAB_Advise,
    IAB_Unadvise,
    IAB_CreateOneOff,
    IAB_NewEntry,
    IAB_ResolveName,
    IAB_Address,
    IAB_Details,
    IAB_RecipOptions,
    IAB_QueryDefaultRecipOpt,
    IAB_GetPAB,
    IAB_SetPAB,
    IAB_GetDefaultDir,
    IAB_SetDefaultDir,
    IAB_GetSearchPath,
    IAB_SetSearchPath,
    IAB_PrepareRecips
};


//
//  Interfaces supported by this object
//
#define IAB_cInterfaces 2
LPIID IAB_LPIID[IAB_cInterfaces] = {
    (LPIID) &IID_IAddrBook,
    (LPIID) &IID_IMAPIProp
};



#define WM_DOWABNOTIFY  WM_USER+102

//***************************************************************************************
//
//  Private functions
//
//***************************************************************************************

//
// VerifyWABOpenEx session - Outlook has a bad bug where the first thread which calls WABOpenEx
//  passes lpIAB to a second thread .. since the second thread didnt call WABOpenEx, it thinks
//  this is a regular WAB session and tries to access the WAB Store and crashes - here we set the
//  pt_bIsWABOpenExSession based on the flag set on lpIAB
//
//  Right now this is only set for the original IAB_methods - wrapped methods from WRAP_methods
//  dont call this function - but hopefully this is enough for now ..
//
void VerifyWABOpenExSession(LPIAB lpIAB)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    pt_bIsWABOpenExSession = lpIAB->lpPropertyStore->bIsWABOpenExSession;
}

/*
 - HrLoadNamedProps
 -
 *  Helper function for loading a bunch of named properties at the same time
 *  
 *      uMax - # of props
 *      nStartIndex - starting index (NOTE this assumes that the indexes for the
 *              properties are contiguous values since we'll gor through a 
 *              loop from nStartIndex to uMax
 *      lpGUID - GUID identifying the named props
 *      lppta - returned prop array
 -
*/
HRESULT HrLoadNamedProps(LPIAB lpIAB, ULONG uMax, int nStartIndex, 
                         LPGUID lpGUID, LPSPropTagArray * lppta)
{
    HRESULT hr = S_OK;
    LPMAPINAMEID * lppConfPropNames;
    SCODE sc;
    ULONG i = 0;


    sc = MAPIAllocateBuffer(sizeof(LPMAPINAMEID) * uMax, (LPVOID *) &lppConfPropNames);
    if(sc)
    {
        hr = ResultFromScode(sc);
        goto err;
    }

    for(i=0;i<uMax;i++)
    {
        sc = MAPIAllocateMore(sizeof(MAPINAMEID), lppConfPropNames, &(lppConfPropNames[i]));
        if(sc)
        {
            hr = ResultFromScode(sc);
            goto err;
        }
        lppConfPropNames[i]->lpguid = lpGUID;
        lppConfPropNames[i]->ulKind = MNID_ID;
        lppConfPropNames[i]->Kind.lID = nStartIndex + i;
    }

    hr = ((LPADRBOOK)lpIAB)->lpVtbl->GetIDsFromNames((LPADRBOOK)lpIAB, uMax, lppConfPropNames,
                                        MAPI_CREATE, lppta);
err:
    if(lppConfPropNames)
        MAPIFreeBuffer(lppConfPropNames);

    return hr;
}

/*
-   ReadWABCustomColumnProps 
-   reads the customized Listview properties from the registry
-   Right now there are only 2 customizable props
-   Customization settings are saved per identity and so need to be read
-   from the identities personal key
*
*/
void ReadWABCustomColumnProps(LPIAB lpIAB)
{
    HKEY hKey = NULL;
    HKEY hKeyRoot = (lpIAB && lpIAB->hKeyCurrentUser) ? 
                    lpIAB->hKeyCurrentUser : HKEY_CURRENT_USER;

    PR_WAB_CUSTOMPROP1 = PR_WAB_CUSTOMPROP2 = 0;
    lstrcpy(szCustomProp1, szEmpty);
    lstrcpy(szCustomProp2, szEmpty);
            
    if(ERROR_SUCCESS == RegOpenKeyEx(hKeyRoot, lpNewWABRegKey, 0, KEY_READ, &hKey))
    {
        int i = 0;
        for(i=0;i<2;i++)
        {
            LPTSTR szPropTag = (i==0?szPropTag1:szPropTag2);
            LPTSTR szPropLabel = (i==0?szCustomProp1:szCustomProp2);
            LPULONG lpulProp = (i==0? (&PR_WAB_CUSTOMPROP1):(&PR_WAB_CUSTOMPROP2));
            DWORD dwSize = sizeof(DWORD);
            DWORD dwType = 0;
            DWORD dwValue = 0;
            TCHAR szTemp[MAX_PATH];
            *szTemp = '\0';
            if(ERROR_SUCCESS == RegQueryValueEx(hKey, szPropTag, NULL, &dwType, (LPBYTE) &dwValue, &dwSize))
            {
                if(dwValue && PROP_TYPE(dwValue) == PT_TSTRING)
                {
#ifdef COLSEL_MENU
                    if( ColSel_PropTagToString(dwValue, szTemp, CharSizeOf( szTemp ) ) )
                    {
                        lstrcpy( szPropLabel, szTemp );                    
                        *lpulProp = dwValue;
                    }
#endif
                }
            }
        }
    }

    if(hKey)
        RegCloseKey(hKey);
}

/*
 - HrLoadPrivateWABProps
 -
 -  WAB uses a bunch of named properties internally .. load them all
 -  upfront - these will be globals accessible from elsewhere all the time
*
*
*/
HRESULT HrLoadPrivateWABProps(LPIAB lpIAB)
{
    ULONG i;
    HRESULT hr = E_FAIL;
    LPSPropTagArray lpta = NULL;
    SCODE sc ;


    // Load the set of conferencing named props
    //

    if(HR_FAILED(hr = HrLoadNamedProps( lpIAB, prWABConfMax, OLK_NAMEDPROPS_START, 
                                        (LPGUID) &PS_Conferencing, &lpta)))
        goto err;

    if(lpta)
    {
        // Set the property types on the returned props
        PR_WAB_CONF_SERVERS         = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABConfServers],        PT_MV_TSTRING);
        PR_WAB_CONF_DEFAULT_INDEX   = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABConfDefaultIndex],   PT_LONG);
        PR_WAB_CONF_BACKUP_INDEX    = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABConfBackupIndex],    PT_LONG);
        PR_WAB_CONF_EMAIL_INDEX     = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABConfEmailIndex],     PT_LONG);
    }

    ptaUIDetlsPropsConferencing.cValues = prWABConfMax;
    ptaUIDetlsPropsConferencing.aulPropTag[prWABConfServers] =      PR_WAB_CONF_SERVERS;
    ptaUIDetlsPropsConferencing.aulPropTag[prWABConfDefaultIndex] = PR_WAB_CONF_DEFAULT_INDEX;
    ptaUIDetlsPropsConferencing.aulPropTag[prWABConfBackupIndex] =  PR_WAB_CONF_BACKUP_INDEX;
    ptaUIDetlsPropsConferencing.aulPropTag[prWABConfEmailIndex] =   PR_WAB_CONF_EMAIL_INDEX;

    if(lpta)
        MAPIFreeBuffer(lpta);

    // Load the set of WAB's internal named props
    //
    if(HR_FAILED(hr = HrLoadNamedProps( lpIAB, prWABUserMax, WAB_NAMEDPROPS_START, 
                                        (LPGUID) &MPSWab_GUID_V4, &lpta)))
        goto err;

    if(lpta)
    {
        // Set the property types on the returned props
        PR_WAB_USER_PROFILEID   = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABUserProfileID], PT_TSTRING);
        PR_WAB_USER_SUBFOLDERS  = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABUserSubfolders],PT_MV_BINARY);
        PR_WAB_HOTMAIL_CONTACTIDS = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABHotmailContactIDs],PT_MV_TSTRING);
        PR_WAB_HOTMAIL_MODTIMES = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABHotmailModTimes],PT_MV_TSTRING);
        PR_WAB_HOTMAIL_SERVERIDS = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABHotmailServerIDs],PT_MV_TSTRING);
        PR_WAB_DL_ONEOFFS  = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABDLOneOffs],PT_MV_BINARY);
        PR_WAB_IPPHONE  = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABIPPhone],PT_TSTRING);
        PR_WAB_FOLDER_PARENT = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABFolderParent],PT_MV_BINARY);
        PR_WAB_SHAREDFOLDER = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABSharedFolder],PT_LONG);
        PR_WAB_FOLDEROWNER = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABFolderOwner],PT_TSTRING);
    }

    if(lpta)
        MAPIFreeBuffer(lpta);

    // Load the set of Yomi named props
    //
    if(HR_FAILED(hr = HrLoadNamedProps( lpIAB, prWABYomiMax, OLK_YOMIPROPS_START, 
                                        (LPGUID) &PS_YomiProps, &lpta)))
        goto err;

    if(lpta)
    {
        // Set the property types on the returned props
        PR_WAB_YOMI_FIRSTNAME   = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABYomiFirst],    PT_TSTRING);
        PR_WAB_YOMI_LASTNAME    = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABYomiLast],     PT_TSTRING);
        PR_WAB_YOMI_COMPANYNAME = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABYomiCompany],  PT_TSTRING);
    }

    if(lpta)
        MAPIFreeBuffer(lpta);

    // Load the default mailing address property
    //
    if(HR_FAILED(hr = HrLoadNamedProps( lpIAB, prWABPostalMax, OLK_POSTALID_START, 
                                        (LPGUID) &PS_PostalAddressID, &lpta)))
        goto err;

    if(lpta)
    {
        // Set the property types on the returned props
        PR_WAB_POSTALID     = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABPostalID],    PT_LONG);
    }

err:
    if(lpta)
        MAPIFreeBuffer(lpta);
    return hr;
}


// The WAB's notification engine is currently a hidden window
// that checks for file changes every NOTIFICATIONTIME milliseconds
// If changes are detected, it fires off a generic notification
//
// <TBD> At some point of time this should be made more granular so apps 
// get a message telling them which entry changed rather than a generic
// notification
//


///////////////////////////////////////////////////////////////////////////////
//  Way to globally turn off all notifications in this process.  Needed because
//  of global Outlook MAPI allocator weirdness.  See the HrSendMail function in
//  uimisc.c
//
//  Includes one static variable and two helper functions
//  [PaulHi]
///////////////////////////////////////////////////////////////////////////////

static BOOL s_bDisableAllNotifications = FALSE;
void vTurnOffAllNotifications()
{
    s_bDisableAllNotifications = TRUE;
}
void vTurnOnAllNotifications()
{
    s_bDisableAllNotifications = FALSE;
}


#define NOTIFICATIONTIME    2000 //millisecs
#define NOTIFTIMER          777


/*
 - IABNotifWndProc
 -
 *  Window procedure for the hidden window on the iadrbook object
 *  that has a notification timer and processes timer messages only
 *  Current timer duration is 3 seconds - so every 3 seconds we check
 *  for changes and fire notifications accordingly
 *
 *
 */
LRESULT CALLBACK IABNotifWndProc(   HWND   hWnd,
                                    UINT   uMsg,
                                    WPARAM wParam,
                                    LPARAM lParam)
{
    LPPTGDATA   lpPTGData=GetThreadStoragePointer();
    LPIAB       lpIAB = NULL;

    switch(uMsg)
    {
    case WM_CREATE:
        {
            LPCREATESTRUCT lpCS = (LPCREATESTRUCT) lParam;
            lpIAB = (LPIAB) lpCS->lpCreateParams;
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR) lpIAB);

            // [PaulHi] 4/27/99  Raid 76520.  Don't use the notification
            // timer for normal WAB store sessions.  We still need this
            // for Outlook store sessions, however.
            if (pt_bIsWABOpenExSession)
            {
                lpIAB->ulNotifyTimer = SetTimer(hWnd, NOTIFTIMER, //random number
                                                NOTIFICATIONTIME,
                                                0);
            }
        }
        break;

    case WM_DOWABNOTIFY:
        lpIAB = (LPIAB)GetWindowLongPtr(hWnd, GWLP_USERDATA);
        if ( lpIAB && !IsBadReadPtr(lpIAB, sizeof(LPVOID)) && !s_bDisableAllNotifications )
        {
            DebugTrace(TEXT("*** *** *** Firing WAB Change Notification *** *** ***\n"));
            HrWABNotify(lpIAB);
        }
        break;

    case WM_TIMER:
        if(wParam == NOTIFTIMER) // is this the WAB timer ID
        {
            lpIAB = (LPIAB)GetWindowLongPtr(hWnd, GWLP_USERDATA);
            if (lpIAB && 
                !IsBadReadPtr(lpIAB, sizeof(LPVOID)) &&
                lpIAB->lpPropertyStore && 
                lpIAB->ulNotifyTimer &&
				CheckChangedWAB(lpIAB->lpPropertyStore, lpIAB->hMutexOlk, 
								&lpIAB->dwOlkRefreshCount, &lpIAB->dwOlkFolderRefreshCount,
                                &(lpIAB->ftLast)))
            {
                DebugTrace(TEXT("*** *** *** Firing WAB Change Notification *** *** ***\n"));
                HrWABNotify(lpIAB);
            }
        }
        break;

    case WM_DESTROY:
        lpIAB = (LPIAB)GetWindowLongPtr(hWnd, GWLP_USERDATA);
        if(lpIAB && lpIAB->ulNotifyTimer)
            KillTimer(hWnd, lpIAB->ulNotifyTimer);
        SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR) NULL);
        break;

    default:
        return DefWindowProc(hWnd,uMsg,wParam,lParam);
    }
    return 0;
}


static TCHAR szWABNotifClassName[] =  TEXT("WAB Notification Engine");
static TCHAR szWABNotifWinName[] =  TEXT("WAB Notification Window");

/*
 - CreateIABNotificationTimer
 -
 *  Creates a hidden window on the IAB object. This window has a timer
 *  which is used to check for changes and fire notifications accordingly
 *
 *
 */
void CreateIABNotificationTimer(LPIAB lpIAB)
{
	HINSTANCE	hinst = hinstMapiXWAB;
	WNDCLASS	wc;
	HWND		hwnd = NULL;

    lpIAB->hWndNotify = FALSE;
    lpIAB->ulNotifyTimer = 0;

	//	Register the window class. Ignore any failures; handle those
	//	when the window is created.
	if (!GetClassInfo(hinst, szWABNotifClassName, &wc))
	{
		ZeroMemory(&wc, sizeof(WNDCLASS));
		wc.style = CS_GLOBALCLASS;
		wc.hInstance = hinst;
		wc.lpfnWndProc = IABNotifWndProc;
		wc.lpszClassName = szWABNotifClassName;

		(void)RegisterClass(&wc);
	}

	//	Create the window.
	hwnd = CreateWindow(    szWABNotifClassName,
                            szWABNotifWinName,
		                    WS_POPUP,	//	MAPI bug 6111: pass on Win95 hotkey
		                    0, 0, 0, 0,
		                    NULL, NULL,
		                    hinst,
		                    (LPVOID)lpIAB);
	if (!hwnd)
	{
		DebugTrace(TEXT("HrNewIAB: failure creating notification window (0x%lx)\n"), GetLastError());
        return;
	}

    lpIAB->hWndNotify = hwnd;

    return;
}


///////////////////////////////////////////////////////////////////////////////
//  IABNotifyThreadProc
//
//  Worker thread that waits for a WAB file mod notification from the system
//  using FindFirstChangeNotification/FindNextChangeNotification functions.  
//  When the WAB file store has been modified, this thread will call the WAB 
//  client notification function.
///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI IABNotifyThreadProc(LPVOID lpParam)
{
    LPIAB   lpIAB = (LPIAB)lpParam;
    HANDLE  hFCN;
    HANDLE  ahWaitHandles[2];
    DWORD   dwWaitRtn;

    Assert(lpIAB);
    
    // Set up the FindFirstChangeNotification handle
    hFCN = FindFirstChangeNotification(
                lpIAB->lpwszWABFilePath,        // Directory path to watch
                FALSE,                          // bWatchSubtree
                FILE_NOTIFY_CHANGE_LAST_WRITE); // Condition(s) to watch

    if (INVALID_HANDLE_VALUE == hFCN || NULL == hFCN)
    {
        Assert(0);
        lpIAB->hThreadNotify = INVALID_HANDLE_VALUE;
        return 0;
    }

    ahWaitHandles[0] = hFCN;
    ahWaitHandles[1] = lpIAB->hEventKillNotifyThread;

    // Wait for file change
    while (1)
    {
        // Wait on file change nofication, or terminate thread event
        dwWaitRtn = WaitForMultipleObjects(2, ahWaitHandles, FALSE, INFINITE);
        switch (dwWaitRtn)
        {
        case WAIT_OBJECT_0:
            // Reset the file change 
            if (!FindNextChangeNotification(hFCN))
            {
                Assert(0);
            }

            // Distribute store change notifications.  Do this on the main
            // IAB thread.
            if (lpIAB->hWndNotify)
                SendMessage(lpIAB->hWndNotify, WM_DOWABNOTIFY, 0, 0);
            break;

        case WAIT_FAILED:
            // If the wait failed then terminate the thread.
            Assert(0);

        case WAIT_OBJECT_0+1:
            // Close the file change notification handle and
            // terminate thread.
            FindCloseChangeNotification(hFCN);
            return 0;
        } // end switch
    } // end while
}

///////////////////////////////////////////////////////////////////////////////
//  CreateIABNotificationThread
//
//  Creates a worker thread that waits for a WAB store file modification
///////////////////////////////////////////////////////////////////////////////
void CreateIABNotificationThread(LPIAB lpIAB)
{
    DWORD   dwThreadID = 0;
    LPWSTR  lpwszTemp;

    // Put together the WAB store file directory path.
    LPMPSWab_FILE_INFO lpMPSWabFileInfo = (LPMPSWab_FILE_INFO)(lpIAB->lpPropertyStore->hPropertyStore);
    int nLen = lstrlen(lpMPSWabFileInfo->lpszMPSWabFileName);
    lpIAB->lpwszWABFilePath = LocalAlloc( LMEM_ZEROINIT, (sizeof(WCHAR) * (nLen+1)) );
    if (!lpIAB->lpwszWABFilePath)
    {
        Assert(0);
        return;
    }
    lstrcpy(lpIAB->lpwszWABFilePath, lpMPSWabFileInfo->lpszMPSWabFileName);

    // Remove file name at the end.  This will take care of:
    // "c:\path\filename", "c:filename", "\\path\filename"
    lpwszTemp = lpIAB->lpwszWABFilePath + nLen;
    while ( (lpwszTemp != lpIAB->lpwszWABFilePath) && 
            (*lpwszTemp != '\\') && (*lpwszTemp != ':') )
    {
        --lpwszTemp;
    }
    if (*lpwszTemp == ':')
        ++lpwszTemp;        // Keep ':' but not the '\\' ... Win95 won't accept the latter.
    (*lpwszTemp) = '\0';

    // Create the kill thread event
    lpIAB->hEventKillNotifyThread = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (lpIAB->hEventKillNotifyThread == NULL)
    {
        Assert(0);
        return;
    }
    
    lpIAB->hThreadNotify = CreateThread(
                            NULL,           // no security attributes
                            0,              // use default stack size
                            IABNotifyThreadProc, // thread function
                            (LPVOID)lpIAB,  // argument to thread function
                            0,              // use default creation flags
                            &dwThreadID);   // returns the thread identifier    

    Assert(INVALID_HANDLE_VALUE != lpIAB->hThreadNotify);
}



/*
-   HrNewIAB
-
*   Creates a new IAddrBook object (also known fondly as IAB object)
*
    lpPropertyStore - Handle to the property store
    lpWABOBject     - the WABOBject for this session (the 2 are closely linked)
    lppIAB          - returned IAB object
*
*/
HRESULT HrNewIAB(LPPROPERTY_STORE lpPropertyStore, 
                LPWABOBJECT lpWABObject, LPVOID *lppIAB)
{
    LPIAB 		    lpIAB 			   = NULL;
    SCODE 		    sc;
    HRESULT 	    hr     		       = hrSuccess;
    LPSTR 		    lpszMessage 	   = NULL;
    ULONG 		    ulLowLevelError    = 0;
    LPSTR 		    lpszComponent 	   = NULL;
    ULONG 		    ulContext 		   = 0;
    UINT 		    ids    		       = 0;
    ULONG 		    ulMemFlag 		   = 0;
    SPropValue      spv[1];
    LPPROPDATA      lpPropData 	       = NULL;
    LPMAPIERROR     lpMAPIError	       = NULL;
    LPSPropValue    lpspvSearchPath    = NULL;
    BOOL            bAddRefedPropStore = FALSE;
    BOOL            bAddRefedWABObject = FALSE;
    LPPTGDATA       lpPTGData=GetThreadStoragePointer();

    //
    //  Allocate space for the IAB structure
    //
    if (FAILED(sc = MAPIAllocateBuffer(sizeof(IAB), (LPVOID *) &lpIAB))) {
        hr = ResultFromScode(sc);
        ulContext = CONT_SESS_OPENAB_1;
        //		ids = IDS_NOT_ENOUGH_MEMORY;
        goto err;
    }
    MAPISetBufferName(lpIAB,  TEXT("AB Object"));

    ZeroMemory(lpIAB, sizeof(IAB));

    lpIAB->lpVtbl = &vtblIAB;

    lpIAB->cIID = IAB_cInterfaces;
    lpIAB->rglpIID = IAB_LPIID;

    lpIAB->hThreadNotify = INVALID_HANDLE_VALUE;

    // The session's reference to the address book doesn't count. Only
    // client references (via SESSOBJ_OpenAddressBook) cause an increase
    // in the refcount.

    lpIAB->lcInit = 1;      // Caller gets an instance

    lpIAB->hLastError = hrSuccess;
    lpIAB->idsLastError = 0;
    lpIAB->lpszComponent = NULL;
    lpIAB->ulContext = 0;
    lpIAB->ulLowLevelError = 0;
    lpIAB->ulErrorFlags = 0;
    lpIAB->lpMAPIError = NULL;

    lpIAB->lRowID = -1;

    if ((FAILED(sc = OpenAddRefPropertyStore(NULL, lpPropertyStore)))) {
        hr = ResultFromScode(sc);
        goto err;
    }
    bAddRefedPropStore = TRUE;

    lpIAB->lpPropertyStore = lpPropertyStore;


    lpIAB->lpEntryIDDD = NULL;
    lpIAB->cbEntryIDDD = 0;

    lpIAB->lpEntryIDPAB = NULL;
    lpIAB->cbEntryIDPAB = 0;

    lpIAB->lpspvSearchPathCache = NULL;

    lpIAB->lpTableData = NULL;
    lpIAB->lpOOData = NULL;

    lpIAB->ulcTableInfo  = 0;
    lpIAB->pargTableInfo = NULL;

    lpIAB->ulcOOTableInfo  	= 0;
    lpIAB->pargOOTableInfo 	= NULL;

    lpIAB->padviselistIAB	= NULL;

    lpIAB->pWABAdviseList = NULL;

    lpIAB->nPropExtDLLs = 0;
    lpIAB->lpPropExtDllList = NULL;

    lpIAB->lpWABObject = (LPIWOINT)lpWABObject;
    UlAddRef(lpWABObject);

    bAddRefedWABObject = TRUE;

    // If this session was opened with given Outlook allocator function pointers
    // then set the boolean
    lpIAB->bSetOLKAllocators = lpIAB->lpWABObject->bSetOLKAllocators;

    //
    //  Create IPropData
    //
    sc = CreateIProp((LPIID)&IID_IMAPIPropData,
      (ALLOCATEBUFFER FAR *) MAPIAllocateBuffer,
      (ALLOCATEMORE FAR *) MAPIAllocateMore,
      MAPIFreeBuffer,
      NULL,
      &lpPropData);

    if (FAILED(sc)) {
        hr = ResultFromScode(sc);
        ulContext = CONT_SESS_OPENAB_2;
        // ids = IDS_NOT_ENOUGH_MEMORY;
        goto err;
    }
    MAPISetBufferName(lpPropData,  TEXT("lpPropData in HrNewIAB"));

    //  PR_OBJECT_TYPE
    spv[0].ulPropTag = PR_OBJECT_TYPE;
    spv[0].Value.l = MAPI_ADDRBOOK;

    //
    //  Set the default properties
    //
    if (HR_FAILED(hr = lpPropData->lpVtbl->SetProps(lpPropData,
      1,
      spv,
      NULL))) {
        lpPropData->lpVtbl->GetLastError(lpPropData,
          hr,
          0,
          &lpMAPIError);
        ids = 0;
        ulMemFlag = 1;
        goto err;
    }

    // object itself can't be modified
    lpPropData->lpVtbl->HrSetObjAccess(lpPropData, IPROP_READONLY);

    lpIAB->lpPropData = lpPropData;

    lpIAB->fLoadedLDAP = FALSE;
    //if (ResolveLDAPServers()) {
    //    // load the LDAP client dll
    //    lpIAB->fLoadedLDAP = InitLDAPClientLib();
    //}

    // Create a notification timer for this IAddrBook obect
    // for handline IAddrBook::Advise calls.
    // [PaulHi] 4/27/99 This just creates the notification "hidden" window.  The
    // timer will be created only if this is an Outlook session.  Otherwise the 
    // FCN wait thread uses this to notify IAB clients of a store change ... using
    // the original thread the IAB was created on.
    CreateIABNotificationTimer(lpIAB);

    // [PaulHi] 4/27/99  Raid 76520  Use FCN wait thread instead
    // of notify window timer for non-Outlook sessions.
    if (!pt_bIsWABOpenExSession)
        CreateIABNotificationThread(lpIAB);

    // All we want to do is initialize the IABs critical section
    // We are already in a SessObj critical section.
    InitializeCriticalSection(&lpIAB->cs);

	lpIAB->hMutexOlk = CreateMutex(NULL, FALSE,  TEXT("MPSWABOlkStoreNotifyMutex"));
	if(GetLastError()!=ERROR_ALREADY_EXISTS)
	{
		// First one to create the mutex ... means we can reset the reg settings
		SetOutlookRefreshCountData(0,0);
	}
	GetOutlookRefreshCountData(&lpIAB->dwOlkRefreshCount,&lpIAB->dwOlkFolderRefreshCount);

    *lppIAB = (LPVOID)lpIAB;

    return(hrSuccess);

err:

    FreeBufferAndNull(&lpIAB);
    UlRelease(lpPropData);

    if(bAddRefedWABObject)
        UlRelease(lpWABObject);

    if(bAddRefedPropStore)
        ReleasePropertyStore(lpPropertyStore);   // undo the above operation

    return(hr);
}



/*
 - SetMAPIError
 -
 *
 *  Parameters:
 *		lpObject
 *		hr
 *		ids - ID of string resource associated with an internal error string
 *		lpszComponent - Constant string, not allocated (must be ANSI)
 *		ulContext
 *		ulLowLevelError
 *		ulErrorFlags - Whether or not the lpMAPIError is UNICODE or not (MAPI_UNICODE)
 *		lpMAPIError - Allocated, generally from foreign object.
 */

VOID SetMAPIError(LPVOID lpObject,
  HRESULT hr,
  UINT ids,
  LPTSTR lpszComponent,
  ULONG ulContext,
  ULONG ulLowLevelError,
  ULONG ulErrorFlags,
  LPMAPIERROR lpMAPIError)
{
    LPIAB lpIAB = (LPIAB) lpObject;

    lpIAB->hLastError = hr;
    lpIAB->ulLowLevelError = ulLowLevelError;
    lpIAB->ulContext = ulContext;

    //  Free any existing MAPI error
    FreeBufferAndNull(&(lpIAB->lpMAPIError));

    // If both a MAPIERROR and a string ID are present then we will
    // concatenate them when the error is reported.
    lpIAB->lpMAPIError = lpMAPIError;
    lpIAB->ulErrorFlags = ulErrorFlags;
    lpIAB->idsLastError = ids;
    lpIAB->lpszComponent = lpszComponent;

    return;
}


/***************************************************
 *
 *  The actual IAdrBook methods
 */


// --------
// IUnknown

STDMETHODIMP
IAB_QueryInterface(LPIAB lpIAB,
  REFIID lpiid,
  LPVOID * lppNewObj)
{

    ULONG iIID;

#ifdef PARAMETER_VALIDATION

    // Check to see if it has a jump table
    if (IsBadReadPtr(lpIAB, sizeof(LPVOID))) {
        // No jump table found
        return(ResultFromScode(E_INVALIDARG));
    }

    // Check to see if the jump table has at least sizeof IUnknown
    if (IsBadReadPtr(lpIAB->lpVtbl, 3*sizeof(LPVOID))) {
        // Jump table not derived from IUnknown
        return(ResultFromScode(E_INVALIDARG));
    }

    // Check to see that it's IAB_QueryInterface
    if (lpIAB->lpVtbl->QueryInterface != IAB_QueryInterface) {
        // Not my jump table
        return(ResultFromScode(E_INVALIDARG));
    }


    // Is there enough there for an interface ID?

    if (IsBadReadPtr(lpiid, sizeof(IID))) {
        DebugTraceSc(IAB_QueryInterface, E_INVALIDARG);
        return(ResultFromScode(E_INVALIDARG));
    }

    // Is there enough there for a new object?
    if (IsBadWritePtr (lppNewObj, sizeof (LPIAB))) {
        DebugTraceSc(IAB_QueryInterface, E_INVALIDARG);
        return(ResultFromScode(E_INVALIDARG));
    }

#endif // PARAMETER_VALIDATION

    EnterCriticalSection(&lpIAB->cs);

    // See if the requested interface is one of ours

    //
    //  First check with IUnknown, since we all have to support that one...
    //
    if (! memcmp(lpiid, &IID_IUnknown, sizeof(IID))) {
        goto goodiid;
    }

    //
    //  Now look through all the iids associated with this object, see if any match
    //
    for(iIID = 0; iIID < lpIAB->cIID; iIID++) {
        if (!memcmp(lpIAB->rglpIID[iIID], lpiid, sizeof(IID))) {
goodiid:
            //
            //  It's a match of interfaces, we support this one then...
            //
            ++lpIAB->lcInit;

            // Bug 48468 - we're not addrefing the WABObject here but
            // we're releasing it in the IadrBook->Release
            //
            UlAddRef(lpIAB->lpWABObject);

            *lppNewObj = lpIAB;

            LeaveCriticalSection(&lpIAB->cs);

            return(0);
        }
    }

    //
    //  No interface we've heard of...
    //

    LeaveCriticalSection(&lpIAB->cs);

    *lppNewObj = NULL;	// OLE requires NULLing out parm on failure
    DebugTraceSc(IAB_QueryInterface, E_NOINTERFACE);
    return(ResultFromScode(E_NOINTERFACE));
}


/**************************************************
 *
 *  IAB_AddRef
 *		Increment lcInit
 *
 */


STDMETHODIMP_(ULONG) IAB_AddRef (LPIAB lpIAB)
{

#ifdef PARAMETER_VALIDATION

    // Check to see if it has a jump table
    if (IsBadReadPtr(lpIAB, sizeof(LPVOID))) {
        //No jump table found
        return(1);
    }

    // Check to see if the jump table has at least sizeof IUnknown
    if (IsBadReadPtr(lpIAB->lpVtbl, 3 * sizeof(LPVOID))) {
        // Jump table not derived from IUnknown
        return(1);
    }

    // Check to see if the method is the same
    if ((IAB_AddRef != lpIAB->lpVtbl->AddRef)
#ifdef	DEBUG
	   //  For spooler session leak tracking
	   //&& ((IAB_AddRef_METHOD *)SESSOBJ_AddRef != lpIAB->lpVtbl->AddRef)
#endif
    ) {
        // Wrong object - the object passed doesn't have this
        // method.
        return(1);
    }

#endif // PARAMETER_VALIDATION

    EnterCriticalSection(&lpIAB->cs);

    ++lpIAB->lcInit;

    LeaveCriticalSection(&lpIAB->cs);

    UlAddRef(lpIAB->lpWABObject);

    return(lpIAB->lcInit);
}


/**************************************************
 *
 *  IAB_Release
 *		Decrement lpInit.
 *		When lcInit == 0, free up the lpIAB structure
 *
 */

STDMETHODIMP_(ULONG)
IAB_Release (LPIAB lpIAB)
{
    UINT    uiABRef;
    BOOL    bSetOLKAllocators;

#ifdef PARAMETER_VALIDATION

    // Check to see if it has a jump table
    if (IsBadReadPtr(lpIAB, sizeof(LPVOID))) {
        // No jump table found
        return(1);
    }


    // Check to see if the jump table has at least sizeof IUnknown
    if (IsBadReadPtr(lpIAB->lpVtbl, 3*sizeof(LPVOID))) {
        // Jump table not derived from IUnknown
        return(1);
    }

    // Check to see if the method is the same
    if (IAB_Release != lpIAB->lpVtbl->Release) {
        // Wrong object - the object passed doesn't have this
        // method.
        return(1);
    }

#endif // PARAMETER_VALIDATION

    VerifyWABOpenExSession(lpIAB);

    // The address book is part of the session object, and one doesn't go away
    // without the other going away also. This code checks that both the
    // session and the address book have a zero refcount before bringing
    // them both down. Note that when I want to get both critical sections,
    // I get the session object CS first. This avoids deadlock.
    // See SESSOBJ_Release in isess.c for very similar code.

    UlRelease(lpIAB->lpWABObject);

    EnterCriticalSection(&lpIAB->cs);

    if (lpIAB->lcInit == 0) {
        uiABRef = 0;
    } else {
        AssertSz(lpIAB->lcInit < UINT_MAX,  TEXT("Overflow in IAB Reference count"));
        uiABRef = (UINT) --(lpIAB->lcInit);
    }

    LeaveCriticalSection(&lpIAB->cs);

    if (uiABRef) {
        return((ULONG)uiABRef);
    }

    EnterCriticalSection(&lpIAB->cs);

    uiABRef = (UINT) lpIAB->lcInit;

    LeaveCriticalSection(&lpIAB->cs);

    if (uiABRef) {
        return(uiABRef);
    }

    IAB_Neuter(lpIAB);

    bSetOLKAllocators = lpIAB->bSetOLKAllocators;
    FreeBufferAndNull(&lpIAB);

    // [PaulHi] 5/5/99  Raid 77138  Null out Outlook allocator function
    // pointers if our global count goes to zero.
    if (bSetOLKAllocators)
    {
        Assert(g_nExtMemAllocCount > 0);
        InterlockedDecrement((LPLONG)&g_nExtMemAllocCount);
        if (g_nExtMemAllocCount == 0)
        {
            lpfnAllocateBufferExternal = NULL;
            lpfnAllocateMoreExternal = NULL;
            lpfnFreeBufferExternal = NULL;
        }
    }

    return(0);
}

/*
 * IAB_Neuter
 *
 * Purpose
 * Destroys the memory and objects inside the address book object, leaving
 * nothing but the object itself to be freed. Called from CleanupSession()
 * in isess.c (client-side cleanup) and from SplsessRelease() in splsess.c
 * (spooler-side cleanup). Note that the address book object is only taken
 * down as a part of session takedown. Once this call is made, we can assume
 * the session is shutting down and can free up everything guilt-free
 */
void
IAB_Neuter(LPIAB lpIAB)
{
	HINSTANCE	hinst = hinstMapiXWAB;
	WNDCLASS	wc;

    if (lpIAB == NULL) {
        TraceSz( TEXT("IAB_Neuter: given a NULL lpIAB"));
        return;
    }

    // clean up the advise list for the AB

#ifdef OLD_STUFF
    if (lpIAB->padviselistIAB) {
        DestroyAdviseList(&lpIAB->padviselistIAB);
    }
#endif // OLD_STUFF

    // Get rid of any cached context menu extension data
    UlRelease(lpIAB->lpCntxtMailUser);

    //
    //  Get rid of my PropData
    //
    UlRelease(lpIAB->lpPropData);

    //
    //  Get rid of any EntryIDs I've got floating around
    //
    FreeBufferAndNull(&(lpIAB->lpEntryIDDD));
    lpIAB->lpEntryIDDD = NULL;

    FreeBufferAndNull(&(lpIAB->lpEntryIDPAB));
    lpIAB->lpEntryIDPAB = NULL;

    // Remove the SearchPath cache

#if defined (WIN32) && !defined (MAC)
    if (fGlobalCSValid) {
        EnterCriticalSection(&csMapiSearchPath);
    } else {
        DebugTrace( TEXT("IAB_Neuter:  WAB32.DLL already detached.\n"));
    }
#endif
	
    FreeBufferAndNull(&(lpIAB->lpspvSearchPathCache));
    lpIAB->lpspvSearchPathCache = NULL;

#if defined (WIN32) && !defined (MAC)
    if (fGlobalCSValid) {
        LeaveCriticalSection(&csMapiSearchPath);
    } else {
        DebugTrace(TEXT("IAB_Neuter: WAB32.DLL got detached.\n"));
    }
#endif

    //
    //	Release any MAPI allocated error structure
    //
    FreeBufferAndNull(&(lpIAB->lpMAPIError));


    // Release the property store associated with the IAB
    ReleasePropertyStore(lpIAB->lpPropertyStore);

    // Unload LDAP client if it was loaded at IAB creation.
    //if (lpIAB->fLoadedLDAP)
    {
        DeinitLDAPClientLib();
    }

    if ((NULL != lpIAB->hWndNotify) && (FALSE != IsWindow(lpIAB->hWndNotify))) {
        SendMessage(lpIAB->hWndNotify, WM_CLOSE, 0, 0);
    }

    // On Windows NT/2000: No window classes registered by a .dll 
    // are unregistered when the .dll is unloaded. 
    // If we dont do this we might point to an old/invalid IABNotifWndProc
    // pointer in CreateIABNotificationTimer
    if (GetClassInfo(hinst, szWABNotifClassName, &wc)) {
        UnregisterClass(szWABNotifClassName, hinst);
    }

    lpIAB->hWndNotify = NULL;
    lpIAB->ulNotifyTimer = 0;

    // Terminate the wab file change notification thread
    if (lpIAB->hThreadNotify != INVALID_HANDLE_VALUE)
    {
        DWORD   dwRtn;

        // Signal thread to terminate and wait
        Assert(lpIAB->hEventKillNotifyThread);
        SetEvent(lpIAB->hEventKillNotifyThread);
        dwRtn = WaitForSingleObject(lpIAB->hThreadNotify, INFINITE);

        CloseHandle(lpIAB->hThreadNotify);
        lpIAB->hThreadNotify = INVALID_HANDLE_VALUE;
    }

    if (lpIAB->lpwszWABFilePath)
        LocalFreeAndNull(&(lpIAB->lpwszWABFilePath));

    if (lpIAB->hEventKillNotifyThread)
    {
        CloseHandle(lpIAB->hEventKillNotifyThread);
        lpIAB->hEventKillNotifyThread = NULL;
    }

    while(  lpIAB->pWABAdviseList && //shouldnt happen
            lpIAB->pWABAdviseList->cAdvises &&
            lpIAB->pWABAdviseList->lpNode)
    {
        HrUnadvise(lpIAB, lpIAB->pWABAdviseList->lpNode->ulConnection);
    }

    // Free any memory allocated to rt-click action items
    //
    if(lpIAB->lpActionList)
        FreeActionItemList(lpIAB);

    if(lpIAB->lpPropExtDllList)
        FreePropExtList(lpIAB->lpPropExtDllList);

    FreeWABFoldersList(lpIAB);

    FreeProfileContainerInfo(lpIAB);

    UninitExtInfo();
    UninitContextExtInfo();
    // Release the account manager
    UninitAccountManager();
    // Release the identity manager
    HrRegisterUnregisterForIDNotifications( lpIAB, FALSE);
    UninitUserIdentityManager(lpIAB);
    if(lpIAB->hKeyCurrentUser)
        RegCloseKey(lpIAB->hKeyCurrentUser);
    // Release trident
    UninitTrident();

    UIOLEUninit();
    //
    //  Set the time-bomb
    //
    lpIAB->lpVtbl = NULL;

    DeleteCriticalSection(&lpIAB->cs);

	if(lpIAB->hMutexOlk)
		CloseHandle(lpIAB->hMutexOlk);

    return;
}


// IMAPIProp


/**************************************************
 *
 *	IAB_GetLastError()
 *
 *		Returns a string associated with the last hResult
 *		returned by the IAB object.
 *
 *		Now UNICODE enabled
 *
 */

STDMETHODIMP
IAB_GetLastError(LPIAB lpIAB,
  HRESULT hError,
  ULONG ulFlags,
  LPMAPIERROR FAR * lppMAPIError)
{

    HRESULT hr = hrSuccess;

#ifdef PARAMETER_VALIDATION

    // Check to see if it has a jump table
    if (IsBadReadPtr(lpIAB, sizeof(LPVOID))) {
        // No jump table found
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check to see if the jump table has at least sizeof IUnknown
    if (IsBadReadPtr(lpIAB->lpVtbl, 4*sizeof(LPVOID))) {
        // Jump table not derived from IUnknown
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check to see if the method is the same
    if (IAB_GetLastError != lpIAB->lpVtbl->GetLastError) {
        // Wrong object - the object passed doesn't have this
        // method.
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (FBadGetLastError(lpIAB, hError, ulFlags, lppMAPIError)) {
        DebugTraceArg(IAB_GetLastError,  TEXT("Bad writeable parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags & ~MAPI_UNICODE) {
        DebugTraceArg(IAB_GetLastError,  TEXT("reserved flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

#endif // PARAMETER_VALIDATION

    EnterCriticalSection(&lpIAB->cs);

    if(lppMAPIError)
        *lppMAPIError = NULL; // really isnt anything to return here for now
                              // set this to NULL, which means no error information

#ifdef OLD_STUFF
    hr = HrGetLastError(lpIAB, hError, ulFlags, lppMAPIError);
#endif	

    LeaveCriticalSection(&lpIAB->cs);

    return(hr);
}


//
// Set of properties set by Creating a one off.
//
enum {
    iooPR_ADDRTYPE = 0,
    iooPR_DISPLAY_NAME,
    iooPR_EMAIL_ADDRESS,
    iooPR_ENTRYID,
    iooPR_OBJECT_TYPE,
    iooMax
};


/***************************************************************************

    Name      : IsOneOffEID

    Purpose   : Is this EntryID a One-off?

    Parameters: cbEntryID = size of lpEntryID
                lpEntryID -> entry ID of one off to open

    Returns   : TRUE or FALSE

    Comment   :

***************************************************************************/
BOOL IsOneOffEID(ULONG cbEntryID, LPENTRYID lpEntryID) {
    return(WAB_ONEOFF == IsWABEntryID(cbEntryID, lpEntryID, NULL, NULL, NULL, NULL, NULL));
}


/***************************************************************************

    Name      : NewOneOff

    Purpose   : Create a new MailUser object based on a OneOff EntryID

    Parameters: cbEntryID = size of lpEntryID
                lpEntryID -> entry ID of one off to open
                lpulObjType -> returned object type

    Returns   : HRESULT

    Comment   : OneOff EID format is MAPI_ENTRYID:
                	BYTE	abFlags[4];
                	MAPIUID	mapiuid;     //  = WABONEOFFEID
                	BYTE	bData[];     // contains szaddrtype followed by szaddress
                                         // the delimiter is the null after szaddrtype.
                                         // The first ULONG in bData[] is the ulMapiDataType, 
                                         // which contains the MAPI_UNICODE flag if unicode.

                Assumes that the EntryID contains valid strings.  It is the job of
                the caller to validate the EntryID before calling NewOneOff.

***************************************************************************/
HRESULT NewOneOff(
    LPIAB lpIAB,
    ULONG cbEntryID,
    LPENTRYID lpEntryID,
    LPULONG lpulObjType,
    LPUNKNOWN FAR * lppUnk)
{
    HRESULT hResult = hrSuccess;
    LPMAPI_ENTRYID lpMapiEID = (LPMAPI_ENTRYID)lpEntryID;
    LPMAILUSER lpMailUser = NULL;
    SPropValue spv[iooMax];
    LPBYTE lpbDisplayName, lpbAddrType, lpbAddress;
    LPTSTR lptszDisplayName = NULL;
    LPTSTR lptszAddrType = NULL;
    LPTSTR lptszAddress = NULL;
    LPPROPDATA lpPropData = NULL;
    ULONG ulMapiDataType = 0;

    // Validate the EntryID as WAB_ONEOFF
    if (WAB_ONEOFF != IsWABEntryID(cbEntryID, lpEntryID, &lpbDisplayName, &lpbAddrType, &lpbAddress, (LPVOID *)&ulMapiDataType, NULL)) {
        hResult = ResultFromScode(MAPI_E_INVALID_ENTRYID);
        goto exit;
    }

    // [PaulHi] 1/20/99  Raid 64211
    // UNICODE is native in WAB.  Convert strings to be consistent
    if (!(ulMapiDataType & MAPI_UNICODE))
    {
        lptszDisplayName = ConvertAtoW((LPSTR)lpbDisplayName);
        lptszAddrType = ConvertAtoW((LPSTR)lpbAddrType);
        lptszAddress = ConvertAtoW((LPSTR)lpbAddress);
    }
    else
    {
        lptszDisplayName = (LPTSTR)lpbDisplayName;
        lptszAddrType = (LPTSTR)lpbAddrType;
        lptszAddress = (LPTSTR)lpbAddress;
    }

    // Parse the addrtype and address out of the entryid
    // DebugTrace(TEXT("NewOneOff: [%s:%s:%s]\n"), lpDisplayName, lpAddrType, lpAddress);

    // Create a new MAILUSER object
    if (HR_FAILED(hResult = HrNewMAILUSER(lpIAB, NULL, MAPI_MAILUSER, 0, &lpMailUser))) {
        goto exit;
    }
    lpPropData = ((LPMailUser)lpMailUser)->lpPropData;


    // Fill it with properties... we only have a few.
    //  PR_OBJECT_TYPE
    spv[iooPR_ADDRTYPE].ulPropTag = PR_ADDRTYPE;
    spv[iooPR_ADDRTYPE].Value.LPSZ = lptszAddrType;

    spv[iooPR_DISPLAY_NAME].ulPropTag = PR_DISPLAY_NAME;
    spv[iooPR_DISPLAY_NAME].Value.LPSZ = lptszDisplayName;

    spv[iooPR_EMAIL_ADDRESS].ulPropTag = PR_EMAIL_ADDRESS;
    spv[iooPR_EMAIL_ADDRESS].Value.LPSZ = lptszAddress;

    spv[iooPR_ENTRYID].ulPropTag = PR_ENTRYID;
    spv[iooPR_ENTRYID].Value.bin.lpb = (LPBYTE)lpEntryID;
    spv[iooPR_ENTRYID].Value.bin.cb = cbEntryID;

// BUGBUG: This is already done in HrNewMAILUSER.
    spv[iooPR_OBJECT_TYPE].ulPropTag = PR_OBJECT_TYPE;
    spv[iooPR_OBJECT_TYPE].Value.l = MAPI_MAILUSER;

    Assert(lpMailUser);

    //  Set the properties
    if (HR_FAILED(hResult = lpPropData->lpVtbl->SetProps(lpPropData,
      iooMax,                       // number of properties to set
      spv,                          // property array
      NULL))) {                     // problem array
        goto exit;
    }

    *lpulObjType = MAPI_MAILUSER;
    *lppUnk = (LPUNKNOWN)lpMailUser;

exit:
    if (!(ulMapiDataType & MAPI_UNICODE))
    {
        LocalFreeAndNull(&lptszDisplayName);
        LocalFreeAndNull(&lptszAddrType);
        LocalFreeAndNull(&lptszAddress);
    }
    if (HR_FAILED(hResult)) {
        FreeBufferAndNull(&lpMailUser);
    }

    return(hResult);
}



typedef enum {
    e_IMailUser,
    e_IDistList,
    e_IABContainer,
    e_IMAPIContainer,
    e_IMAPIProp,
} INTERFACE_INDEX;

/***************************************************************************

    Name      : HrAddPrSearchKey

    Purpose   : Dynamically creates a PR_SEARCH_KEY and adds it to the object.

    Parameters: lppUnk -> pointer to mailuser object

    Returns   : HRESULT

    Comment   : No UNICODE flags.

***************************************************************************/
HRESULT HrAddPrSearchKey(LPUNKNOWN FAR * lppUnk,
                         ULONG cbEntryID,
                         LPENTRYID lpEntryID)
{
    HRESULT hr = E_FAIL;
    ULONG ulcProps = 0;
    LPSPropValue lpPropArray = NULL;
    LPMAILUSER lpMailUser = NULL;
    LPSPropValue    lpPropArrayNew      = NULL;
    ULONG           ulcPropsNew         = 0;
    ULONG           i = 0;
    SCODE sc;
    ULONG ulObjAccess = 0;
    LPIPDAT lpPropData = NULL;

    if(!lppUnk || !(*lppUnk))
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto exit;
    }

    lpMailUser = (LPMAILUSER) (*lppUnk);

    lpPropData = (LPIPDAT) ((LPMailUser) lpMailUser)->lpPropData;

    //temporarily overwrite the object access so we can modify it here
    ulObjAccess = lpPropData->ulObjAccess;
    lpPropData->ulObjAccess = IPROP_READWRITE;

    hr = lpMailUser->lpVtbl->GetProps(  lpMailUser,
                                        NULL,
                                        MAPI_UNICODE,
                                        &ulcProps,
                                        &lpPropArray);

    if(HR_FAILED(hr))
        goto exit;

    if (ulcProps && lpPropArray)
    {

        // 4/14/97 - vikramm
        // Outlook expects a PR_SEARCH_KEY on each mailuser or distlist
        // This is a dynamic property created at runtime - ideally, if we're
        // running against outlook store, we should have one at this point
        // but to be consistent, if we dont have one we should add one
        // The PR_SEARCH_KEY is a binary property which is made of the
        // email address or if there is no email address, is the entryid of
        // this contact ..
        {
            SPropValue PropSearchKey = {0};
            LPTSTR lpszEmail = NULL;
            LPTSTR lpszAddrType = NULL;

            BOOL bSearchKeyFound = FALSE;

            for (i = 0; i < ulcProps; i++)
            {
                switch(lpPropArray[i].ulPropTag)
                {
                case PR_EMAIL_ADDRESS:
                    lpszEmail = lpPropArray[i].Value.LPSZ;
                    break;
                case PR_ADDRTYPE:
                    lpszAddrType = lpPropArray[i].Value.LPSZ;
                    break;
                case PR_SEARCH_KEY:
                    bSearchKeyFound = TRUE;
                    break;
                }
            }

            if(!bSearchKeyFound)
            {
                PropSearchKey.ulPropTag = PR_SEARCH_KEY;

                //Create a search key
                if(lpszEmail && lpszAddrType)
                {
                    // Search Key is based on email address
                    // [PaulHi] 4/23/99  Raid 76717
                    // The Search Key strings must be single byte for Outlook.  Do conversion here.
                    {
                        LPSTR   lpszKey;
                        LPWSTR  lpwszKey = LocalAlloc( LMEM_ZEROINIT, 
                                                       (sizeof(WCHAR)*(lstrlen(lpszAddrType) + 1 + lstrlen(lpszEmail) + 1)) );

                        if (!lpwszKey)
                        {
                            hr = MAPI_E_NOT_ENOUGH_MEMORY;
                            goto exit;
                        }

                        lstrcpy(lpwszKey, lpszAddrType);
                        lstrcat(lpwszKey, szColon);
                        lstrcat(lpwszKey, lpszEmail);

                        // This search key should be in upper case
                        CharUpper(lpwszKey);

                        lpszKey = ConvertWtoA(lpwszKey);
                        LocalFreeAndNull(&lpwszKey);

                        if (!lpszKey)
                        {
                            hr = MAPI_E_NOT_ENOUGH_MEMORY;
                            goto exit;
                        }
                        
                        PropSearchKey.Value.bin.cb = (lstrlenA(lpszKey) + 1);
                        PropSearchKey.Value.bin.lpb = (LPBYTE)lpszKey;
                    }
                }
                else
                {
                    // Search key is based on entry id
                    if(!cbEntryID || !lpEntryID)
                    {
                        hr = MAPI_E_INVALID_PARAMETER;
                        goto exit;
                    }
                    PropSearchKey.Value.bin.cb = cbEntryID;
                    PropSearchKey.Value.bin.lpb = (LPBYTE) lpEntryID;
                }

                // Add this search key to the proparray
                sc = ScMergePropValues( 1,
                                        &PropSearchKey,
                                        ulcProps,
                                        lpPropArray,
                                        &ulcPropsNew,
                                        &lpPropArrayNew);

                // Free this pointer if it was allocated
                if(PropSearchKey.Value.bin.lpb != (LPBYTE) lpEntryID)
                    LocalFree(PropSearchKey.Value.bin.lpb);

                if (sc != S_OK)
                {
                    hr = ResultFromScode(sc);
                    goto exit;
                }
            }

        }

        if (HR_FAILED(hr = lpMailUser->lpVtbl->SetProps(lpMailUser,
                    (lpPropArrayNew ? ulcPropsNew : ulcProps),     // number of properties to set
                    (lpPropArrayNew ? lpPropArrayNew : lpPropArray),  // property array
                      NULL)))      // problem array
        {
            goto exit;
        }
    }

exit:

    // reset the object access
    if(!HR_FAILED(hr) &&
       (ulObjAccess != lpPropData->ulObjAccess))
    {
        lpPropData->ulObjAccess = ulObjAccess;
    }

    if(lpPropArrayNew)
        MAPIFreeBuffer(lpPropArrayNew);
    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    return hr;
}


/***************************************************************************

    Name      : IADDRBOOK_GetIDsFromNames

    Returns   : HRESULT

    Comment   :

***************************************************************************/
STDMETHODIMP
IAB_GetIDsFromNames(LPIAB lpIAB,  ULONG cPropNames, LPMAPINAMEID * lppPropNames, 
                       ULONG ulFlags, LPSPropTagArray * lppPropTags)
{
 #if     !defined(NO_VALIDATION)
    // Make sure the object is valid.
    if (BAD_STANDARD_OBJ(lpIAB, IAB_, GetIDsFromNames, lpVtbl)) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
#endif

    VerifyWABOpenExSession(lpIAB);

    return HrGetIDsFromNames(lpIAB,  
                            cPropNames,
                            lppPropNames, ulFlags, lppPropTags);
}


/***************************************************************************

    Name      : IADDRBOOK::OpenEntry

    Purpose   : Asks the appropriate provider to give a appropriate object
	             relevant to the given lpEntryID.

    Parameters: lpIAB -> this addrbook object
                cbEntryID = size of lpEntryID
                lpEntryID -> entry ID of one off to open
                lpInterface -> requested interface
                ulFlags = flags
                lpulObjType -> returned object type
                lppUnk -> returned object

    Returns   : HRESULT

    Comment   : A special case is the One-Off Provider.  There is no *real*
                provider associated with One-Off entry IDs.  Still though,
                we'll try to treat them much the same as any other provider.

                No UNICODE flags.

***************************************************************************/
STDMETHODIMP
IAB_OpenEntry(LPIAB lpIAB,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  LPCIID lpInterface,
  ULONG ulFlags,
  ULONG FAR * lpulObjType,
  LPUNKNOWN FAR * lppUnk)
{

    HRESULT         hr                  = hrSuccess;
    LPMAILUSER      lpMailUser          = NULL;
    LPMAPIPROP      lpMapiProp          = NULL;
    ULONG           ulcProps;
    LPSPropValue    lpPropArray         = NULL;
    ULONG           i;
    ULONG           ulType;
    INTERFACE_INDEX ii = e_IMailUser;
    SCODE sc;

#ifndef DONT_ADDREF_PROPSTORE
    if ((FAILED(sc = OpenAddRefPropertyStore(NULL, lpIAB->lpPropertyStore)))) {
        hr = ResultFromScode(sc);
        goto exitNotAddRefed;
    }
#endif


#ifdef PARAMETER_VALIDATION

    //
    //  Parameter Validataion
    //

    //  Is this one of mine??
    if (IsBadReadPtr(lpIAB, sizeof(IAB))) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (lpIAB->lpVtbl != &vtblIAB) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (lpInterface && IsBadReadPtr(lpInterface, sizeof(IID))) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags & ~(MAPI_MODIFY | MAPI_DEFERRED_ERRORS | MAPI_BEST_ACCESS)) {
        DebugTraceArg(IAB_OpenEntry ,  TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (IsBadWritePtr(lpulObjType, sizeof(ULONG))) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (IsBadWritePtr(lppUnk, sizeof(LPUNKNOWN))) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif // PARAMETER_VALIDATION


    VerifyWABOpenExSession(lpIAB);

    EnterCriticalSection(&lpIAB->cs);

    //
    //  First check to see if it's NULL - if so, it is our ROOT container
    //
    if (! lpEntryID) {
        hr = HrNewCONTAINER(lpIAB,
          AB_ROOT,      // ulType
          lpInterface,
          ulFlags,
          cbEntryID,
          lpEntryID,
          lpulObjType,
          lppUnk);

        goto exit;
    }

    switch (IsWABEntryID(cbEntryID, lpEntryID, NULL, NULL, NULL, NULL, NULL)) {
        case WAB_PABSHARED:
        case WAB_PAB:
            hr = HrNewCONTAINER(lpIAB,
              AB_PAB,       // ulType
              lpInterface,
              ulFlags,
              cbEntryID,
              lpEntryID,
              lpulObjType,
              lppUnk);
            goto exit;

		case WAB_CONTAINER:
            hr = HrNewCONTAINER(lpIAB,
              AB_CONTAINER,
              lpInterface,
              ulFlags,
              cbEntryID,
              lpEntryID,
              lpulObjType,
              lppUnk);
            goto exit;

        case WAB_LDAP_CONTAINER:
            // Check if the EntryID is for the WAB's PAB container.
            hr = HrNewCONTAINER(lpIAB,
              AB_LDAP_CONTAINER,        // ulType
              lpInterface,
              ulFlags,
              cbEntryID,
              lpEntryID,
              lpulObjType,
              lppUnk);
            goto exit;

        case WAB_LDAP_MAILUSER:
            hr = LDAP_OpenMAILUSER(lpIAB,
                cbEntryID,
              lpEntryID,
              lpInterface,
              ulFlags,
              lpulObjType,
              lppUnk);
            if(!HR_FAILED(hr))
            {
                hr = HrAddPrSearchKey(lppUnk, cbEntryID, lpEntryID);
            }
            goto exit;
    }


    // Check for One-Off
    if (IsOneOffEID(cbEntryID, lpEntryID)) {
        // Create a one-off mailuser object

        hr = NewOneOff(lpIAB,
          cbEntryID,
          lpEntryID,
          lpulObjType,
          lppUnk);

        if(!HR_FAILED(hr))
        {
            hr = HrAddPrSearchKey(lppUnk, cbEntryID, lpEntryID);
        }
        goto exit;
    }

    //
    // Not NULL, is it ours?
    //

    // assume it is ours ..
    {
        SBinary sbEID = {0};
        sbEID.cb = cbEntryID;
        sbEID.lpb = (LPBYTE) lpEntryID;

        // What interface was requested?
        // We've basically got 2 interfaces here... IMailUser and IDistList.
        if (lpInterface != NULL) {
            if (! memcmp(lpInterface, &IID_IMailUser, sizeof(IID))) {
                ii = e_IMailUser;
            } else if (! memcmp(lpInterface, &IID_IDistList, sizeof(IID))) {
                ii = e_IDistList;
            } else if (! memcmp(lpInterface, &IID_IABContainer, sizeof(IID))) {
                ii = e_IABContainer;
            } else if (! memcmp(lpInterface, &IID_IMAPIContainer, sizeof(IID))) {
                ii = e_IMAPIContainer;
            } else if (! memcmp(lpInterface, &IID_IMAPIProp, sizeof(IID))) {
                ii = e_IMAPIProp;
            } else {
                hr = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
                goto exit;
            }
        }
/*** Bug:31975 - dont default to mail user
        else {
            ii = e_IMailUser;
        }
*/
        Assert(lpIAB->lpPropertyStore->hPropertyStore);
        if (HR_FAILED(hr = ReadRecord(lpIAB->lpPropertyStore->hPropertyStore,
          &sbEID,                // EntryID
          0,                        // ulFlags
          &ulcProps,                // number of props returned
          &lpPropArray))) {         // properties returned
            DebugTraceResult(IAB_OpenEntry:ReadRecord, hr);
            goto exit;
        }

        ulType = MAPI_MAILUSER;     // Default

        if (ulcProps) {
            Assert(lpPropArray);
            if (lpPropArray) {
                // Look for PR_OBJECT_TYPE
                for (i = 0; i < ulcProps; i++) {
                    if (lpPropArray[i].ulPropTag == PR_OBJECT_TYPE) {
                        ulType = lpPropArray[i].Value.l;
                        break;
                    }
                }
            }
        }

/*** Bug 31975 - dont default to mailuser **/
        if(!lpInterface)
        {
            ii = (ulType == MAPI_DISTLIST) ? e_IDistList : e_IMailUser;
        }

        switch (ulType) {
            case MAPI_MAILUSER:
            case MAPI_ABCONT:
                switch (ii) {
                    case e_IMailUser:
                    case e_IMAPIContainer:
                    case e_IMAPIProp:
                        // Create a new MAILUSER object
                        if (HR_FAILED(hr = HrNewMAILUSER(lpIAB,
                                                          NULL,
                                                          MAPI_MAILUSER,
                                                          0,
                                                          &lpMapiProp))) 
                        {
                            goto exit;
                        }
                        HrSetMAILUSERAccess((LPMAILUSER)lpMapiProp, MAPI_MODIFY);
                        break;
                    default:
                        hr = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
                        goto exit;
                }
                break;

            case MAPI_DISTLIST:
                switch (ii) {
                    case e_IMailUser:
                    case e_IMAPIProp:
                        // Create a new MAILUSER object
                        if (HR_FAILED(hr = HrNewMAILUSER(lpIAB,
                          NULL,
                          ulType,
                          0,
                          &lpMapiProp))) {
                            goto exit;
                        }
                        HrSetMAILUSERAccess((LPMAILUSER)lpMapiProp, MAPI_MODIFY);
                        break;

                    case e_IDistList:
                    case e_IABContainer:
                    case e_IMAPIContainer:
                        // Create the Distribution List object.
                        if (HR_FAILED(hr = HrNewCONTAINER(lpIAB,
                          AB_DL,        // ulType
                          lpInterface,
                          ulFlags,
                          0,
                          NULL,
                          lpulObjType,
                          &lpMapiProp))) {
                            goto exit;
                        }
                        HrSetCONTAINERAccess((LPCONTAINER)lpMapiProp, MAPI_MODIFY);
                        break;

                    default:
                        Assert(FALSE);
                }
                break;

            default:
                {
                    //Assert(FALSE);
                    // Most likely if we got here we got an object of type MAPI_ABCONT somehow..
                    // better to fail here gracefully than to barf and assert and then crash
                    hr = MAPI_E_INVALID_OBJECT;
                    goto exit;
                }
                break;
        }

        if (ulcProps && lpPropArray)
        {
            LPPROPDATA lpPropData = NULL;

            // If the entry had properties, set them in our returned object
            lpPropData = ((LPMailUser)lpMapiProp)->lpPropData;

            if (HR_FAILED(hr = lpPropData->lpVtbl->SetProps(lpPropData,
                                        ulcProps,     // number of properties to set
                                        lpPropArray,  // property array
                                        NULL)))      // problem array
            {
                goto exit;
            }
        }

        switch (ulType) {
            case MAPI_MAILUSER:
                HrSetMAILUSERAccess((LPMAILUSER)lpMapiProp, ulFlags);
                break;

            case MAPI_DISTLIST:
                HrSetCONTAINERAccess((LPCONTAINER)lpMapiProp, ulFlags);
                break;
        }
        *lpulObjType = ulType;

        *lppUnk = (LPUNKNOWN)lpMapiProp;

        if(!HR_FAILED(hr))
        {
            hr = HrAddPrSearchKey(lppUnk, cbEntryID, lpEntryID);
        }

        goto exit;      // success
    }

    hr = ResultFromScode(MAPI_E_INVALID_ENTRYID);

exit:
#ifndef DONT_ADDREF_PROPSTORE
    ReleasePropertyStore(lpIAB->lpPropertyStore);
exitNotAddRefed:
#endif
    ReadRecordFreePropArray( lpIAB->lpPropertyStore->hPropertyStore,
                        ulcProps,
                        &lpPropArray);     // Free memory from ReadRecord


    LeaveCriticalSection(&lpIAB->cs);
    DebugTraceResult(IAB_OpenEntry, hr);
    return(hr);
}


/**************************************************
 *
 *  IADRBOOK::CreateOneOff()
 *
 *		Creates an entry ID which has all the information
 *		about this entry contained within it.
 *
 *	Notes:
 *		I need a MAPIUID.  For now, I'll make one up.
 *		The ulDataType is UNICODE.  I'll define that in
 *		_abint.h for now.
 *
 *		Now UNICODE enabled.  If the MAPI_UNICODE flag is set
 *		the text elements of the EntryID will be WCHAR.
 */
STDMETHODIMP
IAB_CreateOneOff(LPIAB lpIAB,
  LPTSTR lpszName,
  LPTSTR lpszAdrType,
  LPTSTR lpszAddress,
  ULONG ulFlags,
  ULONG * lpcbEntryID,
  LPENTRYID * lppEntryID)
{

    HRESULT hr = hrSuccess;
    BOOL    bIsUnicode = (ulFlags & MAPI_UNICODE) == MAPI_UNICODE;

    LPTSTR lpName = NULL, lpAdrType = NULL, lpAddress = NULL;

    if(!bIsUnicode) // <note> assumes UNICODE defined
    {
        lpName =    ConvertAtoW((LPSTR)lpszName);
        lpAdrType = ConvertAtoW((LPSTR)lpszAdrType);
        lpAddress = ConvertAtoW((LPSTR)lpszAddress);
    }
    else
    {
        lpName = lpszName;
        lpAdrType = lpszAdrType;
        lpAddress = lpszAddress;
    }


    hr = CreateWABEntryIDEx(bIsUnicode,
                          WAB_ONEOFF,
                          lpName,
                          lpAdrType,
                          lpAddress,
                          0, 0,
                          NULL,
                          lpcbEntryID,
                          lppEntryID);

    if(!bIsUnicode) // <note> assumes UNICODE defined
    {
        LocalFreeAndNull(&lpName);
        LocalFreeAndNull(&lpAdrType);
        LocalFreeAndNull(&lpAddress);
    }
    return(hr);
}



STDMETHODIMP
IAB_CompareEntryIDs(LPIAB lpIAB,
  ULONG cbEntryID1,
  LPENTRYID lpEntryID1,
  ULONG cbEntryID2,
  LPENTRYID lpEntryID2,
  ULONG ulFlags,
  ULONG * lpulResult)
{
    LPMAPI_ENTRYID	lpMapiEid1 = (LPMAPI_ENTRYID) lpEntryID1;
    LPMAPI_ENTRYID	lpMapiEid2 = (LPMAPI_ENTRYID) lpEntryID2;
    HRESULT hr = hrSuccess;


#ifdef PARAMETER_VALIDATION

    //
    //  Parameter Validataion
    //

    //  Is this one of mine??
    if (IsBadReadPtr(lpIAB, sizeof(IAB)))
    {
        //return(ReportResult(0, MAPI_E_INVALID_PARAMETER, 0, 0));
        DebugTrace(TEXT("ERROR: IAB_CompareEntryIDs - invalid lpIAB"));
        return (MAPI_E_INVALID_PARAMETER);
    }

    if (lpIAB->lpVtbl != &vtblIAB)
    {
        //return(ReportResult(0, MAPI_E_INVALID_PARAMETER, 0, 0));
        DebugTrace(TEXT("ERROR: IAB_CompareEntryIDs - invalid lpIAB Vtable"));
        return (MAPI_E_INVALID_PARAMETER);
    }

    //  ulFlags must be 0
    if (ulFlags)
    {
        //return(ReportResult(0, MAPI_E_UNKNOWN_FLAGS, 0, 0));
        DebugTrace(TEXT("WARNING: IAB_CompareEntryIDs - invalid flag parameter"));
        // No need to return error
    }

    if (IsBadWritePtr(lpulResult, sizeof(ULONG)))
    {
        //return(ReportResult(0, MAPI_E_INVALID_PARAMETER, 0, 0));
        DebugTrace(TEXT("ERROR: IAB_CompareEntryIDs - invalid out pointer"));
        return (MAPI_E_INVALID_PARAMETER);
    }

    // NULL EIDs are OK
    if ( cbEntryID1 && lpEntryID1 &&
         IsBadReadPtr(lpEntryID1, cbEntryID1) )
    {
        DebugTrace(TEXT("ERROR: IAB_CompareEntryIDs - invalid EntryID1"));
        return (MAPI_E_INVALID_PARAMETER);
    }

    if ( cbEntryID2 && lpEntryID2 &&
         IsBadReadPtr(lpEntryID2, cbEntryID2))
    {
        DebugTrace(TEXT("ERROR: IAB_CompareEntryIDs - invalid EntryID2"));
        return (MAPI_E_INVALID_PARAMETER);
    }

#endif // PARAMETER_VALIDATION

    EnterCriticalSection(&lpIAB->cs);

    *lpulResult = FALSE;    // default

    //   Optimization, see if they're binarily the same
    if (cbEntryID1 == cbEntryID2) {
        if (cbEntryID1 && 0 == memcmp((LPVOID) lpMapiEid1, (LPVOID) lpMapiEid2,
          (size_t) cbEntryID1)) {
            //
            //  They've got to be the same
            //

            *lpulResult = TRUE;
            hr = hrSuccess;
            goto exit;
        }
    }
exit:
    LeaveCriticalSection(&lpIAB->cs);

    return(hr);
}


//-----------------------------------------------------------------------------
// Synopsis:    IAB_Advise()
// Description:
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//-----------------------------------------------------------------------------

STDMETHODIMP
IAB_Advise(LPIAB lpIAB,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  ULONG ulEventMask,
  LPMAPIADVISESINK lpAdvise,
  ULONG FAR * lpulConnection)
{
    HRESULT hr = hrSuccess;
    SCODE sc = S_OK;
    LPSTR lpszError = NULL;
    LPSTR lpszComponent = NULL;

//  LPMAPI_ENTRYID lpMapiEid = (LPMAPI_ENTRYID) lpEntryID;
//  LPLSTPROVDATA lpProvData = NULL;
//  LPABLOGON       lpABLogon = NULL;




    // The basic advise implementation ignores the entryids and only looks
    // for event masks of type OBjectModified. The only notifications fired
    // are for any changes in the WAB store...
    //

    if (! ulEventMask || !(ulEventMask & fnevObjectModified))
        return MAPI_E_INVALID_PARAMETER;

    hr = HrAdvise(lpIAB,
      cbEntryID,
      lpEntryID,
      ulEventMask,
      lpAdvise,
      lpulConnection);


    return(hr);
}

//-----------------------------------------------------------------------------
// Synopsis:    IAB_Unadvise()
// Description:
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//-----------------------------------------------------------------------------
STDMETHODIMP
IAB_Unadvise (LPIAB lpIAB, ULONG ulConnection)
{

    HRESULT hr = hrSuccess;
    SCODE sc = S_OK;



    hr = HrUnadvise(lpIAB, ulConnection);

    return(hr);
}



//
// Interesting table columns
//
enum {
    ifePR_CONTACT_EMAIL_ADDRESSES = 0,
    ifePR_EMAIL_ADDRESS,
    ifePR_DISPLAY_NAME,
    ifePR_OBJECT_TYPE,
    ifePR_USER_X509_CERTIFICATE,
    ifePR_ENTRYID,
    ifePR_SEARCH_KEY,
    ifeMax
};
static const SizedSPropTagArray(ifeMax, ptaFind) =
{
    ifeMax,
    {
        PR_CONTACT_EMAIL_ADDRESSES,
        PR_EMAIL_ADDRESS,
        PR_DISPLAY_NAME,
        PR_OBJECT_TYPE,
        PR_USER_X509_CERTIFICATE,
        PR_ENTRYID,
        PR_SEARCH_KEY
    }
};

/***************************************************************************

    Name      : HrRowToADRENTRY

    Purpose   : Gets the next row from a table and places it in the ADRENTRY

    Parameters: lpIAB -> Address book object
                lpTable -> table object
                lpAdrEntry = ADRENTRY to fill

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT HrRowToADRENTRY(LPIAB lpIAB, LPMAPITABLE lpTable, LPADRENTRY lpAdrEntry, BOOL bUnicode) {
    HRESULT hResult;
    LPSRowSet lpRow = NULL;
    SCODE sc;
    LPMAPIPROP lpMailUser = NULL;
    LPSPropValue lpPropArray = NULL;
    LPSPropValue lpPropArrayNew = NULL;
    ULONG ulObjType, cValues, cPropsNew;

    if (hResult = lpTable->lpVtbl->QueryRows(lpTable,
      1,    // First row only
      0,    // ulFlags
      &lpRow)) {
        DebugTrace(TEXT("GetNextRowEID:QueryRows -> %x\n"), GetScode(hResult));
    } else {
        // Found it, copy entryid to new allocation
        if (lpRow->cRows) {

            if (HR_FAILED(hResult = lpIAB->lpVtbl->OpenEntry(lpIAB,
              lpRow->aRow[0].lpProps[ifePR_ENTRYID].Value.bin.cb,               // cbEntryID
              (LPENTRYID)lpRow->aRow[0].lpProps[ifePR_ENTRYID].Value.bin.lpb,   // entryid of first match
              NULL,             // interface
              0,                // ulFlags
              &ulObjType,       // returned object type
              (LPUNKNOWN *)&lpMailUser))) {

                // Failed!  Hmmm.
                DebugTraceResult( TEXT("ResolveNames OpenEntry"), hResult);
                goto exit;
            }
            Assert(lpMailUser);

            if (HR_FAILED(hResult = lpMailUser->lpVtbl->GetProps(lpMailUser,
              (LPSPropTagArray)&ptaResolveDefaults,   // lpPropTagArray
              (bUnicode ? MAPI_UNICODE : 0),            // ulFlags
              &cValues,     // how many properties were there?
              &lpPropArray))) {

                DebugTraceResult( TEXT("ResolveNames GetProps"), hResult);
                goto exit;
            }
            hResult = hrSuccess;

            // Now, construct the new ADRENTRY
            // (Allocate a new one, free the old one.
            Assert(lpPropArray);

            // Merge the new props with the ADRENTRY props
            if (sc = ScMergePropValues(lpAdrEntry->cValues,
              lpAdrEntry->rgPropVals,           // source1
              cValues,
              lpPropArray,                      // source2
              &cPropsNew,
              &lpPropArrayNew)) {               // dest
                goto exit;
            }

            // [PaulHi] 2/1/99
            // GetProps now only returns requested property strings in the requested
            // format (UNICODE or ANSI).  If the client calls this function without
            // the MAPI_UNICODE flag then ensure all string properties are converted
            // to ANSI.
            //
            // @review  2/1/99  These ScConvertWPropsToA conversions are expensive, 
            // since there currently is no "MAPIRealloc" function and the original
            // string memory remains allocated until the props array is deallocated.
            if (!bUnicode)
            {
                if(sc = ScConvertWPropsToA((LPALLOCATEMORE) (&MAPIAllocateMore), lpPropArrayNew, cPropsNew, 0))
                    goto exit;
            }

            // Free the original prop value array
            FreeBufferAndNull((LPVOID *) (&(lpAdrEntry->rgPropVals)));

            lpAdrEntry->cValues = cPropsNew;
            lpAdrEntry->rgPropVals = lpPropArrayNew;

            FreeBufferAndNull(&lpPropArray);
        } else {
            hResult = ResultFromScode(MAPI_E_NOT_FOUND);
        }
    }
exit:
    if (lpMailUser) {
        UlRelease(lpMailUser);
    }
    if (lpRow) {
        FreeProws(lpRow);
    }
    return(hResult);
}


/***************************************************************************

    Name      : InitPropertyRestriction

    Purpose   : Fills in the property restriction structure

    Parameters: lpsres -> SRestriction to fill in
                lpspv -> property value structure for this property restriction

    Returns   : none

    Comment   :

***************************************************************************/
void InitPropertyRestriction(LPSRestriction lpsres, LPSPropValue lpspv) {
    lpsres->rt = RES_PROPERTY;    // Restriction type Property
    lpsres->res.resProperty.relop = RELOP_EQ;
    lpsres->res.resProperty.ulPropTag = lpspv->ulPropTag;
    lpsres->res.resProperty.lpProp = lpspv;
}

/***************************************************************************

    Name      : HrSmartResolve

    Purpose   : Goes to great lengths to single out contacts in the local WAB.

    Parameters: lpIAB = adrbook object
                lpContainer = container to search
                ulFlags = flags passed to ResolveName
                lpAdrList -> [in/out] ADRLIST
                lpFlagList -> flags corresponding to adrlist
                lpAmbiguousTables -> ambiguity dialog information

    Returns   : HRESULT

    Comment   : Assumes that the container's ResolveNames method has already
                been called and has filled in lpFlagList.  This routine goes
                the extra mile to find email addresses and to resolve
                ambiguity.

                When we get here, we can assume that the DisplayName was
                either not found or was ambiguous.

***************************************************************************/
HRESULT HrSmartResolve(LPIAB lpIAB, LPABCONT lpContainer, ULONG ulFlags,
  LPADRLIST lpAdrList, LPFlagList lpFlagList, LPAMBIGUOUS_TABLES lpAmbiguousTables) {
    HRESULT hResult = hrSuccess;
    SCODE sc;

    SRestriction res;
    SRestriction resAnd[5];                 // array for AND restrictions
    SPropValue propObjectType, propEmail, propEmails, propDisplayName;
    LPSPropValue lpPropArray = NULL;
    LPSRowSet lpRow = NULL;
    LPSRowSet lpSRowSet = NULL;

    LPMAPITABLE lpTable = NULL;
    LPMAPITABLE lpAmbiguousTable;
    LPTABLEDATA FAR lpTableData = NULL;
    LPADRENTRY lpAdrEntry;
    LPMAPIPROP lpMailUser = NULL;

    LPTSTR lpDisplayName = NULL, lpEmailAddress = NULL;
    ULONG ulObjectType;
    ULONG ulObjType, ulRowCount, i, j, index, cValues;
    ULONG resCount;

    BOOL bUnicode = ulFlags & WAB_RESOLVE_UNICODE;


    Assert(lpAdrList->cEntries == lpFlagList->cFlags);

    //
    // Get the contents table for the PAB container
    //
    if (HR_FAILED(hResult = lpContainer->lpVtbl->GetContentsTable(lpContainer,
        WAB_PROFILE_CONTENTS | WAB_CONTENTTABLE_NODATA | MAPI_UNICODE,    // This table is internal to this function hence is in Unicode
      &lpTable))) {
        DebugTrace(TEXT("PAB GetContentsTable -> %x\n"), GetScode(hResult));
        goto exit;
    }

    // Set the column set
    if (HR_FAILED(hResult = lpTable->lpVtbl->SetColumns(lpTable,
      (LPSPropTagArray)&ptaFind, 0))) {
        DebugTrace(TEXT("PAB SetColumns-> %x\n"), GetScode(hResult));
        goto exit;
    }

    // Set up the property values for restrictions
    propObjectType.ulPropTag = PR_OBJECT_TYPE;
    propEmail.ulPropTag = PR_EMAIL_ADDRESS;
    propDisplayName.ulPropTag = PR_DISPLAY_NAME;
    propEmails.ulPropTag = PR_CONTACT_EMAIL_ADDRESSES;
    propEmails.Value.MVSZ.cValues = 1;

    // All of our restrictions are AND restrictions using the resAnd array
    res.rt = RES_AND;
    res.res.resAnd.lpRes = resAnd;
    // res.res.resAnd.cRes = 2;     Caller must fill in before calling Restrict

    //
    // Loop through every entry, looking for those that need
    // attention.
    //
    for (i = 0; i < lpFlagList->cFlags; i++) 
    {
        lpAdrEntry = &lpAdrList->aEntries[i];

        if (lpFlagList->ulFlag[i] == MAPI_UNRESOLVED ||
            lpFlagList->ulFlag[i] == MAPI_AMBIGUOUS) 
        {

            if(!bUnicode) // <note> assumes Unicode Defined
            {
                LocalFreeAndNull(&lpDisplayName);
                LocalFreeAndNull(&lpEmailAddress);
            }
            else
                lpDisplayName = lpEmailAddress = NULL;  // init the strings

            ulObjectType = 0;                       // invalid type
            resCount = 0;
            ulRowCount = 0;

            // walk through the prop list for this entry looking for interesting props
            for (j = 0; j < lpAdrEntry->cValues; j++) 
            {
                ULONG ulPropTag = lpAdrEntry->rgPropVals[j].ulPropTag;
                if(!bUnicode && PROP_TYPE(ulPropTag)==PT_STRING8) // <note> assumes Unicode Defined
                    ulPropTag = CHANGE_PROP_TYPE(ulPropTag, PT_UNICODE);

                if (ulPropTag == PR_OBJECT_TYPE) 
                {
                    ulObjectType = lpAdrEntry->rgPropVals[j].Value.l;
                    propObjectType.Value.ul = ulObjectType;
                }
                if (ulPropTag == PR_EMAIL_ADDRESS) 
                {
                    lpEmailAddress =(bUnicode) ? 
                                    lpAdrEntry->rgPropVals[j].Value.lpszW :
                                    ConvertAtoW(lpAdrEntry->rgPropVals[j].Value.lpszA);
                    propEmails.Value.MVSZ.LPPSZ = &lpEmailAddress;
                    propEmail.Value.LPSZ = lpEmailAddress;

                }
                if (ulPropTag == PR_DISPLAY_NAME) 
                {
                    lpDisplayName = (bUnicode) ? 
                                    lpAdrEntry->rgPropVals[j].Value.lpszW :
                                    ConvertAtoW(lpAdrEntry->rgPropVals[j].Value.lpszA);
                    propDisplayName.Value.LPSZ = lpDisplayName;
                }
            }

            // Without email address, we can't improve on the standard resolve
            if (lpEmailAddress) 
            {
                // If unresolved, try PR_EMAIL_ADDRESS without displayname
                if (lpFlagList->ulFlag[i] == MAPI_UNRESOLVED ) 
                {
                    resCount = 0;
                    InitPropertyRestriction(&(resAnd[resCount++]), &propEmail);
                    if (ulObjectType) 
                    {
                        InitPropertyRestriction(&(resAnd[resCount++]), &propObjectType);
                    }

                    if (ulFlags & WAB_RESOLVE_NEED_CERT) 
                    {
                        resAnd[resCount].rt = RES_EXIST;
                        resAnd[resCount++].res.resExist.ulPropTag = PR_USER_X509_CERTIFICATE;
                    }
                    res.res.resAnd.cRes = resCount;

                    if (hResult = lpTable->lpVtbl->Restrict(lpTable, &res, 0)) 
                    {
                        goto exit;
                    }

                    // Did any match?
                    if (HR_FAILED(hResult = lpTable->lpVtbl->GetRowCount(lpTable, 0, &ulRowCount))) 
                    {
                        DebugTrace(TEXT("GetRowCount from AB contents table -> %x\n"), GetScode(hResult));
                        goto exit;
                    }
                    switch (ulRowCount) 
                    {
                        default:    // too many
                            if (! (ulFlags & WAB_RESOLVE_FIRST_MATCH)) 
                            {
                                // No point in narrowing the search with PR_DISPLAY_NAME since
                                // we know it wasn't found.  Also no point in putting in
                                // PR_CONTACT_EMAIL_ADDRESSES since that is ambiguous too.

                                // Drop out to the ambiguity handler
                                goto Ambiguity;
                            } // else fall through and take the first one

                        case 1:             // Found one!
                            if (hResult = HrRowToADRENTRY(lpIAB, lpTable, lpAdrEntry, bUnicode)) 
                            {
                                goto exit;
                            }
                            lpFlagList->ulFlag[i] = MAPI_RESOLVED;      // Mark this entry as found.
                            continue;   // next entry

                        case 0:
                            // No match, try PR_CONTACT_EMAIL_ADDRESSES
                            // Create the restriction to find the email address in the multi-valued
                            // PR_CONTACT_EMAIL_ADDRESSES.  (replace propEmail in the restriction)
                            resAnd[0].rt = RES_CONTENT;
                            resAnd[0].res.resContent.ulFuzzyLevel = FL_IGNORECASE | FL_FULLSTRING;
                            resAnd[0].res.resContent.ulPropTag = PR_CONTACT_EMAIL_ADDRESSES;
                            resAnd[0].res.resContent.lpProp = &propEmails;

                            if (hResult = lpTable->lpVtbl->Restrict(lpTable, &res, 0)) {
                                goto exit;
                            }

                            // Did any match?
                            if (HR_FAILED(hResult = lpTable->lpVtbl->GetRowCount(lpTable, 0, &ulRowCount))) {
                                DebugTrace(TEXT("GetRowCount from AB contents table -> %x\n"), GetScode(hResult));
                                goto exit;
                            }
                            switch (ulRowCount) {
                                default:        // More than one.   We'll catch it below.
                                    // Drop out to the ambiguity handler
                                    if (! (ulFlags & WAB_RESOLVE_FIRST_MATCH)) {
                                        // No point in narrowing the search with PR_DISPLAY_NAME since
                                        // we know it wasn't found.
                                        // Drop out to the ambiguity handler
                                        goto Ambiguity;
                                    } // else fall through and take the first one

                                case 1:         // Found one!
                                    if (hResult = HrRowToADRENTRY(lpIAB, lpTable, lpAdrEntry, bUnicode)) {
                                        goto exit;
                                    }
                                    lpFlagList->ulFlag[i] = MAPI_RESOLVED;      // Mark this entry as found.
                                    continue;

                                case 0:
                                    // We're SOL on this one.  Ignore it and move on.
                                    continue;
                            }
                            break;
                    }
                }

                // We should only get here if there was a MAPI_AMBIGUOUS flag

                //
                // Look for PR_DISPLAY_NAME and PR_EMAIL_ADDRESS
                //
                // propEmail goes first so that we can replace it with propEmails later
                InitPropertyRestriction(&(resAnd[resCount++]), &propEmail);
                if (lpDisplayName) {
                    // Shouldn't add the display name in if it is the same as the email!
                    if (lstrcmpi(lpDisplayName, lpEmailAddress)) {
                        InitPropertyRestriction(&(resAnd[resCount++]), &propDisplayName);
                    }
                }
                if (ulObjectType) {
                    InitPropertyRestriction(&(resAnd[resCount++]), &propObjectType);
                }
                if (ulFlags & WAB_RESOLVE_NEED_CERT) {
                    resAnd[resCount].rt = RES_EXIST;
                    resAnd[resCount++].res.resExist.ulPropTag = PR_USER_X509_CERTIFICATE;
                }
                res.res.resAnd.cRes = resCount;

                if (hResult = lpTable->lpVtbl->Restrict(lpTable, &res, 0)) {
                    goto exit;
                }

                // Did any match?
                if (HR_FAILED(hResult = lpTable->lpVtbl->GetRowCount(lpTable, 0, &ulRowCount))) {
                    DebugTrace(TEXT("GetRowCount from AB contents table -> %x\n"), GetScode(hResult));
                    goto exit;
                }
                switch (ulRowCount) {
                    default:    // too many
                        if (! (ulFlags & WAB_RESOLVE_FIRST_MATCH)) {
                            // No point in narrowing the search with PR_CONTACT_EMAIL_ADDRESSES
                            goto Ambiguity;
                        } // else fall through and take the first one

                    case 1:             // Found one!
                        if (hResult = HrRowToADRENTRY(lpIAB, lpTable, lpAdrEntry, bUnicode)) {
                            goto exit;
                        }
                        lpFlagList->ulFlag[i] = MAPI_RESOLVED;      // Mark this entry as found.
                        continue;

                    case 0:
                        // No match, try PR_DISPLAY_NAME and PR_CONTACT_EMAIL_ADDRESSES
                        // Create the restriction to find the email address in the multi-valued
                        // PR_CONTACT_EMAIL_ADDRESSES.
                        resAnd[0].rt = RES_CONTENT;
                        resAnd[0].res.resContent.ulFuzzyLevel = FL_IGNORECASE | FL_FULLSTRING;
                        resAnd[0].res.resContent.ulPropTag = PR_CONTACT_EMAIL_ADDRESSES;
                        resAnd[0].res.resContent.lpProp = &propEmails;

                        if (hResult = lpTable->lpVtbl->Restrict(lpTable, &res, 0)) {
                            goto exit;
                        }

                        // Did any match?
                        if (HR_FAILED(hResult = lpTable->lpVtbl->GetRowCount(lpTable, 0, &ulRowCount))) {
                            DebugTrace(TEXT("GetRowCount from AB contents table -> %x\n"), GetScode(hResult));
                            goto exit;
                        }
                        switch (ulRowCount) {
                            default:        // More than one.   We'll catch it below.
                                if (! (ulFlags & WAB_RESOLVE_FIRST_MATCH)) {
                                    goto Ambiguity;
                                } // else fall through and take the first one

                            case 1:         // Found one!
                                if (hResult = HrRowToADRENTRY(lpIAB, lpTable, lpAdrEntry, bUnicode)) {
                                    goto exit;
                                }
                                lpFlagList->ulFlag[i] = MAPI_RESOLVED;      // Mark this entry as found.
                                continue;

                            case 0:
                                // We're SOL on this one.  Ignore it and move on.
                                continue;
                        }
                        break;
                }

                if (ulRowCount > 1) 
                {
Ambiguity:
                    // Ambiguous results still in table.  We should do some more processing on
                    // this and if necesary, fill in the ambiguity table

                    // BUGBUG: Here is where we should add a restrict on the certificate property

                    if(lpAmbiguousTables)
                    {
                        // [PaulHi] 4/5/99  Use the Internal CreateTableData() function that takes 
                        // the ulFlags and will deal with ANSI/UNICODE requests correctly
                        sc = CreateTableData(
                                    NULL,
                                    (ALLOCATEBUFFER FAR *) MAPIAllocateBuffer,
                                    (ALLOCATEMORE FAR *) MAPIAllocateMore,
                                    MAPIFreeBuffer,
                                    NULL,
                                    TBLTYPE_DYNAMIC,
                                    PR_RECORD_KEY,
                                    (LPSPropTagArray)&ITableColumns,
                                    NULL,
                                    0,
                                    NULL,
                                    ulFlags,
                                    &lpTableData);
                        if ( FAILED(sc) )
                        {
                            DebugTrace(TEXT("CreateTableData() failed %x\n"), sc);
                            hResult = ResultFromScode(sc);
                            goto exit;
                        }

                        if(ulFlags & MAPI_UNICODE)
                            ((TAD*)lpTableData)->bMAPIUnicodeTable = bUnicode;

                        // Allocate an SRowSet to hold the entries.
                        if (FAILED(sc = MAPIAllocateBuffer(sizeof(SRowSet) + ulRowCount* sizeof(SRow),
                                                      (LPVOID *)&lpSRowSet))) 
                        {
                            DebugTrace(TEXT("Allocation of SRowSet failed\n"));
                            hResult = ResultFromScode(sc);
                            goto exit;
                        }

                        lpSRowSet->cRows = 0;
                        for (index = 0; index < ulRowCount; index++) 
                        {
                            if (hResult = lpTable->lpVtbl->QueryRows(lpTable,1,0,&lpRow)) 
                            {
                                DebugTrace(TEXT("GetNextRowEID:QueryRows -> %x\n"), GetScode(hResult));
                                break;
                            } 
                            else 
                            {
                                // Found one, copy entryid to new allocation
                                if (!lpRow->cRows) 
                                    break;

                                if (HR_FAILED(hResult = lpIAB->lpVtbl->OpenEntry(lpIAB,
                                                      lpRow->aRow[0].lpProps[ifePR_ENTRYID].Value.bin.cb,               // cbEntryID
                                                      (LPENTRYID)lpRow->aRow[0].lpProps[ifePR_ENTRYID].Value.bin.lpb,   // entryid of first match
                                                      NULL,             // interface
                                                      0,                // ulFlags
                                                      &ulObjType,       // returned object type
                                                      (LPUNKNOWN *)&lpMailUser))) 
                                {
                                    DebugTraceResult( TEXT("ResolveNames OpenEntry"), hResult);
                                    goto exit;
                                }
                                Assert(lpMailUser);

                                FreeProws(lpRow);
                                lpRow = NULL;

                                // This is stuffed into the SRowSet, so don't free it
                                if (HR_FAILED(hResult = lpMailUser->lpVtbl->GetProps(lpMailUser,
                                                          (LPSPropTagArray)&ptaResolveDefaults,   // lpPropTagArray
                                                          (bUnicode ? MAPI_UNICODE : 0),          // ulFlags
                                                          &cValues,     // how many properties were there?
                                                          &lpPropArray))) 
                                {
                                    DebugTraceResult( TEXT("ResolveNames GetProps"), hResult);
                                    goto exit;
                                }
                                hResult = hrSuccess;

                                UlRelease(lpMailUser);
                                lpMailUser = NULL;

                                // [PaulHi] 2/1/99  GetProps will return UNICODE strings from the 
                                // ptaResolveDefaults request array.  Convert to ANSI if our client
                                // is not UNICODE.
                                if (!bUnicode)
                                {
                                    // @review [PaulHi]  I am fairly certain that this lpPropArray array
                                    // will ALWAYS be allocated from our local MAPIAllocateMore function
                                    // and never from ((LPIDAT)lpMailUser->lpPropData)->inst.lpfAllocateMore.
                                    // Check this.
                                    if(sc = ScConvertWPropsToA((LPALLOCATEMORE) (&MAPIAllocateMore), lpPropArray, cValues, 0))
                                        goto exit;
                                }

                                // Fixup the PR_RECORD_KEY

                                // Make certain we have proper indicies.
                                // For now, we will equate PR_INSTANCE_KEY and PR_RECORD_KEY to PR_ENTRYID.
                                lpPropArray[irdPR_INSTANCE_KEY].ulPropTag = PR_INSTANCE_KEY;
                                lpPropArray[irdPR_INSTANCE_KEY].Value.bin.cb =
                                  lpPropArray[irdPR_ENTRYID].Value.bin.cb;
                                lpPropArray[irdPR_INSTANCE_KEY].Value.bin.lpb =
                                  lpPropArray[irdPR_ENTRYID].Value.bin.lpb;

                                lpPropArray[irdPR_RECORD_KEY].ulPropTag = PR_RECORD_KEY;
                                lpPropArray[irdPR_RECORD_KEY].Value.bin.cb =
                                  lpPropArray[irdPR_ENTRYID].Value.bin.cb;
                                lpPropArray[irdPR_RECORD_KEY].Value.bin.lpb =
                                  lpPropArray[irdPR_ENTRYID].Value.bin.lpb;

                                // Put it in the RowSet
                                lpSRowSet->aRow[index].cValues = cValues;       // number of properties
                                lpSRowSet->aRow[index].lpProps = lpPropArray;   // LPSPropValue
                            }
                        }

                        // Add the rows to the table
                        lpSRowSet->cRows = index;
                        if (HR_FAILED(hResult = lpTableData->lpVtbl->HrModifyRows(lpTableData,
                                                              0,lpSRowSet))) 
                        {
                            DebugTrace(TEXT("HrModifyRows for ambiguity table -> %x\n"), GetScode(hResult));
                            goto exit;
                        }
                        hResult = hrSuccess;

                        // Clean up the row set
                        FreeProws(lpSRowSet);
                        lpSRowSet = NULL;

                        if (lpTableData) 
                        {
                            if (HR_FAILED(hResult = lpTableData->lpVtbl->HrGetView(lpTableData,
                                                              NULL,                     // LPSSortOrderSet lpsos,
                                                              ContentsViewGone,         //  CALLERRELEASE FAR *  lpfReleaseCallback,
                                                              0,                        //  ULONG        ulReleaseData,
                                                              &lpAmbiguousTable))) 
                            {
                                DebugTrace(TEXT("HrGetView of Ambiguity table -> %x\n"), ResultFromScode(hResult));
                                goto exit;
                            }
                        }


                        // Got a contents table; put it in the
                        // ambiguity tables list.
                        Assert(i < lpAmbiguousTables->cEntries);
                        lpAmbiguousTables->lpTable[i] = lpAmbiguousTable;
                    }
                    lpFlagList->ulFlag[i] = MAPI_AMBIGUOUS;     // Mark this entry as ambiguous
                }
            }
        }
    }
exit:
    if(!bUnicode) // <note> assumes Unicode Defined
    {
        LocalFreeAndNull(&lpDisplayName);
        LocalFreeAndNull(&lpEmailAddress);
    }

    if (lpSRowSet) {
        // Clean up the row set
        FreeProws(lpSRowSet);
    }
    if (lpRow) {
        FreeProws(lpRow);
    }
    UlRelease(lpMailUser);
    UlRelease(lpTable);

    if (hResult) {
        DebugTrace(TEXT("HrSmartFind coudln't find %s %s <%s>\n"),
          ulObjectType == MAPI_MAILUSER ?  TEXT("Mail User") :  TEXT("Distribution List"),
          lpDisplayName ? lpDisplayName :  TEXT(""),
          lpEmailAddress ? lpEmailAddress :  TEXT(""));

    }

    return(hResult);
}


/***************************************************************************

    Name      : CountFlags

    Purpose   : Count the ResolveNames flags in the FlagList.

    Parameters: lpFlagList = flag list to count
                lpulResolved -> return count of MAPI_RESOLVED here
                lpulAmbiguous -> return count of MAPI_AMBIGUOUS here
                lpulUnresolved -> return count of MAPI_UNRESOLVED here

    Returns   : none

    Comment   :

***************************************************************************/
void CountFlags(LPFlagList lpFlagList, LPULONG lpulResolved,
  LPULONG lpulAmbiguous, LPULONG lpulUnresolved) {

    register ULONG i;

    *lpulResolved = *lpulAmbiguous = *lpulUnresolved = 0;

    for (i = 0; i < lpFlagList->cFlags; i++) {
        switch (lpFlagList->ulFlag[i]) {
            case MAPI_AMBIGUOUS:
                (*lpulAmbiguous)++;
                break;
            case MAPI_RESOLVED:
                (*lpulResolved)++;
                break;
            case MAPI_UNRESOLVED:
                (*lpulUnresolved)++;
                break;
            default:
                Assert(lpFlagList->ulFlag[i]);
        }
    }
}


/***************************************************************************

    Name      : InitFlagList

    Purpose   : Initialize the flags in a FlagList based on values in the
                matching ADRLIST

    Parameters: lpFlagList = flag list to fill in
                lpAdrList = adrlist to search

    Returns   : none

    Comment   : Initialize the flag to MAPI_RESOLVED if and only if the
                corresponding ADRENTRY has a PR_ENTRYID that is non-NULL.

***************************************************************************/
void InitFlagList(LPFlagList lpFlagList, LPADRLIST lpAdrList) {
    ULONG i, j;
    LPADRENTRY lpAdrEntry;

    Assert(lpAdrList->cEntries == lpFlagList->cFlags);
    for (i = 0; i < lpFlagList->cFlags; i++) {
        lpAdrEntry = &lpAdrList->aEntries[i];

        lpFlagList->ulFlag[i] = MAPI_UNRESOLVED;

        // No props?  Then it's automatically resolved.
        if (lpAdrEntry->cValues == 0) {
            lpFlagList->ulFlag[i] = MAPI_RESOLVED;
        }

        // walk through the prop list for this user
        for (j = 0; j < lpAdrEntry->cValues; j++) {
            // Look for PR_ENTRYID which is not NULL
            if (lpAdrEntry->rgPropVals[j].ulPropTag == PR_ENTRYID &&
              lpAdrEntry->rgPropVals[j].Value.bin.cb != 0) {

                // Already has a PR_ENTRYID, it's considered resolved.
                lpFlagList->ulFlag[i] = MAPI_RESOLVED;
                break;
            }
        }
    }
}


/***************************************************************************

    Name      : UnresolveNoCerts

    Purpose   : Unresolve any entry in the ADRLIST which has no cert property

    Parameters: lpIAB -> IAB object
                lpFlagList = flag list to fill in
                lpAdrList = adrlist to search

    Returns   : none

    Comment   : Initialize the flag to MAPI_RESOLVED if and only if the
                corresponding ADRENTRY has a PR_ENTRYID that is non-NULL.

***************************************************************************/
HRESULT UnresolveNoCerts(LPIAB lpIAB, LPADRLIST lpAdrList, LPFlagList lpFlagList) {
    HRESULT hr = hrSuccess;
    register ULONG i;
    LPADRENTRY lpAdrEntry;
    ULONG ulObjType;
    LPSPropValue lpspvEID, lpspvCERT, lpspvProp = NULL, lpspvNew = NULL;
    ULONG cProps, cPropsNew;
    LPMAILUSER lpMailUser = NULL;
    SizedSPropTagArray(1, ptaCert) =
                    { 1, {PR_USER_X509_CERTIFICATE} };


    for (i = 0; i < lpFlagList->cFlags; i++) {
        switch (lpFlagList->ulFlag[i]) {
            case MAPI_RESOLVED:
                // Look in the ADRENTRY for a PR_USER_X509_CERTIFICATE
                lpAdrEntry = &lpAdrList->aEntries[i];
                if (! (lpspvCERT = LpValFindProp(PR_USER_X509_CERTIFICATE,
                  lpAdrEntry->cValues, lpAdrEntry->rgPropVals))) {
                    // No property in the ADRLIST
                    // Does it exist on the underlying object?

                    if (! (lpspvEID = LpValFindProp(PR_ENTRYID,
                      lpAdrEntry->cValues, lpAdrEntry->rgPropVals))) {
                        // Weird!
                        Assert(FALSE);
                        // No cert prop, unmark it
                        lpFlagList->ulFlag[i] = MAPI_UNRESOLVED;

                        // Invalidate the entryid prop in the ADRENTRY
                        lpspvEID->Value.bin.cb = 0;
                        goto LoopContinue;
                    }

                    if (HR_FAILED(lpIAB->lpVtbl->OpenEntry(lpIAB,
                      lpspvEID->Value.bin.cb,     // size of EntryID to open
                      (LPENTRYID)lpspvEID->Value.bin.lpb,    // EntryID to open
                      NULL,         // interface
                      0,            // flags
                      &ulObjType,
                      (LPUNKNOWN *)&lpMailUser))) {
                        // No cert prop, unmark it
                        lpFlagList->ulFlag[i] = MAPI_UNRESOLVED;

                        // Invalidate the entryid prop in the ADRENTRY
                        lpspvEID->Value.bin.cb = 0;
                        goto LoopContinue;
                    } else {
                        if (lpMailUser) {

                            if (HR_FAILED(lpMailUser->lpVtbl->GetProps(lpMailUser,
                              (LPSPropTagArray)&ptaCert,
                              MAPI_UNICODE,
                              &cProps,
                              &lpspvProp))) {
                                // No cert prop, unmark it
                                lpFlagList->ulFlag[i] = MAPI_UNRESOLVED;

                                // Invalidate the entryid prop in the ADRENTRY
                                lpspvEID->Value.bin.cb = 0;
                                goto LoopContinue;
                            }
                            if (PROP_ERROR(lpspvProp[0])) {
                                // No cert prop, unmark it
                                lpFlagList->ulFlag[i] = MAPI_UNRESOLVED;

                                // Invalidate the entryid prop in the ADRENTRY
                                lpspvEID->Value.bin.cb = 0;
                                goto LoopContinue;
                            }

                            if (lpspvProp) {
                                // BUGBUG: Validate cert against our known e-mail address
                                // Parse the MVBin and do cert stuff.  Yuck!
                                // Blow it off for now, assume they have the right one here.

                                // Put this cert in the ADRENTRY
                                // Merge the new props with the ADRENTRY props
                                if (ScMergePropValues(lpAdrEntry->cValues,
                                  lpAdrEntry->rgPropVals,           // source1
                                  cProps,
                                  lpspvProp,                        // source2
                                  &cPropsNew,
                                  &lpspvNew)) {                     // dest
                                    // Can't merge cert prop, fail
                                    lpFlagList->ulFlag[i] = MAPI_UNRESOLVED;

                                    // Invalidate the entryid prop in the ADRENTRY
                                    lpspvEID->Value.bin.cb = 0;
                                    goto LoopContinue;
                                }

                                // Free old prop array and put new prop array in ADRENTRY
                                FreeBufferAndNull((LPVOID *) (&lpAdrEntry->rgPropVals));

                                lpAdrEntry->rgPropVals = lpspvNew;
                                lpAdrEntry->cValues = cPropsNew;
                            }
                        }
                    }
LoopContinue:
                    FreeBufferAndNull(&lpspvProp);
                    if (lpMailUser) {
                        lpMailUser->lpVtbl->Release(lpMailUser);
                        lpMailUser = NULL;
                    }
                }

                break;

            case MAPI_AMBIGUOUS:
            case MAPI_UNRESOLVED:
                break;
            default:
                Assert(lpFlagList->ulFlag[i]);
        }
    }
    return(hr);
}


/***************************************************************************

    Name      : ResolveLocal

    Purpose   : Resolve a name entered by a user against a local container

    Parameters: lpIAB = This IAB object
				cbEID = bytes in EntryID
				lpEID = EntryID of container
                lpAdrList = adrlist to search
                lpFlagList = flag list to fill in
				ulFlags = flags
				lpAmbiguousTables = ambiguity dialog info

    Returns   : none

***************************************************************************/
void ResolveLocal(LPIAB lpIAB, ULONG cbEID, LPENTRYID lpEID,
		LPADRLIST lpAdrList, LPFlagList lpFlagList, ULONG ulFlags,
		LPAMBIGUOUS_TABLES lpAmbiguousTables)
{
    HRESULT hr;
    ULONG ulObjType, ulResolved, ulAmbiguous, ulUnresolved;
    LPABCONT lpABCont = NULL;

    hr = lpIAB->lpVtbl->OpenEntry(lpIAB, cbEID, lpEID, NULL, 0, &ulObjType, (LPUNKNOWN *)&lpABCont);

    if (SUCCEEDED(hr))
	{
        ULONG Flags = 0;

        if(bAreWABAPIProfileAware(lpIAB) &&
            !(ulFlags & WAB_RESOLVE_USE_CURRENT_PROFILE))
            Flags |= WAB_IGNORE_PROFILES;

        if(ulFlags & WAB_RESOLVE_UNICODE)
            Flags |= MAPI_UNICODE;

		// Simple resolve on container - ignore errors
		lpABCont->lpVtbl->ResolveNames( lpABCont, NULL, 
                                        Flags, 
                                        lpAdrList, lpFlagList);

		// Make certain that any entries we found have a certificate property
		// for this email address.
		if (ulFlags & WAB_RESOLVE_NEED_CERT)
			UnresolveNoCerts(lpIAB, lpAdrList, lpFlagList);
		
        if (ulFlags & WAB_RESOLVE_ALL_EMAILS)
		{
			// If we need more aggressive resolution, use HrSmartResolve
			// This is much slower, so use it judiciously.
			// Count the flags
			CountFlags(lpFlagList, &ulResolved, &ulAmbiguous, &ulUnresolved);
			if (ulAmbiguous || ulUnresolved)
				HrSmartResolve(lpIAB, lpABCont, ulFlags, lpAdrList, lpFlagList,
						lpAmbiguousTables);
		}
        lpABCont->lpVtbl->Release(lpABCont);
	}
}


/***************************************************************************

    Name      : ResolveCurrentProfile

    Purpose   : Resolve a name entered by a user against only the folders that
                are listed in the current profile - this way a user doesnt get
                unexpected name resolution results from what he sees in his
                profile-enabled Outlook Express address book.
                There is an assumption here that this function will only be called
                in the very specific case that OE is running with profiles and the
                user is pressing Ctrl-K to resolve names
                In that case, we will target the contents of the users folders ..
                if something resolves unambiguously good and fine, if something is
                ambiguous we will mark it so, if it doesnt resolve ok ..
                After we've hit the users folders for this resolution, we can then
                call the regular ResolveLocal function to take care of the unmatched
                entries ...

    Parameters: lpIAB = This IAB object
                lpAdrList = adrlist to search
                lpFlagList = flag list to fill in

    Returns   : none

***************************************************************************/
HRESULT HrResolveCurrentProfile(LPIAB lpIAB, LPADRLIST lpAdrList, LPFlagList lpFlagList, BOOL bOutlook, BOOL bUnicode)
{
    LPADRENTRY lpAdrEntry;
    ULONG i, j;
    ULONG ulCount = 1;
    LPSBinary rgsbEntryIDs = NULL;
    HRESULT hResult = hrSuccess;
    LPSPropValue lpPropArrayNew = NULL,lpProps = NULL;
    ULONG ulObjType = 0, cPropsNew = 0,ulcProps = 0;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG ulProfileCount = 0;
    LPSBinary lpsb = NULL;
	ULONG iolkci, colkci;
	OlkContInfo *rgolkci;
    ULONG ulFlags = AB_FUZZY_FIND_ALL;

    EnterCriticalSection(&lpIAB->cs);

#ifndef DONT_ADDREF_PROPSTORE
    if ((FAILED(sc = OpenAddRefPropertyStore(NULL, lpIAB->lpPropertyStore)))) 
    {
        hResult = ResultFromScode(sc);
        goto exitNotAddRefed;
    }
#endif

    if(!bOutlook)
        ulFlags |= AB_FUZZY_FIND_PROFILEFOLDERONLY;

    colkci = bOutlook ? lpIAB->lpPropertyStore->colkci : lpIAB->cwabci;
	Assert(colkci);
    rgolkci = bOutlook ? lpIAB->lpPropertyStore->rgolkci : lpIAB->rgwabci;
	Assert(rgolkci);
    
    // search for each name in the lpAdrList
    for (i = 0; i < lpAdrList->cEntries; i++)
    {
        // Make sure we don't resolve an entry which is already resolved.
        if (lpFlagList->ulFlag[i] == MAPI_RESOLVED)
            continue;

        ulProfileCount = 0;
        LocalFreeSBinary(lpsb);
        lpsb = NULL;

        lpAdrEntry = &(lpAdrList->aEntries[i]);

        // Search for this address
        for (j = 0; j < lpAdrEntry->cValues; j++)
        {
            ULONG ulPropTag = lpAdrEntry->rgPropVals[j].ulPropTag;
            if(!bUnicode && PROP_TYPE(ulPropTag)==PT_STRING8) //<note> assumes UNICODE defined
                ulPropTag = CHANGE_PROP_TYPE(ulPropTag, PT_UNICODE);

            if (ulPropTag == PR_DISPLAY_NAME || ulPropTag == PR_EMAIL_ADDRESS )
            {
                LPTSTR lpsz = (bUnicode) ? 
                                lpAdrEntry->rgPropVals[j].Value.lpszW :
                                ConvertAtoW(lpAdrEntry->rgPropVals[j].Value.lpszA);

                ulCount = 1; // number of matches to find
                rgsbEntryIDs = NULL;
                
                iolkci = bOutlook ? 0 : 1;  // if it's outlook we DO want to search the first folder
                                            // if it's WAB, and this is a profile-enabled session and we are only searching
                                            // through the profile folders, then we shouldn't search through the shared contacts
                                            // folder which is the first folder on the list ...
	                                        // Only if we find nothing in the user's folders should we look into the shared contact
                                            // folder ..
                while (iolkci < colkci && ulProfileCount<=1 ) 
                {
                    if(ulCount && rgsbEntryIDs)
                    {
                        FreeEntryIDs(lpIAB->lpPropertyStore->hPropertyStore, ulCount, rgsbEntryIDs);
                        ulCount = 1;
                        rgsbEntryIDs = NULL;
                    }
                    // Search the property store
                    Assert(lpIAB->lpPropertyStore->hPropertyStore);
                    if (HR_FAILED(hResult = HrFindFuzzyRecordMatches(lpIAB->lpPropertyStore->hPropertyStore,
				                                                      rgolkci[iolkci].lpEntryID,
                                                                      lpsz,
                                                                      ulFlags,
                                                                      &ulCount,// IN: number of matches to find, OUT: number found
                                                                      &rgsbEntryIDs)))
                    {
                        DebugTraceResult( TEXT("HrFindFuzzyRecordMatches"), hResult);
                        goto exit;
                    }
                    ulProfileCount += ulCount;
                    if(ulProfileCount > 1)
                    {
                        LocalFreeSBinary(lpsb);
                        lpsb = NULL;
                    }
                    if(ulCount == 1 && ulProfileCount == 1)
                    {
                        lpsb = LocalAlloc(LMEM_ZEROINIT, sizeof(SBinary));
                        if(lpsb)
                        {
                            lpsb->cb = rgsbEntryIDs[0].cb;
                            lpsb->lpb = LocalAlloc(LMEM_ZEROINIT, lpsb->cb);
                            if(lpsb->lpb)
                                CopyMemory(lpsb->lpb, rgsbEntryIDs[0].lpb, lpsb->cb);
                        }
                    }
                    // next container
                    iolkci++;
                } //while loop

                if(ulProfileCount == 0 && !bOutlook)
                {
                    if(ulCount && rgsbEntryIDs)
                    {
                        FreeEntryIDs(lpIAB->lpPropertyStore->hPropertyStore, ulCount, rgsbEntryIDs);
                        ulCount = 1;
                        rgsbEntryIDs = NULL;
                    }
                    // Search the property store
                    Assert(lpIAB->lpPropertyStore->hPropertyStore);
                    if (HR_FAILED(hResult = HrFindFuzzyRecordMatches(lpIAB->lpPropertyStore->hPropertyStore,
				                                                      rgolkci[0].lpEntryID,
                                                                      lpsz,
                                                                      ulFlags,
                                                                      &ulCount,// IN: number of matches to find, OUT: number found
                                                                      &rgsbEntryIDs)))
                    {
                        DebugTraceResult( TEXT("HrFindFuzzyRecordMatches"), hResult);
                        goto exit;
                    }
                    ulProfileCount += ulCount;
                    if(ulProfileCount > 1)
                    {
                        LocalFreeSBinary(lpsb);
                        lpsb = NULL;
                    }
                    if(ulCount == 1 && ulProfileCount == 1)
                    {
                        lpsb = LocalAlloc(LMEM_ZEROINIT, sizeof(SBinary));
                        if(lpsb)
                        {
                            lpsb->cb = rgsbEntryIDs[0].cb;
                            lpsb->lpb = LocalAlloc(LMEM_ZEROINIT, lpsb->cb);
                            if(lpsb->lpb)
                                CopyMemory(lpsb->lpb, rgsbEntryIDs[0].lpb, lpsb->cb);
                        }
                    }
                } // if ulProfileCount..


                // If after doing all the containers, we have only 1 item that resolved
                if(ulProfileCount > 1)
                {
                    // This is ambiguous within this profile so mark it ambiguous
                    DebugTrace(TEXT("ResolveNames found more than 1 match in Current Profile... MAPI_AMBIGUOUS\n"));
                    lpFlagList->ulFlag[i] = MAPI_AMBIGUOUS;
                }
                else if(ulProfileCount == 1)
                {
                    if (!HR_FAILED(HrGetPropArray((LPADRBOOK)lpIAB, (LPSPropTagArray)&ptaResolveDefaults,
                                                 lpsb->cb, (LPENTRYID)lpsb->lpb,
                                                 (bUnicode ? MAPI_UNICODE : 0),
                                                 &ulcProps, &lpProps)))
                    {
                        // Merge the new props with the ADRENTRY props
                        if (sc = ScMergePropValues(lpAdrEntry->cValues,
                                                  lpAdrEntry->rgPropVals,
                                                  ulcProps,
                                                  lpProps,
                                                  &cPropsNew,
                                                  &lpPropArrayNew))
                        {
                            goto exit;
                        }
                        // Free the original prop value array
                        FreeBufferAndNull((LPVOID*) (&(lpAdrEntry->rgPropVals)));
                        lpAdrEntry->cValues = cPropsNew;
                        lpAdrEntry->rgPropVals = lpPropArrayNew;
                        FreeBufferAndNull(&lpProps);

                        // [PaulHi] Raid 66515
                        // We need to convert these properties to ANSI since we are now the
                        // UNICODE WAB and if our client is !MAPI_UNICODE
                        if (!bUnicode)
                        {
                            if(sc = ScConvertWPropsToA((LPALLOCATEMORE) (&MAPIAllocateMore), lpPropArrayNew, cPropsNew, 0))
                                goto exit;
                        }

                        // Mark this entry as found.
                        lpFlagList->ulFlag[i] = MAPI_RESOLVED;
                    }
                }
                FreeEntryIDs(lpIAB->lpPropertyStore->hPropertyStore,
                             ulCount, rgsbEntryIDs);
                rgsbEntryIDs = NULL;
                break;
            } // if PR_DISPLAY_NAME
        }// for j ...
    } // for i

exit:
#ifndef DONT_ADDREF_PROPSTORE
    ReleasePropertyStore(lpIAB->lpPropertyStore);
exitNotAddRefed:
#endif
    LeaveCriticalSection(&lpIAB->cs);

    if(lpsb)
    {
        //Bug #101354 - (erici) Free leaked alloc.
        LocalFreeSBinary(lpsb);
    }

    return(hResult);
}



/***************************************************************************

    Name      : IAB_ResolveName

    Purpose   : Resolve a name entered by a user

    Parameters: lpIAB = This IAB object
                ulUIParam = hwnd
                ulFlags may contain MAPI_UNICODE or MAPI_DIALOG
                    If this is a profile based session, and we want to do
                    profile specific searches, then we must pass in
                    WAB_RESOLVE_USE_CURRENT_PROFILE. Failure to pass this in
                    will imply that the user wants to search the whole WAB.
                lpszNewEntryTitle = title for ResolveName dialog
                lpAdrList = ADRLIST input/output

    Returns   : HRESULT

    Comment   : For now, the search path is hard coded to be:
                    + reply one-offs
                    + WAB's default container
                    + SMTP one-offs
                    + LDAP containers

***************************************************************************/
STDMETHODIMP
IAB_ResolveName(LPIAB       lpIAB,
                ULONG_PTR   ulUIParam,
                ULONG       ulFlags,
                LPTSTR      lpszNewEntryTitle,
                LPADRLIST   lpAdrList)
{
    HRESULT         hr = hrSuccess;
    SCODE	         sc = S_OK;
    LPFlagList      lpFlagList = NULL;
    LPAMBIGUOUS_TABLES lpAmbiguousTables = NULL;
    ULONG	         ulUnresolved = 0;
    ULONG	         ulResolved = 0;
    ULONG	         ulAmbiguous = 0;
    ULONG           cbWABEID;
    LPENTRYID       lpWABEID = NULL;
    ULONG           ulObjType;
    LPABCONT        lpWABCont = NULL;
    ULONG i;
    LPPTGDATA       lpPTGData = GetThreadStoragePointer();

#ifndef DONT_ADDREF_PROPSTORE
        if ((FAILED(sc = OpenAddRefPropertyStore(NULL, lpIAB->lpPropertyStore)))) {
            hr = ResultFromScode(sc);
            goto exitNotAddRefed;
        }
#endif

#ifdef PARAMETER_VALIDATION
    // Make sure it's an IAB
    //
    if (BAD_STANDARD_OBJ(lpIAB, IAB_, ResolveName, lpVtbl)) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulUIParam && !IsWindow((HWND)ulUIParam)) {
        DebugTraceArg(IAB_ResolveName,  TEXT("Invalid window handle\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // BUGBUG: What's this 512 and where does it come from?
    if (lpszNewEntryTitle && IsBadStringPtr(lpszNewEntryTitle, 512)) {
        DebugTraceArg(IAB_ResolveName,  TEXT("lpszNewEntryTitle fails address check"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (lpAdrList && FBadAdrList(lpAdrList)) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Due to a flag mixup, WAB_RESOLVE_LOCAL_ONLY equals MAPI_UNICODE, therefore IAB_Resolve is the
    // only function that does not take the MAPI_UNICODE flag but instead needs the special
    // WAB_RESOLVE_UNICODE flag
    //
    //if (ulFlags & WAB_RESOLVE_UNICODE) {
    //    DebugTraceArg(IAB_ResolveName,  TEXT("Invalid character width"));
    //    return(ResultFromScode(MAPI_E_BAD_CHARWIDTH));
    //}

#endif // PARAMETER_VALIDATION

    // Validate flags
    if (ulFlags & ~(WAB_RESOLVE_UNICODE | MAPI_DIALOG | WAB_RESOLVE_LOCAL_ONLY |
      WAB_RESOLVE_ALL_EMAILS | WAB_RESOLVE_NO_ONE_OFFS | WAB_RESOLVE_NEED_CERT |
      WAB_RESOLVE_NO_NOT_FOUND_UI | WAB_RESOLVE_USE_CURRENT_PROFILE | WAB_RESOLVE_FIRST_MATCH)) {
        // Unknown flags
        DebugTraceArg(IAB_ResolveName,  TEXT("Unknown flags"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if ( (ulFlags & WAB_RESOLVE_NEED_CERT) && !(ulFlags & WAB_RESOLVE_NO_ONE_OFFS) ) {
        DebugTrace(TEXT("ResolveName got WAB_RESOLVE_NEED_CERT without WAB_RESOLVE_NO_ONE_OFFS\n"));
//        Assert(FALSE);
        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }
/*
    if ((ulFlags & WAB_RESOLVE_USE_CURRENT_PROFILE) && (ulFlags & WAB_RESOLVE_ALL_EMAILS)) {
        DebugTrace(TEXT("ResolveName can't handle both WAB_RESOLVE_USE_CURRENT_PROFILE and WAB_RESOLVE_ALL_EMAILS\n"));
        Assert(FALSE);
        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }
*/

    // A NULL address list is already resolved.
    if (! lpAdrList) {
        goto exit;
    }

    VerifyWABOpenExSession(lpIAB);

    if (ulFlags & MAPI_DIALOG && ulUIParam) {
        pt_hWndFind = (HWND) ulUIParam;
    }

    //
    //  Allocate the lpFlagList first and zero fill it.
    if (sc = MAPIAllocateBuffer((UINT) CbNewSPropTagArray(lpAdrList->cEntries),
      &lpFlagList)) {
        hr = ResultFromScode(sc);
        goto exit;
    }

    MAPISetBufferName(lpFlagList,  TEXT("WAB: lpFlagList in IAB_ResolveName"));

    lpFlagList->cFlags = lpAdrList->cEntries;

    InitFlagList(lpFlagList, lpAdrList);

    // Count the flags
    CountFlags(lpFlagList, &ulResolved, &ulAmbiguous, &ulUnresolved);

    //  Allocate the Ambiguous Table list and zero fill it.
    if (sc = MAPIAllocateBuffer(sizeof(AMBIGUOUS_TABLES) + lpAdrList->cEntries * sizeof(LPMAPITABLE),
      (LPVOID*)&lpAmbiguousTables)) {
        hr = ResultFromScode(sc);
        goto exit;
    }
    MAPISetBufferName(lpAmbiguousTables,  TEXT("IAB_ResolveNames:AmbiguousTables"));
    lpAmbiguousTables->cEntries = lpAdrList->cEntries;
    for (i = 0; i < lpAmbiguousTables->cEntries; i++) {
        lpAmbiguousTables->lpTable[i] = NULL;
    }


    if (! (ulFlags & WAB_RESOLVE_NO_ONE_OFFS) && (ulAmbiguous || ulUnresolved)) {
        // Resolve any PR_DISPLAY_NAME:PR_EMAIL_ADDRESS pairs to one-offs.
        HrResolveOneOffs(lpIAB, lpAdrList, lpFlagList, 
                        (ulFlags & WAB_RESOLVE_UNICODE)?MAPI_UNICODE:0,
                        RECEIVED_EMAIL_ADDRESS);
        CountFlags(lpFlagList, &ulResolved, &ulAmbiguous, &ulUnresolved);
    }

    if( bAreWABAPIProfileAware(lpIAB) && bIsThereACurrentUser(lpIAB) &&
        ulFlags&WAB_RESOLVE_USE_CURRENT_PROFILE && (ulAmbiguous || ulUnresolved))
    {
        HrResolveCurrentProfile(lpIAB, lpAdrList, lpFlagList, FALSE, (ulFlags & WAB_RESOLVE_UNICODE));
        CountFlags(lpFlagList, &ulResolved, &ulAmbiguous, &ulUnresolved);
    }

	// Do the default WAB container
    if ((ulAmbiguous || ulUnresolved) &&
	!(ulFlags & WAB_RESOLVE_USE_CURRENT_PROFILE))
    {
	if (! (hr = lpIAB->lpVtbl->GetPAB(lpIAB,&cbWABEID,&lpWABEID)))
        {
	    ResolveLocal(lpIAB, cbWABEID, lpWABEID, lpAdrList, lpFlagList, ulFlags, lpAmbiguousTables);
            CountFlags(lpFlagList, &ulResolved, &ulAmbiguous, &ulUnresolved);
            FreeBufferAndNull(&lpWABEID);
        }
    }

	// Do the additional containers
	if (pt_bIsWABOpenExSession) 
    {
        HrResolveCurrentProfile(lpIAB, lpAdrList, lpFlagList, TRUE, (ulFlags & WAB_RESOLVE_UNICODE));
        CountFlags(lpFlagList, &ulResolved, &ulAmbiguous, &ulUnresolved);
	}

    if (! (ulFlags & WAB_RESOLVE_NO_ONE_OFFS)) {
        if (ulUnresolved) {
            //
            // Take care of any Internet one-off's
            //
            if (ulUnresolved) {
                hr = HrResolveOneOffs(lpIAB, lpAdrList, lpFlagList, 
                                    (ulFlags & WAB_RESOLVE_UNICODE)?MAPI_UNICODE:0,
                                    ENTERED_EMAIL_ADDRESS);
            }

            // Count the flags
            CountFlags(lpFlagList, &ulResolved, &ulAmbiguous, &ulUnresolved);
        }

        if (ulAmbiguous)
        {
            // Resolve any valid e-mail addresses that are ambiguous
            hr = HrResolveOneOffs(lpIAB, lpAdrList, lpFlagList, 
                                (ulFlags & WAB_RESOLVE_UNICODE)?MAPI_UNICODE:0,
                                AMBIGUOUS_EMAIL_ADDRESS);
            // Count the flags
            CountFlags(lpFlagList, &ulResolved, &ulAmbiguous, &ulUnresolved);
        }
    }

    //
    // Search any LDAP containers
    //
    if (! (ulFlags & WAB_RESOLVE_LOCAL_ONLY) && ulUnresolved) 
    {
        if (! (hr = LDAPResolveName((LPADRBOOK)lpIAB, lpAdrList, lpFlagList, lpAmbiguousTables, ulFlags))) 
        {
            if (ulFlags & WAB_RESOLVE_NEED_CERT) 
            {
                // Make certain that any entries we found have a certificate property
                // for this email address.
                UnresolveNoCerts(lpIAB, lpAdrList, lpFlagList);
            }
            // Count the flags
            CountFlags(lpFlagList, &ulResolved, &ulAmbiguous, &ulUnresolved);
        }
    }

    // If caller just wants the first match, pull them out of the ambiguity tables
    if (ulFlags & WAB_RESOLVE_FIRST_MATCH && ulAmbiguous) 
    {
        Assert(lpAdrList->cEntries == lpAmbiguousTables->cEntries);
        for (i = 0; i < lpAmbiguousTables->cEntries; i++) 
        {
            if (lpAmbiguousTables->lpTable[i]) 
            {
                LPADRENTRY lpAdrEntry = &lpAdrList->aEntries[i];

                // Get the first row from this table and return it.
                if (SUCCEEDED(HrRowToADRENTRY(lpIAB, lpAmbiguousTables->lpTable[i], lpAdrEntry, (ulFlags & WAB_RESOLVE_UNICODE)))) 
                {
                    lpFlagList->ulFlag[i] = MAPI_RESOLVED;      // Mark this entry as found.
                    UlRelease(lpAmbiguousTables->lpTable[i]);
                    lpAmbiguousTables->lpTable[i] = NULL;
                }
            }
        }
        // Count the flags
        CountFlags(lpFlagList, &ulResolved, &ulAmbiguous, &ulUnresolved);
    }

    // Do UI if needed
    if ((ulFlags & MAPI_DIALOG) && (ulAmbiguous || ulUnresolved)) 
    {
#ifdef OLD_STUFF
        // Dump the ambiguous tables
        for (i = 0; i < lpAmbiguousTables->cEntries; i++) {
            if (lpAmbiguousTables->lpTable[i]) {
                DebugMapiTable(lpAmbiguousTables->lpTable[i]);
            }
        }
#endif // OLD_STUFF


        // Do the UI here.
        hr = HrShowResolveUI((LPADRBOOK)lpIAB, (HWND) ulUIParam,
                                    lpIAB->lpPropertyStore->hPropertyStore,
                                    ulFlags,
                                    &lpAdrList, &lpFlagList, lpAmbiguousTables);

        if (ulFlags & WAB_RESOLVE_NEED_CERT) 
        {
            // Make certain that any entries we found have a certificate property
            // for this email address.
            UnresolveNoCerts(lpIAB, lpAdrList, lpFlagList);
        }
        // Count the flags
        CountFlags(lpFlagList, &ulResolved, &ulAmbiguous, &ulUnresolved);
    }

    if (! hr) 
    {
        if (ulAmbiguous) 
            hr = ResultFromScode(MAPI_E_AMBIGUOUS_RECIP);
        else if (ulUnresolved) 
            hr = ResultFromScode(MAPI_E_NOT_FOUND);
    }

exit:
#ifndef DONT_ADDREF_PROPSTORE
    ReleasePropertyStore(lpIAB->lpPropertyStore);
exitNotAddRefed:
#endif
    if (lpAmbiguousTables) {
        for (i = 0; i < lpAmbiguousTables->cEntries; i++) {
            UlRelease(lpAmbiguousTables->lpTable[i]);
        }
        FreeBufferAndNull(&lpAmbiguousTables);
    }

    FreeBufferAndNull(&lpFlagList);

    if(ulFlags&MAPI_DIALOG && ulUIParam)
    {
        LPPTGDATA lpPTGData=GetThreadStoragePointer();
        pt_hWndFind = NULL;
    }

    return(hr);
}


/***************************************************************************

    Name      : IsDomainName

    Purpose   : Is this domain correctly formatted for an Internet address?

    Parameters: lpDomain -> Domain name to check
                fEnclosure = TRUE if the address started with '<'.
                fTrimEnclosure = TRUE if we should truncate the address to
                  remove the '>'.

    Returns   : TRUE if the domain is a correct format for an Internet
                address.

    Comment   : Valid domain names have this form:
                    bar[.bar]*
                    where bar must have non-empty contents
                    no high bits are allowed on any characters
                    no '@' allowed
                    the '>' character ends the address if there was a '<'
                    character at the start of the address.

***************************************************************************/
BOOL IsDomainName(LPTSTR lpDomain, BOOL fEnclosure, BOOL fTrimEnclosure) {
    if (lpDomain) {
        if (*lpDomain == '\0' || *lpDomain == '.' || (fEnclosure && *lpDomain == '>')) {
            // domain name must have contents and can't start with '.'
            return(FALSE);
        }

        while (*lpDomain && (! fEnclosure || *lpDomain != '>')) {
            // Internet addresses only allow pure ASCII.  No high bits!
            // No more '@' or '<' characters allowed.
            if (*lpDomain >= 0x0080 || *lpDomain == '@' || *lpDomain == '<') {
                return(FALSE);
            }

            if (*lpDomain == '.') {
                // Recursively check this part of the domain name
                return(IsDomainName(CharNext(lpDomain), fEnclosure, fTrimEnclosure));
            }
            lpDomain = CharNext(lpDomain);
        }
        if (fEnclosure) {
            if (*lpDomain != '>') {
                return(FALSE);
            }

            // Must be the last thing done before returning TRUE!
            if (fTrimEnclosure && *lpDomain == '>') {
                *lpDomain = '\0';
            }
        }
        return(TRUE);
    }

    return(FALSE);
}


/***************************************************************************

    Name      : IsInternetAddress

    Purpose   : Is this address correctly formatted for an Internet address?

    Parameters: lpAddress -> Address to check
                lppEmail -> Returned email address (May be NULL input if
                  email should not be parsed.)

    Returns   : TRUE if the address is a correct format for an Internet
                address.

    Comment   : Valid addresses have this form:
                    [display name <]foo@bar[.bar]*[>]
                    where foo and bar must have non-empty contents
                    and if there is a display name, there must be angle
                    brackets surrounding the email address.

***************************************************************************/
BOOL IsInternetAddress(LPTSTR lpAddress, LPTSTR * lppEmail) {
    if (lpAddress) {
        BOOL fEnclosure = FALSE;
        LPTSTR lpDisplay = lpAddress;
        LPTSTR lpTemp = lpAddress;
        LPTSTR lpBracket = NULL;

        // Get past any DisplayName stuff
        for(lpTemp = lpAddress; *lpTemp && *lpTemp != '<'; lpTemp = CharNext(lpTemp));   // Looking for NULL or '<'
        if (*lpTemp) {
            Assert(*lpTemp == '<');
            // Found an enclosure.
            // if we are returning the email, plop down a NULL at the end of the display name

            lpBracket = lpTemp;

            // Get past the '<' to the SMTP email address
            lpTemp++;
            fEnclosure = TRUE;
            lpAddress = lpTemp;
        } else {
            lpTemp = lpAddress;
        }

        // Can't start with '@'
        if (*lpTemp == '@') {
            return(FALSE);
        }

        // Step through the address looking for '@'.  If there's an at sign in the middle
        // of a string, this is close enough to being an internet address for me.
        while (*lpTemp) {
            // Internet addresses only allow pure ASCII.  No high bits!
            WCHAR wc = *lpTemp;
            if(wc > 0x007f)
                return FALSE;
            //if (*lpTemp & 0x80) 
            //{
            //    return(FALSE);
            //}

            if (*lpTemp == '@') {
                // Found the at sign.  Is there anything following?
                // (Must NOT be another '@')
                if (IsDomainName(CharNext(lpTemp), fEnclosure, !!lppEmail)) {
                    if (lppEmail) { // Want to parse into Display & Email
                        if (lpBracket) {    // Seperate Display & Email
                            *lpBracket = '\0';

                            // Trim the trailing spaces from the display name
                            TrimSpaces(lpDisplay);
                        }

                        *lppEmail = lpAddress;
                    }
                    return(TRUE);
                } else {
                    return(FALSE);
                }
            }
            lpTemp = CharNext(lpTemp);
        }
    }

    return(FALSE);
}


/***************************************************************************

    Name      : ScNewOOEID

    Purpose   : AllocateMore a One-Off EntryID

    Parameters: lpsbin -> returned SBinary EntryID
                lpRoot = buffer to allocateMore onto
                szDisplayName = display name
                szAddress = email address (may be == szDisplayName)
                szAddrType = addrtype
                bIsUnicode -> TRUE if caller expects Unicode MAPI EID strings

    Returns   : SCODE

    Comment   :

***************************************************************************/
SCODE ScNewOOEID(
    LPSBinary lpsbin,
    LPVOID lpRoot,
    LPTSTR szDisplayName,
    LPTSTR szAddress,
    LPTSTR szAddrType,
    BOOL   bIsUnicode)
{
    return(GetScode(CreateWABEntryIDEx(bIsUnicode, WAB_ONEOFF, (LPVOID) szDisplayName, (LPVOID) szAddrType, (LPVOID) szAddress, 0, 0,
      (LPVOID) lpRoot, (LPULONG) (&lpsbin->cb), (LPENTRYID *)&lpsbin->lpb)));
}


/***************************************************************************

    Name      : HrResolveOneOffs

    Purpose   : Resolves any Internet addresses in the ADRLIST.

    Parameters: lpIAB -> IAddrBook object
                lpAdrList -> input/output ADRLIST as with Resolvenames
                lpFlagList -> flag list as with ResolveNames
                ResolveType = type of one-off resolve to do
                ulFlags - 0 or MAPI_UNICODE (if 0 means all strings in AdrList are ANSI/DBCS)
    Returns   : HRESULT

    Comment   :

***************************************************************************/
enum {
    ioopPR_DISPLAY_NAME = 0,
    ioopPR_EMAIL_ADDRESS,
    ioopPR_ADDRTYPE,
    ioopPR_ENTRYID,
    ioopPR_OBJECT_TYPE,
    ioopMAX
};
const TCHAR szSMTP[] =  TEXT("SMTP");
#define CB_SMTP sizeof(szSMTP)

HRESULT HrResolveOneOffs(LPIAB lpIAB, LPADRLIST lpAdrList, LPFlagList lpFlagList,
                         ULONG ulFlags,
                          RESOLVE_TYPE ResolveType) 
{
    HRESULT hResult = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG i, j, k;
    LPADRENTRY lpAdrEntry = NULL;
    LPSPropValue lpPropArrayTemp = NULL, lpPropArrayNew = NULL;
    LPTSTR lpszDisplayName = NULL, lpszEmailAddress = NULL;
    ULONG cbTemp, cbEmailAddress, cPropsNew;
    LPBYTE lpb;
    BOOL fNotDone;

    // Walk through the flag list, looking for unresolved entries:
    for (i = 0; i < lpFlagList->cFlags; i++)
    {
        BOOL bAmbiguous = FALSE;
        if(ResolveType == AMBIGUOUS_EMAIL_ADDRESS && lpFlagList->ulFlag[i] == MAPI_AMBIGUOUS)
        {
            // Fake the routine into thinking this is an unresolved internet address
            bAmbiguous = TRUE;
            lpFlagList->ulFlag[i] = MAPI_UNRESOLVED;
        }
        if (lpFlagList->ulFlag[i] == MAPI_UNRESOLVED)
        {
            // Found an unresolved entry.   Look at the PR_DISPLAY_NAME
            // and, if RECEIVED_EMAIL_ADDRESS, PR_EMAIL_ADDRESS.
            lpAdrEntry = &(lpAdrList->aEntries[i]);
            if(ulFlags & MAPI_UNICODE)
            {
                lpszDisplayName = NULL;
                lpszEmailAddress = NULL;
            }
            else
            {
                // [PaulHi] 12/17/98  Raid #62242
                // Don't deallocate twice if the two pointers are equal.
                if (lpszEmailAddress != lpszDisplayName)
                    LocalFreeAndNull(&lpszEmailAddress);
                LocalFreeAndNull(&lpszDisplayName);
                lpszEmailAddress = NULL;
            }
            fNotDone = TRUE;

            for (j = 0; j < lpAdrEntry->cValues && fNotDone; j++) 
            {
                ULONG ulPropTag = lpAdrEntry->rgPropVals[j].ulPropTag;
                
                if(!(ulFlags & MAPI_UNICODE) && PROP_TYPE(ulPropTag)==PT_STRING8)
                    ulPropTag = CHANGE_PROP_TYPE(ulPropTag, PT_UNICODE);

                switch (ulPropTag) 
                {
                    case PR_DISPLAY_NAME:
                        lpszDisplayName = (ulFlags & MAPI_UNICODE) ?
                                            lpAdrEntry->rgPropVals[j].Value.lpszW :
                                            ConvertAtoW(lpAdrEntry->rgPropVals[j].Value.lpszA);
                        switch (ResolveType) 
                        {
                            case AMBIGUOUS_EMAIL_ADDRESS:
                            case ENTERED_EMAIL_ADDRESS:
                                // Just look at the display name
                                // we'll check it's validity as an email address.
                                break;

                            case RECEIVED_EMAIL_ADDRESS:
                                // If we are in RECEIVED_EMAIL_ADDRESS mode, find the email address.
                                // if it isn't there, this address doesn't resolve.
                                //
                                if (! lpszEmailAddress) 
                                {
                                    // Haven't seen it yet, go hunt for it.
                                    for (k = j + 1;  k < lpAdrEntry->cValues; k++) 
                                    {
                                        ULONG ulPropTag = lpAdrEntry->rgPropVals[k].ulPropTag;
                                        if(!(ulFlags & MAPI_UNICODE) && PROP_TYPE(ulPropTag)==PT_STRING8)
                                            ulPropTag = CHANGE_PROP_TYPE(ulPropTag, PT_UNICODE);
                                        if (ulPropTag == PR_EMAIL_ADDRESS) 
                                        {
                                            lpszEmailAddress = (ulFlags & MAPI_UNICODE) ?
                                                                lpAdrEntry->rgPropVals[k].Value.lpszW :
                                                                ConvertAtoW(lpAdrEntry->rgPropVals[k].Value.lpszA);
                                            break;  // out of for loop
                                        }
                                    }
                                    if (! lpszEmailAddress) 
                                    {
                                        // No email address, can't resolve in
                                        // RECEIVED_EMAIL_ADDRESS mode.
                                        fNotDone = FALSE;   // exit this ADRENTRY
                                        continue;   // break binds to switch, not for.
                                    }
                                }
                                break;      // found email addr and display name.  It's a one-off.
                            default:
                                Assert(FALSE);
                        }

                        // At this point, we have two pointers: lpszDisplayName and maybe lpszEmailAddress.

                        // Is it an Internet address or a RECEIVED_EMAIL_ADDRESS?
                        if ((ResolveType == RECEIVED_EMAIL_ADDRESS && lpszEmailAddress
                              && lpszDisplayName)
                              || IsInternetAddress(lpszDisplayName, &lpszEmailAddress)) 
                        {
                            if (lpszEmailAddress) 
                            {
                                // We can resolve this.
                                cbEmailAddress = sizeof(TCHAR)*(lstrlen(lpszEmailAddress) + 1);

                                // Allocate a temporary prop array for our new properties
                                cbTemp = ioopMAX * sizeof(SPropValue) + cbEmailAddress + CB_SMTP;
                                if (sc = MAPIAllocateBuffer(cbTemp, &lpPropArrayTemp)) 
                                {
                                    goto exit;
                                }

                                MAPISetBufferName(lpPropArrayTemp,  TEXT("WAB: lpPropArrayTemp in HrResolveOneOffs"));

                                lpb = (LPBYTE)&lpPropArrayTemp[ioopMAX];    // point past array

                                if(!lstrlen(lpszDisplayName))
                                    lpszDisplayName = lpszEmailAddress;
                                //else if(*lpszDisplayName == '.' || *lpszDisplayName == '=')
                                //    lstrcpy(lpszDisplayName, lpszDisplayName+1);
                                else if(*lpszDisplayName == '"')
                                {
                                    // strip out the leading quote if it's the only one ..
                                    LPTSTR lp = lpszDisplayName;
                                    int nQuoteCount = 0;
                                    while(lp && *lp)
                                    {
                                        if(*lp == '"')
                                            nQuoteCount++;
                                        lp = CharNext(lp);
                                    }
                                    if(nQuoteCount == 1)
                                        lstrcpy(lpszDisplayName, lpszDisplayName+1);
                                }

                                {
                                    LPTSTR lp = NULL;
                                    if(sc = MAPIAllocateMore(sizeof(TCHAR)*(lstrlen(lpszDisplayName)+1), lpPropArrayTemp, &lp))
                                        goto exit;
                                    lstrcpy(lp, lpszDisplayName);
                                    lpPropArrayTemp[ioopPR_DISPLAY_NAME].ulPropTag = PR_DISPLAY_NAME;
                                    lpPropArrayTemp[ioopPR_DISPLAY_NAME].Value.LPSZ = lp;
                                }
                                
                                // Fill in our temp prop array
                                lpPropArrayTemp[ioopPR_EMAIL_ADDRESS].ulPropTag = PR_EMAIL_ADDRESS;
                                lpPropArrayTemp[ioopPR_EMAIL_ADDRESS].Value.LPSZ = (LPTSTR)lpb;
                                lstrcpy((LPTSTR)lpb, lpszEmailAddress);
                                lpb += cbEmailAddress;

                                lpPropArrayTemp[ioopPR_ADDRTYPE].ulPropTag = PR_ADDRTYPE;
                                lpPropArrayTemp[ioopPR_ADDRTYPE].Value.LPSZ = (LPTSTR)lpb;
                                lstrcpy((LPTSTR)lpb, szSMTP);
                                lpb += CB_SMTP;

                                lpPropArrayTemp[ioopPR_ENTRYID].ulPropTag = PR_ENTRYID;
                                if (sc = ScNewOOEID(&lpPropArrayTemp[ioopPR_ENTRYID].Value.bin,
                                                      lpPropArrayTemp,  // allocate more on here
                                                      lpszDisplayName,
                                                      lpszEmailAddress,
                                                      (LPTSTR)szSMTP,
                                                      (ulFlags & MAPI_UNICODE))) 
                                {
                                    goto exit;
                                }

                                lpPropArrayTemp[ioopPR_OBJECT_TYPE].ulPropTag = PR_OBJECT_TYPE;
                                lpPropArrayTemp[ioopPR_OBJECT_TYPE].Value.l = MAPI_MAILUSER;

                                if(!(ulFlags & MAPI_UNICODE))
                                {
                                    if (sc = ScConvertWPropsToA((LPALLOCATEMORE) (&MAPIAllocateMore), lpPropArrayTemp, ioopMAX, 0))
                                        goto exit;
                                }

                                if (sc = ScMergePropValues(lpAdrEntry->cValues,
                                                          lpAdrEntry->rgPropVals,           // source1
                                                          ioopMAX,
                                                          lpPropArrayTemp,                  // source2
                                                          &cPropsNew,
                                                          &lpPropArrayNew)) 
                                {               
                                    goto exit;
                                }

                                FreeBufferAndNull(&lpPropArrayTemp);

                                // Free the original prop value array
                                FreeBufferAndNull((LPVOID *) (&(lpAdrEntry->rgPropVals)));

                                // Now, build the new ADRENTRY
                                lpAdrEntry->cValues = cPropsNew;
                                lpAdrEntry->rgPropVals = lpPropArrayNew;

                                // Mark this entry as found.
                                lpFlagList->ulFlag[i] = MAPI_RESOLVED;
                            }
                        }
                        // Once we've found PR_DISPLAY_NAME we don't need to look at
                        // any more props.  Jump to next ADRENTRY.
                        fNotDone = FALSE;   // exit this ADRENTRY
                        continue;

                    case PR_EMAIL_ADDRESS:
                        lpszEmailAddress = (ulFlags & MAPI_UNICODE) ?
                                            lpAdrEntry->rgPropVals[j].Value.lpszW :
                                            ConvertAtoW(lpAdrEntry->rgPropVals[j].Value.lpszA);
                        break;
                }
            }
        }
        // if the ambiguity could not be resolved as an email, reset it
        if(bAmbiguous && lpFlagList->ulFlag[i] == MAPI_UNRESOLVED)
            lpFlagList->ulFlag[i] = MAPI_AMBIGUOUS;

    }

exit:
    hResult = ResultFromScode(sc);

    if(!(ulFlags & MAPI_UNICODE))
    {
        if(lpszEmailAddress != lpszDisplayName)
            LocalFreeAndNull(&lpszEmailAddress);
        LocalFreeAndNull(&lpszDisplayName);
    }

    return(hResult);
}


//---------------------------------------------------------------------------
// Name:		IAB_NewEntry()
//
// Description:	
// Parameters:	
// Returns:	
// Effects:	
// Notes:	
// Revision:	
//---------------------------------------------------------------------------
STDMETHODIMP
IAB_NewEntry(LPIAB lpIAB,
  ULONG_PTR ulUIParam,
  ULONG ulFlags,
  ULONG cbEIDContainer,
  LPENTRYID lpEIDContainer,
  ULONG cbEIDNewEntryTpl,
  LPENTRYID lpEIDNewEntryTpl,
  ULONG FAR * lpcbEIDNewEntry,
  LPENTRYID FAR * lppEIDNewEntry)
{
    HRESULT hr = hrSuccess;
    BOOL bChangesMade = FALSE;
    BYTE bType;
    SCODE sc;

#ifndef DONT_ADDREF_PROPSTORE
        if ((FAILED(sc = OpenAddRefPropertyStore(NULL, lpIAB->lpPropertyStore)))) {
            hr = ResultFromScode(sc);
            goto exitNotAddRefed;
        }
#endif



	// BUGBUG <JasonSo>: This code does not handle the Container param at all.
    VerifyWABOpenExSession(lpIAB);

    bType = IsWABEntryID(cbEIDNewEntryTpl, lpEIDNewEntryTpl, NULL, NULL, NULL, NULL, NULL);

    if (bType == WAB_DEF_MAILUSER || cbEIDNewEntryTpl == 0)
    {
        if(!lpcbEIDNewEntry || !lppEIDNewEntry)
        {
            hr = MAPI_E_INVALID_PARAMETER;
            goto exit;
        }
        *lpcbEIDNewEntry = 0;
        *lppEIDNewEntry = NULL;
        hr = HrShowDetails( (LPADRBOOK)lpIAB,
                            (HWND) ulUIParam,
                            lpIAB->lpPropertyStore->hPropertyStore,
                            cbEIDContainer,
                            lpEIDContainer,
                            lpcbEIDNewEntry,
                            lppEIDNewEntry,
                            NULL,
                            SHOW_NEW_ENTRY,
                            MAPI_MAILUSER,
                            &bChangesMade);
    }
    else if (bType == WAB_DEF_DL)
    {
        hr = HrShowDetails( (LPADRBOOK)lpIAB,
                            (HWND) ulUIParam,
                            lpIAB->lpPropertyStore->hPropertyStore,
                            cbEIDContainer,
                            lpEIDContainer,
                            lpcbEIDNewEntry,
                            lppEIDNewEntry,
                            NULL,
                            SHOW_NEW_ENTRY,
                            MAPI_DISTLIST,
                            &bChangesMade);

    }
    else
    {
        DebugTrace(TEXT("IAB_NewEntry got unknown template entryID\n"));
        hr = ResultFromScode(MAPI_E_INVALID_ENTRYID);
        goto exit;
    }

exit:
#ifndef DONT_ADDREF_PROPSTORE
    ReleasePropertyStore(lpIAB->lpPropertyStore);
exitNotAddRefed:
#endif

    return(hr);
}


//---------------------------------------------------------------------------
// Name:		IAB_Address()
//
// Description:	
// Parameters:	
// Returns:	
// Effects:	
// Notes:	
// Revision:	
//---------------------------------------------------------------------------
STDMETHODIMP
IAB_Address(LPIAB				lpIAB,
			 ULONG_PTR FAR *		lpulUIParam,
			 LPADRPARM			lpAdrParms,
			 LPADRLIST FAR *	lppAdrList)
{
	SCODE sc;
	HRESULT hr = hrSuccess;
//	OOPENTRYIDCONT oopEntryID;
//	LPMAPIERROR lpMAPIError = NULL;
//	MAPIDLG_Address FAR *lpfnAddress;
//  BOOL fInited;

#ifndef DONT_ADDREF_PROPSTORE
        if ((FAILED(sc = OpenAddRefPropertyStore(NULL, lpIAB->lpPropertyStore)))) {
            hr = ResultFromScode(sc);
            goto exitNotAddRefed;
        }
#endif

#ifdef PARAMETER_VALIDATION
	// Make sure it's an IAB
	//
	if (BAD_STANDARD_OBJ(lpIAB, IAB_, Address, lpVtbl))
	{
		DebugTraceArg(IAB_Address,  TEXT("Bad vtable"));		
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	// Validate Parameters
	//
	if ((lpulUIParam && IsBadWritePtr(lpulUIParam, sizeof(ULONG)))
		|| (!lpAdrParms || IsBadWritePtr(lpAdrParms, sizeof(ADRPARM))))
	{
		DebugTraceArg(IAB_Address,  TEXT("Invalid lpulUIParam or lpAdrParms"));		
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	// Validate AdrParm
	//
	
	// validate lpAdrParm->cbABContEntryID and lpAdrParm->lpABContEntryID
	
	if (lpAdrParms->cbABContEntryID
	  && (!lpAdrParms->lpABContEntryID || IsBadReadPtr(lpAdrParms->lpABContEntryID,
		   (UINT)lpAdrParms->cbABContEntryID)))
	{
		DebugTraceArg(IAB_Address,  TEXT("Invalid lpAdrParam->lpABContEntryID"));
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
	
	// validate lpAdrParm->lpfnABSDI, only used if DIALOG_SDI is set.
	
	if (lpAdrParms->ulFlags & DIALOG_SDI)
	{
		if (lpAdrParms->lpfnABSDI && IsBadCodePtr((FARPROC)lpAdrParms->lpfnABSDI))
		{
			DebugTraceArg(IAB_Address,  TEXT("Invalid lpAdrParam->lpfnABSDI"));
			return ResultFromScode(MAPI_E_INVALID_PARAMETER);
		}
	}
	

	//
	//  Validate lpAdrList, if the call would allow modification of the list
	//
	if (lpAdrParms->ulFlags & DIALOG_MODAL)
	{
		if (lppAdrList) // Treat NULL as a special case of don't care
		{
			if (IsBadWritePtr(lppAdrList, sizeof(LPADRLIST)))
			{
				DebugTraceArg(IAB_Address,  TEXT("Invalid lppAdrList"));
				return ResultFromScode(MAPI_E_INVALID_PARAMETER);
			}
			if (*lppAdrList && FBadAdrList(*lppAdrList))
			{
				DebugTraceArg(IAB_Address,  TEXT("Invalid *lppAdrList"));
				return ResultFromScode(MAPI_E_INVALID_PARAMETER);
			}
		}
	}				

	//
	//  Check strings
	//

	//
	//  lpszCaption - goes on the top of the dialog on the caption bar
	//
	if (lpAdrParms->lpszCaption
		&& (lpAdrParms->ulFlags & MAPI_UNICODE
			? IsBadStringPtrW((LPWSTR) lpAdrParms->lpszCaption, (UINT) -1)
			: IsBadStringPtrA((LPSTR) lpAdrParms->lpszCaption, (UINT) -1)))
	{
		DebugTraceArg(IAB_Address,  TEXT("Invalid lpAdrParm->lpszCaption"));
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
	
	//
	//  lpszNewEntryTitle - Goes on the NewEntry dialog by the radio button, uninteresting if
	//  AB_SELECTONLY is set.
	//
	if (!(lpAdrParms->ulFlags & AB_SELECTONLY) && lpAdrParms->lpszNewEntryTitle
		&& (lpAdrParms->ulFlags & MAPI_UNICODE
			? IsBadStringPtrW((LPWSTR) lpAdrParms->lpszNewEntryTitle, (UINT) -1)
			: IsBadStringPtrA((LPSTR) lpAdrParms->lpszNewEntryTitle, (UINT) -1)))
	{
		DebugTraceArg(IAB_Address,  TEXT("Invalid lpAdrParm->lpszNewEntryTitle"));
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
				

	//
	//  Only check the following parameters if cDestFields is non-zero and !-1
	//
	if (lpAdrParms->cDestFields && lpAdrParms->cDestFields != (ULONG) -1)
	{
		ULONG ulString;
		//
		//  lpszDestWellsTitle - Goes above the destination wells, uninteresting if 0 wells is
		//  brought up.
		//
		if (lpAdrParms->lpszNewEntryTitle
			&& (lpAdrParms->ulFlags & MAPI_UNICODE
				? IsBadStringPtrW((LPWSTR) lpAdrParms->lpszNewEntryTitle, (UINT) -1)
				: IsBadStringPtrA((LPSTR) lpAdrParms->lpszNewEntryTitle, (UINT) -1)))
		{
			DebugTraceArg(IAB_Address,  TEXT("Invalid lpAdrParm->lpszNewEntryTitle"));
			return ResultFromScode(MAPI_E_INVALID_PARAMETER);
		}

		//
		//  nDestFieldFocus - needs to be less than cDestFields unless cDestFields is 0.
		//
		if (lpAdrParms->nDestFieldFocus >= lpAdrParms->cDestFields)
		{
			DebugTraceArg(IAB_Address,  TEXT("Invalid lpAdrParm->nDestFieldFocus"));
			return ResultFromScode(MAPI_E_INVALID_PARAMETER);
		}

		//
		//  lppszDestTitles - should be more like rglpszDestTitles[cDestFields].  Each string
		//  should be valid (i.e. not NULL although "" is acceptable).
		//
		if (lpAdrParms->lppszDestTitles)
		{
			//
			//  Loop through each title and see if there's a valid string
			//
			for (ulString = 0; ulString < lpAdrParms->cDestFields; ulString++)
			{
				if (!*(lpAdrParms->lppszDestTitles+ulString)
					|| (lpAdrParms->ulFlags & MAPI_UNICODE
					? IsBadStringPtrW((LPWSTR) *(lpAdrParms->lppszDestTitles+ulString), (UINT)-1)
					: IsBadStringPtrA((LPSTR) *(lpAdrParms->lppszDestTitles+ulString), (UINT)-1)))
				{
					DebugTraceArg(IAB_Address,  TEXT("Invalid lpAdrParm->lppszDestTitles"));
					return ResultFromScode(MAPI_E_INVALID_PARAMETER);
				}
			}
		}
					

		//
		//  lpulDestComps - should be more like rgulDestComps[cDestFields].  This is the value
		//  for the PR_RECIPIENT_TYPE for messages.  In fact, on the adrlist that is returned from
		//  this method, one of the list of values for this list will be set for each recipient.
		//  We don't validate that these have one of the MAPI defined values as we cannot tell
		//  if this call is being made to address a message.  We don't care about this value if
		//  cDestFields is 0.
		//
		if (lpAdrParms->lpulDestComps
			&& IsBadReadPtr(lpAdrParms->lpulDestComps, (UINT) lpAdrParms->cDestFields*sizeof(ULONG)))

		{
			DebugTraceArg(IAB_Address,  TEXT("Invalid lpAdrParm->lpulDestComps"));
			return ResultFromScode(MAPI_E_INVALID_PARAMETER);
		}
	}

	//
	//  lpContRestriction - This restriction, if there, gets applied to every contents table
	//  that is opened during the life of this dialog.
	//
	if (lpAdrParms->lpContRestriction && FBadRestriction(lpAdrParms->lpContRestriction))
	{
		DebugTraceArg(IAB_Address,  TEXT("Invalid lpAdrParm->lpContRestriction"));
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	//
	//  lpHierRestriction - This restriction, if there, gets applied to the hierarchy table.
	//  It's very useful when done on PR_AB_PROVIDER_ID.
	//
	if (lpAdrParms->lpHierRestriction && FBadRestriction(lpAdrParms->lpHierRestriction))
	{
		DebugTraceArg(IAB_Address,  TEXT("Invalid lpAdrParm->lpHierRestriction"));
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}	

	//
	//		DIALOG_SDI
	//
	if (lpAdrParms->ulFlags & DIALOG_SDI)
	{
		//
		//  Only if we're SDI do we check these function pointers.  They don't
		//  have to exist, although our current implementation of the dialogs will
		//  behave strangely without them.
		//
		if (lpAdrParms->lpfnDismiss && IsBadCodePtr((FARPROC)lpAdrParms->lpfnDismiss))
		{
			DebugTraceArg(IAB_Address,  TEXT("Invalid lpAdrParm->lpfnDismiss"));
			return ResultFromScode(MAPI_E_INVALID_PARAMETER);
		}
	}

#endif // PARAMETER_VALIDATION

    VerifyWABOpenExSession(lpIAB);

    hr = HrShowAddressUI(
                         (LPADRBOOK)lpIAB,
                         lpIAB->lpPropertyStore->hPropertyStore,
					     lpulUIParam,
					     lpAdrParms,
					     lppAdrList);

#ifndef DONT_ADDREF_PROPSTORE
    ReleasePropertyStore(lpIAB->lpPropertyStore);
exitNotAddRefed:
#endif

    return hr;
}

//---------------------------------------------------------------------------
// Name:		IAB_Details()
//
// Description:	
// Parameters:	
// Returns:	
// Effects:	
// Notes:	    ulFlags can be 0 or MAPI_UNICODE but the MAPI_UNICODE only affects
//              the lpszButtonText which is not supported. Hence this function doesn't
//              change any behaviour with MAPI_UNICODE flag.
// Revision:	
//---------------------------------------------------------------------------
STDMETHODIMP
IAB_Details(LPIAB			lpIAB,
			 ULONG_PTR FAR *	lpulUIParam,
			 LPFNDISMISS	lpfnDismiss,
			 LPVOID			lpvDismissContext,
			 ULONG			cbEntryID,
			 LPENTRYID 		lpEntryID,
			 LPFNBUTTON		lpfButtonCallback,
			 LPVOID			lpvButtonContext,
			 LPTSTR			lpszButtonText,
			 ULONG			ulFlags)
{
	SCODE		sc;
	HRESULT		hr = hrSuccess;
    BOOL    bChangesMade = FALSE; //flags us if Details lead to any editing
    BYTE bType;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

//	LPMAPIERROR lpMAPIError = NULL;
//	MAPIDLG_Details FAR *lpfnDetails;
//	BOOL fInited;
#ifndef DONT_ADDREF_PROPSTORE
        if ((FAILED(sc = OpenAddRefPropertyStore(NULL, lpIAB->lpPropertyStore)))) {
            hr = ResultFromScode(sc);
            goto exitNotAddRefed;
        }
#endif

#ifdef PARAMETER_VALIDATION
	// Make sure it's an IAB
	//
	if (BAD_STANDARD_OBJ(lpIAB, IAB_, Details, lpVtbl))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	/*
	 *	Validate flags
	 */
	if (ulFlags & ~(MAPI_UNICODE | DIALOG_MODAL | DIALOG_SDI | WAB_ONEOFF_NOADDBUTTON))
	{
		/*
		 *  Unknown flags
		 */
        DebugTraceArg(IAB_Details,  TEXT("Unknown flags used"));
		//return ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
	}
	

	// Validate Parameters
	
	if (!lpulUIParam
		|| (lpulUIParam && IsBadWritePtr(lpulUIParam, sizeof(ULONG))))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	if (!cbEntryID
		|| IsBadReadPtr(lpEntryID, (UINT) cbEntryID))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	if (lpfButtonCallback
		&& (IsBadCodePtr((FARPROC) lpfButtonCallback)
			|| (lpszButtonText
				&& ((ulFlags & MAPI_UNICODE)
					 ? IsBadStringPtrW((LPWSTR) lpszButtonText, (UINT) -1)
					 : IsBadStringPtrA((LPSTR)lpszButtonText, (UINT) -1)))))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	if ((ulFlags & DIALOG_SDI) && IsBadCodePtr((FARPROC) lpfnDismiss))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

#endif // PARAMETER_VALIDATION


    VerifyWABOpenExSession(lpIAB);

    bType = IsWABEntryID(cbEntryID, lpEntryID, NULL, NULL, NULL, NULL, NULL);

    if( (bType == 0) &&
        cbEntryID && lpEntryID) // assume its valid ..
    {
        // its unlikely that anyone will ever give a template entry id to this
        // function. Hence if we are here, we have some non-null cbEntryID
        // and lpEntryid .. if we can open it, we can tell if its a mailuser
        // or a distlist ...
        // We'll have to open this entry and look at its ulObjectType

        ULONG ulObjectType = 0;
        LPMAPIPROP lpMailUser = NULL;

        hr = lpIAB->lpVtbl->OpenEntry(  lpIAB,
                                        cbEntryID,
                                        lpEntryID,
                                        NULL,
                                        0,
                                        &ulObjectType,
                                        (LPUNKNOWN * )&lpMailUser);

        if(HR_FAILED(hr))
            goto exit;

        if (ulObjectType == MAPI_DISTLIST)
            bType = WAB_DEF_DL;
        else
            bType = WAB_DEF_MAILUSER;

        if(lpMailUser)
            lpMailUser->lpVtbl->Release(lpMailUser);
    }

    if ((bType == WAB_DEF_MAILUSER) || (cbEntryID == 0))
    {
        hr = HrShowDetails((LPADRBOOK) lpIAB,
                           (HWND) *lpulUIParam,
                           lpIAB->lpPropertyStore->hPropertyStore,
                           0, NULL, //container EID
                           &cbEntryID,
                           &lpEntryID,
                           NULL,
                           SHOW_DETAILS,
                           MAPI_MAILUSER,
                           &bChangesMade);
    }
    else if (bType == WAB_DEF_DL)
    {
        hr = HrShowDetails((LPADRBOOK) lpIAB,
                           (HWND) *lpulUIParam,
                           lpIAB->lpPropertyStore->hPropertyStore,
                           0, NULL, //container EID
                           &cbEntryID,
                           &lpEntryID,
                           NULL,
                           SHOW_DETAILS,
                           MAPI_DISTLIST,
                           &bChangesMade);

    }
    else if ((bType == WAB_ONEOFF) || (bType == WAB_LDAP_MAILUSER))
    {
        //this may be a one-off entry
        hr = HrShowOneOffDetails((LPADRBOOK) lpIAB,
                            (HWND) *lpulUIParam,
                            cbEntryID,
                            lpEntryID,
                            MAPI_MAILUSER,
                            NULL,
                            NULL,
                            (ulFlags & WAB_ONEOFF_NOADDBUTTON) ? 
                                SHOW_ONE_OFF | WAB_ONEOFF_NOADDBUTTON : SHOW_ONE_OFF);

    }
    else
    {
        DebugTrace(TEXT("IAB_Details got unknown entryID type\n"));
        hr = ResultFromScode(MAPI_E_INVALID_ENTRYID);
        goto exit;
    }

exit:
#ifndef DONT_ADDREF_PROPSTORE
    ReleasePropertyStore(lpIAB->lpPropertyStore);
exitNotAddRefed:
#endif

    // [PaulHi] 3/22/99  Raid 69651  If the DL property sheet changed, assume the title has
    // changed as well and refresh the Tree View
    if ( (bType == WAB_DEF_DL) && bChangesMade && lpIAB->hWndBrowse)
        PostMessage(lpIAB->hWndBrowse, WM_COMMAND, (WPARAM) IDM_VIEW_REFRESH, 0);

    return(hr);
}


//-----------------------------------------------------------------------------
// Synopsis:    IAB_RecipOptions()
// Description:
//              Resolve per Recipient Options.
//
// Parameters:
//  [in]        LPIAB          lpIAB       Pointer to AB object
//  [in]        ULONG          ulUIParam   Platform dependant UI parm
//  [in]        ULONG          ulFlags     Flags. UNICODE Flags
//  [in/out]    LPADRENTRY *   lppRecip    Recipient whose options are to be
//                                         displayed
// Returns:
//              HRESULT hr     hrSuccess: if no problems. Also if no Recip
//                                  Options found.
// Effects:
// Notes:
//				-   HrRecipOptions() will have to be modified to take a
//					ulFlag parameter so that any string properties are returned
//					Unicode if requested.
//
//				-	UNICODE currently not supported
//
// Revision:
//-----------------------------------------------------------------------------

STDMETHODIMP
IAB_RecipOptions(LPIAB lpIAB, ULONG_PTR ulUIParam, ULONG ulFlags,
	LPADRENTRY lpRecip)
{
	HRESULT             hr;
#ifdef OLD_STUFF
	SCODE               sc                  = S_OK;
	LPMALLOC			lpMalloc			= NULL;
	LPXPLOGON           lpXPLogon           = NULL;
	LPOPTIONDATA        lpOptionData        = NULL;
	LPSTR				lpszError           = NULL;
	LPSTR				lpszAdrType         = NULL;
	LPPROPDATA          lpPropData          = NULL;
	LPMAPIPROP          lpIPropWrapped      = NULL;
	LPPROFSUP           lpSup               = NULL;
	LPMAPITABLE         lpDisplayTable      = NULL;
	OPTIONCALLBACK *    pfnXPOptionCallback = NULL;
	UINT                idsError            = 0;
	HINSTANCE           hinstXP             = 0;
	ULONG               cProps;
  LPSPropValue        lpProp;
	LPGUID              lpRecipGuid;
    LPSTR				lpszTitle			= NULL;
	MAPIDLG_DoConfigPropsheet FAR *lpfnPropsheet;
	LPMAPIERROR			lpMapiError			= NULL;
	BOOL				fInited;

#ifdef PARAMETER_VALIDATION

	 //  Check to see if it has a jump table

	if (IsBadReadPtr(lpIAB, sizeof(LPVOID)))
	{
		//  No jump table found

		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	// Check to see that it's IABs jump table

	if (lpIAB->lpVtbl != &vtblIAB)
	{
		// Not my jump table

		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	// Validate that the UI handle is good

	if (ulUIParam && !IsWindow((HWND)ulUIParam))
	{
		DebugTraceArg(IAB_RecipOptions,  TEXT("invalid window handle\n"));
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	// Validate flags

	if (ulFlags & ~MAPI_UNICODE)
	{
		DebugTraceArg(IAB_RecipOptions,   TEXT("reserved flags used\n"));
//		return ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
	}

	// Validate the ADRENTRY

	if (IsBadWritePtr(lpRecip, sizeof(ADRENTRY))) // RAID 1967
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	if (!(lpRecip) || FBadRgPropVal((LPSPropValue)lpRecip->rgPropVals, (int)lpRecip->cValues))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
	
#endif // PARAMETER_VALIDATION


	EnterCriticalSection(&lpIAB->cs);

	// We need the lpMalloc for the OptionCallback
	
	lpMalloc = lpIAB->pSession->lpMalloc;
	
	// Spin through the props and look for the PR_ENTRYID and PR_ADDRTYPE

	lpProp = NULL;
	cProps = lpRecip->cValues;
	lpProp = LpValFindProp(PR_ENTRYID, cProps, lpRecip->rgPropVals);
	if (!lpProp)
	{
		DebugTrace(TEXT("IAB_RecipOptions(): No EntryId found in AdrEntry prop array\n"));
		hr = ResultFromScode(MAPI_E_INVALID_PARAMETER);
		idsError = IDS_INVALID_PARAMETER;
		goto exit;
	}

	// Get MAPI UID

	lpRecipGuid = (LPGUID)((LPENTRYID)lpProp->Value.bin.lpb)->ab;

	lpProp = NULL;
	lpProp = LpValFindProp(PR_ADDRTYPE, cProps, lpRecip->rgPropVals);

	if (lpProp)
	{
		if (PROP_TYPE(lpProp->ulPropTag) == PT_STRING8)
		{
			lpszAdrType = lpProp->Value.lpszA;
		}
	}
	
	// Build the support object.  Try using the Profile Support object.

	if (HR_FAILED(hr = NewProfSup(lpIAB->pSession, &lpSup)))
	{
		idsError = IDS_NOT_ENOUGH_MEMORY;
		DebugTrace(TEXT("IAB_RecipOptions(): error creating Support object\n"));
		goto exit;
	}

    Assert(lpSup);

	// Find out if there is any Option Data for us.

	hr = HrGetRecipOptions(lpRecipGuid, lpszAdrType, &lpSup->muidSection,
			&lpSup->muidService, &lpXPLogon, &lpOptionData);
	if (GetScode(hr) == MAPI_E_NOT_FOUND)
	{
		// It's not really an error, just that no recip options exist for that
		// recipient.  Convert hr to a warning and exit.

		hr = ResultFromScode(MAPI_W_ERRORS_RETURNED);
		idsError = IDS_NO_RECIP_OPTIONS;
		goto exit;
	}

	if (HR_FAILED(hr))
	{
		idsError = IDS_OPTIONS_DATA_ERROR;
		DebugTrace(TEXT("IAB_RecipOptions(): Failure obtaining Option Data\n"));
		goto exit;
	}

	Assert(lpXPLogon && lpOptionData);

	// Get the XP callback function.

	if (FAILED (ScMAPILoadProviderLibrary (lpOptionData->lpszDLLName, &hinstXP)))
	{
		SideAssert(sc = GetLastError());
		idsError = IDS_CANT_INIT_PROVIDER;
		DebugTrace(TEXT("IAB_RecipOptions(): error 0x%lx loading XP provider %s\n"),
				sc, lpOptionData->lpszDLLName);
		goto exit;
	}

	pfnXPOptionCallback = (OPTIONCALLBACK *)GetProcAddress(hinstXP,
			(LPCSTR)lpOptionData->ulOrdinal);
	if (!pfnXPOptionCallback)
	{
		DebugTrace(TEXT("IAB_RecipOptions(): error finding XPOptions callback\n"));
		idsError = IDS_CANT_INIT_PROVIDER;
		hr = ResultFromScode(MAPI_E_NOT_INITIALIZED);
		goto exit;
	}

	// Create MAPIProp object
	sc = CreateIProp((LPIID) &IID_IMAPIPropData,
						MAPIAllocateBuffer,
						MAPIAllocateMore,
						MAPIFreeBuffer,
						NULL,
						&lpPropData);

	if (FAILED(sc)) {
		idsError = IDS_NOT_ENOUGH_MEMORY;
		DebugTrace(TEXT("IAB_RecipOptions(): error creating IProp object\n"));
		goto exit;
	}
	MAPISetBufferName(lpPropData,  TEXT("lpPropData in IAB_RecipOptions"));

    Assert(lpPropData);

	// Copy over the Default props from the Options default props

	if (lpOptionData->cOptionsProps && lpOptionData->lpOptionsProps)
	{
		cProps = lpOptionData->cOptionsProps;
		lpProp = lpOptionData->lpOptionsProps;
		if (HR_FAILED(hr = lpPropData->lpVtbl->SetProps(lpPropData, cProps, lpProp,
			NULL)))
		{
			lpPropData->lpVtbl->GetLastError(lpPropData, hr, 0, &lpMapiError);
			DebugTrace(TEXT("IAB_RecipOptions(): SetProps failed overall\n"));
			goto exit;
		}
	}

	// Copy over the props from the ADRENTRY to our IProp object

	cProps = lpRecip->cValues;
	lpProp = lpRecip->rgPropVals;
	if (HR_FAILED(hr = lpPropData->lpVtbl->SetProps(lpPropData, cProps, lpProp,
			NULL)))
	{
		lpPropData->lpVtbl->GetLastError(lpPropData, hr, 0, &lpMapiError);
		DebugTrace(TEXT("IAB_RecipOptions(): SetProps failed overall\n"));
		goto exit;
	}

	// Call the XP provider callback to get the wrapped IProp Interface

	if (FAILED(sc = (*pfnXPOptionCallback)(hinstXP, lpMalloc,
			OPTION_TYPE_RECIPIENT, lpOptionData->cbOptionsData,
			lpOptionData->lpbOptionsData, (LPMAPISUP)lpSup,
			(LPMAPIPROP)lpPropData, &lpIPropWrapped, &lpMapiError)))
	{
		DebugTrace(TEXT("IAB_RecipOptions(): failure calling XP Callback\n"));
		goto exit;
	}

    Assert(lpIPropWrapped);

	// Get PR_DISPLAY_DETAILS a MAPI Table object

	if (HR_FAILED(hr = lpIPropWrapped->lpVtbl->OpenProperty(lpIPropWrapped,
			PR_DETAILS_TABLE, (LPIID)&IID_IMAPITable, 0, MAPI_MODIFY,
			(LPUNKNOWN *)&lpDisplayTable)))
	{
		lpIPropWrapped->lpVtbl->GetLastError(lpIPropWrapped, hr, 0, &lpMapiError);
		DebugTrace(TEXT("IAB_RecipOptions(): failure opening PR_DISPLAY_DETAILS\n"));
		goto exit;
	}

	Assert(lpDisplayTable);

	// Initialize the common MAPI dialog DLL (MAPID??.DLL)

	sc = ScGetDlgFunction(offsetof(JT_MAPIDLG, dlg_doconfigpropsheet),
		(FARPROC FAR *)&lpfnPropsheet, &fInited);
	if (FAILED(sc))
	{
		idsError = IDS_CANT_INIT_COMMON_DLG;
		TraceSz("IAB_RecipOptions(): common dlg not init'd");
		hr = ResultFromScode(sc);
		goto exit;
	}

	// Loadstring the Subject Prefix text.
	
	sc = ScStringFromIDS(MAPIAllocateBuffer, 0, IDS_RECIPIENT_OPTIONS,
			&lpszTitle);
	if (FAILED(sc))		
	{
		hr = ResultFromScode(sc);
		DebugTrace(TEXT("IAB_RecipOptions(): OOM for prop sheet title string\n"));
        goto exit;
	}
	
	LeaveCriticalSection(&lpIAB->cs);

	// Call into MAPIDLG_DoConfigPropSheet...
	hr = (*lpfnPropsheet)(ulUIParam,
						ulFlags,
						lpszTitle,
						0,
						1,
						&lpDisplayTable,
						&lpIPropWrapped,
						&lpMapiError);

	if (fInited)
		CloseMapidlg();

	EnterCriticalSection(&lpIAB->cs);

	if (HR_FAILED(hr))
	{
		// $ Internal fixup to return error info in this API call so it matches the
		//   the other methods.

		DebugTrace(TEXT("IAB_RecipOptions(): DoConfigPropSheet error\n"));
		goto exit;
	}

	// From the Wrapped Props we'll rebuild a new ADRENTRY prop array
	// and pass it pack to the Client.

	lpProp = NULL;
	if (HR_FAILED(hr = lpIPropWrapped->lpVtbl->GetProps(lpIPropWrapped, NULL,
			MAPI_UNICODE, // ansi
			&cProps, &lpProp)))
	{
		lpIPropWrapped->lpVtbl->GetLastError(lpIPropWrapped, hr, 0, &lpMapiError);
		DebugTrace(TEXT("IAB_RecipOptions(): GetProps on new wrapped IProps failed.\n"));
		goto exit;
	}

	Assert(cProps && lpProp);

	// Free up the old ADRENTRY prop array and hook up the new one

	FreeBufferAndNull(&(lpRecip->rgPropVals));
	lpRecip->rgPropVals = lpProp;
	lpRecip->cValues = cProps;

exit:      // and clean up

	UlRelease(lpSup);
	UlRelease(lpDisplayTable);
	UlRelease(lpIPropWrapped);

	// Free the XP Provider lib

#ifdef WIN32
	if (hinstXP)
#else
	if (hinstXP >= HINSTANCE_ERROR)
#endif
	{
		FreeLibrary(hinstXP);
	}

	UlRelease(lpPropData);
	FreeBufferAndNull(&lpOptionData);
	FreeBufferAndNull(&lpszTitle);
	
	if (sc && !(hr))
		hr = ResultFromScode(sc);

	if (hr)
		SetMAPIError(lpIAB, hr, idsError, NULL, 0, 0,
				ulFlags & MAPI_UNICODE, lpMapiError);
		
	FreeBufferAndNull(&lpMapiError);				

	LeaveCriticalSection(&lpIAB->cs);

#endif
    hr = ResultFromScode(MAPI_E_NO_SUPPORT);

	DebugTraceResult(SESSOBJ_MessageOptions, hr);
	return hr;
}


//-----------------------------------------------------------------------------
// Synopsis:    IAB_QueryDefaultRecipOpt()
//
// Description:	Returns the XP provider registered default options property
//				list.
//
// Parameters:
//  [in]        LPIAB lpIAB       			Pointer to AB object
//  [in]        LPTSTR lpszAdrType
//  [in]        ULONG ulFlags     Flags. 	UNICODE Flags
//  [out]    	ULONG FAR *	lpcValues
//	[out]		LPSPropValue FAR * lppOptions
//
// Returns:
//              HRESULT hr		hrSuccess: if no problems. Also if no Recip
//								Options found.
// Effects:
// Notes:
//              -  	Unicode not implemented.
//
// Revision:
//-----------------------------------------------------------------------------
STDMETHODIMP
IAB_QueryDefaultRecipOpt(LPIAB lpIAB, LPTSTR lpszAdrType, ULONG ulFlags,
		ULONG FAR *	lpcValues, 	LPSPropValue FAR * lppOptions)
{
	HRESULT 			hr					= hrSuccess;
#ifdef OLD_STUFF
	SCODE				sc					= S_OK;
	LPXPLOGON           lpXPLogon           = NULL;
	LPOPTIONDATA        lpOptionData        = NULL;
	LPSPropValue		lpPropCopy			= NULL;
	UINT                idsError            = 0;
	LPSTR				lpszAdrTypeA		= NULL;
	MAPIUID				muidSection;
	MAPIUID				muidService;

#ifdef PARAMETER_VALIDATION

	/*
	 *  Check to see if it has a jump table
	 */
	if (IsBadReadPtr(lpIAB, sizeof(LPVOID)))
	{
		/*
		 *  No jump table found
		 */
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	/*
	 *  Check to see that it's IABs jump table
	 */
	if (lpIAB->lpVtbl != &vtblIAB)
	{
		/*
		 *  Not my jump table
		 */
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	/*
	 *	Check that return params can be written
	 */
	if (IsBadWritePtr(lpcValues, sizeof(ULONG))
	 	|| IsBadWritePtr(lppOptions, sizeof(LPSPropValue)))
	{
		/*
		 *  Bad output parameters
		 */
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	/*
	 *	Validate flags
	 */
	if (ulFlags & ~MAPI_UNICODE)
	{
		/*
		 *  Unknown flags
		 */
		return ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
	}
	

	if (IsBadStringPtrA((LPCSTR)lpszAdrType, (UINT)-1))
	{
		/*
		 *  Bad input string
		 */
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

#endif // PARAMETER_VALIDATION


	EnterCriticalSection(&lpIAB->cs);

	hr = HrGetRecipOptions(NULL, (LPSTR)lpszAdrType, &muidSection, &muidService,
		&lpXPLogon, &lpOptionData);
	
	if (GetScode(hr) == MAPI_E_NOT_FOUND)
	{
		// It's not an error, just that no recip options exist for that
		// adrtype.  Convert hr to hrSucces and exit.

		hr = hrSuccess;
		goto exit;
	}

	Assert(lpXPLogon && lpOptionData);

	if (HR_FAILED(hr))
	{
		idsError = IDS_OPTIONS_DATA_ERROR;
		DebugTrace(TEXT("IAB_QueryDefaultRecipOpt(): Failure obtaining Option Data\n"));
		goto exit;
	}

	// Find out if we have any default options to return.

	if (lpOptionData->cOptionsProps && lpOptionData->lpOptionsProps)
	{
		// Copy out the props from OptionData struct into new memory

		if (FAILED(sc = ScDupPropset((int)lpOptionData->cOptionsProps,
				lpOptionData->lpOptionsProps, MAPIAllocateBuffer,
				&lpPropCopy)))
		{
			idsError = IDS_NOT_ENOUGH_MEMORY,
			DebugTrace(TEXT("IAB_QueryDefaultRecipOpt(): Failure to copy prop set\n"));
			goto exit;
		}
	}

	*lpcValues  = lpOptionData->cOptionsProps;
	*lppOptions = lpPropCopy;

exit:

	FreeBufferAndNull(&lpOptionData);

	if (sc && !hr)
		hr = ResultFromScode(sc);

	if (hr)
		SetMAPIError(lpIAB, hr, idsError, NULL, 0, 0, 0, NULL);

	LeaveCriticalSection(&lpIAB->cs);
#endif

   hr = ResultFromScode(MAPI_E_NO_SUPPORT);
	DebugTraceResult(IAB_QueryDefaultRecipOpt, hr);
	return hr;
}

//---------------------------------------------------------------------------
// Name:		IAB_GetPAB()
// Description:	
//          This API normally returns what would be the default WAB Container
//          In pre-IE5 implementations of WAB, there is only 1 container which is
//          returned by this statement .. 
//          In IE5 WAB, the WAB can be running in profile mode or not in profile mode
//          If the WAB is not in profile mode it runs same as before (GetPAB returns a 
//              single container that has all the WAB contents in it)
//          If the WAB is in profile mode and has no current user, it runs same as before (GetPAB
//              returns a single container that has all the WAB contents in it)
//          If the WAB is in profile mode and has a user, the container returned here
//              corresponds to the user's contact folder - thus external apps would manipulate
//              directly into the users contact folder and not into other folders
//          Internally, however, the WAB may want to have a "Shared Contacts" container which has
//              stuff not in other folders. This shared contacts is needed for the WAB UI in both
//              with-user and without-user modes .. to distinguish between when we want the
//              shared contacts folder vs. when we want the all-contacts PAB or user's folder PAB, 
//              we define 2 internal functions that set the PAB EID to a special setting..
//              The assumption is that GetPAB is always followed by OpenEntry to get the container ..
//              .. if it is, then in OpenEntry we can check the PAB EID and determine what kind of
//              container to create ..
//              If lpContainer->pmbinOlk = NULL, this container contains all WAB contents
//              If lpContainer->pmbinOlk != NULL but lpContainer->pmbinOlk.cb = 0 and
//                  lpContainer->pmbinOlk->lpb = NULL, this is the "Shared Contacts" folder
//              If nothing is NULL, then this is the user's folder ..
//              
//          For the special EID, we set *lpcbEntryID == SIZEOF_WAB_ENTRYID and
//              *lppEntryID to szEmpty (This is a hack but there is no flag param here and it
//              should be safe for internal use only)
//              
// Parameters:	
// Returns:	
// Effects:	
// Notes:	
// Revision:	
//---------------------------------------------------------------------------

/*
-   SetVirtualPABEID
-   When calling GetPAB, we want to sometimes specify getting the virtual PAB
*   Folder instead of getting the Current User's Folder which is what
*   would be returned if this was a profile session. to somehow indicate to 
*   GetPAB what folder we want, we have a very special EID combination that
*   needs to be hndled very carefully .. for this the cbSize if 4 and
*   the lpEntryID is the static const string szEmpty
*/
// This function is added here so we can keep it linked to how GetPAB works
void SetVirtualPABEID(LPIAB lpIAB, ULONG * lpcb, LPENTRYID * lppb)
{
    //if(bAreWABAPIProfileAware(lpIAB))// && bIsThereACurrentUser(lpIAB))
    {
        *lpcb = SIZEOF_WAB_ENTRYID;
        *lppb = (LPENTRYID) szEmpty;
    }
}
// This function determines if the EID denotes a special virtual root PAB
BOOL bIsVirtualPABEID(ULONG cbEID, LPENTRYID lpEID)
{
    return (cbEID == SIZEOF_WAB_ENTRYID && szEmpty == (LPTSTR) lpEID);
}

STDMETHODIMP
IAB_GetPAB (LPIAB	lpIAB,
			ULONG *			lpcbEntryID,
			LPENTRYID *		lppEntryID)
{
    HRESULT hr;
    ULONG cbEID = 0;
    LPENTRYID lpEID = NULL;
    BOOL bSharedPAB = FALSE;

#ifdef PARAMETER_VALIDATION

    //  Check to see if it has a jump table

    if (IsBadReadPtr(lpIAB, sizeof(LPVOID))) {
        // No jump table found
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check to see that it's IABs jump table
    if (lpIAB->lpVtbl != &vtblIAB) {
        // Not my jump table
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (IsBadWritePtr(lpcbEntryID, sizeof(ULONG)) ||
      IsBadWritePtr(lppEntryID, sizeof(LPENTRYID)))
    {
        // Bad parameters.
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif // PARAMETER_VALIDATION

    VerifyWABOpenExSession(lpIAB);

    cbEID = *lpcbEntryID;
    lpEID = *lppEntryID;

    if(bIsVirtualPABEID(cbEID, lpEID))
    {
        // this is a special case where we asked for an over-ride of the GetPAB behaviour ..
        // in this case, we don't do anything
        bSharedPAB =TRUE;
        cbEID = 0; lpEID = NULL;
    }
    else
    if(bAreWABAPIProfileAware(lpIAB) && bIsThereACurrentUser(lpIAB))
    {
        // if this is a user-session then 
        cbEID = lpIAB->lpWABCurrentUserFolder->sbEID.cb;
        lpEID = (LPENTRYID)lpIAB->lpWABCurrentUserFolder->sbEID.lpb;
    }
    else
    {
        cbEID = 0;
        lpEID = NULL;
    }

    *lppEntryID = NULL;
    *lpcbEntryID = 0;

    if(!cbEID && !lpEID)
    {
        BYTE bPABType = bSharedPAB ? WAB_PABSHARED : WAB_PAB;
        if (HR_FAILED(hr = CreateWABEntryID(  bPABType,      // Create WAB's PAB entryid
                                              lpEID, NULL, NULL, 
                                              cbEID, 0,
                                              NULL,         // lpRoot (allocmore here)
                                              lpcbEntryID,  // returned cbEntryID
                                              lppEntryID))) 
        {
            goto out;
        }
    }
    else
    {
        if(!MAPIAllocateBuffer(cbEID, (LPVOID *)lppEntryID))
        {
            *lpcbEntryID = cbEID;
            CopyMemory(*lppEntryID, lpEID, cbEID);
        }
    }

    MAPISetBufferName(*lppEntryID,  TEXT("WAB PAB Entry ID"));
    hr = hrSuccess;

out:
    return(hr);
}


//---------------------------------------------------------------------------
// Name:		IAB_SetPAB()
// Description:	
// Parameters:	
// Returns:	
// Effects:	
// Notes:	
// Revision:	
//---------------------------------------------------------------------------
STDMETHODIMP
IAB_SetPAB (LPIAB	lpIAB,
				ULONG 		cbEntryID,
				LPENTRYID	lpEntryID)
{
   return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


//---------------------------------------------------------------------------
// Name:		IAB_GetDefaultDir()
//
// Description:	
// Parameters:	
// Returns:	
// Effects:	
// Notes:	
// Revision:	
//---------------------------------------------------------------------------
STDMETHODIMP
IAB_GetDefaultDir (LPIAB	lpIAB,
				   ULONG *		lpcbEntryID,
				   LPENTRYID *	lppEntryID)
{

#ifdef OLD_STUFF
    HRESULT 		hr = hrSuccess;
	SCODE 			sc;
	ULONG 			cValues;
	LPSPropValue 	lpPropVal 		= NULL;
	LPSBinary		lpbinEntryID	= NULL;

#ifdef PARAMETER_VALIDATION

	/*
	 *  Check to see if it has a jump table
	 */
	if (IsBadReadPtr(lpIAB, sizeof(LPVOID)))
	{
		/*
		 *  No jump table found
		 */
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	/*
	 *  Check to see that it's IABs jump table
	 */
	if (lpIAB->lpVtbl != &vtblIAB)
	{
		/*
		 *  Not my jump table
		 */
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	if (IsBadWritePtr(lpcbEntryID, sizeof(ULONG)) ||
		IsBadWritePtr(lppEntryID, sizeof(LPENTRYID)))
	{
		/*
		 *  Bad parameters.
		 */
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

#endif // PARAMETER_VALIDATION

	EnterCriticalSection(&lpIAB->cs);

	*lppEntryID = NULL;
	*lpcbEntryID = 0;
	//
	//  Check to see if IAdrBook already has this info...
	//
	if (lpIAB->lpEntryIDDD)
	{
		//  If so, copy it and we're done.

		if ((sc = MAPIAllocateBuffer(lpIAB->cbEntryIDDD,
			 (LPVOID *) lppEntryID))
			!= S_OK)
		{
			hr = ResultFromScode(sc);
			goto out;
		}
		MAPISetBufferName(*lppEntryID,  TEXT("Entry ID"));
		MemCopy(*lppEntryID, lpIAB->lpEntryIDDD, (UINT)lpIAB->cbEntryIDDD);
		*lpcbEntryID = lpIAB->cbEntryIDDD;

		hr = hrSuccess;
		goto out;
	}


	//  If not...
	//
	//	Retrieve PR_AB_DEFAULT_DIR from MAPIs default profile section
	//
	if (HR_FAILED(hr = ResultFromScode(IAB_ScGetABProfSectProps(
											lpIAB,
											&SPT_DD,
											&cValues,
											&lpPropVal))))
	{
		SetMAPIError(lpIAB, hr, IDS_NO_DEFAULT_DIRECTORY, NULL, 0,
			0, 0, NULL);
		goto out;
	}

	//
	//  Did I get it??  Is it in the hierarchy??
	//
	if (PROP_TYPE(lpPropVal->ulPropTag) == PT_ERROR ||
		!FContainerInHierarchy(lpIAB,
							   lpPropVal->Value.bin.cb,
							   (LPENTRYID) lpPropVal->Value.bin.lpb))
	{
		//  No, look for the first global read-only container with Recipients.
		
		hr = HrFindDirectory(lpIAB, 0, AB_RECIPIENTS | AB_UNMODIFIABLE,
				&lpbinEntryID, NULL, NULL);
								
		if (HR_FAILED(hr))
		{
			if (GetScode(hr) != MAPI_E_NOT_FOUND)
			{
				//  Assume HrFindDirectory set the last error sz
				
				goto out;
			}

			//	Didn't find any read-only containers, how about read write?
			
			hr = HrFindDirectory(lpIAB, 0, AB_RECIPIENTS | AB_MODIFIABLE,
					&lpbinEntryID, NULL, NULL);
					
			if (HR_FAILED(hr))
			{
	  			//  Assume HrFindDirectory set the last error sz
	  			
	  			goto out;
			}
		}

		sc = MAPIAllocateBuffer(lpbinEntryID->cb, lppEntryID);
		if (FAILED(sc))
			goto out;

		MemCopy(*lppEntryID, lpbinEntryID->lpb, lpbinEntryID->cb);
		*lpcbEntryID = lpbinEntryID->cb;
		
		MAPISetBufferName(*lppEntryID,  TEXT("Default Dir EntryID"));
	}
	else
	{
		//  Yes?  Copy it and return it to the caller

		hr = hrSuccess;	// Don't return warnings.

		if ((sc = MAPIAllocateBuffer(lpPropVal->Value.bin.cb,
			(LPVOID *) lppEntryID)) != S_OK)
		{
			hr = ResultFromScode(sc);
			goto out;
		}

		MAPISetBufferName(*lppEntryID,  TEXT("Entry ID"));
		MemCopy(*lppEntryID, lpPropVal->Value.bin.lpb,
			(UINT)lpPropVal->Value.bin.cb);
		*lpcbEntryID = lpPropVal->Value.bin.cb;
	}
	
	// Cache default directory in Iadrbook.
	
	sc = MAPIAllocateBuffer(*lpcbEntryID, (LPVOID *) &(lpIAB->lpEntryIDDD));

	if (FAILED(sc))
	{
		hr = ResultFromScode(sc);
		goto out;
	}
	
	MAPISetBufferName(lpIAB->lpEntryIDDD,  TEXT("cached IAB Entry ID"));

	//  Set IAdrBooks Default directory

	MemCopy(lpIAB->lpEntryIDDD, *lppEntryID,(UINT)*lpcbEntryID);
	lpIAB->cbEntryIDDD = *lpcbEntryID;
	
out:

	FreeBufferAndNull(&lpPropVal);
	FreeBufferAndNull(&lpbinEntryID);
	LeaveCriticalSection (&lpIAB->cs);
	
	// MAPI_E_NOT_FOUND is not an error
	
	if (MAPI_E_NOT_FOUND == GetScode(hr))
		hr = hrSuccess;

	DebugTraceResult(IAB_GetDefaultDir, hr);

	return hr;
#endif
	return(IAB_GetPAB(lpIAB, lpcbEntryID, lppEntryID));
}



//---------------------------------------------------------------------------
// Name:		IAB_SetDefaultDir()
//
// Description:	
// Parameters:	
// Returns:	
// Effects:	
// Notes:	
// Revision:	
//---------------------------------------------------------------------------
STDMETHODIMP
IAB_SetDefaultDir (LPIAB	lpIAB,
					   ULONG 		cbEntryID,
					   LPENTRYID	lpEntryID)
{
#ifdef OLD_STUFF
    HRESULT hr = hrSuccess;

	SPropValue spvDD;
	SCODE sc;


#ifdef PARAMETER_VALIDATION

	/*
	 *  Check to see if it has a jump table
	 */
	if (IsBadReadPtr(lpIAB, sizeof(LPVOID)))
	{
		/*
		 *  No jump table found
		 */
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	/*
	 *  Check to see that it's IABs jump table
	 */
	if (lpIAB->lpVtbl != &vtblIAB)
	{
		/*
		 *  Not my jump table
		 */
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	if (IsBadReadPtr(lpEntryID, (UINT)cbEntryID)
		|| (cbEntryID < sizeof (LPENTRYID)))
	{
		/*
		 *  Not my jump table
		 */
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}


#endif // PARAMETER_VALIDATION


	EnterCriticalSection(&lpIAB->cs);

	//
	//  Check to see if IAdrBook already has the Default Dir
	//

	if ((lpEntryID == lpIAB->lpEntryIDDD) ||
		((cbEntryID == lpIAB->cbEntryIDDD) &&
		 (!memcmp(lpEntryID, lpIAB->lpEntryIDDD, (UINT)cbEntryID))))
	{

		//  If so, all done.
		goto out;
	}


	//
	//  Free the old entryid
	//
	if (lpIAB->lpEntryIDDD)
	{
		FreeBufferAndNull(&(lpIAB->lpEntryIDDD));
		lpIAB->lpEntryIDDD = NULL;
		lpIAB->cbEntryIDDD = 0;
	}

	//
	//  Allocate space for a new entry id
	//
	if ((sc = MAPIAllocateBuffer(cbEntryID, (LPVOID *) &(lpIAB->lpEntryIDDD)))
		!= S_OK)
	{
		hr = ResultFromScode(sc);
		goto out;
	}
	MAPISetBufferName(lpIAB->lpEntryIDDD,  TEXT("cached IAB Entry ID"));

	//
	//  Set IAdrBooks Default directory
	//

	MemCopy(lpIAB->lpEntryIDDD, lpEntryID, (UINT)cbEntryID);
	lpIAB->cbEntryIDDD = cbEntryID;

	//
	//	Set the PR_AB_DEFAULT_DIR
	//	If it fails, continue anyway.
	//
	spvDD.ulPropTag = PR_AB_DEFAULT_DIR;
	spvDD.Value.bin.cb = cbEntryID;
	spvDD.Value.bin.lpb = (LPBYTE) lpEntryID;

	(void) IAB_ScSetABProfSectProps(lpIAB, 1, &spvDD);

out:

	LeaveCriticalSection(&lpIAB->cs);
	return hr;
#endif
	// BUGBUG: We need to fool Word into thinking this call succeeded.
	return(SUCCESS_SUCCESS);
}


// #pragma SEGMENT(IAdrBook2)


//---------------------------------------------------------------------------
// Name:		IAB_GetSearchPath()
//
// Description:	
// Parameters:	
// Returns:	
// Effects:	
// Notes:	
// Revision:	
//---------------------------------------------------------------------------
STDMETHODIMP
IAB_GetSearchPath(LPIAB			lpIAB,
				   ULONG			ulFlags,
				   LPSRowSet FAR *	lppSearchPath)
{

    HRESULT     hr = E_FAIL;
    ULONG       ulObjectType = 0;
    LPROOT      lpRoot = NULL;
    LPMAPITABLE lpContentsTable = NULL;
    LPSRowSet   lpSRowSet = NULL;
    ULONG       i=0,j=0;
    ULONG       ulContainerCount = 0;
    LPPTGDATA   lpPTGData=GetThreadStoragePointer();

#ifdef PARAMETER_VALIDATION
	// Make sure it's an IAB
	//
	if (BAD_STANDARD_OBJ(lpIAB, IAB_, Address, lpVtbl))
	{
		DebugTraceArg(IAB_Address,  TEXT("Bad vtable"));		
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

    // [PaulHi] 1/28/99  Raid 58495
    if (IsBadWritePtr(lppSearchPath, sizeof(LPSRowSet)))
    {
        DebugTrace(TEXT("ERROR: IAB_GetSearchPath - invalid out pointer"));
        return ResultFromScode(MAPI_E_INVALID_PARAMETER);
    }
#endif

    VerifyWABOpenExSession(lpIAB);

    hr = lpIAB->lpVtbl->OpenEntry( lpIAB,
                                    0,
                                    NULL, 	
                                    NULL, 	
                                    0, 	
                                    &ulObjectType, 	
                                    (LPUNKNOWN *) &lpRoot );

    if (HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("OpenEntry Failed: %x\n"),hr));
        goto out;
    }

    hr = lpRoot->lpVtbl->GetContentsTable( lpRoot,
                                            ulFlags,
                                            &lpContentsTable);

    if (HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("GetContentsTable Failed: %x\n"),hr));
        goto out;
    }

    // Set the columns to the bare minimum
    hr = lpContentsTable->lpVtbl->SetColumns(lpContentsTable,
                                            (LPSPropTagArray)&irnColumns,
                                            0);

    // This contentstable contains a list of all the containers,
    // which is basically the local container(s) followed by
    // all the LDAP containers ...
    //
    // By doing a QueryAllRows we will get an allocated SRowSet
    // which we will reuse and free the remaining elements of it
    //
    hr = HrQueryAllRows(lpContentsTable,
                        NULL,
                        NULL,
                        NULL,
                        0,
                        &lpSRowSet);

    if (HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("HrQueryAllRows Failed: %x\n"),hr));
        goto out;
    }

    // Now we want to return only the WAB container(s) and the
    // only those LDAP containers that have been chosen for
    // doing a ResolveNames operation ..

    if (pt_bIsWABOpenExSession) {
		ulContainerCount = lpIAB->lpPropertyStore->colkci;
		Assert(ulContainerCount);
	} else
        ulContainerCount = 1; // always return WAB_PAB so minimum is one

    // Do a restriction on the contentstable to get resolvename
    // LDAP containers ..

    {
        SRestriction resAnd[2]; // 0 = LDAP, 1 = ResolveFlag
        SRestriction resLDAPResolve;
        SPropValue ResolveFlag;
        ULONG cRows;

        // Restrict: Only show LDAP containers with Resolve TRUE
        resAnd[0].rt = RES_EXIST;
        resAnd[0].res.resExist.ulReserved1 = 0;
        resAnd[0].res.resExist.ulReserved2 = 0;
        resAnd[0].res.resExist.ulPropTag = (ulFlags & MAPI_UNICODE) ? // <note> assumes UNICODE defined
                                            PR_WAB_LDAP_SERVER :
                                            CHANGE_PROP_TYPE( PR_WAB_LDAP_SERVER, PT_STRING8);

        ResolveFlag.ulPropTag = PR_WAB_RESOLVE_FLAG;
        ResolveFlag.Value.b = TRUE;

        resAnd[1].rt = RES_PROPERTY;
        resAnd[1].res.resProperty.relop = RELOP_EQ;
        resAnd[1].res.resProperty.ulPropTag = PR_WAB_RESOLVE_FLAG;
        resAnd[1].res.resProperty.lpProp = &ResolveFlag;

        resLDAPResolve.rt = RES_AND;
        resLDAPResolve.res.resAnd.cRes = 2;
        resLDAPResolve.res.resAnd.lpRes = resAnd;

        hr = lpContentsTable->lpVtbl->Restrict(lpContentsTable,
                                              &resLDAPResolve,
                                              0);
        if (HR_FAILED(hr))
        {
            DebugTraceResult( TEXT("RootTable: Restrict"), hr);
            goto out;
        }

        // Since the number of resolve-LDAP-Containers is less than the
        // set of all the containers ... we can safely use our LPSRowset
        // allocated structure to get the items we want without worrying
        // about overruns ..

        {
            ULONG cRows = 1;
            while(cRows)
            {
                LPSRowSet lpRow = NULL;
                hr = lpContentsTable->lpVtbl->QueryRows(lpContentsTable,
                                                        1, //one row at a time
                                                        0,
                                                        &lpRow);
                if(HR_FAILED(hr))
                {
                    DebugTraceResult( TEXT("ResolveName:QueryRows"), hr);
                    cRows = 0;
                }
                else if (lpRow)
                {
                    cRows = lpRow->cRows;
                    if (cRows)
                    {
                        // replace a container in the lpSRowSet list with
                        // this one ...
                        FreeBufferAndNull((LPVOID *) (&lpSRowSet->aRow[ulContainerCount].lpProps));
                        lpSRowSet->aRow[ulContainerCount].cValues = lpRow->aRow[0].cValues;
                        lpSRowSet->aRow[ulContainerCount].lpProps = lpRow->aRow[0].lpProps;
                        lpRow->aRow[0].cValues = 0;
                        lpRow->aRow[0].lpProps = NULL;
                        ulContainerCount++;
                    }
                    FreeProws(lpRow);
                }
                else
                {
                    cRows = 0;
                }

            } // while cRows

            //Free any extra memory we might have got ...
            for (i=ulContainerCount;i<lpSRowSet->cRows;i++)
            {
                FreeBufferAndNull((LPVOID *) (&lpSRowSet->aRow[i].lpProps));
            }
            lpSRowSet->cRows = ulContainerCount;
        }
    }

    hr = S_OK;
	*lppSearchPath = lpSRowSet;

out:

    if(lpContentsTable)
        lpContentsTable->lpVtbl->Release(lpContentsTable);

    if(lpRoot)
        lpRoot->lpVtbl->Release(lpRoot);

   return(hr);
}



//---------------------------------------------------------------------------
// Name:		IAB_SetSearchPath()
// Description:	
//				Sets new searchpath in the user's profile.
//				Special case empty or NULL rowset by deleting search path
//				property from the profile.
//
// Parameters:	
// Returns:	
// Effects:	
// Notes:	
// Revision:	
//---------------------------------------------------------------------------
STDMETHODIMP
IAB_SetSearchPath(LPIAB		lpIAB,
				   ULONG		ulFlags,
				   LPSRowSet	lpSearchPath)
{
#ifdef OLD_STUFF
    SCODE		sc = SUCCESS_SUCCESS;

    LPSBinary	lpargbinDirEntryIDs = NULL;
    LPSRow		lprow;
    LPSBinary	lpbin;
    UINT		idsErr 				= 0;

#ifdef PARAMETER_VALIDATION

	/*
	 *  Check to see if it has a jump table
	 */
	if (IsBadReadPtr(lpIAB, sizeof(LPVOID)))
	{
		/*
		 *  No jump table found
		 */
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	/*
	 *  Check to see that it's IABs jump table
	 */
	if (lpIAB->lpVtbl != &vtblIAB)
	{
		/*
		 *  Not my jump table
		 */
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	if (FBadRowSet(lpSearchPath))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

#endif // PARAMETER_VALIDATION



	if (ulFlags) {
		//
		// No flags are defined for this call
		//
		return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
	}

	EnterCriticalSection(&lpIAB->cs);
	
	if (! lpSearchPath || ! lpSearchPath->cRows) {
		sc = IAB_ScDeleteABProfSectProps(lpIAB,
          (LPSPropTagArray)&ptagaABSearchPath);
		
		// Clear the searchpath cache

#if defined (WIN32) && !defined (MAC)
		if (fGlobalCSValid) {
			EnterCriticalSection(&csMapiSearchPath);
		} else {
			DebugTrace(TEXT("IAB_SetSearchPath:  MAPI32.DLL already detached.\n"));
		}
#endif
				
		FreeBufferAndNull(&(lpIAB->lpspvSearchPathCache));

#if defined (WIN32) && !defined (MAC)
		if (fGlobalCSValid) {
			LeaveCriticalSection(&csMapiSearchPath);
		} else {
			DebugTrace(TEXT("IAB_SetSearchPath:  MAPI32.DLL got detached.\n"));
		}
#endif
				
		goto ret;
	}

	if (FAILED(sc = MAPIAllocateBuffer(lpSearchPath->cRows * sizeof(SBinary),
										(LPVOID FAR *) &lpargbinDirEntryIDs))) {
		DebugTrace(TEXT("IAB::SetSearchPath() - Error allocating space for search path array (SCODE = 0x%08lX)\n"), sc);
		idsErr = IDS_NOT_ENOUGH_MEMORY;
		goto err;
	}
	
	MAPISetBufferName(lpargbinDirEntryIDs,  TEXT("IAB Search Path Array"));

	//	Convert the row set into an array of SBinarys
	
	lprow = lpSearchPath->aRow + lpSearchPath->cRows;
	lpbin = lpargbinDirEntryIDs + lpSearchPath->cRows;
	
	while (lprow--, lpbin-- > lpargbinDirEntryIDs) {
		//$???	Can I rely on the first column being the EntryID?
		//$  No. - BJD
		
		SPropValue *lpProp = PpropFindProp(lprow->lpProps, lprow->cValues, PR_ENTRYID);

		if (!lpProp) {
           DebugTrace(TEXT("IAB::SetSearchPath() - Row passed without PR_ENTRYID.\n"));
			sc = MAPI_E_MISSING_REQUIRED_COLUMN;
			goto err;
		}
		
		*lpbin = lpProp->Value.bin;
	}

	//	Set the search path
	
	sc = IAB_ScSetSearchPathI(lpIAB, lpSearchPath->cRows, lpargbinDirEntryIDs);
	
	if (FAILED(sc)) {
		DebugTrace(TEXT("IAB::SetSearchPath() - Error setting search path (SCODE = 0x%08lX)\n"), sc);
		idsErr = IDS_SET_SEARCH_PATH;
		goto err;
	}
	
ret:
    LeaveCriticalSection(&lpIAB->cs);
    FreeBufferAndNull(&lpargbinDirEntryIDs);

    DebugTraceSc(IAB_SetSearchPath, sc);

    return(ResultFromScode(sc));

err:
    SetMAPIError(lpIAB, ResultFromScode(sc), idsErr, NULL, 0, 0, 0, NULL);

    goto ret;
    return(ResultFromScode(sc));
#endif

    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


//----------------------------------------------------------------------------
// Synopsis:	IAB_PrepareRecips()
//
// Description:	
//				Calls each registered AB Provider with PrepareRecips.
//				The providers convert short entryids to longterm entryids
//				and ensures that the columnset contains the property tags
//				identified in lpPropTagArray.
//
// Parameters:	
// Returns:	
// Effects:	
// Notes:	
// Revision:
//				Now check to see if enough info has been provided to avoid
//				calling each registerd provider. RAID 5291
//
//----------------------------------------------------------------------------
STDMETHODIMP
IAB_PrepareRecips(	LPIAB					lpIAB,
	                ULONG                   ulFlags,
	                LPSPropTagArray         pPropTagArray,
	                LPADRLIST               pRecipList)
{
#ifdef OLD_STUFF

#ifdef PARAMETER_VALIDATION

	//  Check to see if it has a jump table
	
	if (IsBadReadPtr(lpIAB, sizeof(LPVOID)))
	{
		// No jump table found
		
		DebugTraceArg(IAB_PrepareRecips,  TEXT("Bad vtable"));
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	// Check to see that it's IABs jump table
	
	if (lpIAB->lpVtbl != &vtblIAB)
	{
		// Not my jump table
		
		DebugTraceArg(IAB_PrepareRecips,  TEXT("Bad vtable"));
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	// validate the prop tag array

	if (lpPropTagArray && FBadColumnSet(lpPropTagArray))
	{
		DebugTraceArg(IAB_PrepareRecips,  TEXT("Bad PropTag Array"));
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	if (!lpRecipList || FBadAdrList(lpRecipList))
	{
		DebugTraceArg(IAB_PrepareRecips,  TEXT("Bad ADRLIST"));
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	//  Make sure we've got a valid lpSession
	
	hr = HrCheckSession(0, lpIAB->pSession);
	if (HR_FAILED(hr))
	{
		DebugTraceArg(IAB_PrepareRecips,  TEXT("Bad Session Object"));
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
	
#endif // PARAMETER_VALIDATION

#endif // oldstuff


	HRESULT				hr = hrSuccess;
	ULONG				ulRecip;
	ULONG				ulProp;
	ULONG				ulObjType;
	ULONG				cValues;
	ULONG				cTotal;
	LPSPropValue		pspv = NULL, pspvEID = NULL;
	LPADRENTRY			pRecipEntry;
	LPMAILUSER			pMailUser = NULL;
    ULONG               i = 0;
    LPSPropValue        lpPropArrayNew = NULL;
    ULONG               ulcPropsNew = 0;
    SCODE               sc;

	Assert(pRecipList);

	if (!pRecipList)
		return(MAPI_E_INVALID_PARAMETER);

    // Since our entry id's are always long-term, we are done if
	// no additional properties are specified.
	if (!pRecipList->cEntries || !pPropTagArray)
		return S_OK;

	EnterCriticalSection(&lpIAB->cs);
	
    VerifyWABOpenExSession(lpIAB);

	for (ulRecip = 0; ulRecip < pRecipList->cEntries; ulRecip++)
	{
        pspvEID = NULL;

		pRecipEntry = &(pRecipList->aEntries[ulRecip]);

        for(i=0;i<pRecipEntry->cValues;i++)
        {
            if(pRecipEntry->rgPropVals[i].ulPropTag == PR_ENTRYID)
            {
                pspvEID = &(pRecipEntry->rgPropVals[i]);
                break;
            }
        }

		// Ignore unresolved entries
		if (!pspvEID)
			continue;

		// Open the entry
		if (FAILED(lpIAB->lpVtbl->OpenEntry(lpIAB,
                                            pspvEID->Value.bin.cb,
				                            (LPENTRYID)pspvEID->Value.bin.lpb,
                                            &IID_IMailUser, 0,
				                            &ulObjType, (LPUNKNOWN *)&pMailUser)))
			continue;

		Assert((ulObjType == MAPI_MAILUSER) || (ulObjType == MAPI_DISTLIST));

		// Get the requested props
		hr = pMailUser->lpVtbl->GetProps(pMailUser, pPropTagArray, MAPI_UNICODE, &cValues, &pspv);

		pMailUser->lpVtbl->Release(pMailUser);

		if (FAILED(hr))
			continue;

        if(cValues && pspv)
        {
            sc = ScMergePropValues( cValues,
                                    pspv,
                                    pRecipEntry->cValues,
				                    pRecipEntry->rgPropVals,
                                    &ulcPropsNew,
                                    &lpPropArrayNew);
            if (sc != S_OK)
            {
                hr = ResultFromScode(sc);
                goto out;
            }
        }

		// We're done with this now
		FreeBufferAndNull(&pspv);
		pspv = NULL;

		// Replace the props in the address list
		FreeBufferAndNull((LPVOID *) (&pRecipEntry->rgPropVals));
		pRecipEntry->rgPropVals = lpPropArrayNew;
		pRecipEntry->cValues = ulcPropsNew;
		lpPropArrayNew = NULL;
	} // for

	hr = hrSuccess;

out:
	if (lpPropArrayNew)
		FreeBufferAndNull(&lpPropArrayNew);
	
    if (pspv)
		FreeBufferAndNull(&pspv);

    LeaveCriticalSection(&lpIAB->cs);

	return hr;

}

#define MAX_DIGITS_ULONG_10 10      // 10 digits max in a ULONG base 10

/***************************************************************************

    Name      : GetNewPropTag

    Purpose   : Gets the next valid named PropTag for this property store.

    Parameters: lpgnp -> GUID_NAMED_PROPS containing all named props for
                    this store.
                ulEntryCount = number of GUIDs in lpgnp

    Returns   : returns the next valid PropTag value.  If 0, there are no
                more named properties.  (This would be bad.)

    Comment   :

***************************************************************************/
ULONG GetNewPropTag(LPGUID_NAMED_PROPS lpgnp, ULONG ulEntryCount) {
    static WORD wPropIDNext = 0;
    ULONG j, k;

    if (wPropIDNext == 0) {
        // look through the current named props
        // Since we don't allow removing named prop ids
        // we always increment past the largest ID in use.
        for (j = 0; j < ulEntryCount; j++) {
            for (k = 0; k < lpgnp[j].cValues; k++) {
                wPropIDNext = max(wPropIDNext, (WORD)PROP_ID(lpgnp[j].lpnm[k].ulPropTag));
            }
        }
        if (wPropIDNext == 0) {
            wPropIDNext = 0x8000;   // start at 8000
        } else {
            wPropIDNext++;          // next = one past current
        }
    }

    return(PROP_TAG(PT_UNSPECIFIED, wPropIDNext++));
}

/** WAB specific GetIDsFromNames **/
HRESULT HrGetIDsFromNames(LPIAB lpIAB,  ULONG cPropNames,
                            LPMAPINAMEID * lppPropNames, ULONG ulFlags, LPSPropTagArray * lppPropTags)
{
    HRESULT hResult;
    LPGUID_NAMED_PROPS lpgnp = NULL, lpgnpNew = NULL, lpgnpOld = NULL;
    LPNAMED_PROP lpnm;
    ULONG ulEntryCount;
    ULONG i, j, k;
    ULONG ulEntryCountOld = 0;
    BOOL fChanged = FALSE;
    LPTSTR lpName = NULL;
    LPTSTR * lpID = NULL;
    LPTSTR * rgNames = NULL;
    ULONG ulNameSize;
    UCHAR ucDefaultChar = '\002';
    UCHAR ucNumericChar = '\001';
    LPPROPERTY_STORE lpPropertyStore = lpIAB->lpPropertyStore;

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if(pt_bIsWABOpenExSession)
    {
        // This is a WABOpenEx session using outlooks storage provider
        if(!lpPropertyStore->hPropertyStore)
            return MAPI_E_NOT_INITIALIZED;

        {
            LPWABSTORAGEPROVIDER lpWSP = (LPWABSTORAGEPROVIDER) lpPropertyStore->hPropertyStore;

            hResult = lpWSP->lpVtbl->GetIDsFromNames( lpWSP,
                                                      cPropNames,
                                                      lppPropNames,
                                                      ulFlags,
                                                      lppPropTags);

            DebugTrace(TEXT("WABStorageProvider::GetIDsFromNames returned:%x\n"),hResult);

            return hResult;
        }
    }

    *lppPropTags = NULL;

    // Call into property store for the table of named props
    if (hResult = GetNamedPropsFromPropStore(lpPropertyStore->hPropertyStore,
      &ulEntryCountOld,
      &lpgnpOld)) {
        DebugTraceResult( TEXT("GetNamedPropsFromPropStore"), hResult);
        goto exit;
    }

    ulEntryCount = ulEntryCountOld;

    if (hResult = ResultFromScode(MAPIAllocateBuffer(sizeof(SPropTagArray) + (cPropNames * sizeof(ULONG)), lppPropTags))) {
        DebugTraceResult( TEXT("GetIDsFromNames allocation of proptag array"), hResult);
        goto exit;
    }
    (*lppPropTags)->cValues = cPropNames;

    // If we're creating new entries, copy the existing array into a new one with space
    // for worst-case expansion.
    if (ulFlags & MAPI_CREATE) {
        if (! (lpgnpNew = LocalAlloc(LPTR, (ulEntryCount + cPropNames) * sizeof(GUID_NAMED_PROPS)))) {
            hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
            goto exit;
        }

        if (ulEntryCount) {
            // Copy the existing array into the new one.  Retain the same GUID pointers.
            CopyMemory(lpgnpNew, lpgnpOld, ulEntryCount * sizeof(GUID_NAMED_PROPS));

            // Now, copy the prop arrays for each GUID
            for (i = 0; i < ulEntryCount; i++) {
                if (! (lpnm = LocalAlloc(LPTR, (cPropNames + lpgnpNew[i].cValues) * sizeof(NAMED_PROP)))) {
                    LocalFreeAndNull(&lpgnpNew);
                    hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                    goto exit;
                }

                // Copy the existing array into the new one.  Retain string pointers.
                CopyMemory(lpnm, lpgnpOld[i].lpnm, lpgnpOld[i].cValues * sizeof(NAMED_PROP));
                lpgnpNew[i].lpnm = lpnm;
            }
        }

        lpgnp = lpgnpNew;   // Use the new one
    } else {
        lpgnp = lpgnpOld;   // Use the old one
    }

    // Allocate an array for ANSI name strings
    if (! (rgNames = LocalAlloc(LPTR, cPropNames * sizeof(LPTSTR)))) {
        DebugTrace(TEXT("GetIDsFromNames couldn't allocate names array\n"));
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    if (! (lpID = LocalAlloc(LPTR, cPropNames * sizeof(LPTSTR *)))) {
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    // For each requested property, look through the prop store values
    for (i = 0; i < cPropNames; i++) {
        if (lppPropNames[i]->ulKind == MNID_ID) {
            // Map the numeric ID into a string name
            if (! (rgNames[i] = LocalAlloc(LPTR, sizeof(TCHAR)*(MAX_DIGITS_ULONG_10 + 2)))) {
                DebugTrace(TEXT("GetIDsFromNames couldn't allocate name buffer\n"));
                hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                goto exit;
            }
            wsprintf(rgNames[i],  TEXT("%c%u"), ucNumericChar, lppPropNames[i]->Kind.lID);
            lpName = rgNames[i];
        } 
        else if (lppPropNames[i]->ulKind == MNID_STRING) 
        {
            ulNameSize = lstrlen(lppPropNames[i]->Kind.lpwstrName)+1;
            if (! ulNameSize) {
                // invalid name
                DebugTrace(TEXT("GetIDsFromNames WideCharToMultiByte -> %u\n"), GetLastError());
                (*lppPropTags)->aulPropTag[i] = PROP_TAG(PT_ERROR, PR_NULL);
                hResult = ResultFromScode(MAPI_W_ERRORS_RETURNED);
                continue;
            }
            if (! (lpID[i] = LocalAlloc(LPTR, ulNameSize*sizeof(TCHAR)))) {
                DebugTrace(TEXT("GetIDsFromNames couldn't allocate name buffer\n"));
                hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                goto exit;
            }
            lstrcpy(lpID[i],lppPropNames[i]->Kind.lpwstrName);
            lpName = lpID[i];
        }

        (*lppPropTags)->aulPropTag[i] = PR_NULL;  // init to NULL
        for (j = 0; j < ulEntryCount; j++) {
            if (! memcmp(lppPropNames[i]->lpguid, lpgnp[j].lpGUID, sizeof(GUID))) {
                for (k = 0; k < lpgnp[j].cValues; k++) {

                    if (! lstrcmpi(lpgnp[j].lpnm[k].lpsz, lpName)) {
                        // found it
                        (*lppPropTags)->aulPropTag[i] = lpgnp[j].lpnm[k].ulPropTag;
                        break;
                    }
                }

                if ((*lppPropTags)->aulPropTag[i] == PR_NULL) {
                    if (ulFlags & MAPI_CREATE) {
                        // Create a new one since it's not there
                        register ULONG cValues = lpgnp[j].cValues;

                        lpgnp[j].lpnm[cValues].lpsz = lpName;
                        lpgnp[j].lpnm[cValues].ulPropTag = GetNewPropTag(lpgnp, ulEntryCount);
                        (*lppPropTags)->aulPropTag[i] = lpgnp[j].lpnm[cValues].ulPropTag;

                        lpgnp[j].cValues++;
                        fChanged = TRUE;
                    } else {
                        // Error
                        (*lppPropTags)->aulPropTag[i] = PROP_TAG(PT_ERROR, PR_NULL);
                        hResult = ResultFromScode(MAPI_W_ERRORS_RETURNED);
                    }
                }
                break;
            }
        }

        if ((*lppPropTags)->aulPropTag[i] == PR_NULL) {
            if (ulFlags & MAPI_CREATE) {
                register ULONG cValues = 0;

                // Must add the new GUID
                lpgnp[ulEntryCount].lpGUID = lppPropNames[i]->lpguid;
                lpgnp[ulEntryCount].cValues = 0;
                // conservative: Allocate room in case we need to put all of the
                // requested prop names in here.
                if (! (lpgnp[ulEntryCount].lpnm = LocalAlloc(LPTR, cPropNames * sizeof(NAMED_PROP)))) {
                    hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                    goto exit;
                }

                // Now, create a new prop
                lpgnp[ulEntryCount].lpnm[cValues].lpsz = lpName;
                lpgnp[ulEntryCount].lpnm[cValues].ulPropTag = GetNewPropTag(lpgnp, ulEntryCount);
                (*lppPropTags)->aulPropTag[i] = lpgnp[ulEntryCount].lpnm[cValues].ulPropTag;

                lpgnp[ulEntryCount].cValues++;
                ulEntryCount++; // new GUID
                fChanged = TRUE;
            } else {
                // Error
                (*lppPropTags)->aulPropTag[i] = PROP_TAG(PT_ERROR, PR_NULL);
                hResult = ResultFromScode(MAPI_W_ERRORS_RETURNED);
            }
        }
    }

    if (ulFlags & MAPI_CREATE && fChanged) {
        // Save the property mappings
        if (hResult = SetNamedPropsToPropStore(lpPropertyStore->hPropertyStore,
          ulEntryCount,
          lpgnp)) {

            DebugTraceResult( TEXT("SetNamedPropToPropStore"), hResult);
        }
    }


exit:
    if (rgNames) {
        for (i = 0; i < cPropNames; i++) {
            LocalFreeAndNull(&(rgNames[i]));
            LocalFreeAndNull(&(lpID[i]));
        }
        LocalFreeAndNull((LPVOID *)&rgNames);
    }

    if(lpID)
        LocalFreeAndNull((LPVOID*)&lpID);

    if (lpgnpOld) {
        FreeGuidnamedprops(ulEntryCountOld, lpgnpOld);
    }

    if (lpgnpNew) { // not so simple, only free the arrays, not the strings, guids
        for (i = 0; i < ulEntryCount; i++) {
            LocalFreeAndNull(&(lpgnpNew[i].lpnm));
        }
        LocalFreeAndNull(&lpgnpNew);
    }

    if (HR_FAILED(hResult)) {
        FreeBufferAndNull(lppPropTags);    // yes, no &
    }

    return(hResult);
}


#ifdef OLD_STUFF

//  Forward reference
HRESULT HrFixupTDN(LPADRLIST lpRecipList);

//---------------------------------------------------------------------------
// Name:		HrPrepareRecips()
//
// Description:	
//				Internal function that does what IAB_PrepareRecips does but
//				also supports a status flag so we know if we called down
//				into a provider and really made some modifications.
//
// Parameters:	
// Returns:	
// Effects:	
// Notes:	
// Revision:	
//---------------------------------------------------------------------------
STDMETHODIMP
HrPrepareRecips(LPIAB lpIAB, ULONG ulFlags, LPSPropTagArray lpPropTagArray,
		LPADRLIST lpRecipList, ULONG * pulPrepRecipStatus)
{
	HRESULT			hr				= hrSuccess;
	SCODE			sc;
	BOOL			fPrepRequired;
	LPLSTPROVDATA 	lpABProvData;
	BOOL			fFixupTDN = FALSE;
    ULONG           iTag;
	
	// Verify that we need to call provider's PrepareRecips
	
	sc = ScVerifyPrepareRecips(lpIAB, ulFlags, lpPropTagArray, lpRecipList,
			&fPrepRequired);
	
	if (FAILED(sc))
	{
		DebugTrace(TEXT("Failure calling ScVerifyPrepareResult sc = %08X\n"), sc);
		hr = ResultFromScode(sc);
		goto exit;
	}
	
	// Recipient properties already prepared, we're out o' here
	
	if (!fPrepRequired)
		goto exit;
	else
	{
		if (pulPrepRecipStatus)
		{
			*pulPrepRecipStatus |= PREPARE_RECIP_MOD_REQUIRED;
		}
	}
	
	//  First handle the one-offs...
	
	hr = INT_PrepareRecips (lpIAB, ulFlags, lpPropTagArray, lpRecipList);
	if (hr)
	{
		//  Log it
		
		DebugTraceResult(IAB_PrepareRecips, hr);
	}

	//  Get the list of logged in ABProviders from the session and
	//  Iterate down the list
	
	for (lpABProvData = lpIAB->pSession->lstAdrProv.lpProvData; lpABProvData;
		lpABProvData=lpABProvData->lstNext)
	{
		//  For each logged in session, have them fix up their entries
		
		hr = ((LPABLOGON)(lpABProvData->lpProviderInfo))->lpVtbl->PrepareRecips(
				(LPABLOGON)(lpABProvData->lpProviderInfo), ulFlags, lpPropTagArray,
				lpRecipList);

#ifdef DEBUG
		if (HR_FAILED(hr))
			DebugTrace(TEXT("Failure in AB Provider <%s> calling PrepareRecips()\n"),
					lpABProvData->lpInitData->lpszDLLName);
#endif
					
		DebugTraceResult(IAB_PrepareRecips, hr);
	}
	
	// mask any provider errors
	
	hr = hrSuccess;

	//
	//  Ok, Check to see if PR_TRANSMITABLE_DISPLAY_NAME_A was asked for
	//  and if so, make sure each recipient has one.
	//

	if (lpPropTagArray)
	{
		for (iTag=0; !fFixupTDN && iTag<lpPropTagArray->cValues; iTag++)
			fFixupTDN =
				(lpPropTagArray->aulPropTag[iTag] == PR_TRANSMITABLE_DISPLAY_NAME_A);

		if (fFixupTDN)
		{
			hr = HrFixupTDN(lpRecipList);
		}
	}

exit:
	
	DebugTraceResult(HrPrepareRecips, hr);
	return hr;
}

//
//  HrFixupTDN - Fixup Transmitable Display Name
//
//  For those entries that do not have PR_TRANSMITABLE_DISPLAY_NAME
//  MAPI will generate it for them.
//

HRESULT
HrFixupTDN(LPADRLIST lpRecipList)
{
	HRESULT hResult = hrSuccess;
	SCODE sc = S_OK;
	ULONG iRecip;
	LPSPropValue lpspvTDN = NULL;
	LPSPropValue lpspvDN = NULL;

	for (iRecip = 0; iRecip < lpRecipList->cEntries; iRecip++)
	{
		LPSPropValue lpspvUser = lpRecipList->aEntries[iRecip].rgPropVals;
		ULONG cValues = lpRecipList->aEntries[iRecip].cValues;
		
		//$  This is where we default the value of PR_TRANSMITABLE_DISPLAY_NAME
		//$  if was asked for.
		//
		//
		lpspvTDN = PpropFindProp(lpspvUser,
				cValues,
				PROP_TAG(PT_ERROR, PROP_ID(PR_TRANSMITABLE_DISPLAY_NAME_A)));
		lpspvDN = PpropFindProp(lpspvUser, cValues, PR_DISPLAY_NAME_A);
		if (lpspvTDN && lpspvDN)
		{
			LPSTR lpszDN;
			LPSTR lpszTDN;
			
			lpszDN = lpspvDN->Value.lpszA;

			//
			//  Check to see if the DN is already in the form 'name'.
			//
			if (*lpszDN == '\'' &&
				*(lpszDN+lstrlen(lpszDN)-1) == '\'')
			{
				//
				//  Simply point lpspvT to lpspvDN
				//
				lpspvTDN->ulPropTag = PR_TRANSMITABLE_DISPLAY_NAME_A;
				lpspvTDN->Value.lpszA = lpszDN;
			} else
			{
				//
				//  We tic it ourselves and set it back in...
				//
				sc = MAPIAllocateMore(sizeof(TCHAR)*(lstrlen(lpszDN)+3), lpspvUser, &lpszTDN);
				if (sc)
				{
					DebugTrace(TEXT("HrFixupTDN out of memory\n"));
					hResult = ResultFromScode(sc);

					goto error;
				}
				*lpszTDN = '\'';
				lstrcpy(&(lpszTDN[1]), lpszDN);
				lstrcat(lpszTDN,  TEXT("\'"));
				lpspvTDN->ulPropTag = PR_TRANSMITABLE_DISPLAY_NAME_A;
				lpspvTDN->Value.lpszA = lpszTDN;
			}
		}
	}

error:

	DebugTraceResult(HrFixupTDN, hResult);
	return hResult;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\hotsync.h ===
// HotSync.h
//
//  Definitions for WAB <-> HotMail synchronization
//

#ifndef __hotsync_h__
#define __hotsync_h__

#include "imnxport.h"
#include <wab.h>
#include "ui_cflct.h"

#define CBIHTTPCALLBACK sizeof(IHTTPCALLBACK)

#define WAB_IHTTPCALLBACK_METHODS(IPURE)                                \
        MAPIMETHOD(OnTimeout)(                                          \
            THIS_                                                       \
            /* [out][in] */ DWORD FAR *pdwTimeout,                      \
            /* [in] */ IInternetTransport FAR *pTransport) IPURE;       \
        MAPIMETHOD(OnLogonPrompt)(                                      \
            THIS_                                                       \
            /* [out][in] */ LPINETSERVER pInetServer,                   \
            /* [in] */ IInternetTransport FAR *pTransport) IPURE;       \
        MAPIMETHOD(OnPrompt)(                                           \
            THIS_                                                       \
            /* [in] */ HRESULT hrError,                                 \
            /* [in] */ LPCTSTR pszText,                                 \
            /* [in] */ LPCTSTR pszCaption,                              \
            /* [in] */ UINT uType,                                      \
            /* [in] */ IInternetTransport FAR *pTransport) IPURE;       \
        MAPIMETHOD(OnStatus)(                                           \
            THIS_                                                       \
            /* [in] */ IXPSTATUS ixpstatus,                             \
            /* [in] */ IInternetTransport FAR *pTransport) IPURE;       \
        MAPIMETHOD(OnError)(                                            \
            THIS_                                                       \
            /* [in] */ IXPSTATUS ixpstatus,                             \
            /* [in] */ LPIXPRESULT pResult,                             \
            /* [in] */ IInternetTransport FAR *pTransport) IPURE;       \
        MAPIMETHOD(OnCommand)(                                          \
            THIS_                                                       \
            /* [in] */ CMDTYPE cmdtype,                                 \
            /* [in] */ LPSTR pszLine,                                   \
            /* [in] */ HRESULT hrResponse,                              \
            /* [in] */ IInternetTransport FAR *pTransport) IPURE;       \
        MAPIMETHOD(OnResponse)(                                         \
            THIS_                                                       \
            /* [in] */ LPHTTPMAILRESPONSE pResponse) IPURE;             \



#undef           INTERFACE
#define          INTERFACE      IHTTPCallback
DECLARE_MAPI_INTERFACE_(IHTTPCallback, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        WAB_IHTTPCALLBACK_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IHTTPCallback, LPHTTPCALLBACK);


#undef  INTERFACE
#define INTERFACE       struct _IHTTPCALLBACK

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IHTTPCALLBACK_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IHTTPCALLBACK_)
                MAPI_IUNKNOWN_METHODS(IMPL)
                WAB_IHTTPCALLBACK_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IHTTPCALLBACK_)
                MAPI_IUNKNOWN_METHODS(IMPL)
                WAB_IHTTPCALLBACK_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IHTTPCALLBACK_)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(IMPL)
        WAB_IHTTPCALLBACK_METHODS(IMPL)
};


typedef struct tagSyncOp HOTSYNCOP, *LPHOTSYNCOP;   // forward declaration

enum tagSYNCHSTATE
{	SYNC_STATE_INITIALIZING	= 0,
	SYNC_STATE_SERVER_CONTACT_DISCOVERY	= SYNC_STATE_INITIALIZING + 1,
	SYNC_STATE_PROCESS_OPS	            = SYNC_STATE_SERVER_CONTACT_DISCOVERY + 1,
    SYNC_STATE_PROCESS_CONFLICTS        = SYNC_STATE_PROCESS_OPS + 1,
    SYNC_STATE_PROCESS_MERGED_CONFLICTS = SYNC_STATE_PROCESS_CONFLICTS + 1,
	SYNC_STATE_DONE	                    = SYNC_STATE_PROCESS_MERGED_CONFLICTS + 1
}	SYNCSTATE;

enum tagOPSTATE
{	OP_STATE_INITIALIZING	= 0,
    OP_STATE_SERVER_GET     = OP_STATE_INITIALIZING + 1,
    OP_STATE_LOADED         = OP_STATE_SERVER_GET + 1,
    OP_STATE_MERGED         = OP_STATE_LOADED + 1, 
    OP_STATE_SERVER_PUT     = OP_STATE_MERGED + 1,
    OP_STATE_DONE           = OP_STATE_SERVER_PUT + 1
}   OPSTATE;

typedef int (__cdecl*FnCompareFunc)(const void*lpvA, const void *lpvB);

typedef struct tagVector
{
    DWORD       m_cItems;
    DWORD       m_cSpaces;
    DWORD       m_dwGrowBy;
    LPVOID     *m_pItems;      
} VECTOR, *LPVECTOR;

HRESULT     Vector_Create(LPVECTOR *ppVector);
void        Vector_Delete(LPVECTOR pVector);
DWORD       Vector_GetLength(LPVECTOR pVector);
HRESULT     Vector_AddItem(LPVECTOR pVector, LPVOID lpvItem);
void        Vector_Remove(LPVECTOR pVector, LPVOID lpvItem);
void        Vector_RemoveItem(LPVECTOR pVector, DWORD    dwIndex);
LPVOID      Vector_GetItem(LPVECTOR pVector, DWORD   dwIndex);    
void        Vector_Sort(LPVECTOR pVector, FnCompareFunc lpfnCompare);    


HRESULT CopyMultiValueString(
                             SWStringArray *pInArray,
                             SLPSTRArray **ppOutArray);
HRESULT FreeMultiValueString(SLPSTRArray *pInArray);
HRESULT SetMultiValueStringValue(SLPSTRArray *pInArray, LPSTR szStr, DWORD dwIndex);
HRESULT AppendToMultiValueString(SLPSTRArray *pInArray, LPSTR szStr);

typedef struct tagWabSync
{
    IHTTPMailCallbackVtbl FAR *vtbl;
    LONG                    m_cRef;         // Reference Counting
    DWORD                   m_state;  
    HWND                    m_hWnd;
    HWND                    m_hParentWnd;
    IAddrBook              *m_pAB;
    IHTTPMailTransport     *m_pTransport;
    IXPSTATUS               m_ixpStatus;
    INETSERVER              m_rInetServerInfo;
    BOOL                    m_fAborted;
    BOOL                    m_fSkipped;
#ifdef HM_GROUP_SYNCING
    BOOL                    m_fSyncGroups;
#endif
    DWORD                   m_cTotalOps;
    LPVECTOR                m_pOps;
    LPVECTOR                m_pWabItems;
    char                    m_szLoginName[256];
    DWORD                   m_cAborts;
    DWORD                   m_dwServerID;
    FILETIME                m_ftLastSync;
    LPSTR                   m_pszRootUrl;
    LPSTR                   m_pszAccountId;
} WABSYNC, *LPWABSYNC;

typedef HRESULT (*FnHandleResponse)(LPHOTSYNCOP pSyncOp, LPHTTPMAILRESPONSE pResponse);
typedef HRESULT (*FnBeginOp)(LPHOTSYNCOP pSyncOp);

typedef struct 
{
    LPSTR           pszHotmailHref;
    LPSTR           pszHotmailId;
    LPSTR           pszModHotmail;
    SLPSTRArray    *pszaContactIds;
    SLPSTRArray    *pszaServerIds;
    SLPSTRArray    *pszaModtimes;
    SLPSTRArray    *pszaEmails;
    DWORD           dwEmailIndex;
    LPENTRYID       lpEID;
    ULONG           cbEID;
    FILETIME        ftModWab;
#ifdef HM_GROUP_SYNCING
    ULONG           ulContactType;
#endif
    BOOL            fDelete;
} WABCONTACTINFO, *LPWABCONTACTINFO;

void    WABContact_Delete(LPWABCONTACTINFO pContact);

struct tagSyncOp
{
    BYTE                    m_bOpType;
    BYTE                    m_bState;
    DWORD                   m_dwRetries;
    BOOL                    m_fPartialSkip;
    IHTTPMailCallback      *m_pHotSync;
    IHTTPMailTransport     *m_pTransport;
    FnHandleResponse        m_pfnHandleResponse;
    FnBeginOp               m_pfnBegin;
    LPWABCONTACTINFO        m_pContactInfo;
    LPHTTPCONTACTINFO       m_pServerContact;
    LPHTTPCONTACTINFO       m_pClientContact;
};


#ifdef HM_GROUP_SYNCING
HRESULT  HrSynchronize(HWND hWnd, LPADRBOOK lpIAB, LPCTSTR pszAccountID, BOOL bSyncGroups);
#else
HRESULT  HrSynchronize(HWND hWnd, LPADRBOOK lpIAB, LPCTSTR pszAccountID);
#endif

HRESULT     WABSync_Create(LPWABSYNC *ppWabSync);
void        WABSync_Delete(LPWABSYNC pWabSync);
    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
STDMETHODIMP WABSync_QueryInterface(IHTTPMailCallback __RPC_FAR * This, REFIID riid, LPVOID *ppv);
STDMETHODIMP_(ULONG) WABSync_AddRef(IHTTPMailCallback __RPC_FAR * This);
STDMETHODIMP_(ULONG) WABSync_Release(IHTTPMailCallback __RPC_FAR * This);

    //----------------------------------------------------------------------
    // IHTTPMailCallback Members
    //----------------------------------------------------------------------
STDMETHODIMP WABSync_OnTimeout (IHTTPMailCallback __RPC_FAR * This, DWORD *pdwTimeout, IInternetTransport *pTransport);
STDMETHODIMP WABSync_OnLogonPrompt (IHTTPMailCallback __RPC_FAR * This, LPINETSERVER pInetServer, IInternetTransport *pTransport);
STDMETHODIMP_(INT) WABSync_OnPrompt (IHTTPMailCallback __RPC_FAR * This, HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, IInternetTransport *pTransport);
STDMETHODIMP WABSync_OnStatus (IHTTPMailCallback __RPC_FAR * This, IXPSTATUS ixpstatus, IInternetTransport *pTransport);
STDMETHODIMP WABSync_OnError (IHTTPMailCallback __RPC_FAR * This, IXPSTATUS ixpstatus, LPIXPRESULT pResult, IInternetTransport *pTransport);
STDMETHODIMP WABSync_OnCommand (IHTTPMailCallback __RPC_FAR * This, CMDTYPE cmdtype, LPSTR pszLine, HRESULT hrResponse, IInternetTransport *pTransport);
STDMETHODIMP WABSync_OnResponse (IHTTPMailCallback __RPC_FAR * This, LPHTTPMAILRESPONSE pResponse);
STDMETHODIMP WABSync_GetParentWindow (IHTTPMailCallback __RPC_FAR *This, HWND *pHwndParent);

    //----------------------------------------------------------------------
    // Public Members
    //----------------------------------------------------------------------
#ifdef HM_GROUP_SYNCING
STDMETHODIMP WABSync_Initialize(LPWABSYNC pWabSync, HWND hWnd, IAddrBook *pAB, LPCTSTR pszAccountID, BOOL bSyncGroups);
#else
STDMETHODIMP WABSync_Initialize(LPWABSYNC pWabSync, HWND hWnd, IAddrBook *pAB, LPCTSTR pszAccountID);
#endif
STDMETHODIMP WABSync_BeginSynchronize(LPWABSYNC pWabSync);
STDMETHODIMP WABSync_Abort(LPWABSYNC pWabSync, HRESULT hr);
STDMETHODIMP WABSync_OperationCompleted(LPWABSYNC pWabSync, LPHOTSYNCOP pOp);

    //----------------------------------------------------------------------
    // Private Members
    //----------------------------------------------------------------------
STDMETHODIMP WABSync_FinishSynchronize(LPWABSYNC pWabSync, HRESULT hr);
STDMETHODIMP WABSync_RequestServerIDList(LPWABSYNC pWabSync);
STDMETHODIMP WABSync_RequestContactsRootProperty(LPWABSYNC pWabSync);
STDMETHODIMP WABSync_HandleContactsRootResponse(LPWABSYNC pWabSync, LPHTTPMAILRESPONSE pResponse);
STDMETHODIMP WABSync_HandleIDListResponse(LPWABSYNC pWabSync, LPHTTPMAILRESPONSE pResponse);
STDMETHODIMP_ (void) WABSync_NextState(LPWABSYNC pWabSync);
STDMETHODIMP_ (BOOL) WABSync_NextOp(LPWABSYNC pWabSync, BOOL fPopFirst);
STDMETHODIMP WABSync_BuildWabContactList(LPWABSYNC pWabSync);
STDMETHODIMP WABSync_LoadLastModInfo(LPWABSYNC pWabSync);
STDMETHODIMP WABSync_SaveCurrentModInfo(LPWABSYNC pWabSync);
STDMETHODIMP_ (void) WABSync_FreeItems(LPWABSYNC pWabSync);
STDMETHODIMP_ (void) WABSync_FreeOps(LPWABSYNC pWabSync);
STDMETHODIMP WABSync_FindContactByServerId(LPWABSYNC pWabSync, LPSTR pszServerId, LPWABCONTACTINFO *ppContact, DWORD *pdwIndex);
STDMETHODIMP WABSync_DoConflicts(LPWABSYNC pWabSync);
STDMETHODIMP WABSync_AbortOp(LPWABSYNC pWabSync, HRESULT hr);
STDMETHODIMP_ (void) WABSync_Progress(LPWABSYNC pWabSync, DWORD dwResId, DWORD dwCount);
STDMETHODIMP_ (void) WABSync_MergeAddsToConflicts(LPWABSYNC pWabSync);

enum tagSYNCOPTYPE
{	SYNCOP_SERVER_INVALID	= 0,
	SYNCOP_SERVER_DELETE,
	SYNCOP_CLIENT_DELETE,
    SYNCOP_SERVER_ADD,
	SYNCOP_SERVER_CHANGE,
	SYNCOP_CLIENT_ADD,
	SYNCOP_CLIENT_CHANGE,
	SYNCOP_CONFLICT
}	SYNCOPTYPE;



LPHOTSYNCOP Syncop_CreateServerAdd(LPWABCONTACTINFO pContactInfo);
HRESULT     Syncop_ServerAddResponse(LPHOTSYNCOP pSyncOp, LPHTTPMAILRESPONSE pResponse);
HRESULT     Syncop_ServerAddBegin(LPHOTSYNCOP pSyncOp);

LPHOTSYNCOP Syncop_CreateServerDelete(LPWABCONTACTINFO pContactInfo);
HRESULT     Syncop_ServerDeleteResponse(LPHOTSYNCOP pSyncOp, LPHTTPMAILRESPONSE pResponse);
HRESULT     Syncop_ServerDeleteBegin(LPHOTSYNCOP pSyncOp);

LPHOTSYNCOP Syncop_CreateServerChange(LPWABCONTACTINFO pContactInfo);
HRESULT     Syncop_ServerChangeResponse(LPHOTSYNCOP pSyncOp, LPHTTPMAILRESPONSE pResponse);
HRESULT     Syncop_ServerChangeBegin(LPHOTSYNCOP pSyncOp);

LPHOTSYNCOP Syncop_CreateClientAdd(LPWABCONTACTINFO pContactInfo);
HRESULT     Syncop_ClientAddResponse(LPHOTSYNCOP pSyncOp, LPHTTPMAILRESPONSE pResponse);
HRESULT     Syncop_ClientAddBegin(LPHOTSYNCOP pSyncOp);

LPHOTSYNCOP Syncop_CreateClientDelete(LPWABCONTACTINFO pContactInfo);
HRESULT     Syncop_ClientDeleteResponse(LPHOTSYNCOP pSyncOp, LPHTTPMAILRESPONSE pResponse);
HRESULT     Syncop_ClientDeleteBegin(LPHOTSYNCOP pSyncOp);

LPHOTSYNCOP Syncop_CreateClientChange(LPWABCONTACTINFO pContactInfo);
HRESULT     Syncop_ClientChangeResponse(LPHOTSYNCOP pSyncOp, LPHTTPMAILRESPONSE pResponse);
HRESULT     Syncop_ClientChangeBegin(LPHOTSYNCOP pSyncOp);

LPHOTSYNCOP Syncop_CreateConflict(LPWABCONTACTINFO pContactInfo);
HRESULT     Syncop_ConflictResponse(LPHOTSYNCOP pSyncOp, LPHTTPMAILRESPONSE pResponse);
HRESULT     Syncop_ConflictBegin(LPHOTSYNCOP pSyncOp);



HRESULT     Syncop_Init(LPHOTSYNCOP pSyncOp, IHTTPMailCallback *pHotSync, IHTTPMailTransport     *pTransport);
HRESULT     Syncop_Delete(LPHOTSYNCOP pSyncOp);
HRESULT     Syncop_HandleResponse(LPHOTSYNCOP pSyncOp, LPHTTPMAILRESPONSE pResponse);
HRESULT     Syncop_Begin(LPHOTSYNCOP pSyncOp);
HRESULT     Syncop_Abort(LPHOTSYNCOP pSyncOp);
void        Syncop_SetServerContactInfo(LPHOTSYNCOP pSyncOp, LPWABCONTACTINFO pWabContactInfo, LPHTTPCONTACTINFO pContactInfo);

void        ContactInfo_Free(LPHTTPCONTACTINFO pContactInfo);
void        ContactInfo_Clear(LPHTTPCONTACTINFO pContactInfo);
HRESULT     ContactInfo_SaveToWAB(LPWABSYNC pWabSync, LPHTTPCONTACTINFO pContactInfo, LPWABCONTACTINFO  pWabContact, LPENTRYID   lpEntryID, ULONG cbEntryID, BOOL  fDeleteProps);
HRESULT     ContactInfo_LoadFromWAB(LPWABSYNC pWabSync, LPHTTPCONTACTINFO pContactInfo, LPWABCONTACTINFO  pWabContact, LPENTRYID   lpEntryID, ULONG cbEntryID);
HRESULT     ContactInfo_GenerateNickname(LPHTTPCONTACTINFO pContactInfo);
BOOL        ContactInfo_Match(LPHTTPCONTACTINFO pci1, LPHTTPCONTACTINFO pci2);
HRESULT     ContactInfo_PreparePatch(LPHTTPCONTACTINFO pciFrom, LPHTTPCONTACTINFO pciTo);
HRESULT     ContactInfo_EmptyNullItems(LPHTTPCONTACTINFO pci);
HRESULT     ContactInfo_BlendResults(LPHTTPCONTACTINFO pciServer, LPHTTPCONTACTINFO pciClient, CONFLICT_DECISION *prgDecisions);
HRESULT     ContactInfo_BlendNewContact(LPWABSYNC pWabSync, LPHTTPCONTACTINFO pContactInfo);

void        UpdateSynchronizeMenus(HMENU hMenu, LPIAB lpIAB);
DWORD       CountHTTPMailAccounts(LPIAB lpIAB);

INT_PTR CALLBACK SyncProgressDlgProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);



#endif __hotsync_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\idrgdrp.c ===
/*******************************************************************************
*
*
*
*   idrgdrp.c - Drag and Drop code for dropping vCards in and out of the WAB
*           Several Formats are droppable into other apps:
*           Within the WAB, we drop entryids
*           Within different WABs we drop flat buffers containing full Property
*               arrays (but Named Propery data is lost in the process)(sometimes)
*           We provide data as vCard files that can be dropped into anything asking
*               for CF_HDROP
*           We also create a text buffer and drop that into CF_TEXT requesters
*               The text buffers only hold the same data as the tooltip ..
*
*   created 5/97 - vikramm
*
*   (c) Microsoft Corp, 1997
*
********************************************************************************/
#include <_apipch.h>

const TCHAR szVCardExt[] = TEXT(".vcf");
//
//  IWABDocHost jump tables is defined here...
//

IWAB_DRAGDROP_Vtbl vtblIWAB_DRAGDROP = {
    VTABLE_FILL
    IWAB_DRAGDROP_QueryInterface,
    IWAB_DRAGDROP_AddRef,
    IWAB_DRAGDROP_Release,
};

IWAB_DROPTARGET_Vtbl vtblIWAB_DROPTARGET = {
    VTABLE_FILL
    (IWAB_DROPTARGET_QueryInterface_METHOD *)	IWAB_DRAGDROP_QueryInterface,
    (IWAB_DROPTARGET_AddRef_METHOD *)			IWAB_DRAGDROP_AddRef,
    (IWAB_DROPTARGET_Release_METHOD *)			IWAB_DRAGDROP_Release,
	IWAB_DROPTARGET_DragEnter,
	IWAB_DROPTARGET_DragOver,
	IWAB_DROPTARGET_DragLeave,
	IWAB_DROPTARGET_Drop
};


IWAB_DROPSOURCE_Vtbl vtblIWAB_DROPSOURCE = {
    VTABLE_FILL
    (IWAB_DROPSOURCE_QueryInterface_METHOD *)	IWAB_DRAGDROP_QueryInterface,
    (IWAB_DROPSOURCE_AddRef_METHOD *)			IWAB_DRAGDROP_AddRef,
    (IWAB_DROPSOURCE_Release_METHOD *)			IWAB_DRAGDROP_Release,
	IWAB_DROPSOURCE_QueryContinueDrag,
	IWAB_DROPSOURCE_GiveFeedback,
};


IWAB_DATAOBJECT_Vtbl vtblIWAB_DATAOBJECT = {
    VTABLE_FILL
    IWAB_DATAOBJECT_QueryInterface,
    IWAB_DATAOBJECT_AddRef,
    IWAB_DATAOBJECT_Release,
    IWAB_DATAOBJECT_GetData,
    IWAB_DATAOBJECT_GetDataHere,
    IWAB_DATAOBJECT_QueryGetData,
    IWAB_DATAOBJECT_GetCanonicalFormatEtc,
    IWAB_DATAOBJECT_SetData,
    IWAB_DATAOBJECT_EnumFormatEtc,
    IWAB_DATAOBJECT_DAdvise,
    IWAB_DATAOBJECT_DUnadvise,
    IWAB_DATAOBJECT_EnumDAdvise
};


IWAB_ENUMFORMATETC_Vtbl vtblIWAB_ENUMFORMATETC = {
    VTABLE_FILL
    IWAB_ENUMFORMATETC_QueryInterface,
    IWAB_ENUMFORMATETC_AddRef,
    IWAB_ENUMFORMATETC_Release,
    IWAB_ENUMFORMATETC_Next,
    IWAB_ENUMFORMATETC_Skip,
    IWAB_ENUMFORMATETC_Reset,
    IWAB_ENUMFORMATETC_Clone,
};


extern void GetCurrentSelectionEID(LPBWI lpbwi, HWND hWndTV, LPSBinary * lppsbEID, ULONG * lpulObjectType, BOOL bTopMost);
extern void LocalFreeSBinary(LPSBinary lpsb);
extern BOOL bIsGroupSelected(HWND hWndLV, LPSBinary lpsbEID);
extern void UpdateLV(LPBWI lpbwi);

//registered clipboard formats
CLIPFORMAT g_cfWABFlatBuffer = 0;
const TCHAR c_szWABFlatBuffer[] =  TEXT("WABFlatBuffer");
CLIPFORMAT g_cfWABEntryIDList = 0;
const TCHAR c_szWABEntryIDList[] =  TEXT("WABEntryIDList");


///////////////////////////////////////////////////////////////////////////////
//  Helper functions to keep track of and delete *.vcf files in temp directory,
//  created by drag/drop
//
typedef struct _tagVFileList
{
    LPTSTR                  lptszFilename;
    struct _tagVFileList *  pNext;
} VFILENAMELIST, *PVFILENAMELIST;
static VFILENAMELIST * s_pFileNameList = NULL;
static BOOL bAddToNameList(LPTSTR lptszFilename);
static void DeleteFilesInList();


//$$//////////////////////////////////////////////////////////////////////////
//
// Creates a New IWABDocHost Object
//
//////////////////////////////////////////////////////////////////////////////
HRESULT HrCreateIWABDragDrop(LPIWABDRAGDROP * lppIWABDragDrop)
{

    LPIWABDRAGDROP	lpIWABDragDrop = NULL;
    SCODE 		     sc;
    HRESULT 	     hr     	   = hrSuccess;

    //
    //  Allocate space for the IAB structure
    //
    if (FAILED(sc = MAPIAllocateBuffer(sizeof(IWABDRAGDROP), (LPVOID *) &lpIWABDragDrop))) {
        hr = ResultFromScode(sc);
        goto err;
    }

    MAPISetBufferName(lpIWABDragDrop,  TEXT("WAB Drag Drop Data Object"));

    ZeroMemory(lpIWABDragDrop, sizeof(IWABDRAGDROP));

    lpIWABDragDrop->lpVtbl = &vtblIWAB_DRAGDROP;

	lpIWABDragDrop->lpIWDD = lpIWABDragDrop;


    sc = MAPIAllocateMore(sizeof(IWABDROPTARGET), lpIWABDragDrop,  &(lpIWABDragDrop->lpIWABDropTarget));
    if(sc)
        goto err;
    ZeroMemory(lpIWABDragDrop->lpIWABDropTarget, sizeof(IWABDROPTARGET));
    lpIWABDragDrop->lpIWABDropTarget->lpVtbl = &vtblIWAB_DROPTARGET;
    lpIWABDragDrop->lpIWABDropTarget->lpIWDD = lpIWABDragDrop;


    sc = MAPIAllocateMore(sizeof(IWABDROPSOURCE), lpIWABDragDrop,  &(lpIWABDragDrop->lpIWABDropSource));
    if(sc)
        goto err;
    ZeroMemory(lpIWABDragDrop->lpIWABDropSource, sizeof(IWABDROPSOURCE));
    lpIWABDragDrop->lpIWABDropSource->lpVtbl = &vtblIWAB_DROPSOURCE;
    lpIWABDragDrop->lpIWABDropSource->lpIWDD = lpIWABDragDrop;

	lpIWABDragDrop->lpVtbl->AddRef(lpIWABDragDrop);

    *lppIWABDragDrop = lpIWABDragDrop;

    if(g_cfWABFlatBuffer == 0)
    {
        g_cfWABFlatBuffer = (CLIPFORMAT) RegisterClipboardFormat(c_szWABFlatBuffer);
        g_cfWABEntryIDList = (CLIPFORMAT) RegisterClipboardFormat(c_szWABEntryIDList);
    }
    
    /*
	if (g_cfFileContents == 0)
    {
	    g_cfFileContents = RegisterClipboardFormat(c_szFileContents);
	    g_cfFileGroupDescriptor = RegisterClipboardFormat(c_szFileGroupDescriptor);
    }
*/
err:
	return hr;
}


//$$//////////////////////////////////////////////////////////////////////////
//
// Release the IWABDragDrop object
//
//////////////////////////////////////////////////////////////////////////////
void ReleaseWABDragDrop(LPIWABDRAGDROP lpIWABDragDrop)
{

	MAPIFreeBuffer(lpIWABDragDrop);

    // WAB is closing down.  Delete any *.vcf files left in temp directory
    DeleteFilesInList();
}


BOOL bCheckFileType(LPIWABDROPTARGET lpIWABDropTarget, LPDATAOBJECT pDataObj, DWORD * pdwEffect)
{
#ifndef WIN16
    FORMATETC       fmte    = {lpIWABDropTarget->lpIWDD->m_cfAccept, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
#else
    FORMATETC       fmte;
#endif
    STGMEDIUM       medium;
	BOOL			bRet = FALSE;

#ifdef WIN16 // Set fmte member value.
    fmte.cfFormat = lpIWABDropTarget->lpIWDD->m_cfAccept;
    fmte.ptd      = NULL;
    fmte.dwAspect = DVASPECT_CONTENT;
    fmte.lindex   = -1;
    fmte.tymed    = TYMED_HGLOBAL;
#endif

    *pdwEffect = lpIWABDropTarget->lpIWDD->m_dwEffect;

    if (pDataObj && 
        SUCCEEDED(pDataObj->lpVtbl->GetData(pDataObj, &fmte, &medium)))
    {

        HDROP hDrop=(HDROP)GlobalLock(medium.hGlobal);

		// Enumerate the files and check them
        if(hDrop)
		{
			TCHAR    szFile[MAX_PATH];
			UINT    cFiles;
			UINT    iFile;
    
			// Let's work through the files given to us
			cFiles = DragQueryFile(hDrop, (UINT) -1, NULL, 0);
			
			for (iFile = 0; iFile < cFiles; ++iFile)
			{
				DragQueryFile(hDrop, iFile, szFile, MAX_PATH);
				// As long as any file is a vCard we can use it
				if(SubstringSearch(szFile, (LPTSTR) szVCardExt))
				{
					bRet = TRUE;
					break;
				}
			}
		}

        GlobalUnlock(medium.hGlobal);
    }

    if (medium.pUnkForRelease)
        medium.pUnkForRelease->lpVtbl->Release(medium.pUnkForRelease);
    else
        GlobalFree(medium.hGlobal);

    return bRet;
}


/**
*
* The Interface methods
*
*
***/

STDMETHODIMP_(ULONG)
IWAB_DRAGDROP_AddRef(LPIWABDRAGDROP lpIWABDragDrop)
{
    return(++(lpIWABDragDrop->lcInit));
}

STDMETHODIMP_(ULONG)
IWAB_DRAGDROP_Release(LPIWABDRAGDROP lpIWABDragDrop)
{
    if(--(lpIWABDragDrop->lcInit)==0 &&
		lpIWABDragDrop == lpIWABDragDrop->lpIWDD)
	{
       ReleaseWABDragDrop(lpIWABDragDrop);
       return 0;
    }

    return(lpIWABDragDrop->lcInit);
}


STDMETHODIMP
IWAB_DRAGDROP_QueryInterface(LPIWABDRAGDROP lpIWABDragDrop,
                          REFIID lpiid,
                          LPVOID * lppNewObj)
{
    LPVOID lp = NULL;

    if(!lppNewObj)
        return MAPI_E_INVALID_PARAMETER;

    *lppNewObj = NULL;

    if(IsEqualIID(lpiid, &IID_IUnknown))
        lp = (LPVOID) lpIWABDragDrop;

    if(IsEqualIID(lpiid, &IID_IDropTarget))
    {
        DebugTrace(TEXT("WABDropTarget:QI - IDropTarget\n"));
        lp = (LPVOID) (LPDROPTARGET) lpIWABDragDrop->lpIWDD->lpIWABDropTarget;
    }

    if(IsEqualIID(lpiid, &IID_IDropSource))
    {
        DebugTrace(TEXT("WABDropSource:QI - IDropSource\n"));
        lp = (LPVOID) (LPDROPSOURCE) lpIWABDragDrop->lpIWDD->lpIWABDropSource;
    }

    if(!lp)
    {
        return E_NOINTERFACE;
    }

    ((LPIWABDRAGDROP) lp)->lpVtbl->AddRef((LPIWABDRAGDROP) lp);

    *lppNewObj = lp;

    return S_OK;

}



STDMETHODIMP
IWAB_DROPTARGET_DragEnter(	LPIWABDROPTARGET lpIWABDropTarget,
						IDataObject * pDataObj,					
						DWORD grfKeyState,							
						POINTL pt,									
						DWORD * pdwEffect)
{
    LPENUMFORMATETC penum = NULL;
    HRESULT         hr;    
    FORMATETC       fmt;
    ULONG           ulCount = 0;
    LPBWI           lpbwi = (LPBWI) lpIWABDropTarget->lpIWDD->m_lpv;

    if(!pdwEffect || !pDataObj)
        return E_INVALIDARG;

	*pdwEffect = DROPEFFECT_NONE;

    if(lpIWABDropTarget->lpIWDD->m_bSource)
    {
        // if this is true thent he drag started in the ListView
        // if we are currently over the treeview, then we can say ok ...
        // otherwise we have to say no
        POINT pt1;
        pt1.x = pt.x;
        pt1.y = pt.y;
        if(bwi_hWndTV == WindowFromPoint(pt1))
        {
            *pdwEffect = DROPEFFECT_COPY;
            lpIWABDropTarget->lpIWDD->m_bOverTV = TRUE;
            lpIWABDropTarget->lpIWDD->m_cfAccept = g_cfWABEntryIDList;
        }
    }
    else
    {
        lpIWABDropTarget->lpIWDD->m_dwEffect = DROPEFFECT_NONE;
	    lpIWABDropTarget->lpIWDD->m_cfAccept = 0;

        // lets get the enumerator from the IDataObject, and see if the format we take is
        // available
        hr = pDataObj->lpVtbl->EnumFormatEtc(pDataObj, DATADIR_GET, &penum);

        if(SUCCEEDED(hr) && penum)
        {
            hr = penum->lpVtbl->Reset(penum);

            while(SUCCEEDED(hr=penum->lpVtbl->Next(penum, 1, &fmt, &ulCount)) && ulCount)
            {
                if( fmt.cfFormat==CF_HDROP || fmt.cfFormat==g_cfWABFlatBuffer)
                {
                    lpIWABDropTarget->lpIWDD->m_cfAccept=fmt.cfFormat;
                    break;
                }
            }
        }        
    
        if(penum)
		    penum->lpVtbl->Release(penum);

	    if( (lpIWABDropTarget->lpIWDD->m_cfAccept == CF_HDROP &&
             bCheckFileType(lpIWABDropTarget, pDataObj, pdwEffect))
          || lpIWABDropTarget->lpIWDD->m_cfAccept == g_cfWABFlatBuffer)
	    {
		    //if(grfKeyState & MK_CONTROL)
		    //{
			    *pdwEffect = DROPEFFECT_COPY;
		    //	lpIWABDropTarget->lpIWDD->m_bIsCopyOperation = TRUE;
		    //}
		    //else
		    //	*pdwEffect = DROPEFFECT_MOVE;
        }
    }

    if(*pdwEffect != DROPEFFECT_NONE)
    {
		lpIWABDropTarget->lpIWDD->m_pIDataObject = pDataObj;
		pDataObj->lpVtbl->AddRef(pDataObj);
	}

	return NOERROR;
}


//
//  FUNCTION:   ::UpdateDragDropHilite()
//
//  PURPOSE:    Called by the various IDropTarget interfaces to move the drop
//              selection to the correct place in our listview.
//
//  PARAMETERS:
//      <in> *ppt - Contains the point that the mouse is currently at.  If this
//                  is NULL, then the function removes any previous UI.
//
HTREEITEM UpdateDragDropHilite(LPBWI lpbwi, POINTL *ppt, ULONG * lpulObjType)
{
    TV_HITTESTINFO tvhti;
    HTREEITEM htiTarget = NULL;

    // If a position was provided
    if (ppt)
    {
        // Figure out which item is selected
        tvhti.pt.x = ppt->x;
        tvhti.pt.y = ppt->y;
        ScreenToClient(bwi_hWndTV, &tvhti.pt);        
        htiTarget = TreeView_HitTest(bwi_hWndTV, &tvhti);

        // Only if the cursor is over something do we relock the window.
        if (htiTarget)
            TreeView_SelectDropTarget(bwi_hWndTV, htiTarget);

        if(lpulObjType)
        {
            // Determine the object type if requested
            TV_ITEM tvI = {0};
            tvI.mask = TVIF_PARAM;
            tvI.hItem = htiTarget;
            if(TreeView_GetItem(bwi_hWndTV, &tvI) && tvI.lParam)
                *lpulObjType = ((LPTVITEM_STUFF)tvI.lParam)->ulObjectType;
        }
    } 
    else
        TreeView_SelectDropTarget(bwi_hWndTV, NULL);

    return htiTarget;
}   



STDMETHODIMP
IWAB_DROPTARGET_DragOver(	LPIWABDROPTARGET lpIWABDropTarget,
						DWORD grfKeyState,					
						POINTL pt,
						DWORD * pdwEffect)
{
    if(lpIWABDropTarget->lpIWDD->m_bSource)
    {
        if(lpIWABDropTarget->lpIWDD->m_bOverTV)
        {
            ULONG ulObjType = 0;
            if(UpdateDragDropHilite((LPBWI)lpIWABDropTarget->lpIWDD->m_lpv, &pt, &ulObjType))
            {
                if(ulObjType == MAPI_ABCONT)
                    *pdwEffect =  DROPEFFECT_MOVE;
                else
                    *pdwEffect =  DROPEFFECT_COPY;
            }
            else
                *pdwEffect = DROPEFFECT_NONE;
        }
        else
            *pdwEffect = DROPEFFECT_NONE;
    }
    else
    if(lpIWABDropTarget->lpIWDD->m_pIDataObject)
	{
        // Anything going from the WAB to anywhere else is a COPY operation .. hence
        // always override to mark it as a copy operation so that the appropriate cursor is shown
        // 
        DWORD m_dwEffect = lpIWABDropTarget->lpIWDD->m_dwEffect;

        if((*pdwEffect&DROPEFFECT_COPY)==DROPEFFECT_COPY)
            m_dwEffect=DROPEFFECT_COPY;
    
        if((*pdwEffect&DROPEFFECT_MOVE)==DROPEFFECT_MOVE)
            m_dwEffect=DROPEFFECT_COPY;//DROPEFFECT_MOVE;

        *pdwEffect &= ~(DROPEFFECT_MOVE|DROPEFFECT_COPY);
        *pdwEffect |= m_dwEffect;

        lpIWABDropTarget->lpIWDD->m_dwEffect = m_dwEffect;
    }
	else
	{
		*pdwEffect = DROPEFFECT_NONE;
	}
	return NOERROR;

}


STDMETHODIMP
IWAB_DROPTARGET_DragLeave(	LPIWABDROPTARGET lpIWABDropTarget)
{
    if(lpIWABDropTarget->lpIWDD->m_bSource)
    {
        if(lpIWABDropTarget->lpIWDD->m_bOverTV)
        {
            UpdateDragDropHilite((LPBWI)lpIWABDropTarget->lpIWDD->m_lpv, NULL, NULL);
            lpIWABDropTarget->lpIWDD->m_bOverTV = FALSE;
        }
    }
	if(lpIWABDropTarget->lpIWDD->m_pIDataObject)
	{
		lpIWABDropTarget->lpIWDD->m_pIDataObject->lpVtbl->Release(lpIWABDropTarget->lpIWDD->m_pIDataObject);
		lpIWABDropTarget->lpIWDD->m_pIDataObject = NULL;
	}
	lpIWABDropTarget->lpIWDD->m_bIsCopyOperation = FALSE;
	lpIWABDropTarget->lpIWDD->m_dwEffect = 0;
	lpIWABDropTarget->lpIWDD->m_cfAccept = 0;

	return NOERROR;
}


/*
-   DropVCardFiles
-
*   Gets the files based on the file names dropped in ..
*
*/
void DropVCardFiles(LPBWI lpbwi, STGMEDIUM medium)
{
    HDROP hDrop=(HDROP)GlobalLock(medium.hGlobal);
    TCHAR    szFile[MAX_PATH];
    UINT    cFiles=0, iFile=0;

    // Let's work through the files given to us
    cFiles = DragQueryFile(hDrop, (UINT) -1, NULL, 0);

    for (iFile = 0; iFile < cFiles; ++iFile)
    {
	    DragQueryFile(hDrop, iFile, szFile, MAX_PATH);
	    // As long as any file is a vCard we can use it
	    if(SubstringSearch(szFile, (LPTSTR) szVCardExt))
	    {
		    if(!(HR_FAILED(OpenAndAddVCard(lpbwi, szFile))))
		    {
			    // if this is not a copy operation - remove original
			    //if(!lpIWABDropTarget->lpIWDD->m_bIsCopyOperation)
			    	//*pdwEffect = DROPEFFECT_MOVE; //we want to remove the temp file from the system
                //else
				//  *pdwEffect = DROPEFFECT_COPY;

		    }
	    }
    }
    GlobalUnlock(medium.hGlobal);
}


/*
-   DropFlatBuffer
-
*   Gets the files based on the file names dropped in ..
*
*/
void DropFlatBuffer(LPBWI lpbwi, STGMEDIUM medium)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPBYTE lpBuf = (LPBYTE)GlobalLock(medium.hGlobal);
    if(lpBuf)
    {
        LPBYTE lp = lpBuf;
        ULONG cItems = 0, i=0;
        CopyMemory(&cItems, lp, sizeof(ULONG));
        lp+=sizeof(ULONG);
        for(i=0;i<cItems;i++)
        {
            LPBYTE lpsz = NULL;
            ULONG cbsz = 0, ulcProps  = 0;
            CopyMemory(&ulcProps, lp, sizeof(ULONG));
            lp+=sizeof(ULONG);
            CopyMemory(&cbsz, lp, sizeof(ULONG));
            lp+=sizeof(ULONG);
            lpsz = LocalAlloc(LMEM_ZEROINIT, cbsz);
            if(lpsz)
            {
                LPSPropValue lpProps = NULL;
                CopyMemory(lpsz, lp, cbsz);
                lp+=cbsz;
                if(!HR_FAILED(HrGetPropArrayFromBuffer(lpsz, cbsz, ulcProps, 0, &lpProps)))
                {
                    ULONG cbEID = 0;
                    LPENTRYID lpEID = NULL;
                    ULONG ulObjType = MAPI_MAILUSER, j =0;
                    for(j=0;j<ulcProps;j++)
                    {
                        if(lpProps[j].ulPropTag == PR_OBJECT_TYPE)
                            ulObjType = lpProps[j].Value.l;
                        else
                        if(lpProps[j].ulPropTag == PR_ENTRYID) // if dropped from another wab entryid is irrelevant
                        {
                            if(lpProps[j].Value.bin.lpb)
                                LocalFree(lpProps[j].Value.bin.lpb);
                            lpProps[j].Value.bin.lpb = NULL;
                            lpProps[j].ulPropTag = PR_NULL;
                        }
                        else// if dropped from another wab remove the folder parent property
                        if(lpProps[j].ulPropTag == PR_WAB_FOLDER_PARENT || lpProps[j].ulPropTag == PR_WAB_FOLDER_PARENT_OLDPROP) 
                        {
                            ULONG k = 0;
                            for(k=0;k<lpProps[j].Value.MVbin.cValues;k++)
                            {
                                if(lpProps[j].Value.MVbin.lpbin[k].lpb)
                                    LocalFree(lpProps[j].Value.MVbin.lpbin[k].lpb);
                            }
                            LocalFreeAndNull((LPVOID *) (&(lpProps[j].Value.MVbin.lpbin)));
                            lpProps[j].ulPropTag = PR_NULL;
                        }
                        else // if this contact was synced with Hotmail, remove the server, mod, and contact IDs
                        // [PaulHi] 12/2/98  Raid #58486
                        if ( (lpProps[j].ulPropTag == PR_WAB_HOTMAIL_SERVERIDS) ||
                             (lpProps[j].ulPropTag == PR_WAB_HOTMAIL_MODTIMES) ||
                             (lpProps[j].ulPropTag == PR_WAB_HOTMAIL_CONTACTIDS) )
                        {
                            ULONG k=0;
                            Assert(PROP_TYPE(lpProps[j].ulPropTag) == PT_MV_TSTRING);
                            for(k=0;k<lpProps[j].Value.MVSZ.cValues;k++)
                            {
                                if (lpProps[j].Value.MVSZ.LPPSZ[k])
                                    LocalFree(lpProps[j].Value.MVSZ.LPPSZ[k]);
                            }
                            LocalFreeAndNull((LPVOID *) (lpProps[j].Value.MVSZ.LPPSZ));
                            lpProps[j].Value.MVSZ.cValues = 0;
                            lpProps[j].ulPropTag = PR_NULL;
                        }
                    }

                    {
                        LPSBinary lpsbEID = NULL;
                        ULONG ulContObjType = 0;
                        GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsbEID, &ulContObjType, FALSE);
                       // [PaulHi] 12/1/98  Raid #58486.  Changed CREATE_CHECK_DUP_STRICT flag
                        // to zero (0) so user can copy/paste without restriction.
                        if(!HR_FAILED(HrCreateNewEntry(bwi_lpAdrBook,
                                        bwi_hWndAB, ulObjType,
                                        (lpsbEID) ? lpsbEID->cb : 0, 
                                        (LPENTRYID) ((lpsbEID) ? lpsbEID->lpb : NULL), 
                                        ulContObjType,
                                        0, TRUE,
                                        ulcProps, lpProps,
                                        &cbEID, &lpEID)))
                        {
                            UpdateLV(lpbwi);
                            if(lpEID)
                                MAPIFreeBuffer(lpEID);
                        }
                        if(lpsbEID)
                            LocalFreeSBinary(lpsbEID);
                    }
                    LocalFreePropArray(NULL, ulcProps, &lpProps);
                }
                LocalFree(lpsz);
            }
        }
    }
    GlobalUnlock(medium.hGlobal);
}


/*
-   DropEntryIDs
-
*   Gets the files based on the entryids
*   EntryIDs only get used when it is an internal only drop
*   on a treeview item - so we check if this is dropped on 
*   a folder or if it is dropped on a group
*
*   If on a group, we add the item to the group
*   If on a folder, we add the item to the folder
*
*
*   If the src was a group and the destination a folder, we dont do anything to the
*   group but we update the items parent folder to not contain the old parent and we
*   update the item to point to the new folder as a parent
*
*   If the src was a folder and the destination a folder, we update the parent folder for the
*   item and we add the item to the dest folders list ..
*
*   If the src was a group and the destination a group, we dont do anything to anyone - just add
*   the item as a group
*   If the src was a folder and the destination a group, then we dont to anything to anyone
*
*   Within the WABs, all drops on folders are moves.
*/
BOOL DropEntryIDs(LPBWI lpbwi, STGMEDIUM medium, POINTL pt, LPSBinary lpsbEID, ULONG ulObjType)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPBYTE lpBuf = (LPBYTE)GlobalLock(medium.hGlobal);
    SBinary sb = {0};
    ULONG ulObjectType = 0;
    BOOL bRet = FALSE;
    LPTSTR lpWABFile = NULL;
    ULONG cProps = 0;
    LPSPropValue lpProps = NULL;

    if(!lpBuf)
        goto out;

    if(!lpsbEID && !ulObjType)
    {
        TV_ITEM tvI = {0};
        // Find out what exactly is the item we dropped stuff on
        tvI.hItem = UpdateDragDropHilite(lpbwi, &pt, NULL);

        if(!tvI.hItem)
            goto out;

        tvI.mask = TVIF_PARAM | TVIF_HANDLE;
        if(TreeView_GetItem(bwi_hWndTV, &tvI) && tvI.lParam)
        {
            LPTVITEM_STUFF lptvStuff = (LPTVITEM_STUFF) tvI.lParam;
            if(lptvStuff)
            {
                ulObjectType = lptvStuff->ulObjectType;
                if(lptvStuff->lpsbEID)
                {
                    sb.cb = lptvStuff->lpsbEID->cb;
                    sb.lpb = lptvStuff->lpsbEID->lpb;
                }
            }
        }
    }
    else
    {
        sb.cb = lpsbEID->cb;
        sb.lpb = lpsbEID->lpb;
        ulObjectType = ulObjType;
    }
    // Get our data from the drop and convert into an array of entryids
    {
        LPBYTE lp = lpBuf;
        ULONG i=0, cb = 0;
        ULONG_PTR ulIAB = 0;
        ULONG ulWABFile = 0;

        // Verify that this is the same lpIAB thats involved
        CopyMemory(&ulIAB, lp, sizeof(ULONG_PTR));
        lp+=sizeof(ULONG_PTR);
        CopyMemory(&ulWABFile, lp, sizeof(ULONG));
        lp+=sizeof(ULONG);
        lpWABFile = LocalAlloc(LMEM_ZEROINIT, ulWABFile);
        if(!lpWABFile)
            goto out;
        CopyMemory(lpWABFile, lp, ulWABFile);
        lp+=ulWABFile;
        if(ulIAB != (ULONG_PTR) bwi_lpIAB)
        {
            // this came from a different IAdrBook object - double check that its
            // not the same file in a different process
            LPTSTR lpWAB = GetWABFileName(((LPIAB)bwi_lpIAB)->lpPropertyStore->hPropertyStore, TRUE);
            if(lstrcmp(lpWAB, lpWABFile))
                goto out; //different
        }
        
        CopyMemory(&cProps, lp, sizeof(ULONG));
        lp+=sizeof(ULONG);
        CopyMemory(&cb, lp, sizeof(ULONG));
        lp+=sizeof(ULONG);

        if(!HR_FAILED(HrGetPropArrayFromBuffer(lp , cb, cProps, 0, &lpProps)))
        {
            for(i=0;i<cProps;i++)
            {
                if(lpProps[i].ulPropTag == PR_ENTRYID)
                {
                    if(HR_FAILED(AddEntryToContainer(bwi_lpAdrBook,
                                    ulObjectType,
                                    sb.cb, (LPENTRYID) sb.lpb,
                                    lpProps[i].Value.bin.cb,
                                    (LPENTRYID) lpProps[i].Value.bin.lpb)))
                    {
                        goto out;
                    }
                    //break;
                }
            }
        }
        else goto out;
    }

    bRet = TRUE;
out:
    LocalFreePropArray(NULL, cProps, &lpProps);

    GlobalUnlock(medium.hGlobal);

    if(lpWABFile)
        LocalFree(lpWABFile);
    return bRet;
}


/*
-
-
*
*
*/
STDMETHODIMP
IWAB_DROPTARGET_Drop(	LPIWABDROPTARGET lpIWABDropTarget,
					IDataObject * pDataObj,
					DWORD grfKeyState,
					POINTL pt,
					DWORD * pdwEffect)
{

#ifndef WIN16
	FORMATETC       fmte    = {lpIWABDropTarget->lpIWDD->m_cfAccept, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
#else
	FORMATETC       fmte;
#endif
    STGMEDIUM       medium = {0};
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
	
#ifdef WIN16
	fmte.cfFormat = lpIWABDropTarget->lpIWDD->m_cfAccept;
	fmte.ptd      = NULL;
	fmte.dwAspect = DVASPECT_CONTENT;
	fmte.lindex   = -1;
	fmte.tymed    = TYMED_HGLOBAL;
#endif

    if (pDataObj && 
		SUCCEEDED(pDataObj->lpVtbl->GetData(pDataObj, &fmte, &medium)))
	{
        if(lpIWABDropTarget->lpIWDD->m_cfAccept == CF_HDROP)
        {
            DropVCardFiles((LPBWI) lpIWABDropTarget->lpIWDD->m_lpv, medium);
        }
        else
        if(lpIWABDropTarget->lpIWDD->m_cfAccept == g_cfWABFlatBuffer)
        {
            DropFlatBuffer((LPBWI) lpIWABDropTarget->lpIWDD->m_lpv, medium);
        }
        else
        if(lpIWABDropTarget->lpIWDD->m_cfAccept == g_cfWABEntryIDList)
        {
            DropEntryIDs((LPBWI) lpIWABDropTarget->lpIWDD->m_lpv, medium, pt, NULL, 0);
            if(lpIWABDropTarget->lpIWDD->m_bOverTV)
            {
                UpdateDragDropHilite((LPBWI)lpIWABDropTarget->lpIWDD->m_lpv, NULL, NULL);
                lpIWABDropTarget->lpIWDD->m_bOverTV = FALSE;
            }
        }
            
	}

	if (medium.pUnkForRelease)
		medium.pUnkForRelease->lpVtbl->Release(medium.pUnkForRelease);
	else
		GlobalFree(medium.hGlobal);

	if(pDataObj)
	{
		pDataObj->lpVtbl->Release(pDataObj);
		if(pDataObj == lpIWABDropTarget->lpIWDD->m_pIDataObject) 
            lpIWABDropTarget->lpIWDD->m_pIDataObject = NULL;
	}

	return NOERROR;
}

/***** DropSource Interfaces *****/

STDMETHODIMP
IWAB_DROPSOURCE_QueryContinueDrag(LPIWABDROPSOURCE lpIWABDropSource,
							      BOOL fEscapePressed,				
                                  DWORD grfKeyState)
{
    if (fEscapePressed)
        return DRAGDROP_S_CANCEL;

    // initialize ourself with the drag begin button
    if (lpIWABDropSource->lpIWDD->m_grfInitialKeyState == 0)
        lpIWABDropSource->lpIWDD->m_grfInitialKeyState = (grfKeyState & (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON));

    if (!(grfKeyState & lpIWABDropSource->lpIWDD->m_grfInitialKeyState))
    {
        lpIWABDropSource->lpIWDD->m_grfInitialKeyState = 0;
        return DRAGDROP_S_DROP;	
    }
    else
        return S_OK;

    return NOERROR;
}

STDMETHODIMP
IWAB_DROPSOURCE_GiveFeedback(LPIWABDROPSOURCE lpIWABDropSource,
                             DWORD dwEffect)
{
    return DRAGDROP_S_USEDEFAULTCURSORS;
}


/****************************************************************************
*
*     DataObject Methods 
*
****************************************************************************/

/*
-   HrGetTempFile
-
*   szTempFile - will contain full file name on returning
*   szDisplayName - name for this contact - therefore name of file to create
*   cbEntryID, lpEntryID - entryids
*
*/
HRESULT HrGetTempFile(LPADRBOOK lpAdrBook,
                      LPTSTR szTempFile,
                      LPTSTR szDisplayName,
                      ULONG cbEntryID, 
                      LPENTRYID lpEntryID)
{
    TCHAR szTemp[MAX_PATH];
    TCHAR szName[MAX_PATH];
    
    ULONG ulObjType = 0;
    DWORD dwPath = 0;
    HRESULT hr = E_FAIL;
    LPMAILUSER lpMailUser = NULL;

    if(!cbEntryID || !lpEntryID || !szTempFile)
        goto out;

    //Get the Temporary File Name
    dwPath = GetTempPath(CharSizeOf(szTemp), szTemp);

    if(!dwPath)
        goto out;

    lstrcpy(szName, szDisplayName);

    // Truncated display names have ellipses in them - get rid of these ellipses

    if(lstrlen(szName) > 30)
    {
        LPTSTR lp = szName;
        while(*lp)
        {
            if(*lp == '.' && *(lp+1) == '.' && *(lp+2) == '.')
            {
                *lp = '\0';
                break;
            }
            lp = CharNext(lp);
        }
    }    
    // There is always the possibility that the display name + the temp path will exceed
    // Max Path .. in which case reduce the display name to say 8.3 characters ..
    if(dwPath + lstrlen(szName) + CharSizeOf(szVCardExt) + 2 > CharSizeOf(szTemp))
    {
        szName[8] = '\0'; // This is totally arbitrary
    }

    TrimIllegalFileChars(szName);

    lstrcat(szTemp, szName);
    lstrcat(szTemp, szVCardExt);

    DebugTrace(TEXT("Creating vCard file: %s\n"), szTemp);

    lstrcpy(szTempFile, szTemp);

    // Get a MailUser corresponding to the given entryids
    if (hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                        cbEntryID,
                                        lpEntryID,
                                        NULL,         // interface
                                        0,            // flags
                                        &ulObjType,
                                        (LPUNKNOWN *)&lpMailUser)) 
    {
        DebugTraceResult( TEXT("OpenEntry failed:"), hr);
        goto out;
    }

    hr = VCardCreate(lpAdrBook,
                    0, 0,
                    szTemp,
                    lpMailUser);

out:
    if(lpMailUser)
        lpMailUser->lpVtbl->Release(lpMailUser);

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Helper functions to manage VCard temp file list and clean up
//
BOOL bAddToNameList(LPTSTR lptszFilename)
{
    VFILENAMELIST * pFileItem = NULL;
    VFILENAMELIST * pList = NULL;

    if (!lptszFilename || *lptszFilename == '\0')
    {
        // Invalid arguments
        return FALSE;
    }

    pFileItem = LocalAlloc(LMEM_ZEROINIT, sizeof(VFILENAMELIST));
    if (!pFileItem)
        return FALSE;

    pFileItem->lptszFilename = LocalAlloc(LMEM_ZEROINIT, (sizeof(TCHAR) * (lstrlen(lptszFilename)+1)));
    if (!pFileItem->lptszFilename)
    {
        LocalFree(pFileItem);
        return FALSE;
    }
    lstrcpy(pFileItem->lptszFilename, lptszFilename);

    pList = s_pFileNameList;
    if (pList == NULL)
    {
        s_pFileNameList = pFileItem;
    }
    else
    {
        while (pList->pNext)
            pList = pList->pNext;
        pList->pNext = pFileItem;
    }

    return TRUE;
}
void DeleteFilesInList()
{
    // Delete files and clean up list
    VFILENAMELIST * pList = s_pFileNameList;
    VFILENAMELIST * pNext = NULL;

    while (pList)
    {
        if (pList->lptszFilename)
        {
            DeleteFile(pList->lptszFilename);
            LocalFree(pList->lptszFilename);
        }
        pNext = pList->pNext;
        LocalFree(pList);
        pList = pNext;
    }
    s_pFileNameList = NULL;
}


//$$///////////////////////////////////////////////////////////////////////
//
// HrBuildHDrop - builds the HDrop structure for dropping files to the 
//  drop target
//
///////////////////////////////////////////////////////////////////////////
HRESULT HrBuildHDrop(LPIWABDATAOBJECT lpIWABDataObject)
{
    HWND m_hwndList = lpIWABDataObject->m_hWndLV;
    LPDROPFILES     lpDrop=0;
    LPVOID          *rglpvTemp=NULL;
    ULONG           *rglpcch=NULL;
    int             cFiles, i, iItem= -1;
    ULONG           cch;
    ULONG           cb;
    HRESULT         hr = E_FAIL;
    TCHAR szTempFile[MAX_PATH];


    cFiles=ListView_GetSelectedCount(m_hwndList);

    if(!cFiles)
      return E_FAIL;    // nothing to build

    // Walk the list and find out how much space we need.
    rglpvTemp = LocalAlloc(LMEM_ZEROINIT, sizeof(LPVOID)*cFiles);
    rglpcch = LocalAlloc(LMEM_ZEROINIT, sizeof(ULONG)*cFiles);
    if(!rglpvTemp || !rglpcch)
        goto errorMemory;

    cFiles=0;
    cch = 0;
    cb = 0;

    while(((iItem=ListView_GetNextItem(m_hwndList, iItem, 
                                           LVNI_SELECTED|LVNI_ALL))!=-1))
    {
        LPRECIPIENT_INFO lpItem = GetItemFromLV(m_hwndList, iItem);
        LPSTR lpszA = NULL;

        if (!lpItem)
        {
            hr=E_FAIL;
            goto error;
        }

        if(lpItem->ulObjectType == MAPI_DISTLIST)
            continue;

        // Take this object and turn it into a temporary vCard
        // We will delete this temporary vCard file when this DataObject is released

        hr=HrGetTempFile(   lpIWABDataObject->m_lpAdrBook,
                            szTempFile, 
                            lpItem->szDisplayName, 
                            lpItem->cbEntryID, lpItem->lpEntryID);
        if (FAILED(hr))
            goto error;

        // Add temporary VCard files to list for later clean up
        if ( !bAddToNameList(szTempFile) )
        {
            Assert(0);
        }

        // [PaulHi] 4/6/99  Raid 75071  Convert to ANSI depending on whether
        // the OS is Win9X or WinNT
        if (g_bRunningOnNT)
        {
            rglpcch[cFiles] = lstrlen(szTempFile) + 1;
            rglpvTemp[cFiles] = LocalAlloc(LMEM_FIXED, (rglpcch[cFiles]*sizeof(WCHAR)));
            if (!rglpvTemp[cFiles])
                goto errorMemory;

            lstrcpy((LPWSTR)rglpvTemp[cFiles], szTempFile);
        }
        else
        {
            rglpvTemp[cFiles] = ConvertWtoA(szTempFile);
            if (!rglpvTemp[cFiles])
                goto errorMemory;

            rglpcch[cFiles] = lstrlenA(rglpvTemp[cFiles]) + 1;
        }
        cch += rglpcch[cFiles];

        cFiles++;
    }

    if(cFiles == 0) //e.g. only groups were selected
    {
        hr=S_OK;
        goto error;
    }
    cch += 1;       //double-null term at end.

    // Fill in the path names.
    // [PaulHi] 4/6/99  Raid 75071  Use Unicode names for WinNT and ANSI 
    // names for Win9X.
    if (g_bRunningOnNT)
    {
        LPWSTR  lpwszPath = NULL;

        // Allocate the buffer and fill it in.
        cb = (cch * sizeof(WCHAR)) + sizeof(DROPFILES);
        if(MAPIAllocateMore(cb, lpIWABDataObject, (LPVOID*) &lpDrop))
            goto errorMemory;
        ZeroMemory(lpDrop, cb);
        lpDrop->pFiles = sizeof(DROPFILES);
        lpDrop->fWide = TRUE;

        lpwszPath = (LPWSTR)((BYTE *)lpDrop + sizeof(DROPFILES));
        for (i=0; i<cFiles; i++)
        {
            lstrcpy(lpwszPath, (LPWSTR)rglpvTemp[i]);
            lpwszPath += rglpcch[i];
        }
    }
    else
    {
        LPSTR   lpszPath = NULL;

        // Allocate the buffer and fill it in.
        cb = cch + sizeof(DROPFILES);
        if(MAPIAllocateMore(cb, lpIWABDataObject, (LPVOID*) &lpDrop))
            goto errorMemory;
        ZeroMemory(lpDrop, cb);
        lpDrop->pFiles = sizeof(DROPFILES);

        lpszPath = (LPSTR)((BYTE *)lpDrop + sizeof(DROPFILES));
        for(i=0; i<cFiles; i++)
        {
            lstrcpyA(lpszPath, (LPSTR)rglpvTemp[i]);
            lpszPath += rglpcch[i];
        }
    }

    lpIWABDataObject->pDatahDrop = (LPVOID)lpDrop;
    lpIWABDataObject->cbDatahDrop = cb;
    
    // Don't free the dropfiles struct
    lpDrop = NULL;

    hr = NOERROR;

error:
    if (rglpvTemp)
    {
        for(i=0; i<cFiles; i++)
            LocalFree(rglpvTemp[i]);
        LocalFree(rglpvTemp);
    }
    
    LocalFreeAndNull(&rglpcch);

    return hr;

errorMemory:
    hr=E_OUTOFMEMORY;
    goto error;
}


/*
-   HrBuildcfText - builds the CF_TEXT data for dropping info
-
*
*
*/
HRESULT HrBuildcfText(LPIWABDATAOBJECT lpIWABDataObject)
{
    HWND m_hwndList = lpIWABDataObject->m_hWndLV;
    LPTSTR           lpszText = NULL;
    int             i, cSel;
    LV_ITEM         lvi;
    ULONG           cb = 0;
    HRESULT         hr = E_FAIL;
    LPTSTR *        rglpszTemp = NULL;
    LPSTR           lpA = NULL;
    LPWSTR          lpW = NULL;

    cSel=ListView_GetSelectedCount(m_hwndList);
    if(!cSel)
      return E_FAIL;    // nothing to build

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem=-1;
    
    // Collate how much space we need
    rglpszTemp = LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR)*cSel);

    if(!rglpszTemp)
        goto errorMemory;

    cSel = 0;


    while(((lvi.iItem=ListView_GetNextItem(m_hwndList, lvi.iItem, 
                                           LVNI_SELECTED|LVNI_ALL))!=-1))
    {
        LPTSTR lp = NULL;
        if(!HR_FAILED(HrGetLVItemDataString(lpIWABDataObject->m_lpAdrBook,
                                            m_hwndList, lvi.iItem, &lp)))
        {
            rglpszTemp[cSel] = lp;
            cb += sizeof(TCHAR)*(lstrlen(lp) + lstrlen(szCRLF) + lstrlen(szCRLF) + 1);
        }
        cSel++;
    }

    // Allocate the buffer and fill it in.
    if(MAPIAllocateMore(cb, lpIWABDataObject, (LPVOID*) &lpszText))
        goto errorMemory;
    
    ZeroMemory(lpszText, cb);

    for(i=0; i<cSel; i++)
    {
        lstrcat(lpszText, rglpszTemp[i]);
        lstrcat(lpszText, szCRLF);
        lstrcat(lpszText, szCRLF);
    }

    lpIWABDataObject->pDataTextW = (LPVOID) lpszText;
    lpIWABDataObject->cbDataTextW = cb;
    if(ScWCToAnsiMore((LPALLOCATEMORE) (&MAPIAllocateMore), lpIWABDataObject, lpszText, &lpA))
        goto error;
    lpIWABDataObject->pDataTextA = lpA;
    lpIWABDataObject->cbDataTextA = lstrlenA(lpA)+1;
    
    hr = NOERROR;

error:
    if (rglpszTemp)
    {
        for(i=0; i<cSel; i++)
            if(rglpszTemp[i])
                LocalFree(rglpszTemp[i]);
        LocalFree(rglpszTemp);
        }
    return hr;

errorMemory:
    hr=E_OUTOFMEMORY;
    goto error;
}


/*
-   HrBuildcfFlatBuffer - builds the CF_TEXT data for dropping info
-
*
*
*/
HRESULT HrBuildcfFlatBuffer(LPIWABDATAOBJECT lpIWABDataObject)
{
    HWND m_hwndList = lpIWABDataObject->m_hWndLV;
    LPSTR           lpszText = NULL, lpBuf = NULL;
    int             i, cSel, iItem= -1;
    ULONG           cb = 0, cbBuf = 0;
    HRESULT         hr = E_FAIL;
    LPBYTE *        rglpTemp = NULL;
    ULONG *         cbTemp = NULL;
    ULONG *         cbProps = NULL;

    cSel=ListView_GetSelectedCount(m_hwndList);
    if(!cSel)
      return E_FAIL;    // nothing to build

    // Collate how much space we need
    rglpTemp = LocalAlloc(LMEM_ZEROINIT, sizeof(LPBYTE)*cSel);
    if(!rglpTemp)
        goto errorMemory;

    // Collate how much space we need
    cbTemp = LocalAlloc(LMEM_ZEROINIT, sizeof(ULONG)*cSel);
    if(!cbTemp)
        goto errorMemory;

    // Collate how much space we need
    cbProps = LocalAlloc(LMEM_ZEROINIT, sizeof(ULONG)*cSel);
    if(!cbProps)
        goto errorMemory;

    cSel = 0;

    cb = sizeof(ULONG);

    while(((iItem=ListView_GetNextItem(m_hwndList, iItem, 
                                           LVNI_SELECTED|LVNI_ALL))!=-1))
    {
        LPMAILUSER lpMailUser = NULL;
        LPRECIPIENT_INFO lpItem = GetItemFromLV(m_hwndList, iItem);
        LPADRBOOK lpAdrBook = lpIWABDataObject->m_lpAdrBook;
        LPSPropValue lpProps = NULL;
        ULONG ulcProps = 0;
        ULONG ulObjType = 0;

        if (!lpItem)
        {
            hr=E_FAIL;
            goto error;
        }

        if(lpItem->ulObjectType == MAPI_DISTLIST)
            continue;

        // Get a MailUser corresponding to the given entryids
        if (!HR_FAILED(lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                                    lpItem->cbEntryID,
                                                    lpItem->lpEntryID,
                                                    NULL,         // interface
                                                    0,            // flags
                                                    &ulObjType,
                                                    (LPUNKNOWN *)&lpMailUser)))
        {
            if(!HR_FAILED(lpMailUser->lpVtbl->GetProps(lpMailUser, NULL, MAPI_UNICODE, &ulcProps, &lpProps)))
            {
                if(!HR_FAILED(HrGetBufferFromPropArray( ulcProps, lpProps,
                                                        &(cbTemp[cSel]),
                                                        &(rglpTemp[cSel]))))
                {
                    cbProps[cSel] = ulcProps;
                    if(cbTemp[cSel] && rglpTemp[cSel])
                        cb += cbTemp[cSel] + sizeof(ULONG) + sizeof(ULONG) + 1;
                    cSel++;
                }
                if(lpProps)
                    MAPIFreeBuffer(lpProps);
            }
            if(lpMailUser)
                lpMailUser->lpVtbl->Release(lpMailUser);
        }
    }

    if(!cSel)
      goto error;    // nothing to build

    // Allocate the buffer and fill it in.
    if(MAPIAllocateMore(cb, lpIWABDataObject, (LPVOID*) &lpszText))
        goto errorMemory;
    
    ZeroMemory(lpszText, cb);

    lpBuf = lpszText;
    CopyMemory(lpBuf, &cSel, sizeof(ULONG));
    lpBuf += sizeof(ULONG);

    for(i=0; i<cSel; i++)
    {
        CopyMemory(lpBuf, &(cbProps[i]), sizeof(ULONG));
        lpBuf+=sizeof(ULONG);
        CopyMemory(lpBuf, &(cbTemp[i]), sizeof(ULONG));
        lpBuf+=sizeof(ULONG);
        CopyMemory(lpBuf, rglpTemp[i], cbTemp[i]);
        lpBuf+=cbTemp[i];
    }

    lpIWABDataObject->pDataBuffer = (LPVOID) lpszText;
    lpIWABDataObject->cbDataBuffer = cb;
    
    hr = NOERROR;

error:
    if (rglpTemp)
    {
        for(i=0; i<cSel; i++)
            if(rglpTemp[i])
                LocalFree(rglpTemp[i]);
        LocalFree(rglpTemp);
    }
    if(cbProps)
        LocalFree(cbProps);
    if(cbTemp)
        LocalFree(cbTemp);
    return hr;

errorMemory:
    hr=E_OUTOFMEMORY;
    goto error;
}


/*
-   HrBuildcfEIDList - Builds an SPropValue array that only has entryid's in it
-           When doing internal-only drops, we scan this list of entryids and 
-           use the entryids for adding items to items instead of physically 
-           adding the contents of the item
*
*/
HRESULT HrBuildcfEIDList(LPIWABDATAOBJECT lpIWABDataObject)
{
    HWND m_hwndList = lpIWABDataObject->m_hWndLV;
    ULONG           cb = 0, cProps = 0, cbTotal=0;
    HRESULT         hr = E_FAIL;
    LPSPropValue lpProps = 0;
    LPBYTE lpBufEID = NULL, lp = NULL, lpTemp = NULL;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPBWI lpbwi = (LPBWI) lpIWABDataObject->m_lpv;
    LPTSTR lpWABFile = GetWABFileName( ((LPIAB)bwi_lpIAB)->lpPropertyStore->hPropertyStore, TRUE);
    int iItem = -1;

    cProps=ListView_GetSelectedCount(m_hwndList);

    if(!cProps)
      return E_FAIL;    // nothing to build

    lpProps = LocalAlloc(LMEM_ZEROINIT, sizeof(SPropValue)*cProps);
    if(!lpProps)
        goto errorMemory;

    cProps = 0;

    while(((iItem=ListView_GetNextItem(m_hwndList, iItem, 
                                           LVNI_SELECTED|LVNI_ALL))!=-1))
    {
        LPRECIPIENT_INFO lpItem = GetItemFromLV(m_hwndList, iItem);
        if (!lpItem)
            goto error;
        lpProps[cProps].ulPropTag = PR_ENTRYID;
        lpProps[cProps].Value.bin.lpb = LocalAlloc(LMEM_ZEROINIT, lpItem->cbEntryID);
        if(!lpProps[cProps].Value.bin.lpb)
            goto errorMemory;
        CopyMemory(lpProps[cProps].Value.bin.lpb, lpItem->lpEntryID, lpItem->cbEntryID);
        lpProps[cProps].Value.bin.cb = lpItem->cbEntryID;
        cProps++;
    }
    if(!cProps)
      goto error;    // nothing to build

    // Convert this proparray to a buffer
    if(HR_FAILED(hr = HrGetBufferFromPropArray( cProps, lpProps,
                                            &cb, &lpBufEID)))
        goto error;

    cbTotal = cb+ sizeof(ULONG) //lpIAB
                + sizeof(ULONG) + sizeof(TCHAR)*(lstrlen(lpWABFile) + 1) // WAB File Name
                + sizeof(ULONG) //cProps
                + sizeof(ULONG); //cb;

    // Allocate the buffer and fill it in.
    if(MAPIAllocateMore(cbTotal, lpIWABDataObject, (LPVOID*) &lp))
        goto errorMemory;
    
    ZeroMemory(lp, cbTotal);

    lpTemp = lp;
    {
        // tag this data with the pointer address identifying the current
        // iadrbook object
        ULONG_PTR ulIAB = (ULONG_PTR) bwi_lpIAB;
        ULONG ulWAB = lstrlen(lpWABFile)+1;
        CopyMemory(lpTemp, &ulIAB, sizeof(ULONG_PTR));
        lpTemp += sizeof(ULONG_PTR);
        CopyMemory(lpTemp, &ulWAB, sizeof(ULONG));
        lpTemp += sizeof(ULONG);
        CopyMemory(lpTemp, lpWABFile, ulWAB);
        lpTemp += ulWAB;
    }
    CopyMemory(lpTemp, &cProps, sizeof(ULONG));
    lpTemp += sizeof(ULONG);
    CopyMemory(lpTemp, &cb, sizeof(ULONG));
    lpTemp += sizeof(ULONG);
    CopyMemory(lpTemp, lpBufEID, cb);

    lpIWABDataObject->pDataEID = lp;
    lpIWABDataObject->cbDataEID = cbTotal;
    
    hr = NOERROR;

error:
    LocalFreePropArray(NULL, cProps, &lpProps);

    if(lpBufEID)
        LocalFree(lpBufEID);

    return hr;

errorMemory:
    hr=E_OUTOFMEMORY;
    goto error;
}

/*
-   HrCreateIWABDataObject
-
*   Creates a WAB Data Object
*   Data is created from current selection in the hWndLV list view
*   bDataNow - means collect the raw data now or do it later
*       For Drag-Drops we do it later since the drag-drop operation is synchronous and
*           the ListView wont lose its selection
*       For Copy/Paste we get the data now at creation time since user may choose to paste
*           at some later time at which point we may have completely lost the data
*/
HRESULT HrCreateIWABDataObject(LPVOID lpv, LPADRBOOK lpAdrBook, HWND hWndLV, 
                                LPIWABDATAOBJECT * lppIWABDataObject, BOOL bGetDataNow, BOOL bIsGroup)
{

    LPIWABDATAOBJECT lpIWABDataObject = NULL;
    SCODE 		     sc;
    HRESULT 	     hr     	   = hrSuccess;

    //
    //  Allocate space for the IAB structure
    //
    if (FAILED(sc = MAPIAllocateBuffer(sizeof(IWABDATAOBJECT), (LPVOID *) &lpIWABDataObject))) {
        hr = ResultFromScode(sc);
        goto err;
    }

    MAPISetBufferName(lpIWABDataObject,  TEXT("WAB Data Object"));

    ZeroMemory(lpIWABDataObject, sizeof(IWABDATAOBJECT));

    lpIWABDataObject->lpVtbl = &vtblIWAB_DATAOBJECT;

    lpIWABDataObject->lpVtbl->AddRef(lpIWABDataObject);

    lpIWABDataObject->m_lpAdrBook = lpAdrBook;
    lpAdrBook->lpVtbl->AddRef(lpAdrBook);

    lpIWABDataObject->m_hWndLV = hWndLV;
    lpIWABDataObject->m_lpv = lpv;
    lpIWABDataObject->m_bObjectIsGroup = bIsGroup;

    if(bGetDataNow)
    {
        if(HR_FAILED(HrBuildHDrop(lpIWABDataObject)))
            goto err;

        if(HR_FAILED(HrBuildcfText(lpIWABDataObject)))
            goto err;

        if(HR_FAILED(HrBuildcfFlatBuffer(lpIWABDataObject)))
            goto err;

        if(HR_FAILED(HrBuildcfEIDList(lpIWABDataObject)))
            goto err;
    }

    if(g_cfWABFlatBuffer == 0)
    {
        g_cfWABFlatBuffer = (CLIPFORMAT) RegisterClipboardFormat(c_szWABFlatBuffer);
        g_cfWABEntryIDList = (CLIPFORMAT) RegisterClipboardFormat(c_szWABEntryIDList);
    }

	*lppIWABDataObject = lpIWABDataObject;

    return hr;

err:
    if(lpIWABDataObject)
        MAPIFreeBuffer(lpIWABDataObject);

    *lppIWABDataObject = NULL;

	return hr;
}


/*
-
-
*
*
*/
void ReleaseWABDataObject(LPIWABDATAOBJECT lpIWABDataObject)
{
    // Ideally we should clean up any files that were created in <TEMPDIR> ..
    // however, there is a problem when dropping to the shell - OLE doesnt
    // seem to get to these files until after we've deleted them and then
    // pops up error messages.
    // So we'll just let these files lie as is.
/*
    STGMEDIUM medium;
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	
	if (lpIWABDataObject && 
		SUCCEEDED(lpIWABDataObject->lpVtbl->GetData(lpIWABDataObject, &fmte, &medium)))
	{

		HDROP hDrop=(HDROP)GlobalLock(medium.hGlobal);

		// Enumerate the files and delete them
		{
			TCHAR    szFile[MAX_PATH];
			UINT    cFiles;
			UINT    iFile;
    
			// Let's work through the files given to us
			cFiles = DragQueryFile(hDrop, (UINT) -1, NULL, 0);
			
			for (iFile = 0; iFile < cFiles; ++iFile)
			{
				DragQueryFile(hDrop, iFile, szFile, MAX_PATH);

                DeleteFile(szFile);
			}
		}

		GlobalUnlock(medium.hGlobal);
	}

	if (medium.pUnkForRelease)
		medium.pUnkForRelease->lpVtbl->Release(medium.pUnkForRelease);
	else
		GlobalFree(medium.hGlobal);
*/

    if(lpIWABDataObject->m_lpAdrBook)
        lpIWABDataObject->m_lpAdrBook->lpVtbl->Release(lpIWABDataObject->m_lpAdrBook);

    lpIWABDataObject->m_hWndLV = NULL;

	MAPIFreeBuffer(lpIWABDataObject);
}



STDMETHODIMP_(ULONG)
IWAB_DATAOBJECT_AddRef(LPIWABDATAOBJECT lpIWABDataObject)
{
    return(++(lpIWABDataObject->lcInit));
}


STDMETHODIMP_(ULONG)
IWAB_DATAOBJECT_Release(LPIWABDATAOBJECT lpIWABDataObject)
{
    if(--(lpIWABDataObject->lcInit)==0)
	{
       ReleaseWABDataObject(lpIWABDataObject);
       return 0;
    }

    return(lpIWABDataObject->lcInit);
}


STDMETHODIMP
IWAB_DATAOBJECT_QueryInterface( LPIWABDATAOBJECT lpIWABDataObject,
                                REFIID lpiid,
                                LPVOID * lppNewObj)
{
    LPVOID lp = NULL;

    if(!lppNewObj)
        return MAPI_E_INVALID_PARAMETER;

    *lppNewObj = NULL;

    if(IsEqualIID(lpiid, &IID_IUnknown))
        lp = (LPVOID) lpIWABDataObject;

    if(IsEqualIID(lpiid, &IID_IDataObject))
    {
        lp = (LPVOID) (LPDATAOBJECT) lpIWABDataObject;
    }

    if(!lp)
    {
        return E_NOINTERFACE;
    }

    lpIWABDataObject->lpVtbl->AddRef(lpIWABDataObject);

    *lppNewObj = lp;

    return S_OK;

}



STDMETHODIMP
IWAB_DATAOBJECT_GetDataHere(    LPIWABDATAOBJECT lpIWABDataObject,
                            FORMATETC * pFormatetc,
                            STGMEDIUM * pmedium)
{
    DebugTrace(TEXT("IDataObject: GetDataHere\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IWAB_DATAOBJECT_GetData(LPIWABDATAOBJECT lpIWABDataObject,
                            FORMATETC * pformatetcIn,	                    
                            STGMEDIUM * pmedium)
{
    HRESULT hres = E_INVALIDARG;
    LPVOID  pv = NULL;

    DebugTrace(TEXT("IDataObject: GetData ->"));

    pmedium->hGlobal = NULL;
    pmedium->pUnkForRelease = NULL;
    
    if(     (pformatetcIn->tymed & TYMED_HGLOBAL)
        &&  (   g_cfWABEntryIDList == pformatetcIn->cfFormat || 
                g_cfWABFlatBuffer == pformatetcIn->cfFormat ||
                CF_HDROP == pformatetcIn->cfFormat ||
                CF_TEXT == pformatetcIn->cfFormat ||
                CF_UNICODETEXT == pformatetcIn->cfFormat  )    )
    {
        LPVOID lp = NULL;
        ULONG cb = 0;

	    if (lpIWABDataObject->m_bObjectIsGroup &&
			pformatetcIn->cfFormat != g_cfWABEntryIDList)
			return E_FAIL;
 
        if(g_cfWABEntryIDList == pformatetcIn->cfFormat)
        {
            DebugTrace(TEXT("cfWABEntryIDList requested \n"));
            if(!lpIWABDataObject->cbDataEID && !lpIWABDataObject->pDataEID)
            {
                if(HR_FAILED(HrBuildcfEIDList(lpIWABDataObject)))
                    return E_FAIL;
            }
            cb = lpIWABDataObject->cbDataEID;
            lp = (LPVOID)lpIWABDataObject->pDataEID;
        }
        else if(g_cfWABFlatBuffer == pformatetcIn->cfFormat)
        {
            DebugTrace(TEXT("cfWABFlatBuffer requested \n"));
            if(!lpIWABDataObject->cbDataBuffer && !lpIWABDataObject->pDataBuffer)
            {
                if(HR_FAILED(HrBuildcfFlatBuffer(lpIWABDataObject)))
                    return E_FAIL;
            }
            cb = lpIWABDataObject->cbDataBuffer;
            lp = (LPVOID)lpIWABDataObject->pDataBuffer;
        }
        else if (CF_HDROP == pformatetcIn->cfFormat)
        {
            DebugTrace(TEXT("CF_HDROP requested \n"));
            // Time to go create the actual files on disk and pass that information back
            if(!lpIWABDataObject->cbDatahDrop && !lpIWABDataObject->pDatahDrop)
            {
                if(HR_FAILED(HrBuildHDrop(lpIWABDataObject)))
                    return E_FAIL;
            }
            cb = lpIWABDataObject->cbDatahDrop;
            lp = (LPVOID)lpIWABDataObject->pDatahDrop;
        }
        else if(CF_TEXT == pformatetcIn->cfFormat)
        {
            DebugTrace(TEXT("CF_TEXT requested \n"));
            if(!lpIWABDataObject->cbDataTextA && !lpIWABDataObject->pDataTextA)
            {
                if(HR_FAILED(HrBuildcfText(lpIWABDataObject)))
                    return E_FAIL;
            }
            cb = lpIWABDataObject->cbDataTextA;
            lp = (LPVOID)lpIWABDataObject->pDataTextA;
        }
        else if(CF_UNICODETEXT == pformatetcIn->cfFormat)
        {
            DebugTrace(TEXT("CF_UNICODETEXT requested \n"));
            if(!lpIWABDataObject->cbDataTextW && !lpIWABDataObject->pDataTextW)
            {
                if(HR_FAILED(HrBuildcfText(lpIWABDataObject)))
                    return E_FAIL;
            }
            cb = lpIWABDataObject->cbDataTextW;
            lp = (LPVOID)lpIWABDataObject->pDataTextW;
        }

        if(!cb || !lp)
            return (E_FAIL);

        // Make a copy of the data for this pInfo
        pmedium->hGlobal = GlobalAlloc(GMEM_SHARE | GHND, cb);
        if (!pmedium->hGlobal)
            return (E_OUTOFMEMORY);
        pv = GlobalLock(pmedium->hGlobal);
        CopyMemory(pv, lp, cb);
        GlobalUnlock(pmedium->hGlobal);            
        // Fill in the pStgMedium struct
        if (pformatetcIn->tymed & TYMED_HGLOBAL)
        {
            pmedium->tymed = TYMED_HGLOBAL;
            return (S_OK);
        }
    }

    return hres;
}

STDMETHODIMP
IWAB_DATAOBJECT_QueryGetData(LPIWABDATAOBJECT lpIWABDataObject,
                            FORMATETC * pformatetcIn)
{
    DebugTrace(TEXT("IDataObject: QueryGetData: %d "),pformatetcIn->cfFormat);

//    if (pformatetcIn->cfFormat == g_cfFileContents ||
//        pformatetcIn->cfFormat == g_cfFileGroupDescriptor)
    if (lpIWABDataObject->m_bObjectIsGroup)
    {
        if(pformatetcIn->cfFormat == g_cfWABEntryIDList)
		{
			DebugTrace(TEXT("S_OK\n"));
    		return S_OK;
		}
		else
		{
			DebugTrace(TEXT("S_FALSE\n"));
			return DV_E_FORMATETC;
		}
    }
    else
    if (pformatetcIn->cfFormat == g_cfWABEntryIDList ||
        pformatetcIn->cfFormat == g_cfWABFlatBuffer ||
        pformatetcIn->cfFormat == CF_HDROP ||
        pformatetcIn->cfFormat == CF_TEXT ||
        pformatetcIn->cfFormat == CF_UNICODETEXT)
    {
        DebugTrace(TEXT("S_OK\n"));
    	return S_OK;
    }
    else
    {
        DebugTrace(TEXT("S_FALSE\n"));
        return DV_E_FORMATETC;
    }
    return NOERROR;
}

STDMETHODIMP
IWAB_DATAOBJECT_GetCanonicalFormatEtc(  LPIWABDATAOBJECT lpIWABDataObject,
                                        FORMATETC * pFormatetcIn,
                                        FORMATETC * pFormatetcOut)
{
    DebugTrace(TEXT("IDataObject: GetCanonicalFormatEtc\n"));
    return DATA_S_SAMEFORMATETC;
}


STDMETHODIMP
IWAB_DATAOBJECT_SetData(    LPIWABDATAOBJECT lpIWABDataObject,
                            FORMATETC * pFormatetc,                     
                            STGMEDIUM * pmedium,                        
                            BOOL fRelease)
{
    DebugTrace(TEXT("IDataObject: SetData\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IWAB_DATAOBJECT_EnumFormatEtc(  LPIWABDATAOBJECT lpIWABDataObject,
                                DWORD dwDirection,	                        
                                IEnumFORMATETC ** ppenumFormatetc)
{
    FORMATETC fmte[5] = {
//        {g_cfFileContents, 	  NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
//        {g_cfFileGroupDescriptor, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {g_cfWABEntryIDList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {g_cfWABFlatBuffer, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {CF_TEXT, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {CF_UNICODETEXT, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
    };
	int nType = 0;

    DebugTrace(TEXT("IDataObject: EnumFormatEtc\n"));

	if(lpIWABDataObject->m_bObjectIsGroup)
		nType = 1;
	else
		nType = sizeof(fmte)/sizeof(FORMATETC);
    return HrCreateIWABEnumFORMATETC(nType, fmte, 
                                    (LPIWABENUMFORMATETC *) ppenumFormatetc);
}


STDMETHODIMP
IWAB_DATAOBJECT_DAdvise(LPIWABDATAOBJECT lpIWABDataObject,
                        FORMATETC * pFormatetc,	                    
                        DWORD advf,
                        IAdviseSink * pAdvSink,
                        DWORD * pdwConnection)
{
    DebugTrace(TEXT("IDataObject: DAdvise\n"));
    return OLE_E_ADVISENOTSUPPORTED;
}


STDMETHODIMP
IWAB_DATAOBJECT_DUnadvise(  LPIWABDATAOBJECT lpIWABDataObject,
                            DWORD dwConnection)
{
    DebugTrace(TEXT("IDataObject: DUnadvise\n"));
    return OLE_E_ADVISENOTSUPPORTED;
}


STDMETHODIMP
IWAB_DATAOBJECT_EnumDAdvise(  LPIWABDATAOBJECT lpIWABDataObject,
                            IEnumSTATDATA ** ppenumAdvise)
{
    DebugTrace(TEXT("IDataObject: EnumDAdvise\n"));
    return OLE_E_ADVISENOTSUPPORTED;
}



/*--------------------------------------------------------------------------------*/



/****************************************************************************
*
*     STDEnumFmt Methods
*
****************************************************************************/

HRESULT HrCreateIWABEnumFORMATETC(  UINT cfmt, 
                                    const FORMATETC afmt[], 
                                    LPIWABENUMFORMATETC *ppenumFormatEtc)
{

    LPIWABENUMFORMATETC lpIWABEnumFORMATETC = NULL;
    SCODE 		     sc;
    HRESULT 	     hr     	   = hrSuccess;

    if (FAILED(sc = MAPIAllocateBuffer(sizeof(IWABENUMFORMATETC)+(cfmt - 1) * sizeof(FORMATETC), (LPVOID *) &lpIWABEnumFORMATETC))) {
        hr = ResultFromScode(sc);
        goto err;
    }

    MAPISetBufferName(lpIWABEnumFORMATETC,  TEXT("WAB EnumFORMATETC Object"));

    ZeroMemory(lpIWABEnumFORMATETC, sizeof(IWABENUMFORMATETC));

    lpIWABEnumFORMATETC->lpVtbl = &vtblIWAB_ENUMFORMATETC;

    lpIWABEnumFORMATETC->lpVtbl->AddRef(lpIWABEnumFORMATETC);

	lpIWABEnumFORMATETC->cfmt = cfmt;

	lpIWABEnumFORMATETC->ifmt = 0;

	MoveMemory(lpIWABEnumFORMATETC->afmt, afmt, cfmt * sizeof(FORMATETC));

    *ppenumFormatEtc = lpIWABEnumFORMATETC;

err:
	return hr;
}



void ReleaseWABEnumFORMATETC(LPIWABENUMFORMATETC lpIWABEnumFORMATETC)
{

	MAPIFreeBuffer(lpIWABEnumFORMATETC);
}



STDMETHODIMP_(ULONG)
IWAB_ENUMFORMATETC_AddRef(LPIWABENUMFORMATETC lpIWABEnumFORMATETC)
{
    return(++(lpIWABEnumFORMATETC->lcInit));
}


STDMETHODIMP_(ULONG)
IWAB_ENUMFORMATETC_Release(LPIWABENUMFORMATETC lpIWABEnumFORMATETC)
{
    if(--(lpIWABEnumFORMATETC->lcInit)==0)
	{
       ReleaseWABEnumFORMATETC(lpIWABEnumFORMATETC);
       return 0;
    }

    return(lpIWABEnumFORMATETC->lcInit);
}


STDMETHODIMP
IWAB_ENUMFORMATETC_QueryInterface( LPIWABENUMFORMATETC lpIWABEnumFORMATETC,
                                REFIID lpiid,
                                LPVOID * lppNewObj)
{
    LPVOID lp = NULL;

    if(!lppNewObj)
        return MAPI_E_INVALID_PARAMETER;

    *lppNewObj = NULL;

    if(IsEqualIID(lpiid, &IID_IUnknown))
        lp = (LPVOID) lpIWABEnumFORMATETC;

    if(IsEqualIID(lpiid, &IID_IEnumFORMATETC))
    {
        lp = (LPVOID) (LPENUMFORMATETC) lpIWABEnumFORMATETC;
    }

    if(!lp)
    {
        return E_NOINTERFACE;
    }

    lpIWABEnumFORMATETC->lpVtbl->AddRef(lpIWABEnumFORMATETC);

    *lppNewObj = lp;

    return S_OK;

}


STDMETHODIMP
IWAB_ENUMFORMATETC_Next(LPIWABENUMFORMATETC lpIWABEnumFORMATETC,
                        ULONG celt,
                        FORMATETC *rgelt,
                        ULONG *pceltFethed)
{
    UINT cfetch;
    HRESULT hres = S_FALSE;	// assume less numbers

    if (lpIWABEnumFORMATETC->ifmt < lpIWABEnumFORMATETC->cfmt)
    {
	    cfetch = lpIWABEnumFORMATETC->cfmt - lpIWABEnumFORMATETC->ifmt;

    	if (cfetch >= celt)
	    {
	        cfetch = celt;
	        hres = S_OK;
	    }

	    CopyMemory(rgelt, &(lpIWABEnumFORMATETC->afmt[lpIWABEnumFORMATETC->ifmt]), cfetch * sizeof(FORMATETC));
	    lpIWABEnumFORMATETC->ifmt += cfetch;
    }
    else
    {
    	cfetch = 0;
    }

    if (pceltFethed)
        *pceltFethed = cfetch;

    return hres;
}


STDMETHODIMP
IWAB_ENUMFORMATETC_Skip(LPIWABENUMFORMATETC lpIWABEnumFORMATETC,
                        ULONG celt)
{
    lpIWABEnumFORMATETC->ifmt += celt;
    if (lpIWABEnumFORMATETC->ifmt > lpIWABEnumFORMATETC->cfmt)
    {
	    lpIWABEnumFORMATETC->ifmt = lpIWABEnumFORMATETC->cfmt;
	    return S_FALSE;
    }
    return S_OK;
}


STDMETHODIMP
IWAB_ENUMFORMATETC_Reset(LPIWABENUMFORMATETC lpIWABEnumFORMATETC)
{
    lpIWABEnumFORMATETC->ifmt = 0;
    return S_OK;
}

STDMETHODIMP
IWAB_ENUMFORMATETC_Clone(LPIWABENUMFORMATETC lpIWABEnumFORMATETC,
                         LPENUMFORMATETC * ppenum)
{
    return HrCreateIWABEnumFORMATETC(   lpIWABEnumFORMATETC->cfmt, 
                                        lpIWABEnumFORMATETC->afmt, 
                                        (LPIWABENUMFORMATETC *) ppenum);
}



/********************************************************************************/


/*
-
-   bIsPasteData
*
*   Checks if there is pastable data on the clipboard - 
*       if this data is being dropped within the same WAB, 
*       then we can look for the entryids else we ask for
*       flat-buffer or cf-hdrop
*/
BOOL bIsPasteData()
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPDATAOBJECT lpDataObject = NULL;
    BOOL bRet = FALSE;

    OleGetClipboard(&lpDataObject);

    if(lpDataObject)
    {
        FORMATETC fe[3] = 
        {
            {g_cfWABEntryIDList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            {g_cfWABFlatBuffer, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        };
        ULONG i = 0;
        for(i=0;i<sizeof(fe)/sizeof(FORMATETC);i++)
        {
            if(NOERROR == lpDataObject->lpVtbl->QueryGetData(lpDataObject, &(fe[i])))
            {
                // TBD - ideally before accepting CF_HDROP as a valid format, we
                // should make sure the droppable files are indeed vCard files ...
                bRet = TRUE;
                break;
            }
        }
    }

    if(lpDataObject)
        lpDataObject->lpVtbl->Release(lpDataObject);

    return bRet;
}


//////////////////////////////////////////////////////////////////////////
// Helper function to determine drop target type
//
// bIsDropTargetGroup()
//////////////////////////////////////////////////////////////////////////

BOOL bIsDropTargetGroup(LPBWI lpbwi)
{
    // The drop target can be in either the List View or Tree View control.
    // First check the List View.
    BOOL fRtn = FALSE;
    SBinary sb = {0};
    if ( (GetFocus() == bwi_hWndListAB) &&
         bIsGroupSelected(bwi_hWndListAB, &sb) )
    {
        fRtn = TRUE;
    }
    else
    {
        // Next try the Tree View control.
        LPSBinary lpsbEID = NULL;
        ULONG     ulObjectType = 0;
        GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsbEID, &ulObjectType, FALSE);
        fRtn = (ulObjectType == MAPI_DISTLIST);
    }

    return fRtn;
}



/*
-   PasteData
-
*   Pastes data when user chooses to paste data (from a menu)
*
*/
HRESULT HrPasteData(LPBWI lpbwi)
{
    HRESULT hr = S_OK;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPDATAOBJECT lpDataObject = NULL;
    STGMEDIUM       medium = {0};
    LPSBinary lpsbEID = NULL;
    SBinary sb = {0};
    FORMATETC fmte[3] = 
    {
        {g_cfWABEntryIDList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {g_cfWABFlatBuffer, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
    };
    // this only got called if valid pastable data existed

    OleGetClipboard(&lpDataObject);
    if(lpDataObject)
    {
        // [PaulHi] 12/1/98  Raid #58486
        // First check for a flat buffer.  We prefer to paste a new contact (i.e., 
        // new entryid) based on the clipboard flat buffer, UNLESS we are pasting 
        // to a group or distribution list.  Only existing entryids can be added to 
        // a group.
        BOOL bGroupTarget = bIsDropTargetGroup(lpbwi);
        if( !bGroupTarget &&
            (NOERROR == lpDataObject->lpVtbl->QueryGetData(lpDataObject, &(fmte[1]))) )
        {
            // yes - we are the pasting within the same wab
            if (SUCCEEDED(lpDataObject->lpVtbl->GetData(lpDataObject, &fmte[1], &medium)))
            {
                DropFlatBuffer(lpbwi, medium);
            }
            goto out;
        }

        // next check if entryids are available
        if(NOERROR == lpDataObject->lpVtbl->QueryGetData(lpDataObject, &(fmte[0])))
        {
            // yes entryids are available - but is this the source of the date ?
            // entryids are only useful when dropping between the wab and itself
            if (SUCCEEDED(lpDataObject->lpVtbl->GetData(lpDataObject, &fmte[0], &medium)))
            {
                ULONG ulObjType = 0;
                POINTL pt = {0};
                if(!bIsGroupSelected(bwi_hWndListAB, &sb))
                    GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsbEID, &ulObjType, FALSE);
                else
                    lpsbEID = &sb;
                if(!DropEntryIDs(lpbwi, medium, pt, lpsbEID, ulObjType))
                {
                    //Something failed - try another format)
	                if (medium.pUnkForRelease)
                    {
		                medium.pUnkForRelease->lpVtbl->Release(medium.pUnkForRelease);
                        medium.pUnkForRelease = NULL;
                    }
	                else if(medium.hGlobal)
                    {
		                GlobalFree(medium.hGlobal);
                        medium.hGlobal = NULL;
                    }
                }
                else
                    goto out;
            }
        }

        // otherwise we're just dropping files
        if(NOERROR == lpDataObject->lpVtbl->QueryGetData(lpDataObject, &(fmte[2])))
        {
            // yes - we are the pasting within the same wab
            if (SUCCEEDED(lpDataObject->lpVtbl->GetData(lpDataObject, &fmte[2], &medium)))
            {
                DropVCardFiles(lpbwi, medium);
            }
            goto out;
        }
    }

    hr = E_FAIL;
out:
    if(lpsbEID != &sb)
        LocalFreeSBinary(lpsbEID);

    if (medium.pUnkForRelease)
		medium.pUnkForRelease->lpVtbl->Release(medium.pUnkForRelease);
	else if(medium.hGlobal)
		GlobalFree(medium.hGlobal);

    if(lpDataObject)
        lpDataObject->lpVtbl->Release(lpDataObject);

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\imem.c ===
/*
 *	IMEM.C
 *	
 *	Per-instance global data for WIN32 (trivial), WIN16, and Mac.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#pragma warning(disable:4100)	/* unreferenced formal parameter */
#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4209)	/* benign typedef redefinition */
#pragma warning(disable:4214)	/* bit field types other than int */
#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4115)	/* named type definition in parens */

#ifdef WIN32
#define INC_OLE2 /* Get the OLE2 stuff */
#define INC_RPC  /* harmless on Windows NT; Windows 95 needs it */
#endif

#include "_apipch.h"

#ifdef	DEBUG
#define STATIC
#else
#define STATIC static
#endif

#pragma warning (disable:4514)		/* unreferenced inline function */

#ifdef	WIN16

#pragma code_seg("IMAlloc")

#pragma warning(disable: 4005)		/* redefines MAX_PATH */
#include <toolhelp.h>
#pragma warning(default: 4005)

#pragma warning(disable: 4704)		/* Inline assembler */

/*
 *	These arrays are parallel. RgwInstKey holds the stack
 *	segment of each task that calls the DLL we're in; rgpvInst
 *	has a pointer to that task's instance globals in the slot with
 *	the same index. Since all Win16 tasks share the same x86
 *	segment descriptor tables, no two tasks can have the same stack
 *	segment.
 *	
 *	Note carefully the last elements of the initializers. The value
 *	in rgwInstKey is a sentinel, which will always stop the scan
 *	whether the value being sought is a valid stack segment or
 *	zero.
 */

STATIC WORD	  rgwInstKey[cInstMax+1]= { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0xFFFF };
STATIC LPVOID rgpvInst[cInstMax+1]=   { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
STATIC DWORD  rgdwPid[cInstMax+1]=    { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };

STATIC WORD   wCachedKey			= 0;
STATIC LPVOID pvCachedInst			= NULL;

/*
 -	IFindInst
 -	
 *	Purpose:
 *		Used to locate a particular task's instance pointer, and
 *		also to find a free slot in the table.
 *	
 *	Arguments:
 *		The value to look up. This is either a task's stack
 *		segment, or 0 (if an empty slot is being sought).
 *	
 *	Returns:
 *		Returns the index of the given value in rgwInstKey. 
 *		If the value is not present, returns cInstMax.
 *	
 */

#pragma warning(disable: 4035)		/* function return value done in asm */

STATIC int
IFindInst(WORD w)
{
	_asm
	{
		mov cx,cInstMax+1			/* count includes sentinel */
		mov ax,ds					/* point es:di at rgwInstKey */
		mov es,ax
		mov di,OFFSET rgwInstKey
		mov ax,w					/* scan for this value */
		cld							/* scan forward... */
		repne scasw					/* go */
		mov ax,cx					/* Convert the number of items remaining */
		sub ax,cInstMax+1			/* to the index of the item found. */
		inc ax
		neg ax
	}
}

#pragma warning(default: 4035)

/*
 -	PvGetInstanceGlobals
 -	
 *	Purpose:
 *		Returns a pointer to the instance global data structre for
 *		the current task.
 *	
 *	Returns:
 *		Pointer to the instance data structure, or NULL if no
 *		structure has yet been installed for this task.
 */

LPVOID FAR PASCAL
PvGetInstanceGlobals(void)
{
	int iInst;
	WORD wMe;
	
	_asm mov wMe,ss			; get key for this process

	/* First check cached value */
	if (wCachedKey == wMe)
		return pvCachedInst;

	/* Miss, do the lookup */
	iInst = IFindInst(wMe);

	/* Cache and return the found value */
	if (iInst != cInstMax)
	{
		wCachedKey = wMe;
		pvCachedInst = rgpvInst[iInst];
	}
	return rgpvInst[iInst];		/* Note: parallel to the lookup sentinel */
}

LPVOID FAR PASCAL
PvGetVerifyInstanceGlobals(DWORD dwPid)
{
	int iInst;
	WORD wMe;
	
	_asm mov wMe,ss			; get key for this process

	/* Always do the lookup */
	iInst = IFindInst(wMe);

	/* If SS misses, return null right away */
	if (iInst == cInstMax)
		return NULL;

	/* SS hit, now check the OLE process ID */
	if (dwPid != rgdwPid[iInst])
	{
		wCachedKey = 0;			/* Take no chances */
		rgwInstKey[iInst] = 0;
		rgpvInst[iInst] = 0;
		rgdwPid[iInst] = 0;
		return NULL;
	}

	/* Cache and return the found value */
	wCachedKey = wMe;
	pvCachedInst = rgpvInst[iInst];
	return pvCachedInst;
}

LPVOID FAR PASCAL
PvSlowGetInstanceGlobals(DWORD dwPid)
{
	int iInst;
	
	/* Always do the lookup */
	for (iInst = 0; iInst < cInstMax; ++iInst)
	{
		if (rgdwPid[iInst] == dwPid)
			break;
	}

	/* If PID misses, return null */
	if (iInst == cInstMax)
		return NULL;

	/* Return the found value. Do not cache; this function is being
	 * called because SS is not what it "normally" is.
	 */
	return rgpvInst[iInst];
}

/*
 -	ScSetVerifyInstanceGlobals
 -	
 *	Purpose:
 *		Installs or deinstalls instance global data for the current task.
 *	
 *	Arguments:
 *		pv			in		Pointer to instance data structure (to
 *							install); NULL (to deinstall).
 *		dwPid		in		Zero or process ID, for better matching.
 *	
 *	Returns:
 *		MAPI_E_NOT_ENOUGH_MEMORY if no slot is available in the
 *		fixed-size table, else 0.
 */

LONG FAR PASCAL
ScSetVerifyInstanceGlobals(LPVOID pv, DWORD dwPid)
{
	int iInst;
	WORD wMe;

	_asm mov wMe,ss
	if (pv)
	{
		/* I am NOT supposed to be in the array at this time! */
		Assert(IFindInst(wMe) == cInstMax);

		/* Installing instance globals. Find a free slot and park there. */
		iInst = IFindInst(0);
		if (iInst == cInstMax)
		{
#ifdef	DEBUG
			OutputDebugString("Instance globals maxed out\r\n");
#endif	
			return MAPI_E_NOT_ENOUGH_MEMORY;
		}
		rgpvInst[iInst] = pv;
		rgwInstKey[iInst] = wMe;
		rgdwPid[iInst] = dwPid;

		/* Set the cache. */
		wCachedKey = wMe;
		pvCachedInst = pv;
	}
	else
	{
		/* Deinstalling instance globals. Search and destroy. */
		iInst = IFindInst(wMe);
		if (iInst == cInstMax)
		{
#ifdef	DEBUG
			OutputDebugString("No instance globals to reset\r\n");
#endif	
			return MAPI_E_NOT_INITIALIZED;
		}
		rgpvInst[iInst] = NULL;
		rgwInstKey[iInst] = 0;
		rgdwPid[iInst] = 0L;

		/* Clear the cache. */
		wCachedKey = 0;
		pvCachedInst = NULL;
	}

	return 0;
}

LONG FAR PASCAL
ScSetInstanceGlobals(LPVOID pv)
{
	return ScSetVerifyInstanceGlobals(pv, 0L);
}

BOOL __export FAR PASCAL
FCleanupInstanceGlobals(WORD wID, DWORD dwData)
{
	int iInst;
	WORD wMe;

	/*
	 *	Would be nice if we could release the pmalloc
	 *	and the inst structure in this function, but docs say
	 *	don't make Windows calls from this callback.
	 *	That means also NO DEBUG TRACES
	 */

	/*
	 *	First, double-check that the DLL's data segment is available.
	 *	Code snitched from MSDN article "Loading, Initializing, and
	 *	Terminating a DLL."
	 */
	_asm
	{
		push cx
		mov cx, ds			; get selector of interest
		lar ax, cx			; get selector access rights
		pop cx
		jnz bail			; failed, segment is bad
		test ax, 8000h		; if bit 8000 is clear, segment is not loaded
		jz bail				; we're OK
	}

	if (wID == NFY_EXITTASK)
	{
		_asm mov wMe,ss
		iInst = IFindInst(wMe);

		if (iInst < cInstMax)
		{
			/* Clear this process's entry */
			rgpvInst[iInst] = NULL;
			rgwInstKey[iInst] = 0;
		}

		/* Clear the cache too */
		wCachedKey = 0;
		pvCachedInst = NULL;
	}

bail:
	return 0;		/* don't suppress further notifications */
}

#elif defined(_MAC)	/* !WIN16 */

/*
 *	The Mac implementation uses a linked list containing unique keys
 *	to the calling process and pointers to instance data. This linked
 *	list is n-dimensional because the Mac version often groups several
 *	dlls into one exe.
 *
 *	The OLE code that TomSax wrote allows us to keep track of the caller's
 *	%a5 world when we call from another application. This code depends on
 *	on that.
 *
 */

typedef struct tag_INSTDATA	{
	DWORD					dwInstKey;
	DWORD					dwPid;
	LPVOID					lpvInst[kMaxSet];
	struct tag_INSTDATA		*next;
} INSTDATA, *LPINSTDATA, **HINSTDATA;


LPINSTDATA		lpInstHead = NULL;

#define	PvSlowGetInstanceGlobals(_dw, _dwId)	PvGetVerifyInstanceGlobals(_dw, _dwId)

VOID
DisposeInstData(LPINSTDATA lpInstPrev, LPINSTDATA lpInst)
{
	HINSTDATA	hInstHead = &lpInstHead;
	
	/* This better only happen when both elements are NULL! */
	if (lpInst->lpvInst[kInstMAPIX] == lpInst->lpvInst[kInstMAPIU])
	{
		/* No inst data, remove element from linked list */
		if (lpInst == *hInstHead)
			*hInstHead = lpInst->next;
		else
			lpInstPrev->next = lpInst->next;
		DisposePtr((Ptr)lpInst);
	}
}

/*
 -	PvGetInstanceGlobals
 -	
 *	Purpose:
 *		Returns a pointer to the instance global data structre for
 *		the current task.
 *	
 *	Returns:
 *		Pointer to the instance data structure, or NULL if no
 *		structure has yet been installed for this task.
 */

LPVOID FAR PASCAL
PvGetInstanceGlobals(WORD wDataSet)
{
	HINSTDATA		hInstHead = &lpInstHead;
	LPINSTDATA		lpInst = *hInstHead;

#ifdef DEBUG
	if (wDataSet >= kMaxSet)
	{
		DebugStr("\pPvGetInstanceGlobals : This data set has not been defined.");
		return NULL;
	}
#endif

	while (lpInst)
	{
		if (lpInst->dwInstKey == (DWORD)LMGetCurrentA5())
			break;
		lpInst = lpInst->next;
	} 
	return(lpInst->lpvInst[wDataSet]);
}

LPVOID FAR PASCAL
PvGetVerifyInstanceGlobals(DWORD dwPid, DWORD wDataSet)
{
	HINSTDATA	hInstHead = &lpInstHead;
	LPINSTDATA	lpInst, lpInstPrev;

	lpInst = lpInstPrev = *hInstHead;

	/* Always do the lookup */
	while (lpInst)
	{
		if (lpInst->dwInstKey == (DWORD)LMGetCurrentA5())
			break;
		lpInstPrev = lpInst;
		lpInst = lpInst->next;
	}

	/* If PvGetInstanceGlobals() misses, return NULL right away */
	if (lpInst->lpvInst[wDataSet] == NULL)
		return NULL;

	/* Found a match, now check the OLE process ID */
	if (dwPid != lpInst->dwPid)
	{
		DisposeInstData(lpInstPrev, lpInst);
		return NULL;
	}


	/* Return the found value */
	return lpInst->lpvInst[wDataSet];
}

/*
 -	ScSetVerifyInstanceGlobals
 -	
 *	Purpose:
 *		Installs or deinstalls instance global data for the current task.
 *	
 *	Arguments:
 *		pv			in		Pointer to instance data structure (to
 *							install); NULL (to deinstall).
 *		dwPid		in		Zero or process ID, for better matching.
 *		wDataSet	in		Inst data set to init or deinit (MAPIX or MAPIU)
 *	
 *	Returns:
 *		MAPI_E_NOT_ENOUGH_MEMORY if a pointer of INSTDATA size cannot be
 *		created, else 0.
 */

LONG FAR PASCAL
ScSetVerifyInstanceGlobals(LPVOID pv, DWORD dwPid, WORD wDataSet)
{
	HINSTDATA		hInstHead = &lpInstHead;
	LPINSTDATA		lpInst, lpInstPrev;

	lpInst = lpInstPrev = *hInstHead;

	Assert(wDataSet < kMaxSet);

	/* Find our linked list element and the one before it */
	while (lpInst)
	{
		if (lpInst->dwInstKey == (DWORD)LMGetCurrentA5())
			break;
		lpInstPrev = lpInst;
		lpInst = lpInst->next;
	}

	if (pv)
	{
		if (lpInst)
		{
			/* I am NOT supposed to be in the array at this time! */
			Assert(lpInst->lpvInst[wDataSet] == NULL);
			lpInst->lpvInst[wDataSet] = pv;
		}
		else
		{
			/* Add a new linked list element and store <pv> there. */
			lpInst = (LPVOID) NewPtrClear(sizeof(INSTDATA));
			if (!lpInst)
			{
#ifdef	DEBUG
				OutputDebugString("Instance globals maxed out\r");
#endif	
				return MAPI_E_NOT_ENOUGH_MEMORY;
			}
			if (lpInstPrev)
				lpInstPrev->next = lpInst;
			else
				*hInstHead = lpInst;
			lpInst->dwInstKey = (DWORD)LMGetCurrentA5();

			lpInst->dwPid = dwPid;
			lpInst->lpvInst[wDataSet] = pv;
		}
	}
	else
	{
		/* Deinstalling instance globals. Search and destroy. */
		if (lpInst == NULL || lpInst->lpvInst[wDataSet] == NULL)
		{
#ifdef	DEBUG
			OutputDebugString("No instance globals to reset\r");
#endif	
			return MAPI_E_NOT_INITIALIZED;
		}
		/* The memory for <lpInst->lpvInst[wDataSet]> is disposed of	*/
		/* elsewhere. just as it was allocated elsewhere.				*/
		lpInst->lpvInst[wDataSet] = NULL;
		DisposeInstData(lpInstPrev, lpInst);
	}

	return 0;
}


LONG FAR PASCAL
ScSetInstanceGlobals(LPVOID pv, WORD wDataSet)
{
	return ScSetVerifyInstanceGlobals(pv, 0L, wDataSet);
}

BOOL FAR PASCAL
FCleanupInstanceGlobals(WORD wID, DWORD dwData)
{
/*
 * This is no longer used.
 *
 */

#ifdef DEBUG
	DebugStr("\pCalled FCleanupInstanceGlobals : Empty function");
#endif

	return 0;
}

#else /* !WIN16 && !_MAC */

/* This is the entire 32-bit implementation for instance globals. */

VOID FAR *pinstX = NULL;

#endif	/* WIN16 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\initguid.c ===
/**************
**  INITGUID.CPP
**      simply includes initguid.h
**      to instantiate the GUIDs in the other
**      included files
*/

#include "_apipch.h"
#include <initguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\iso8601.c ===
#include <_apipch.h>
#include "iso8601.h"

// This code implements a parser & generater for the ISO 8601 date format.

// This table defines different "types" of characters for use as the columns
// of the state table

unsigned char iso8601chartable[256] = {
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0x82, 0,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

// State table
// 0x80 bit = Error
// 0x20 = Add character & advance to next field
// 0x40 = Add character & advance to next field + skip one (for day of week)
// 0x1f = Mask to determine next state #

// Columns = input character type: unknown, number, "-", "T", ":", "Z"
unsigned char iso8601StateTable[][6] =
{
	0x80, 0x01, 0x25, 0x80, 0x80, 0x80, // year
	0x80, 0x02, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x03, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x24, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x06, 0x05, 0x85, 0x85, 0x05, //0x04 month
	0x80, 0x06, 0x48, 0x80, 0x80, 0x80,
	0x80, 0x47, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x09, 0x08, 0x88, 0x88, 0x08, //0x07 day
	0x80, 0x09, 0x8b, 0x2b, 0x8b, 0x80,
	0x80, 0x2a, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x0c, 0x8b, 0x0b, 0x8b, 0x08, //0x0a hour
	0x80, 0x0c, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x2d, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x0f, 0x8e, 0x8e, 0x0e, 0x08, //0x0d min
	0x80, 0x0f, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x30, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x12, 0x91, 0x91, 0x11, 0x08, //0x10 sec
	0x80, 0x12, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x30, 0x80, 0x80, 0x80, 0x80,
};

HRESULT iso8601ToFileTime(char *pszisoDate, FILETIME *pftTime, BOOL fLenient, BOOL fPartial)
{
    SYSTEMTIME  stTime;
    HRESULT     hr;

    hr = iso8601ToSysTime(pszisoDate, &stTime, fLenient, fPartial);

    if (SUCCEEDED(hr))
    {
        if (SystemTimeToFileTime( &stTime, pftTime))
            return S_OK;
        else
            return E_FAIL;
    }
    return hr;
}

// Convert a character string formatted as iso8601 into a SYSTEMTIME structure
// Supports both basic & extended forms of iso8601.
// isoDate: Input string. It can be null or space terminated.
// pSysTime: Output SYSTEMTIME structure
// fLenient: true for normal operation. "false" if you want to detect incorrectly
//			formatted iso8601. Will still return the "best guess" value.
// fPartial: Set to true if you will accept partial results. Note that this just fills
//			in zeros where data is missing, which strictly speaking can't be distinguished
//			from real zeros in this implementation. An improvement would have a second
//			structure to fill in with validity bits.

HRESULT iso8601ToSysTime(char *pszisoDate, SYSTEMTIME *pSysTime, BOOL fLenient, BOOL fPartial)
{
	HRESULT hr = S_OK;
	WORD *dateWords = (WORD *) pSysTime;
	WORD *endWord = dateWords + 7;	// To detect the end of the date
	int state = 0;
	int pos = 0;
    unsigned char action;

    if (NULL == pszisoDate || NULL == pSysTime)
    {
        if (NULL != pSysTime)
            ZeroMemory(pSysTime, sizeof(SYSTEMTIME));

        return E_INVALIDARG;
    }

	*dateWords = 0;

	// Main state machine loop. Loop until a space or null.
	while(*pszisoDate && *pszisoDate != ' ')
	{
		char code = iso8601chartable[*pszisoDate];
		if(code & 0x80)
			{
			if(!fLenient)
				hr = E_FAIL;	// Illegal character only when lenient
			code = code & 0x7f;
			}
		action = iso8601StateTable[state][code];
		
		state = action&0x1f;	// Calculate the next state

		if(code == 1)	// The character code 1 is always a number which gets accumulated
			*dateWords = *dateWords * 10 + *pszisoDate - '0';
		switch(action >> 5)
		{
		case 0x1:
			if(!fPartial && !*dateWords)
				hr = E_FAIL; // Only partial, error
			if(dateWords == endWord)	// Prevent an overflow
				return S_OK;
			dateWords++;
			*dateWords = 0;
			break;
		case 0x2:	// Finish piece & advance twice (past day of week)
			if(!fPartial && !*dateWords)
				hr = E_FAIL; // Only partial, error

			// We don't need to check for an overflow here since the state machine
			// only calls this to skip "dayofweek" in the SYSTEMTIME structure.
			// We could do dateWords+=2 instead of the following if leaving random
			// values in dayofweek is acceptable.
			dateWords++;
			*dateWords = 0;
			dateWords++;
			*dateWords = 0;
			break;
		}
		if((action & 0x80) && !fLenient)
			hr = E_FAIL;
		pszisoDate++;
	}

	// Zero out the rest of the SYSTEMTIME structure
	while(dateWords < endWord)
		*(++dateWords) = 0;
	return hr;
}

// The function toExtended accepts a FILETIME and converts it into the ISO8601 extended
// form, placeing it in the character buffer 'buf'. The buffer 'buf' must have room for
// a minimum of 40 characters to support the longest forms of 8601 (currently only 21 are used).
HRESULT FileTimeToiso8601(FILETIME *pftTime, char *pszBuf)
{
    SYSTEMTIME  stTime;

    if (NULL == pftTime)
        return E_INVALIDARG;

    if (FileTimeToSystemTime( pftTime, &stTime))
    {
        return SysTimeToiso8601(&stTime, pszBuf);
    }
    else
        return E_FAIL; 
}


// The function toExtended accepts a SYSTEMTIME and converts it into the ISO8601 extended
// form, placeing it in the character buffer 'buf'. The buffer 'buf' must have room for
// a minimum of 40 characters to support the longest forms of 8601 (currently only 21 are used).
HRESULT SysTimeToiso8601(SYSTEMTIME *pstTime, char *pszBuf)
{
    if (NULL == pstTime || NULL == pszBuf)
    {
        if (NULL != pstTime)
            ZeroMemory(pstTime, sizeof(SYSTEMTIME));

        return E_INVALIDARG;
    }

	pszBuf[0] = pstTime->wYear / 1000 + '0';
	pszBuf[1] = ((pstTime->wYear / 100) % 10) + '0';
	pszBuf[2] = ((pstTime->wYear / 10) % 10) + '0';
	pszBuf[3] = ((pstTime->wYear) % 10) + '0';
	pszBuf[4] = '.';
	pszBuf[5] = pstTime->wMonth / 10 + '0';
	pszBuf[6] = (pstTime->wMonth % 10) + '0';
	pszBuf[7] = '.';
	pszBuf[8] = pstTime->wDay / 10 + '0';
	pszBuf[9] = (pstTime->wDay % 10) + '0';
	pszBuf[10] = 'T';
	pszBuf[11] = pstTime->wHour / 10 + '0';
	pszBuf[12] = (pstTime->wHour % 10) + '0';
	pszBuf[13] = ':';
	pszBuf[14] = pstTime->wMinute / 10 + '0';
	pszBuf[15] = (pstTime->wMinute % 10) + '0';
	pszBuf[16] = ':';
	pszBuf[17] = pstTime->wSecond / 10 + '0';
	pszBuf[18] = (pstTime->wSecond % 10) + '0';
	pszBuf[19] = 'Z';
	pszBuf[20] = 0;

	return S_OK;
}


#ifdef STANDALONETEST8601

// This code does some simple tests.
int main(int argc, char **argv)
{
	char *isoDate;
	SYSTEMTIME sysTime;
	char outBuf[256];
	HRESULT hr;

	isoDate = "1997.01.01T14:23:53Z";
	hr = iso8601::toSysTime(isoDate, &sysTime, FALSE);
	if(hr != S_OK)
		printf("error.\n");
	iso8601::toExtended(&sysTime, outBuf);
	printf("%s\n", outBuf);

	isoDate = "19970101T142353Z";
	hr = iso8601::toSysTime(isoDate, &sysTime, FALSE);
	if(hr != S_OK)
		printf("error.\n");
	iso8601::toExtended(&sysTime, outBuf);
	printf("%s\n", outBuf);

	isoDate = "1997:01.01T14:23:53Z";
	hr = iso8601::toSysTime(isoDate, &sysTime, FALSE);
	if(hr != S_OK)
		printf("error (correct).\n");
	iso8601::toExtended(&sysTime, outBuf);
	printf("%s\n", outBuf);

	isoDate = ".01.01T14:23:53Z";
	hr = iso8601::toSysTime(isoDate, &sysTime, FALSE);
	if(hr != S_OK)
		printf("error.\n");
	iso8601::toExtended(&sysTime, outBuf);
	printf("%s\n", outBuf);

	isoDate = "..01T14:23:53Z";
	hr = iso8601::toSysTime(isoDate, &sysTime, FALSE);
	if(hr != S_OK)
		printf("error.\n");
	iso8601::toExtended(&sysTime, outBuf);
	printf("%s\n", outBuf);

	isoDate = "..T14:23:53Z";
	hr = iso8601::toSysTime(isoDate, &sysTime, FALSE);
	if(hr != S_OK)
		printf("error.\n");
	iso8601::toExtended(&sysTime, outBuf);
	printf("%s\n", outBuf);

	return 0;
}
#endif // STANDALONETEST8601
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\imemx.c ===
/*
 *	IMEMX.C
 *	
 *	Per-instance global data for WINNT, WIN95 (trivial), WIN16, and Mac.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#pragma warning(disable:4100)	/* unreferenced formal parameter */
#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4209)	/* benign typedef redefinition */
#pragma warning(disable:4214)	/* bit field types other than int */
#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4115)	/* named type definition in parens */

#ifdef WIN32
#define INC_OLE2 /* Get the OLE2 stuff */
#define INC_RPC  /* harmless on Windows NT; Windows 95 needs it */
#endif
#include "_apipch.h"

#ifdef	DEBUG
#define STATIC
#else
#define STATIC static
#endif

#pragma warning (disable:4514)		/* unreferenced inline function */

#ifdef	WIN16

#pragma code_seg("IMAlloc")

#pragma warning(disable: 4005)		/* redefines MAX_PATH */
#undef MAX_PATH
#include <toolhelp.h>
#pragma warning(default: 4005)

#pragma warning(disable: 4704)		/* Inline assembler */

BOOL
FIsTask(HTASK hTask)
{
        TASKENTRY teT;
        BOOL fSucceed = FALSE;

        teT.dwSize = sizeof(TASKENTRY);

        fSucceed = TaskFirst(&teT);
        while (fSucceed)
        {
                if (hTask == teT.hTask)
                        break;
                fSucceed = TaskNext(&teT);
        }

        return fSucceed;
}

/*
 *	The InstList structure holds three parallel arrays.
 *	InstList.lprgwInstKey
 *		Holds the stack segment of each task that calls
 *		ScSetVerifyInstanceGlobals for the DLL we're in
 *		Since all Win16 tasks share the same x86 segment descriptor tables,
 *		no two tasks can have the same stack segment at the same time.
 *	InstList.lprglpvInst
 *		Holds a pointer to that task's instance globals in the slot with
 *		the same index as the task SS in lprgwInstKey.
 *	InstList.lprglpvInst
 *		Holds a task indentifier that is guaranteed unique to the task through
 *		the life (in memory) of the DLL.  It is at the same index as the
 *		task SS in lprgwInstKey.
 */


/*
 -	IFindInstEx
 -	
 *	Purpose:
 *		Used to locate a particular task's instance pointer, and
 *		also to find a free slot in the table.
 *	
 *	Arguments:
 *		The value to look up. This is either a task's stack
 *		segment, or 0 (if an empty slot is being sought).
 *	
 *	Returns:
 *		Returns the index of the given value in rgwInstKey. 
 *		If the value is not present, returns cInstEntries.
 *	
 */

#pragma warning(disable: 4035)		/* function return value done in asm */

STATIC WORD
IFindInstEx(WORD w, WORD FAR * lprgwInstKey, WORD cInstEntries)
{
#ifdef USE_C_EQUIVALENT
        WORD iInst, * pw = lprgwInstKey;

        for (iInst = 0; iInst < cInstEntries; ++pw, ++iInst)
                if (*pw == w)
                        break;

        return(iInst);
#else
        _asm
        {
                        push    es
                        push    di
                        mov             ax, w
                        mov             cx, cInstEntries
                        mov             bx, cx
                        jcxz    done
                        les             di, lprgwInstKey
                        cld
                        repne   scasw
                        jnz             done
                        sub             bx, cx
                        dec             bx
        done:   mov             ax, bx
                        pop             di
                        pop             es
        };
#endif
}

#pragma warning(default: 4035)

/*
 -	PvGetInstanceGlobalsEx
 -	
 *	Purpose:
 *		Returns a pointer to the instance global data structre for
 *		the current task.
 *	
 *	Returns:
 *		Pointer to the instance data structure, or NULL if no
 *		structure has yet been installed for this task.
 */

LPVOID
PvGetInstanceGlobalsInt(LPInstList lpInstList)
{
	WORD iInst;
	WORD wMe;
	
        // get key for this process
	_asm
        {
             mov wMe,ss
        };

	/* First check cached value */
	if (lpInstList->wCachedKey == wMe)
		return lpInstList->lpvCachedInst;

	// Miss, do the lookup

	iInst = IFindInstEx( wMe
			 , lpInstList->lprgwInstKey
			 , lpInstList->cInstEntries);

	/* Cache and return the found value */
	if (iInst != lpInstList->cInstEntries)
	{
		lpInstList->wCachedKey = wMe;
		return (lpInstList->lpvCachedInst = lpInstList->lprglpvInst[iInst]);
	}

	/*	If I get here then no instance was found
	 */
	return NULL;
}

#if 0
LPVOID
PvGetVerifyInstanceGlobalsInt(DWORD dwPid, LPInstList lpInstList)
{
	WORD iInst;
	WORD wMe;
	
        // get key for this process
	_asm
        {
             mov wMe,ss
        };

	// Always do the lookup
        iInst = IFindInstEx( wMe
					 , lpInstList->lprgwInstKey
					 , lpInstList->cInstEntries);

	/* If SS misses, return null right away */
	if (iInst == lpInstList->cInstEntries)
		return NULL;

	/* SS hit, now check the OLE process ID */
	if (dwPid != lpInstList->lprgdwPID[iInst])
	{
		/* Take no chances.  Remove the entry and reset the cache. */
		lpInstList->wCachedKey = 0;
		lpInstList->lprgwInstKey[iInst] = 0;
		lpInstList->lprglpvInst[iInst] = 0;
		lpInstList->lprgdwPID[iInst] = 0;
		return NULL;
	}

	/* Cache and return the found value.
	 */
	lpInstList->wCachedKey = wMe;
	lpInstList->lpvCachedInst = lpInstList->lprglpvInst[iInst];
	return lpInstList->lpvCachedInst;
}
#endif

LPVOID
PvSlowGetInstanceGlobalsInt(DWORD dwPid, LPInstList lpInstList)
{
	WORD	iInst;
	WORD	cInstEntries = lpInstList->cInstEntries;
	
	/* Always do the lookup */
	for (iInst = 0; iInst < cInstEntries; ++iInst)
	{
		if (lpInstList->lprgdwPID[iInst] == dwPid)
			break;
	}

	/* If PID misses, return null */
	if (iInst == cInstEntries)
		return NULL;

	/* Return the found value. Do not cache; this function is being
	 * called because SS is not what it "normally" is.
	 */
	return lpInstList->lprglpvInst[iInst];
}

/*
 -	ScSetVerifyInstanceGlobalsInt
 -	
 *	Purpose:
 *		Installs or deinstalls instance global data for the current task.
 *	
 *	Arguments:
 *		pv			in		Pointer to instance data structure (to
 *							install); NULL (to deinstall).
 *		dwPid		in		Zero or process ID, for better matching.
 *	
 *	Returns:
 *		MAPI_E_NOT_ENOUGH_MEMORY if no slot is available in the
 *		fixed-size table, else 0.
 */

LONG
ScSetVerifyInstanceGlobalsInt(LPVOID pv, DWORD dwPid, LPInstList lpInstList)
{
	WORD	iInst;
	WORD	wMe;
	WORD	cInstEntries = lpInstList->cInstEntries;

        // get key for this process
	_asm
        {
             mov wMe,ss
        };

	if (pv)
	{
		/* I am NOT supposed to be in the array at this time! */
		Assert(   IFindInstEx(wMe, lpInstList->lprgwInstKey, cInstEntries)
			   == cInstEntries);

		/* Installing instance globals. Find a free slot and park there. */
		Assert(cInstEntries || (lpInstList->dwInstFlags && INST_ALLOCATED));
		if (!cInstEntries)
		{
			DWORD	cbMem =   cInstChunk
							* (sizeof(WORD) + sizeof(LPVOID) + sizeof(DWORD)
							+ sizeof(HTASK)); 	// raid 31090 lprghTask;
			
			if (!(lpInstList->lprgwInstKey
						 = (WORD FAR *) GlobalAllocPtr( GPTR | GMEM_SHARE
						 							  , cbMem)))
			{
#ifdef	DEBUG
				OutputDebugString("Instance list can't be allocated.\r\n");
#endif	
				return MAPI_E_NOT_ENOUGH_MEMORY;
			}

			ZeroMemory( lpInstList->lprgwInstKey, (size_t) cbMem);

			lpInstList->cInstEntries = cInstEntries = cInstChunk;

			lpInstList->lprglpvInst = (LPVOID FAR *) (lpInstList->lprgwInstKey + cInstEntries);
			lpInstList->lprgdwPID =   (DWORD FAR *)  (lpInstList->lprglpvInst  + cInstEntries);
			lpInstList->lprghTask =   (HTASK FAR *)  (lpInstList->lprgdwPID    + cInstEntries);
		}

		iInst = IFindInstEx(0, lpInstList->lprgwInstKey, cInstEntries);
		if (iInst == cInstEntries)
		{
			UINT uidx;

			// raid 31090: Time to do some scavanging.  Find a HTASK that isn't
			// valid and use that slot.

			for ( uidx = 0; uidx < cInstEntries; uidx++ )
			{
	   			if ( !lpInstList->lprghTask[uidx] || !FIsTask( lpInstList->lprghTask[uidx] ) )
				{
					// found one

					iInst = uidx;
					break;
				}
			}

			if ( uidx == cInstEntries )
			{
				DebugTrace( "MAPI: ScSetVerifyInstanceGlobalsInt maxed out instance data and tasks can't be scavanged\n" );
				return MAPI_E_NOT_ENOUGH_MEMORY;
			}
		}

		// set the instance data

		lpInstList->lprglpvInst[iInst] = pv;
		lpInstList->lprgwInstKey[iInst] = wMe;
		lpInstList->lprgdwPID[iInst] = dwPid;
		lpInstList->lprghTask[iInst] = GetCurrentTask();

		/* Set the cache. */
		lpInstList->wCachedKey = wMe;
		lpInstList->lpvCachedInst = pv;
	}
	else
	{
		/* Deinstalling instance globals. Search and destroy. */
		iInst = IFindInstEx(wMe, lpInstList->lprgwInstKey, cInstEntries);
		if (iInst == cInstEntries)
		{
#ifdef	DEBUG
			OutputDebugString("No instance globals to reset\r\n");
#endif	
			return MAPI_E_NOT_INITIALIZED;
		}
		lpInstList->lprglpvInst[iInst] = NULL;
		lpInstList->lprgwInstKey[iInst] = 0;
		lpInstList->lprgdwPID[iInst] = 0L;

		/* Clear the cache. */
		lpInstList->wCachedKey = 0;
		lpInstList->lpvCachedInst = NULL;
	}

	return 0;
}

LONG
ScSetInstanceGlobalsInt(LPVOID pv, LPInstList lpInstList)
{
	return ScSetVerifyInstanceGlobalsInt(pv, 0L, lpInstList);
}

BOOL __export FAR PASCAL
FCleanupInstanceGlobalsInt(LPInstList lpInstList)
{
	/*
	 *	The docs say don't make Windows calls from this callback.
	 *	That means NO DEBUG TRACES
	 */

/*	This code belongs in the WEP */
	/*
	 *	First, double-check that the DLL's data segment is available.
	 *	Code snitched from MSDN article "Loading, Initializing, and
	 *	Terminating a DLL."
	 */
/*
	_asm
	{
		push cx
		mov cx, ds			; get selector of interest
		lar ax, cx			; get selector access rights
		pop cx
		jnz bail			; failed, segment is bad
		test ax, 8000h		; if bit 8000 is clear, segment is not loaded
		jz bail				; we're OK
	};
*/

	//$DEBUG	Assert non-zero entries here

	if (   (lpInstList->dwInstFlags & INST_ALLOCATED)
		&& lpInstList->cInstEntries
		&& lpInstList->lprgwInstKey)
	{
		GlobalFreePtr(lpInstList->lprgwInstKey);
		lpInstList->cInstEntries = lpInstList->wCachedKey
							 = 0;
		lpInstList->lprgwInstKey = NULL;
		lpInstList->lprglpvInst = NULL;
		lpInstList->lprgdwPID = NULL;
		lpInstList->lpvCachedInst = NULL;
	}

	return 0;		/* don't suppress further notifications */
}

#elif defined(MAC)	/* !WIN16 */

/*
 *	The Mac implementation uses a linked list containing unique keys
 *	to the calling process and pointers to instance data. This linked
 *	list is n-dimensional because the Mac version often groups several
 *	dlls into one exe.
 *
 *	The OLE code that TomSax wrote allows us to keep track of the caller's
 *	%a5 world when we call from another application. This code depends on
 *	on that.
 *
 */

typedef struct tag_INSTDATA	{
	DWORD					dwInstKey;
	DWORD					dwPid;
	LPVOID					lpvInst[kMaxSet];
	struct tag_INSTDATA		*next;
} INSTDATA, *LPINSTDATA, **HINSTDATA;


LPINSTDATA		lpInstHead = NULL;

#define	PvSlowGetInstanceGlobals(_dw, _dwId)	PvGetVerifyInstanceGlobals(_dw, _dwId)

VOID
DisposeInstData(LPINSTDATA lpInstPrev, LPINSTDATA lpInst)
{
	HINSTDATA	hInstHead = &lpInstHead;
	
	/* This better only happen when both elements are NULL! */
	if (lpInst->lpvInst[kInstMAPIX] == lpInst->lpvInst[kInstMAPIU])
	{
		/* No inst data, remove element from linked list */
		if (lpInst == *hInstHead)
			*hInstHead = lpInst->next;
		else
			lpInstPrev->next = lpInst->next;
		DisposePtr((Ptr)lpInst);
	}
}

/*
 -	PvGetInstanceGlobalsMac
 -	
 *	Purpose:
 *		Returns a pointer to the instance global data structre for
 *		the current task.
 *	
 *	Returns:
 *		Pointer to the instance data structure, or NULL if no
 *		structure has yet been installed for this task.
 */

LPVOID FAR PASCAL
PvGetInstanceGlobalsMac(WORD wDataSet)
{
	HINSTDATA		hInstHead = &lpInstHead;
	LPINSTDATA		lpInst = *hInstHead;

#ifdef DEBUG
	if (wDataSet >= kMaxSet)
	{
		DebugStr("\pPvGetInstanceGlobals : This data set has not been defined.");
		return NULL;
	}
#endif

	while (lpInst)
	{
		if (lpInst->dwInstKey == (DWORD)LMGetCurrentA5())
			break;
		lpInst = lpInst->next;
	} 
	if (lpInst == NULL)
		return NULL;
	return(lpInst->lpvInst[wDataSet]);
}

LPVOID FAR PASCAL
PvGetVerifyInstanceGlobals(DWORD dwPid, DWORD wDataSet)
{
	HINSTDATA	hInstHead = &lpInstHead;
	LPINSTDATA	lpInst, lpInstPrev;

	lpInst = lpInstPrev = *hInstHead;

	/* Always do the lookup */
	while (lpInst)
	{
		if (lpInst->dwInstKey == (DWORD)LMGetCurrentA5())
			break;
		lpInstPrev = lpInst;
		lpInst = lpInst->next;
	}

	/* If PvGetInstanceGlobals() misses, return NULL right away */
	if ((lpInst == NULL) || (lpInst->lpvInst[wDataSet] == NULL))
		return NULL;

	/* Found a match, now check the OLE process ID */
	if (dwPid != lpInst->dwPid)
	{
		DisposeInstData(lpInstPrev, lpInst);
		return NULL;
	}


	/* Return the found value */
	return lpInst->lpvInst[wDataSet];
}

/*
 -	ScSetVerifyInstanceGlobals
 -	
 *	Purpose:
 *		Installs or deinstalls instance global data for the current task.
 *	
 *	Arguments:
 *		pv			in		Pointer to instance data structure (to
 *							install); NULL (to deinstall).
 *		dwPid		in		Zero or process ID, for better matching.
 *		wDataSet	in		Inst data set to init or deinit (MAPIX or MAPIU)
 *	
 *	Returns:
 *		MAPI_E_NOT_ENOUGH_MEMORY if a pointer of INSTDATA size cannot be
 *		created, else 0.
 */

LONG FAR PASCAL
ScSetVerifyInstanceGlobals(LPVOID pv, DWORD dwPid, WORD wDataSet)
{
	HINSTDATA		hInstHead = &lpInstHead;
	LPINSTDATA		lpInst, lpInstPrev;

	lpInst = lpInstPrev = *hInstHead;

	Assert(wDataSet < kMaxSet);

	/* Find our linked list element and the one before it */
	while (lpInst)
	{
		if (lpInst->dwInstKey == (DWORD)LMGetCurrentA5())
			break;
		lpInstPrev = lpInst;
		lpInst = lpInst->next;
	}

	if (pv)
	{
		if (lpInst)
		{
			/* I am NOT supposed to be in the array at this time! */
			Assert(lpInst->lpvInst[wDataSet] == NULL);
			lpInst->lpvInst[wDataSet] = pv;
		}
		else
		{
			/* Add a new linked list element and store <pv> there. */
			lpInst = (LPVOID) NewPtrClear(sizeof(INSTDATA));
			if (!lpInst)
			{
#ifdef	DEBUG
				OutputDebugString("Instance globals maxed out\r");
#endif	
				return MAPI_E_NOT_ENOUGH_MEMORY;
			}
			if (lpInstPrev)
				lpInstPrev->next = lpInst;
			else
				*hInstHead = lpInst;
			lpInst->dwInstKey = (DWORD)LMGetCurrentA5();

			lpInst->dwPid = dwPid;
			lpInst->lpvInst[wDataSet] = pv;
		}
	}
	else
	{
		/* Deinstalling instance globals. Search and destroy. */
		if (lpInst == NULL || lpInst->lpvInst[wDataSet] == NULL)
		{
#ifdef	DEBUG
			OutputDebugString("No instance globals to reset\r");
#endif	
			return MAPI_E_NOT_INITIALIZED;
		}
		/* The memory for <lpInst->lpvInst[wDataSet]> is disposed of	*/
		/* elsewhere. just as it was allocated elsewhere.				*/
		lpInst->lpvInst[wDataSet] = NULL;
		DisposeInstData(lpInstPrev, lpInst);
	}

	return 0;
}


LONG FAR PASCAL
ScSetInstanceGlobalsMac(LPVOID pv, WORD wDataSet)
{
	return ScSetVerifyInstanceGlobals(pv, 0L, wDataSet);
}

BOOL FAR PASCAL
FCleanupInstanceGlobals(WORD wID, DWORD dwData)
{
/*
 * This is no longer used.
 *
 */

#ifdef DEBUG
	DebugStr("\pCalled FCleanupInstanceGlobals : Empty function");
#endif

	return 0;
}

#elif defined(_WINNT)

/* NT implementation of instance list stuff goes here */

//	A new instance list is defined using "DefineInst(instance_name)"
//	A new instance list is declared using "DeclareInst(instance_name);"
//
//	You then access them using the functions below (through macros
//	in _imemx.h)

//	Access to the instance lists must be serialized

CRITICAL_SECTION	csInstance;

//
//	Each security context has its own instance.  So that we can find
//	the right instance data for a particular security context at any
//	time, we maintain a global mapping of security contexts to instances
//	called the instance list.  Entries in the instance list appear in no
//	particular order.  That is, the list must always be searched linearly.
//	It is expected that the number of security contexts is sufficiently
//	small that a linear search is not a performance problem.
//
//	Each entry in the instance list is just a struct which identifies a
//	security context and its associated instance.
//
typedef struct _MAPI_INSTANCE_DESCRIPTOR
{
	ULARGE_INTEGER	uliSecurity;	// Security context identifier
	LPVOID			lpInstance;		// Pointer to associated instance data

} MAPI_INSTANCE_DESCRIPTOR, *LPMAPI_INSTANCE_DESCRIPTOR;

typedef struct _MAPI_INSTANCE_LIST
{
	UINT	cDescriptorsMax;	// How many descriptors are in the array
	UINT	cDescriptorsMac;	// How many are currently in use
	MAPI_INSTANCE_DESCRIPTOR rgDescriptors[0];

} MAPI_INSTANCE_LIST, *LPMAPI_INSTANCE_LIST;

enum { INSTANCE_LIST_CHUNKSIZE = 20 };

#define NEW_INSTANCE

#if defined(NEW_INSTANCE)

/*
 -	UlCrcSid
 -
 *	Purpose:
 *		compute a CRC-32 based on a seed and value
 *
 *		Ripped from runt.c because we don't want to introduce all of
 *		that files dependencies just for one function
 *
 *	Arguments:
 *		cb		size of data to hash
 *		pb		data to hash
 *
 *	Returns:
 *		new seed value
 *
 *	Source:
 *		UlCrc() in \mapi\src\common\runt.c
 */

static ULONG
UlCrcSid(UINT cb, LPBYTE pb)
{
	int iLoop;
	int bit;
	DWORD dwSeed = 0;
	BYTE bValue;

	Assert(!IsBadReadPtr(pb, cb));

	while (cb--)
	{
		bValue = *pb++;

		dwSeed ^= bValue;
		for (iLoop = 0; iLoop < 8; iLoop++)
		{
			bit = (int)(dwSeed & 0x1);
			dwSeed >>= 1;
			if (bit)
				dwSeed ^= 0xedb88320;
		}
	}

	return dwSeed;
}

/*++

Routine Description:

	Returns the size and CRC of the SID that this code is running in the 
	account of.  Should make a pretty good 64-bit number to uniqify by.
	
Arguments:
	None

Return Value:
	BOOL - if everything worked.  Call the systems GetLastError() if
	it didn't.
	*lpulSize - size of the SID
	*lpulCRC - CRC-32 of the SID

	!!! This function is duplicated in \mapi\src\glh\glglobal.c
	!!! We really need to put it in a static LIB!

--*/

static
BOOL WINAPI GetAccountCRC( ULONG *lpulSize, ULONG *lpulCRC)
{

	BOOL	fHappen = FALSE;  // Assume the function failed
	HANDLE	hTok	= NULL;

// max size of sid + TOKEN_USER base

#define TOKENBUFFSIZE (256*6) + sizeof (TOKEN_USER)


	BYTE	tokenbuff[TOKENBUFFSIZE];
	ULONG	ulcbTok = TOKENBUFFSIZE;

	TOKEN_USER *ptu = (TOKEN_USER *) tokenbuff;

	//	Open the process and the process token, and get out the
	//	security ID.

	if (!OpenThreadToken(GetCurrentThread(),
						TOKEN_QUERY, TRUE,  //$ TRUE for Process security!
						&hTok))
	{
		if (!OpenThreadToken(GetCurrentThread(),
						TOKEN_QUERY, FALSE,  // Sometimes process security doesn't work!
						&hTok))
		{
			if (!OpenProcessToken(GetCurrentProcess(),
							TOKEN_QUERY,
							&hTok))					  
				goto out;
		}
	}

	fHappen = GetTokenInformation(hTok,
								TokenUser,
								ptu,
								ulcbTok,
								&ulcbTok);

#ifdef DEBUG

	AssertSz1 (fHappen, "GetTokenInformation fails with error %lu", GetLastError());

	if ( fHappen &&
		 GetPrivateProfileInt("General", "TraceInstContext", 0, "mapidbg.ini") )
	{
		DWORD			dwAccount;
		CHAR			rgchAccount[MAX_PATH+1];
		DWORD			dwDomain;
		CHAR			rgchDomain[MAX_PATH+1];
		SID_NAME_USE	snu;

		dwAccount = sizeof(rgchAccount);
		dwDomain  = sizeof(rgchDomain);

		if ( LookupAccountSid( NULL,
							   ptu->User.Sid,
							   rgchAccount,
							   &dwAccount,
							   rgchDomain,
							   &dwDomain,
							   &snu ) )
		{
			DebugTrace( "Locating MAPI instance for %s:%s\n", rgchDomain, rgchAccount );
		}
	}
#endif

	//
	//	We should have the TOKEN_USER data now. Get the size of the
	//	contained SID then calculate its CRC.
	//

	if (fHappen && ulcbTok != 0 && (ptu->User.Sid != NULL))
	{
		*lpulSize = GetLengthSid (ptu->User.Sid);
		*lpulCRC = UlCrcSid(*lpulSize, (LPBYTE) ptu->User.Sid);
	}
#ifdef DEBUG
	else
		AssertSz (FALSE, "GetAccountCRC failed to get the SID");
#endif

out:
	if (hTok)
		CloseHandle(hTok);

	return fHappen;

}


/*
 -	ForeachInstance() [EXTERNAL]
 -
 *	Purpose:
 *		Iterates over all instances in an instance list
 *		performing the specified action on each
 *
 *	Arguments:
 *		pfnAction		Action to do for each instance.  Must be
 *						a void function taking a pointer to
 *						instance data as a parameter.
 *		lpInstList		Instance list
 *
 *	Returns:
 *		nothing
 */

VOID FAR PASCAL
ForeachInstance( INSTACTION *	pfnAction,
				 LPVOID			pvInstList )
{
	UINT	iDescriptor;


	//
	//	If there's no descriptor list, then there are obviously
	//	no descriptors and hence no instances to which an
	//	action can be applied.
	//
	if ( pvInstList == NULL )
		goto ret;

	//
	//	Trundle down the descriptor list applying the
	//	specified action to each instance therein.
	//
	for ( iDescriptor = 0;
		  iDescriptor < ((LPMAPI_INSTANCE_LIST) pvInstList)->cDescriptorsMac;
		  iDescriptor++ )
	{
		pfnAction( ((LPMAPI_INSTANCE_LIST) pvInstList)->rgDescriptors[iDescriptor].lpInstance );
	}

ret:
	return;
}



/*
 -	LpFindInstanceDescriptor()
 -
 *	Purpose:
 *		Looks in the instance descriptor list for an instance
 *		descriptor corresponding to the specified security
 *		context.
 *
 *	Arguments:
 *		lpInstList		Instance list
 *		uliSecurity		CRC'd security context
 *
 *	Returns:
 *		A pointer to the instance descriptor or NULL if there is
 *		no instance descriptor for the specified security context.
 */

LPMAPI_INSTANCE_DESCRIPTOR
LpFindInstanceDescriptor( LPMAPI_INSTANCE_LIST	lpInstList,
						  ULARGE_INTEGER		uliSecurity )
{
	LPMAPI_INSTANCE_DESCRIPTOR	lpDescriptorFound = NULL;
	UINT						iDescriptor;


	//
	//	If there's no descriptor list, then there are obviously
	//	no descriptors matching this security context.
	//
	if ( lpInstList == NULL )
		goto ret;

	//
	//	Trundle down the descriptor list looking for our context.
	//	If we find it, then return its associated descriptor.
	//
	for ( iDescriptor = 0;
		  iDescriptor < lpInstList->cDescriptorsMac;
		  iDescriptor++ )
	{
		if ( lpInstList->rgDescriptors[iDescriptor].uliSecurity.QuadPart ==
			 uliSecurity.QuadPart )
		{
			lpDescriptorFound = &lpInstList->rgDescriptors[iDescriptor];
			break;
		}
	}

ret:
	return lpDescriptorFound;
}


/*
 -	ScNewInstanceDescriptor()
 -
 *	Purpose:
 *		Creates a new instance descriptor in the instance descriptor list,
 *		allocating or growing the list as necessary.
 *
 *	Arguments:
 *		plpInstList			Pointer to instance list
 *		uliSecurity			CRC'd security context
 *		pvInstance			Associated instance
 *		plpDescriptorNew	Pointer to returned descriptor
 *
 *	Returns:
 *		A pointer to a new 0-filled instance descriptor added to
 *		to the instance descriptor list.
 */

__inline UINT
CbNewInstanceList( UINT cDescriptors )
{
	return offsetof(MAPI_INSTANCE_LIST, rgDescriptors) +
		   sizeof(MAPI_INSTANCE_DESCRIPTOR) * cDescriptors;
}

SCODE
ScNewInstanceDescriptor( LPMAPI_INSTANCE_LIST *			plpInstList,
						 ULARGE_INTEGER					uliSecurity,
						 LPVOID							pvInstance,
						 LPMAPI_INSTANCE_DESCRIPTOR *	plpDescriptorNew )
{
	LPMAPI_INSTANCE_DESCRIPTOR	lpDescriptor = NULL;
	SCODE						sc           = S_OK;


	Assert( !IsBadWritePtr( plpInstList, sizeof(LPMAPI_INSTANCE_LIST) ) );
	Assert( !IsBadWritePtr( plpDescriptorNew, sizeof(LPMAPI_INSTANCE_DESCRIPTOR) ) );

	//
	//	Allocate/Grow the descriptor list if necessary.
	//
	if ( *plpInstList == NULL ||
		 (*plpInstList)->cDescriptorsMac == (*plpInstList)->cDescriptorsMax )
	{
		LPMAPI_INSTANCE_LIST	lpInstListNew;


		lpInstListNew = (*plpInstList == NULL) ?

			HeapAlloc( GetProcessHeap(),
					   HEAP_ZERO_MEMORY,
					   CbNewInstanceList( INSTANCE_LIST_CHUNKSIZE ) ) :

			HeapReAlloc( GetProcessHeap(),
						 HEAP_ZERO_MEMORY,
						 *plpInstList,
						 CbNewInstanceList( INSTANCE_LIST_CHUNKSIZE +
											(*plpInstList)->cDescriptorsMax ) );

		if ( lpInstListNew == NULL )
		{
			DebugTrace( "ScNewInstanceDescriptor() - Error allocating/growing descriptor list (%d)\n", GetLastError() );
			sc = MAPI_E_NOT_ENOUGH_MEMORY;
			goto ret;
		}

		*plpInstList = lpInstListNew;
		(*plpInstList)->cDescriptorsMax += INSTANCE_LIST_CHUNKSIZE;
	}

	//
	//	Grab the next available descriptor
	//
	*plpDescriptorNew = &(*plpInstList)->rgDescriptors[
							(*plpInstList)->cDescriptorsMac];

	++(*plpInstList)->cDescriptorsMac;

	//
	//	Fill in its security context and instance
	//
	(*plpDescriptorNew)->uliSecurity = uliSecurity;
	(*plpDescriptorNew)->lpInstance  = pvInstance;

ret:
	return sc;
}


/*
 -	DeleteInstanceDescriptor()
 -
 *	Purpose:
 *		Removes the specified instance descriptor from the instance
 *		descriptor list.  Frees and re-NULLs the list when the last
 *		descriptor is removed.
 *
 *	Arguments:
 *		plpInstList		Pointer to instance descriptor list
 *		lpDescriptor	Descriptor to remove
 *
 *	Returns:
 *		Nothing.
 */

VOID
DeleteInstanceDescriptor( LPMAPI_INSTANCE_LIST *		plpInstList,
						  LPMAPI_INSTANCE_DESCRIPTOR	lpDescriptor )
{
	Assert( !IsBadWritePtr(plpInstList, sizeof(LPMAPI_INSTANCE_LIST)) );
	Assert( *plpInstList != NULL );
	Assert( lpDescriptor >= (*plpInstList)->rgDescriptors );
	Assert( lpDescriptor <  (*plpInstList)->rgDescriptors + (*plpInstList)->cDescriptorsMac );
	Assert( ((LPBYTE)lpDescriptor - (LPBYTE)(*plpInstList)->rgDescriptors) %
			sizeof(MAPI_INSTANCE_DESCRIPTOR) == 0 );

	MoveMemory( lpDescriptor,
				lpDescriptor + 1,
				sizeof(MAPI_INSTANCE_DESCRIPTOR) *
					((*plpInstList)->cDescriptorsMac -
					 ((lpDescriptor - (*plpInstList)->rgDescriptors) + 1) ) );

	--(*plpInstList)->cDescriptorsMac;

	if ( (*plpInstList)->cDescriptorsMac == 0 )
	{
		HeapFree( GetProcessHeap(), 0, *plpInstList );
		*plpInstList = NULL;
	}
}


/*
 -	PvGetInstanceGlobalsExInt() [EXTERNAL]
 -
 *	Purpose:
 *		Fetch the instance globals for the current security context.
 *
 *	Arguments:
 *		ppvInstList		Transparent pointer to instance descriptor list
 *
 *	Returns:
 *		Pointer to the instance globals.
 */

LPVOID FAR PASCAL
PvGetInstanceGlobalsExInt (LPVOID * ppvInstList)
{
	LPMAPI_INSTANCE_DESCRIPTOR	lpDescriptor;
	ULARGE_INTEGER				uliSecurity;
	LPVOID						lpvInstanceRet = NULL;


	EnterCriticalSection (&csInstance);

	//
	//	Get our security context.
	//
	SideAssertSz1(
		GetAccountCRC (&uliSecurity.LowPart, &uliSecurity.HighPart) != 0,

		"PvGetInstanceGlobalsExInt: Failed to get account info (%d)",
		GetLastError() );

	//
	//	Look for a descriptor in the descriptor list
	//	with our security context.
	//
	lpDescriptor = LpFindInstanceDescriptor( *ppvInstList, uliSecurity );

	//
	//	If we find one, then return its associated instance.
	//	Return NULL if we didn't find one.
	//
	if ( lpDescriptor != NULL )
		lpvInstanceRet = lpDescriptor->lpInstance;

	LeaveCriticalSection (&csInstance);
	return lpvInstanceRet;
}


/*
 -	ScSetInstanceGlobalsExInt() [EXTERNAL]
 -
 *	Purpose:
 *		Assigns (new) instance globals for the current security context.
 *
 *	Arguments:
 *		pvInstNew		Instance globals
 *		ppvInstList		Transparent pointer to instance descriptor list
 *
 *	Returns:
 *		Success or failure SCODE.
 */

SCODE FAR PASCAL
ScSetInstanceGlobalsExInt (LPVOID pvInstNew, LPVOID *ppvInstList)
{
	LPMAPI_INSTANCE_DESCRIPTOR	lpDescriptor;
	ULARGE_INTEGER				uliSecurity;
	SCODE						sc = S_OK;


	EnterCriticalSection (&csInstance);

	//
	//	Get our security context.
	//
	SideAssertSz1(
		GetAccountCRC (&uliSecurity.LowPart, &uliSecurity.HighPart) != 0,

		"ScSetInstanceGlobalsExInt: Failed to get account info (%d)",
		GetLastError() );

	//
	//	Look for a descriptor in the descriptor list
	//	with our security context.
	//
	lpDescriptor = LpFindInstanceDescriptor( *ppvInstList, uliSecurity );

	//
	//	If we find one then replace its instance
	//
	if ( lpDescriptor != NULL )
	{
		lpDescriptor->lpInstance = pvInstNew;
	}

	//
	//	If we don't find a descriptor then create a new one
	//	for this security context and instance
	//
	else
	{
		sc = ScNewInstanceDescriptor( (LPMAPI_INSTANCE_LIST *) ppvInstList,
									  uliSecurity,
									  pvInstNew,
									  &lpDescriptor );

		if ( sc != S_OK )
		{
			DebugTrace( "Error creating new instance descriptor (%s)\n", SzDecodeScode(sc) );
			goto ret;
		}
	}

ret:
	LeaveCriticalSection (&csInstance);
	return sc;
}


/*
 -	ScDeleteInstanceGlobalsExInt() [EXTERNAL]
 -
 *	Purpose:
 *		Uninstalls instance globals for the current security context.
 *
 *	Arguments:
 *		ppvInstList		Transparent pointer to instance descriptor list
 *
 *	Returns:
 *		S_OK
 */

SCODE FAR PASCAL
ScDeleteInstanceGlobalsExInt (LPVOID *ppvInstList)
{
	LPMAPI_INSTANCE_DESCRIPTOR	lpDescriptor;
	ULARGE_INTEGER				uliSecurity;


	EnterCriticalSection (&csInstance);

	//
	//	Get our security context.
	//
	SideAssertSz1(
		GetAccountCRC (&uliSecurity.LowPart, &uliSecurity.HighPart) != 0,

		"ScDeleteInstanceGlobalsExInt: Failed to get account info (%d)",
		GetLastError() );

	//
	//	Look for a descriptor in the descriptor list
	//	with our security context.
	//
	lpDescriptor = LpFindInstanceDescriptor( *ppvInstList, uliSecurity );

	//
	//	If we find one, then remove it from the list.  Don't worry if we
	//	don't find one.  We may be cleaning up after a failed initialization.
	//
	if ( lpDescriptor != NULL )
		DeleteInstanceDescriptor( (LPMAPI_INSTANCE_LIST *) ppvInstList,
								  lpDescriptor );

	LeaveCriticalSection (&csInstance);
	return S_OK;
}

#else	// !defined(NEW_INSTANCE)

SCODE FAR PASCAL
ScSetInstanceGlobalsExInt (LPVOID pvInstNew, LPVOID *ppvInstList)
{
	*ppvInstList = pvInstNew;
	return S_OK;
}

LPVOID FAR PASCAL
PvGetInstanceGlobalsExInt (LPVOID *ppvInstList)
{
	lpvReturn = *ppvInstList;
}

SCODE FAR PASCAL
ScDeleteInstanceGlobalsExInt (LPVOID *ppvInstList)
{
	*ppvInstList = NULL;
	return S_OK;
}

#endif	// !defined(NEW_INSTANCE)

#elif defined(_WIN95)

/* There is nothing to do here for Win95.
 * Using "DefineInst(pinstX)" to define your instance pointer
 * and "DeclareInst(pinstX)" to declare external refs is enough.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\iprop.c ===
/*
 *      IPROP.C
 *
 *      IProperty in memory
 */
#include "_apipch.h"

// #pragma SEGMENT(IProp)

//
//  IPropData jump table is defined here...
//


IPDAT_Vtbl vtblIPDAT = {
        VTABLE_FILL
        (IPDAT_QueryInterface_METHOD FAR *)     UNKOBJ_QueryInterface,
        (IPDAT_AddRef_METHOD FAR *)                     UNKOBJ_AddRef,
        IPDAT_Release,
        (IPDAT_GetLastError_METHOD FAR *)       UNKOBJ_GetLastError,
        IPDAT_SaveChanges,
        IPDAT_GetProps,
        IPDAT_GetPropList,
        IPDAT_OpenProperty,
        IPDAT_SetProps,
        IPDAT_DeleteProps,
        IPDAT_CopyTo,
        IPDAT_CopyProps,
        IPDAT_GetNamesFromIDs,
        IPDAT_GetIDsFromNames,
        IPDAT_HrSetObjAccess,
        IPDAT_HrSetPropAccess,
        IPDAT_HrGetPropAccess,
        IPDAT_HrAddObjProps
};

/* Interface which can be queried fro lpIPDAT.
 *
 * It is important that the order of the interfaces supported be preserved
 * and that IID_IUnknown be the last in the list.
 */
IID const FAR * argpiidIPDAT[] =
{
    &IID_IMAPIPropData,
    &IID_IMAPIProp,
    &IID_IUnknown
};

#define CIID_IPROP_INHERITS         1
#define CIID_IPROPDATA_INHERITS     2

/*
 * Utility functions/macros used by iprop.
 */

#define AlignPropVal(_cb)       Align8(_cb)

SCODE
ScDupNameID(LPIPDAT lpIPDAT,
                    LPVOID lpvBaseAlloc,
                    LPMAPINAMEID lpNameSrc,
                    LPMAPINAMEID * lppNameDest)
{
        SCODE sc;

        //
        //  Allocate space for the name
        //
        sc = UNKOBJ_ScAllocateMore( (LPUNKOBJ) lpIPDAT,
                                                                sizeof(MAPINAMEID),
                                                                lpvBaseAlloc,
                                                                lppNameDest);
        if (FAILED(sc))
        {
                goto err;
        }
        MemCopy(*lppNameDest, lpNameSrc, sizeof(MAPINAMEID));

        //
        //  Copy the lpguid
        //
        sc = UNKOBJ_ScAllocateMore( (LPUNKOBJ) lpIPDAT,
                                                                sizeof(GUID),
                                                                lpvBaseAlloc,
                                                                &((*lppNameDest)->lpguid));
        if (FAILED(sc))
        {
                goto err;
        }
        MemCopy((*lppNameDest)->lpguid, lpNameSrc->lpguid, sizeof(GUID));

        //
        //  conditionally copy the string
        //
        if (lpNameSrc->ulKind == MNID_STRING)
        {
                UINT cbString;

                cbString = (lstrlenW(lpNameSrc->Kind.lpwstrName)+1)*sizeof(WCHAR);

                //
                //  Copy the lpwstrName
                //
                sc = UNKOBJ_ScAllocateMore( (LPUNKOBJ) lpIPDAT,
                                                                        cbString,
                                                                        lpvBaseAlloc,
                                                                        &((*lppNameDest)->Kind.lpwstrName));
                if (FAILED(sc))
                {
                        goto err;
                }
                MemCopy((*lppNameDest)->Kind.lpwstrName,
                                lpNameSrc->Kind.lpwstrName,
                                cbString);
        }

out:
        return sc;

err:
        goto out;
}

SCODE
ScMakeMAPINames(LPIPDAT lpIPDAT,
                                LPSPropTagArray lpsPTaga,
                                LPMAPINAMEID ** lpppPropNames)
{
        SCODE sc;
        LPGUID lpMAPIGuid = NULL;
        int iProp;
        LPMAPINAMEID rgNames = NULL;
        //
        //  First off, allocate enough space in lppPropNames
        //  to hold all the names.
        //

        sc = UNKOBJ_ScAllocate( (LPUNKOBJ) lpIPDAT,
                                                        lpsPTaga->cValues*sizeof(LPMAPINAMEID),
                                                        (LPVOID *)lpppPropNames);

        if (FAILED(sc))
        {
                goto out;
        }

        //
        //  Allocate the guid  -
        //$ Do I really need to do this?? bjd
        //
        sc = UNKOBJ_ScAllocateMore( (LPUNKOBJ) lpIPDAT,
                                                                sizeof(GUID),
                                                                *lpppPropNames,
                                                                &lpMAPIGuid);
        if (FAILED(sc))
        {
                goto out;
        }
        MemCopy(lpMAPIGuid, (LPGUID) &PS_MAPI, sizeof(GUID));

        //
        //  Allocate a block of MAPINAMEIDs
        //
        sc = UNKOBJ_ScAllocateMore( (LPUNKOBJ) lpIPDAT,
                                                                lpsPTaga->cValues*sizeof(MAPINAMEID),
                                                                *lpppPropNames,
                                                                &rgNames);

        if (FAILED(sc))
        {
                goto out;
        }


        for (iProp = 0; iProp < (int) lpsPTaga->cValues; iProp++)
        {
                //
                //  First make the name
                //
                rgNames[iProp].lpguid = lpMAPIGuid;
                rgNames[iProp].ulKind = MNID_ID;
                rgNames[iProp].Kind.lID = PROP_ID(lpsPTaga->aulPropTag[iProp]);

                //
                //  Now put it in the name array
                //
                (*lpppPropNames)[iProp] = &(rgNames[iProp]);
        }

out:
        return sc;
}


/*
 *      FreeLpLstSPV()
 *
 *      Purpose:
 *              Releases objects and frees memory used by lpLstSPV.
 *              Handles NULL.
 *
 *      Arguments
 *              lpIPDAT         Pointer to IPropData object (alloc and free heap)
 *              lpLstSPV        The property value list entry which is to be freed.
 *
 *      Returns
 *              VOID
 *
 */
VOID
FreeLpLstSPV( LPIPDAT   lpIPDAT,
                          LPLSTSPV      lpLstSPV)
{

        if (!lpLstSPV)
        {
                return;
        }

        /* Free the property list node. This also frees the property value
         * and property name string.
         */
    UNKOBJ_Free( (LPUNKOBJ) lpIPDAT, lpLstSPV);
}


/*
 *      LinkLstSPV()
 *
 *      Purpose:
 *              Link a new property node after an existing property node in a singly
 *              linked list.  lppLstLnk points to the element that will preceed
 *              the newly linked element.  This element may be the list head.
 *
 *      Arguments
 *              lppLstLnk       Pointer to list entry (or list head) AFTER which
 *                                      lpLstLnk will be inserted.
 *              lpLstLnk        The element to be inserted in the singly linked list.
 *
 *      Returns
 *              VOID
 */
VOID
LinkLstLnk( LPLSTLNK FAR *      lppLstLnk,
                        LPLSTLNK                lpLstLnk)
{
        /* Always insert at the head of the list.
         */
        lpLstLnk->lpNext = *lppLstLnk;
        *lppLstLnk = lpLstLnk;
}


/*
 *      UnlinkLstLNK()
 *
 *      Purpose:
 *              Unlink the next element in the list.  You pass a pointer the element
 *              before the one to be unlinked (this can be the list head).
 *
 *              The input is typed as LPPLSTLNK because the element before the one to
 *              be unlinked should point to the one one that is to be linked.
 *
 *      Arguments
 *              lppLstLnk       Pointer to the element before the element that is to be
 *                                      unlinked from the singly linked list.
 *
 *      Returns
 *              VOID
 */
VOID
UnlinkLstLnk( LPPLSTLNK lppLstLnk)
{
        /* Unlink the element following the one passed in.
         */
        if (*lppLstLnk)
        {
                ((LPLSTLNK) lppLstLnk)->lpNext = (*lppLstLnk)->lpNext;
        }
}


/*
 *      lpplstspvFindProp()
 *
 *      Purpose:
 *              Locate a property in the linked list of properties (lppLstSPV),
 *              return a pointer to pointer to it.
 *
 *              Pointer to pointer is returned to make it easy to unlink the singly
 *              linked list entry if required.
 *
 *      Arguments
 *              lppLstLnkHead   Pointer to the head of a singly linked list which is
 *                                              to be searched.  It may also point to the element
 *                                              before the first one to be searched if a partial list
 *                                              search (lppLstLnkHead->next to the end) is desired.
 *              ulPropTag               The property tag for which a match is desired.
 *                                              NOTE!  Only the PROP_ID portion is compared.
 *
 *      Returns:
 *              NULL if the requested property is not in the list
 *              lppLstSPV to the property it found in the list.
 */
LPPLSTLNK
LPPLSTLNKFindProp( LPPLSTLNK    lppLstLnkHead,
                                   ULONG                ulPropTag)
{
        ULONG           ulID2Find = PROP_ID(ulPropTag);
        LPLSTLNK        lpLstLnk;
        LPPLSTLNK       lppLstLnk;

        for ( lpLstLnk = *lppLstLnkHead, lppLstLnk = lppLstLnkHead
                ; lpLstLnk
                ; lppLstLnk = (LPPLSTLNK) lpLstLnk, lpLstLnk = lpLstLnk->lpNext)
        {
                /* If this property matches the one we are looking for return a
                 * pointer to the one before it.
                 */
                if (ulID2Find == PROP_ID(lpLstLnk->ulKey))
                {
                        return lppLstLnk;
                }
        }

        return NULL;
}


/*
 *      ScCreateSPV()
 *
 *      Purpose:
 *              Create a lstSPV for the given property and copy the property to it.
 *
 *      Arguments
 *              lpIPDAT         Pointer to IPropData object (alloc and free heap)
 *              lpPropToAdd     Pointer to a property value for which a property value
 *                                      list entry is to be created.
 *              lppLstSPV       Pointer to the memory location which will receive a pointer
 *                                      to the newly allocated list entry.
 *
 *      Returns
 *              SCODE
 */
SCODE
ScCreateSPV(LPIPDAT            lpIPDAT,
            LPSPropValue       lpPropToAdd,
            LPLSTSPV FAR *     lppLstSPV)
{
        SCODE           sc = S_OK;
        LPLSTSPV        lpLstSPV = NULL;
        LPSPropValue    lpPropNew = NULL;
        ULONG           cbToAllocate = 0;


        /* Calculate the space needed to hold the entire property
         */
        sc = ScCountProps( 1, lpPropToAdd, &cbToAllocate );
        if (FAILED(sc))
        {
            DebugTrace(TEXT("ScCreateSPV() - ScCountProps failed (SCODE = 0x%08lX)\n"), sc );
            goto error;
        }

        /* Account for the base LSTSPV.
         */
        cbToAllocate += AlignPropVal(CBLSTSPV);

        /* Allocate the whole chunk
         */
        if (FAILED(sc = UNKOBJ_ScAllocate( (LPUNKOBJ) lpIPDAT, cbToAllocate, &lpLstSPV)))
        {
            goto error;
        }

        lpPropNew = (LPSPropValue) (((LPBYTE)lpLstSPV) + AlignPropVal(CBLSTSPV));

        /* Initialize the property node.
         */
        lpLstSPV->ulAccess = IPROP_READWRITE | IPROP_DIRTY;
        lpLstSPV->lstlnk.ulKey = lpPropToAdd->ulPropTag;

        /* Copy the property.
         */
        if (sc = ScCopyProps(1, lpPropToAdd, lpPropNew, NULL))
        {
                DebugTrace(TEXT("ScCreateSPV() - Error copying prop (SCODE = 0x%08lX)\n"), sc );
                goto error;
        }

        /* Link in the new property value...
         */
        lpLstSPV->lpPropVal = lpPropNew;

        /* ...and return the new property node.
         */
        *lppLstSPV = lpLstSPV;

        goto out;

error:
        UNKOBJ_Free( (LPUNKOBJ) lpIPDAT, lpLstSPV);

out:
        return sc;
}


SCODE
ScMakeNamePropList( LPIPDAT                                     lpIPDAT,
                                        ULONG                                   ulCount,
                                        LPLSTSPN                                lplstSpn,
                                        LPSPropTagArray FAR *   lppPropTagArray,
                                        ULONG                                   ulFlags,
                                        LPGUID                                  lpGuid)
{
        SCODE           sc;
        UNALIGNED ULONG FAR *     lpulPropTag;


        if (FAILED(sc = UNKOBJ_ScAllocate(      (LPUNKOBJ) lpIPDAT,
                                                                                CbNewSPropTagArray(ulCount),
                                                                                (LPVOID *) lppPropTagArray)))
        {
                return sc;
        }


        /* Initialize the count of PropTags to 0.
         */
        (*lppPropTagArray)->cValues = 0;

        for ( lpulPropTag = (*lppPropTagArray)->aulPropTag
                ; lplstSpn
                ; lplstSpn = (LPLSTSPN)lplstSpn->lstlnk.lpNext)
        {
                /* Set the next PropTag and increment the count of PropTags.
                 */

                //
                //  See if we have a guid to look for.
                //  If it's not the one we're looking for, then we keep looking.
                //
                if (lpGuid &&
                        (memcmp(lpGuid, lplstSpn->lpPropName->lpguid, sizeof(GUID))) )
                        continue;

                //
                //  Three cases here:
                //              We don't want strings
                //              We don't want IDs
                //              We don't care - we want all.
                //
                if (   ((lplstSpn->lpPropName->ulKind == MNID_ID) &&
                                 (ulFlags & MAPI_NO_IDS))
                        || ((lplstSpn->lpPropName->ulKind == MNID_STRING) &&
                                 (ulFlags & MAPI_NO_STRINGS))  )
                                continue;

                //
                //  We want these tags
                //
                *lpulPropTag = lplstSpn->lstlnk.ulKey;
                lpulPropTag++;
        (*lppPropTagArray)->cValues++;

        }

        return sc;
}



/*
 *      ScMakePropList
 *
 *      Purpose:
 *              Allocate memory for, and fill in a complete list of properties for
 *              the given lpIPDAT.
 *
 *      Arguments
 *              lpIPDAT                 Pointer to IPropData object (alloc and free heap)
 *              lppPropTagArray Pointer to the memory location which will receive a
 *                                              pointer to the newly allocated Tag array.
 *
 *      Returns
 *              SCODE
 */
SCODE
ScMakePropList( LPIPDAT                                 lpIPDAT,
                                ULONG                                   ulCount,
                                LPLSTLNK                                lplstLink,
                                LPSPropTagArray FAR *   lppPropTagArray,
                                ULONG                                   ulUpperBound)
{
        SCODE           sc;
        UNALIGNED ULONG FAR *     lpulPropTag;


        if (FAILED(sc = UNKOBJ_ScAllocate(  (LPUNKOBJ) lpIPDAT,
                                            CbNewSPropTagArray(ulCount),
                                            (LPVOID *) lppPropTagArray)))
        {
                return sc;
        }


        /* Initialize the count of PropTags to 0.
         */
        (*lppPropTagArray)->cValues = 0;

        for ( lpulPropTag = (*lppPropTagArray)->aulPropTag
                ; lplstLink
                ; lplstLink = lplstLink->lpNext)
        {
                /* Set the next PropTag and increment the count of PropTags.
                 */
                if (PROP_ID(lplstLink->ulKey) < ulUpperBound) // Not <= !
                {
                  *lpulPropTag = lplstLink->ulKey;
                  (*lppPropTagArray)->cValues++;
                  lpulPropTag++;
                }
        }

        return sc;
}



/****************************************************************
 *
 -  CreateIProp
 -
 *      Purpose
 *              Used for creating a property interface in memory.
 *
 *
 *      Arguments
 *              lpInterface             Pointer to the interface ID of the object the caller
 *                                              wants.  This should match IID_IMAPIPropData for the
 *                                              current version of IPROP.DLL.
 *              lpfAllocateBuffer       Pointer to MAPI memory allocator.
 *              lpfAllocateMore         Pointer to MAPI memory allocate more.
 *              lpfFreeBuffer           Pointer to MAPI memory de-allocator.
 *              lppMAPIPropData         Pointer to memory location which will receive a
 *                                                      pointer to the new IMAPIPropData object.
 *
 *      Notes
 *              The caller must insure the MAPI support object from which it drew the
 *              memory allocation routines is not Released before the new IPropData.
 *
 *      Returns
 *              SCODE
 *
 */


STDAPI_(SCODE)
CreateIProp(LPCIID                              lpInterface,
                        ALLOCATEBUFFER FAR *lpfAllocateBuffer,
                        ALLOCATEMORE FAR *      lpfAllocateMore,
                        FREEBUFFER FAR *        lpfFreeBuffer,
                        LPVOID                          lpvReserved,
                        LPPROPDATA FAR *        lppMAPIPropData )
{

        SCODE           sc;
        LPIPDAT         lpIPDAT = NULL;


        // validate paremeters

        AssertSz( lpfAllocateBuffer && !IsBadCodePtr( (FARPROC)lpfAllocateBuffer ),
                         TEXT("lpfAllocateBuffer fails address check") );

        AssertSz( !lpfAllocateMore || !IsBadCodePtr( (FARPROC)lpfAllocateMore ),
                         TEXT("lpfAllocateMore fails address check") );

        AssertSz( !lpfFreeBuffer || !IsBadCodePtr( (FARPROC)lpfFreeBuffer ),
                         TEXT("lpfFreeBuffer fails address check") );

        AssertSz( lppMAPIPropData && !IsBadWritePtr( lppMAPIPropData, sizeof( LPPROPDATA ) ),
                         TEXT("LppMAPIPropData fails address check") );

        /* Make sure that the caller is asking for an object that we support.
         */
        if (   lpInterface
                && !IsEqualGUID(lpInterface, &IID_IMAPIPropData))
        {
                sc = MAPI_E_INTERFACE_NOT_SUPPORTED;
                goto error;
        }

        //
        //  Create a IPDAT per object for lpMAPIPropInternal so that it gets
        //  called first.

        if (FAILED(sc = lpfAllocateBuffer(CBIPDAT, &lpIPDAT)))
        {
                goto error;
        }

        /* Init the object to 0, NULL
         */
    memset( (BYTE *) lpIPDAT, 0, sizeof(*lpIPDAT));

        /* Fill in the object specific instance data.
         */
        lpIPDAT->inst.lpfAllocateBuffer = lpfAllocateBuffer;
        lpIPDAT->inst.lpfAllocateMore = lpfAllocateMore;
        lpIPDAT->inst.lpfFreeBuffer = lpfFreeBuffer;

#ifndef MAC
        lpIPDAT->inst.hinst = hinstMapiX;//HinstMapi();

        #ifdef DEBUG
        if (lpIPDAT->inst.hinst == NULL)
                TraceSz1( TEXT("IPROP: GetModuleHandle failed with error %08lX"),
                        GetLastError());
        #endif /* DEBUG */

#else
        lpIPDAT->inst.hinst = hinstMapiX;//(HINSTANCE) GetCurrentProcess();
#endif


        /* Initialize the  TEXT("standard") object.
         * This must be the last operation that
         * can fail. If not, explicitly call
         * UNKOBJ_Deinit() for failures after
         * a successful UNKOBJ_Init.
         */
        if (FAILED(sc = UNKOBJ_Init( (LPUNKOBJ) lpIPDAT
                                                           , (UNKOBJ_Vtbl FAR *) &vtblIPDAT
                                                           , sizeof(vtblIPDAT)
                                                           , (LPIID FAR *) argpiidIPDAT
                                                           , dimensionof( argpiidIPDAT)
                                                           , &(lpIPDAT->inst))))
        {
                DebugTrace(  TEXT("CreateIProp() - Error initializing IPDAT object (SCODE = 0x%08lX)\n"), sc );
                goto error;
        }

        /* Initialize the defaults in IPROP specific part of the object.
         */
        lpIPDAT->ulObjAccess = IPROP_READWRITE;
        lpIPDAT->ulNextMapID = 0x8000;

        *lppMAPIPropData = (LPPROPDATA) lpIPDAT;

        return S_OK;

error:
        if (lpIPDAT)
        {
                lpfFreeBuffer(lpIPDAT);
        }

        return sc;
}




// --------
// IUnknown



/*
 -      IPDAT_Release
 -
 *      Purpose:
 *              Decrements reference count on the IPropData object and
 *              removes instance data if reference count becomes zero.
 *
 *      Arguments:
 *               lpIPDAT        The IPropData object to be released.
 *
 *      Returns:
 *               Decremented reference count
 *
 *      Side effects:
 *
 *      Errors:
 */
STDMETHODIMP_(ULONG)
IPDAT_Release (LPIPDAT  lpIPDAT)
{
        ULONG   ulcRef;

#if     !defined(NO_VALIDATION)
        /* Make sure the object is valid.
         */
    if (BAD_STANDARD_OBJ( lpIPDAT, IPDAT_, Release, lpVtbl))
        {
                DebugTrace(  TEXT("IPDAT::Release() - Bad object passed\n") );
                return 1;
        }
#endif


        UNKOBJ_EnterCriticalSection((LPUNKOBJ) lpIPDAT);
        ulcRef = --lpIPDAT->ulcRef;
        UNKOBJ_LeaveCriticalSection((LPUNKOBJ) lpIPDAT);

        /* Free the object.
         *
         * No critical section lock is required since we are guaranteed to be
         * the only thread accessing the object (ie ulcRef == 0).
         */
        if (!ulcRef)
        {
                LPLSTLNK lpLstLnk;
                LPLSTLNK lpLstLnkNext;
                FREEBUFFER * lpfFreeBuffer;

                /* Free the property value list.
                 */
                for ( lpLstLnk = (LPLSTLNK) (lpIPDAT->lpLstSPV); lpLstLnk; )
                {
                        lpLstLnkNext = lpLstLnk->lpNext;
                        FreeLpLstSPV( lpIPDAT, (LPLSTSPV) lpLstLnk);
                        lpLstLnk = lpLstLnkNext;
                }

                /* Free the ID to NAME map list.
                 */
                for ( lpLstLnk = (LPLSTLNK) (lpIPDAT->lpLstSPN); lpLstLnk; )
                {
                        lpLstLnkNext = lpLstLnk->lpNext;
                        UNKOBJ_Free( (LPUNKOBJ) lpIPDAT, lpLstLnk);
                        lpLstLnk = lpLstLnkNext;
                }

                /* Free the object.
                 */

                lpfFreeBuffer = lpIPDAT->inst.lpfFreeBuffer;
                UNKOBJ_Deinit((LPUNKOBJ) lpIPDAT);

                lpIPDAT->lpVtbl = NULL;
                lpfFreeBuffer(lpIPDAT);
        }


        return ulcRef;
}



/*
 -      IPDAT_SaveChanges
 -
 *      Purpose:
 *              This DOES not actually save changes since all changes (SetProps etc)
 *              become effective immediately.  This method will invalidate or keep
 *              the IPropData object open depending on the flags passed in.
 *
 *      Arguments:
 *               lpIPDAT        IPropData object to save changes on.
 *               ulFlags        KEEP_OPEN_READONLY
 *                                      KEEP_OPEN_READWRITE
 *                                      FORCE_SAVE (valid but no support)
 *
 *      Returns:
 *               HRESULT
 *
 */
STDMETHODIMP
IPDAT_SaveChanges (LPIPDAT      lpIPDAT,
                                   ULONG        ulFlags)
{
        SCODE   sc = S_OK;


#if     !defined(NO_VALIDATION)
        /* Make sure the object is valid.
         */
    if (BAD_STANDARD_OBJ( lpIPDAT, IPDAT_, SaveChanges, lpVtbl))
        {
                DebugTrace(  TEXT("IPDAT::SaveChanges() - Bad object passed\n") );
                return ResultFromScode(MAPI_E_INVALID_PARAMETER);
        }

    Validate_IMAPIProp_SaveChanges( lpIPDAT, ulFlags );

#endif

        /* The error exit assumes that we are already in a critical section.
         */
        UNKOBJ_EnterCriticalSection((LPUNKOBJ) lpIPDAT);


//$REVIEW is this really needed?
        /* Check object access rights.
         */
    if (!(lpIPDAT->ulObjAccess & IPROP_READWRITE))
        {
                sc = MAPI_E_NO_ACCESS;
                goto error;
        }


        /* IPROP objects are always up to date (saved to memory) so all
         * we have to do is figure out whether and how to leave it open.
         */
        if (!(ulFlags & (KEEP_OPEN_READONLY | KEEP_OPEN_READWRITE)))
        {
                /* We really should invalidate the object here but we have no
                 * clear cut way to call the MakeInvalid method since
                 * we don't have a pointer to the support object!
                 */
//$REVIEW If we are ever going to hand the client an unwrapped interface
//$REVIEW to IMAPIProp then we must get our own support object!

                sc = S_OK;
                goto out;
        }

//$BUG Combine the READWRITE and READONLY flags to IPROP_WRITABLE.
        else if (ulFlags & KEEP_OPEN_READWRITE)
        {
                lpIPDAT->ulObjAccess |= IPROP_READWRITE;
                lpIPDAT->ulObjAccess &= ~IPROP_READONLY;
        }

        else
        {
                lpIPDAT->ulObjAccess |= IPROP_READONLY;
                lpIPDAT->ulObjAccess &= ~IPROP_READWRITE;
        }

        goto out;


error:
        UNKOBJ_SetLastError((LPUNKOBJ) lpIPDAT, sc, 0);

out:
        UNKOBJ_LeaveCriticalSection((LPUNKOBJ) lpIPDAT);

        return ResultFromScode(sc);
}



/*
 -      IPDAT_GetProps
 -
 *      Purpose:
 *              Returns in lpcValues and lppPropArray the values of the properties
 *              in lpPropTagArray.  If the latter is NULL, all properties available
 *              (except PT_OBJECT) from the IPropData object are returned.
 *
 *      Arguments:
 *               lpIPDAT                The IPropData object whose properties are requested.
 *               lpPropTagArray Pointer to a counted array of property tags of
 *                                              properties requested.
 *               lpcValues              Pointer to the memory location which will receive the
 *                                              number of values returned.
 *               lppPropArray   Pointer to the memory location which will receive the
 *                                              address of the returned property value array.
 *
 *      Returns:
 *               HRESULT
 *
 *      Notes:
 *              Now UNICODE enabled.  If UNICODE is set, then any string properties
 *              not otherwise specified to be String8 are returned in UNICODE, otherwise
 *              unspecified string properties are in String8.  String Properties with
 *              unspecified types occur when GetProps() is used with a NULL for the
 *              lpPropTagArray.
 *
 */
STDMETHODIMP
IPDAT_GetProps (LPIPDAT lpIPDAT, LPSPropTagArray lpPropTagArray,
                ULONG   ulFlags,
                ULONG FAR * lpcValues, LPSPropValue FAR * lppPropArray)
{
    SCODE   sc          = S_OK;
    ULONG   ulcWarning  = 0;
    ULONG   iProp       = 0;
    LPSPropValue lpPropValue = NULL;

#if !defined(NO_VALIDATION)
    /* Make sure the object is valid.
     */
    if (BAD_STANDARD_OBJ( lpIPDAT, IPDAT_, GetProps, lpVtbl))
    {
        DebugTrace(  TEXT("IPDAT::GetProps() - Bad object passed\n") );
        return ResultFromScode(MAPI_E_INVALID_PARAMETER);
    }

    Validate_IMAPIProp_GetProps(lpIPDAT,
                            lpPropTagArray,
                            ulFlags,
                            lpcValues,
                            lppPropArray);
#endif

    /* The error exit assumes that we are already in a critical section.
     */
    UNKOBJ_EnterCriticalSection((LPUNKOBJ) lpIPDAT);

    /*  If they aren't asking for anything specific, then
     *  just copy what we have and be done with it.
     */
    if (!lpPropTagArray)
    {
        LPLSTSPV lpLstSPV;

        if (!lpIPDAT->ulCount)
        {
            /* iProp is  initialized to 0 on entry. */
            *lpcValues = iProp;
            *lppPropArray = lpPropValue;
            goto out;
        }

        /* Allocate space for all listed properties.  Space allocated for
         * properties which are not actually returned is simply wasted.
         */
//$REVIEW This would be a good place for a MAPI reallocBuf function.
        if (sc = UNKOBJ_ScAllocate( (LPUNKOBJ) lpIPDAT , lpIPDAT->ulCount * sizeof (SPropValue) , &lpPropValue))
        {
            //
            //  Memory error
            //
            goto error;
        }

        *lpcValues = 0;

        /* iProp is initialized to 0 on method entry.
         */
        for ( lpLstSPV = lpIPDAT->lpLstSPV; lpLstSPV; lpLstSPV = (LPLSTSPV) (lpLstSPV->lstlnk.lpNext))
        {
            /* Copy the property.
             */
            switch (PROP_TYPE(lpLstSPV->lpPropVal->ulPropTag))
            {
            case PT_OBJECT:
            case PT_NULL:
                /* These properties with type PT_NULL and PT_OBJECT are handled
                 * specially.  PropCopyMore doesn't handle them now.
                 */
                lpPropValue[iProp].ulPropTag = lpLstSPV->lpPropVal->ulPropTag;
                iProp++;
                break;

            default:
                if (FAILED(sc = PropCopyMore(   &(lpPropValue[iProp]), (LPSPropValue) (lpLstSPV->lpPropVal),
                                                lpIPDAT->inst.lpfAllocateMore, lpPropValue)))
                {
                    goto error;
                }
                iProp++;
                break;
            }
        }

        /* Return the propValue array and the count of properties actually
         * returned.
         */
        *lpcValues = iProp;
        *lppPropArray = lpPropValue;

        // Handle UNICODE / String conversions depending on ulFlags
        //
        // Default WAB Handling is going to be in Unicode so don't need to worry about the MAPI_UNICODE
        // flag. Only when the flag is not supplied do we have to provide the non-Unicode data
        //
        // We'll leave the Unicode code in place anyway for now
        if (ulFlags & MAPI_UNICODE )
        {
            if(sc = ScConvertAPropsToW(lpIPDAT->inst.lpfAllocateMore, *lppPropArray, *lpcValues, 0))
                goto error;
        }
    