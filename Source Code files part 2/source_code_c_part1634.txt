E;
                break;
            }
        }
    }

    // ************************* now for language based desc/vers.info ******************************

    // You must find the size first before getting any file info
    dwVerInfoSize = GetFileVersionInfoSize(szBuf, &dwVerHnd);

    if (dwVerInfoSize) {
        LPTSTR   lpstrVffInfo;             // Pointer to block to hold info
        HANDLE  hMem;                     // handle to mem alloc'ed

        // Get a block big enough to hold version info
        hMem          = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize);
        if (!hMem)
            return DV_ERR_NOMEM;

        lpstrVffInfo  = GlobalLock(hMem);
        if (!lpstrVffInfo)
        {
            GlobalFree (hMem);
            GetLastError (); // for debugging
            return DV_ERR_NOMEM;
        }

        // Get the File Version first
        if (GetFileVersionInfo(szBuf, 0L, dwVerInfoSize, lpstrVffInfo)) {
            if(VerQueryValue((LPVOID)lpstrVffInfo,
                         TEXT("\\"),
                         (void FAR*)&p_vsFixedFileInfo,
                         (UINT FAR *) &wLen))
            {
                // fill in the file version
                wsprintf(szBuf,
                         TEXT("Version:  %d.%d.%d.%d"),
                         HIWORD(p_vsFixedFileInfo->dwFileVersionMS),
                         LOWORD(p_vsFixedFileInfo->dwFileVersionMS),
                         HIWORD(p_vsFixedFileInfo->dwFileVersionLS),
                         LOWORD(p_vsFixedFileInfo->dwFileVersionLS));
                if (fGetVersion)
                   lstrcpyn (lpszVer, szBuf, cbVer);
            }

            // now if still no desc. was set, attempt to read it from the file...
            if(!bDescSet) {
                // Read the list of languages and code pages.
                VerQueryValue(lpstrVffInfo,
                              TEXT("\\VarFileInfo\\Translation"),
                              (LPVOID*)&lpTranslate,
                              &cbTranslate);

                // Read the file description for the 1st language and code page.
                if(cbTranslate>=sizeof(struct LANGANDCODEPAGE)) // at least one language/codepage pair retrieved...
                {
                        wLanguage = lpTranslate[0].wLanguage ;
                        wCodePage = lpTranslate[0].wCodePage ;
                }
                else
                {
                        wLanguage = 0x0409 ; // 0x0409 (English (United States))
                        wCodePage = 0x04b0 ; // 0x04b0 Unicode
                }

                //get description
                wsprintf( szGetName,TEXT("\\StringFileInfo\\%04x%04x\\FileDescription"),wLanguage,wCodePage);

                wLen   = 0;
                lpStr  = NULL;

                // Look for the corresponding string.
                bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo,
                                (LPTSTR)szGetName,
                                (void FAR* FAR*)&lpStr,
                                (UINT FAR *) &wLen);

                if (fGetName && bRetCode && wLen && lpStr)
                   lstrcpyn (lpszDesc, lpStr, cbDesc);
            }
        }

        // Let go of the memory
        GlobalUnlock(hMem);
        GlobalFree(hMem);
    }
    return DV_ERR_OK;
}



/**************************************************************************
* @doc INTERNAL VIDEO
*
* @api void | videoCleanup | clean up video stuff
*   called in MSVIDEOs WEP()
*
**************************************************************************/
void FAR PASCAL videoCleanup(HTASK hTask)
{
}

//
//  Assist with unicode conversions
//

int Iwcstombs(LPSTR lpstr, LPCWSTR lpwstr, int len)
{
    return WideCharToMultiByte(GetACP(), 0, lpwstr, -1, lpstr, len, NULL, NULL);
}

int Imbstowcs(LPWSTR lpwstr, LPCSTR lpstr, int len)
{
    return MultiByteToWideChar(GetACP(),
                               MB_PRECOMPOSED,
                               lpstr,
                               -1,
                               lpwstr,
                               len);
}




DWORD WINAPI NTvidxFrame (
   HVIDEOX       hVideo,
   //LPVIDEOHDREX lpVHdr) {
   LPVIDEOHDR lpVHdr) {
    return NTvideoFrame(hVideo, (LPVIDEOHDR) lpVHdr);
}

DWORD WINAPI NTvidxAddBuffer (
   HVIDEOX       hVideo,
   PTR32         lpVHdr,
   DWORD         cbData) {

    NTvideoStreamPrepareHeader(hVideo, lpVHdr, cbData);
    return NTvideoStreamAddBuffer(hVideo, lpVHdr, cbData);
}

#define USE_HW_BUFFERS 1
// #define USE_CONTIG_ALLOC     // can we do this in 32-bit land?



typedef struct _thk_hvideo FAR * LPTHKHVIDEO;
typedef struct _thk_hvideo {
    struct _thk_hvideo * pNext;
    DWORD          Stamp;
    UINT           nHeaders;
    UINT           cbAllocHdr;
    UINT           cbVidHdr;
    UINT           spare;
    LPVOID         paHdrs;
    PTR32          p32aHdrs;
    LPVOID         pVSyncMem;
    DWORD          p32VSyncMem;
    DWORD          pid;

    HVIDEO         hVideo;
    HVIDEO         hFill;

    DWORD_PTR          dwCallback;
    DWORD_PTR          dwUser;

    LPTHKVIDEOHDR  pPreviewHdr;

    } THKHVIDEO;

#define THKHDR(ii) ((LPTHKVIDEOHDR)((LPBYTE)ptv->paHdrs + (ii * ptv->cbAllocHdr)))

static struct _thk_local {
    THKHVIDEO *    pMruHandle;
    THKHVIDEO *    pFreeHandle;
    int            nPoolSize;
    int            nAllocCount;
    } tl;

#define THKHVIDEO_STAMP  MAKEFOURCC('t','V','H','x')
#define V_HVIDEO(ptv) if (!ptv || ptv->Stamp != THKHVIDEO_STAMP) { \
             AuxDebugEx (-1, DEBUGLINE "V_HVIDEO failed hVideo=%08lx\r\n", ptv); \
             return MMSYSERR_INVALHANDLE; \
        }
#define V_HEADER(ptv,p32Hdr,ptvh) if (!(ptvh = NTvidxLookupHeader(ptv,p32Hdr))) { \
            AuxDebugEx(-1, DEBUGLINE "V_HEADER(%08lX,%08lX) failed!", ptv, p32Hdr); \
            return MMSYSERR_INVALPARAM; \
        }

// !!! this means we only allow one of these at a time, which might
// be okay since there's usually only one capture card.
static THKHVIDEO g_tv = { NULL, THKHVIDEO_STAMP, };

#define DATAFROMHANDLE(h) &g_tv

DWORD WINAPI NTvidxAllocBuffer (
   HVIDEOX     hv,
   UINT        ii,
   PTR32 FAR * pp32Hdr,
   DWORD       cbData)
{

    LPTHKHVIDEO ptv = DATAFROMHANDLE(hv);
    LPTHKVIDEOHDR ptvh;
   #ifdef USE_CONTIG_ALLOC
    CPA_DATA cpad;
   #endif

    *pp32Hdr = 0;

    V_HVIDEO(ptv);
    if (ii >= ptv->nHeaders || ptv->paHdrs == NULL)
        return MMSYSERR_NOMEM;

    ptvh = THKHDR(ii);

  #ifdef USE_HW_BUFFERS
    // try to allocate a buffer on hardware
    //
    if (NTvideoMessage (ptv->hVideo, DVM_STREAM_ALLOCBUFFER,
                (LPARAM) (LPVOID)&ptvh->dwTile, cbData)
        == DV_ERR_OK)
    {
        // if we got hw buffers, dwMemHandle == 0 && dwTile != 0
        // we will depend on this to know who to free the memory to
        // (for phys mem both will be non zero, while for GlobalMem
        // both will be zero)
        //
        ptvh->dwMemHandle = 0;
        ptvh->p16Alloc = (PTR16)ptvh->dwTile;
        ptvh->p32Buff = MapSL(ptvh->p16Alloc);
        *pp32Hdr = (BYTE *) ptv->p32aHdrs + (ii * ptv->cbAllocHdr);
        return MMSYSERR_NOERROR;
    }

    // if we have more than 1 buffer, and
    // the first buffer was on hardware.  if we fail
    // to allocate a buffer on hardware, return failure
    //
    // !!! This might upset somebody who doesn't get a min # of buffers
    if ((ii > 0) &&
        (0 == THKHDR(0)->dwMemHandle) &&
        (0 != THKHDR(0)->dwTile))
        return MMSYSERR_NOMEM;
  #endif

  #ifdef USE_CONTIG_ALLOC
    cpad.dwMemHandle = 0;
    cpad.dwPhysAddr = 0;
    // first try to get contig memory
    //
    ptvh->p32Buff = capPageAllocate (PageContig | PageFixed | PageUseAlign,
                                     (cbData + 4095) >> 12,
                                     0xFFFFF,  // max phys addr mask (fffff is no max addr)
                                     &cpad);
    if (ptvh->p32Buff)
    {
        ptvh->dwMemHandle = cpad.dwMemHandle;
        ptvh->dwTile = capTileBuffer (ptvh->p32Buff, cbData);
        ptvh->p16Alloc = PTR_FROM_TILE(ptvh->dwTile);
        if ( ! ptvh->p16Alloc)
        {
            capPageFree (ptvh->dwMemHandle);
            ptvh->dwMemHandle = 0;
            ptvh->dwTile = ptvh->p32Buff = 0;
        }
        else
        {
            // put the physical address into the the header so that
            // it can be used on the 32 bit side
            //
            ptvh->vh.dwReserved[3] = cpad.dwPhysAddr;
        }
    }

    // if we failed to get contiguous memory,
    // return NOMEM if there is a sufficient number of buffers
    // otherwise use GlobalAlloc
    // !!! The ideal thing to do is only use contig memory buffers until
    // they're all full, then fall back on more non-contig buffers
    //
    if ( ! ptvh->p32Buff)
        if (ii >= MIN_VIDEO_BUFFERS)
            return MMSYSERR_NOMEM;
        else
   #endif
        {
            ptvh->dwTile = ptvh->dwMemHandle = 0;
            ptvh->p16Alloc = GlobalAllocPtr(GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE, cbData);
            if ( ! ptvh->p16Alloc)
               return MMSYSERR_NOMEM;

            ptvh->p32Buff = MapSL(ptvh->p16Alloc);
        }

    *pp32Hdr = (BYTE *) ptv->p32aHdrs + (ii * ptv->cbAllocHdr);

    return MMSYSERR_NOERROR;
}

DWORD WINAPI NTvidxFreePreviewBuffer (
    HVIDEOX       hv,
    PTR32         p32)
{
    LPTHKHVIDEO ptv = DATAFROMHANDLE(hv);
    LPTHKVIDEOHDR ptvh;

    V_HVIDEO(ptv);

    ptvh = ptv->pPreviewHdr;

    if (! ptvh )
        return MMSYSERR_NOMEM;

    if (ptvh->p16Alloc)
        GlobalFreePtr (ptvh->p16Alloc);

    GlobalFreePtr (ptvh);

    ptv->pPreviewHdr = NULL;

    return MMSYSERR_NOERROR;
}

DWORD WINAPI NTvidxAllocPreviewBuffer (
   HVIDEOX      hVideo,
   PTR32 FAR *  p32,
   UINT         cbHdr,
   DWORD        cbData)
{
    LPTHKHVIDEO ptv = DATAFROMHANDLE(hVideo);
    LPTHKVIDEOHDR ptvh;

    cbHdr = max(cbHdr, sizeof(THKVIDEOHDR));

    *p32 = 0;

    V_HVIDEO(ptv);

    if (ptv->pPreviewHdr)
        NTvidxFreePreviewBuffer (hVideo, 0);

    ptvh = (LPVOID) GlobalAllocPtr(GPTR | GMEM_SHARE, cbHdr);
    if (!ptvh)
       return MMSYSERR_NOMEM;

    ptv->pPreviewHdr = ptvh;

    ptvh->dwTile = ptvh->dwMemHandle = 0;
    ptvh->p16Alloc = GlobalAllocPtr(GPTR | GMEM_SHARE, cbData);
    if ( ! ptvh->p16Alloc)
       {
       GlobalFreePtr (ptvh);
       return MMSYSERR_NOMEM;
       }

    ptvh->p32Buff = MapSL(ptvh->p16Alloc);

    *p32 = ptvh->p32Buff;
    return MMSYSERR_NOERROR;
}

DWORD WINAPI NTvidxAllocHeaders(
   HVIDEOX     hVideo,
   UINT        nHeaders,
   UINT        cbAllocHdr,
   PTR32 FAR * lpHdrs)
{
    LPTHKHVIDEO ptv = DATAFROMHANDLE(hVideo);
    LPVOID      lpv;

    V_HVIDEO(ptv);

    if ( ! nHeaders ||
        cbAllocHdr < sizeof(THKVIDEOHDR) ||
        cbAllocHdr & 3 ||
        (cbAllocHdr * nHeaders) > 0x10000l)
        return MMSYSERR_INVALPARAM;

    assert (ptv->paHdrs == NULL);

    lpv = GlobalAllocPtr (GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE,
                          cbAllocHdr * nHeaders);

    if (!lpv)
        return MMSYSERR_NOMEM;

    ptv->nHeaders   = nHeaders;
    ptv->cbAllocHdr = cbAllocHdr;
    //ptv->cbVidHdr   = sizeof(VIDEOHDREX);
    ptv->cbVidHdr   = sizeof(VIDEOHDR);
    ptv->p32aHdrs   = MapSL(lpv);
    ptv->paHdrs     = lpv;

    *lpHdrs = ptv->p32aHdrs;

    return MMSYSERR_NOERROR;
}

STATICFN VOID PASCAL FreeBuffer (
    LPTHKHVIDEO ptv,
    LPTHKVIDEOHDR ptvh)
{
    assert (!(ptvh->vh.dwFlags & VHDR_PREPARED));

  #ifdef USE_CONTIG_ALLOC
    //
    // if this buffer was pageAllocated (as indicated by dwMemHandle
    // is non-zero)
    //
    if (ptvh->dwMemHandle)
    {
        if (ptvh->dwTile)
            capUnTileBuffer (ptvh->dwTile), ptvh->dwTile = 0;

        capPageFree (ptvh->dwMemHandle), ptvh->dwMemHandle = 0;
    }
    else
  #endif
  #ifdef USE_HW_BUFFERS
    //
    // if this buffer was allocated from capture hardware
    // (as indicated by dwMemHandle == 0 && dwTile != 0)
    //
    if (ptvh->dwTile != 0)
    {
        assert (ptvh->dwMemHandle == 0);
        NTvideoMessage (ptv->hVideo, DVM_STREAM_FREEBUFFER,
                (LPARAM) (LPVOID) ptvh->dwTile, 0);
        ptvh->dwTile = 0;
    }
    else
  #endif
    //
    // if this buffer was allocated from global memory
    //
    {
        if (ptvh->p16Alloc)
            GlobalFreePtr (ptvh->p16Alloc);
    }

    ptvh->p16Alloc = NULL;
    ptvh->p32Buff  = 0;
}

DWORD WINAPI NTvidxFreeHeaders(
   HVIDEOX hv)
{
    LPTHKHVIDEO ptv = DATAFROMHANDLE(hv);
    UINT          ii;
    LPTHKVIDEOHDR ptvh;

    V_HVIDEO(ptv);

    if ( ! ptv->paHdrs)
        return MMSYSERR_ERROR;

    for (ptvh = THKHDR(ii = 0); ii < ptv->nHeaders; ++ii, ptvh = THKHDR(ii))
    {
        if (ptvh->vh.dwFlags & VHDR_PREPARED)
        {
            NTvideoStreamUnprepareHeader (ptv->hVideo, (LPVOID)ptvh, ptv->cbVidHdr);
            ptvh->vh.dwFlags &= ~VHDR_PREPARED;
        }
        FreeBuffer (ptv, ptvh);
    }

    GlobalFreePtr (ptv->paHdrs);
    ptv->paHdrs = NULL;
    ptv->p32aHdrs = 0;
    ptv->nHeaders = 0;

    return MMSYSERR_NOERROR;

}

STATICFN LPTHKVIDEOHDR PASCAL NTvidxLookupHeader (
    LPTHKHVIDEO ptv,
    DWORD_PTR p32Hdr)
{
    WORD ii;

    if ( ! p32Hdr || ! ptv->paHdrs || ! ptv->cbAllocHdr)
        return NULL;

    if ((p32Hdr - (DWORD_PTR) ptv->p32aHdrs) % ptv->cbAllocHdr)
        return NULL;

    ii = (WORD)((p32Hdr - (DWORD_PTR) ptv->p32aHdrs) / ptv->cbAllocHdr);
    if (ii > ptv->nHeaders)
        return NULL;

    return THKHDR(ii);
}

DWORD WINAPI NTvidxFreeBuffer (
    HVIDEOX       hv,
    DWORD_PTR         p32Hdr)
{
    LPTHKHVIDEO ptv = DATAFROMHANDLE(hv);
    LPTHKVIDEOHDR ptvh;

    V_HVIDEO(ptv);
    V_HEADER(ptv,p32Hdr,ptvh);

    // single frame buffers are never prepared!
    //
    assert (!(ptvh->vh.dwFlags & VHDR_PREPARED));

    FreeBuffer (ptv, ptvh);
    return MMSYSERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivcap\vidx.h ===
/*+ vidx.h
 *
 * structures and prototypes for thunkable videoXXX api's
 *
 *-================ Copyright 1995 Microsoft Corp. ======================*/

#ifndef _VIDX_H_
#define _VIDX_H_

// Force C declarations for C++
//
#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

#ifdef WIN32
  typedef unsigned __int64 QUADWORD;
  #define HVIDEOX HVIDEO
  #define PTR32   LPVOID
  #define PTR16   LPVOID
#ifndef DWORD_PTR
#define DWORD_PTR unsigned long
#endif
#ifndef INT_PTR
#define INT_PTR int
#endif
#ifndef LONG_PTR
#define LONG_PTR long
#endif
#ifndef UINT_PTR
#define UINT_PTR unsigned int
#endif
#else
  #define QUADWORD struct { DWORD lo; DWORD hi; }
  #undef  WINAPI
  #define WINAPI FAR PASCAL _export
  typedef struct _thk_hvideo FAR * LPTHKHVIDEO;
  #undef  HVIDEO
  #define HVIDEOX LPTHKHVIDEO
  #define PTR32   DWORD
  #define PTR16   LPVOID
#endif

// 'cooked' SMPTE timecode.  this is organized so that
// timecode values can be compared as a single QUAD operation
// so long as frame rates match.
//
// it is treated as a fixed point 48bit binary real number
// with the decimal point always at 32.16
//
// the only non-integral frame rate is 29.97 (NTSC) which is
// indicated by 0 in the frame rate field.
//
typedef union _vidxtimecode {
   struct {
      WORD  wFrameRate;  // 0 == 29.97 frame rate
      WORD  wFrameFract; // fractional frames. range 0-FFFF
      DWORD dwFrames;    // frame count.
      };
   QUADWORD qw;          // for copy/compare operations.
   } VIDXTIMECODE;

// timecode + userdata
//
typedef struct _vidxtimecodedata {
   VIDXTIMECODE time;
   DWORD    dwSMPTEFlags;
   DWORD    dwUser;
   } VIDXTIMECODEDATA;

// structure of memory shared between driver and quartz
// capture. used to allow Quartz to slave a clock to
// the vsync interrupt.
//
// This memory region will be locked down prior to being
// passed to the driver in Win95 so that it may be accessed at
// interrupt time. Because of the way the thunking layer works,
// it is not advisable for the driver to attempt to lock this
// memory. The memory will be visible in all process contexts.
//
// The driver is responsible for updating nVsyncCount on each VSYNC
// or as often as possible.  Whenever nVsyncCount is updated, qwSystemTime
// should be updated also, and if SMPTE timecode corresponding to this VSYNC
// is available, tcdata should be updated also.  If SMPTE timecode for this
// VSYNC is NOT available, dwFlags should be changed to indicate there is no
// timecode infomation (clear the VSYNCMEM_FLAGS_SMPTE bit of dwFlags)
//
// While updating, the driver should set the low bit of the dwInUse flag to 1.
//
// The driver should set the dwFlags field to indicated the presense
// of valid nVsyncCount/qwSystemTime and tcdata.
//
// The driver is allowed to choose between setting qwSystemTime to the return
// value of QueryPerformanceCounter or the value of the Pentium tick.  It is
// recommended to use QPC on NT as the pentium tick is not necessarily available
// to application code in that environment.
//
// When the Quartz capture wrapper reads from this shared memory, it will check
// the dwInUse flag and also read twice comparing results to insure that it reads
// valid, consistent data.
//
typedef struct _vsyncmem {
   DWORD        dwInUse;       // low bit is non-zero when the driver is
                               // updating this struture.  other bits reserved.

   DWORD        nVsyncCount;  // VSYNC count
   QUADWORD     qwSystemTime; // QueryPerformanceCounter value at this VSYNC

   DWORD        dwFlags;      // flags indicate which fields are in use
   #define VSYNCMEM_TIME_MASK    0x0000000F // mask to get type of qwSystemTime
   #define VSYNCMEM_TIME_QPC     0x00000001 // qwSystemTime is QueryPerformanceCounter
   #define VSYNCMEM_TIME_PENTIUM 0x00000002 // qwSystemTime is pentium CPU tick

   #define VSYNCMEM_FLAG_SMPTE   0x00000010  // set if tcdata is valid

   DWORD        dwSpare;      // spare to align the next field on Quad boundary
   VIDXTIMECODEDATA tcdata;   // SMPTE timecode associated with this VSYNC
   } VSYNCMEM;

// DVM_xxx messages are defined in VFW.H
//
#ifndef DVM_CONFIGURE_START
  #define DVM_CONFIGURE_START 0x1000
#endif
#define DVM_CLOCK_BUFFER     (UINT)(DVM_CONFIGURE_START+0x10)
   //
   // dw1 = ptr to VSYNCMEM. ptr is valid until next DVM_CLOCK_BUFFER message
   //       or until driver is closed.
   // dw2 = size of VSYNCMEM buffer
   //
   // driver should return MMSYSERR_NOERROR (0) to indicate that it is
   // capable of keeping the contents of the VSYNCMEM buffer up to date.
   //


// legacy VFW capture filter will NOT make any attempt at time code/line 21
//========================================================================
#if 0
// The extended video header has extra fields that can be used to
// return CC (Line21) and SMPTE timcode information along with captured
// video frames.
//
// the first time the driver gets a DVM_STREAM_PREPAREHEADER and/or DVM_STREAM_ADDBUFFER
// message, it will contain sizeof(VIDEOHDREX) as dwParam2, if the driver fails
// this message, all subsequent messages will use sizeof(VIDEOHDR) as the videoheader size.
// drivers that do not fail this message, may still not be checking the header size
// and responding properly to the new fields.
//
// Drivers that do support the extra fields in VIDEOHDREX are responsible for setting
// bits in dwExtraMask to indicate which extra fields have valid data, this should be
// done BEFORE setting the 'done' bit in the VIDEOHDR
//
typedef struct _videohdrex {
  LPBYTE lpData;
  DWORD  dwBufferLength;
  DWORD  dwBytesUsed;
  DWORD  dwTimeCaptured;
  DWORD  dwUser;
  DWORD  dwFlags;
  DWORD  dwReserved[4];
  //
  // fields above this match the VIDEOHDR
  //

  // bits in this mask indicate which extra header fields
  // have data in them
  DWORD  dwExtraMask;

  // accumulated line21 info since last header. older data
  // is in smaller index'd elements.  the mask indicates
  // how many words of line21 are filled in the array.
  // if both CC and OTHER information are being captured
  // then CC data is in even elements and OTHER data is in
  // odd elements.
  //
  #define VHDR_EXTRA_LINE21     0x0000F  // count of wLine21 members that have data
  #define VHDR_EXTRA_CC         0x00010  // set when data is from CC field
  #define VHDR_EXTRA_OTHER      0x00020  // set when data is program info field
  WORD   wLine21[10]; // this needs to be a multiple of 4+2 so
                      // that the timecode field below gets aligned
                      // properly

  // primary and secondary timecode + userdata
  // timecodeA is in element [0] of the array
  //
  #define VHDR_EXTRA_TIMECODEA  0x10000
  #define VHDR_EXTRA_TIMECODEB  0x20000
  VIDXTIMECODEDATA timecode[2];

} VIDEOHDREX, FAR * LPVIDEOHDREX;
#endif
//========================================================================

// VIDEOHDR + extra fields used by the thunking layer
//
typedef struct _thk_videohdr {
    //VIDEOHDREX vh;
    VIDEOHDR vh;
    PTR32      p32Buff;
    PTR16      p16Alloc;
    DWORD      dwMemHandle;
    DWORD      dwTile;
    DWORD_PTR  dwUser;          // use this instead of dwUser in VIDEOHDR
                                // because some drivers trash it! (Miro DC30)
    DWORD      dwIndex;         // which header is this in our array?
    PTR32      pStart;
} THKVIDEOHDR, FAR *LPTHKVIDEOHDR;

DWORD WINAPI vidxAllocHeaders(
   HVIDEOX     hVideo,
   UINT        nHeaders,
   UINT        cbHeader,
   PTR32 FAR * lpHdrs);
DWORD WINAPI NTvidxAllocHeaders(
   HVIDEOX     hVideo,
   UINT        nHeaders,
   UINT        cbHeader,
   PTR32 FAR * lpHdrs);

DWORD WINAPI vidxFreeHeaders(
   HVIDEOX hv);
DWORD WINAPI NTvidxFreeHeaders(
   HVIDEOX hv);

DWORD WINAPI vidxAllocBuffer (
   HVIDEOX     hv,
   UINT        iHdr,
   PTR32 FAR * pp32Hdr,
   DWORD       dwSize);
DWORD WINAPI NTvidxAllocBuffer (
   HVIDEOX     hv,
   UINT        iHdr,
   PTR32 FAR * pp32Hdr,
   DWORD       dwSize);

DWORD WINAPI vidxFreeBuffer (
   HVIDEOX hv,
   DWORD   p32Hdr);
DWORD WINAPI NTvidxFreeBuffer (
   HVIDEOX hv,
   DWORD_PTR p32Hdr);

DWORD WINAPI vidxFrame (
   HVIDEOX       hVideo,
   //LPVIDEOHDREX lpVHdr);
   LPVIDEOHDR lpVHdr);
DWORD WINAPI NTvidxFrame (
   HVIDEOX       hVideo,
   //LPVIDEOHDREX lpVHdr);
   LPVIDEOHDR lpVHdr);

DWORD WINAPI vidxAddBuffer (
   HVIDEOX       hVideo,
   PTR32         lpVHdr,
   DWORD         cbData);
DWORD WINAPI NTvidxAddBuffer (
   HVIDEOX       hVideo,
   PTR32         lpVHdr,
   DWORD         cbData);

DWORD WINAPI vidxAllocPreviewBuffer (
   HVIDEOX      hVideo,
   PTR32 FAR *  lpBits,
   UINT         cbHdr,
   DWORD        cbData);
DWORD WINAPI NTvidxAllocPreviewBuffer (
   HVIDEOX      hVideo,
   PTR32 FAR *  lpBits,
   UINT         cbHdr,
   DWORD        cbData);

DWORD WINAPI vidxFreePreviewBuffer (
   HVIDEOX     hVideo,
   PTR32       lpBits);
DWORD WINAPI NTvidxFreePreviewBuffer (
   HVIDEOX     hVideo,
   PTR32       lpBits);

DWORD WINAPI vidxSetupVSyncMem (
    HVIDEOX     hVideo,
    PTR32 FAR * ppVsyncMem); // NULL to release VSYNC mem
DWORD WINAPI NTvidxSetupVSyncMem (
    HVIDEOX     hVideo,
    PTR32 FAR * ppVsyncMem); // NULL to release VSYNC mem


// needed for Win95 thunking
//
VOID WINAPI OpenMMDEVLDR(void);
VOID WINAPI CloseMMDEVLDR(void);

#ifdef __cplusplus
}
#endif

#endif // _VIDX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivcap\wdmdlgs.h ===
/****************************************************************************
 *  @doc INTERNAL DIALOGS
 *
 *  @module WDMDialg.h | Include file for <c CWDMDialog> class used to display
 *    video settings and camera controls dialog for WDM devices.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#ifndef _DIALOGS_H_
#define _DIALOGS_H_

// Constants used to check if the property has an automatic mode or/and a manual mode
#define KSPROPERTY_FLAGS_MANUAL KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL
#define KSPROPERTY_FLAGS_AUTO KSPROPERTY_CAMERACONTROL_FLAGS_AUTO

#if (KSPROPERTY_FLAGS_AUTO != KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO) || (KSPROPERTY_FLAGS_MANUAL != KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL)
#error Why did you mess with the kernel streaming include files? - PhilF-
#endif

typedef struct _tagPROPSLIDECONTROL
{
    LONG lLastValue;
    LONG lCurrentValue;
    LONG lMin;
    LONG lMax;
    ULONG ulCapabilities;

    // Dialog item IDs
    UINT uiProperty;
    UINT uiSlider;
    UINT uiString;
    UINT uiStatic;
    UINT uiCurrent;
    UINT uiAuto;
} PROPSLIDECONTROL, * PPROPSLIDECONTROL;

// For now, we only expose a video settings and camera control page
#define MAX_PAGES 2

/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGCLASS
 *
 *  @class CWDMDialog | This class provides support for property
 *    pages to be displayed within a property sheet.
 *
 *  @mdata BOOL | CWDMDialog | m_bInit | This member is set to TRUE after the
 *    page has been initialized.
 *
 *  @mdata BOOL | CWDMDialog | m_bChanged | This member is set to TRUE after the
 *    page has been changed.
 *
 *  @mdata int | CWDMDialog | m_DlgID | Resource ID of the property page dialog.
 *
 *  @mdata HWND | CWDMDialog | m_hDlg | Window handle of the property page.
 *
 *  @mdata PDWORD | CWDMDialog | m_pdwHelp | Pointer to the list of help IDs
 *    to be displayed in the property page.
 *
 *  @mdata CWDMPin * | CWDMDialog | m_pCWDMPin | Pointer to the kernel
 *    streaming object we will query the property on.
 *
 *  @mdata PPROPSLIDECONTROL | CWDMDialog | m_pPC | Pointer to the list of
 *    slider controls to be displayed in the property page.
 *
 *  @mdata DWORD | CWDMDialog | m_dwNumControls | Number of controls to\
 *    display in the page.
 *
 *  @mdata GUID | CWDMDialog | m_guidPropertySet | GUID of the KS property
 *    we are showing in the property page.
 ***************************************************************************/
class CWDMDialog
{
public:
    CWDMDialog(int DlgID, DWORD dwNumControls, GUID guidPropertySet, PPROPSLIDECONTROL pPC, CTAPIVCap *pCaptureFilter);
    ~CWDMDialog() {};

	HPROPSHEETPAGE	Create();

private:
	BOOL				m_bInit;
	BOOL				m_bChanged;
	int					m_DlgID;
	HWND				m_hDlg;
	PPROPSLIDECONTROL	m_pPC;
	DWORD				m_dwNumControls;
	GUID				m_guidPropertySet;
	CTAPIVCap			*m_pCaptureFilter;

	// Dialog proc helper functions
	int		SetActive();
	int		QueryCancel();
	int		DoCommand(WORD wCmdID,WORD hHow);

	// Dialog proc
	static BOOL CALLBACK BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};

#endif // _DIALOGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivcap\wdmdlgs.cpp ===
/****************************************************************************
 *  @doc INTERNAL DIALOGS
 *
 *  @module WDMDialg.cpp | Source file for <c CWDMDialog> class used to display
 *    video settings and camera controls dialog for WDM devices.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#include "Precomp.h"

// Globals
extern HINSTANCE g_hInst;

// For now, we only expose a video settings and camera control page
#define MAX_PAGES 2

// Video settings (brightness tint hue etc.)
#define NumVideoSettings 8
static PROPSLIDECONTROL g_VideoSettingControls[NumVideoSettings] =
{
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,   IDC_SLIDER_BRIGHTNESS, IDS_BRIGHTNESS, IDC_BRIGHTNESS_STATIC, IDC_TXT_BRIGHTNESS_CURRENT, IDC_CB_AUTO_BRIGHTNESS},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_CONTRAST,     IDC_SLIDER_CONTRAST,   IDS_CONTRAST,   IDC_CONTRAST_STATIC,   IDC_TXT_CONTRAST_CURRENT,   IDC_CB_AUTO_CONTRAST},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_HUE,          IDC_SLIDER_HUE,        IDS_HUE,        IDC_HUE_STATIC,        IDC_TXT_HUE_CURRENT,        IDC_CB_AUTO_HUE},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_SATURATION,   IDC_SLIDER_SATURATION, IDS_SATURATION, IDC_SATURATION_STATIC, IDC_TXT_SATURATION_CURRENT, IDC_CB_AUTO_SATURATION},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_SHARPNESS,    IDC_SLIDER_SHARPNESS,  IDS_SHARPNESS,  IDC_SHARPNESS_STATIC,  IDC_TXT_SHARPNESS_CURRENT,  IDC_CB_AUTO_SHARPNESS},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE, IDC_SLIDER_WHITEBAL,   IDS_WHITEBAL,   IDC_WHITE_STATIC,      IDC_TXT_WHITE_CURRENT,      IDC_CB_AUTO_WHITEBAL},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_GAMMA,        IDC_SLIDER_GAMMA,      IDS_GAMMA,      IDC_GAMMA_STATIC,      IDC_TXT_GAMMA_CURRENT,      IDC_CB_AUTO_GAMMA},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION,    IDC_SLIDER_BACKLIGHT,  IDS_BACKLIGHT,  IDC_BACKLIGHT_STATIC,      IDC_TXT_BACKLIGHT_CURRENT,  IDC_CB_AUTO_BACKLIGHT}
};

// Camera control (focus, zoom etc.)
#define NumCameraControls 7
static PROPSLIDECONTROL g_CameraControls[NumCameraControls] =
{
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_FOCUS,   IDC_SLIDER_FOCUS,   IDS_FOCUS,    IDC_FOCUS_STATIC,   IDC_TXT_FOCUS_CURRENT,    IDC_CB_AUTO_FOCUS},
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_ZOOM,    IDC_SLIDER_ZOOM,    IDS_ZOOM,     IDC_ZOOM_STATIC,    IDC_TXT_ZOOM_CURRENT,     IDC_CB_AUTO_ZOOM},
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_EXPOSURE,IDC_SLIDER_EXPOSURE,IDS_EXPOSURE, IDC_EXPOSURE_STATIC,IDC_TXT_EXPOSURE_CURRENT, IDC_CB_AUTO_EXPOSURE},
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_IRIS,    IDC_SLIDER_IRIS,    IDS_IRIS,     IDC_IRIS_STATIC,    IDC_TXT_IRIS_CURRENT,     IDC_CB_AUTO_IRIS},
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_TILT,    IDC_SLIDER_TILT,    IDS_TILT,     IDC_TILT_STATIC,    IDC_TXT_TILT_CURRENT,     IDC_CB_AUTO_TILT},
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_PAN,     IDC_SLIDER_PAN,     IDS_PAN,      IDC_PAN_STATIC,     IDC_TXT_PAN_CURRENT,      IDC_CB_AUTO_PAN},
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_ROLL,    IDC_SLIDER_ROLL,    IDS_ROLL,     IDC_ROLL_STATIC,    IDC_TXT_ROLL_CURRENT,     IDC_CB_AUTO_ROLL},
};

/****************************************************************************
 *  @doc INTERNAL CWDMDLGSMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | HasDialog | This method is used to
 *    determine if the specified dialog box exists in the driver.
 *
 *  @parm int | iDialog | Specifies the desired dialog box. This is a member
 *    of the <t VfwCaptureDialogs> enumerated data type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_UNEXPECTED | Unrecoverable error
 *  @flag S_OK | If the driver contains the dialog box
 *  @flag S_FALSE | If the driver doesn't contain the dialog box
 ***************************************************************************/
HRESULT CWDMCapDev::HasDialog(IN int iDialog)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CWDMCapDev::HasDialog")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, TEXT("%s: begin"), _fx_));

        // Validate input parameters
        ASSERT((iDialog == VfwCaptureDialog_Source) || (iDialog == VfwCaptureDialog_Format) || (iDialog == VfwCaptureDialog_Display));
        if (iDialog == VfwCaptureDialog_Source)
                Hr = S_OK;
        else if (iDialog == VfwCaptureDialog_Format)
                Hr = S_FALSE;
        else if (iDialog == VfwCaptureDialog_Display)
                Hr = S_FALSE;
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, TEXT("%s:   ERROR: Invalid argument"), _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, TEXT("%s: end"), _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CWDMDLGSMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | ShowDialog | This method is used to
 *    displaay the specified dialog box.
 *
 *  @parm int | iDialog | Specifies the desired dialog box. This is a member
 *    of the <t VfwCaptureDialogs> enumerated data type.
 *
 *  @parm HWND | hwnd | Specifies the handle of the dialog box's parent
 *    window.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_UNEXPECTED | Unrecoverable error
 *  @flag VFW_E_NOT_STOPPED | The operation could not be performed because the filter is not stopped
 *  @flag VFW_E_CANNOT_CONNECT | No combination of intermediate filters could be found to make the connection
 ***************************************************************************/
HRESULT CWDMCapDev::ShowDialog(IN int iDialog, IN HWND hwnd)
{
        HRESULT                 Hr = NOERROR;
        PROPSHEETHEADER Psh;
        HPROPSHEETPAGE  Pages[MAX_PAGES];
    CWDMDialog          VideoSettings(IDD_VIDEO_SETTINGS, NumVideoSettings, PROPSETID_VIDCAP_VIDEOPROCAMP, g_VideoSettingControls, m_pCaptureFilter);
    CWDMDialog          CamControl(IDD_CAMERA_CONTROL, NumCameraControls, PROPSETID_VIDCAP_CAMERACONTROL, g_CameraControls, m_pCaptureFilter);

        FX_ENTRY("CWDMCapDev::ShowDialog")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, TEXT("%s: begin"), _fx_));

        ASSERT((iDialog == VfwCaptureDialog_Source) || (iDialog == VfwCaptureDialog_Format) || (iDialog == VfwCaptureDialog_Display));

        // Before we bring the format dialog up, make sure we're not streaming, or about to
        // Also make sure another dialog isn't already up (I'm paranoid)
        if (iDialog == VfwCaptureDialog_Format || iDialog == VfwCaptureDialog_Display)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, TEXT("%s:   ERROR: Unsupported dialog!"), _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        if (hwnd == NULL)
                hwnd = GetDesktopWindow();

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, TEXT("%s:   SUCCESS: Putting up Source dialog..."), _fx_));

        // Initialize property sheet header     and common controls
        Psh.dwSize              = sizeof(Psh);
        Psh.dwFlags             = PSH_DEFAULT;
        Psh.hInstance   = g_hInst;
        Psh.hwndParent  = hwnd;
        if(m_bCached_vcdi)
                Psh.pszCaption  = m_vcdi.szDeviceDescription;
        else
                Psh.pszCaption  = g_aDeviceInfo[m_dwDeviceIndex].szDeviceDescription;
        Psh.nPages              = 0;
        Psh.nStartPage  = 0;
        Psh.pfnCallback = NULL;
        Psh.phpage              = Pages;

    // Create the video settings property page and add it to the video settings sheet
        if (Pages[Psh.nPages] = VideoSettings.Create())
                Psh.nPages++;

    // Create the camera control property page and add it to the video settings sheet
        if (Pages[Psh.nPages] = CamControl.Create())
                Psh.nPages++;

        // Put up the property sheet
        if (Psh.nPages && PropertySheet(&Psh) >= 0)
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, TEXT("%s:   SUCCESS: ...videoDialog succeeded"), _fx_));
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, TEXT("%s:   ERROR: ...videoDialog failed!"), _fx_));
                Hr = E_FAIL;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, TEXT("%s: end"), _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc HPROPSHEETPAGE | CWDMDialog | Create | This function creates a new
 *    page for a property sheet.
 *
 *  @rdesc Returns the handle to the new property sheet if successful, or
 *    NULL otherwise.
 ***************************************************************************/
HPROPSHEETPAGE CWDMDialog::Create()
{
    PROPSHEETPAGE psp;

    psp.dwSize        = sizeof(psp);
    psp.dwFlags       = PSP_USEREFPARENT;
    psp.hInstance     = g_hInst;
    psp.pszTemplate   = MAKEINTRESOURCE(m_DlgID);
    psp.pfnDlgProc    = (DLGPROC)BaseDlgProc;
    psp.pcRefParent   = 0;
    psp.pfnCallback   = (LPFNPSPCALLBACK)NULL;
    psp.lParam        = (LPARAM)this;

    return CreatePropertySheetPage(&psp);
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc BOOL | CWDMDialog | BaseDlgProc | This function implements
 *    the dialog box procedure for the page of a property sheet.
 *
 *  @parm HWND | hDlg | Handle to dialog box.
 *
 *  @parm UINT | uMessage | Message sent to the dialog box.
 *
 *  @parm WPARAM | wParam | First message parameter.
 *
 *  @parm LPARAM | lParam | Second message parameter.
 *
 *  @rdesc Except in response to the WM_INITDIALOG message, the dialog box
 *    procedure returns nonzero if it processes the message, and zero if it
 *    does not.
 ***************************************************************************/
BOOL CALLBACK CWDMDialog::BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    CWDMDialog *pSV = (CWDMDialog*)GetWindowLong(hDlg, DWL_USER);

        FX_ENTRY("CWDMDialog::BaseDlgProc");

    switch (uMessage)
    {
        case WM_INITDIALOG:
                        {
                                LPPROPSHEETPAGE psp=(LPPROPSHEETPAGE)lParam;
                                pSV=(CWDMDialog*)psp->lParam;
                                pSV->m_hDlg = hDlg;
                                SetWindowLong(hDlg,DWL_USER,(LPARAM)pSV);
                                pSV->m_bInit = FALSE;
                                pSV->m_bChanged = FALSE;
                                return TRUE;
                        }
                        break;

        case WM_COMMAND:
            if (pSV)
            {
                int iRet = pSV->DoCommand(LOWORD(wParam), HIWORD(wParam));
                if (!iRet && pSV->m_bInit)
                                {
                                        PropSheet_Changed(GetParent(pSV->m_hDlg), pSV->m_hDlg);
                                        pSV->m_bChanged = TRUE;
                                }
                return iRet;
            }
                        break;

        case WM_HSCROLL:
                        if (pSV && pSV->m_pCaptureFilter && pSV->m_pCaptureFilter->m_pCapDev && pSV->m_pPC)
                        {
                                HWND hwndControl = (HWND) lParam;
                                HWND hwndSlider;
                                ULONG i;
                                TCHAR szTemp[32];

                                for (i = 0 ; i < pSV->m_dwNumControls ; i++)
                                {
                                        hwndSlider = GetDlgItem(pSV->m_hDlg, pSV->m_pPC[i].uiSlider);

                                        // find matching slider
                                        if (hwndSlider == hwndControl)
                                        {
                                                LONG lValue = (LONG)SendMessage(GetDlgItem(pSV->m_hDlg, pSV->m_pPC[i].uiSlider), TBM_GETPOS, 0, 0);
                                                ((CWDMCapDev *)(pSV->m_pCaptureFilter->m_pCapDev))->SetPropertyValue(pSV->m_guidPropertySet, pSV->m_pPC[i].uiProperty, lValue, KSPROPERTY_FLAGS_MANUAL, pSV->m_pPC[i].ulCapabilities);
                                                pSV->m_pPC[i].lCurrentValue = lValue;
                                                wsprintf(szTemp,"%d", lValue);
                                                SetWindowText(GetDlgItem(pSV->m_hDlg, pSV->m_pPC[i].uiCurrent), szTemp);
                                                break;
                                        }
                                }
                        }

                        break;

        case WM_NOTIFY:
                        if (pSV)
                        {
                                switch (((NMHDR FAR *)lParam)->code)
                                {
                                        case PSN_SETACTIVE:
                                                {
                                                        // We call out here specially so we can mark this page as having been init'd.
                                                        int iRet = pSV->SetActive();
                                                        pSV->m_bInit = TRUE;
                                                        return iRet;
                                                }
                                                break;

                                        case PSN_APPLY:
                                                // Since we apply the changes on the fly when the user moves the slide bars,
                                                // there isn't much left to do on PSN_APPLY...
                                                if (pSV->m_bChanged)
                                                        pSV->m_bChanged = FALSE;
                                                return FALSE;
                                                break;

                                        case PSN_QUERYCANCEL:
                                                return pSV->QueryCancel();
                                                break;

                                        default:
                                                break;
                                }
                        }
                        break;

                default:
                        return FALSE;
    }

    return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc void | CWDMDialog | CWDMDialog | Property page class constructor.
 *
 *  @parm int | DlgId | Resource ID of the property page dialog.
 *
 *  @parm DWORD | dwNumControls | Number of controls to display in the page.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are showing in
 *    the property page.
 *
 *  @parm PPROPSLIDECONTROL | pPC | Pointer to the list of slider controls
 *    to be displayed in the property page.
 *
 *  @parm PDWORD | pdwHelp | Pointer to the list of help IDs to be displayed
 *    in the property page.
 *
 *  @parm CWDMPin * | pCWDMPin | Pointer to the kernel streaming object
 *    we will query the property on.
 ***************************************************************************/
CWDMDialog::CWDMDialog(int DlgId, DWORD dwNumControls, GUID guidPropertySet, PPROPSLIDECONTROL pPC, CTAPIVCap *pCaptureFilter)
{
        FX_ENTRY("CWDMDialog::CWDMDialog");

        ASSERT(dwNumControls);
        ASSERT(pPC);
        ASSERT(pCaptureFilter);

        m_DlgID                         = DlgId;
        m_pCaptureFilter        = pCaptureFilter;
        m_dwNumControls         = dwNumControls;
        m_guidPropertySet       = guidPropertySet;
        m_pPC                           = pPC;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc int | CWDMDialog | SetActive | This function handles
 *    PSN_SETACTIVE by intializing all the property page controls.
 *
 *  @rdesc Always returns 0.
 ***************************************************************************/
int CWDMDialog::SetActive()
{
        FX_ENTRY("CWDMDialog::SetActive");

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, TEXT("%s: begin"), _fx_));

    if (!m_pCaptureFilter || !m_pPC || !m_pCaptureFilter->m_pCapDev)
        return 0;

    // Returns zero to accept the activation or
    // -1 to activate the next or previous page
    // (depending on whether the user chose the Next or Back button)
    LONG i;
    EnableWindow(m_hDlg, TRUE);

    if (m_bInit)
        return 0;

    LONG  j, lValue, lMin, lMax, lStep;
    ULONG ulCapabilities, ulFlags;
    TCHAR szDisplay[256];

    for (i = j = 0 ; i < (LONG)m_dwNumControls; i++)
        {
        // Get the current value
        if (SUCCEEDED(((CWDMCapDev *)(m_pCaptureFilter->m_pCapDev))->GetPropertyValue(m_guidPropertySet, m_pPC[i].uiProperty, &lValue, &ulFlags, &ulCapabilities)))
                {
            LoadString(g_hInst, m_pPC[i].uiString, szDisplay, sizeof(szDisplay));
            SetWindowText(GetDlgItem(m_hDlg, m_pPC[i].uiStatic), szDisplay);

            // Get the Range of Values possible.
            if (SUCCEEDED(((CWDMCapDev *)(m_pCaptureFilter->m_pCapDev))->GetRangeValues(m_guidPropertySet, m_pPC[i].uiProperty, &lMin, &lMax, &lStep)))
                        {
                                HWND hTB = GetDlgItem(m_hDlg, m_pPC[i].uiSlider);

                                SendMessage(hTB, TBM_SETTICFREQ, (lMax-lMin)/lStep, 0);
                                SendMessage(hTB, TBM_SETRANGE, 0, MAKELONG(lMin, lMax));
                        }
            else
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, TEXT("%s:   ERROR: Cannot get range values for this property ID = %d"), _fx_, m_pPC[j].uiProperty));
            }

            // Save these value for Cancel
            m_pPC[i].lLastValue = m_pPC[i].lCurrentValue = lValue;
            m_pPC[i].lMin                              = lMin;
            m_pPC[i].lMax                              = lMax;
            m_pPC[i].ulCapabilities                    = ulCapabilities;

            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TRUE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiStatic), TRUE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), TRUE);

                        SendMessage(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TBM_SETPOS, TRUE, lValue);
                        wsprintf(szDisplay,"%d", lValue);
                        SetWindowText(GetDlgItem(m_hDlg, m_pPC[i].uiCurrent), szDisplay);

                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, TEXT("%s:   Capability = 0x%08lX; Flags=0x%08lX; lValue=%d"), _fx_, ulCapabilities, ulFlags, lValue));
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, TEXT("%s:   switch(%d):"), _fx_, ulCapabilities & (KSPROPERTY_FLAGS_MANUAL | KSPROPERTY_FLAGS_AUTO)));

            switch (ulCapabilities & (KSPROPERTY_FLAGS_MANUAL | KSPROPERTY_FLAGS_AUTO))
                        {
                                case KSPROPERTY_FLAGS_MANUAL:
                                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);    // Disable auto
                                        break;

                                case KSPROPERTY_FLAGS_AUTO:
                                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);    // Disable slider;
                                        // always auto!
                                        SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_SETCHECK, 1, 0);
                                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);    // Disable auto (greyed out)
                                        break;

                                case (KSPROPERTY_FLAGS_MANUAL | KSPROPERTY_FLAGS_AUTO):
                                        // Set flags
                                        if (ulFlags & KSPROPERTY_FLAGS_AUTO)
                                        {
                                                // Set auto check box; greyed out slider
                                                SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_SETCHECK, 1, 0);
                                                EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);
                                        }
                                        else
                                        {
                                                // Unchecked auto; enable slider
                                                SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_SETCHECK, 0, 0);
                                                EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TRUE);
                                        }
                                        break;

                                case 0:
                                default:
                                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);    // Disable slider; always auto!
                                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);    // Disable auto (greyed out)
                                        break;
            }

            j++;

        }
                else
                {
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiStatic), FALSE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);
        }
    }

    // Disable the "default" push button;
    // or inform user that no control is enabled.
    if (j == 0)
        EnableWindow(GetDlgItem(m_hDlg, IDC_DEFAULT), FALSE);

    return 0;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc int | CWDMDialog | DoCommand | This function handles WM_COMMAND. This
 *    is where a click on the Default button or one of the Auto checkboxes
 *    is handled
 *
 *  @parm WORD | wCmdID | Command ID.
 *
 *  @parm WORD | hHow | Notification code.
 *
 *  @rdesc Always returns 1.
 ***************************************************************************/
int CWDMDialog::DoCommand(WORD wCmdID, WORD hHow)
{
    // If a user select default settings of the video format
    if (wCmdID == IDC_DEFAULT)
        {
        if (m_pCaptureFilter && m_pCaptureFilter->m_pCapDev && m_pPC)
                {
            HWND hwndSlider;
            LONG  lDefValue;
                        TCHAR szTemp[32];

            for (ULONG i = 0 ; i < m_dwNumControls ; i++)
                        {
                hwndSlider = GetDlgItem(m_hDlg, m_pPC[i].uiSlider);

                if (IsWindowEnabled(hwndSlider))
                                {
                    if (SUCCEEDED(((CWDMCapDev *)(m_pCaptureFilter->m_pCapDev))->GetDefaultValue(m_guidPropertySet, m_pPC[i].uiProperty, &lDefValue)))
                                        {
                        if (lDefValue != m_pPC[i].lCurrentValue)
                                                {
                            ((CWDMCapDev *)(m_pCaptureFilter->m_pCapDev))->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, lDefValue, KSPROPERTY_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
                                                        SendMessage(hwndSlider, TBM_SETPOS, TRUE, lDefValue);
                                                        wsprintf(szTemp,"%d", lDefValue);
                                                        SetWindowText(GetDlgItem(m_hDlg, m_pPC[i].uiCurrent), szTemp);
                                                        m_pPC[i].lCurrentValue = lDefValue;
                        }
                    }
                }
            }
        }
        return 1;
    }
        else if (hHow == BN_CLICKED)
        {
        if (m_pCaptureFilter && m_pCaptureFilter->m_pCapDev && m_pPC)
                {
            for (ULONG i = 0 ; i < m_dwNumControls ; i++)
                        {
                // find matching slider
                if (m_pPC[i].uiAuto == wCmdID)
                                {
                    if (BST_CHECKED == SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_GETCHECK, 1, 0))
                                        {
                        ((CWDMCapDev *)(m_pCaptureFilter->m_pCapDev))->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, m_pPC[i].lCurrentValue, KSPROPERTY_FLAGS_AUTO, m_pPC[i].ulCapabilities);
                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);
                    }
                                        else
                                        {
                        ((CWDMCapDev *)(m_pCaptureFilter->m_pCapDev))->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, m_pPC[i].lCurrentValue, KSPROPERTY_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TRUE);
                    }
                    break;
                }
            }
        }
    }

    return 1;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc int | CWDMDialog | QueryCancel | This function handles
 *    PSN_QUERYCANCEL by resetting the values of the controls.
 *
 *  @rdesc Always returns 0.
 ***************************************************************************/
int CWDMDialog::QueryCancel()
{
    if (m_pCaptureFilter && m_pCaptureFilter->m_pCapDev && m_pPC)
        {
        for (ULONG i = 0 ; i < m_dwNumControls ; i++)
                {
            if (IsWindowEnabled(GetDlgItem(m_hDlg, m_pPC[i].uiSlider)))
                        {
                if (m_pPC[i].lLastValue != m_pPC[i].lCurrentValue)
                    ((CWDMCapDev *)(m_pCaptureFilter->m_pCapDev))->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, m_pPC[i].lLastValue, KSPROPERTY_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
            }
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivcap\vidctrl.cpp ===
/****************************************************************************
 *  @doc INTERNAL VIDCTRL
 *
 *  @module VidCtrl.cpp | Source file for the <c CTAPIVCap>
 *    class methods used to implement the <i IAMVideoControl> interface.
 ***************************************************************************/

#include "Precomp.h"

/*****************************************************************************
 *  @doc INTERNAL CVIDEOCSTRUCTENUM
 *
 *  @enum VideoControlFlags | The <t VideoControlFlags> enum is used to describe
 *    video modes.
 *
 *  @emem VideoControlFlag_FlipHorizontal | Specifies that the camera control
 *    setting can be modified manually.
 *
 *  @emem VideoControlFlag_FlipVertical | Specifies that the camera control
 *    setting can be modified automatically.
 *
 *  @emem VideoControlFlag_ExternalTriggerEnable | Specifies that the camera
 *    control setting can be modified automatically.
 *
 *  @emem VideoControlFlag_Trigger | Specifies that the camera control setting
 *    can be modified automatically.
 ****************************************************************************/

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | GetCaps | This method is used to retrieve
 *    the capabilities of the TAPI MSP Video Capture filter regarding
 *    flipping pictures and external triggers.
 *
 *  @parm IPin* | pPin | Used to specify the video output pin to query
 *    capabilities from.
 *
 *  @parm long* | pCapsFlags | Used to retrieve a value representing a
 *    combination of the flags from the <t VideoControlFlags> enumeration.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVCap::GetCaps(IN IPin *pPin, OUT long *pCapsFlags)
{
	HRESULT Hr = NOERROR;
	IVideoControl *pIVideoControl;

	FX_ENTRY("CTAPIVCap::GetCaps")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pPin);
	ASSERT(pCapsFlags);
	if (!pPin || !pCapsFlags)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Delegate call to the pin
	if (SUCCEEDED(Hr = pPin->QueryInterface(__uuidof(IVideoControl), (void **)&pIVideoControl)))
	{
		Hr = pIVideoControl->GetCaps(pCapsFlags);
		pIVideoControl->Release();
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | SetMode | This method is used to set the
 *    video control mode of operation.
 *
 *  @parm IPin* | pPin | Used to specify the pin to set the video control
 *    mode on.
 *
 *  @parm long | Mode | Used to specify a combination of the flags from the
 *    <t VideoControlFlags> enumeration.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVCap::SetMode(IN IPin *pPin, IN long Mode)
{
	HRESULT Hr = NOERROR;
	IVideoControl *pIVideoControl;

	FX_ENTRY("CTAPIVCap::SetMode")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pPin);
	if (!pPin)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Delegate call to the pin
	if (SUCCEEDED(Hr = pPin->QueryInterface(__uuidof(IVideoControl), (void **)&pIVideoControl)))
	{
		Hr = pIVideoControl->SetMode(Mode);
		pIVideoControl->Release();
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | GetMode | This method is used to retrieve
 *    the video control mode of operation.
 *
 *  @parm IPin* | pPin | Used to specify the pin to get the video control
 *    mode from.
 *
 *  @parm long | Mode | Pointer to a value representing a combination of the
 *    flags from the <t VideoControlFlags> enumeration.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVCap::GetMode(IN IPin *pPin, OUT long *Mode)
{
	HRESULT Hr = NOERROR;
	IVideoControl *pIVideoControl;

	FX_ENTRY("CTAPIVCap::GetMode")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pPin);
	ASSERT(Mode);
	if (!pPin || !Mode)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Delegate call to the pin
	if (SUCCEEDED(Hr = pPin->QueryInterface(__uuidof(IVideoControl), (void **)&pIVideoControl)))
	{
		Hr = pIVideoControl->GetMode(Mode);
		pIVideoControl->Release();
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | GetCurrentActualFrameRate | This method is
 *    used to retrieve the actual frame rate, expressed as a frame duration
 *    in 100 ns units.
 *
 *  @parm IPin* | pPin | Used to specify the pin to retrieve the frame rate
 *    from.
 *
 *  @parm LONGLONG* | ActualFrameRate | Pointer to the frame rate in frame
 *    duration in 100 nS units.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVCap::GetCurrentActualFrameRate(IN IPin *pPin, OUT LONGLONG *ActualFrameRate)
{
	HRESULT Hr = NOERROR;
	IVideoControl *pIVideoControl;

	FX_ENTRY("CTAPIVCap::GetCurrentActualFrameRate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pPin);
	ASSERT(ActualFrameRate);
	if (!pPin || !ActualFrameRate)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Delegate call to the pin
	if (SUCCEEDED(Hr = pPin->QueryInterface(__uuidof(IVideoControl), (void **)&pIVideoControl)))
	{
		Hr = pIVideoControl->GetCurrentActualFrameRate(ActualFrameRate);
		pIVideoControl->Release();
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | GetMaxAvailableFrameRate | This method is
 *    used to retrieve the maximum frame rate currently available, based on
 *    bus bandwidth usage for connections, such as USB (Universal Serial Bus)
 *    and IEEE 1394, where the maximum frame rate may be limited due to
 *    bandwidth availability.
 *
 *  @parm IPin* | pPin | Used to specify the pin to retrieve the frame rate
 *    from.
 *
 *  @parm long | iIndex | Used to specify the index of the format to query
 *    for frame rates. This index corresponds to the order in which formats
 *    are enumerated by IAMStreamConfig::GetStreamCaps. The value must range
 *    between 0 and the number of supported <t VIDEO_STREAM_CONFIG_CAPS>
 *    structures returned by IAMStreamConfig::GetNumberOfCapabilities.
 *
 *  @parm SIZE | Dimensions | Used to specify the frame's image size (width
 *    and height) in pixels.
 *
 *  @parm LONGLONG* | MaxAvailableFrameRate | Pointer to the maximum
 *    available frame rate in frame duration in 100 nS units.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVCap::GetMaxAvailableFrameRate(IN IPin *pPin, IN long iIndex, IN SIZE Dimensions, OUT LONGLONG *MaxAvailableFrameRate)
{
	HRESULT Hr = NOERROR;
	IVideoControl *pIVideoControl;

	FX_ENTRY("CTAPIVCap::GetMaxAvailableFrameRate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pPin);
	ASSERT(MaxAvailableFrameRate);
	if (!pPin || !MaxAvailableFrameRate)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Delegate call to the pin
	if (SUCCEEDED(Hr = pPin->QueryInterface(__uuidof(IVideoControl), (void **)&pIVideoControl)))
	{
		Hr = pIVideoControl->GetMaxAvailableFrameRate(iIndex, Dimensions, MaxAvailableFrameRate);
		pIVideoControl->Release();
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | GetFrameRateList | This method is
 *    used to retrieve the list of available frame rates.
 *
 *  @parm IPin* | pPin | Used to specify the pin to retrieve the frame rates
 *    from.
 *
 *  @parm long | iIndex | Used to specify the index of the format to query
 *    for frame rates. This index corresponds to the order in which formats
 *    are enumerated by IAMStreamConfig::GetStreamCaps. The value must range
 *    between 0 and the number of supported <t VIDEO_STREAM_CONFIG_CAPS>
 *    structures returned by IAMStreamConfig::GetNumberOfCapabilities.
 *
 *  @parm SIZE | Dimensions | Used to specify the frame's image size (width
 *    and height) in pixels.
 *
 *  @parm long* | ListSize | Pointer to the number of elements in the list
 *    of frame rates.
 *
 *  @parm LONGLONG** | MaxAvailableFrameRate | Pointer to an array of frame
 *    rates in 100 ns units. Can be NULL if only <p ListSize> is wanted.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVCap::GetFrameRateList(IN IPin *pPin, IN long iIndex, IN SIZE Dimensions, OUT long *ListSize, OUT LONGLONG **FrameRates)
{
	HRESULT Hr = NOERROR;
	IVideoControl *pIVideoControl;

	FX_ENTRY("CTAPIVCap::GetFrameRateList")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pPin);
	ASSERT(ListSize);
	ASSERT(FrameRates);
	if (!pPin || !ListSize || !FrameRates)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Delegate call to the pin
	if (SUCCEEDED(Hr = pPin->QueryInterface(__uuidof(IVideoControl), (void **)&pIVideoControl)))
	{
		Hr = pIVideoControl->GetFrameRateList(iIndex, Dimensions, ListSize, FrameRates);
		pIVideoControl->Release();
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetCaps | This method is used to retrieve
 *    the capabilities of the TAPI MSP Video Capture filter capture pin regarding
 *    flipping pictures and external triggers.
 *
 *  @parm long* | pCapsFlags | Used to retrieve a value representing a
 *    combination of the flags from the <t VideoControlFlags> enumeration.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetCaps(OUT long *pCapsFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIBasePin::GetCaps")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pCapsFlags);
	if (!pCapsFlags)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Return capabilities
	*pCapsFlags = VideoControlFlag_FlipHorizontal | VideoControlFlag_FlipVertical;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | SetMode | This method is used to set the
 *    video control mode of operation.
 *
 *  @parm long | Mode | Used to specify a combination of the flags from the
 *    <t VideoControlFlags> enumeration.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::SetMode(IN long Mode)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIBasePin::SetMode")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT((Mode & VideoControlFlag_ExternalTriggerEnable) == 0);
	ASSERT((Mode & VideoControlFlag_Trigger) == 0);
	if ((Mode & VideoControlFlag_ExternalTriggerEnable) || (Mode & VideoControlFlag_Trigger))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Set flip modes
	m_fFlipHorizontal = Mode & VideoControlFlag_FlipHorizontal;
	m_fFlipVertical = Mode & VideoControlFlag_FlipVertical;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetMode | This method is used to retrieve
 *    the video control mode of operation.
 *
 *  @parm long | Mode | Pointer to a value representing a combination of the
 *    flags from the <t VideoControlFlags> enumeration.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetMode(OUT long *Mode)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIBasePin::GetMode")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(Mode);
	if (!Mode)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Return current modes
	*Mode = 0;
	if (m_fFlipHorizontal)
		*Mode |= VideoControlFlag_FlipHorizontal;
	if (m_fFlipVertical)
		*Mode |= VideoControlFlag_FlipVertical;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetCurrentActualFrameRate | This method is
 *    used to retrieve the actual frame rate, expressed as a frame duration
 *    in 100 ns units.
 *
 *  @parm LONGLONG* | ActualFrameRate | Pointer to the frame rate in frame
 *    duration in 100 nS units.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetCurrentActualFrameRate(OUT LONGLONG *ActualFrameRate)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIBasePin::GetCurrentActualFrameRate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(ActualFrameRate);
	if (!ActualFrameRate)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Return current actual frame rate
	*ActualFrameRate = m_lCurrentAvgTimePerFrame;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetMaxAvailableFrameRate | This method is
 *    used to retrieve the maximum frame rate currently available, based on
 *    bus bandwidth usage for connections, such as USB (Universal Serial Bus)
 *    and IEEE 1394, where the maximum frame rate may be limited due to
 *    bandwidth availability.
 *
 *  @parm long | iIndex | Used to specify the index of the format to query
 *    for frame rates. This index corresponds to the order in which formats
 *    are enumerated by IAMStreamConfig::GetStreamCaps. The value must range
 *    between 0 and the number of supported <t VIDEO_STREAM_CONFIG_CAPS>
 *    structures returned by IAMStreamConfig::GetNumberOfCapabilities.
 *
 *  @parm SIZE | Dimensions | Used to specify the frame's image size (width
 *    and height) in pixels.
 *
 *  @parm LONGLONG* | MaxAvailableFrameRate | Pointer to the maximum
 *    available frame rate in frame duration in 100 nS units.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetMaxAvailableFrameRate(IN long iIndex, IN SIZE Dimensions, OUT LONGLONG *MaxAvailableFrameRate)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIBasePin::GetMaxAvailableFrameRate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(MaxAvailableFrameRate);
	if (!MaxAvailableFrameRate)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Return max available frame rate
	*MaxAvailableFrameRate = m_lAvgTimePerFrameRangeMax;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetFrameRateList | This method is
 *    used to retrieve the list of available frame rates.
 *
 *  @parm long | iIndex | Used to specify the index of the format to query
 *    for frame rates. This index corresponds to the order in which formats
 *    are enumerated by IAMStreamConfig::GetStreamCaps. The value must range
 *    between 0 and the number of supported <t VIDEO_STREAM_CONFIG_CAPS>
 *    structures returned by IAMStreamConfig::GetNumberOfCapabilities.
 *
 *  @parm SIZE | Dimensions | Used to specify the frame's image size (width
 *    and height) in pixels.
 *
 *  @parm long* | ListSize | Pointer to the number of elements in the list
 *    of frame rates.
 *
 *  @parm LONGLONG** | MaxAvailableFrameRate | Pointer to an array of frame
 *    rates in 100 ns units. Can be NULL if only <p ListSize> is wanted.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetFrameRateList(IN long iIndex, IN SIZE Dimensions, OUT long *ListSize, OUT LONGLONG **FrameRates)
{
	HRESULT Hr = NOERROR;
	PLONGLONG pFrameRate;

	FX_ENTRY("CTAPIBasePin::GetFrameRateList")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(ListSize);
	if (!ListSize)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the number of frame rates
	if (m_lAvgTimePerFrameRangeMax > m_lAvgTimePerFrameRangeMin && m_lAvgTimePerFrameRangeSteppingDelta)
	{
		*ListSize = (LONG)((m_lAvgTimePerFrameRangeMax - m_lAvgTimePerFrameRangeMin) / m_lAvgTimePerFrameRangeSteppingDelta);
	}
	else
	{
		*ListSize = 1;
	}

	// Get the actual frame rates
	if (FrameRates)
	{
		if (*FrameRates = (PLONGLONG)CoTaskMemAlloc(sizeof(LONGLONG) * *ListSize))
		{
			pFrameRate = *FrameRates;
			for (LONG j=0 ; j < *ListSize; j++)
			{
				// Spew the list of sizes
				*pFrameRate++ = (LONGLONG)(m_lAvgTimePerFrameRangeMin + m_lAvgTimePerFrameRangeSteppingDelta * j);
			}
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory!", _fx_));
			Hr = E_OUTOFMEMORY;
			goto MyExit;
		}
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivcap\wrkrthd.cpp ===
/****************************************************************************
 *  @doc INTERNAL WRKRTHD
 *
 *  @module WrkrThd.cpp | Source file for the <c CTAPIVCap> class methods
 *    used to implement the video capture worker thread.
 ***************************************************************************/

#include "Precomp.h"

EXTERN_C int g_IsNT;

#define __WRKRTHD__
#include "dbgxtra.h"

#ifdef XTRA_TRACE
#include "dbgxtra.c"
#endif

//#define DEBUG_STREAMING
#define DEBUG_STREAMING_BRK 1

#ifdef DEBUG_STREAMING
DWORD debug_streaming_flag=0;
#define ODS(str)    OutputDebugString(str);      DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: DBG_STRM %s", _fx_,str))

DWORD crca[6]={0};

#endif

#ifndef SLSH     // actually it is previously defined in dbgxtra.h, but just in case ...
#define SLSH(a)    a##/
#endif


//#define LOOPBUGFIX
#ifndef LOOPBUGFIX    // cristiai: isolate statements for the loopbug fix ...
    #define TEST_LBUG SLSH(/)
#else
    #define TEST_LBUG
#endif

#if defined(DEBUG) && defined(DEBUG_STREAMING)
    #define DBGONLY
#else
    #define DBGONLY SLSH(/)
#endif

#ifdef DEBUG
#define DBGUTIL_ENABLE
#endif

#define WRKRTHD_DEBUG
//--//#include "dbgutil.h" // this defines the __DBGUTIL_H__ below
#if defined(DBGUTIL_ENABLE) && defined(__DBGUTIL_H__)

  #ifdef WRKRTHD_DEBUG
    DEFINE_DBG_VARS(WrkrThd, (NTSD_OUT | LOG_OUT), 0x8000);
  #else
    DEFINE_DBG_VARS(WrkrThd, 0, 0);
  #endif
  #define D(f) if(g_dbg_WrkrThd & (f))
  #define DEQ(f) if((g_dbg_WrkrThd & (f)) == (f))

#else
  #undef WRKRTHD_DEBUG

  #define D(f) ; / ## /
  #define DEQ(f) ; / ## /
  #define dprintf ; / ## /
  #define dout ; / ## /
#endif


/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | ThreadProc | Capture worker thread.
 *
 *  @rdesc This method returns 0.
 *
 *  @comm General strategy for thread synchronization:
 *    as much as possible we try to handle thread state transitions without
 *    trying to grab any critical sections. we use InterlockedExchange of a
 *    thread state variable and count on the fact that only Active and Inactive
 *    and the ThreadProc can change the thread state
 *
 *    this works because: the caller of Active/Inactive is serialized so we
 *    will never try to make two state changes simultaneously.
 *    so state transitions boil down to a few simple possibilities:
 *
 *    Not->Create   - Create() does this. effectively serializes Create
 *                    so that the first thread does the work and subsequent
 *                    threads fail.
 *
 *    Create->Init  - worker does this when it starts up. worker will always
 *                    proceed to Pause, this state exists only to make debugging
 *                    easier.
 *    Init->Pause   - worker does this when done with initialization.
 *
 *    Pause->Run    - user does  this via Run()
 *    Run->Pause    - user does this via Pause()
 *
 *    Run->Stop     - user does this via Stop()
 *    Pause->Stop   - user does this via Stop()
 *
 *    Stop->Destroy - another debugging state. worker sets destroy to indicate
 *                    that it has noticed Stop request and is not shutting down
 *                    thread always proceeds to Exit from
 *    Destroy->Exit - worker does this prior to dying.  this is a debug transition
 *    Exit->Not     - Destroy() does this after waiting for the worker to die.
 *
 *    When Active returns, worker should always be in Pause or Run state
 *    When Inactive returns, worker should always be in Not state (worker does
 *       not exist)
 *
 ***************************************************************************/
DWORD CTAPIVCap::ThreadProc()
{
    ThdState state;

    FX_ENTRY("CTAPIVCap::ThreadProc")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    state = ChangeThdState (TS_Init);
    ASSERT (state == TS_Create);
    if (state != TS_Create)
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid state!", _fx_));
        goto MyExit;
    }

    // Do the work necessary to go into the paused state
    if (FAILED(Prepare()))
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Error preparing the allocator. Can't capture!", _fx_));
        // Main thread is blocked right now!
        SetEvent(m_hEvtPause);
        goto MyExit;
    }

    // Go into paused state
    state = ChangeThdState (TS_Pause);
    ASSERT (state == TS_Init);
    if (state != TS_Init)
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid state!", _fx_));
        goto MyExit;
    }

    SetEvent(m_hEvtPause);

    while (m_state != TS_Stop)
    {
        // Don't start capturing until we run (or stop)
        WaitForSingleObject(m_hEvtRun, INFINITE);
        ResetEvent(m_hEvtRun);

        // Stream until not running, or we get an error
        // There is no reason to call Capture if WaitForSingleObject
        // woke up on a stop event...
        if (m_state != TS_Stop)
            Capture();
    }

    // We expect to be in the Stop state when we get to here.
    // Flush any downstream buffers.
    ASSERT (m_state == TS_Stop);

    // For next time we pause
    ResetEvent(m_hEvtPause);
    if (m_pCapturePin && m_pCapturePin->IsConnected())
        m_pCapturePin->Flush();
    if (m_pPreviewPin && m_pPreviewPin->IsConnected())
        m_pPreviewPin->Flush();
    if (m_pRtpPdPin && m_pRtpPdPin->IsConnected())
        m_pRtpPdPin->Flush();

MyExit:

    // Change the state to destroy to indicate that we are exiting
    state = ChangeThdState (TS_Destroy);

    // Free stuff
    Unprepare();

    // Change state to Exit and then get out of here
    ChangeThdState (TS_Exit);

    return 0;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | ThreadProcInit | Thread init stub.
 *
 *  @rdesc This method returns 0
 ***************************************************************************/
DWORD WINAPI CTAPIVCap::ThreadProcInit (void * pv)
{
   CTAPIVCap * pThis = (CTAPIVCap *) pv;
   return pThis->ThreadProc();
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | CreateThd | This method creates the
 *    capture worker thread.
 *
 *  @rdesc This method returns TRUE on success, FALSE otherwise.
 ***************************************************************************/
BOOL CTAPIVCap::CreateThd()
{
    BOOL fRes = TRUE;

    FX_ENTRY("CTAPIVCap::CreateThd")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    // Return fail if someone else is already creating / has created
    // the worker thread
    if (ChangeThdState(TS_Create) > TS_Not)
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Thread already created!", _fx_));
        goto MyError0;
    }

    // Create Pause event
    ASSERT (!m_hEvtPause);
    if (!(m_hEvtPause = CreateEvent(NULL, TRUE, FALSE, NULL)))
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't create Pause event!", _fx_));
        goto MyError0;
    }

    // Create Run event
    ASSERT (!m_hEvtRun);
    if (!(m_hEvtRun = CreateEvent(NULL, TRUE, FALSE, NULL)))
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't create Run event!", _fx_));
        goto MyError1;
    }

    m_EventAdvise.Reset();

    // Create the worker thread
    if (!(m_hThread = CreateThread (NULL, 0, CTAPIVCap::ThreadProcInit, this, 0, &m_tid)))
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't create capture worker thread!", _fx_));
        goto MyError2;
    }

    goto MyExit;

MyError2:
    if (m_hEvtRun)
        CloseHandle(m_hEvtRun), m_hEvtRun = NULL;
MyError1:
    if (m_hEvtPause)
        CloseHandle(m_hEvtPause), m_hEvtPause = NULL;
MyError0:
    m_state = TS_Not;
    fRes = FALSE;
MyExit:
    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
    return fRes;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | DestroyThd | This method waita for the
 *    worker thread to die before performing some cleanup.
 *
 *  @rdesc This method returns TRUE
 ***************************************************************************/
BOOL CTAPIVCap::DestroyThd()
{
    FX_ENTRY("CTAPIVCap::DestroyThd")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    // Anything to destroy?
    if (m_state == TS_Not)
     goto MyExit;

    // Wait for the thread to die. (Destroy must be preceeded by
    // a Stop or we could deadlock here)
    ASSERT (m_state >= TS_Stop);
    WaitForSingleObject (m_hThread, INFINITE);
    ASSERT (m_state == TS_Exit);

    // Cleanup
    if (m_hThread)
        CloseHandle(m_hThread), m_hThread = NULL;
    m_tid = 0;
    if (m_hEvtPause)
        CloseHandle(m_hEvtPause), m_hEvtPause = NULL;
    if (m_hEvtRun)
        CloseHandle(m_hEvtRun), m_hEvtRun = NULL;
    m_state = TS_Not;

MyExit:
    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
    return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | RunThd | This method puts the worker
 *    thread into the run state. This call does not wait for the state
 *    transition to be complete before returning.
 *
 *  @rdesc This method returns TRUE on success, FALSE otherwise
 ***************************************************************************/
BOOL CTAPIVCap::RunThd()
{
    BOOL fRes = TRUE;
    ThdState state;

    FX_ENTRY("CTAPIVCap::RunThd")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    // Bail if we are already running
    if (m_state == TS_Run)
    {
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: We're already running!", _fx_));
        goto MyExit;
    }

    // A transition to run state is only valid if the current
    // state is Pause (or already Running)
    state = m_state;
    if (state != TS_Run && state != TS_Pause)
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid state transition!", _fx_));
        fRes = FALSE;
        goto MyExit;
    }

    // Change the state and turn on the 'run' event
    // in case the thread is blocked on it.  If state that we are
    // changing from is not Run or Pause, then something is seriously wrong!!
    state = ChangeThdState(TS_Run);
    ASSERT(state == TS_Run || state == TS_Pause);
    SetEvent(m_hEvtRun);

    // Go capture, go! Note when we started it
    if (m_pClock)
        m_pClock->GetTime((REFERENCE_TIME *)&m_cs.rtDriverStarted);
    else
        m_cs.rtDriverStarted = m_tStart;

    // Start streaming on streaming capture devices
    m_pCapDev->StartStreaming();

    // These need to be zeroed every time the driver is told to stream, because
    // the driver will start counting from 0 again
    m_cs.dwlLastTimeCaptured = 0;
    m_cs.dwlTimeCapturedOffset = 0;

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: We're running!", _fx_));

MyExit:
    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
    return fRes;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc BOOL | CTAPIVCap | PauseThd | This method puts the capture
 *    worker thread in a paused state and wait for it to get there.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
BOOL CTAPIVCap::PauseThd()
{
    BOOL fRes = TRUE;
    ThdState state = m_state;

    FX_ENTRY("CTAPIVCap::PauseThd")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    // We're already paused
    if (state == TS_Pause)
        goto MyExit;

    // It is valid to go into the pause state only if currently in the Create/Init
    // (depending on if our thread has run yet) or Run state
    ASSERT (state == TS_Create || state == TS_Init || state == TS_Run);

    // If we are in the init state, we will fall into the pause state
    // naturally, we just have to wait for it to happen
    if (state == TS_Create || state == TS_Init)
    {
        WaitForSingleObject (m_hEvtPause, INFINITE);
        state = m_state;
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Transition Create->Init->Pause complete", _fx_));
    }
    else if (state == TS_Run)
    {
        state = ChangeThdState (TS_Pause);

        ASSERT(state == TS_Run);

        // Since we aren't running, stop streaming on streaming capture devices
        m_pCapDev->StopStreaming();

        state = m_state;
        m_cs.fReRun = TRUE;  // if we are RUN now, it will have been RUN-PAUSE-RUN
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:  SUCCESS: Transition Run->Pause complete", _fx_));
    }

    fRes = (BOOL)(state == TS_Pause);

MyExit:
    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
    return fRes;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc BOOL | CTAPIVCap | StopThd | This method puts the capture
 *    worker thread in a stopped state.
 *
 *  @rdesc Returns TRUE
 ***************************************************************************/
BOOL CTAPIVCap::StopThd()
{
    ThdState state = m_state;

    FX_ENTRY("CTAPIVCap::StopThd")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    // Are we already stopped or some other pin terminated the worker thread?
    if (state >= TS_Stop || state == TS_Not)
     goto MyExit;

    // Don't go from Run->Stop without Pause
    if (state == TS_Run)
        PauseThd();

    state = ChangeThdState (TS_Stop);

    // We won't be running, unblock our thread
    SetEvent(m_hEvtRun);

    // Next RUN is not a RUN-PAUSE-RUN
    m_cs.fReRun = FALSE;

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:  SUCCESS: Transition Pause->Stop complete", _fx_));

    // Do we expect that Stop can only be called when the thread is in a Pause state ?
    // No, it can be called also when a call to PauseThd failed, like in BasePin.cpp@414...
    //thus the assert below is commented out (see bug 209192)
    //ASSERT (state == TS_Pause);

MyExit:
    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
    return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc BOOL | CTAPIVCap | ChangeThdState | This method changes the state of the
 *    capture worker thread.
 *
 *  @rdesc Returns new thread state
 ***************************************************************************/
ThdState CTAPIVCap::ChangeThdState(ThdState state)
{
#ifdef DEBUG
    static char szState[] = "Not    \0Create \0Init   \0Pause  \0"
                            "Run    \0Stop   \0Destroy\0Exit   \0";
#endif

    FX_ENTRY("CTAPIVCap::ChangeThdState")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:  SUCCESS: ChangeThdState(%d:%s) current=%d:%s", _fx_, (int)state, (state <= TS_Exit && state >= TS_Not) ? szState + (int)state * 8 : "<Invalid>", (int)m_state, (m_state <= TS_Exit && m_state >= TS_Not) ? szState + (int)m_state * 8 : "<Invalid>"));

    return (ThdState) InterlockedExchange ((LONG *)&m_state, (LONG)state);
} ;

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINFUNCTION
 *
 *  @func DWORD | OpenVxDHandle | On Win9x we have to convert the event
 *    handle we will be using as a callback into a VxD handle. Ssince the
 *    Win9x kernel does not publish this entry point we dynamically link to
 *    it.
 *
 *  @parm HANDLE | hEvent | Specifies a event handle.
 *
 *  @rdesc Returns mapped event handle
 ***************************************************************************/
static DWORD WINAPI OpenVxDHandle(HANDLE hEvent)
{
    HMODULE hModule;
    typedef DWORD (WINAPI *PFNOPENVXDHANDLE)(HANDLE);
    static DWORD (WINAPI *pfnOpenVxDHandle)(HANDLE);

    if (!pfnOpenVxDHandle)
    {
        if (!(hModule = GetModuleHandle(TEXT("Kernel32"))))
        {
            ASSERT(0);
            return 0;
        }
        if (!(pfnOpenVxDHandle = (PFNOPENVXDHANDLE)GetProcAddress (hModule, "OpenVxDHandle")))
        {
            ASSERT(0);
            return 0;
        }
    }
    return pfnOpenVxDHandle (hEvent);
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | Capture | This method is used to
 *    run the capture loop. Executes while in the run state.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIVCap::Capture()
{
    HRESULT Hr = E_FAIL;
    DWORD dwOldPrio;
    BOOL bDiscon;
    LPTHKVIDEOHDR ptvh;
    DWORD dwBytesUsed, dwBytesExtent;
    DWORD dwCaptureTime, dwLastCaptureTime, dwCaptureWaitTime;
    DWORD dwPreviewTime, dwLastPreviewTime, dwPreviewWaitTime;
    DWORD dwLastRefCaptureTime, dwLastRefPreviewTime, dwLastRefDeviceTime, dwTime, dwWaitTime;
    BOOL fCapture, fPreview;
    HEVENT hEvent;
    UINT uiLatestIndex;
    CFrameSample *pCSample;
    CFrameSample *pPSample;
    CRtpPdSample *pRSample;
    DWORD dwNumBufferDone;
    DWORD dwDoneCount;
    REFERENCE_TIME DeviceAvgTimePerFrame;
    DWORD dwNumPreviewFramesDelivered, dwNumCaptureFramesDelivered;
    DWORD dwNumPreviewBytesDelivered, dwNumCaptureBytesDelivered;
#if defined(DEBUG) && defined(DEBUG_STREAMING)
    char szDebug[512];
#endif

    FX_ENTRY("CTAPIVCap::Capture")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    if ((dwOldPrio = GetThreadPriority(GetCurrentThread())) != THREAD_PRIORITY_HIGHEST)
        SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

    // Start streams
    bDiscon = TRUE;

    dwNumPreviewFramesDelivered = dwNumCaptureFramesDelivered = 0;
    dwNumPreviewBytesDelivered = dwNumCaptureBytesDelivered = 0;
    dwNumBufferDone = 0;
    hEvent = (HEVENT)(HANDLE)m_EventAdvise;
    dwLastRefCaptureTime = dwLastRefPreviewTime = dwLastRefDeviceTime = dwLastCaptureTime = dwLastPreviewTime = timeGetTime();
    DeviceAvgTimePerFrame = m_user.pvi->AvgTimePerFrame;

#if defined(DEBUG)
        OutputDebugString("Capture...\n");
        {       UINT i; char buf[64+36];
                for(i=0; i<m_cs.nHeaders;i++)
                        if(m_pBufferQueue[i]!=i) {
                                _itoa(i,buf,16);
                                strcat(buf," : order changed\n");
                                OutputDebugString(buf);
                        }
        }
#endif


    // Stream as long as we're running - or paused
    // The test on Pause did not exist in the original code. There is a time
    // window where m_state may be set to Paused (Pausing the graph), before any of the deliver
    // function gets to block due to the base filter m_State set to paused.
    // If you hit this window you will exit Capture!
    while ((m_state == TS_Run || m_state == TS_Pause) && m_cs.nHeaders > 0)
    {

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Loop ******** m_pBufferQueue[m_uiQueueTail] = m_pBufferQueue[%d] = %d", _fx_, m_uiQueueTail,m_pBufferQueue[m_uiQueueTail]));

        ptvh = &m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].tvh;
        pCSample = pPSample = NULL;
        pRSample = NULL;

        if (m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_Streaming)
        {
            DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Waiting for done buffer **** m_pBufferQueue[m_uiQueueTail] = m_pBufferQueue[%d] = %d", _fx_, m_uiQueueTail,m_pBufferQueue[m_uiQueueTail]));

            // STOP will hang until this event times out. So make sure this never
            // waits across a state transition
            // !!! PAUSE will still keep waiting until the timeout for slow rates
            HANDLE hStuff[2] = {m_cs.hEvtBufferDone, m_hEvtRun};
            int waitcode = WaitForMultipleObjects(2, hStuff, FALSE, 1000);
            //int waitcode = WaitForMultipleObjects(2, hStuff, FALSE, m_user.usPerFrame / 500);

            // timeout?
            if (waitcode == WAIT_TIMEOUT)
            {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   ERROR: Waiting for buffer %d TIMED OUT!", _fx_, m_pBufferQueue[m_uiQueueTail]));
                DBGONLY if(debug_streaming_flag & DEBUG_STREAMING_BRK) DebugBreak();
                continue;
            }
            else if (waitcode != WAIT_OBJECT_0)
            {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: hEvtRun was set", _fx_));
                ResetEvent(m_hEvtRun);  // don't infinite loop
                continue;
            }

#if DBG
            if (m_pCapDev->IsBufferDone(&ptvh->vh))
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: GOT %d EVENT AND DONE BIT!", _fx_, m_pBufferQueue[m_uiQueueTail]));
#endif

#if defined(DEBUG) && defined(DEBUG_STREAMING_ZZZ)
            { char *pd=szDebug; DWORD nh; BOOL b;
            pd+=wsprintf(pd, "Buffer DONE status: ");
            for(nh=dwDoneCount=0; nh<m_cs.nHeaders; nh++) {
                    // (@fixed for variable number of buffers -- Cristi) // Hmmm, you're assuming always 6 buffers here... KABOOM!
                    b=m_pCapDev->IsBufferDone(&m_cs.paHdr[m_pBufferQueue[nh]].tvh.vh);
                    pd+=wsprintf(pd, "%d[%s] ", m_pBufferQueue[nh], b ? "X" : "_");
                    if(b)
                        dwDoneCount++;
                    }
            wsprintf(pd, "(total %d) C:%d", dwDoneCount, m_uiQueueTail);
            DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   %s",_fx_, szDebug));
            OutputDebugString(szDebug);
            if(dwDoneCount==0) {
                if(debug_streaming_flag & DEBUG_STREAMING_BRK) DebugBreak();
                OutputDebugString("dwDoneCount==0");

                }
            }
#endif
            // Make sure we always use the latest DONE buffer
            dwDoneCount=0;
            while (1)
            {
                dwNumBufferDone++; dwDoneCount++;
                uiLatestIndex = m_uiQueueTail + 1;
                //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   1. Using uiLatestIndex %d",_fx_, uiLatestIndex));
                if (uiLatestIndex == m_cs.nHeaders)
                    uiLatestIndex = 0;
                if (uiLatestIndex == m_uiQueueHead)
                    break;
                //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   2. Using uiLatestIndex %d (lLock=%ld)",_fx_, uiLatestIndex,m_cs.paHdr[m_pBufferQueue[uiLatestIndex]].lLock));
                TEST_LBUG DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   2. Using uiLatestIndex %d (nUsed=%ld)",_fx_, uiLatestIndex,m_cs.paHdr[m_pBufferQueue[uiLatestIndex]].nUsedDownstream));
                if (    !(m_pCapDev->IsBufferDone(&m_cs.paHdr[m_pBufferQueue[uiLatestIndex]].tvh.vh))
                     TEST_LBUG || m_cs.paHdr[m_pBufferQueue[uiLatestIndex]].nUsedDownstream>0
                   )
                    break;
                DBGONLY if(dwDoneCount>6) {
                DBGONLY         //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   dwDoneCount == %d > 6: WRAP!",_fx_, dwDoneCount));
                DBGONLY         //OutputDebugString("dwDoneCount>6: WRAP!");
                DBGONLY         if(debug_streaming_flag & DEBUG_STREAMING_BRK) DebugBreak();
                DBGONLY         }

                //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   3. Using uiLatestIndex %d, m_uiQueueTail = %d,m_uiQueueHead = %d",_fx_, uiLatestIndex, m_uiQueueTail,m_uiQueueHead));
                // This is an old buffer and there is a newer one available - release old buffer
                // @todo Isn't there a better way to return the buffer to the device?
                //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   4. Before AddRefs lLock=%ld", _fx_, m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock));
                if (m_cs.paCaptureSamples && (pCSample = (CFrameSample *)m_cs.paCaptureSamples[m_pBufferQueue[m_uiQueueTail]]))
                    pCSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);
                if (m_cs.paPreviewSamples && (pPSample = (CFrameSample *)m_cs.paPreviewSamples[m_pBufferQueue[m_uiQueueTail]]))
                    pPSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);
                if (m_pRtpPdPin->IsConnected() && m_cs.paRtpPdSamples && (pRSample = (CRtpPdSample *)m_cs.paRtpPdSamples[m_pBufferQueue[m_uiQueueTail]]))
                    pRSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);
                //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   5. After ...      lLock=%ld", _fx_, m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock));
                m_uiQueueTail = uiLatestIndex;
                //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   6. set m_uiQueueTail = %d", _fx_, m_uiQueueTail));
                if (pPSample)
                    pPSample->Release(), pPSample = NULL;
                if (pCSample)
                    pCSample->Release(), pCSample = NULL;
                if (pRSample)
                    pRSample->Release(), pRSample = NULL;
                //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   7. After release lLock = %ld", _fx_, m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock));
                ptvh = &m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].tvh;
            }

            //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   m_pBufferQueue[%d] .. m_pBufferQueue[%d] = %d .. %d",_fx_, m_uiQueueTail, m_uiQueueHead, m_pBufferQueue[m_uiQueueTail], m_pBufferQueue[m_uiQueueHead]));
            if(dwDoneCount==0)      // no done buffers available
                    continue;
        }

#ifdef WRKRTHD_DEBUG
        { int i; DWORD crc;
        crc=Buf_CRC32((unsigned char*)ptvh->vh.lpData,ptvh->vh.dwBufferLength); // this is for m_pBufferQueue[m_uiQueueTail]
        D(4) dout(3,g_dwVideoCaptureTraceID, TRCE, "%s:   8. crc(buffer[%d] : %p) = %08lx", _fx_, m_pBufferQueue[m_uiQueueTail],ptvh,crc);
        for(i=0;i<6;i++)
                if(crca[i]==crc)
                        D(4) dprintf("%s:   crca[%d ==  %d] = %08lx * * * * * * * * * * * * * * * *\n", _fx_, i, m_pBufferQueue[m_uiQueueTail],crc);
        crca[m_pBufferQueue[m_uiQueueTail]]=crc;
        }
#endif
        TEST_LBUG //we are going to use the buffer, so mark it in use down stream below
        TEST_LBUG DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:  -9. m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].nUsedDownstream = %ld", _fx_,m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].nUsedDownstream));
        TEST_LBUG InterlockedCompareExchange(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].nUsedDownstream,1,0);
        TEST_LBUG DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:  =9. m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].nUsedDownstream = %ld", _fx_,m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].nUsedDownstream));
        TEST_LBUG OutputDebugString("m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].nUsedDownstream <- 1\n");

#ifdef WRKRTHD_DEBUG
        D(0x8000)
        if (m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_Streaming)
        { int i;
          D(1) dprintf("Image buffer at %p (len = %d)\n",(unsigned char*)ptvh->vh.lpData,ptvh->vh.dwBufferLength);
          D(1) dprintf("W 4CC used = %lX : '%.4s' (bitcount = %d )\n", g_dbg_4cc, &g_dbg_4cc, g_dbg_bc);

          //D(1) dprintf("YUY2 160 x 120 means %d\n", 160*120*2);
          //D(1) dprintf("I420 176 x 144 means %d\n", 176*144+(176*144)/2);

          D(1) hex_dump((unsigned char*)ptvh->vh.lpData,16);
          D(1) fill4cc(g_dbg_4cc,g_dbg_bc, (unsigned char*)ptvh->vh.lpData, g_dbg_w, g_dbg_h, "\x0e\x64\x40");
          for(i=0; i<20; i++)
                set4cc(g_dbg_4cc,g_dbg_bc, (unsigned char*)ptvh->vh.lpData, g_dbg_w, g_dbg_h, "\xa0\x10\xd0",i,i);
          for(i=0; i<20; i++)
                set4cc(g_dbg_4cc,g_dbg_bc, (unsigned char*)ptvh->vh.lpData, g_dbg_w, g_dbg_h, "\xa0\x10\xd0",20-i,i);
          //for(i=0; i<80; i++)
          //      set4cc(g_dbg_4cc,g_dbg_bc, (unsigned char*)ptvh->vh.lpData, g_dbg_w, g_dbg_h, "\xa0\x10\xd0",10+i,20+i/2);
          D(2) DebugBreak();
        }
#endif

        dwCaptureTime = dwPreviewTime = dwTime = timeGetTime();

        // Note the clock time as close as possible to the capturing of this
        // frame.
        if (m_pClock)
            m_pClock->GetTime((REFERENCE_TIME *)&m_cs.rtThisFrameTime);
        else
            m_cs.rtThisFrameTime = (REFERENCE_TIME)dwTime * 10000;

        // Evaluate the  rate at which video frames are coming from the capture device
        if (dwNumBufferDone && ((dwTime - dwLastRefDeviceTime) > 1000))
        {
            if (dwNumBufferDone)
                DeviceAvgTimePerFrame = (REFERENCE_TIME)(dwTime - dwLastRefDeviceTime) * 10000 / dwNumBufferDone;
            dwNumBufferDone = 0;
            dwLastRefDeviceTime = dwTime;
        }

        // Do we have a use for this frame on the capture pin?
        if (    !m_pCapturePin->IsConnected()
                || (    m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_Streaming
                        && (dwCaptureTime - dwLastCaptureTime + (DWORD)(DeviceAvgTimePerFrame / 10000)
                                               < (DWORD)(m_pCapturePin->m_lMaxAvgTimePerFrame / 10000))
                    )
           )
            fCapture = FALSE;
        else
            fCapture = TRUE;

        // Do we have a use for this frame on the preview pin?
        if (    m_fPreviewCompressedData
                || !m_pPreviewPin->IsConnected()
                || (    m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_Streaming
                        && (dwPreviewTime - dwLastPreviewTime + (DWORD)(DeviceAvgTimePerFrame / 10000)
                                               < (DWORD)(m_pPreviewPin->m_lMaxAvgTimePerFrame / 10000))
                   )
           )
            fPreview = FALSE;
        else
            fPreview = TRUE;

        //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   fPreview = %d fCapture = %d",_fx_, fPreview, fCapture));
        if (!fPreview && !fCapture)
        {
            // We're sending buffers downstream at a much lower rate
            // than we are capturing - return this buffer to the
            // capture device and wait for the next one. This next buffer
            // will still allow us to deliver a frame on time. This
            // way, we avoid waiting in the worker thread too long
            // which would ultimately starve the capture device.
            // @todo Isn't there a better way to return the buffer to the device?
            if (m_cs.paCaptureSamples && (pCSample = (CFrameSample *)m_cs.paCaptureSamples[m_pBufferQueue[m_uiQueueTail]]))
                pCSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);
            if (m_cs.paPreviewSamples && (pPSample = (CFrameSample *)m_cs.paPreviewSamples[m_pBufferQueue[m_uiQueueTail]]))
                pPSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);
            if (m_pRtpPdPin->IsConnected() && m_cs.paRtpPdSamples && (pRSample = (CRtpPdSample *)m_cs.paRtpPdSamples[m_pBufferQueue[m_uiQueueTail]]))
                pRSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);
            if (++m_uiQueueTail >= m_cs.nHeaders)
                m_uiQueueTail = 0;
            if (pPSample)
                pPSample->Release(), pPSample = NULL;
            if (pCSample)
                pCSample->Release(), pCSample = NULL;
            if (pRSample)
                pRSample->Release(), pRSample = NULL;
#if defined(DEBUG) && defined(DEBUG_STREAMING)
            wsprintf(szDebug, "Too soon: DeviceAvgTimePerFrame = %ld\n", DeviceAvgTimePerFrame);
            OutputDebugString(szDebug);
            wsprintf(szDebug, "Too soon: dwCaptureTime - dwLastCaptureTime + (DWORD)(DeviceAvgTimePerFrame / 10000) = (%ld - %ld + (DWORD)(%ld / 10000) = %ld\n", dwCaptureTime, dwLastCaptureTime, DeviceAvgTimePerFrame, dwCaptureTime - dwLastCaptureTime + (DWORD)(DeviceAvgTimePerFrame / 10000));
            OutputDebugString(szDebug);
            wsprintf(szDebug, "Too soon: (DWORD)(m_pCapturePin->m_lMaxAvgTimePerFrame / 10000) = (DWORD)(%ld / 10000) = %ld\n", m_pCapturePin->m_lMaxAvgTimePerFrame, (DWORD)(m_pCapturePin->m_lMaxAvgTimePerFrame / 10000));
            OutputDebugString(szDebug);
            wsprintf(szDebug, "Too soon: dwPreviewTime - dwLastPreviewTime + (DWORD)(DeviceAvgTimePerFrame / 10000) = (%ld - %ld + (DWORD)(%ld / 10000) = %ld\n", dwPreviewTime, dwLastPreviewTime, DeviceAvgTimePerFrame, dwPreviewTime - dwLastPreviewTime + (DWORD)(DeviceAvgTimePerFrame / 10000));
            OutputDebugString(szDebug);
            wsprintf(szDebug, "Too soon: (DWORD)(m_pPreviewPin->m_lMaxAvgTimePerFrame / 10000) = (DWORD)(%ld / 10000) = %ld\n", m_pPreviewPin->m_lMaxAvgTimePerFrame, (DWORD)(m_pPreviewPin->m_lMaxAvgTimePerFrame / 10000));
            OutputDebugString(szDebug);
#endif
            continue;
        }
        else
        {
            // What pin needs it first?
            if (fPreview)
            {
                if (    (dwPreviewTime < (dwLastPreviewTime + (DWORD)m_pPreviewPin->m_lMaxAvgTimePerFrame / 10000UL))
                     && (       (m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_FrameGrabbing)
                             || (dwLastPreviewTime + (DWORD)m_pPreviewPin->m_lMaxAvgTimePerFrame / 10000-dwPreviewTime < DeviceAvgTimePerFrame/10000)
                        )
                   )
                    dwPreviewWaitTime = dwLastPreviewTime + (DWORD)m_pPreviewPin->m_lMaxAvgTimePerFrame / 10000 - dwPreviewTime;
                else
                    dwPreviewWaitTime = 0;
            }
            else
            {
                dwPreviewWaitTime = 0xFFFFFFFF;
            }
            if (fCapture)
            {
                if (    (dwCaptureTime < (dwLastCaptureTime + (DWORD)m_pCapturePin->m_lMaxAvgTimePerFrame / 10000UL))
                     && (       (m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_FrameGrabbing)
                             || (dwLastCaptureTime + (DWORD)m_pCapturePin->m_lMaxAvgTimePerFrame / 10000-dwCaptureTime < DeviceAvgTimePerFrame/10000)
                        )
                   )
                    dwCaptureWaitTime = dwLastCaptureTime + (DWORD)m_pCapturePin->m_lMaxAvgTimePerFrame / 10000 - dwCaptureTime;
                else
                    dwCaptureWaitTime = 0;
            }
            else
            {
                dwCaptureWaitTime = 0xFFFFFFFF;
            }

            // Sleep until it is time to deliver a frame on either pin
            //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   dwPreviewWaitTime 0x%08lx, dwCaptureWaitTime 0x%08lx dwTimex%08lx", _fx_,dwPreviewWaitTime, dwCaptureWaitTime, dwTime));
            dwWaitTime = min(dwPreviewWaitTime, dwCaptureWaitTime);
#if defined(DEBUG) && defined(DEBUG_STREAMING)
            D(8) {
            wsprintf(szDebug, "Waiting %d ms...", dwWaitTime);
            OutputDebugString(szDebug);
            }
#endif
            if ((dwWaitTime > 1) && (timeSetEvent(dwWaitTime, 1, (LPTIMECALLBACK)hEvent, NULL, TIME_ONESHOT | TIME_CALLBACK_EVENT_SET)))
            {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Waiting %d ms...",_fx_, dwWaitTime));
                m_EventAdvise.Wait();
                dwTime = timeGetTime();
            }
#if defined(DEBUG) && defined(DEBUG_STREAMING)
            D(8) OutputDebugString(" done!\n");

            if (m_pBufferQueue[m_uiQueueTail] == m_cs.uiLastAdded)
            {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   WARNING: Capture device is STARVING!", _fx_));
            }
#endif

            if ((m_pCapDev->m_vcdi.nCaptureMode != CaptureMode_Streaming) && (m_state == TS_Run)) {
                HRESULT Hrg;
                if (FAILED(Hrg=m_pCapDev->GrabFrame(&ptvh->vh))) {
                    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   WARNING: GrabFrame returned error 0x%08lx", _fx_,Hrg));
                    break;
                }

#ifdef WRKRTHD_DEBUG
                D(0x8000)
                { int i;
                  D(1) dprintf("Image buffer at %p (len = %d) !!! frame grab !!!\n",(unsigned char*)ptvh->vh.lpData,ptvh->vh.dwBufferLength);
                  D(1) dprintf("W 4CC used = %lX : '%.4s' (bitcount = %d )\n", g_dbg_4cc, &g_dbg_4cc, g_dbg_bc);

                  //D(1) dprintf("YUY2 160 x 120 means %d\n", 160*120*2);
                  //D(1) dprintf("I420 176 x 144 means %d\n", 176*144+(176*144)/2);
                  D(1) hex_dump((unsigned char*)ptvh->vh.lpData,16);
                  D(1) fill4cc(g_dbg_4cc,g_dbg_bc, (unsigned char*)ptvh->vh.lpData, g_dbg_w, g_dbg_h, "\x0e\x64\x40");
                  for(i=0; i<20; i++)
                        set4cc(g_dbg_4cc,g_dbg_bc, (unsigned char*)ptvh->vh.lpData, g_dbg_w, g_dbg_h, "\xa0\x10\xd0",i,i);
                  for(i=0; i<20; i++)
                        set4cc(g_dbg_4cc,g_dbg_bc, (unsigned char*)ptvh->vh.lpData, g_dbg_w, g_dbg_h, "\xa0\x10\xd0",20-i,i);
                  //for(i=0; i<80; i++)
                  //      set4cc(g_dbg_4cc,g_dbg_bc, (unsigned char*)ptvh->vh.lpData, g_dbg_w, g_dbg_h, "\xa0\x10\xd0",10+i,20+i/2);
                  D(2) DebugBreak();
                }
#endif

                DBGONLY if(IsBadReadPtr(ptvh->p32Buff, ptvh->vh.dwBytesUsed)) {
                DBGONLY    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   ERROR: GrabFrame returned garbled buffer: %p (size: %ld)", _fx_,ptvh->p32Buff, ptvh->vh.dwBytesUsed));
                DBGONLY    if(debug_streaming_flag & DEBUG_STREAMING_BRK) DebugBreak();
                DBGONLY    break;
                DBGONLY }
            }

            if (fPreview && dwPreviewWaitTime == dwWaitTime)
            {
                // This is a preview frame
                dwPreviewTime = dwTime;

#if defined(DEBUG) && defined(DEBUG_STREAMING)
                D(8) wsprintf(szDebug, "Delta P: %ld ms\n", dwPreviewTime - dwLastPreviewTime);
#endif
                dwLastPreviewTime = dwPreviewTime;

                // Deliver the sample downstream
                if (pPSample = (CFrameSample *)m_cs.paPreviewSamples[m_pBufferQueue[m_uiQueueTail]])
                {
                    pPSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);
                    // Deliver inside SendFrame failed or returned S_FALSE.  Stop capture.
                    if (FAILED(Hr = m_pPreviewPin->SendFrame(pPSample, (PBYTE)ptvh->p32Buff, ptvh->vh.dwBytesUsed, &dwBytesUsed, &dwBytesExtent, bDiscon)))
                    {
                        // So the next time we enter this function we're ready to continue
                        if (++m_uiQueueTail >= m_cs.nHeaders)
                            m_uiQueueTail = 0;
                        pPSample->Release(), pPSample = NULL;
                        break;
                    }
                }
                bDiscon = FALSE;

#if defined(DEBUG) && defined(DEBUG_STREAMING)
                D(8) OutputDebugString(szDebug);
#endif
                // Compute statistics
                dwNumPreviewFramesDelivered++;
                dwNumPreviewBytesDelivered += dwBytesUsed;
                // dwCaptureTime = timeGetTime();
                if (dwNumPreviewFramesDelivered && ((dwPreviewTime - dwLastRefPreviewTime) > 1000))
                {
                    m_pPreviewPin->m_lCurrentAvgTimePerFrame = (dwPreviewTime - dwLastRefPreviewTime) * 10000 / dwNumPreviewFramesDelivered;
                    m_pPreviewPin->m_lCurrentBitrate = (DWORD)((LONGLONG)dwNumPreviewBytesDelivered * 8000 / ((REFERENCE_TIME)(dwPreviewTime - dwLastRefPreviewTime)));
                    dwNumPreviewFramesDelivered = 0;
                    dwNumPreviewBytesDelivered = 0;
                    dwLastRefPreviewTime = dwPreviewTime;
                }

                // Do I need to send a capture frame too?
                dwCaptureTime = timeGetTime();

                // Do we have a use for this frame on the capture pin?
                if (!m_pCapturePin->IsConnected() || (dwCaptureTime - dwLastCaptureTime + (DWORD)(DeviceAvgTimePerFrame / 10000) < (DWORD)(m_pCapturePin->m_lMaxAvgTimePerFrame / 10000)))
                    fCapture = FALSE;
                else
                    fCapture = TRUE;

                if (fCapture)
                {
                    if ((dwCaptureTime < (dwLastCaptureTime + (DWORD)m_pCapturePin->m_lMaxAvgTimePerFrame / 10000UL)) && (dwLastCaptureTime + (DWORD)m_pCapturePin->m_lMaxAvgTimePerFrame / 10000 - dwCaptureTime < DeviceAvgTimePerFrame / 10000))
                        dwCaptureWaitTime = dwLastCaptureTime + (DWORD)m_pCapturePin->m_lMaxAvgTimePerFrame / 10000 - dwCaptureTime;
                    else
                        dwCaptureWaitTime = 0;

                    // Sleep until it is time to deliver a frame on capture pin
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                    D(8) {
                    wsprintf(szDebug, "Waiting %d ms...", dwCaptureWaitTime);
                    OutputDebugString(szDebug);
                    }
#endif
                    if ((dwCaptureWaitTime > 1) && (timeSetEvent(dwCaptureWaitTime, 1, (LPTIMECALLBACK)hEvent, NULL, TIME_ONESHOT | TIME_CALLBACK_EVENT_SET)))
                    {
                        m_EventAdvise.Wait();
                        dwCaptureTime = timeGetTime();
                    }
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                    D(8) OutputDebugString(" done!\n");

                    D(8) wsprintf(szDebug, "Delta C: %ld ms\n", dwCaptureTime - dwLastCaptureTime);
#endif
                    dwLastCaptureTime = dwCaptureTime;

                    // Deliver the video sample downstream
                    if (pCSample = (CFrameSample *)m_cs.paCaptureSamples[m_pBufferQueue[m_uiQueueTail]])
                        pCSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);
                    // Deliver inside SendFrame failed or returned S_FALSE.  Stop capture.
                    if (FAILED(Hr = m_pCapturePin->SendFrame(pCSample, (PBYTE)ptvh->p32Buff, ptvh->vh.dwBytesUsed, &dwBytesUsed, &dwBytesExtent, bDiscon)))
                    {
                        // So the next time we enter this function we're ready to continue
                        if (++m_uiQueueTail >= m_cs.nHeaders)
                            m_uiQueueTail = 0;
                        if (pCSample)
                            pCSample->Release(), pCSample = NULL;
                        break;
                    }

                    // Deliver the Rtp Pd sample downstream
                    if (Hr == S_OK && m_pRtpPdPin->IsConnected())
                    {
                        if (pRSample = (CRtpPdSample *)m_cs.paRtpPdSamples[m_pBufferQueue[m_uiQueueTail]])
                            pRSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);

                        // Deliver inside SendFrame failed or returned S_FALSE.  Stop capture.
                        if (FAILED(Hr = m_pRtpPdPin->SendFrame(pCSample, pRSample, dwBytesExtent, bDiscon)))
                        {
                            // So the next time we enter this function we're ready to continue
                            if (++m_uiQueueTail >= m_cs.nHeaders)
                                m_uiQueueTail = 0;
                            if (pCSample)
                                pCSample->Release(), pCSample = NULL;
                            if (pRSample)
                                pRSample->Release(), pRSample = NULL;
                            break;
                        }
                    }

                    bDiscon = FALSE;
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                    D(8) OutputDebugString(szDebug);
#endif
                    // Compute statistics
                    dwNumCaptureFramesDelivered++;
                    dwNumCaptureBytesDelivered += dwBytesUsed;
                    // dwCaptureTime = timeGetTime();
                    if (dwNumCaptureFramesDelivered && ((dwCaptureTime - dwLastRefCaptureTime) > 1000))
                    {
                        m_pCapturePin->m_lCurrentAvgTimePerFrame = (dwCaptureTime - dwLastRefCaptureTime) * 10000 / dwNumCaptureFramesDelivered;
                        m_pCapturePin->m_lCurrentBitrate = (DWORD)((LONGLONG)dwNumCaptureBytesDelivered * 8000 / ((REFERENCE_TIME)(dwCaptureTime - dwLastRefCaptureTime)));
                        dwNumCaptureFramesDelivered = 0;
                        dwNumCaptureBytesDelivered = 0;
                        dwLastRefCaptureTime = dwCaptureTime;
                    }

                    // Now we're all done with this sample
                    if (pCSample)
                        pCSample->Release(), pCSample = NULL;
                    if (pRSample)
                        pRSample->Release(), pRSample = NULL;
                }

                // Please don't increment m_uiQueueTail until after the SendFrame
                // and FakePreview
                if (++m_uiQueueTail >= m_cs.nHeaders)
                    m_uiQueueTail = 0;
                //** ASSERT( m_uiQueueTail != m_uiQueueHead );

                // Now we're all done with this sample
                if (pPSample)
                    pPSample->Release(), pPSample = NULL;
            }
            else
            {
                // This is a capture frame
                dwCaptureTime = dwTime;
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                D(8) wsprintf(szDebug, "Delta C: %ld ms\n", dwCaptureTime - dwLastCaptureTime);
#endif
                dwLastCaptureTime = dwCaptureTime;

                // Deliver the video sample downstream
                if (pCSample = (CFrameSample *)m_cs.paCaptureSamples[m_pBufferQueue[m_uiQueueTail]])
                    pCSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);

                if (m_fPreviewCompressedData && m_pPreviewPin->IsConnected())
                {
                    // We'll also deliver a sample on the preview pin
                    if (pPSample = (CFrameSample *)m_cs.paPreviewSamples[m_pBufferQueue[m_uiQueueTail]])
                        pPSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);

                    D(8) if(!(ptvh->vh.dwBytesUsed>0)) dprintf("Before SendFrames: ptvh->vh.dwBytesUsed=%lu\n",ptvh->vh.dwBytesUsed);
                    // Deliver inside SendFrame failed or returned S_FALSE.  Stop capture.
                    if (FAILED(Hr = m_pCapturePin->SendFrames(pCSample, pPSample, (PBYTE)ptvh->p32Buff, ptvh->vh.dwBytesUsed, &dwBytesUsed, &dwBytesExtent, bDiscon)))
                    {
                        // So the next time we enter this function we're ready to continue
                        if (++m_uiQueueTail >= m_cs.nHeaders)
                            m_uiQueueTail = 0;
                        if (pCSample)
                            pCSample->Release(), pCSample = NULL;
                        if (pPSample)
                            pPSample->Release(), pPSample = NULL;
                        break;
                    }
                }
                else
                {
                    // Deliver inside SendFrame failed or returned S_FALSE.  Stop capture.
                    if (FAILED(Hr = m_pCapturePin->SendFrame(pCSample, (PBYTE)ptvh->p32Buff, ptvh->vh.dwBytesUsed, &dwBytesUsed, &dwBytesExtent, bDiscon)))
                    {
                        // So the next time we enter this function we're ready to continue
                        if (++m_uiQueueTail >= m_cs.nHeaders)
                            m_uiQueueTail = 0;
                        if (pCSample)
                            pCSample->Release(), pCSample = NULL;
                        break;
                    }
                }

                // Deliver the Rtp Pd sample downstream, only if the video packet was also sent downstream
                if (Hr == S_OK && m_pRtpPdPin->IsConnected())
                {
                    if (pRSample = (CRtpPdSample *)m_cs.paRtpPdSamples[m_pBufferQueue[m_uiQueueTail]])
                        pRSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);

                    // Deliver inside SendFrame failed or returned S_FALSE.  Stop capture.
                    if (FAILED(Hr = m_pRtpPdPin->SendFrame(pCSample, pRSample, dwBytesExtent, bDiscon)))
                    {
                        // So the next time we enter this function we're ready to continue
                        if (++m_uiQueueTail >= m_cs.nHeaders)
                            m_uiQueueTail = 0;
                        if (pCSample)
                            pCSample->Release(), pCSample = NULL;
                        if (pPSample)
                            pPSample->Release(), pPSample = NULL;
                        if (pRSample)
                            pRSample->Release(), pRSample = NULL;
                        break;
                    }
                }

                bDiscon = FALSE;

#if defined(DEBUG) && defined(DEBUG_STREAMING)
                D(8) OutputDebugString(szDebug);
#endif
                // Compute statistics
                dwNumCaptureFramesDelivered++;
                dwNumCaptureBytesDelivered += dwBytesUsed;
                // dwCaptureTime = timeGetTime();
                if (dwNumCaptureFramesDelivered && ((dwCaptureTime - dwLastRefCaptureTime) > 1000))
                {
                    m_pCapturePin->m_lCurrentAvgTimePerFrame = (dwCaptureTime - dwLastRefCaptureTime) * 10000 / dwNumCaptureFramesDelivered;
                    if (m_fPreviewCompressedData)
                        m_pPreviewPin->m_lCurrentAvgTimePerFrame = m_pCapturePin->m_lCurrentAvgTimePerFrame;
                    m_pCapturePin->m_lCurrentBitrate = (DWORD)((LONGLONG)dwNumCaptureBytesDelivered * 8000 / ((REFERENCE_TIME)(dwCaptureTime - dwLastRefCaptureTime)));
                    dwNumCaptureFramesDelivered = 0;
                    dwNumCaptureBytesDelivered = 0;
                    dwLastRefCaptureTime = dwCaptureTime;
                }

                // Do I need to send a preview frame too?
                dwPreviewTime = timeGetTime();

                // Do we have a use for this frame on the capture pin?
                if (m_fPreviewCompressedData || !m_pPreviewPin->IsConnected() || (dwPreviewTime - dwLastPreviewTime + (DWORD)(DeviceAvgTimePerFrame / 10000) < (DWORD)(m_pPreviewPin->m_lMaxAvgTimePerFrame / 10000)))
                    fPreview = FALSE;
                else
                    fPreview = TRUE;

                if (fPreview)
                {
                    if ((dwPreviewTime < (dwLastPreviewTime + (DWORD)m_pPreviewPin->m_lMaxAvgTimePerFrame / 10000UL)) && (dwLastPreviewTime + (DWORD)m_pPreviewPin->m_lMaxAvgTimePerFrame / 10000 - dwPreviewTime < DeviceAvgTimePerFrame / 10000))
                        dwPreviewWaitTime = dwLastPreviewTime + (DWORD)m_pPreviewPin->m_lMaxAvgTimePerFrame / 10000 - dwPreviewTime;
                    else
                        dwPreviewWaitTime = 0;

                    // Sleep until it is time to deliver a frame on preview pin
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                    D(8) {
                    wsprintf(szDebug, "Waiting %d ms...", dwPreviewWaitTime);
                    OutputDebugString(szDebug);
                    }
#endif
                    if ((dwPreviewWaitTime > 1) && (timeSetEvent(dwPreviewWaitTime, 1, (LPTIMECALLBACK)hEvent, NULL, TIME_ONESHOT | TIME_CALLBACK_EVENT_SET)))
                    {
                        m_EventAdvise.Wait();
                        dwPreviewTime = timeGetTime();
                    }
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                    D(8) OutputDebugString(" done!\n");

                    D(8) wsprintf(szDebug, "Delta P: %ld ms\n", dwPreviewTime - dwLastPreviewTime);
#endif
                    dwLastPreviewTime = dwPreviewTime;

                    // Deliver the sample downstream
                    if (pPSample = (CFrameSample *)m_cs.paPreviewSamples[m_pBufferQueue[m_uiQueueTail]])
                        pPSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);
                    // Deliver inside SendFrame failed or returned S_FALSE.  Stop capture.
                    if (FAILED(Hr = m_pPreviewPin->SendFrame(pPSample, (PBYTE)ptvh->p32Buff, ptvh->vh.dwBytesUsed, &dwBytesUsed, &dwBytesExtent, bDiscon)))
                    {
                        // So the next time we enter this function we're ready to continue
                        if (++m_uiQueueTail >= m_cs.nHeaders)
                            m_uiQueueTail = 0;
                        if (pPSample)
                            pPSample->Release(), pPSample = NULL;
                        break;
                    }

                    bDiscon = FALSE;
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                    D(8) OutputDebugString(szDebug);
#endif
                    // Compute statistics
                    dwNumPreviewFramesDelivered++;
                    dwNumPreviewBytesDelivered += dwBytesUsed;
                    // dwCaptureTime = timeGetTime();
                    if (dwNumPreviewFramesDelivered && ((dwPreviewTime - dwLastRefPreviewTime) > 1000))
                    {
                        m_pPreviewPin->m_lCurrentAvgTimePerFrame = (dwPreviewTime - dwLastRefPreviewTime) * 10000 / dwNumPreviewFramesDelivered;
                        m_pPreviewPin->m_lCurrentBitrate = (DWORD)((LONGLONG)dwNumPreviewBytesDelivered * 8000 / ((REFERENCE_TIME)(dwPreviewTime - dwLastRefPreviewTime)));
                        dwNumPreviewFramesDelivered = 0;
                        dwNumPreviewBytesDelivered = 0;
                        dwLastRefPreviewTime = dwPreviewTime;
                    }

                    // Now we're all done with this sample
                    if (pPSample)
                        pPSample->Release(), pPSample = NULL;
                }

                // Please don't increment m_uiQueueTail until after the SendFrame
                // and FakePreview
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                //ASSERT( m_uiQueueTail != m_uiQueueHead );
                if(m_uiQueueTail != m_uiQueueHead) {
                    wsprintf(szDebug, "m_uiQueueTail -> %d : %d <- m_uiQueueHead", m_uiQueueTail , m_uiQueueHead);
                    OutputDebugString(szDebug);
                }
#endif
                if (++m_uiQueueTail >= m_cs.nHeaders)
                    m_uiQueueTail = 0;

                // Now we're all done with this sample
                if (pCSample)
                    pCSample->Release(), pCSample = NULL;
                if (m_fPreviewCompressedData && pPSample)
                    pPSample->Release(), pPSample = NULL;
                if (pRSample)
                    pRSample->Release(), pRSample = NULL;
            }
        }
    }

    // The main thread will stop the capture because this thread probably hung
    // in Deliver going from run->pause and will never get to this line!
    // (The video renderer will hold samples in Receive in pause mode)
    // videoStreamStop (m_cs.hVideoIn);
    SetThreadPriority (GetCurrentThread(), dwOldPrio);

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
    return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINMETHOD
 *
 *  @mfunc DWORD | CTAPIVCap | Prepare | This method is used to allocate
 *    resources in preparation for capture loop.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIVCap::Prepare()
{
    HRESULT Hr = NOERROR;
    LPBYTE pbyCompressedBuffer, pbyRtpPdBuffer;
    DWORD i, j;
    DWORD cbCaptureBuffer, cbPreviewBuffer;
    DWORD cbPrefix, cbAlign;

    FX_ENTRY("CTAPIVCap::Prepare");


#ifdef XTRA_TRACE
    char strMutexName[80];
    wsprintf(strMutexName, TEXT("%dCTAPIVCap"), _getpid());

    h_mut1 = CreateMutex(NULL,FALSE,strMutexName);

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Enabling Xtra Tracing", _fx_));
    QueryPerformanceFrequency(&g_liFreq);
        MyTraceId=TraceRegisterEx("TRAX",TRACE_USE_FILE);
        if(MyTraceId==0) {
                OutputDebugString("Failed to enable Xtra Tracing ... \n");
                }

#endif


    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    m_cs.paHdr = NULL;
    m_cs.hEvtBufferDone = NULL;
    m_cs.h0EvtBufferDone = 0;
    m_cs.llLastTick = (LONGLONG)-1;
    m_cs.uiLastAdded = (UINT)-1;
    // m_cs.dwFirstFrameOffset = 0;
    m_cs.llFrameCountOffset = 0;
    m_cs.fReRun = FALSE;
    m_cs.rtDriverLatency = -1;
    m_cs.cbVidHdr = sizeof(VIDEOHDR);

    // Can't do anything if no videoformat has been chosen
    if (!m_user.pvi)
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: No video format chosen yet!", _fx_));
        Hr = E_FAIL;
        goto MyError;
    }

    // Set default number of capture buffers. We may adjust this below
    // if a pin wants to ship the video capture buffers downstream
    m_cs.nHeaders = m_user.nMaxBuffers;

    // Set default size. Again, if some pin wants to deliver a video
    // capture buffer downstream, this may be adjusted to match the
    // pin's allocator requirements regarding buffer alignment for instance
    m_cs.cbBuffer = m_user.pvi->bmiHeader.biSizeImage;


    if (m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_Streaming)
    {
        // Create the VfW streaming capture event (**cristi: WDM capture event ?)
        if (!(m_cs.hEvtBufferDone = CreateEvent (NULL, FALSE, FALSE, NULL)))
        {
            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed to create buffer done event!", _fx_));
            Hr = E_OUTOFMEMORY;
            goto MyError;
        }

        if (m_pCapDev->m_vcdi.nDeviceType == DeviceType_VfW)
        {
            if (!g_IsNT)
            {
                // Map this event
                if (!(m_cs.h0EvtBufferDone = OpenVxDHandle(m_cs.hEvtBufferDone)))
                {
                    DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed to create event's Ring 0 handle!", _fx_));
                    Hr = E_FAIL;
                    goto MyError;
                }
            }
            else
            {
                m_cs.h0EvtBufferDone = (DWORD_PTR)m_cs.hEvtBufferDone;
            }
        }
    }

    cbPrefix = cbAlign = 0;
    m_cs.cCaptureSamples = m_cs.cPreviewSamples = 0;

    if (m_pCapturePin->IsConnected())
    {
        //dprintf("m_user.pvi->bmiHeader.biSizeImage = %x <= %x (DWORD)m_pCapturePin->m_parms.cbBuffer\n",m_user.pvi->bmiHeader.biSizeImage,m_pCapturePin->m_parms.cbBuffer);
        if (m_cs.fCaptureNeedConverter =   HEADER(m_user.pvi)->biCompression != HEADER(m_pCapturePin->m_mt.pbFormat)->biCompression
                                        || HEADER(m_user.pvi)->biWidth       != HEADER(m_pCapturePin->m_mt.pbFormat)->biWidth
                                        || HEADER(m_user.pvi)->biHeight      != HEADER(m_pCapturePin->m_mt.pbFormat)->biHeight)
        {
            // For each compressed buffer, allocate the user requested size
            // Also, align allocation size up to nearest align boundary
            cbCaptureBuffer = m_pCapturePin->m_parms.cbPrefix + m_pCapturePin->m_parms.cbAlign + m_pCapturePin->m_parms.cbBuffer;
            ASSERT(HEADER(m_pCapturePin->m_mt.pbFormat)->biSizeImage <= (DWORD)m_pCapturePin->m_parms.cbBuffer);
            m_cs.cCaptureSamples = m_pCapturePin->m_parms.cBuffers;
        }
        else
        {
            // This pin will ship the video capture buffers downstream.
            // For each buffer, allocate the user requested size
            // Also, align allocation size up to nearest align boundary
            cbPrefix = m_pCapturePin->m_parms.cbPrefix;
            cbAlign = m_pCapturePin->m_parms.cbAlign;
            m_cs.cbBuffer = cbCaptureBuffer = max(m_cs.cbBuffer, cbPrefix + cbAlign + m_pCapturePin->m_parms.cbBuffer);
            ASSERT(m_user.pvi->bmiHeader.biSizeImage <= (DWORD)m_pCapturePin->m_parms.cbBuffer);

            // Try to get the requested number of buffers, but make sure
            // to get at least MIN_VIDEO_BUFFERS and no more than MAX_VIDEO_BUFFERS
            m_cs.nHeaders = max((DWORD)m_pCapturePin->m_parms.cBuffers, m_user.nMinBuffers);
            m_cs.nHeaders = min(m_cs.nHeaders, m_user.nMaxBuffers);
            m_cs.cCaptureSamples = m_cs.nHeaders;
        }
    }

    if (m_pPreviewPin->IsConnected())
    {
        //dprintf("m_user.pvi->bmiHeader.biSizeImage = %x <= %x (DWORD)m_pPreviewPin->m_parms.cbBuffer\n",m_user.pvi->bmiHeader.biSizeImage,m_pPreviewPin->m_parms.cbBuffer);
        m_cs.fPreviewNeedConverter = FALSE;

        if (m_fPreviewCompressedData ||
                (m_cs.fPreviewNeedConverter =   (HEADER(m_user.pvi)->biCompression != HEADER(m_pPreviewPin->m_mt.pbFormat)->biCompression
                                              || HEADER(m_user.pvi)->biBitCount    != HEADER(m_pPreviewPin->m_mt.pbFormat)->biBitCount
                                              || HEADER(m_user.pvi)->biWidth       != HEADER(m_pPreviewPin->m_mt.pbFormat)->biWidth
                                              || HEADER(m_user.pvi)->biHeight      != HEADER(m_pPreviewPin->m_mt.pbFormat)->biHeight)
                ))
        {
            // Hey! You can only preview compressed data if you have connected the capture pin...
            ASSERT(!m_fPreviewCompressedData || (m_fPreviewCompressedData && m_pCapturePin->IsConnected()));

            // For each compressed buffer, allocate the user requested size
            // Also, align allocation size up to nearest align boundary
            cbPreviewBuffer = m_pPreviewPin->m_parms.cbPrefix + m_pPreviewPin->m_parms.cbAlign + m_pPreviewPin->m_parms.cbBuffer;
            ASSERT(HEADER(m_pPreviewPin->m_mt.pbFormat)->biSizeImage <= (DWORD)m_pPreviewPin->m_parms.cbBuffer);
            m_cs.cPreviewSamples = m_pPreviewPin->m_parms.cBuffers;
        }
        else
        {
            // This pin will ship the video capture buffers downstream.
            // For each buffer, allocate the user requested size
            // Also, align allocation size up to nearest align boundary
            cbPrefix = max(cbPrefix, (DWORD)m_pPreviewPin->m_parms.cbPrefix);
            cbAlign = max(cbAlign, (DWORD)m_pPreviewPin->m_parms.cbAlign);
            m_cs.cbBuffer = max(m_cs.cbBuffer, (DWORD)(cbPrefix + cbAlign + m_pPreviewPin->m_parms.cbBuffer));
            ASSERT(m_user.pvi->bmiHeader.biSizeImage <= (DWORD)m_pPreviewPin->m_parms.cbBuffer);

            // Try to get the requested number of buffers, but make sure
            // to get at least MIN_VIDEO_BUFFERS and no more than MAX_VIDEO_BUFFERS
            m_cs.nHeaders = max((DWORD)m_pPreviewPin->m_parms.cBuffers, m_user.nMinBuffers);
            m_cs.nHeaders = min(m_cs.nHeaders, m_user.nMaxBuffers);
            m_cs.cPreviewSamples = m_cs.nHeaders;
        }
    }

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   We are trying to get %d compressed/capture buffers", _fx_, m_cs.nHeaders));

    // Allocate headers for all of the buffers that we will be using


    //if (FAILED(m_pCapDev->AllocateHeaders(m_cs.nHeaders, sizeof(THKVIDEOHDR) + sizeof(DWORD), (LPVOID *)&m_cs.paHdr)))
    if (FAILED(m_pCapDev->AllocateHeaders(m_cs.nHeaders, sizeof(struct CTAPIVCap::_cap_parms::_cap_hdr), (LPVOID *)&m_cs.paHdr)))
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: vidxAllocHeaders failed!", _fx_));
        Hr = E_OUTOFMEMORY;
        goto MyError;
    }

    // Allocate each buffer, if buffer allocation ever fails
    // just set the number of buffers to the number of successes
    // and continue on.
    for (i = 0; i < m_cs.nHeaders; ++i)
    {
        LPTHKVIDEOHDR ptvh;

        if (m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_FrameGrabbing)
        {
            ptvh = &m_cs.paHdr[i].tvh;
        }

        if (FAILED(m_pCapDev->AllocateBuffer((LPTHKVIDEOHDR *)&ptvh, i, m_cs.cbBuffer)))
            break; //it was goto MyExit; (cristiai; see bug 186119)

        ASSERT (ptvh == &m_cs.paHdr[i].tvh);

        dprintf("Align buffer %d; before %p\n",i,ptvh->vh.lpData);
        // Fix the memory we got to obey alignment
        ptvh->vh.lpData = cbAlign ? (LPBYTE)ALIGNUP(ptvh->p32Buff, cbAlign) + cbPrefix : (LPBYTE)ptvh->p32Buff + cbPrefix;
        dprintf("                after  %p\n",ptvh->vh.lpData);
        dprintf("                length: ptvh->vh.dwBufferLength %d ( m_cs.cbBuffer = %d ) \n",ptvh->vh.dwBufferLength,m_cs.cbBuffer);
        // We added cbAlign up top, so take it back now
        ptvh->vh.dwBufferLength = m_cs.cbBuffer - cbAlign - cbPrefix;
        dprintf("                length: [adjusted]              %d\n",ptvh->vh.dwBufferLength);
        ptvh->vh.dwBytesUsed = ptvh->vh.dwTimeCaptured = 0;
        // Which buffer is this?
        ptvh->dwIndex = i;

        ASSERT (!IsBadWritePtr(ptvh->vh.lpData, ptvh->vh.dwBufferLength));

        dout(3,g_dwVideoCaptureTraceID, TRCE, "%s:   Alloc'd: ptvh %08lX, buffer %08lX, size %d, p32 %08lX, p16 %08lX", _fx_, ptvh, ptvh->vh.lpData, ptvh->vh.dwBufferLength, ptvh->p32Buff, ptvh->p16Alloc);
    }


    // Now allocate the capture pin media samples
    if (m_cs.cCaptureSamples)
    {
        if (!(m_cs.paCaptureSamples = (CFrameSample **) new BYTE[sizeof(CFrameSample *) * m_cs.cCaptureSamples]))
        {
            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Allocation failed!", _fx_));
            Hr = E_OUTOFMEMORY;
            goto MyError;
        }
        ZeroMemory(m_cs.paCaptureSamples, sizeof(CFrameSample *) * m_cs.cCaptureSamples);
        //dprintf("m_cs.cCaptureSamples = %d in m_cs.paCaptureSamples @ %p\n",m_cs.cCaptureSamples, m_cs.paCaptureSamples);
        //dprintf("m_cs.fCaptureNeedConverter = %d\n",m_cs.fCaptureNeedConverter);
        for (j = 0; j < m_cs.cCaptureSamples; j++)
        {
            if (m_pCapturePin->IsConnected())
            {
                if (m_cs.fCaptureNeedConverter)
                {
                    // Allocate compressed header
                    // @todo Do some real error handling here
                    if (!(pbyCompressedBuffer = new BYTE[cbCaptureBuffer]))
                        break;
                    dprintf("Capture sample %-4d :                             @ %p\n",j,pbyCompressedBuffer);

                    // Fix the memory we got to obey alignment
                    if (m_pCapturePin->m_parms.cbAlign) {
                        pbyCompressedBuffer = (LPBYTE) ALIGNUP(pbyCompressedBuffer, m_pCapturePin->m_parms.cbAlign) + m_pCapturePin->m_parms.cbPrefix;
                        dprintf("ALIGNUP: m_pCapturePin->m_parms.cbAlign = %4x .... %p\n",m_pCapturePin->m_parms.cbAlign,pbyCompressedBuffer);
                    }

                    // We added cbAlign up top, so take it back now
                    // @todo Before you can do the following you need to decouple the samples
                    // from the capture buffers. This means using two different queues: one for
                    // the capture samples, and one for the capture buffers. This will also allow
                    // for a much smaller number of samples than capture buffers.
                    m_cs.paCaptureSamples[j] = (CFrameSample *)new CFrameSample(static_cast<IMemAllocator*>(m_pCapturePin),
                        &Hr, &m_cs.paHdr[j].tvh, pbyCompressedBuffer,cbCaptureBuffer - m_pCapturePin->m_parms.cbAlign - m_pCapturePin->m_parms.cbPrefix);
                    //dprintf("m_cs.paCaptureSamples[%d] @ %p (len = %d , m_pCapturePin->m_parms. : cbAlign = %x, cbPrefix = %x)\n",j,m_cs.paCaptureSamples[j],cbCaptureBuffer - m_pCapturePin->m_parms.cbAlign - m_pCapturePin->m_parms.cbPrefix,m_pCapturePin->m_parms.cbAlign , m_pCapturePin->m_parms.cbPrefix);
                }
                else
                {
                    m_cs.paCaptureSamples[j] = new CFrameSample(static_cast<IMemAllocator*>(m_pCapturePin),
                        &Hr, &m_cs.paHdr[j].tvh, m_cs.paHdr[j].tvh.vh.lpData,m_cs.paHdr[j].tvh.vh.dwBufferLength);
                }
            }
        }
    }

    // Now allocate the Rtp Pd pin media samples
    if (m_pCapturePin->IsConnected() && m_pRtpPdPin->IsConnected() && m_cs.cCaptureSamples && m_pRtpPdPin->m_parms.cBuffers)
    {
        m_cs.cRtpPdSamples = m_pRtpPdPin->m_parms.cBuffers;
        if (!(m_cs.paRtpPdSamples = (CRtpPdSample **) new BYTE[sizeof(CRtpPdSample *) * m_cs.cRtpPdSamples]))
        {
            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Allocation failed!", _fx_));
            Hr = E_OUTOFMEMORY;
            goto MyError;
        }
        ZeroMemory(m_cs.paRtpPdSamples, sizeof(CRtpPdSample *) * m_cs.cRtpPdSamples);
        //dprintf("m_cs.cRtpPdSamples = %d in m_cs.paRtpPdSamples @ %p\n",m_cs.cRtpPdSamples, m_cs.paRtpPdSamples);
        for (j = 0; j < m_cs.cRtpPdSamples; j++)
        {
            if (m_pRtpPdPin->IsConnected())
            {
                // Allocate Rtp Pd buffer
                // @todo Do some real error handling here
                if (!(pbyRtpPdBuffer = new BYTE[m_pRtpPdPin->m_parms.cbPrefix + m_pRtpPdPin->m_parms.cbAlign + m_pRtpPdPin->m_parms.cbBuffer]))
                    break;

                // Fix the memory we got to obey alignment
                if (m_pRtpPdPin->m_parms.cbAlign)
                    pbyRtpPdBuffer = (LPBYTE) ALIGNUP(pbyRtpPdBuffer, m_pRtpPdPin->m_parms.cbAlign) + m_pRtpPdPin->m_parms.cbPrefix;

                // We added cbAlign up top, so take it back now
                // @todo Before you can do the following you need to decouple the samples
                // from the capture buffers. This means using two different queues: one for
                // the capture samples, and one for the capture buffers. This will also allow
                // for a much smaller number of samples than capture buffers.
                m_cs.paRtpPdSamples[j] = (CRtpPdSample *)new CRtpPdSample(static_cast<IMemAllocator*>(m_pRtpPdPin),
                        &Hr, &m_cs.paHdr[j].tvh, pbyRtpPdBuffer, m_pRtpPdPin->m_parms.cbBuffer);
            }
        }
    }

    // Now allocate the preview pin media samples
    if (m_cs.cPreviewSamples)
    {
        if (!(m_cs.paPreviewSamples = (CFrameSample **) new BYTE[sizeof(CFrameSample *) * m_cs.cPreviewSamples]))
        {
            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Allocation failed!", _fx_));
            Hr = E_OUTOFMEMORY;
            goto MyError;
        }
        ZeroMemory(m_cs.paPreviewSamples, sizeof(CFrameSample *) * m_cs.cPreviewSamples);
        //dprintf("m_cs.cPreviewSamples = %d in m_cs.paPreviewSamples @ %p\n",m_cs.cPreviewSamples, m_cs.paPreviewSamples);
        //dprintf("m_fPreviewCompressedData || m_cs.fPreviewNeedConverter = %d\n",m_fPreviewCompressedData || m_cs.fPreviewNeedConverter);
        for (j = 0; j < m_cs.cPreviewSamples; j++)
        {
            if (m_pPreviewPin->IsConnected())
            {
                if (m_fPreviewCompressedData || m_cs.fPreviewNeedConverter)
                {
                    // Allocate compressed header
                    // @todo Do some real error handling here
                    if (!(pbyCompressedBuffer = new BYTE[cbPreviewBuffer]))
                        break;
                    dprintf("Preview sample %-4d :                             @ %p\n",j,pbyCompressedBuffer);

                    // Fix the memory we got to obey alignment
                    if (m_pPreviewPin->m_parms.cbAlign) {
                        pbyCompressedBuffer = (LPBYTE) ALIGNUP(pbyCompressedBuffer, m_pPreviewPin->m_parms.cbAlign) + m_pPreviewPin->m_parms.cbPrefix;
                        dprintf("ALIGNUP: m_pPreviewPin->m_parms.cbAlign = %4x .... %p\n",m_pPreviewPin->m_parms.cbAlign,pbyCompressedBuffer);
                    }

                    // We added cbAlign up top, so take it back now
                    // @todo Before you can do the following you need to decouple the samples
                    // from the capture buffers. This means using two different queues: one for
                    // the preview samples, and one for the capture buffers. This will also allow
                    // for a much smaller number of samples than capture buffers.
                    m_cs.paPreviewSamples[j] = new CFrameSample(static_cast<IMemAllocator*>(m_pPreviewPin),
                        &Hr, &m_cs.paHdr[j].tvh, pbyCompressedBuffer, cbPreviewBuffer - m_pPreviewPin->m_parms.cbAlign - m_pPreviewPin->m_parms.cbPrefix);
                    //dprintf("m_cs.paPreviewSamples[%d] @ %p (len = %d , m_pPreviewPin->m_parms. : cbAlign = %x, cbPrefix = %x)\n",j,m_cs.paPreviewSamples[j],cbPreviewBuffer - m_pPreviewPin->m_parms.cbAlign - m_pPreviewPin->m_parms.cbPrefix,m_pPreviewPin->m_parms.cbAlign , m_pPreviewPin->m_parms.cbPrefix);
                }
                else
                {
                    m_cs.paPreviewSamples[j] = new CFrameSample(static_cast<IMemAllocator*>(m_pPreviewPin),
                        &Hr, &m_cs.paHdr[j].tvh, m_cs.paHdr[j].tvh.vh.lpData, m_cs.paHdr[j].tvh.vh.dwBufferLength);
                }
            }
        }
    }

    D(0x10) DebugBreak();

    // Update total number of buffers succesfully allocated
    m_cs.nHeaders = i;

    // This is where we will remember in what order we gave the buffers to the driver
    m_pBufferQueue = (UINT *)QzTaskMemAlloc(i * sizeof(UINT));

    if (m_cs.nHeaders < m_user.nMinBuffers)
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: We only allocated %d buffer(s) which is less than MIN_VIDEO_BUFFERS", _fx_, m_cs.nHeaders));
        Hr = E_FAIL;
        goto MyError;
    }

    // Calculate the requested microsec per frame
    // RefTime is in 100ns units, so we divide by
    // 10 to get microsec/frame. (the +5 is to handle rounding)
    {
        m_user.usPerFrame = (DWORD) ((TickToRefTime(1) + 5) / 10);
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Using m_dwDeviceIndex %d", _fx_, m_dwDeviceIndex));
        if (m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_Streaming)
        {
            // Open the driver for streaming access
            DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Initializing driver at %d usPerFrame", _fx_, m_user.usPerFrame));

            HRESULT hres;
            hres=m_pCapDev->InitializeStreaming(m_user.usPerFrame,
                        m_pCapDev->m_vcdi.nDeviceType == DeviceType_VfW ? m_cs.h0EvtBufferDone : (DWORD_PTR)m_cs.hEvtBufferDone);
            if (FAILED(hres))
            {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: videoStreamInit failed", _fx_));
                Hr = E_FAIL;
                goto MyError;
            }
        }
    }

    if (m_pCapDev->m_vcdi.nDeviceType == DeviceType_VfW && m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_Streaming)
    {
        // Send the buffers to the driver
        for (i = 0; i < m_cs.nHeaders; ++i)
        {
            ASSERT (m_cs.cbVidHdr >= sizeof(VIDEOHDR));

            // vidxAddBuffer can fail if there is not enough memory to
            // prepare (lock down) the buffer. This is ok, we will just
            // make due with the buffers that we have
            if (FAILED(m_pCapDev->AddBuffer(&m_cs.paHdr[i].tvh.vh, m_cs.cbVidHdr)))
            {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: vidxAddBuffer failed", _fx_));
                Hr = E_FAIL;
                goto MyError;
            }
        }
    }

    // To start with, we gave the buffers to the driver in numerical order.
    // From now on, we will use this list to know what buffer to wait for
    // next, and when we send another buffer to the driver.  We can't assume
    // they'll always be in the same order.  What if a downstream filter
    // decides to hold on to a sample longer than the next one we send it?
    UINT kk;
    for (kk = 0; kk < m_cs.nHeaders; kk++)
        m_pBufferQueue[kk] = kk;
    m_uiQueueHead = 0;
    m_uiQueueTail = 0;

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   We are capturing with %d buffers", _fx_, m_cs.nHeaders));

    if (m_pCapturePin->IsConnected() && m_cs.fCaptureNeedConverter && FAILED(Hr = m_pCapturePin->OpenConverter(HEADER(m_user.pvi), HEADER(m_pCapturePin->m_mt.pbFormat))))
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't open convertor!", _fx_));
    }
    else if (m_pPreviewPin->IsConnected() && m_cs.fPreviewNeedConverter && FAILED(Hr = m_pPreviewPin->OpenConverter(HEADER(m_user.pvi), HEADER(m_pPreviewPin->m_mt.pbFormat))))
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't open convertor!", _fx_));
    }

    // if we have 0 buffers to capture into DO NOT BAIL... bad things seem to
    // happen if you fail a Pause transition, and we start hanging later
    goto MyExit;

MyError:
    Unprepare();
MyExit:
    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
    return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINMETHOD
 *
 *  @mfunc DWORD | CTAPIVCap | Unprepare | This method is used to
 *    free resources used by the capture loop.
 *
 *  @rdesc This method returns NOERROR
 ***************************************************************************/
HRESULT CTAPIVCap::Unprepare()
{
    CFrameSample *pSample;
    CRtpPdSample *pRSample;
    LPBYTE lp;
    DWORD i,j;

        INIT_TICKS;

    FX_ENTRY("CTAPIVCap::Unprepare")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    ASSERT(m_pCapturePin);
    ASSERT(m_pPreviewPin);
    ASSERT(m_pRtpPdPin);
    ASSERT(m_pCapDev);

    // Free all of the capture samples
    if (m_cs.cCaptureSamples && m_cs.paCaptureSamples)
    {
        for (j = 0; j < m_cs.cCaptureSamples; j++)
        {
            if (pSample = (CFrameSample *)m_cs.paCaptureSamples[j])
            {
                // Free the conversion buffers if necessary
                if (m_cs.fCaptureNeedConverter)
                {
                    lp = NULL;
                    if (SUCCEEDED(pSample->GetPointer(&lp)))
                    {
                        dprintf("%s : GetPointer on m_cs.paCaptureSamples[%d] : %p\n",_fx_,j,lp);
                        if (lp)
                            delete[] lp;
                    }
                }
                LOG_MSG_VAL("delCsamples:cRef,pSample,this",pSample->m_cRef,(DWORD)pSample,(DWORD)this);
                ASSERT(pSample->m_cRef==0 || pSample->m_cRef==1);
                delete pSample, m_cs.paCaptureSamples[j] = NULL;
            }
        }

        delete[] m_cs.paCaptureSamples, m_cs.paCaptureSamples = NULL;
    }

    // Free all of the Rtp Pd samples
    if (m_cs.cRtpPdSamples && m_cs.paRtpPdSamples)
    {
        for (j = 0; j < m_cs.cRtpPdSamples; j++)
        {
            if (pRSample = (CRtpPdSample *)m_cs.paRtpPdSamples[j])
            {
                lp = NULL;
                if (SUCCEEDED(pRSample->GetPointer(&lp)))
                {
                    if (lp)
                        delete[] lp;
                }
                LOG_MSG_VAL("delRsamples:cRef,pRSample,this",pRSample->m_cRef,(DWORD)pRSample,(DWORD)this);
                ASSERT(pRSample->m_cRef==0 || pRSample->m_cRef==1);
                delete pRSample, m_cs.paRtpPdSamples[j] = NULL;
            }
        }

        delete[] m_cs.paRtpPdSamples, m_cs.paRtpPdSamples = NULL;
    }

    // Free all of the preview samples
    if (m_cs.cPreviewSamples && m_cs.paPreviewSamples)
    {
        for (j = 0; j < m_cs.cPreviewSamples; j++)
        {
            if (pSample = (CFrameSample *)m_cs.paPreviewSamples[j])
            {
                // Free the conversion buffers if necessary
                if (m_fPreviewCompressedData || m_cs.fPreviewNeedConverter)
                {
                    lp = NULL;
                    if (SUCCEEDED(pSample->GetPointer(&lp)))
                    {
                        dprintf("%s : GetPointer on m_cs.paPreviewSamples[%d] : %p\n",_fx_,j,lp);
                        if (lp)
                            delete[] lp;
                    }
                }
                LOG_MSG_VAL("delPsamples:cRef,pSample,this",pSample->m_cRef,(DWORD)pSample,(DWORD)this);
                ASSERT(pSample->m_cRef==0 || pSample->m_cRef==1);
                delete pSample, m_cs.paPreviewSamples[j] = NULL;
            }
        }

        delete[] m_cs.paPreviewSamples, m_cs.paPreviewSamples = NULL;
    }

        HEAPCHK("before Term.Str.");
        BEGIN_TICK;

    if (m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_Streaming)
    {
        if(FAILED(m_pCapDev->TerminateStreaming()))
                {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: TerminateStreaming failed", _fx_));
                }
    }
        HEAPCHK("after Term.Str.");
        MARK_LOG_TICK("after TerminateStr");


    if(m_cs.paHdr!=NULL) {
        // Free all of the capture buffers
        for (j = 0; j < m_cs.nHeaders; j++)
        {
            #ifdef XTRA_TRACE
            if(m_pCapDev->m_vcdi.nDeviceType == DeviceType_WDM)
                    FillPattern((char*)m_cs.paHdr[j].tvh.vh.lpData,m_cs.paHdr[j].tvh.vh.dwBufferLength,0,"Free%3d:%08x (%x)",j,m_cs.paHdr[j].tvh.vh.lpData,m_cs.paHdr[j].tvh.vh.dwBufferLength);
            #endif //XTRA_TRACE
            m_pCapDev->FreeBuffer(&m_cs.paHdr[j].tvh); // previously was .tvh.vh
        }

            HEAPCHK("after freeBufs");
            MARK_LOG_TICK("after freeBufs");
        if (m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_Streaming)
        {
            //m_pCapDev->TerminateStreaming();
            if (m_pCapDev->m_vcdi.nDeviceType == DeviceType_WDM)
                delete[] m_cs.paHdr;
        }
        else
        {
            delete[] m_cs.paHdr;
        }
        m_cs.paHdr = NULL;
    }

        HEAPCHK("after delete paHdr");
        MARK_LOG_TICK("after delete paHdr");
    if (m_pBufferQueue)
        QzTaskMemFree(m_pBufferQueue), m_pBufferQueue = NULL;

    if (m_cs.hEvtBufferDone)
        CloseHandle (m_cs.hEvtBufferDone), m_cs.hEvtBufferDone = NULL;

    if (m_pCapturePin->IsConnected())
    {
        if (m_cs.fCaptureNeedConverter)
            m_pCapturePin->CloseConverter();
#ifdef USE_SOFTWARE_CAMERA_CONTROL
        if (m_pCapturePin->IsSoftCamCtrlOpen())
            m_pCapturePin->CloseSoftCamCtrl();
#endif
    }

    if (m_pPreviewPin->IsConnected())
    {
        if (m_cs.fPreviewNeedConverter)
            m_pPreviewPin->CloseConverter();
#ifdef USE_SOFTWARE_CAMERA_CONTROL
        if (m_pPreviewPin->IsSoftCamCtrlOpen())
            m_pPreviewPin->CloseSoftCamCtrl();
#endif
    }

        END_LOG_TICK("end of Unprepare");
#ifdef XTRA_TRACE
        TraceDeregister(MyTraceId);
        if(h_mut1 != INVALID_HANDLE_VALUE) {
                if(!CloseHandle(h_mut1)) {
                        OutputDebugString("Failed to close mutex handle ... \n");
                        }
                h_mut1 = INVALID_HANDLE_VALUE;
        }
#endif
    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
    return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | ReleaseFrame | This method is used to
 *    return a buffer to the capture driver.
 *
 *  @parm LPTHKVIDEOHDR | ptvh | ???.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag S_FALSE | If the pin is off (IAMStreamControl)
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIVCap::ReleaseFrame(LPTHKVIDEOHDR ptvh)
{
    HRESULT Hr = S_OK;
    LONG l;
#if defined(DEBUG) && defined(DEBUG_STREAMING)
    char szDebug[512];
#endif

    FX_ENTRY("CTAPIVCap::ReleaseFrame")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Giving buffer (%d) back to the driver (lLock=%ld)", _fx_, ptvh->dwIndex,m_cs.paHdr[m_pBufferQueue[ptvh->dwIndex]].lLock));

    if (!(l=InterlockedDecrement(&m_cs.paHdr[m_pBufferQueue[ptvh->dwIndex]].lLock)))
    {
        #if defined(DEBUG) && defined(DEBUG_STREAMING)
        D(8) dprintf("Giving buffer (%d) back to the driver... [After ILockDecr. lLock = %ld]...", ptvh->dwIndex,l);
        #endif

        ptvh->vh.dwFlags &= ~VHDR_DONE;
        //ASSERT(ptvh->vh.dwBufferLength>0);
        //memset((unsigned char*)ptvh->vh.lpData,0,ptvh->vh.dwBufferLength);
        if (m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_Streaming && m_pCapDev->AddBuffer(&ptvh->vh, m_cs.cbVidHdr))
        {
            #if defined(DEBUG) && defined(DEBUG_STREAMING)
            D(8) dout(3, g_dwVideoCaptureTraceID, TRCE, "failed!\n");
            #endif
            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: vidxAddBuffer failed!", _fx_));
            Hr = E_FAIL;
            goto MyExit;
        }
        else
        {
            #if defined(DEBUG) && defined(DEBUG_STREAMING)
            D(8) dout(3, g_dwVideoCaptureTraceID, TRCE, "succeeded!\n");
            #endif
            TEST_LBUG long l=InterlockedCompareExchange(&m_cs.paHdr[m_pBufferQueue[ptvh->dwIndex]].nUsedDownstream,0,1);
            TEST_LBUG #if defined(DEBUG) && defined(DEBUG_STREAMING)
            TEST_LBUG D(8) dprintf("Initial nUsedDownstream was %ld\n", l);
            TEST_LBUG #endif
            m_pBufferQueue[m_uiQueueHead] = ptvh->dwIndex;
            if (++m_uiQueueHead >= m_cs.nHeaders)
                m_uiQueueHead = 0;
        }

        //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   X. m_pBufferQueue[%d] .. m_pBufferQueue[%d] = %d .. %d",_fx_, m_uiQueueTail, m_uiQueueHead, m_pBufferQueue[m_uiQueueTail], m_pBufferQueue[m_uiQueueHead]));

        if (++m_cs.uiLastAdded >= m_cs.nHeaders)
            m_cs.uiLastAdded = 0;

        if (m_cs.uiLastAdded != ptvh->dwIndex)
        {
            DWORD dw = m_cs.uiLastAdded;
            m_cs.uiLastAdded = ptvh->dwIndex;
            // Use dw to keep the above code fairly atomic... debug printf will get prempted
            DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Out of order AddBuffer - %d not %d", _fx_, ptvh->dwIndex, dw));
        }
    }
#if defined(DEBUG) && defined(DEBUG_STREAMING)
    else
    {
        D(8) dprintf("Not Giving buffer (%d) back to the driver yet... [lLock = %ld]\n", ptvh->dwIndex,l);
    }
#endif

MyExit:
    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
    return Hr;
}


#undef _WIN32_WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivcap\i386\procid.asm ===
;*  Procdi.asm - Processor Identification routines
;*
;*      (C) Copyright Microsoft Corp., 1995
;*
;*      Processor ID
;*
;*  Origin:
;*
;*  Change history:
;*
;*  Date       Who        Description
;*  ---------  ---------  -------------------------------------------------
;*  12-Oct-95  MikeG      Created
;*

.386p
.387

.model  flat


;************************** Include Files ************************

;    include winbase.inc
;    include winerror.inc
;    include kernel32.inc
;    include segs.inc
;    include regstr.inc
;******************** Data Declerations **************************

.data
_DATA SEGMENT
CPU_ID  macro
        db      0fh, 0a2h
        endm

NONE            equ     0
PRESENT         equ     1
Nx586           equ     5
UNKNOWN         equ     0


_nxcpu          db      NONE                    ;default to none
_cputype        db      UNKNOWN                 ;default to unknown
_cpuid_flag     db      NONE                    ;default to no CPUID
_vendor_id      db      "************"
_cpu_signature  dd      0
_features_ecx   dd      0
_features_edx   dd      0
_features_ebx   dd      0
NexGen_id       db      "NexGenDriven"



;*********************** Prototypes ******************************


;************************** Code *********************************

.code

_TEXT	SEGMENT
;==========================================================================
; _get_nxcpu_type
;       This routine identifies NexGen's processor type in following steps:
;
;       if (no AC flag) {       //current Nx586 does not support AC flag
;               set ZF=1;
;               execute DIV to result a none zero value;
;               if (ZF=0) {     //ZF is changed
;                       not a NexGen processor;
;                       exit;
;               } else {        //Nx586 does not change ZF on DIV instruction
;                       if (ID bit not writeable) {
;                               CPU is Nx586 with no CPUID support
;                       } else {                //Nx586 with CPUID support
;                               execute CPUID instruction;
;                               save CPU information;
;                       }
;               }
;       } else {
;               if (ID bit not writeable) {
;                       not a NexGen processor;
;               } else {        //NexGen future processors support CPUID
;                       execute CPUID instruction;
;                       save CPU information;
;               }
;       }
;
;==========================================================================
get_nxcpu_type proc  C cdecl:DWORD
        push    ebx
        push    esi
        push    edi
        mov     byte ptr _nxcpu,PRESENT ; default to present

; test AC bit on EFLAGS register
        mov     bx,sp           ; save the current stack pointer
        and     sp,not 3        ; align the stack to avoid AC fault
        pushfd                  ;
        pop     eax             ; get the original EFLAGS
        mov     ecx,eax         ; save original flag
        xor     eax,40000h      ; flip AC bit in EFLAGS
        push    eax             ; save for EFLAGS
        popfd                   ; copy it to EFLAGS
        pushfd                  ;
        pop     eax             ; get the new EFLAGS value
        mov     sp,bx           ; restore stack pointer
        xor     eax,ecx         ; if the AC bit is unchanged
        je      test_zf         ;       goto second step
        jmp     nx_future_cpu

test_zf:
; test ZF on DIV instruction
        mov     ax,5555h        ; init AX with a non-zero value
        xor     dx,dx           ; set ZF=1
        mov     cx,2
        div     cx              ; Nx586 processor does not modify ZF on DIV
        jnz     not_nx_cpu      ; not a NexGen processor if ZF=0 (modified)

test_cpuid:
; test if CPUID instruction is available
; new Nx586 or future CPU supports CPUID instruction
        pushfd                  ; get EFLAGs
        pop     eax
        mov     ecx,eax         ; save it
        xor     eax,200000h     ; modify ID bit
        push    eax
        popfd                   ; save it in new EFLAGS
        pushfd                  ; get new EFLAGS
        pop     eax             ;
        xor     eax,ecx         ; is ID bit changed?
        jnz     cpuid_present   ; yes

        mov     byte ptr _cputype,Nx586 ; no, current Nx586
	mov	eax,1		; set return code == true
        jz      cpuid_exit      ; stop testing

nx_future_cpu:
; all NexGen's future processors feature a CPUID instruction
        mov     eax,ecx         ; get original EFLAGS
        xor     eax,200000h     ; modify ID bit
        push    eax
        popfd                   ; save it in new EFLAGS
        pushfd                  ; get new EFLAGS
        pop     eax             ;
        xor     eax,ecx         ; is ID bit changed?
        jz      not_nx_cpu      ; no, not a NexGen processor

cpuid_present:
; execute CPUID instruction to get vendor name, stepping and feature info
        xor     eax,eax
        CPU_ID
        mov     dword ptr _vendor_id,ebx
        mov     dword ptr _vendor_id[+4],edx
        mov     dword ptr _vendor_id[+8],ecx

        mov     bx,ds
        mov     es,bx
        mov     esi,offset _vendor_id
        mov     edi,offset NexGen_id
        mov     cx,12
        cld
        repe    cmpsb           ; compare vendor ID string
        jne     not_nx_cpu

        mov     byte ptr _cpuid_flag,PRESENT
        cmp     eax,1           ; check highest level
        jl      cpuid_exit

        mov     eax,1
        CPU_ID
        mov     _cpu_signature,eax
        mov     _features_ecx,ecx
        mov     _features_edx,edx
        mov     _features_ebx,ebx
        shr     eax,8
        and     al,0fh
        mov     _cputype,al
        jmp     cpuid_exit
not_nx_cpu:
        mov     byte ptr _nxcpu,NONE
        xor     eax,eax
cpuid_exit:
        pop     edi
        pop     esi
        pop     ebx
        ret
get_nxcpu_type endp

;**************************************************************************
;       Function:       int is_cyrix ()
;
;       Purpose:        Determine if Cyrix CPU is present
;       Technique:      Cyrix CPUs do not change flags where flags change
;                        in an undefined manner on other CPUs
;       Inputs:         none
;       Output:         ax == 1 Cyrix present, 0 if not
;**************************************************************************
is_cyrix proc C __cdecl:WORD
           .486
           push  bx
           xor   ax, ax         ; clear ax
           sahf                 ; clear flags, bit 1 is always 1 in flags
           mov   ax, 5
           mov   bx, 2
           div   bl             ; do an operation that does not change flags
           lahf                 ; get flags
           cmp   ah, 2          ; check for change in flags
           jne   not_cyrix      ; flags changed not Cyrix
           mov   ax, 1          ; TRUE Cyrix CPU
           jmp   done

not_cyrix:
           mov  ax, 0           ; FALSE NON-Cyrix CPU
done:
           pop  bx
           ret
is_cyrix   endp
_TEXT ends
      end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\cameracp.h ===
/****************************************************************************
 *  @doc INTERNAL CAMERACP
 *
 *  @module CameraCP.h | Header file for the <c CCameraControlProperty>
 *    class used to implement a property page to test the TAPI interface
 *    <i ICameraControl>.
 *
 *  @comm This code tests the TAPI Video Decoder Filter <i ICameraControl>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/

#ifndef _CAMERACP_H_
#define _CAMERACP_H_

#ifdef USE_PROPERTY_PAGES

#ifdef USE_CAMERA_CONTROL

#define NUM_CAMERA_CONTROLS 9

/****************************************************************************
 *  @doc INTERNAL CCAMERACPCLASS
 *
 *  @class CCameraControlProperty | This class implements handling of a
 *    single camera control property in a property page.
 *
 *  @mdata int | CCameraControlProperty | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata ICameraControl * | CCameraControlProperty | m_pInterface | Pointer
 *    to the <i ICameraControl> interface.
 *
 *  @comm This code tests the TAPI Video Decoder Filter <i ICameraControl>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
***************************************************************************/
class CCameraControlProperty : public CPropertyEditor 
{
	public:
	CCameraControlProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, ICameraControl *pInterface);
	~CCameraControlProperty ();

	// CPropertyEditor base class pure virtual overrides
	HRESULT GetValue();
	HRESULT SetValue();
	HRESULT GetRange();
	BOOL CanAutoControl(void);
	BOOL GetAuto(void);
	BOOL SetAuto(BOOL fAuto);

	private:
	ICameraControl *m_pInterface;
};

/****************************************************************************
 *  @doc INTERNAL CCAMERACPCLASS
 *
 *  @class CCameraControlProperties | This class runs a property page to test
 *    the TAPI Capture Filter <i ICameraControl> implementation.
 *
 *  @mdata int | CCameraControlProperties | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata ICameraControl * | CCameraControlProperties | m_pICameraControl | Pointer
 *    to the <i ICameraControl> interface.
 *
 *  @mdata CCameraControlProperty * | CCameraControlProperties | m_Controls[NUM_CAMERA_CONTROLS] | Array
 *    of camera control properties.
 *
 *  @comm This code tests the TAPI Capture Filter <i ICameraControl>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
***************************************************************************/
class CCameraControlProperties : public CBasePropertyPage
{
	public:
	CCameraControlProperties(LPUNKNOWN pUnk, HRESULT *pHr);
	~CCameraControlProperties();

	HRESULT OnConnect(IUnknown *pUnk);
	HRESULT OnDisconnect();
	HRESULT OnActivate();
	HRESULT OnDeactivate();
	HRESULT OnApplyChanges();
	BOOL    OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	private:

	void SetDirty();

	int m_NumProperties;
	ICameraControl *m_pICameraControl;
	BOOL m_fActivated;
	CCameraControlProperty *m_Controls[NUM_CAMERA_CONTROLS];
};

#endif // USE_CAMERA_CONTROL

#endif // USE_PROPERTY_PAGES

#endif // _CAMERACP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\camerac.cpp ===
/****************************************************************************
 *  @doc INTERNAL CAMERAC
 *
 *  @module CameraC.cpp | Source file for the <c CTAPIVDec>
 *    class methods used to implement the TAPI <i ICameraControl> interface.
 *
 *  @comm The <c CTAPIVDec> class does everything in software.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_CAMERA_CONTROL

#define PAN_TILT_MIN -180
#define PAN_TILT_MAX 180
#define PAN_TILT_DELTA 1
#define PAN_TILT_DEFAULT 0
#define ZOOM_MIN 10
#define ZOOM_MAX 600
#define ZOOM_DELTA 10
#define ZOOM_DEFAULT ZOOM_MIN
#define FLIP_MIN 0
#define FLIP_MAX 1
#define FLIP_DELTA 1
#define FLIP_DEFAULT FLIP_MIN

// From TAPIH263\cdrvdefs.h
#define PLAYBACK_CUSTOM_START				(ICM_RESERVED_HIGH     + 1)
#define PLAYBACK_CUSTOM_SET_ZOOM			(PLAYBACK_CUSTOM_START + 12)
#define PLAYBACK_CUSTOM_SET_PAN				(PLAYBACK_CUSTOM_START + 13)
#define PLAYBACK_CUSTOM_SET_TILT			(PLAYBACK_CUSTOM_START + 14)
#define PLAYBACK_CUSTOM_SET_FLIPVERTICAL	(PLAYBACK_CUSTOM_START + 15)
#define PLAYBACK_CUSTOM_SET_FLIPHORIZONTAL	(PLAYBACK_CUSTOM_START + 16)

/****************************************************************************
 *  @doc INTERNAL CCAMERACMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | Set | This method is used to set the value
 *    of a camera control setting.
 *
 *  @parm TAPICameraControlProperty | Property | Used to specify the camera
 *    control setting to set the value of. Use a member of the
 *    <t TAPICameraControlProperty> enumerated type.
 *
 *  @parm long | lValue | Used to specify the new value of the camera control
 *    setting.
 *
 *  @parm TAPIControlFlags | Flags | A member of the <t TAPIControlFlags>
 *    enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::Set(IN TAPICameraControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIVDec::Set (CameraControl)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT((Property >= TAPICameraControl_Pan && Property <= TAPICameraControl_Focus) || Property == TAPICameraControl_FlipVertical || Property == TAPICameraControl_FlipHorizontal);

	// Update the property and flags
	switch (Property)
	{
		case TAPICameraControl_Pan:
			ASSERT(lValue >= PAN_TILT_MIN && lValue <= PAN_TILT_MAX);
			if (lValue >= PAN_TILT_MIN && lValue <= PAN_TILT_MAX)
			{
				m_lCCPan = lValue;
				(*m_pDriverProc)((DWORD)m_pInstInfo, NULL, PLAYBACK_CUSTOM_SET_PAN, (LPARAM)lValue, NULL);
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
				Hr = E_INVALIDARG;
			}
			break;
		case TAPICameraControl_Tilt:
			ASSERT(lValue >= PAN_TILT_MIN && lValue <= PAN_TILT_MAX);
			if (lValue >= PAN_TILT_MIN && lValue <= PAN_TILT_MAX)
			{
				m_lCCTilt = lValue;
				(*m_pDriverProc)((DWORD)m_pInstInfo, NULL, PLAYBACK_CUSTOM_SET_TILT, (LPARAM)lValue, NULL);
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
				Hr = E_INVALIDARG;
			}
			break;
		case TAPICameraControl_Zoom:
			ASSERT(lValue >= ZOOM_MIN && lValue <= ZOOM_MAX);
			if (lValue >= ZOOM_MIN && lValue <= ZOOM_MAX)
			{
				m_lCCZoom = lValue;
				(*m_pDriverProc)((DWORD)m_pInstInfo, NULL, PLAYBACK_CUSTOM_SET_ZOOM, (LPARAM)lValue, NULL);
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
				Hr = E_INVALIDARG;
			}
			break;
		case TAPICameraControl_FlipVertical:
			m_fFlipVertical = lValue;
			(*m_pDriverProc)((DWORD)m_pInstInfo, NULL, PLAYBACK_CUSTOM_SET_FLIPVERTICAL, (LPARAM)lValue, NULL);
			break;
		case TAPICameraControl_FlipHorizontal:
			m_fFlipHorizontal = lValue;
			(*m_pDriverProc)((DWORD)m_pInstInfo, NULL, PLAYBACK_CUSTOM_SET_FLIPHORIZONTAL, (LPARAM)lValue, NULL);
			break;
		default:
			Hr = E_PROP_ID_UNSUPPORTED;
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | Get | This method is used to retrieve the
 *    value of a camera control setting.
 *
 *  @parm TAPICameraControlProperty | Property | Used to specify the camera
 *    control setting to get the value of. Use a member of the
 *    <t TAPICameraControlProperty> enumerated type.
 *
 *  @parm long* | plValue | Used to retrieve the current value of the
 *    camera control setting.
 *
 *  @parm TAPIControlFlags* | plFlags | Pointer to a member of the <t TAPIControlFlags>
 *    enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::Get(IN TAPICameraControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIVDec::Get (CameraControl)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plValue);
	ASSERT(plFlags);
	if (!plValue || !plFlags)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT((Property >= TAPICameraControl_Pan && Property <= TAPICameraControl_Focus) || Property == TAPICameraControl_FlipVertical || Property == TAPICameraControl_FlipHorizontal);

	// Update the property and flags
	*plFlags = TAPIControl_Flags_Manual;
	switch (Property)
	{
		case TAPICameraControl_Pan:
			*plValue = m_lCCPan;
			break;
		case TAPICameraControl_Tilt:
			*plValue = m_lCCTilt;
			break;
		case TAPICameraControl_Zoom:
			*plValue = m_lCCZoom;
			break;
		case TAPICameraControl_FlipVertical:
			*plValue = m_fFlipVertical;
			break;
		case TAPICameraControl_FlipHorizontal:
			*plValue = m_fFlipHorizontal;
			break;
		default:
			Hr = E_PROP_ID_UNSUPPORTED;
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | GetRange | This method is used to retrieve
 *    the minimum, maximum, and default values for specific camera control
 *    settings.
 *
 *  @parm CameraControlProperty | Property | Used to specify the camera
 *    control setting to determine the range of. Use a member of the
 *    <t CameraControlProperty> enumerated type.
 *
 *  @parm long* | plMin | Used to retrieve the minimum value of the camera
 *    control setting range.
 *
 *  @parm long* | plMax | Used to retrieve the maximum value of the camera
 *    control setting range.
 *
 *  @parm long* | plSteppingDelta | Used to retrieve the stepping delta of
 *    the camera control setting range.
 *
 *  @parm long* | plDefault | Used to retrieve the default value of the
 *    camera control setting range.
 *
 *  @parm TAPIControlFlags* | plCapsFlags | Used to retrieve the capabilities
 *     of the camera control setting. Pointer to a member of the <t TAPIControlFlags>
 *     enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::GetRange(IN TAPICameraControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIVDec::GetRange (CameraControl)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plMin);
	ASSERT(plMax);
	ASSERT(plSteppingDelta);
	ASSERT(plDefault);
	ASSERT(plCapsFlags);
	if (!plMin || !plMax || !plSteppingDelta || !plDefault || !plCapsFlags)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT((Property >= TAPICameraControl_Pan && Property <= TAPICameraControl_Focus) || Property == TAPICameraControl_FlipVertical || Property == TAPICameraControl_FlipHorizontal);

	// Update the property and flags
	*plCapsFlags = TAPIControl_Flags_Manual;
	switch (Property)
	{
		case TAPICameraControl_Pan:
		case TAPICameraControl_Tilt:
			*plMin = PAN_TILT_MIN;
			*plMax = PAN_TILT_MAX;
			*plSteppingDelta = PAN_TILT_DELTA;
			*plDefault = PAN_TILT_DEFAULT;
			break;
		case TAPICameraControl_Zoom:
			*plMin = ZOOM_MIN;
			*plMax = ZOOM_MAX;
			*plSteppingDelta = ZOOM_DELTA;
			*plDefault = ZOOM_DEFAULT;
			break;
		case TAPICameraControl_FlipVertical:
		case TAPICameraControl_FlipHorizontal:
			*plMin = FLIP_MIN;
			*plMax = FLIP_MAX;
			*plSteppingDelta = FLIP_DELTA;
			*plDefault = FLIP_DEFAULT;
			break;
		default:
			Hr = E_PROP_ID_UNSUPPORTED;
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivcap\vc50\msviddrv.h ===
/****************************************************************************/
/*                                                                          */
/*        MSVIDDRV.H - Include file for messages to video drivers           */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1994, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MSVIDDRV
#define _INC_MSVIDDRV	50	/* version number */

#ifdef WIN32
#ifndef DWORD_PTR
#define DWORD_PTR unsigned long
#endif
#ifndef INT_PTR
#define INT_PTR int
#endif
#ifndef LONG_PTR
#define LONG_PTR long
#endif
#ifndef UINT_PTR
#define UINT_PTR unsigned int
#endif
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****************************************************************************

                 Digital Video Messages (DVM_)

****************************************************************************/

// General messages
#define DVM_START                         DRV_USER
#define DVM_GETERRORTEXT                  (DVM_START + 0)
#define DVM_GETVIDEOAPIVER                (DVM_START + 1)

// This value increments each time the API changes
// It is passed to the driver in the DRV_OPEN message.
#define VIDEOAPIVERSION 		3

// General messages applicable to all channel types
#define DVM_DIALOG			(DVM_START + 100)
#define DVM_CONFIGURESTORAGE		(DVM_START + 101)
#define DVM_GET_CHANNEL_CAPS         	(DVM_START + 102)
#define DVM_UPDATE         		(DVM_START + 103)

// Single frame msg
#define DVM_FRAME			(DVM_START + 200)

// stream messages
#define DVM_STREAM_MSG_START            (DVM_START + 300)
#define DVM_STREAM_MSG_END              (DVM_START + 399)

#define DVM_STREAM_ADDBUFFER            (DVM_START + 300)
#define DVM_STREAM_FINI                 (DVM_START + 301)
#define DVM_STREAM_GETERROR             (DVM_START + 302)
#define DVM_STREAM_GETPOSITION          (DVM_START + 303)
#define DVM_STREAM_INIT                 (DVM_START + 304)
#define DVM_STREAM_PREPAREHEADER        (DVM_START + 305)
#define DVM_STREAM_RESET                (DVM_START + 306)
#define DVM_STREAM_START                (DVM_START + 307)
#define DVM_STREAM_STOP                 (DVM_START + 308)
#define DVM_STREAM_UNPREPAREHEADER      (DVM_START + 309)

// Following added post VFW1.1a
#define DVM_STREAM_ALLOCHDRANDBUFFER    (DVM_START + 310)
#define DVM_STREAM_FREEHDRANDBUFFER     (DVM_START + 311)

// NOTE that DVM_CONFIGURE numbers will start at 0x1000 (for configure API)


/****************************************************************************

                            Open Definitions

****************************************************************************/
#define OPEN_TYPE_VCAP mmioFOURCC('v', 'c', 'a', 'p')

// The following structure is the same as IC_OPEN
// to allow compressors and capture devices to share
// the same DriverProc.

typedef struct tag_video_open_parms {
    DWORD               dwSize;         // sizeof(VIDEO_OPEN_PARMS)
    FOURCC              fccType;        // 'vcap'
    FOURCC              fccComp;        // unused
    DWORD               dwVersion;      // version of msvideo opening you
    DWORD               dwFlags;        // channel type
    DWORD               dwError;        // if open fails, this is why
} VIDEO_OPEN_PARMS, FAR * LPVIDEO_OPEN_PARMS;

typedef struct tag_video_geterrortext_parms {
       DWORD  dwError;          // The error number to identify
#ifdef WIN32
       LPWSTR lpText;		// Text buffer to fill
#else
       LPSTR lpText;		// Text buffer to fill
#endif
       DWORD  dwLength;		// Size of text buffer in characters
} VIDEO_GETERRORTEXT_PARMS, FAR * LPVIDEO_GETERRORTEXT_PARMS;

typedef struct tag_video_stream_init_parms {
       DWORD  dwMicroSecPerFrame;
       DWORD_PTR  dwCallback;
       DWORD_PTR  dwCallbackInst;
       DWORD  dwFlags;
       HVIDEO  hVideo;
} VIDEO_STREAM_INIT_PARMS, FAR * LPVIDEO_STREAM_INIT_PARMS;

typedef struct tag_video_configure_parms {
       LPDWORD  lpdwReturn;	// Return parameter from configure MSG.
       LPVOID	lpData1;	// Pointer to data 1.
       DWORD	dwSize1;	// size of data buffer 1.
       LPVOID	lpData2;	// Pointer to data 2.
       DWORD	dwSize2;	// size of data buffer 2.
} VIDEOCONFIGPARMS, FAR * LPVIDEOCONFIGPARMS;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_MSVIDDRV */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivcap\i386\seh.c ===
/*****************************************************************************
 *
 *  Seh.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Structured exception handling.
 *
 *****************************************************************************/
#include <windows.h>

typedef DWORD (CALLBACK *INEXCEPTION)(LPEXCEPTION_RECORD per, PCONTEXT pctx);
typedef DWORD (CALLBACK *EXCEPTPROC)(void* pv);

typedef void *PV;

/*****************************************************************************
 *
 *      SEHFRAME
 *
 *      Special stack frame used by lightweight structured exception
 *      handling.
 *
 *****************************************************************************/

typedef struct SEHFRAME {

    PV      pvSEH;              /* Link to previous frame   */
    FARPROC Handler;            /* MyExceptionFilter        */
    FARPROC sehTarget;          /* Where to jump on error   */
    INEXCEPTION InException;    /* In-exception handler     */

} SEHFRAME, *PSEHFRAME;

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | _MyExceptionFilter |
 *
 *          My tiny exception filter.
 *
 *  @parm   LPEXCEPTION_RECORD | pExceptionRecord |
 *
 *          Exception record describing why we were called.
 *
 *  @parm   PV | EstablisherFrame |
 *
 *          The exception frame (pNext, pHandler)
 *          on the stack which is being handled.  This is used so that
 *          the handler can access its local variables and knows how
 *          far to smash the stack if the exception is being eaten.
 *
 *  @parm   PCONTEXT | pContextRecord |
 *
 *          Client context at time of exception.
 *
 *  @parm   PV | DispatcherContext |
 *
 *          Not used.  Which is good, because I don't know what it means.
 *
 ***************************************************************************/

#define EXCEPTION_UNWINDING     0x00000002
#define EXCEPTION_EXIT_UNWIND   0x00000004

WINBASEAPI void WINAPI
RtlUnwind(PV TargetFrame, PV TargetIp, PEXCEPTION_RECORD per, PV ReturnValue);

EXCEPTION_DISPOSITION
__cdecl
_MyExceptionFilter(
    LPEXCEPTION_RECORD pExceptionRecord,
    PV EstablisherFrame,
    PCONTEXT pContextRecord,
    PV DispatcherContext
)
{
    DispatcherContext;
    pContextRecord;

    /* Don't interfere with an unwind */
    if ((pExceptionRecord->ExceptionFlags &
            (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND)) == 0) {
        PSEHFRAME pseh = EstablisherFrame;
        BOOL fRc = pseh->InException(pExceptionRecord, pContextRecord);

        /*
         *  RtlUnwind will tell all exception frames that may have
         *  been created underneath us that they are about to be
         *  blown away and should do their __finally handling.
         *
         *  On return, the nested frames have been unlinked.
         */
        RtlUnwind(EstablisherFrame, 0, 0, 0);

        /*
         *  And jump back to the caller.  It is the caller's
         *  responsibility to restore nonvolatile registers!
         *
         *  We also assume that the caller has nothing on the
         *  stack beneath the exception record!
         *
         *  And the handler address is right after the exception
         *  record!
         */
        __asm {
            mov     eax, fRc;               /* Get return value */
            mov     esp, EstablisherFrame;  /* Restore ESP */
//            jmp     [esp].sehTarget;        /* Back to CallWithSEH */

//We should be doing the above, but it faults VC4.2. Gotta love it.

            jmp     DWORD ptr [esp+8]
        }

    }

    /*
     *  We are unwinding.  Don't interfere.
     */
    return EXCEPTION_CONTINUE_SEARCH;
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | CallWithSEH |
 *
 *          Call the function with an exception frame active.
 *
 *          If the procedure raises an exception, then call
 *          InException and propagate whatever InException returns.
 *
 ***************************************************************************/

#pragma warning(disable:4035)           /* no return value (duh) */

__declspec(naked) DWORD WINAPI
CallWithSEH(EXCEPTPROC pfn, PV pv, INEXCEPTION InException)
{
    __asm {

        /* Function prologue */
        push    ebp;
        mov     ebp, esp;                       /* To keep C compiler happy */
        push    ebx;
        push    edi;
        push    esi;

        /*
         *  Build a SEHFRAME.
         */
        push    InException;                    /* What to handle */
        push    offset Exit;                    /* Where to go on error */

        xor     edx, edx;                       /* Keep zero handy */
        push    offset _MyExceptionFilter;      /* My handler */
        push    dword ptr fs:[edx];             /* Build frame */
        mov     fs:[edx], esp;                  /* Link in */
    }

        pfn(pv);                                /* Call the victim */

    __asm {
        /*
         *  The validation layer jumps here (all registers in a random
         *  state except for ESP) if something went wrong.
         *
         *  We don't need to restore nonvolatile registers now;
         *  that will be done as part of the procedure exit.
         */
Exit:;

        xor     edx, edx;                       /* Keep zero handy */
        pop     dword ptr fs:[edx];             /* Remove frame */

        /*
         *  Discard MyExceptionFilter, Exit, and InException.
         */
        add     esp, 12;

        pop     esi;
        pop     edi;
        pop     ebx;
        pop     ebp;
        ret     12;
    }

}

#pragma warning(default:4035)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\formats.h ===
/****************************************************************************
 *  @doc INTERNAL FORMATS
 *
 *  @module Formats.h | Header file for the supported compressed input formats.
 ***************************************************************************/

#ifndef _FORMATS_H_
#define _FORMATS_H_

// List of capture formats supported
#define MAX_FRAME_INTERVAL 10000000L
#define MIN_FRAME_INTERVAL 333333L
#define STILL_FRAME_INTERVAL 10000000

#define NUM_H245VIDEOCAPABILITYMAPS 5
#define NUM_RATES_PER_RESOURCE 5
#define NUM_ITU_SIZES 3
#define QCIF_SIZE 0
#define CIF_SIZE 1
#define SQCIF_SIZE 2

#define R263_QCIF_H245_CAPID 0UL
#define R263_CIF_H245_CAPID 1UL
#define R263_SQCIF_H245_CAPID 2UL
#define R261_QCIF_H245_CAPID 3UL
#define R261_CIF_H245_CAPID 4UL

extern const AM_MEDIA_TYPE AMMT_R263_QCIF;
extern const AM_MEDIA_TYPE AMMT_R263_CIF;
extern const AM_MEDIA_TYPE AMMT_R263_SQCIF;
extern const AM_MEDIA_TYPE AMMT_R261_QCIF;
extern const AM_MEDIA_TYPE AMMT_R261_CIF;

#define NUM_R26X_FORMATS 5

extern const AM_MEDIA_TYPE* const R26XFormats[NUM_R26X_FORMATS];
extern const TAPI_STREAM_CONFIG_CAPS* const R26XCaps[NUM_R26X_FORMATS];
extern DWORD const R26XPayloadTypes[NUM_R26X_FORMATS];

#define H263_PAYLOAD_TYPE 34UL
#define H261_PAYLOAD_TYPE 31UL

#endif // _FORMATS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\cameracp.cpp ===
/****************************************************************************
 *  @doc INTERNAL CAMERACP
 *
 *  @module CameraCP.cpp | Source file for the <c CCameraControlProperty>
 *    class used to implement a property page to test the TAPI interface
 *    <i ICameraControl>.
 *
 *  @comm This code tests the TAPI H.26X Video Decoder filter <i ICameraControl>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_PROPERTY_PAGES

#ifdef USE_CAMERA_CONTROL

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc void | CCameraControlProperty | CCameraControlProperty | This
 *    method is the constructor for camera control property objects. It
 *    calls the base class constructor, calls InitCommonControlsEx, and saves
 *    a pointer to the <i ICameraControl> interface.
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    property progress bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the Ks property.
 *
 *  @parm ICameraControl* | pInterface | Specifies a pointer to the
 *    <i ICameraControl> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCameraControlProperty::CCameraControlProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, ICameraControl *pInterface)
: CPropertyEditor(hDlg, IDLabel, IDMinControl, IDMaxControl, IDDefaultControl, IDStepControl, IDEditControl, IDTrackbarControl, IDProgressControl, IDProperty, IDAutoControl)
{
	INITCOMMONCONTROLSEX cc;

	FX_ENTRY("CCameraControlProperty::CCameraControlProperty")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
	cc.dwICC  = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

	InitCommonControlsEx(&cc);

	// It's fine if the interface pointer is NULL, we'll grey the
	// associated items in the property page
	m_pInterface = pInterface;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc void | CCameraControlProperty | ~CCameraControlProperty | This
 *    method is the destructor for camera control property objects. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCameraControlProperty::~CCameraControlProperty()
{
	FX_ENTRY("CCameraControlProperty::~CCameraControlProperty")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperty | GetValue | This method queries for
 *    the value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperty::GetValue()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCameraControlProperty::GetValue")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->Get((TAPICameraControlProperty)m_IDProperty, &m_CurrentValue, (TAPIControlFlags *)&m_CurrentFlags)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_CurrentValue=%ld, m_CurrentFlags=%ld", _fx_, m_CurrentValue, m_CurrentFlags));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: m_pICameraControl->Get failed Hr=0x%08lX", _fx_, Hr));
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperty | SetValue | This method sets the
 *    value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperty::SetValue()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCameraControlProperty::SetValue")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->Set((TAPICameraControlProperty)m_IDProperty, m_CurrentValue, (TAPIControlFlags)m_CurrentFlags)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_CurrentValue=%ld, m_CurrentFlags=%ld", _fx_, m_CurrentValue, m_CurrentFlags));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: m_pICameraControl->Set failed Hr=0x%08lX", _fx_, Hr));
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperty | GetRange | This method retrieves
 *    the range information of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperty::GetRange()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCameraControlProperty::GetRange")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->GetRange((TAPICameraControlProperty)m_IDProperty, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, (TAPIControlFlags *)&m_CapsFlags)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Min=%ld, m_Max=%ld, m_SteppingDelta=%ld, m_DefaultValue=%ld, m_CapsFlags=%ld", _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue, m_CapsFlags));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: m_pICameraControl->GetRange failed Hr=0x%08lX", _fx_, Hr));
	}
	m_DefaultFlags = m_CapsFlags;

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc CUnknown* | CCameraControlProperties | CreateInstance | This
 *    method is called by DShow to create an instance of a
 *    Property Page. It is referred to in the global structure <t g_Templates>.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Returns a pointer to the nondelegating CUnknown portion of the
 *    object, or NULL otherwise.
 ***************************************************************************/
CUnknown* CALLBACK CCameraControlPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr) 
{
	CUnknown *pUnknown = (CUnknown *)NULL;

	FX_ENTRY("CCameraControlPropertiesCreateInstance")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pHr);
	if (!pHr)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		goto MyExit;
	}

	if (!(pUnknown = new CCameraControlProperties(pUnkOuter, pHr)))
	{
		*pHr = E_OUTOFMEMORY;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: new CCameraControlProperties failed", _fx_));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: new CCameraControlProperties created", _fx_));
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return pUnknown;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc void | CCameraControlProperties | CCameraControlProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCameraControlProperties::CCameraControlProperties(LPUNKNOWN pUnk, HRESULT *pHr) : CBasePropertyPage(NAME("Camera Control Property Page"), pUnk, IDD_CameraControlProperties, IDS_CAMERACONTROLPROPNAME)
{
	FX_ENTRY("CCameraControlProperties::CCameraControlProperties")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	m_pICameraControl = NULL;
	m_NumProperties = NUM_CAMERA_CONTROLS;
	m_fActivated = FALSE;

	for (int i = 0; i < m_NumProperties; i++)
		m_Controls[i] = NULL;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc void | CCameraControlProperties | ~CCameraControlProperties | This
 *    method is the destructor for camera control property page. It
 *    simply calls the base class destructor after deleting all the controls.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCameraControlProperties::~CCameraControlProperties()
{
	int		j;

	FX_ENTRY("CCameraControlProperties::~CCameraControlProperties")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperties | OnConnect | This
 *    method is called when the property page is connected to the filter.
 *
 *  @parm LPUNKNOWN | pUnknown | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperties::OnConnect(IUnknown *pUnk)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCameraControlProperties::OnConnect")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pUnk);
	if (!pUnk)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the camera control interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(ICameraControl),(void **)&m_pICameraControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_pICameraControl=0x%08lX", _fx_, m_pICameraControl));
	}
	else
	{
		m_pICameraControl = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers. We'll just grey the controls in the property page
	// to make it clear to the user that they can't control those properties on the device
	Hr = NOERROR;

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperties::OnDisconnect()
{
	FX_ENTRY("CCameraControlProperties::OnDisconnect")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters: we seem to get called several times here
	// Make sure the interface pointer is still valid
	if (!m_pICameraControl)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   WARNING: already disconnected!", _fx_));
	}
	else
	{
		// Release the interface
		m_pICameraControl->Release();
		m_pICameraControl = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: releasing m_pICameraControl", _fx_));
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperties | OnActivate | This
 *    method is called when the property page is activated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperties::OnActivate()
{
	HRESULT	Hr = E_OUTOFMEMORY;
	int		j;

	FX_ENTRY("CCameraControlProperties::OnActivate")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Create the controls for the properties
	if (!(m_Controls[0] = new CCameraControlProperty(m_hwnd, IDC_Pan_Label, IDC_Pan_Minimum, IDC_Pan_Maximum, IDC_Pan_Default, IDC_Pan_Stepping, IDC_Pan_Edit, IDC_Pan_Slider, 0, TAPICameraControl_Pan, IDC_Pan_Auto, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_Pan] failed - Out of memory", _fx_));
		goto MyExit;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_Pan]=0x%08lX", _fx_, m_Controls[0]));
	}

	if (!(m_Controls[1] = new CCameraControlProperty(m_hwnd, IDC_Tilt_Label, IDC_Tilt_Minimum, IDC_Tilt_Maximum, IDC_Tilt_Default, IDC_Tilt_Stepping, IDC_Tilt_Edit, IDC_Tilt_Slider, 0, TAPICameraControl_Tilt, IDC_Tilt_Auto, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_Tilt] failed - Out of memory", _fx_));
		goto MyError0;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_Tilt]=0x%08lX", _fx_, m_Controls[1]));
	}

	if (!(m_Controls[2] = new CCameraControlProperty(m_hwnd, IDC_Roll_Label, IDC_Roll_Minimum, IDC_Roll_Maximum, IDC_Roll_Default, IDC_Roll_Stepping, IDC_Roll_Edit, IDC_Roll_Slider, 0, TAPICameraControl_Roll, IDC_Roll_Auto, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_Roll] failed - Out of memory", _fx_));
		goto MyError1;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_Roll]=0x%08lX", _fx_, m_Controls[2]));
	}

	if (!(m_Controls[3] = new CCameraControlProperty(m_hwnd, IDC_Zoom_Label, IDC_Zoom_Minimum, IDC_Zoom_Maximum, IDC_Zoom_Default, IDC_Zoom_Stepping, IDC_Zoom_Edit, IDC_Zoom_Slider, 0, TAPICameraControl_Zoom, IDC_Zoom_Auto, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_Zoom] failed - Out of memory", _fx_));
		goto MyError2;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_Zoom]=0x%08lX", _fx_, m_Controls[3]));
	}

	if (!(m_Controls[4] = new CCameraControlProperty(m_hwnd, IDC_Exposure_Label, IDC_Exposure_Minimum, IDC_Exposure_Maximum, IDC_Exposure_Default, IDC_Exposure_Stepping, IDC_Exposure_Edit, IDC_Exposure_Slider, 0, TAPICameraControl_Exposure, IDC_Exposure_Auto, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_Exposure] failed - Out of memory", _fx_));
		goto MyError3;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_Exposure]=0x%08lX", _fx_, m_Controls[4]));
	}

	if (!(m_Controls[5] = new CCameraControlProperty(m_hwnd, IDC_Iris_Label, IDC_Iris_Minimum, IDC_Iris_Maximum, IDC_Iris_Default, IDC_Iris_Stepping, IDC_Iris_Edit, IDC_Iris_Slider, 0, TAPICameraControl_Iris, IDC_Iris_Auto, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_Iris] failed - Out of memory", _fx_));
		goto MyError4;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_Iris]=0x%08lX", _fx_, m_Controls[5]));
	}

	if (!(m_Controls[6] = new CCameraControlProperty(m_hwnd, IDC_Focus_Label, IDC_Focus_Minimum, IDC_Focus_Maximum, IDC_Focus_Default, IDC_Focus_Stepping, IDC_Focus_Edit, IDC_Focus_Slider, 0, TAPICameraControl_Focus, 0, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_Focus] failed - Out of memory", _fx_));
		goto MyError5;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_Focus]=0x%08lX", _fx_, m_Controls[6]));
	}

	if (!(m_Controls[7] = new CCameraControlProperty(m_hwnd, 0, 0, 0, 0, 0, IDC_FlipVertical_Edit, 0, 0, TAPICameraControl_FlipVertical, 0, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_FlipVertical] failed - Out of memory", _fx_));
		goto MyError6;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_FlipVertical]=0x%08lX", _fx_, m_Controls[7]));
	}

	if (!(m_Controls[8] = new CCameraControlProperty(m_hwnd, 0, 0, 0, 0, 0, IDC_FlipHorizontal_Edit, 0, 0, TAPICameraControl_FlipHorizontal, 0, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_FlipHorizontal] failed - Out of memory", _fx_));
		goto MyError7;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_FlipHorizontal]=0x%08lX", _fx_, m_Controls[8]));
	}


	// Initialize all the controls. If the initialization fails, it's Ok. It just means
	// that the TAPI control interface isn't implemented by the device. The dialog item
	// in the property page will be greyed, showing this to the user.
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j]->Init())
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[%ld]->Init()", _fx_, j));
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   WARNING: m_Controls[%ld]->Init() failed", _fx_, j));
		}
	}

	Hr = NOERROR;
	goto MyExit;

MyError7:
	if (m_Controls[7])
		delete m_Controls[7], m_Controls[7] = NULL;
MyError6:
	if (m_Controls[6])
		delete m_Controls[6], m_Controls[6] = NULL;
MyError5:
	if (m_Controls[5])
		delete m_Controls[5], m_Controls[5] = NULL;
MyError4:
	if (m_Controls[4])
		delete m_Controls[4], m_Controls[4] = NULL;
MyError3:
	if (m_Controls[3])
		delete m_Controls[3], m_Controls[3] = NULL;
MyError2:
	if (m_Controls[2])
		delete m_Controls[2], m_Controls[2] = NULL;
MyError1:
	if (m_Controls[1])
		delete m_Controls[1], m_Controls[1] = NULL;
MyError0:
	if (m_Controls[0])
		delete m_Controls[0], m_Controls[0] = NULL;
MyExit:
	m_fActivated = TRUE;
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperties | OnDeactivate | This
 *    method is called when the property page is dismissed.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperties::OnDeactivate()
{
	int		j;

	FX_ENTRY("CCameraControlProperties::OnDeactivate")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	m_fActivated = FALSE;
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperties | OnApplyChanges | This
 *    method is called when the user applies changes to the property page.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperties::OnApplyChanges()
{
	HRESULT	Hr = NOERROR;

	FX_ENTRY("CCameraControlProperties::OnApplyChanges")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	for (int j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			if (m_Controls[j]->HasChanged())
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: calling m_Controls[%ld]=0x%08lX->OnApply", _fx_, j, m_Controls[j]));
				m_Controls[j]->OnApply();
			}
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: can't call m_Controls[%ld]=NULL->OnApply", _fx_, j));
			Hr = E_UNEXPECTED;
			break;
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc BOOL | CCameraControlProperties | OnReceiveMessage | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
BOOL CCameraControlProperties::OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
		case WM_INITDIALOG:
			return TRUE; // Don't call setfocus

		case WM_HSCROLL:
		case WM_VSCROLL:
			if (m_fActivated)
			{
				// Process all of the Trackbar messages
				for (j = 0; j < m_NumProperties; j++)
				{
					ASSERT(m_Controls[j]);
					if (m_Controls[j]->GetTrackbarHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnScroll(uMsg, wParam, lParam);
						SetDirty();
					}
				}
				OnApplyChanges();
			}
			break;

		case WM_COMMAND:

			// This message gets sent even before OnActivate() has been
			// called(!). We need to test and make sure the controls have
			// beeen initialized before we can use them.

			if (m_fActivated)
			{
				// Process all of the auto checkbox messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetAutoHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnAuto(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				// Process all of the edit box messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetEditHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnEdit(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				switch (LOWORD(wParam))
				{
					case IDC_CONTROL_DEFAULT:
						for (j = 0; j < m_NumProperties; j++)
						{
							if (m_Controls[j])
								m_Controls[j]->OnDefault();
						}
						break;

					default:
						break;
				}

			OnApplyChanges();
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc BOOL | CCameraControlProperties | SetDirty | This
 *    method notifies the property page site of changes.
 *
 *  @rdesc Nada.
 ***************************************************************************/
void CCameraControlProperties::SetDirty()
{
	m_bDirty = TRUE;
	if (m_pPageSite)
		m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}

#endif // USE_CAMERA_CONTROL

#endif // USE_PROPERTY_PAGES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\formats.cpp ===
/****************************************************************************
 *  @doc INTERNAL FORMATS
 *
 *  @module Formats.cpp | Source file for the video formats we support.
 ***************************************************************************/

#include "Precomp.h"

// RTP packetized H.263 Version 1 QCIF size
#define CIF_BUFFER_SIZE 32768
#define D_X_CIF 352
#define D_Y_CIF 288

const TAPI_STREAM_CONFIG_CAPS TSCC_R263_CIF = 
{
	VideoStreamConfigCaps,						// CapsType
	{
	    L"H.263 v.1 CIF",						// Description
	    AnalogVideo_None,						// VideoStandard
	    D_X_CIF, D_Y_CIF,						// InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
	    D_X_CIF, D_Y_CIF,						// MinCroppingSize, smallest rcSrc cropping rect allowed
	    D_X_CIF, D_Y_CIF,						// MaxCroppingSize, largest  rcSrc cropping rect allowed
	    1,										// CropGranularityX, granularity of cropping size
	    1,										// CropGranularityY
	    1,										// CropAlignX, alignment of cropping rect 
	    1,										// CropAlignY;
	    D_X_CIF, D_Y_CIF,						// MinOutputSize, smallest bitmap stream can produce
	    D_X_CIF, D_Y_CIF,						// MaxOutputSize, largest  bitmap stream can produce
	    1,										// OutputGranularityX, granularity of output bitmap size
	    1,										// OutputGranularityY;
	    0,										// StretchTapsX
	    0,										// StretchTapsY
	    0,										// ShrinkTapsX
	    0,										// ShrinkTapsY
	    MIN_FRAME_INTERVAL,						// MinFrameInterval, 100 nS units
	    MAX_FRAME_INTERVAL,						// MaxFrameInterval, 100 nS units
	    0,										// MinBitsPerSecond
	    CIF_BUFFER_SIZE * 30 * 8				// MaxBitsPerSecond;
	}
}; 

const VIDEOINFOHEADER_H263 VIH_R263_CIF = 
{
    0,0,0,0,								// RECT  rcSource; 
    0,0,0,0,								// RECT  rcTarget; 
    CIF_BUFFER_SIZE * 30 * 8,				// DWORD dwBitRate;
    0L,										// DWORD dwBitErrorRate; 
    MIN_FRAME_INTERVAL,						// REFERENCE_TIME  AvgTimePerFrame;   

	{
		sizeof (BITMAPINFOHEADER_H263),		// DWORD biSize;
		D_X_CIF,							// LONG  biWidth;
		D_Y_CIF,							// LONG  biHeight;
		1,									// WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
		24,									// WORD  biBitCount;
#else
		0,									// WORD  biBitCount;
#endif
		FOURCC_R263,						// DWORD biCompression;
		CIF_BUFFER_SIZE,					// DWORD biSizeImage;
		0,									// LONG  biXPelsPerMeter;
		0,									// LONG  biYPelsPerMeter;
		0,									// DWORD biClrUsed;
		0,									// DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
		// H.263 specific fields
		CIF_BUFFER_SIZE * 30 * 8 / 100,     // dwMaxBitrate
		CIF_BUFFER_SIZE * 8 / 1024,			// dwBppMaxKb
		0,									// dwHRD_B

		//Options
		0,									// fUnrestrictedVector
		0,									// fArithmeticCoding
		0,									// fAdvancedPrediction
		0,									// fPBFrames
		0,									// fErrorCompensation
		0,									// fAdvancedIntraCodingMode
		0,									// fDeblockingFilterMode
		0,									// fImprovedPBFrameMode
		0,									// fUnlimitedMotionVectors
		0,									// fFullPictureFreeze
		0,									// fPartialPictureFreezeAndRelease
		0,									// fResizingPartPicFreezeAndRelease
		0,									// fFullPictureSnapshot
		0,									// fPartialPictureSnapshot
		0,									// fVideoSegmentTagging
		0,									// fProgressiveRefinement
		0,									// fDynamicPictureResizingByFour
		0,									// fDynamicPictureResizingSixteenthPel
		0,									// fDynamicWarpingHalfPel
		0,									// fDynamicWarpingSixteenthPel
		0,									// fIndependentSegmentDecoding
		0,									// fSlicesInOrder-NonRect
		0,									// fSlicesInOrder-Rect
		0,									// fSlicesNoOrder-NonRect
		0,									// fSlicesNoOrder-NonRect
		0,									// fAlternateInterVLCMode
		0,									// fModifiedQuantizationMode
		0,									// fReducedResolutionUpdate
		0,									// fReserved

		// Reserved
		0, 0, 0, 0							// dwReserved[4]
#endif
	}
};

const AM_MEDIA_TYPE AMMT_R263_CIF = 
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,			// majortype
    STATIC_MEDIASUBTYPE_R263_V1,			// subtype
    FALSE,									// bFixedSizeSamples (all samples same size?)
    TRUE,									// bTemporalCompression (uses prediction?)
    0,										// lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
	NULL,									// pUnk
	sizeof (VIH_R263_CIF),			// cbFormat
	(LPBYTE)&VIH_R263_CIF,			// pbFormat
};

// H.263 Version 1 QCIF size
#define QCIF_BUFFER_SIZE 8192
#define D_X_QCIF 176
#define D_Y_QCIF 144

const TAPI_STREAM_CONFIG_CAPS TSCC_R263_QCIF = 
{
	VideoStreamConfigCaps,						// CapsType
	{
	    L"H.263 v.1 QCIF",						// Description
	    AnalogVideo_None,						// VideoStandard
	    D_X_QCIF, D_Y_QCIF,						// InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
	    D_X_QCIF, D_Y_QCIF,						// MinCroppingSize, smallest rcSrc cropping rect allowed
	    D_X_QCIF, D_Y_QCIF,						// MaxCroppingSize, largest  rcSrc cropping rect allowed
	    1,										// CropGranularityX, granularity of cropping size
	    1,										// CropGranularityY
	    1,										// CropAlignX, alignment of cropping rect 
	    1,										// CropAlignY;
	    D_X_QCIF, D_Y_QCIF,						// MinOutputSize, smallest bitmap stream can produce
	    D_X_QCIF, D_Y_QCIF,						// MaxOutputSize, largest  bitmap stream can produce
	    1,										// OutputGranularityX, granularity of output bitmap size
	    1,										// OutputGranularityY;
	    0,										// StretchTapsX
	    0,										// StretchTapsY
	    0,										// ShrinkTapsX
	    0,										// ShrinkTapsY
	    MIN_FRAME_INTERVAL,						// MinFrameInterval, 100 nS units
	    MAX_FRAME_INTERVAL,						// MaxFrameInterval, 100 nS units
	    0,										// MinBitsPerSecond
	    QCIF_BUFFER_SIZE * 30 * 8				// MaxBitsPerSecond;
	}
}; 

const VIDEOINFOHEADER_H263 VIH_R263_QCIF = 
{
    0,0,0,0,								// RECT  rcSource; 
    0,0,0,0,								// RECT  rcTarget; 
    QCIF_BUFFER_SIZE * 30 * 8,				// DWORD dwBitRate;
    0L,										// DWORD dwBitErrorRate; 
    MIN_FRAME_INTERVAL,						// REFERENCE_TIME  AvgTimePerFrame;   

	{
		sizeof (BITMAPINFOHEADER_H263),		// DWORD biSize;
		D_X_QCIF,							// LONG  biWidth;
		D_Y_QCIF,							// LONG  biHeight;
		1,									// WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
		24,									// WORD  biBitCount;
#else
		0,									// WORD  biBitCount;
#endif
		FOURCC_R263,						// DWORD biCompression;
		QCIF_BUFFER_SIZE,					// DWORD biSizeImage;
		0,									// LONG  biXPelsPerMeter;
		0,									// LONG  biYPelsPerMeter;
		0,									// DWORD biClrUsed;
		0,									// DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
		// H.263 specific fields
		QCIF_BUFFER_SIZE * 30 * 8 / 100,	// dwMaxBitrate
		QCIF_BUFFER_SIZE * 8 / 1024,		// dwBppMaxKb
		0,									// dwHRD_B

		//Options
		0,									// fUnrestrictedVector
		0,									// fArithmeticCoding
		0,									// fAdvancedPrediction
		0,									// fPBFrames
		0,									// fErrorCompensation
		0,									// fAdvancedIntraCodingMode
		0,									// fDeblockingFilterMode
		0,									// fImprovedPBFrameMode
		0,									// fUnlimitedMotionVectors
		0,									// fFullPictureFreeze
		0,									// fPartialPictureFreezeAndRelease
		0,									// fResizingPartPicFreezeAndRelease
		0,									// fFullPictureSnapshot
		0,									// fPartialPictureSnapshot
		0,									// fVideoSegmentTagging
		0,									// fProgressiveRefinement
		0,									// fDynamicPictureResizingByFour
		0,									// fDynamicPictureResizingSixteenthPel
		0,									// fDynamicWarpingHalfPel
		0,									// fDynamicWarpingSixteenthPel
		0,									// fIndependentSegmentDecoding
		0,									// fSlicesInOrder-NonRect
		0,									// fSlicesInOrder-Rect
		0,									// fSlicesNoOrder-NonRect
		0,									// fSlicesNoOrder-NonRect
		0,									// fAlternateInterVLCMode
		0,									// fModifiedQuantizationMode
		0,									// fReducedResolutionUpdate
		0,									// fReserved

		// Reserved
		0, 0, 0, 0							// dwReserved[4]
#endif
	}
};

const AM_MEDIA_TYPE AMMT_R263_QCIF = 
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,			// majortype
    STATIC_MEDIASUBTYPE_R263_V1,			// subtype
    FALSE,									// bFixedSizeSamples (all samples same size?)
    TRUE,									// bTemporalCompression (uses prediction?)
    0,										// lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
	NULL,									// pUnk
	sizeof (VIH_R263_QCIF),			// cbFormat
	(LPBYTE)&VIH_R263_QCIF,			// pbFormat
};

// H.263 Versions 1 SQCIF size
#define SQCIF_BUFFER_SIZE 8192
#define D_X_SQCIF 128
#define D_Y_SQCIF 96

const TAPI_STREAM_CONFIG_CAPS TSCC_R263_SQCIF = 
{
	VideoStreamConfigCaps,						// CapsType
	{
	    L"H.263 v.1 SQCIF",						// Description
	    D_X_SQCIF, D_Y_SQCIF,					// InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
	    D_X_SQCIF, D_Y_SQCIF,					// MinCroppingSize, smallest rcSrc cropping rect allowed
	    D_X_SQCIF, D_Y_SQCIF,					// MaxCroppingSize, largest  rcSrc cropping rect allowed
	    1,										// CropGranularityX, granularity of cropping size
	    1,										// CropGranularityY
	    1,										// CropAlignX, alignment of cropping rect 
	    1,										// CropAlignY;
	    D_X_SQCIF, D_Y_SQCIF,					// MinOutputSize, smallest bitmap stream can produce
	    D_X_SQCIF, D_Y_SQCIF,					// MaxOutputSize, largest  bitmap stream can produce
	    1,										// OutputGranularityX, granularity of output bitmap size
	    1,										// OutputGranularityY;
	    0,										// StretchTapsX
	    0,										// StretchTapsY
	    0,										// ShrinkTapsX
	    0,										// ShrinkTapsY
	    MIN_FRAME_INTERVAL,						// MinFrameInterval, 100 nS units
	    MAX_FRAME_INTERVAL,						// MaxFrameInterval, 100 nS units
	    0,										// MinBitsPerSecond
	    SQCIF_BUFFER_SIZE * 30 * 8				// MaxBitsPerSecond;
	}
}; 

const VIDEOINFOHEADER_H263 VIH_R263_SQCIF = 
{
    0,0,0,0,								// RECT  rcSource; 
    0,0,0,0,								// RECT  rcTarget; 
    SQCIF_BUFFER_SIZE * 30 * 8,				// DWORD dwBitRate;
    0L,										// DWORD dwBitErrorRate; 
    MIN_FRAME_INTERVAL,						// REFERENCE_TIME  AvgTimePerFrame;   

	{
		sizeof (BITMAPINFOHEADER_H263),		// DWORD biSize;
		D_X_SQCIF,							// LONG  biWidth;
		D_Y_SQCIF,							// LONG  biHeight;
		1,									// WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
		24,									// WORD  biBitCount;
#else
		0,									// WORD  biBitCount;
#endif
		FOURCC_R263,						// DWORD biCompression;
		SQCIF_BUFFER_SIZE,					// DWORD biSizeImage;
		0,									// LONG  biXPelsPerMeter;
		0,									// LONG  biYPelsPerMeter;
		0,									// DWORD biClrUsed;
		0,									// DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
		// H.263 specific fields
		SQCIF_BUFFER_SIZE * 30 * 8 / 100,	// dwMaxBitrate
		SQCIF_BUFFER_SIZE * 8 / 1024,		// dwBppMaxKb
		0,									// dwHRD_B

		//Options
		0,									// fUnrestrictedVector
		0,									// fArithmeticCoding
		0,									// fAdvancedPrediction
		0,									// fPBFrames
		0,									// fErrorCompensation
		0,									// fAdvancedIntraCodingMode
		0,									// fDeblockingFilterMode
		0,									// fImprovedPBFrameMode
		0,									// fUnlimitedMotionVectors
		0,									// fFullPictureFreeze
		0,									// fPartialPictureFreezeAndRelease
		0,									// fResizingPartPicFreezeAndRelease
		0,									// fFullPictureSnapshot
		0,									// fPartialPictureSnapshot
		0,									// fVideoSegmentTagging
		0,									// fProgressiveRefinement
		0,									// fDynamicPictureResizingByFour
		0,									// fDynamicPictureResizingSixteenthPel
		0,									// fDynamicWarpingHalfPel
		0,									// fDynamicWarpingSixteenthPel
		0,									// fIndependentSegmentDecoding
		0,									// fSlicesInOrder-NonRect
		0,									// fSlicesInOrder-Rect
		0,									// fSlicesNoOrder-NonRect
		0,									// fSlicesNoOrder-NonRect
		0,									// fAlternateInterVLCMode
		0,									// fModifiedQuantizationMode
		0,									// fReducedResolutionUpdate
		0,									// fReserved

		// Reserved
		0, 0, 0, 0							// dwReserved[4]
#endif
	}
};

const AM_MEDIA_TYPE AMMT_R263_SQCIF = 
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,			// majortype
    STATIC_MEDIASUBTYPE_R263_V1,			// subtype
    FALSE,									// bFixedSizeSamples (all samples same size?)
    TRUE,									// bTemporalCompression (uses prediction?)
    0,										// lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
	NULL,									// pUnk
	sizeof (VIH_R263_SQCIF),		// cbFormat
	(LPBYTE)&VIH_R263_SQCIF,		// pbFormat
};

// RTP packetized H.261 CIF size
const TAPI_STREAM_CONFIG_CAPS TSCC_R261_CIF = 
{
	VideoStreamConfigCaps,						// CapsType
	{
	    L"H.261 CIF",							// Description
	    AnalogVideo_None,						// VideoStandard
	    D_X_CIF, D_Y_CIF,						// InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
	    D_X_CIF, D_Y_CIF,						// MinCroppingSize, smallest rcSrc cropping rect allowed
	    D_X_CIF, D_Y_CIF,						// MaxCroppingSize, largest  rcSrc cropping rect allowed
	    1,										// CropGranularityX, granularity of cropping size
	    1,										// CropGranularityY
	    1,										// CropAlignX, alignment of cropping rect 
	    1,										// CropAlignY;
	    D_X_CIF, D_Y_CIF,						// MinOutputSize, smallest bitmap stream can produce
	    D_X_CIF, D_Y_CIF,						// MaxOutputSize, largest  bitmap stream can produce
	    1,										// OutputGranularityX, granularity of output bitmap size
	    1,										// OutputGranularityY;
	    0,										// StretchTapsX
	    0,										// StretchTapsY
	    0,										// ShrinkTapsX
	    0,										// ShrinkTapsY
	    MIN_FRAME_INTERVAL,						// MinFrameInterval, 100 nS units
	    MAX_FRAME_INTERVAL,						// MaxFrameInterval, 100 nS units
	    0,										// MinBitsPerSecond
	    CIF_BUFFER_SIZE * 30 * 8				// MaxBitsPerSecond;
	}
}; 

const VIDEOINFOHEADER_H261 VIH_R261_CIF = 
{
    0,0,0,0,								// RECT  rcSource; 
    0,0,0,0,								// RECT  rcTarget; 
    CIF_BUFFER_SIZE * 30 * 8,				// DWORD dwBitRate;
    0L,										// DWORD dwBitErrorRate; 
    MIN_FRAME_INTERVAL,						// REFERENCE_TIME  AvgTimePerFrame;   

	{
		sizeof (BITMAPINFOHEADER_H261),		// DWORD biSize;
		D_X_CIF,							// LONG  biWidth;
		D_Y_CIF,							// LONG  biHeight;
		1,									// WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
		24,									// WORD  biBitCount;
#else
		0,									// WORD  biBitCount;
#endif
		FOURCC_R261,						// DWORD biCompression;
		CIF_BUFFER_SIZE,					// DWORD biSizeImage;
		0,									// LONG  biXPelsPerMeter;
		0,									// LONG  biYPelsPerMeter;
		0,									// DWORD biClrUsed;
		0,									// DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
		// H.261 specific fields
		CIF_BUFFER_SIZE * 30 * 8 / 100,     // dwMaxBitrate
		0,									// fStillImageTransmission

		// Reserved
		0, 0, 0, 0							// dwReserved[4]
#endif
	}
};

const AM_MEDIA_TYPE AMMT_R261_CIF = 
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,			// majortype
    STATIC_MEDIASUBTYPE_R261,				// subtype
    FALSE,									// bFixedSizeSamples (all samples same size?)
    TRUE,									// bTemporalCompression (uses prediction?)
    0,										// lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
	NULL,									// pUnk
	sizeof (VIH_R261_CIF),			// cbFormat
	(LPBYTE)&VIH_R261_CIF,			// pbFormat
};

// RTP packetized H.261 QCIF size
const TAPI_STREAM_CONFIG_CAPS TSCC_R261_QCIF = 
{
	VideoStreamConfigCaps,						// CapsType
	{
	    L"H.261 QCIF",							// Description
	    AnalogVideo_None,						// VideoStandard
	    D_X_QCIF, D_Y_QCIF,						// InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
	    D_X_QCIF, D_Y_QCIF,						// MinCroppingSize, smallest rcSrc cropping rect allowed
	    D_X_QCIF, D_Y_QCIF,						// MaxCroppingSize, largest  rcSrc cropping rect allowed
	    1,										// CropGranularityX, granularity of cropping size
	    1,										// CropGranularityY
	    1,										// CropAlignX, alignment of cropping rect 
	    1,										// CropAlignY;
	    D_X_QCIF, D_Y_QCIF,						// MinOutputSize, smallest bitmap stream can produce
	    D_X_QCIF, D_Y_QCIF,						// MaxOutputSize, largest  bitmap stream can produce
	    1,										// OutputGranularityX, granularity of output bitmap size
	    1,										// OutputGranularityY;
	    0,										// StretchTapsX
	    0,										// StretchTapsY
	    0,										// ShrinkTapsX
	    0,										// ShrinkTapsY
	    MIN_FRAME_INTERVAL,						// MinFrameInterval, 100 nS units
	    MAX_FRAME_INTERVAL,						// MaxFrameInterval, 100 nS units
	    0,										// MinBitsPerSecond
	    QCIF_BUFFER_SIZE * 30 * 8				// MaxBitsPerSecond;
	}
}; 

const VIDEOINFOHEADER_H261 VIH_R261_QCIF = 
{
    0,0,0,0,								// RECT  rcSource; 
    0,0,0,0,								// RECT  rcTarget; 
    QCIF_BUFFER_SIZE * 30 * 8,				// DWORD dwBitRate;
    0L,										// DWORD dwBitErrorRate; 
    MIN_FRAME_INTERVAL,						// REFERENCE_TIME  AvgTimePerFrame;   

	{
		sizeof (BITMAPINFOHEADER_H261),		// DWORD biSize;
		D_X_QCIF,							// LONG  biWidth;
		D_Y_QCIF,							// LONG  biHeight;
		1,									// WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
		24,									// WORD  biBitCount;
#else
		0,									// WORD  biBitCount;
#endif
		FOURCC_R261,						// DWORD biCompression;
		QCIF_BUFFER_SIZE,					// DWORD biSizeImage;
		0,									// LONG  biXPelsPerMeter;
		0,									// LONG  biYPelsPerMeter;
		0,									// DWORD biClrUsed;
		0,									// DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
		// H.261 specific fields
		QCIF_BUFFER_SIZE * 30 * 8 / 100,	// dwMaxBitrate
		0,									// fStillImageTransmission

		// Reserved
		0, 0, 0, 0							// dwReserved[4]
#endif
	}
};

const AM_MEDIA_TYPE AMMT_R261_QCIF = 
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,			// majortype
    STATIC_MEDIASUBTYPE_R261,				// subtype
    FALSE,									// bFixedSizeSamples (all samples same size?)
    TRUE,									// bTemporalCompression (uses prediction?)
    0,										// lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
	NULL,									// pUnk
	sizeof (VIH_R261_QCIF),			// cbFormat
	(LPBYTE)&VIH_R261_QCIF,			// pbFormat
};

// Array of all formats
const AM_MEDIA_TYPE* const R26XFormats[] = 
{
    (AM_MEDIA_TYPE*) &AMMT_R263_QCIF,
    (AM_MEDIA_TYPE*) &AMMT_R263_CIF,
    (AM_MEDIA_TYPE*) &AMMT_R263_SQCIF,
    (AM_MEDIA_TYPE*) &AMMT_R261_QCIF,
    (AM_MEDIA_TYPE*) &AMMT_R261_CIF
};
const TAPI_STREAM_CONFIG_CAPS* const R26XCaps[] = 
{
	(TAPI_STREAM_CONFIG_CAPS*) &TSCC_R263_QCIF,
	(TAPI_STREAM_CONFIG_CAPS*) &TSCC_R263_CIF,
	(TAPI_STREAM_CONFIG_CAPS*) &TSCC_R263_SQCIF,
	(TAPI_STREAM_CONFIG_CAPS*) &TSCC_R261_QCIF,
	(TAPI_STREAM_CONFIG_CAPS*) &TSCC_R261_CIF
};
DWORD const R26XPayloadTypes [] =
{
	H263_PAYLOAD_TYPE,
	H263_PAYLOAD_TYPE,
	H263_PAYLOAD_TYPE,
	H261_PAYLOAD_TYPE,
	H261_PAYLOAD_TYPE,
};

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | SetFormat | This method is used to
 *    set a specific media type on a pin. It is only implemented by the
 *    output pin of video encoders.
 *
 *  @parm DWORD | dwRTPPayLoadType | Specifies the payload type associated
 *    to the pointer to the <t AM_MEDIA_TYPE> structure passed in.
 *
 *  @parm AM_MEDIA_TYPE* | pMediaType | Specifies a pointer to an
 *    <t AM_MEDIA_TYPE> structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::SetFormat(IN DWORD dwRTPPayLoadType, IN AM_MEDIA_TYPE *pMediaType)
{
	FX_ENTRY("CTAPIInputPin::SetFormat")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));

    // we can handle dynamic format changing.
	return S_OK;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | GetFormat | This method is used to
 *    retrieve the current media type on a pin.
 *
 *  @parm DWORD* | pdwRTPPayLoadType | Specifies the address of a DWORD
 *    to receive the payload type associated to an <t AM_MEDIA_TYPE> structure.
 *
 *  @parm AM_MEDIA_TYPE** | ppMediaType | Specifies the address of a pointer
 *    to an <t AM_MEDIA_TYPE> structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 *
 *  @comm Note that we return the output type, not the format at which
 *    we are capturing. Only the filter really cares about how the data is
 *    being captured.
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::GetFormat(OUT DWORD *pdwRTPPayLoadType, OUT AM_MEDIA_TYPE **ppMediaType)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIInputPin::GetFormat")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pdwRTPPayLoadType);
	ASSERT(ppMediaType);
	if (!pdwRTPPayLoadType || !ppMediaType)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Return a copy of our current format
	*ppMediaType = CreateMediaType(&m_mt);

	// Return the payload type associated to the current format
	*pdwRTPPayLoadType = m_dwRTPPayloadType;

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | GetNumberOfCapabilities | This method is
 *    used to retrieve the number of stream capabilities structures.
 *
 *  @parm DWORD* | pdwCount | Specifies a pointer to a DWORD to receive the
 *    number of <t TAPI_STREAM_CONFIG_CAPS> structures supported.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::GetNumberOfCapabilities(OUT DWORD *pdwCount)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIInputPin::GetNumberOfCapabilities")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pdwCount);
	if (!pdwCount)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Return relevant info
	*pdwCount = NUM_R26X_FORMATS;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Returning %ld formats", _fx_, *pdwCount));

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | GetStreamCaps | This method is
 *    used to retrieve a video stream capability pair.
 *
 *  @parm DWORD | dwIndex | Specifies the index to the desired media type
 *    and capability pair.
 *
 *  @parm AM_MEDIA_TYPE** | ppMediaType | Specifies the address of a pointer
 *    to an <t AM_MEDIA_TYPE> structure.
 *
 *  @parm TAPI_STREAM_CONFIG_CAPS* | pTSCC | Specifies a pointer to a
 *    <t TAPI_STREAM_CONFIG_CAPS> configuration structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::GetStreamCaps(IN DWORD dwIndex, OUT AM_MEDIA_TYPE **ppMediaType, OUT TAPI_STREAM_CONFIG_CAPS *pTSCC, OUT DWORD * pdwRTPPayLoadType)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIInputPin::GetStreamCaps")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(dwIndex < NUM_R26X_FORMATS);
	if (!(dwIndex < NUM_R26X_FORMATS))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid dwIndex argument!", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Return a copy of the requested AM_MEDIA_TYPE structure 
	if (ppMediaType)
    {
	    if (!(*ppMediaType = CreateMediaType(R26XFormats[dwIndex])))
	    {
		    DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory!", _fx_));
		    Hr = E_OUTOFMEMORY;
		    goto MyExit;
	    }
    }

	// Return a copy of the requested VIDEO_STREAM_CONFIG_CAPS structure
	if (pTSCC)
    {
        CopyMemory(pTSCC, R26XCaps[dwIndex], sizeof(TAPI_STREAM_CONFIG_CAPS));
    }

    if (pdwRTPPayLoadType)
    {
        *pdwRTPPayLoadType = R26XPayloadTypes[dwIndex];
    }

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Returning format index %ld: %s %ld bpp %ldx%ld", _fx_, dwIndex, HEADER(R26XFormats[dwIndex]->pbFormat)->biCompression == FOURCC_M263 ? "H.263" : HEADER(R26XFormats[dwIndex]->pbFormat)->biCompression == FOURCC_M261 ? "H.261" : HEADER(R26XFormats[dwIndex]->pbFormat)->biCompression == BI_RGB ? "RGB" : "????", HEADER(R26XFormats[dwIndex]->pbFormat)->biBitCount, HEADER(R26XFormats[dwIndex]->pbFormat)->biWidth, HEADER(R26XFormats[dwIndex]->pbFormat)->biHeight));

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\inpin.cpp ===
/****************************************************************************
 *  @doc INTERNAL INPIN
 *
 *  @module InPin.cpp | Source file for the <c CTAPIInputPin> class methods
 *    used to implement the TAPI base output pin.
 ***************************************************************************/

#include "Precomp.h"

/****************************************************************************
 *  @doc INTERNAL CINPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | CTAPIInputPin | This method is the
 *  constructor for the <c CTAPIInputPin> object
 *
 *  @rdesc Nada.
 ***************************************************************************/
CTAPIInputPin::CTAPIInputPin(IN TCHAR *pObjectName, IN CTAPIVDec *pDecoderFilter, IN CCritSec *pLock, IN HRESULT *pHr, IN LPCWSTR pName) : CBaseInputPin(pObjectName, pDecoderFilter, pLock, pHr, pName)
{
        FX_ENTRY("CTAPIInputPin::CTAPIInputPin")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Initialize stuff
        m_pDecoderFilter = pDecoderFilter;

        // Initialize to default format: H.263 176x144 at 30 fps
        m_mt = *R26XFormats[0];
        m_dwRTPPayloadType = R26XPayloadTypes[0];
        m_iCurrFormat   = 0L;

        // Frame rate control
        // This should not be based on the capabilities of the machine.
        // These members are only used for read-only operations, and we
        // could receive CIF or SQCIF. In the former case, we could be
        // maxed out at 7 fps but still can receive 30fps. So, we should
        // initialize those values to their potential max.
        m_lMaxAvgTimePerFrame = 333333L;
        m_lCurrentAvgTimePerFrame       = LONG_MAX;
        m_lAvgTimePerFrameRangeMin = 333333L;
        m_lAvgTimePerFrameRangeMax = LONG_MAX;
        m_lAvgTimePerFrameRangeSteppingDelta = 333333L;
        m_lAvgTimePerFrameRangeDefault = 333333L;

        // Bitrate control
        m_lTargetBitrate = 0L;
        m_lCurrentBitrate = 0L;
        m_lBitrateRangeMin = 0L;
        m_lBitrateRangeMax = 1000000;
        m_lBitrateRangeSteppingDelta = 1L;
        m_lBitrateRangeDefault = 0L;

        // H.245 video capabilities
        m_pH245MediaCapabilityMap = NULL;
        m_pVideoResourceBounds = NULL;
        m_pFormatResourceBounds = NULL;

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CINPINMETHOD
 *
 *  @mfunc void | CTAPIInputPin | ~CTAPIInputPin | This method is the
 *    destructor of our input pin. We simply release the pointer to the
 *    <i IH245EncoderCommand> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CTAPIInputPin::~CTAPIInputPin()
{
        FX_ENTRY("CTAPIInputPin::~CTAPIInputPin")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CINPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | NonDelegatingQueryInterface | This
 *    method is the nondelegating interface query function. It returns a
 *    pointer to the specified interface if supported. The only interfaces
 *    explicitly supported being <i IOutgoingInterface>,
 *    <i IFrameRateControl> and <i IBitrateControl>.
 *
 *  @parm REFIID | riid | Specifies the identifier of the interface to return.
 *
 *  @parm PVOID* | ppv | Specifies the place in which to put the interface
 *    pointer.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::NonDelegatingQueryInterface(IN REFIID riid, OUT void **ppv)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::NonDelegatingQueryInterface")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(ppv);
        if (!ppv)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Retrieve interface pointer
        if (riid == __uuidof(IStreamConfig))
        {
                if (FAILED(Hr = GetInterface(static_cast<IStreamConfig*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for IStreamConfig failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: IStreamConfig*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
        else if (riid == __uuidof(IOutgoingInterface))
        {
                if (FAILED(Hr = GetInterface(static_cast<IOutgoingInterface*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for IOutgoingInterface failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: IOutgoingInterface*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#ifdef USE_PROPERTY_PAGES
        else if (riid == IID_ISpecifyPropertyPages)
        {
                if (FAILED(Hr = GetInterface(static_cast<ISpecifyPropertyPages*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for ISpecifyPropertyPages failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: ISpecifyPropertyPages*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#endif
        else if (riid == __uuidof(IH245Capability))
        {
                if (FAILED(Hr = GetInterface(static_cast<IH245Capability*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for IH245Capability failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: IH245Capability*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
        else if (riid == __uuidof(IFrameRateControl))
        {
                if (FAILED(Hr = GetInterface(static_cast<IFrameRateControl*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for IFrameRateControl failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: IFrameRateControl*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
        else if (riid == __uuidof(IBitrateControl))
        {
                if (FAILED(Hr = GetInterface(static_cast<IBitrateControl*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for IBitrateControl failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: IBitrateControl*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }

        if (FAILED(Hr = CBaseInputPin::NonDelegatingQueryInterface(riid, ppv)))
        {
                DBGOUT((g_dwVideoDecoderTraceID, WARN, "%s:   WARNING: NDQI for {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX} failed Hr=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], Hr));
        }
        else
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}*=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], *ppv));
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

#ifdef USE_PROPERTY_PAGES
/****************************************************************************
 *  @doc INTERNAL CINPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | GetPages | This method fills a counted
 *    array of GUID values where each GUID specifies the CLSID of each
 *    property page that can be displayed in the property sheet for this
 *    object.
 *
 *  @parm CAUUID* | pPages | Specifies a pointer to a caller-allocated CAUUID
 *    structure that must be initialized and filled before returning. The
 *    pElems field in the CAUUID structure is allocated by the callee with
 *    CoTaskMemAlloc and freed by the caller with CoTaskMemFree.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_OUTOFMEMORY | Allocation failed
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::GetPages(OUT CAUUID *pPages)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::GetPages")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pPages);
        if (!pPages)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        pPages->cElems = 1;
        if (pPages->cElems)
        {
                if (!(pPages->pElems = (GUID *) QzTaskMemAlloc(sizeof(GUID) * pPages->cElems)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                        Hr = E_OUTOFMEMORY;
                }
                else
                {
                        pPages->pElems[0] = __uuidof(TAPIVDecInputPinPropertyPage);
                }
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
#endif

/****************************************************************************
 *  @doc INTERNAL CFPSINCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | Get | This method is used to retrieve
 *    the value of the current or maximum frame rate advertized.
 *
 *  @parm FrameRateControlProperty | Property | Used to specify the frame rate
 *    control setting to get the value of. Use a member of the
 *    <t FrameRateControlProperty> enumerated type.
 *
 *  @parm long* | plValue | Used to receive the value of the property, in
 *    100-nanosecond units.
 *
 *  @parm TAPIControlFlags* | plFlags | Pointer to a member of the
 *     <t TAPIControlFlags> enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::Get(IN FrameRateControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::Get (FrameRateControlProperty)")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(plValue);
        ASSERT(plFlags);
        if (!plValue || !plFlags)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(Property >= FrameRateControl_Maximum && Property <= FrameRateControl_Current);

        // Return relevant values
        *plFlags = TAPIControl_Flags_None;
        if (Property == FrameRateControl_Maximum)
                *plValue = m_lMaxAvgTimePerFrame;
        else if (Property == FrameRateControl_Current)
                *plValue = m_lCurrentAvgTimePerFrame;
        else
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
                Hr = E_PROP_ID_UNSUPPORTED;
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CFPSINCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | GetRange | This method is used to
 *    retrieve support, minimum, maximum, and default values of the current
 *    or maximum frame rate advertized.
 *
 *  @parm FrameRateControlProperty | Property | Used to specify the frame rate
 *    control setting to get the range values of. Use a member of the
 *    <t FrameRateControlProperty> enumerated type.
 *
 *  @parm long* | plMin | Used to retrieve the minimum value of the
 *    property, in 100-nanosecond units.
 *
 *  @parm long* | plMax | Used to retrieve the maximum value of the
 *    property, in 100-nanosecond units.
 *
 *  @parm long* | plSteppingDelta | Used to retrieve the stepping delta
 *    of the property, in 100-nanosecond units.
 *
 *  @parm long* | plDefault | Used to retrieve the default value of the
 *    property, in 100-nanosecond units.
 *
 *  @parm TAPIControlFlags* | plCapsFlags | Pointer to a member of the
 *     <t TAPIControlFlags> enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::GetRange(IN FrameRateControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::GetRange (FrameRateControlProperty)")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(plMin);
        ASSERT(plMax);
        ASSERT(plSteppingDelta);
        ASSERT(plDefault);
        ASSERT(plCapsFlags);
        if (!plMin || !plMax || !plSteppingDelta || !plDefault || !plCapsFlags)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(Property >= FrameRateControl_Maximum && Property <= FrameRateControl_Current);
        if (Property != FrameRateControl_Maximum && Property != FrameRateControl_Current)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
                Hr = E_PROP_ID_UNSUPPORTED;
                goto MyExit;
        }

        // Return relevant values
        *plCapsFlags = TAPIControl_Flags_None;
        *plMin = m_lAvgTimePerFrameRangeMin;
        *plMax = m_lAvgTimePerFrameRangeMax;
        *plSteppingDelta = m_lAvgTimePerFrameRangeSteppingDelta;
        *plDefault = m_lAvgTimePerFrameRangeDefault;

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Ranges: Min=%ld, Max=%ld, Step=%ld, Default=%ld", _fx_, m_lAvgTimePerFrameRangeMin, m_lAvgTimePerFrameRangeMax, m_lAvgTimePerFrameRangeSteppingDelta, m_lAvgTimePerFrameRangeDefault));

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBPSCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | Get | This method is used to retrieve
 *    the current or maximum limit in bandwidth transmission advertized.
 *
 *  @parm BitrateControlProperty | Property | Used to specifiy the property
 *    to retrieve the value of.
 *
 *  @parm long* | plValue | Used to receive the value of the property, in bps.
 *
 *  @parm TAPIControlFlags* | plFlags | Used to receive the value of the flag
 *    associated to the property.
 *
 *  @parm DWORD | dwLayerId | Specifies the ID of the encoding layer the
 *    call applies to. For standard audio and video encoders, this field is
 *    always set to 0. In the case of multi-layered encoders, this field
 *    shall be set to 0 for the base layer, 1 for the first enhancement
 *    layer, 2 for the next enhancement layer, etc
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::Get(IN BitrateControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags, IN DWORD dwLayerId)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::Get (BitrateControlProperty)")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(plValue);
        ASSERT(plFlags);
        if (!plValue || !plFlags)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(dwLayerId == 0);
        if (dwLayerId)
        {
                // We don't support multi-layered decoding in this filter
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }
        ASSERT(Property >= BitrateControl_Maximum && Property <= BitrateControl_Current);

        // Return relevant values
        *plFlags = TAPIControl_Flags_None;
        if (Property == BitrateControl_Maximum)
                *plValue = m_lTargetBitrate;
        else if (Property == BitrateControl_Current)
                *plValue = m_lCurrentBitrate;
        else
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
                Hr = E_PROP_ID_UNSUPPORTED;
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBPSCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | GetRange | This
 *    method is used to retrieve support, minimum, maximum, and default
 *    values for the upper limit in bandwidth transmission the an output pin
 *    may be setup for.
 *
 *  @parm long* | plMin | Used to retrieve the minimum value of the
 *    property, in bps.
 *
 *  @parm long* | plMax | Used to retrieve the maximum value of the
 *    property, in bps.
 *
 *  @parm long* | plSteppingDelta | Used to retrieve the stepping delta
 *    of the property, in bps.
 *
 *  @parm long* | plDefault | Used to retrieve the default value of the
 *    property, in bps.
 *
 *  @parm TAPIControlFlags* | plCapsFlags | Used to receive the flags
 *    suppported by the property.
 *
 *  @parm DWORD | dwLayerId | Specifies the ID of the encoding layer the
 *    call applies to. For standard audio and video encoders, this field is
 *    always set to 0. In the case of multi-layered encoders, this field
 *    shall be set to 0 for the base layer, 1 for the first enhancement
 *    layer, 2 for the next enhancement layer, etc
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::GetRange(IN BitrateControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags, IN DWORD dwLayerId)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::GetRange (BitrateControlProperty)")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(plMin);
        ASSERT(plMax);
        ASSERT(plSteppingDelta);
        ASSERT(plDefault);
        ASSERT(plCapsFlags);
        if (!plMin || !plMax || !plSteppingDelta || !plDefault || !plCapsFlags)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(dwLayerId == 0);
        if (dwLayerId)
        {
                // We don't implement multi-layered encoding in this filter
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }
        ASSERT(Property >= BitrateControl_Maximum && Property <= BitrateControl_Current);
        if (Property != BitrateControl_Maximum && Property != BitrateControl_Current)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
                Hr = E_PROP_ID_UNSUPPORTED;
                goto MyExit;
        }

        // Return relevant values
        *plCapsFlags = TAPIControl_Flags_None;
        *plMin = m_lBitrateRangeMin;
        *plMax = m_lBitrateRangeMax;
        *plSteppingDelta = m_lBitrateRangeSteppingDelta;
        *plDefault = m_lBitrateRangeDefault;

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CINPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | Receive | This method is used to retrieve
 *    the next block of data from the stream and call the transform operations
 *    supported by this filter.
 *
 *  @parm IMediaSample* | pIn | Specifies a pointer to the input
 *    IMediaSample interface.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::Receive(IMediaSample *pIn)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::Receive")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

    CAutoLock Lock(&m_pDecoderFilter->m_csReceive);

        // Validate input parameters
        ASSERT(pIn);
        if (!pIn)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Check all is well with the base class
        if ((Hr = CBaseInputPin::Receive(pIn)) == S_OK)
        {
                Hr = m_pDecoderFilter->Transform(pIn, m_lPrefixSize);
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

STDMETHODIMP CTAPIInputPin::NotifyAllocator(
    IMemAllocator * pAllocator,
    BOOL bReadOnly)
{
    HRESULT hr = CBaseInputPin::NotifyAllocator(pAllocator, bReadOnly);

    if (SUCCEEDED(hr))
    {
        ALLOCATOR_PROPERTIES Property;
        hr = m_pAllocator->GetProperties(&Property);
        
        if (SUCCEEDED(hr))
        {
            m_lPrefixSize = Property.cbPrefix;
        }
    }

    return hr;
}

/****************************************************************************
 *  @doc INTERNAL CINPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | CheckMediaType | This method is used to
 *    verify that the input pin supports the media type.
 *
 *  @parm const CMediaType* | pmtIn | Specifies a pointer to an input
 *    media type object.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIInputPin::CheckMediaType(IN const CMediaType *pmtIn)
{
        HRESULT                 Hr = NOERROR;
        VIDEOINFOHEADER *pVidInfHdr;
        ICOPEN                  icOpen;
        LPINST                  pInstInfo;
        BOOL                    fOpenedDecoder = FALSE;
        ICDECOMPRESSEX  icDecompress = {0};

        FX_ENTRY("CTAPIInputPin::CheckMediaType")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pmtIn);
        if (!pmtIn)
        {
                Hr = E_POINTER;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                goto MyExit;
        }

        // We only support MEDIATYPE_Video type and VIDEOINFOHEADER format type
        if (*pmtIn->Type() != MEDIATYPE_Video || !pmtIn->Format() || *pmtIn->FormatType() != FORMAT_VideoInfo)
        {
                Hr = E_INVALIDARG;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: input not a valid video format", _fx_));
                goto MyExit;
        }

        // We only support H.263, H.261, RTP packetized H.263 and RTP packetized H.261.
        if (HEADER(pmtIn->Format())->biCompression != FOURCC_M263 && HEADER(pmtIn->Format())->biCompression != FOURCC_M261 && HEADER(pmtIn->Format())->biCompression != FOURCC_R263 && HEADER(pmtIn->Format())->biCompression != FOURCC_R261)
        {
                Hr = E_INVALIDARG;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: we only support H.263 and H.261", _fx_));
                goto MyExit;
        }

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input:  biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, HEADER(pmtIn->Format())->biCompression, HEADER(pmtIn->Format())->biBitCount, HEADER(pmtIn->Format())->biWidth, HEADER(pmtIn->Format())->biHeight, HEADER(pmtIn->Format())->biSize));

        pVidInfHdr = (VIDEOINFOHEADER *)pmtIn->Format();

        // Look for a decoder for this format
        if (m_pDecoderFilter->m_FourCCIn != HEADER(pVidInfHdr)->biCompression)
        {
#if DXMRTP <= 0
                // Load TAPIH263.DLL or TAPIH263.DLL and get a proc address
                if (!m_pDecoderFilter->m_hTAPIH26XDLL)
                {
                        if (!(m_pDecoderFilter->m_hTAPIH26XDLL = LoadLibrary(TEXT("TAPIH26X"))))
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s: TAPIH26X.dll load failed!", _fx_));
                                Hr = E_FAIL;
                                goto MyError;
                        }
                }
                if (!m_pDecoderFilter->m_pDriverProc)
                {
                        if (!(m_pDecoderFilter->m_pDriverProc = (LPFNDRIVERPROC)GetProcAddress(m_pDecoderFilter->m_hTAPIH26XDLL, "DriverProc")))
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s: Couldn't find DriverProc on TAPIH26X.dll!", _fx_));
                                Hr = E_FAIL;
                                goto MyError;
                        }
                }
#else
                if (!m_pDecoderFilter->m_pDriverProc)
        {
            m_pDecoderFilter->m_pDriverProc = H26XDriverProc;
        }
#endif
        
                // Load decoder
#if defined(ICM_LOGGING) && defined(DEBUG)
                OutputDebugString("CTAPIInputPin::CheckMediaType - DRV_LOAD\r\n");
#endif
                if (!(*m_pDecoderFilter->m_pDriverProc)(NULL, NULL, DRV_LOAD, 0L, 0L))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Failed to load decoder", _fx_));
                        Hr = E_FAIL;
                        goto MyError;
                }

                // Open decoder
                icOpen.fccHandler = HEADER(pVidInfHdr)->biCompression;
                icOpen.dwFlags = ICMODE_DECOMPRESS;
#if defined(ICM_LOGGING) && defined(DEBUG)
                OutputDebugString("CTAPIInputPin::CheckMediaType - DRV_OPEN\r\n");
#endif
                if (!(pInstInfo = (LPINST)(*m_pDecoderFilter->m_pDriverProc)(NULL, NULL, DRV_OPEN, 0L, (LPARAM)&icOpen)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Failed to open decoder", _fx_));
                        Hr = E_FAIL;
                        goto MyError1;
                }

                if (pInstInfo)
                        fOpenedDecoder = TRUE;
        }
        else
        {
                pInstInfo = m_pDecoderFilter->m_pInstInfo;
        }

        if (!pInstInfo)
        {
                Hr = VFW_E_NO_DECOMPRESSOR;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: can't open a decoder", _fx_));
                goto MyError;
        }

        icDecompress.lpbiSrc = HEADER(pVidInfHdr);
        icDecompress.lpbiDst = NULL;
#if defined(ICM_LOGGING) && defined(DEBUG)
        OutputDebugString("CTAPIInputPin::CheckMediaType - ICM_DECOMPRESSEX_QUERY\r\n");
#endif
        if ((*m_pDecoderFilter->m_pDriverProc)((DWORD)pInstInfo, NULL, ICM_DECOMPRESSEX_QUERY, (long)&icDecompress, NULL))
        {
                Hr = VFW_E_TYPE_NOT_ACCEPTED;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: decoder rejected input format", _fx_));
                if (fOpenedDecoder)
                {
#if defined(ICM_LOGGING) && defined(DEBUG)
                        OutputDebugString("CTAPIInputPin::CheckMediaType - DRV_CLOSE\r\n");
                        OutputDebugString("CTAPIInputPin::CheckMediaType - DRV_FREE\r\n");
#endif
                        (*m_pDecoderFilter->m_pDriverProc)((DWORD)pInstInfo, NULL, DRV_CLOSE, 0L, 0L);
                        (*m_pDecoderFilter->m_pDriverProc)((DWORD)pInstInfo, NULL, DRV_FREE, 0L, 0L);
                }
                goto MyExit;
        }

        // Remember this decoder to save time if asked again, if it won't interfere with an existing connection.
        // If a connection is broken, we will remember the next decoder.
        if (!IsConnected())
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: caching this decoder", _fx_));
                if (fOpenedDecoder && m_pDecoderFilter->m_pInstInfo)
                {
#if defined(ICM_LOGGING) && defined(DEBUG)
                        OutputDebugString("CTAPIInputPin::CheckMediaType - DRV_CLOSE\r\n");
                        OutputDebugString("CTAPIInputPin::CheckMediaType - DRV_FREE\r\n");
#endif
                        (*m_pDecoderFilter->m_pDriverProc)((DWORD)m_pDecoderFilter->m_pInstInfo, NULL, DRV_CLOSE, 0L, 0L);
                        (*m_pDecoderFilter->m_pDriverProc)((DWORD)m_pDecoderFilter->m_pInstInfo, NULL, DRV_FREE, 0L, 0L);
                }
                m_pDecoderFilter->m_pInstInfo = pInstInfo;
                m_pDecoderFilter->m_FourCCIn = HEADER(pVidInfHdr)->biCompression;
        }
        else if (fOpenedDecoder)
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: not caching decoder - we're connected", _fx_));
                if (fOpenedDecoder && pInstInfo)
                {
#if defined(ICM_LOGGING) && defined(DEBUG)
                        OutputDebugString("CTAPIInputPin::CheckMediaType - DRV_CLOSE\r\n");
                        OutputDebugString("CTAPIInputPin::CheckMediaType - DRV_FREE\r\n");
#endif
                        (*m_pDecoderFilter->m_pDriverProc)((DWORD)pInstInfo, NULL, DRV_CLOSE, 0L, 0L);
                        (*m_pDecoderFilter->m_pDriverProc)((DWORD)pInstInfo, NULL, DRV_FREE, 0L, 0L);
                }
        }

        goto MyExit;

MyError1:
        if (m_pDecoderFilter->m_pDriverProc)
        {
#if defined(ICM_LOGGING) && defined(DEBUG)
                OutputDebugString("CTAPIInputPin::CheckMediaType - DRV_FREE\r\n");
#endif
                (*m_pDecoderFilter->m_pDriverProc)(NULL, NULL, DRV_FREE, 0L, 0L);
        }
MyError:
        m_pDecoderFilter->m_pDriverProc = NULL;
#if DXMRTP <= 0
        if (m_pDecoderFilter->m_hTAPIH26XDLL)
                FreeLibrary(m_pDecoderFilter->m_hTAPIH26XDLL), m_pDecoderFilter->m_hTAPIH26XDLL = NULL;
#endif
MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CINPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | SetMediaType | This method is called when
 *    the media type is established for the connection.
 *
 *  @parm const CMediaType* | pmt | Specifies a pointer to a media type
 *    object.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 *
 *  @todo Is this the method that I should call when I detect that the
 *    input format data has changed in-band? But I would be streaming at
 *    this point...
 ***************************************************************************/
HRESULT CTAPIInputPin::SetMediaType(IN const CMediaType *pmt)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::SetMediaType")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameter
        ASSERT(pmt);
        if (!pmt)
        {
                Hr = E_POINTER;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: null pointer argument", _fx_));
                goto MyExit;
        }

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input: biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, HEADER(m_mt.pbFormat)->biCompression, HEADER(m_mt.pbFormat)->biBitCount, HEADER(m_mt.pbFormat)->biWidth, HEADER(m_mt.pbFormat)->biHeight, HEADER(m_mt.pbFormat)->biSize));

        // We better have one of these opened by now
        ASSERT(m_pDecoderFilter->m_pInstInfo);

    Hr = CBaseInputPin::SetMediaType(pmt);

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\inpin.h ===
/****************************************************************************
 *  @doc INTERNAL INPIN
 *
 *  @module InPin.h | Header file for the <c CTAPIInputPin> class methods
 *    used to implement the TAPI base input pin.
 ***************************************************************************/

#ifndef _INPIN_H_
#define _INPIN_H_

#define MAX_FRAME_INTERVAL 10000000L
#define MIN_FRAME_INTERVAL 333333L

/****************************************************************************
 *  @doc INTERNAL CINPINCLASS
 *
 *  @class CTAPIInputPin | This class implements the TAPI H.26X Video
 *    Decoder input pin.
 *
 *  @mdata CTAPIVCap* | CTAPIInputPin | m_pDecoderFilter | Pointer to the
 *    filter that owns us.
 *
 *  @mdata REFERENCE_TIME | CTAPIInputPin | m_AvgTimePerFrameRangeMin | Minimum
 *    target frame rate.
 *
 *  @mdata REFERENCE_TIME | CTAPIInputPin | m_AvgTimePerFrameRangeMax | Maximum
 *    target frame rate.
 *
 *  @mdata REFERENCE_TIME | CTAPIInputPin | m_AvgTimePerFrameRangeSteppingDelta | Target
 *    frame rate stepping delta.
 *
 *  @mdata REFERENCE_TIME | CTAPIInputPin | m_AvgTimePerFrameRangeDefault | Target
 *    frame rate default.
 *
 *  @mdata REFERENCE_TIME | CTAPIInputPin | m_CurrentAvgTimePerFrame | Current
 *    frame rate.
 *
 *  @mdata DWORD | CTAPIInputPin | m_dwBitrateRangeMin | Minimum target bitrate.
 *
 *  @mdata DWORD | CTAPIInputPin | m_dwBitrateRangeMax | Maximum target bitrate.
 *
 *  @mdata DWORD | CTAPIInputPin | m_dwBitrateRangeSteppingDelta | Target
 *    bitrate stepping delta.
 *
 *  @mdata DWORD | CTAPIInputPin | m_dwBitrateRangeDefault | Default target bitrate.
 *
 *  @mdata DWORD | CTAPIInputPin | m_dwMaxBitrate | Target bitrate.
 *
 *  @mdata DWORD | CTAPIInputPin | m_dwCurrentBitrate | Current bitrate.
 *
 *  @mdata DWORD | CTAPIInputPin | m_dwNumBytesDelivered | Counts number of
 *    bytes delivered, reset every second or so.
 ***************************************************************************/
class CTAPIInputPin : public CBaseInputPin, public IStreamConfig, public IH245Capability, public IOutgoingInterface, public IFrameRateControl, public IBitrateControl
#ifdef USE_PROPERTY_PAGES
,public ISpecifyPropertyPages
#endif
{
        public:
        DECLARE_IUNKNOWN
        STDMETHODIMP NonDelegatingQueryInterface(IN REFIID riid, OUT PVOID *ppv);
        CTAPIInputPin(IN TCHAR *pObjectName, IN CTAPIVDec *pDecoderFilter, IN CCritSec *pLock, IN HRESULT *pHr, IN LPCWSTR pName);
        ~CTAPIInputPin();

        // override CBaseInputPin methods.
        STDMETHODIMP ReceiveCanBlock() {return S_FALSE;};
        STDMETHODIMP Receive(IMediaSample *pSample);
    STDMETHODIMP NotifyAllocator(
                    IMemAllocator * pAllocator,
                    BOOL bReadOnly);

        // CBasePin stuff
        HRESULT GetMediaType(IN int iPosition, IN CMediaType *pmtIn) {return VFW_S_NO_MORE_ITEMS;};
        HRESULT CheckMediaType(IN const CMediaType *pmtIn);
        HRESULT SetMediaType(IN const CMediaType *pmt);

        // Implement IStreamConfig
        STDMETHODIMP SetFormat(IN DWORD dwRTPPayLoadType, IN AM_MEDIA_TYPE *pMediaType);
        STDMETHODIMP GetFormat(OUT DWORD *pdwRTPPayLoadType, OUT AM_MEDIA_TYPE **ppMediaType);
        STDMETHODIMP GetNumberOfCapabilities(OUT DWORD *pdwCount);
        STDMETHODIMP GetStreamCaps(IN DWORD dwIndex, OUT AM_MEDIA_TYPE **ppMediaType, OUT TAPI_STREAM_CONFIG_CAPS *pTSCC, OUT DWORD * pdwRTPPayLoadType);

#ifdef USE_PROPERTY_PAGES
        // ISpecifyPropertyPages methods
        STDMETHODIMP GetPages(OUT CAUUID *pPages);
#endif

        // Implement IH245Capability
        STDMETHODIMP GetH245VersionID(OUT DWORD *pdwVersionID);
        STDMETHODIMP GetFormatTable(OUT H245MediaCapabilityTable *pTable);
        STDMETHODIMP ReleaseFormatTable(IN H245MediaCapabilityTable *pTable);
        STDMETHODIMP IntersectFormats(
        IN DWORD dwUniqueID, 
        IN const H245MediaCapability *pLocalCapability, 
        IN const H245MediaCapability *pRemoteCapability, 
        OUT H245MediaCapability **ppIntersectedCapability,
        OUT DWORD *pdwPayloadType
        );
        STDMETHODIMP Refine(IN OUT H245MediaCapability *pLocalCapability, IN DWORD dwUniqueID, IN DWORD dwResourceBoundIndex);
        STDMETHODIMP GetLocalFormat(IN DWORD dwUniqueID, IN const H245MediaCapability *pIntersectedCapability, OUT AM_MEDIA_TYPE **ppAMMediaType);
        STDMETHODIMP ReleaseNegotiatedCapability(IN H245MediaCapability *pIntersectedCapability);
        STDMETHODIMP FindIDByRange(IN const AM_MEDIA_TYPE *pAMMediaType, OUT DWORD *pdwID);
#if 0
        STDMETHODIMP TestH245VidC();
#endif

        // Implement IFrameRateControl
        STDMETHODIMP GetRange(IN FrameRateControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags);
        STDMETHODIMP Set(IN FrameRateControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags) { return E_NOTIMPL;};
        STDMETHODIMP Get(IN FrameRateControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags);

        // Implement IBitrateControl
        STDMETHODIMP GetRange(IN BitrateControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags, IN DWORD dwLayerId);
        STDMETHODIMP Set(IN BitrateControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags, IN DWORD dwLayerId) { return E_NOTIMPL;};
        STDMETHODIMP Get(IN BitrateControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags, IN DWORD dwLayerId);

        // Implement IOutgoingInterface
        STDMETHODIMP Set(IN IH245EncoderCommand *pIH245EncoderCommand);

        protected:

        friend class CTAPIVDec;
        friend class CTAPIOutputPin;

        CTAPIVDec *m_pDecoderFilter;

        // Formats
        int             m_iCurrFormat;
        DWORD   m_dwRTPPayloadType;
    LONG    m_lPrefixSize;

        // Frame rate control
        LONG m_lAvgTimePerFrameRangeMin;
        LONG m_lAvgTimePerFrameRangeMax;
        LONG m_lAvgTimePerFrameRangeSteppingDelta;
        LONG m_lAvgTimePerFrameRangeDefault;
        LONG m_lMaxAvgTimePerFrame;
        LONG m_lCurrentAvgTimePerFrame;

        // Bitrate control
        LONG m_lBitrateRangeMin;
        LONG m_lBitrateRangeMax;
        LONG m_lBitrateRangeSteppingDelta;
        LONG m_lBitrateRangeDefault;
        LONG m_lTargetBitrate;
        LONG m_lCurrentBitrate;

        // H.245 Video Capabilities
        H245MediaCapabilityMap  *m_pH245MediaCapabilityMap;
        VideoResourceBounds             *m_pVideoResourceBounds;
        FormatResourceBounds    *m_pFormatResourceBounds;
};

#endif // _INPIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\h245comm.cpp ===
/****************************************************************************
 *  @doc INTERNAL H245COMM
 *
 *  @module H245Comm.cpp | Source file for the <c CTAPIInputPin>  and
 *    <c CTAPIVDec> class methods used to implement the video decoder input
 *    pin remote H.245 encoder command methods, and <c CTAPIOutputPin> H.245
 *    decoder command method.
 *
 *  @comm Our decoder only issues video fast-update picture commands.
 ***************************************************************************/

#include "Precomp.h"

/****************************************************************************
 *  @doc INTERNAL CH245COMMMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | videoFastUpdatePicture | This
 *    method is used to specify to the remote encoder to enter
 *    the fast-update picture mode at its earliest opportunity.
 *
 *  @rdesc This method returns NOERROR.
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::videoFastUpdatePicture()
{
	FX_ENTRY("CTAPIVDec::videoFastUpdatePicture")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Ask the channel controller to issue an I-frame request 
	if (m_pIH245EncoderCommand)
		m_pIH245EncoderCommand->videoFastUpdatePicture();

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CH245COMMMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | Set | This method is used by the incoming
 *    video stream to provide a pointer to the <i IH245EncoderCommand>
 *    interface supported by the associated channel controller.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::Set(IN IH245EncoderCommand *pIH245EncoderCommand)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIInputPin::videoFastUpdateGOB")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pIH245EncoderCommand);
	if (!pIH245EncoderCommand)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Remember the interface pointer 
	m_pDecoderFilter->m_pIH245EncoderCommand = pIH245EncoderCommand;

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245COMMMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | videoFreezePicture | This
 *    method is used to specify to the decoder to complete updating the
 *    current video frame and subsequently display the frozen picture until
 *    receipt of the appropriate freeze-picture release control signal.
 *
 *  @rdesc This method returns NOERROR.
 ***************************************************************************/
STDMETHODIMP CTAPIOutputPin::videoFreezePicture()
{
	FX_ENTRY("CTAPIOutputPin::videoFreezePicture")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Freeze the video decoding 
	m_pDecoderFilter->m_fFreezePicture = TRUE;
	m_pDecoderFilter->m_dwFreezePictureStartTime = timeGetTime();

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\h245vidc.cpp ===
/****************************************************************************
 *  @doc INTERNAL H245VIDC
 *
 *  @module H245VidC.cpp | Source file for the <c CTAPIInputPin> class methods
 *    used to implement the <i IH245Capability> TAPI inteface.
 *
 *  @comm For now, use the NM heuristics.
 ***************************************************************************/

#include "Precomp.h"

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | GetH245VersionID | This method is used to
 *    retrieve a DWORD value that identifies the platform version that the
 *    TAPI MSP Video Capture filter was designed for. The platform version is
 *    defined as TAPI_H245_VERSION_ID.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::GetH245VersionID(OUT DWORD *pdwVersionID)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::GetH245VersionID")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameter
        ASSERT(pdwVersionID);
        if (!pdwVersionID)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument!", _fx_));
                Hr = E_POINTER;
        }
        else
        {
                *pdwVersionID = TAPI_H245_VERSION_ID;
                Hr = NOERROR;
        }

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | GetFormatTable | This method is used to
 *    obtain <t H245MediaCapabilityMap> structures for all formats and format
 *    options that the TAPI MSP Video Decoder filter supports. The content of
 *    the capability information that the TAPI MSP Capability module obtains
 *    via this method is a two dimensional table that relates every supported
 *    receive format to steady-state resource requirements of that format.
 *
 *  @parm H245MediaCapabilityTable* | pTable | Specifies a pointer to an
 *    <t H245MediaCapabilityTable> structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 *
 *  @comm The memory allocated by <mf CTAPIInputPin.GetFormatTable> is released
 *    by calling <mf CTAPIInputPin.ReleaseFormatTable>
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::GetFormatTable(OUT H245MediaCapabilityTable *pTable)
{
        HRESULT                                 Hr = NOERROR;
        int                                             nNormalizedSpeed;
        LONG                                    lRate, lRateCIF, lRateQCIF, lRateSQCIF;
        DWORD                                   dwNumQCIFBounds, dwNumCIFBounds, dwNumSQCIFBounds;
        DWORD                                   dwCPUUsage;
        DWORD                                   dwBitsPerSec;

        FX_ENTRY("CTAPIInputPin::GetFormatTable")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pTable);
        if (!pTable)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // We support H.261 QCIF and CIF, as well as H.263 SQCIF, QCIF, and CIF

        // Allocate memory to describe the capabilities of these formats
        if (!(m_pH245MediaCapabilityMap = new H245MediaCapabilityMap[NUM_H245VIDEOCAPABILITYMAPS]))
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Initialize the array of capabilities
        ZeroMemory(m_pH245MediaCapabilityMap, NUM_H245VIDEOCAPABILITYMAPS * sizeof(H245MediaCapabilityMap));

        // Allocate memory to describe the resource bounds of our capabilities
        if (!(m_pVideoResourceBounds = new VideoResourceBounds[NUM_ITU_SIZES * NUM_RATES_PER_RESOURCE]))
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_POINTER;
                goto MyError1;
        }

        // Initialize the array of resource bounds
        ZeroMemory(m_pVideoResourceBounds, NUM_ITU_SIZES * NUM_RATES_PER_RESOURCE * sizeof(FormatResourceBounds));

        // Allocate memory to describe the format bounds of our capabilities
        if (!(m_pFormatResourceBounds = new FormatResourceBounds[NUM_ITU_SIZES * NUM_RATES_PER_RESOURCE]))
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_POINTER;
                goto MyError2;
        }

        // Initialize the array of resource bounds
        ZeroMemory(m_pFormatResourceBounds, NUM_ITU_SIZES * NUM_RATES_PER_RESOURCE * sizeof(FormatResourceBounds));

        // Get the CPU properties
        GetNormalizedCPUSpeed(&nNormalizedSpeed);

        // Initialize frame rate limits
        if (nNormalizedSpeed > SLOW_CPU_MHZ && nNormalizedSpeed < FAST_CPU_MHZ)
        {
                // 110MHz < CPUs < 200MhZ
                lRateCIF   = CIF_RATE_SLOW;
                lRateQCIF  = QCIF_RATE_SLOW;
                lRateSQCIF = SQCIF_RATE_SLOW;
        }
        else if (nNormalizedSpeed >= FAST_CPU_MHZ && nNormalizedSpeed < VERYFAST_CPU_MHZ)
        {
                // 200MHz < CPUs < 400MhZ
                lRateCIF   = CIF_RATE_FAST;
                lRateQCIF  = QCIF_RATE_FAST;
                lRateSQCIF = SQCIF_RATE_FAST;
        }
        else if (nNormalizedSpeed >= VERYFAST_CPU_MHZ)
        {
                // CPUs > 400MhZ
                // It would be better if we could scale between 15 and 30 frames/sec
                // depending on the CPU speed. But H.245 doesn't have any values
                // between 15 and 30. (See definition of Minimum Picture Interval)
                // So for now, 30 frames per sec CIF for all 400mhz and faster machines
                lRateCIF = CIF_RATE_VERYFAST;
                lRateQCIF = QCIF_RATE_FAST;
                lRateSQCIF = SQCIF_RATE_FAST;
        }
        else
        {
                // CPUs < 110MHZ
                lRateCIF   = CIF_RATE_VERYSLOW;
                lRateQCIF  = QCIF_RATE_VERYSLOW;
                lRateSQCIF = SQCIF_RATE_VERYSLOW;
        }

        //it was #define HUNDREDSBITSPERPIC 640
        //#define BITSPERPIC (64*1024)
        #define BITSPERPIC (8*1024)
        // Compute resources bounds
        for (lRate = lRateQCIF, dwNumQCIFBounds = 0, dwCPUUsage = MAX_CPU_USAGE; lRate; lRate >>= 1, dwCPUUsage >>= 1)
        {
                dwBitsPerSec = lRate * BITSPERPIC;
                if(dwBitsPerSec < (DWORD)m_lBitrateRangeMin || dwBitsPerSec > (DWORD)m_lBitrateRangeMax ) {
                //if(dwBitsPerSec > (DWORD)m_lTargetBitrate) {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   QCIF: At lRate=%ld, dwBitsPerSec(%lu) > m_lTargetBitrate(%ld). Skipped...", _fx_,lRate,dwBitsPerSec,m_lTargetBitrate));
                        continue;
                }
                m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumQCIFBounds].dwBitsPerPicture = BITSPERPIC;
                m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumQCIFBounds].lPicturesPerSecond = lRate;
                m_pFormatResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumQCIFBounds].dwCPUUtilization = dwCPUUsage;
                m_pFormatResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumQCIFBounds].dwBitsPerSecond = dwBitsPerSec;
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   QCIF: lRate=%ld, dwBitsPerSec(%lu) [%lu]", _fx_,lRate,dwBitsPerSec,dwNumQCIFBounds));
                dwNumQCIFBounds++;
        }
        for (lRate = lRateCIF, dwNumCIFBounds = 0, dwCPUUsage = MAX_CPU_USAGE; lRate; lRate >>= 1, dwCPUUsage >>= 1)
        {
                dwBitsPerSec = lRate * BITSPERPIC;
                if(dwBitsPerSec < (DWORD)m_lBitrateRangeMin || dwBitsPerSec > (DWORD)m_lBitrateRangeMax ) {
                //if(dwBitsPerSec > (DWORD)m_lTargetBitrate) {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:    CIF: At lRate=%ld, dwBitsPerSec(%lu) > m_lTargetBitrate(%ld). Skipped...", _fx_,lRate,dwBitsPerSec,m_lTargetBitrate));
                        continue;
                }
                m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumCIFBounds].dwBitsPerPicture = BITSPERPIC;
                m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumCIFBounds].lPicturesPerSecond = lRate;
                m_pFormatResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumCIFBounds].dwCPUUtilization = dwCPUUsage;
                m_pFormatResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumCIFBounds].dwBitsPerSecond = dwBitsPerSec;
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:    CIF: lRate=%ld, dwBitsPerSec(%lu) [%lu]", _fx_,lRate,dwBitsPerSec,dwNumCIFBounds));
                dwNumCIFBounds++;
        }
        for (lRate = lRateSQCIF, dwNumSQCIFBounds = 0, dwCPUUsage = MAX_CPU_USAGE; lRate; lRate >>= 1, dwCPUUsage >>= 1)
        {
                dwBitsPerSec = lRate * BITSPERPIC;
                if(dwBitsPerSec < (DWORD)m_lBitrateRangeMin || dwBitsPerSec > (DWORD)m_lBitrateRangeMax ) {
                //if(dwBitsPerSec > (DWORD)m_lTargetBitrate) {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:  SQCIF: At lRate=%ld, dwBitsPerSec(%lu) > m_lTargetBitrate(%ld). Skipped...", _fx_,lRate,dwBitsPerSec,m_lTargetBitrate));
                        continue;
                }
                m_pVideoResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumSQCIFBounds].dwBitsPerPicture = BITSPERPIC;
                m_pVideoResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumSQCIFBounds].lPicturesPerSecond = lRate;
                m_pFormatResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumSQCIFBounds].dwCPUUtilization = dwCPUUsage;
                m_pFormatResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumSQCIFBounds].dwBitsPerSecond = dwBitsPerSec;
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:  SQCIF: lRate=%ld, dwBitsPerSec(%lu) [%lu]", _fx_,lRate,dwBitsPerSec,dwNumSQCIFBounds));
                dwNumSQCIFBounds++;
        }

        // Initialise H.263 QCIF H245MediaCapabilityMap
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].dwUniqueID = R263_QCIF_H245_CAPID;
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].filterGuid = __uuidof(TAPIVideoDecoder);
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].uNumEntries = dwNumQCIFBounds;
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].pResourceBoundArray = &m_pFormatResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE];
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].h245MediaCapability.media_type = H245MediaType_Video;
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.choice = h263VideoCapability_chosen;
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.bit_mask = H263VideoCapability_qcifMPI_present;
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.qcifMPI = (WORD)(30 / lRateQCIF);
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.maxBitRate =
        min((WORD)(8192 * 8 * lRateQCIF / 100), MAX_BITRATE_H263); // The max frame size we can decode is 8192 bytes
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.bppMaxKb = 64; // The max frame size we can decode is 8192 = 64 * 1024 bytes

        // Initialise H.263 CIF H245MediaCapabilityMap
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].dwUniqueID = R263_CIF_H245_CAPID;
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].filterGuid = __uuidof(TAPIVideoDecoder);
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].uNumEntries = dwNumCIFBounds;
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].pResourceBoundArray = &m_pFormatResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE];
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].h245MediaCapability.media_type = H245MediaType_Video;
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.choice = h263VideoCapability_chosen;
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.bit_mask = H263VideoCapability_cifMPI_present;
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.cifMPI = (WORD)(30 / lRateCIF);
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.maxBitRate =
        min((WORD)(32768 * 8 * lRateCIF / 100), MAX_BITRATE_H263); // The max frame size we can decode is 32768 bytes
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.bppMaxKb = 256; // The max frame size we can decode is 32768 = 256 * 1024 bytes

        // Initialise H.263 SQCIF H245MediaCapabilityMap
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].dwUniqueID = R263_SQCIF_H245_CAPID;
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].filterGuid = __uuidof(TAPIVideoDecoder);
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].uNumEntries = dwNumSQCIFBounds;
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].pResourceBoundArray = &m_pFormatResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE];
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].h245MediaCapability.media_type = H245MediaType_Video;
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].h245MediaCapability.capability.video_cap.choice = h263VideoCapability_chosen;
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.bit_mask = H263VideoCapability_sqcifMPI_present;
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.sqcifMPI = (WORD)(30 / lRateSQCIF);
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.maxBitRate =
        min((WORD)(32768 * 8 * lRateSQCIF / 100), MAX_BITRATE_H263); // The max frame size we can decode is 32768 bytes
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.bppMaxKb = 64; // The max frame size we can decode is 8192 = 64 * 1024 bytes

        // Initialise H.261 QCIF H245MediaCapabilityMap
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].dwUniqueID = R261_QCIF_H245_CAPID;
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].filterGuid = __uuidof(TAPIVideoDecoder);
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].uNumEntries = dwNumQCIFBounds;
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].pResourceBoundArray = &m_pFormatResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE];
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].h245MediaCapability.media_type = H245MediaType_Video;
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.choice = h261VideoCapability_chosen;
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h261VideoCapability.bit_mask = H261VideoCapability_qcifMPI_present;
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h261VideoCapability.qcifMPI = (WORD)(30 / lRateQCIF);
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h261VideoCapability.maxBitRate =
        min((WORD)(8192 * 8 * lRateQCIF / 100), MAX_BITRATE_H261); // The max frame size we can decode is 8192 bytes

        // Initialise H.261 CIF H245MediaCapabilityMap
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].dwUniqueID = R261_CIF_H245_CAPID;
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].filterGuid = __uuidof(TAPIVideoDecoder);
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].uNumEntries = dwNumCIFBounds;
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].pResourceBoundArray = &m_pFormatResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE];
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].h245MediaCapability.media_type = H245MediaType_Video;
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.choice = h261VideoCapability_chosen;
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h261VideoCapability.bit_mask = H261VideoCapability_cifMPI_present;
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h261VideoCapability.cifMPI = (WORD)(30 / lRateCIF);
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h261VideoCapability.maxBitRate =
        min((WORD)(32768 * 8 * lRateCIF / 100), MAX_BITRATE_H261); // The max frame size we can decode is 32768 bytes

        // Return our H245MediaCapabilityTable
        pTable->uMappedCapabilities = NUM_H245VIDEOCAPABILITYMAPS;
        pTable->pCapabilityArray = m_pH245MediaCapabilityMap;

        goto MyExit;

MyError2:
        if (m_pVideoResourceBounds)
                delete[] m_pVideoResourceBounds, m_pVideoResourceBounds = NULL;
MyError1:
        if (m_pH245MediaCapabilityMap)
                delete[] m_pH245MediaCapabilityMap, m_pH245MediaCapabilityMap = NULL;
MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | ReleaseFormatTable | This method is used to
 *    to release memory allocated by the <mf CTAPIInputPin.GetFormatTable> method.
 *
 *  @parm H245MediaCapabilityTable* | pTable | Specifies a pointer to an
 *    <t H245MediaCapabilityTable> structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 *
 *  @xref <mf CTAPIInputPin.GetFormatTable>
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::ReleaseFormatTable(IN H245MediaCapabilityTable *pTable)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::ReleaseFormatTable")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters - if it is our table, it should have NUM_H245VIDEOCAPABILITYMAPS entries
        ASSERT(pTable);
        if (!pTable || !pTable->pCapabilityArray)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(pTable->uMappedCapabilities == NUM_H245VIDEOCAPABILITYMAPS && pTable->pCapabilityArray == m_pH245MediaCapabilityMap);
        if (pTable->uMappedCapabilities != NUM_H245VIDEOCAPABILITYMAPS || pTable->pCapabilityArray != m_pH245MediaCapabilityMap)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Release the table of H245MediaCapabilityMap structures
        if (m_pH245MediaCapabilityMap)
                delete[] m_pH245MediaCapabilityMap, m_pH245MediaCapabilityMap = NULL;
        if (m_pVideoResourceBounds)
                delete[] m_pVideoResourceBounds, m_pVideoResourceBounds = NULL;
        if (m_pFormatResourceBounds)
                delete[] m_pFormatResourceBounds, m_pFormatResourceBounds = NULL;

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | Refine | This method is used to
 *    refine the content of an <t H245MediaCapability> structure based on the
 *    CPU and bandwidth limitations passed in.
 *
 *  @parm H245MediaCapability* | pLocalCapability | Specifies the H.245 video
 *    format, including all parameters and options defined by H.245, of a
 *    local video capability.
 *
 *  @parm DWORD | dwUniqueID | Specifies the unique ID of the local capability
 *    structure passed in.
 *
 *  @parm DWORD | dwResourceBoundIndex | Specifies the resource limitations to
 *    be applied on the local capability structure passed in.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_FAIL | Unsupported format
 *  @flag NOERROR | No error
 *
 *  @xref <mf CTAPIInputPin.GetNegotiatedLimitProperty>
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::Refine(IN OUT H245MediaCapability *pLocalCapability, IN DWORD dwUniqueID, IN DWORD dwResourceBoundIndex)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::Refine")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pLocalCapability);
        if (!pLocalCapability)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(pLocalCapability->media_type == H245MediaType_Video);
        if (pLocalCapability->media_type != H245MediaType_Video)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Update the relevant fields
        ASSERT(dwUniqueID <= R261_CIF_H245_CAPID);
        switch (dwUniqueID)
        {
                case R263_QCIF_H245_CAPID:
                        ASSERT(dwResourceBoundIndex < m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].uNumEntries);
                        if (m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond)
                        {
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.qcifMPI = (WORD)(30 / m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond);
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate = (WORD)(8192 * 8 * m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond / 100); // The max frame size we can decode is 8192 bytes
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate = min(pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate, MAX_BITRATE_H263);
                pLocalCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb = 64; // The max frame size we can decode is 8192 = 64 * 1024 bytes
                        }
                        else
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                                Hr = E_INVALIDARG;
                        }
                        break;
                case R263_CIF_H245_CAPID:
                        ASSERT(dwResourceBoundIndex < m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].uNumEntries);
                        if (m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond)
                        {
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.cifMPI = (WORD)(30 / m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond);
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate = (WORD)(32768 * 8 * m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond / 100); // The max frame size we can decode is 32768 bytes
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate = min(pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate, MAX_BITRATE_H263);
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb = 256; // The max frame size we can decode is 32768 = 256 * 1024 bytes
                        }
                        else
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                                Hr = E_INVALIDARG;
                        }
                        break;
                case R263_SQCIF_H245_CAPID:
                        ASSERT(dwResourceBoundIndex < m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].uNumEntries);
                        if (m_pVideoResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond)
                        {
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.sqcifMPI = (WORD)(30 / m_pVideoResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond);
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate = (WORD)(8192 * 8 * m_pVideoResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond / 100); // The max frame size we can decode is 8192 bytes
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate = min(pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate, MAX_BITRATE_H263);
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb = 64; // The max frame size we can decode is 8192 = 64 * 1024 bytes
                        }
                        else
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                                Hr = E_INVALIDARG;
                        }
                        break;
                case R261_QCIF_H245_CAPID:
                        ASSERT(dwResourceBoundIndex < m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].uNumEntries);
                        if (m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond)
                        {
                                pLocalCapability->capability.video_cap.u.h261VideoCapability.qcifMPI = (WORD)(30 / m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond);
                                pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate = (WORD)(8192 * 8 * m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond / 100); // The max frame size we can decode is 8192 bytes
                                pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate = min(pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate, MAX_BITRATE_H261);
                        }
                        else
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                                Hr = E_INVALIDARG;
                        }
                        break;
                case R261_CIF_H245_CAPID:
                        ASSERT(dwResourceBoundIndex < m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].uNumEntries);
                        if (m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond)
                        {
                                pLocalCapability->capability.video_cap.u.h261VideoCapability.cifMPI = (WORD)(30 / m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond);
                                pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate = (WORD)(32768 * 8 * m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond / 100); // The max frame size we can decode is 32768 bytes
                                pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate = min(pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate, MAX_BITRATE_H261);
                        }
                        else
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                                Hr = E_INVALIDARG;
                        }
                        break;
                default:
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                        Hr = E_INVALIDARG;
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | IntersectFormats | This method is used to
 *    compare and intersect one local capability and one remote capability
 *    and to obtain configuration parameters.
 *
 *  @parm DWORD | dwUniqueID | Specifies the unique idea for the local H.245
 *    video capability passed in.
 *
 *  @parm H245MediaCapability* | pLocalCapability | Specifies the H.245 video
 *    format, including all parameters and options defined by H.245, of a
 *    local video capability.
 *
 *  @parm H245MediaCapability* | pRemoteCapability | Specifies the H.245
 *    video format, including all parameters and options defined by H.245, of
 *    a remote video capability.
 *
 *  @parm H245MediaCapability* | pIntersectedCapability | Specifies the H.245
 *    video format, of the resolved common local and remote capability
 *    options and limits.
 *
 *  @parm DWORD* | pdwPayloadType | Specifies RTP payload type to be used.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_FAIL | Unsupported format
 *  @flag NOERROR | No error
 *
 *  @xref <mf CTAPIInputPin.GetNegotiatedLimitProperty>
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::IntersectFormats(
    IN DWORD dwUniqueID,
    IN const H245MediaCapability *pLocalCapability,
    IN const H245MediaCapability *pRemoteCapability,
    OUT H245MediaCapability **ppIntersectedCapability,
    OUT  DWORD *pdwPayloadType
    )
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::IntersectFormats")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pLocalCapability);
    ASSERT(pdwPayloadType);

        if (!pLocalCapability || !pdwPayloadType)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                return E_POINTER;
        }

    *pdwPayloadType = R26XPayloadTypes[dwUniqueID];

    // initialize intersected cap
    if (ppIntersectedCapability) *ppIntersectedCapability = NULL;

    if (pRemoteCapability == NULL)
    {
        // if this is NULL, the caller just want a copy of the local caps.

        // Allocate memory to describe the capabilities of these formats
            if (!(*ppIntersectedCapability = new H245MediaCapability))
            {
                    DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                    Hr = E_OUTOFMEMORY;
                    goto MyExit;
            }

        *(*ppIntersectedCapability) = *pLocalCapability;

                Hr = S_OK;
                goto MyExit;
    }

    // First: test for basic similarity between local and remote format.
        if(pLocalCapability->capability.audio_cap.choice != pRemoteCapability->
                capability.audio_cap.choice)
        {
                Hr = E_INVALIDARG; // E_NO_INTERSECTION ?
                goto MyExit;
        }

    if (ppIntersectedCapability == NULL)
    {
        // just test to see if we like it.
            if (pRemoteCapability->media_type == H245MediaType_Video
            && pRemoteCapability->capability.video_cap.choice == h263VideoCapability_chosen)
        {
            if (!(pLocalCapability->capability.video_cap.u.h263VideoCapability.bit_mask
                & pRemoteCapability->capability.video_cap.u.h263VideoCapability.bit_mask))
            {
                return E_FAIL;
            }

#ifdef STRICT_H245
            // do more testing withe the capability. They might break the interop
            // with bad H323 endpoints.

            if (pLocalCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb <
                pRemoteCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb)
            {
                return E_FAIL;
            }

            if (pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate <
                pRemoteCapability->capability.video_cap.u.h263VideoCapability.maxBitRate)
            {
                return E_FAIL;
            }

            if (pLocalCapability->capability.video_cap.u.h263VideoCapability.qcifMPI >
                pRemoteCapability->capability.video_cap.u.h263VideoCapability.qcifMPI)
            {
                return E_FAIL;
            }

            if (pLocalCapability->capability.video_cap.u.h263VideoCapability.cifMPI >
                pRemoteCapability->capability.video_cap.u.h263VideoCapability.cifMPI)
            {
                return E_FAIL;
            }

            if (pLocalCapability->capability.video_cap.u.h263VideoCapability.sqcifMPI >
                pRemoteCapability->capability.video_cap.u.h263VideoCapability.sqcifMPI)
            {
                return E_FAIL;
            }
#endif
        }
            else if (pRemoteCapability->media_type == H245MediaType_Video
            && pRemoteCapability->capability.video_cap.choice == h261VideoCapability_chosen)
        {
            if (!(pLocalCapability->capability.video_cap.u.h261VideoCapability.bit_mask
                & pRemoteCapability->capability.video_cap.u.h261VideoCapability.bit_mask))
            {
                return E_FAIL;
            }

#ifdef STRICT_H245
            if (pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate <
                pRemoteCapability->capability.video_cap.u.h261VideoCapability.maxBitRate)
            {
                return E_FAIL;
            }

            if (pLocalCapability->capability.video_cap.u.h261VideoCapability.qcifMPI >
                pRemoteCapability->capability.video_cap.u.h261VideoCapability.qcifMPI)
            {
                return E_FAIL;
            }

            if (pLocalCapability->capability.video_cap.u.h261VideoCapability.cifMPI >
                pRemoteCapability->capability.video_cap.u.h261VideoCapability.cifMPI)
            {
                return E_FAIL;
            }
#endif
        }
        else
        {
            return E_UNEXPECTED;
        }

        return S_OK;
    }

        // Allocate memory to describe the capabilities of these formats
        if (!(*ppIntersectedCapability = new H245MediaCapability))
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_OUTOFMEMORY;
                goto MyExit;
        }

        // Initialize the intersected capability
        ZeroMemory(*ppIntersectedCapability, sizeof(H245MediaCapability));

        // Resolve the capabilities
        if (pRemoteCapability->media_type == H245MediaType_Video && pRemoteCapability->capability.video_cap.choice == h263VideoCapability_chosen)
        {
                (*ppIntersectedCapability)->media_type = H245MediaType_Video;
                (*ppIntersectedCapability)->capability.video_cap.choice = h263VideoCapability_chosen;
                (*ppIntersectedCapability)->capability.video_cap.u.h263VideoCapability.bit_mask = pLocalCapability->capability.video_cap.u.h263VideoCapability.bit_mask & pRemoteCapability->capability.video_cap.u.h263VideoCapability.bit_mask;
                if (!(*ppIntersectedCapability)->capability.video_cap.u.h263VideoCapability.bit_mask)
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Unsupported format", _fx_));
                        Hr = E_FAIL;
                        goto MyExit;
                }
                (*ppIntersectedCapability)->capability.video_cap.u.h263VideoCapability.bppMaxKb = min(pLocalCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb, pRemoteCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb);
                (*ppIntersectedCapability)->capability.video_cap.u.h263VideoCapability.maxBitRate = min(pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate, pRemoteCapability->capability.video_cap.u.h263VideoCapability.maxBitRate);
                (*ppIntersectedCapability)->capability.video_cap.u.h263VideoCapability.qcifMPI = max(pLocalCapability->capability.video_cap.u.h263VideoCapability.qcifMPI, pRemoteCapability->capability.video_cap.u.h263VideoCapability.qcifMPI);
                (*ppIntersectedCapability)->capability.video_cap.u.h263VideoCapability.cifMPI = max(pLocalCapability->capability.video_cap.u.h263VideoCapability.cifMPI, pRemoteCapability->capability.video_cap.u.h263VideoCapability.cifMPI);
                (*ppIntersectedCapability)->capability.video_cap.u.h263VideoCapability.sqcifMPI = max(pLocalCapability->capability.video_cap.u.h263VideoCapability.sqcifMPI, pRemoteCapability->capability.video_cap.u.h263VideoCapability.sqcifMPI);
        }
        else if (pRemoteCapability->media_type == H245MediaType_Video && pRemoteCapability->capability.video_cap.choice == h261VideoCapability_chosen)
        {
                (*ppIntersectedCapability)->media_type = H245MediaType_Video;
                (*ppIntersectedCapability)->capability.video_cap.choice = h261VideoCapability_chosen;
                (*ppIntersectedCapability)->capability.video_cap.u.h261VideoCapability.bit_mask = pLocalCapability->capability.video_cap.u.h261VideoCapability.bit_mask & pRemoteCapability->capability.video_cap.u.h261VideoCapability.bit_mask;
                if (!(*ppIntersectedCapability)->capability.video_cap.u.h261VideoCapability.bit_mask)
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Unsupported format", _fx_));
                        Hr = E_FAIL;
                        goto MyExit;
                }
                (*ppIntersectedCapability)->capability.video_cap.u.h261VideoCapability.maxBitRate = min(pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate, pRemoteCapability->capability.video_cap.u.h261VideoCapability.maxBitRate);
                (*ppIntersectedCapability)->capability.video_cap.u.h261VideoCapability.qcifMPI = max(pLocalCapability->capability.video_cap.u.h261VideoCapability.qcifMPI, pRemoteCapability->capability.video_cap.u.h261VideoCapability.qcifMPI);
                (*ppIntersectedCapability)->capability.video_cap.u.h261VideoCapability.cifMPI = max(pLocalCapability->capability.video_cap.u.h261VideoCapability.cifMPI, pRemoteCapability->capability.video_cap.u.h261VideoCapability.cifMPI);
        }
        else
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Unsupported format", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

MyExit:
    if (FAILED (Hr))
    {
        if (ppIntersectedCapability && *ppIntersectedCapability)
        {
            // clear allocated memory if we failed
            delete (*ppIntersectedCapability);
            *ppIntersectedCapability = NULL;
        }
    }

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | GetLocalFormat | This method is used to
 *    obtain the local TAPI MSP Video Decoder filter configuration
 *    parameters that are compatible with a remote capability.
 *
 *  @parm DWORD | dwUniqueID | Specifies the unique idea for the intersected
 *    H.245 video capability passed in.
 *
 *  @parm H245MediaCapability* | pIntersectedCapability | Specifies the H.245
 *    video format, of the resolved common local and remote capability
 *    options and limits.
 *
 *  @parm AM_MEDIA_TYPE** | ppAMMediaType | Specifies the address of a pointer
 *    to an <t AM_MEDIA_TYPE> structure to be been initialized with regards
 *    to negotiated options.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument argument
 *  @flag NOERROR | No error
 *
 *  @xref <mf CTAPIInputPin.GetNegotiatedLimitProperty>
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::GetLocalFormat(IN DWORD dwUniqueID, IN const H245MediaCapability *pIntersectedCapability, OUT AM_MEDIA_TYPE **ppAMMediaType)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::GetLocalFormat")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pIntersectedCapability);
        ASSERT(ppAMMediaType);
        if (!pIntersectedCapability || !ppAMMediaType)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Find the DShow format the passed in capability structure matches
        ASSERT(pIntersectedCapability->media_type == H245MediaType_Video);
        ASSERT(dwUniqueID <= R261_CIF_H245_CAPID);
        if (!(dwUniqueID <= R261_CIF_H245_CAPID) || pIntersectedCapability->media_type != H245MediaType_Video)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Unsupported format", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Return a copy of the format that matches the capability negociated
        if (!(*ppAMMediaType = CreateMediaType(R26XFormats[dwUniqueID])))
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_OUTOFMEMORY;
                goto MyExit;
        }

        // Doctor the AM_MEDIA_TYPE fields to show the changes in frame
        // rate, bitrate, and max frame size in the negotiated capability
        switch (dwUniqueID)
        {
                case R263_QCIF_H245_CAPID:
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->AvgTimePerFrame =  pIntersectedCapability->capability.video_cap.u.h263VideoCapability.qcifMPI * MIN_FRAME_INTERVAL;
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->dwBitRate = pIntersectedCapability->capability.video_cap.u.h263VideoCapability.maxBitRate * 100L;
                        break;
                case R263_CIF_H245_CAPID:
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->AvgTimePerFrame =  pIntersectedCapability->capability.video_cap.u.h263VideoCapability.cifMPI * MIN_FRAME_INTERVAL;
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->dwBitRate = pIntersectedCapability->capability.video_cap.u.h263VideoCapability.maxBitRate * 100L;
                        break;
                case R263_SQCIF_H245_CAPID:
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->AvgTimePerFrame =  pIntersectedCapability->capability.video_cap.u.h263VideoCapability.sqcifMPI * MIN_FRAME_INTERVAL;
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->dwBitRate = pIntersectedCapability->capability.video_cap.u.h263VideoCapability.maxBitRate * 100L;
                        break;
                case R261_QCIF_H245_CAPID:
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->AvgTimePerFrame =  pIntersectedCapability->capability.video_cap.u.h261VideoCapability.qcifMPI * MIN_FRAME_INTERVAL;
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->dwBitRate = pIntersectedCapability->capability.video_cap.u.h261VideoCapability.maxBitRate * 100L;
                        break;
                case R261_CIF_H245_CAPID:
                default:
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->AvgTimePerFrame =  pIntersectedCapability->capability.video_cap.u.h261VideoCapability.cifMPI * MIN_FRAME_INTERVAL;
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->dwBitRate = pIntersectedCapability->capability.video_cap.u.h261VideoCapability.maxBitRate * 100L;
                        break;
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | ReleaseNegotiatedCapability | This method
 *    is used to release the TAPI MSP Video Capture filter internal memory
 *    allocated by either the <mf CTAPIInputPin.IntersectFormats> or
 *    <mf CTAPIInputPin.GetLocalFormat> method.
 *
 *  @parm H245MediaCapability* | pIntersectedCapability | Specifies the H.245
 *    video format, of the resolved common local and remote capability
 *    options and limits.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 *
 *  @xref <mf CTAPIInputPin.IntersectFormats>, <mf CTAPIInputPin.GetLocalFormat>
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::ReleaseNegotiatedCapability(IN H245MediaCapability *pIntersectedCapability)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::ReleaseNegotiatedCapability")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pIntersectedCapability);
        if (!pIntersectedCapability)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Release the memory
        delete pIntersectedCapability;

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | FindIDByRange | This method is used to
 *    obtain the unique format ID of a capability that corresponds to an
 *    <t AM_MEDIA_TYPE>.
 *
 *  @parm AM_MEDIA_TYPE* | pAMMediaType | Specifies a pointer to an
 *    <t AM_MEDIA_TYPE> structure that has been initialized with a
 *    specific format.
 *
 *  @parm DWORD* | pdwID | Specifies a pointer to a DWORD output parameter
 *    that will contain the unique format ID.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::FindIDByRange(IN const AM_MEDIA_TYPE *pAMMediaType, OUT DWORD *pdwID)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::FindIDByRange")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pAMMediaType);
        ASSERT(pdwID);
        if (!pAMMediaType || !pdwID)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(pAMMediaType->majortype == MEDIATYPE_Video && pAMMediaType->formattype == FORMAT_VideoInfo && pAMMediaType->pbFormat);
        if (!pAMMediaType || !pdwID || pAMMediaType->majortype != MEDIATYPE_Video || pAMMediaType->formattype != FORMAT_VideoInfo || !pAMMediaType->pbFormat)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Which media type is this?
        if (HEADER(pAMMediaType->pbFormat)->biCompression == FOURCC_R263)
        {
                if (HEADER(pAMMediaType->pbFormat)->biWidth == 176 && HEADER(pAMMediaType->pbFormat)->biHeight == 144)
                {
                        *pdwID = R263_QCIF_H245_CAPID;
                }
                else if (HEADER(pAMMediaType->pbFormat)->biWidth == 352 && HEADER(pAMMediaType->pbFormat)->biHeight == 288)
                {
                        *pdwID = R263_CIF_H245_CAPID;
                }
                else if (HEADER(pAMMediaType->pbFormat)->biWidth == 128 && HEADER(pAMMediaType->pbFormat)->biHeight == 96)
                {
                        *pdwID = R263_SQCIF_H245_CAPID;
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                        Hr = E_INVALIDARG;
                }
        }
        else if (HEADER(pAMMediaType->pbFormat)->biCompression == FOURCC_R261)
        {
                if (HEADER(pAMMediaType->pbFormat)->biWidth == 176 && HEADER(pAMMediaType->pbFormat)->biHeight == 144)
                {
                        *pdwID = R261_QCIF_H245_CAPID;
                }
                else if (HEADER(pAMMediaType->pbFormat)->biWidth == 352 && HEADER(pAMMediaType->pbFormat)->biHeight == 288)
                {
                        *pdwID = R261_CIF_H245_CAPID;
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                        Hr = E_INVALIDARG;
                }
        }
        else
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_INVALIDARG;
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

#if 0
STDMETHODIMP CTAPIInputPin::TestH245VidC()
{
        HRESULT Hr = NOERROR;
        DWORD   dw;
        H245MediaCapabilityTable Table;
        H245MediaCapability *pIntersectedCapability;
        AM_MEDIA_TYPE *pAMMediaType;

        FX_ENTRY("CTAPIInputPin::TestH245VidC")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Test GetH245VersionID
        GetH245VersionID(&dw);

        // Test GetFormatTable
        GetFormatTable(&Table);

        for (DWORD i=0; i < Table.uMappedCapabilities; i++)
        {
                // Test Refine
                for (DWORD j=0; j < Table.pCapabilityArray[i].uNumEntries; j++)
                        Refine(&Table.pCapabilityArray[i].h245MediaCapability, Table.pCapabilityArray[i].dwUniqueID, j);

                // Test IntersectFormats
                IntersectFormats(Table.pCapabilityArray[i].dwUniqueID, &Table.pCapabilityArray[i].h245MediaCapability, &Table.pCapabilityArray[i].h245MediaCapability, &pIntersectedCapability);

                // Test GetLocalFormat
                GetLocalFormat(Table.pCapabilityArray[i].dwUniqueID, pIntersectedCapability, &pAMMediaType);

                // Test FindIDByRange
                FindIDByRange(pAMMediaType, &dw);

                // Test ReleaseNegotiatedCapability
                ReleaseNegotiatedCapability(pIntersectedCapability);
        }

        // Test ReleaseFormatTable
        ReleaseFormatTable(&Table);

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\inpinp.h ===
/****************************************************************************
 *  @doc INTERNAL INPINP
 *
 *  @module InPinP.h | Header file for the <c CInputPinProperty>
 *    class used to implement a property page to test the TAPI interfaces
 *    <i IFrameRateControl> and <i IBitrateControl>.
 *
 *  @comm This code is only compiled if USE_PROPERTY_PAGES is defined.
 ***************************************************************************/

#ifndef _INPINP_H_
#define _INPINP_H_

#ifdef USE_PROPERTY_PAGES

#define NUM_INPUT_PIN_PROPERTIES 2
#define CurrentFrameRate     0
#define CurrentBitrate       1

/****************************************************************************
 *  @doc INTERNAL CINPINPCLASS
 *
 *  @class CInputPinProperty | This class implements handling of a
 *    single property in a property page.
 *
 *  @mdata int | CInputPinProperty | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata IFrameRateControl * | CInputPinProperty | m_pIFrameRateControl | Pointer
 *    to the <i IFrameRateControl> interface.
 *
 *  @mdata IBitrateControl * | CInputPinProperty | m_pIBitrateControl | Pointer
 *    to the <i IBitrateControl> interface.
 *
 *  @comm This code tests the TAPI Video Decoder Filter <i IFrameRateControl>
 *     and <i IBitrateControl> implementation. This code is only compiled if
 *     USE_PROPERTY_PAGES is defined.
***************************************************************************/
class CInputPinProperty : public CPropertyEditor 
{
	public:
	CInputPinProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, IFrameRateControl *pIFrameRateControl, IBitrateControl *pIBitrateControl);
	~CInputPinProperty ();

	// CPropertyEditor base class pure virtual overrides
	HRESULT GetValue();
	HRESULT SetValue();
	HRESULT GetRange();
	BOOL CanAutoControl(void);
	BOOL GetAuto(void);
	BOOL SetAuto(BOOL fAuto);

	private:
	IFrameRateControl *m_pIFrameRateControl;
	IBitrateControl *m_pIBitrateControl;
};

/****************************************************************************
 *  @doc INTERNAL CINPINPCLASS
 *
 *  @class CInputPinProperties | This class runs a property page to test
 *    the TAPI Video Decoder Filter <i IFrameRateControl> and <i IBitrateControl>
 *    implementation.
 *
 *  @mdata int | CInputPinProperties | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata IFrameRateControl * | CInputPinProperties | m_pIFrameRateControl | Pointer
 *    to the <i IFrameRateControl> interface.
 *
 *  @mdata IBitrateControl * | CInputPinProperties | m_pIBitrateControl | Pointer
 *    to the <i IBitrateControl> interface.
 *
 *  @mdata CInputPinProperty * | CInputPinProperties | m_Controls[NUM_INPUT_PIN_PROPERTIES] | Array
 *    of properties.
 *
 *  @comm This code tests the TAPI Video Decoder Filter <i IFrameRateControl>
 *     and <i IBitrateControl> implementation. This code is only compiled if
 *     USE_PROPERTY_PAGES is defined.
***************************************************************************/
class CInputPinProperties : public CBasePropertyPage
{
	public:
	CInputPinProperties(LPUNKNOWN pUnk, HRESULT *pHr);
	~CInputPinProperties();

	HRESULT OnConnect(IUnknown *pUnk);
	HRESULT OnDisconnect();
	HRESULT OnActivate();
	HRESULT OnDeactivate();
	HRESULT OnApplyChanges();
	BOOL    OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	private:

	void SetDirty();

	int m_NumProperties;
	IFrameRateControl *m_pIFrameRateControl;
	IBitrateControl *m_pIBitrateControl;
	BOOL m_fActivated;
	CInputPinProperty *m_Controls[NUM_INPUT_PIN_PROPERTIES];
};

#endif // USE_PROPERTY_PAGES

#endif // _INPINP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\inpinp.cpp ===
/****************************************************************************
 *  @doc INTERNAL INPINP
 *
 *  @module InPinP.cpp | Source file for the <c CInputPinProperty>
 *    class used to implement a property page to test the TAPI interfaces
 *    <i IFrameRateControl> and <i IBitrateControl>.
 *
 *  @comm This code is only compiled if USE_PROPERTY_PAGES is defined.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_PROPERTY_PAGES

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc void | CInputPinProperty | CInputPinProperty | This
 *    method is the constructor for control property objects. It
 *    calls the base class constructor, calls InitCommonControlsEx, and saves
 *    a pointer to the control interface(s).
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    property progress bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the Ks property.
 *
 *  @parm IFrameRateControl* | pIFrameRateControl | Specifies a pointer to the
 *    <i IFrameRateControl> interface.
 *
 *  @parm IBitrateControl* | pIBitrateControl | Specifies a pointer to the
 *    <i IBitrateControl> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CInputPinProperty::CInputPinProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, IFrameRateControl *pIFrameRateControl, IBitrateControl *pIBitrateControl)
: CPropertyEditor(hDlg, IDLabel, IDMinControl, IDMaxControl, IDDefaultControl, IDStepControl, IDEditControl, IDTrackbarControl, IDProgressControl, IDProperty, IDAutoControl)
{
	INITCOMMONCONTROLSEX cc;

	FX_ENTRY("CInputPinProperty::CInputPinProperty")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
	cc.dwICC  = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

	InitCommonControlsEx(&cc);

	// It's fine if the interface pointer is NULL, we'll grey the
	// associated items in the property page
	m_pIFrameRateControl = pIFrameRateControl;
	m_pIBitrateControl   = pIBitrateControl;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc void | CInputPinProperty | ~CInputPinProperty | This
 *    method is the destructor for camera control property objects. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CInputPinProperty::~CInputPinProperty()
{
	FX_ENTRY("CInputPinProperty::~CInputPinProperty")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc HRESULT | CInputPinProperty | GetValue | This method queries for
 *    the value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CInputPinProperty::GetValue()
{
	HRESULT Hr = NOERROR;
	LONG CurrentValue;

	FX_ENTRY("CInputPinProperty::GetValue")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	switch (m_IDProperty)
	{									
		case CurrentFrameRate:
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->Get(FrameRateControl_Current, &CurrentValue, (TAPIControlFlags *)&m_CurrentFlags)))
			{
				if (CurrentValue)
					m_CurrentValue = (LONG)(10000000 / CurrentValue);
				else
					m_CurrentValue = 0;
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pAvgTimePerFrame=%ld"), _fx_, CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case CurrentBitrate:
			if (m_pIBitrateControl && SUCCEEDED (Hr = m_pIBitrateControl->Get(BitrateControl_Current, &m_CurrentValue, (TAPIControlFlags *)&m_CurrentFlags, 0UL)))
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pdwCurrentBitrate=%ld, dwLayerId=0"), _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Unknown property"), _fx_));
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc HRESULT | CInputPinProperty | SetValue | This method sets the
 *    value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CInputPinProperty::SetValue()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CInputPinProperty::SetValue")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// This is a read-only property. Don't do anything.

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc HRESULT | CInputPinProperty | GetRange | This method retrieves
 *    the range information of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CInputPinProperty::GetRange()
{
	HRESULT Hr = E_NOTIMPL;
	LONG Min;
	LONG Max;
	LONG SteppingDelta;
	LONG Default;

	FX_ENTRY("CInputPinProperty::GetRange")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	switch (m_IDProperty)
	{
		case CurrentFrameRate:
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->GetRange(FrameRateControl_Current, &Min, &Max, &SteppingDelta, &Default, (TAPIControlFlags *)&m_CapsFlags)))
			{
				if (Min)
					m_Max = (LONG)(10000000 / Min);
				else
					m_Max = 0;
				if (Max)
					m_Min = (LONG)(10000000 / Max);
				else
					m_Min = 0;
				if (SteppingDelta)
					m_SteppingDelta = (m_Max - m_Min) / (LONG)((Max - Min) / SteppingDelta);
				else
					m_SteppingDelta = 0;
				if (Default)
					m_DefaultValue = (LONG)(10000000 / Default);
				else
					m_DefaultValue = 0;
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pMin=%ld, *pMax=%ld, *pSteppingDelta=%ld, *pDefault=%ld"), _fx_, Min, Max, SteppingDelta, Default));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case CurrentBitrate:
			if (m_pIBitrateControl && SUCCEEDED (Hr = m_pIBitrateControl->GetRange(BitrateControl_Current, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, (TAPIControlFlags *)&m_CapsFlags, 0UL)))
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld, dwLayerId=0"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Unknown property"), _fx_));
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc CUnknown* | CInputPinProperties | CreateInstance | This
 *    method is called by DShow to create an instance of a
 *    Property Page. It is referred to in the global structure <t g_Templates>.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Returns a pointer to the nondelegating CUnknown portion of the
 *    object, or NULL otherwise.
 ***************************************************************************/
CUnknown* CALLBACK CInputPinPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr) 
{
	CUnknown *pUnknown = (CUnknown *)NULL;

	FX_ENTRY("CInputPinPropertiesCreateInstance")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	ASSERT(pHr);
	if (!pHr)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: invalid input parameter"), _fx_));
		goto MyExit;
	}

	if (!(pUnknown = new CInputPinProperties(pUnkOuter, pHr)))
	{
		*pHr = E_OUTOFMEMORY;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: new CInputPinProperties failed"), _fx_));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: new CInputPinProperties created"), _fx_));
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return pUnknown;
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc void | CInputPinProperties | CInputPinProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CInputPinProperties::CInputPinProperties(LPUNKNOWN pUnk, HRESULT *pHr) : CBasePropertyPage(NAME("Input Pin Property Page"), pUnk, IDD_InputPinProperties, IDS_INPUTPINPROPNAME)
{
	FX_ENTRY("CInputPinProperties::CInputPinProperties")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	m_pIFrameRateControl = NULL;
	m_pIBitrateControl = NULL;
	m_NumProperties = NUM_INPUT_PIN_PROPERTIES;
	m_fActivated = FALSE;

	for (int i = 0; i < m_NumProperties; i++)
		m_Controls[i] = NULL;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc void | CInputPinProperties | ~CInputPinProperties | This
 *    method is the destructor for camera control property page. It
 *    simply calls the base class destructor after deleting all the controls.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CInputPinProperties::~CInputPinProperties()
{
	int		j;

	FX_ENTRY("CInputPinProperties::~CInputPinProperties")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX"), _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: control already freed"), _fx_));
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc HRESULT | CInputPinProperties | OnConnect | This
 *    method is called when the property page is connected to the filter.
 *
 *  @parm LPUNKNOWN | pUnknown | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CInputPinProperties::OnConnect(IUnknown *pUnk)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CInputPinProperties::OnConnect")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	ASSERT(pUnk);
	if (!pUnk)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: invalid input parameter"), _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the frame rate control interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(IFrameRateControl),(void **)&m_pIFrameRateControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_pIFrameRateControl=0x%08lX"), _fx_, m_pIFrameRateControl));
	}
	else
	{
		m_pIFrameRateControl = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: IOCTL failed Hr=0x%08lX"), _fx_, Hr));
	}

	// Get the bitrate control interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(IBitrateControl),(void **)&m_pIBitrateControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_pIBitrateControl=0x%08lX"), _fx_, m_pIBitrateControl));
	}
	else
	{
		m_pIBitrateControl = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: IOCTL failed Hr=0x%08lX"), _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers. We'll just grey the controls in the property page
	// to make it clear to the user that they can't control those properties on the device
	Hr = NOERROR;

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc HRESULT | CInputPinProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CInputPinProperties::OnDisconnect()
{
	FX_ENTRY("CInputPinProperties::OnDisconnect")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Validate input parameters: we seem to get called several times here
	// Make sure the interface pointer is still valid
	if (!m_pIFrameRateControl)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pIFrameRateControl->Release();
		m_pIFrameRateControl = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: releasing m_pIFrameRateControl"), _fx_));
	}

	if (!m_pIBitrateControl)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pIBitrateControl->Release();
		m_pIBitrateControl = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: releasing m_pIBitrateControl"), _fx_));
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc HRESULT | CInputPinProperties | OnActivate | This
 *    method is called when the property page is activated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CInputPinProperties::OnActivate()
{
	HRESULT	Hr = E_OUTOFMEMORY;
	int		j;

	FX_ENTRY("CInputPinProperties::OnActivate")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Create the controls for the properties
	if (!(m_Controls[0] = new CInputPinProperty(m_hwnd, IDC_FrameRateControl_Label, 0, 0, 0, 0, IDC_FrameRateControl_Actual, 0, IDC_FrameRateControl_Meter, CurrentFrameRate, 0, m_pIFrameRateControl, m_pIBitrateControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: mew m_Controls[CurrentFrameRate] failed - Out of memory"), _fx_));
		goto MyExit;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[CurrentFrameRate]=0x%08lX"), _fx_, m_Controls[0]));
	}

	if (!(m_Controls[1] = new CInputPinProperty(m_hwnd, IDC_BitrateControl_Label, 0, 0, 0, 0, IDC_BitrateControl_Actual, 0, IDC_BitrateControl_Meter, CurrentBitrate, 0, m_pIFrameRateControl, m_pIBitrateControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: mew m_Controls[CurrentBitrate] failed - Out of memory"), _fx_));
		goto MyError0;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[CurrentBitrate]=0x%08lX"), _fx_, m_Controls[1]));
	}

	// Initialize all the controls. If the initialization fails, it's Ok. It just means
	// that the TAPI control interface isn't implemented by the filter. The dialog item
	// in the property page will be greyed, showing this to the user.
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j]->Init())
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[%ld]->Init()"), _fx_, j));
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: m_Controls[%ld]->Init() failed"), _fx_, j));
		}
	}

	Hr = NOERROR;
	goto MyExit;

MyError0:
	if (m_Controls[0])
		delete m_Controls[0], m_Controls[0] = NULL;
MyExit:
	m_fActivated = TRUE;
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc HRESULT | CInputPinProperties | OnDeactivate | This
 *    method is called when the property page is dismissed.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CInputPinProperties::OnDeactivate()
{
	int		j;

	FX_ENTRY("CInputPinProperties::OnDeactivate")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX"), _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: control already freed"), _fx_));
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	m_fActivated = FALSE;
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc HRESULT | CInputPinProperties | OnApplyChanges | This
 *    method is called when the user applies changes to the property page.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CInputPinProperties::OnApplyChanges()
{
	HRESULT	Hr = NOERROR;

	FX_ENTRY("CInputPinProperties::OnApplyChanges")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	for (int j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			if (m_Controls[j]->HasChanged())
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: calling m_Controls[%ld]=0x%08lX->OnApply"), _fx_, j, m_Controls[j]));
				m_Controls[j]->OnApply();
			}
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: can't call m_Controls[%ld]=NULL->OnApply"), _fx_, j));
			Hr = E_UNEXPECTED;
			break;
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc BOOL | CInputPinProperties | OnReceiveMessage | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
BOOL CInputPinProperties::OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
		case WM_INITDIALOG:
			return TRUE; // Don't call setfocus

		case WM_TIMER:
			if (m_fActivated)
			{
				// Update the Vu-Meters
				for (j = 0; j < m_NumProperties; j++)
				{
					ASSERT(m_Controls[j]);
					if (m_Controls[j]->GetProgressHWnd())
					{
						m_Controls[j]->UpdateProgress();
						SetDirty();
					}
				}
			}
			break;

		case WM_HSCROLL:
		case WM_VSCROLL:
			if (m_fActivated)
			{
				// Process all of the Trackbar messages
				for (j = 0; j < m_NumProperties; j++)
				{
					ASSERT(m_Controls[j]);
					if (m_Controls[j]->GetTrackbarHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnScroll(uMsg, wParam, lParam);
						SetDirty();
					}
				}
				OnApplyChanges();
			}
			break;

		case WM_COMMAND:

			// This message gets sent even before OnActivate() has been
			// called(!). We need to test and make sure the controls have
			// beeen initialized before we can use them.

			if (m_fActivated)
			{
				// Process all of the auto checkbox messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetAutoHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnAuto(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				// Process all of the edit box messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetEditHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnEdit(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				switch (LOWORD(wParam))
				{
					case IDC_CONTROL_DEFAULT:
						for (j = 0; j < m_NumProperties; j++)
						{
							if (m_Controls[j])
								m_Controls[j]->OnDefault();
						}
						break;

					default:
						break;
				}

			OnApplyChanges();
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc BOOL | CInputPinProperties | SetDirty | This
 *    method notifies the property page site of changes.
 *
 *  @rdesc Nada.
 ***************************************************************************/
void CInputPinProperties::SetDirty()
{
	m_bDirty = TRUE;
	if (m_pPageSite)
		m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}

#endif // USE_PROPERTY_PAGES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\outpin.cpp ===
/****************************************************************************
 *  @doc INTERNAL OUTPIN
 *
 *  @module OutPin.cpp | Source file for the <c CTAPIOutputPin> class methods
 *    used to implement the TAPI base output pin.
 ***************************************************************************/

#include "Precomp.h"

// Default CPU load for decoding a frame (in %)
#define DEFAULT_CPU_LOAD 85

/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | CTAPIOutputPin | This method is the
 *  constructor for the <c CTAPIOutputPin> object
 *
 *  @rdesc Nada.
 ***************************************************************************/
#if 0
CTAPIOutputPin::CTAPIOutputPin(IN TCHAR *pObjectName, IN CTAPIVDec *pDecoderFilter, IN CCritSec *pLock, IN HRESULT *pHr, IN LPCWSTR pName) : CBaseOutputPinEx(pObjectName, pDecoderFilter, pLock, pHr, pName)
#else
CTAPIOutputPin::CTAPIOutputPin(IN TCHAR *pObjectName, IN CTAPIVDec *pDecoderFilter, IN CCritSec *pLock, IN HRESULT *pHr, IN LPCWSTR pName) : CBaseOutputPin(pObjectName, pDecoderFilter, pLock, pHr, pName)
#endif
{
	FX_ENTRY("CTAPIOutputPin::CTAPIOutputPin")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Initialize stuff
	m_pDecoderFilter = pDecoderFilter;

#ifdef USE_CPU_CONTROL
	// CPU control
	m_lMaxProcessingTime = 333333L;
	m_lCurrentProcessingTime = 0;
	m_lMaxCPULoad = DEFAULT_CPU_LOAD;
	m_lCurrentCPULoad = 0UL;
#endif

	// Frame rate control
	// This should not be based on the capabilities of the machine.
	// We could receive CIF or SQCIF. In the former case, we could be
	// maxed out at 7 fps but still can render 30fps. So, we should
	// initialize those values to their potential max.
	m_lMaxAvgTimePerFrame = 333333L;
	m_lCurrentAvgTimePerFrame = 333333L;
	m_lAvgTimePerFrameRangeMin = 333333L;
	m_lAvgTimePerFrameRangeMax = 10000000L;
	m_lAvgTimePerFrameRangeSteppingDelta = 333333L;
	m_lAvgTimePerFrameRangeDefault = 333333L;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc void | CTAPIOutputPin | ~CTAPIOutputPin | This method is the
 *    destructor of our output pin.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CTAPIOutputPin::~CTAPIOutputPin()
{
	FX_ENTRY("CTAPIOutputPin::~CTAPIOutputPin")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | NonDelegatingQueryInterface | This
 *    method is the nondelegating interface query function. It returns a
 *    pointer to the specified interface if supported. The only interfaces
 *    explicitly supported being <i ICPUControl>, <i IFrameRateControl>
 *    and <i IH245DecoderCommand>.
 *
 *  @parm REFIID | riid | Specifies the identifier of the interface to return.
 *
 *  @parm PVOID* | ppv | Specifies the place in which to put the interface
 *    pointer.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIOutputPin::NonDelegatingQueryInterface(IN REFIID riid, OUT void **ppv)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIOutputPin::NonDelegatingQueryInterface")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(ppv);
	if (!ppv)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Retrieve interface pointer
	if (riid == __uuidof(IH245DecoderCommand))
	{
		if (FAILED(Hr = GetInterface(static_cast<IH245DecoderCommand*>(this), ppv)))
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for IH245DecoderCommand failed Hr=0x%08lX", _fx_, Hr));
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: IH245DecoderCommand*=0x%08lX", _fx_, *ppv));
		}

		goto MyExit;
	}
#ifdef USE_PROPERTY_PAGES
	else if (riid == IID_ISpecifyPropertyPages)
	{
		if (FAILED(Hr = GetInterface(static_cast<ISpecifyPropertyPages*>(this), ppv)))
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for ISpecifyPropertyPages failed Hr=0x%08lX", _fx_, Hr));
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: ISpecifyPropertyPages*=0x%08lX", _fx_, *ppv));
		}

		goto MyExit;
	}
#endif
	else if (riid == __uuidof(IFrameRateControl))
	{
		if (FAILED(Hr = GetInterface(static_cast<IFrameRateControl*>(this), ppv)))
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for IFrameRateControl failed Hr=0x%08lX", _fx_, Hr));
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: IFrameRateControl*=0x%08lX", _fx_, *ppv));
		}

		goto MyExit;
	}
#ifdef USE_CPU_CONTROL
	else if (riid == __uuidof(ICPUControl))
	{
		if (FAILED(Hr = GetInterface(static_cast<ICPUControl*>(this), ppv)))
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for ICPUControl failed Hr=0x%08lX", _fx_, Hr));
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: ICPUControl*=0x%08lX", _fx_, *ppv));
		}

		goto MyExit;
	}
#endif

	if (FAILED(Hr = CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, WARN, "%s:   WARNING: NDQI for {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX} failed Hr=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], Hr));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}*=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], *ppv));
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

#ifdef USE_PROPERTY_PAGES
/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | GetPages | This method fills a counted
 *    array of GUID values where each GUID specifies the CLSID of each
 *    property page that can be displayed in the property sheet for this
 *    object.
 *
 *  @parm CAUUID* | pPages | Specifies a pointer to a caller-allocated CAUUID
 *    structure that must be initialized and filled before returning. The
 *    pElems field in the CAUUID structure is allocated by the callee with
 *    CoTaskMemAlloc and freed by the caller with CoTaskMemFree.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_OUTOFMEMORY | Allocation failed
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIOutputPin::GetPages(OUT CAUUID *pPages)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIOutputPin::GetPages")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pPages);
	if (!pPages)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	pPages->cElems = 1;
	if (pPages->cElems)
	{
		if (!(pPages->pElems = (GUID *) QzTaskMemAlloc(sizeof(GUID) * pPages->cElems)))
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
			Hr = E_OUTOFMEMORY;
		}
		else
		{
			pPages->pElems[0] = __uuidof(TAPIVDecOutputPinPropertyPage);
		}
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}
#endif

/****************************************************************************
 *  @doc INTERNAL CFPSOUTCMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | Set | This method is used to set the
 *    value of a frame rate control property.
 *
 *  @parm FrameRateControlProperty | Property | Used to specify the frame rate
 *    control setting to set the value of. Use a member of the
 *    <t FrameRateControlProperty> enumerated type.
 *
 *  @parm long | lValue | Used to specify the new value of the frame rate control
 *    setting.
 *
 *  @parm TAPIControlFlags | lFlags | A member of the <t TAPIControlFlags>
 *    enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIOutputPin::Set(IN FrameRateControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIOutputPin::Set (FrameRateControlProperty)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(lValue >= m_lAvgTimePerFrameRangeMin);
	ASSERT(lValue <= m_lAvgTimePerFrameRangeMax);
	ASSERT(Property >= FrameRateControl_Maximum && Property <= FrameRateControl_Current);

	// Set relevant values
	if (Property == FrameRateControl_Maximum)
	{
		if (!lValue || lValue < m_lAvgTimePerFrameRangeMin || lValue > m_lAvgTimePerFrameRangeMax)
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
			Hr = E_INVALIDARG;
			goto MyExit;
		}
		m_lMaxAvgTimePerFrame = lValue;
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   New target frame rate: %ld.%ld fps", _fx_, 10000000/m_lMaxAvgTimePerFrame, 1000000000/m_lMaxAvgTimePerFrame - (10000000/m_lMaxAvgTimePerFrame) * 100));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
		Hr = E_PROP_ID_UNSUPPORTED;
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CFPSOUTCMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | Get | This method is used to retrieve
 *    the value of the current or maximum frame rate advertized.
 *
 *  @parm FrameRateControlProperty | Property | Used to specify the frame rate
 *    control setting to get the value of. Use a member of the
 *    <t FrameRateControlProperty> enumerated type.
 *
 *  @parm long* | plValue | Used to receive the value of the property, in
 *    100-nanosecond units.
 *
 *  @parm TAPIControlFlags* | plFlags | Pointer to a member of the
 *     <t TAPIControlFlags> enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIOutputPin::Get(IN FrameRateControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIOutputPin::Get (FrameRateControlProperty)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plValue);
	ASSERT(plFlags);
	if (!plValue || !plFlags)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(Property >= FrameRateControl_Maximum && Property <= FrameRateControl_Current);

	// Return relevant values
	*plFlags = TAPIControl_Flags_None;
	if (Property == FrameRateControl_Maximum)
		*plValue = m_lMaxAvgTimePerFrame;
	else if (Property == FrameRateControl_Current)
		*plValue = m_lCurrentAvgTimePerFrame;
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
		Hr = E_PROP_ID_UNSUPPORTED;
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CFPSOUTCMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | GetRange | This method is used to
 *    retrieve support, minimum, maximum, and default values of the current
 *    or maximum frame rate advertized.
 *
 *  @parm FrameRateControlProperty | Property | Used to specify the frame rate
 *    control setting to get the range values of. Use a member of the
 *    <t FrameRateControlProperty> enumerated type.
 *
 *  @parm long* | plMin | Used to retrieve the minimum value of the
 *    property, in 100-nanosecond units.
 *
 *  @parm long* | plMax | Used to retrieve the maximum value of the
 *    property, in 100-nanosecond units.
 *
 *  @parm long* | plSteppingDelta | Used to retrieve the stepping delta
 *    of the property, in 100-nanosecond units.
 *
 *  @parm long* | plDefault | Used to retrieve the default value of the
 *    property, in 100-nanosecond units.
 *
 *  @parm TAPIControlFlags* | plCapsFlags | Pointer to a member of the
 *     <t TAPIControlFlags> enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIOutputPin::GetRange(IN FrameRateControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIOutputPin::GetRange (FrameRateControlProperty)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plMin);
	ASSERT(plMax);
	ASSERT(plSteppingDelta);
	ASSERT(plDefault);
	ASSERT(plCapsFlags);
	if (!plMin || !plMax || !plSteppingDelta || !plDefault || !plCapsFlags)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(Property >= FrameRateControl_Maximum && Property <= FrameRateControl_Current);
	if (Property != FrameRateControl_Maximum && Property != FrameRateControl_Current)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
		Hr = E_PROP_ID_UNSUPPORTED;
		goto MyExit;
	}

	// Return relevant values
	*plCapsFlags = TAPIControl_Flags_None;
	*plMin = m_lAvgTimePerFrameRangeMin;
	*plMax = m_lAvgTimePerFrameRangeMax;
	*plSteppingDelta = m_lAvgTimePerFrameRangeSteppingDelta;
	*plDefault = m_lAvgTimePerFrameRangeDefault;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Ranges: Min=%ld, Max=%ld, Step=%ld, Default=%ld", _fx_, m_lAvgTimePerFrameRangeMin, m_lAvgTimePerFrameRangeMax, m_lAvgTimePerFrameRangeSteppingDelta, m_lAvgTimePerFrameRangeDefault));

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

#ifdef USE_CPU_CONTROL

/****************************************************************************
 *  @doc INTERNAL CCPUCMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | Set | This method is used to set the
 *    value of a CPU control property.
 *
 *  @parm CPUControlProperty | Property | Used to specify the CPU
 *    control setting to set the value of. Use a member of the
 *    <t CPUControlProperty> enumerated type.
 *
 *  @parm long | lValue | Used to specify the new value of the CPU control
 *    setting.
 *
 *  @parm TAPIControlFlags | lFlags | A member of the <t TAPIControlFlags>
 *    enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 *
 *  @comm We don't support CPUControl_MaxCPULoad and CPUControl_MaxProcessingTime.
 ***************************************************************************/
STDMETHODIMP CTAPIOutputPin::Set(IN CPUControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIOutputPin::Set (CPUControlProperty)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	ASSERT(Property >= CPUControl_MaxCPULoad && Property <= CPUControl_CurrentProcessingTime);

	// Set relevant values
	switch(Property)
	{
#if 0
		case CPUControl_MaxCPULoad:

			// Validate input parameters
			ASSERT(lValue >= 0 && lValue <= 100);
			if (!(lValue >= 0 && lValue <= 100))
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument - 0<Max CPU Load<100", _fx_));
				Hr = E_INVALIDARG;
				goto MyExit;
			}

			// Remember value passed in
			m_lMaxCPULoad = lValue;
			break;

		case CPUControl_MaxProcessingTime:

			// Validate input parameters - we can't take more than the picture interval
			// if we still want to be working in real time
			ASSERT(lValue < m_lMaxAvgTimePerFrame);
			if (!(lValue < m_lMaxAvgTimePerFrame))
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument - would break real-time!", _fx_));
				Hr = E_INVALIDARG;
				goto MyExit;
			}

			// Remember value passed in 
			m_lMaxProcessingTime = lValue;
			break;
#endif
		case CPUControl_CurrentCPULoad:
		case CPUControl_CurrentProcessingTime:

			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument - Property is read-only", _fx_));
			Hr = E_INVALIDARG;
			goto MyExit;

		default:
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument - Property is not supported", _fx_));
			Hr = E_PROP_ID_UNSUPPORTED;
			goto MyExit;
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Value=%ld", _fx_, lValue));

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCPUCMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | Get | This method is used to retrieve
 *    the value of a CPU control property.
 *
 *  @parm CPUControlProperty | Property | Used to specify the CPU
 *    control setting to get the value of. Use a member of the
 *    <t CPUControlProperty> enumerated type.
 *
 *  @parm long* | plValue | Used to receive the value of the property.
 *
 *  @parm TAPIControlFlags* | plFlags | Pointer to a member of the <t TAPIControlFlags>
 *    enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 *
 *  @comm We don't support CPUControl_MaxCPULoad and CPUControl_MaxProcessingTime.
 ***************************************************************************/
STDMETHODIMP CTAPIOutputPin::Get(IN CPUControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIOutputPin::Get (CPUControlProperty)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plValue);
	ASSERT(plFlags);
	if (!plValue || !plFlags)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(Property >= CPUControl_MaxCPULoad && Property <= CPUControl_CurrentProcessingTime);

	// Return relevant values
	*plFlags = TAPIControl_Flags_None;
	switch(Property)
	{
#if 0
		case CPUControl_MaxCPULoad:
			*plValue = m_lMaxCPULoad;
			break;

		case CPUControl_MaxProcessingTime:
			*plValue = m_lMaxProcessingTime;
			break;
#endif
		case CPUControl_CurrentCPULoad:
			*plValue = m_lCurrentCPULoad;
			break;

		case CPUControl_CurrentProcessingTime:
			*plValue = m_lCurrentProcessingTime;
			break;

		default:
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument - Property is not supported", _fx_));
			Hr = E_PROP_ID_UNSUPPORTED;
			goto MyExit;
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Value=%ld", _fx_, *plValue));

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CFPSCMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | GetRange | This method is used to
 *    retrieve support, minimum, maximum, and default values of a CPU control
 *    property.
 *
 *  @parm CPUControlProperty | Property | Used to specifiy the CPU control
 *    property to retrieve the range values of.
 *
 *  @parm long* | plMin | Used to retrieve the minimum value of the
 *    property.
 *
 *  @parm long* | plMax | Used to retrieve the maximum value of the
 *    property.
 *
 *  @parm long* | plSteppingDelta | Used to retrieve the stepping delta
 *    of the property.
 *
 *  @parm long* | plDefault | Used to retrieve the default value of the
 *    property.
 *
 *  @parm TAPIControlFlags* | plCapsFlags | Used to receive the flags
 *    suppported by the property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 *
 *  @comm We don't support CPUControl_MaxCPULoad and CPUControl_MaxProcessingTime.
 ***************************************************************************/
STDMETHODIMP CTAPIOutputPin::GetRange(IN CPUControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIOutputPin::GetRange (CPUControlProperty)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plMin);
	ASSERT(plMax);
	ASSERT(plSteppingDelta);
	ASSERT(plDefault);
	ASSERT(plCapsFlags);
	if (!plMin || !plMax || !plSteppingDelta || !plDefault || !plCapsFlags)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(Property >= CPUControl_MaxCPULoad && Property <= CPUControl_CurrentProcessingTime);

	// Return relevant values
	*plCapsFlags = TAPIControl_Flags_None;
#if 0
	if (Property == CPUControl_MaxCPULoad || Property == CPUControl_CurrentCPULoad)
#else
	if (Property == CPUControl_CurrentCPULoad)
#endif
	{
		*plMin = 0;
		*plMax = 100;
		*plSteppingDelta = 1;
		*plDefault = DEFAULT_CPU_LOAD;
	}
#if 0
	else if (Property == CPUControl_MaxProcessingTime || Property == CPUControl_CurrentProcessingTime)
#else
	else if (Property == CPUControl_CurrentProcessingTime)
#endif
	{
		*plMin = 0;
		*plMax = m_lMaxAvgTimePerFrame;
		*plSteppingDelta = 1;
		*plDefault = m_lMaxAvgTimePerFrame;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
		Hr = E_PROP_ID_UNSUPPORTED;
		goto MyExit;
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Ranges: Min=%ld, Max=%ld, Step=%ld, Default=%ld", _fx_, m_lAvgTimePerFrameRangeMin, m_lAvgTimePerFrameRangeMax, m_lAvgTimePerFrameRangeSteppingDelta, m_lAvgTimePerFrameRangeDefault));

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

#endif

/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | GetMediaType | This method is called when
 *    enumerating the media type the output pin supports. It checks the
 *    current display mode to device which of the RGB types to return.
 *
 *  @parm int | iPosition | Specifies the position of the media type in the
 *    media type list.
 *
 *  @parm CMediaType* | pmt | Specifies a pointer pointer to the returned
 *    media type object.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIOutputPin::GetMediaType(IN int iPosition, OUT CMediaType *pMediaType)
{
	HRESULT				Hr = NOERROR;
	HDC					hDC;
	int					nBPP;
	LPBITMAPINFOHEADER	lpbi;
	LARGE_INTEGER		li;
	FOURCCMap			fccHandler;
	VIDEOINFOHEADER		*pf;

	FX_ENTRY("CTAPIOutputPin::GetMediaType")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

    // we can't lock the filter here because of a deadlock.
    // On the receive path, if there is a format change, the video allocator
    // calls back into this function holding the receive lock. If the graph is
    // being stopped at the same time, the other thead will lock the filter and
    // try to lock the receive lock. A simple fix is to remove this lock and
    // assume that no one is going to call this method and disconnect the input
    // pin at the same time.
    //CAutoLock Lock(&m_pDecoderFilter->m_csFilter);

	// Validate input parameters
	ASSERT(iPosition >= 0);
	ASSERT(pMediaType);
	if (iPosition < 0)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid iPosition argument", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}
	if (!pMediaType)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
    if (!m_pDecoderFilter->m_pInput->m_mt.IsValid())
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid input pin format", _fx_));
		Hr = E_FAIL;
		goto MyExit;
    }

	// Get the current bitdepth
	hDC = GetDC(NULL);
	nBPP = GetDeviceCaps(hDC, BITSPIXEL) * GetDeviceCaps(hDC, PLANES);
	ReleaseDC(NULL, hDC);

	// Get most of the format attributes from the input format and override the appropriate fields
	*pMediaType = m_pDecoderFilter->m_pInput->m_mt;

#ifndef NO_YUV_MODES
	if (iPosition == 0)
	{
		// YUY2
		pMediaType->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));
		lpbi = HEADER(pMediaType->Format());
		lpbi->biSize = sizeof(BITMAPINFOHEADER);
		lpbi->biCompression = FOURCC_YUY2;
		lpbi->biBitCount = 16;
		lpbi->biClrUsed = 0;
		lpbi->biClrImportant = 0;
		lpbi->biSizeImage = DIBSIZE(*lpbi);
		pMediaType->SetSubtype(&MEDIASUBTYPE_YUY2);
	}
	else if (iPosition == 1)
	{
		// UYVY
		pMediaType->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));
		lpbi = HEADER(pMediaType->Format());
		lpbi->biSize = sizeof(BITMAPINFOHEADER);
		lpbi->biCompression = FOURCC_UYVY;
		lpbi->biBitCount = 16;
		lpbi->biClrUsed = 0;
		lpbi->biClrImportant = 0;
		lpbi->biSizeImage = DIBSIZE(*lpbi);
		pMediaType->SetSubtype(&MEDIASUBTYPE_UYVY);
	}
	else if (iPosition == 2)
	{
		// I420
		pMediaType->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));
		lpbi = HEADER(pMediaType->Format());
		lpbi->biSize = sizeof(BITMAPINFOHEADER);
		lpbi->biCompression = FOURCC_I420;
		lpbi->biBitCount = 12;
		lpbi->biClrUsed = 0;
		lpbi->biClrImportant = 0;
		lpbi->biSizeImage = DIBSIZE(*lpbi);
		pMediaType->SetSubtype(&MEDIASUBTYPE_I420);
	}
	else if (iPosition == 3)
	{
		// IYUV
		pMediaType->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));
		lpbi = HEADER(pMediaType->Format());
		lpbi->biSize = sizeof(BITMAPINFOHEADER);
		lpbi->biCompression = FOURCC_IYUV;
		lpbi->biBitCount = 12;
		lpbi->biClrUsed = 0;
		lpbi->biClrImportant = 0;
		lpbi->biSizeImage = DIBSIZE(*lpbi);
		pMediaType->SetSubtype(&MEDIASUBTYPE_IYUV);
	}
	else if (iPosition == 4)
	{
		// YV12
		pMediaType->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));
		lpbi = HEADER(pMediaType->Format());
		lpbi->biSize = sizeof(BITMAPINFOHEADER);
		lpbi->biCompression = FOURCC_YV12;
		lpbi->biBitCount = 12;
		lpbi->biClrUsed = 0;
		lpbi->biClrImportant = 0;
		lpbi->biSizeImage = DIBSIZE(*lpbi);
		pMediaType->SetSubtype(&MEDIASUBTYPE_YV12);
	}
	else
	{
#endif
		// Configure the bitmap info header based on the bit depth of the screen
	    switch (nBPP)
		{
		    case 32:
		    {
#ifndef NO_YUV_MODES
				if (iPosition == 5)
#else
				if (iPosition == 0)
#endif
				{
					pMediaType->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));
					lpbi = HEADER(pMediaType->Format());
					lpbi->biSize = sizeof(BITMAPINFOHEADER);
					lpbi->biCompression = BI_RGB;
					lpbi->biBitCount = 32;
					lpbi->biClrUsed = 0;
					lpbi->biClrImportant = 0;
					lpbi->biSizeImage = DIBSIZE(*lpbi);
			        pMediaType->SetSubtype(&MEDIASUBTYPE_RGB32);
				}
				else
				{
					Hr = VFW_S_NO_MORE_ITEMS;
					goto MyExit;
				}
		        break;
		    }

		    case 16:
		    {
#ifndef NO_YUV_MODES
				if (iPosition == 5)
#else
				if (iPosition == 0)
#endif
				{
					if (FAILED(pMediaType->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER) + SIZE_MASKS)))
					{
						DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
						Hr = E_OUTOFMEMORY;
						goto MyExit;
					}
					lpbi = HEADER(pMediaType->Format());
					lpbi->biSize = sizeof(BITMAPINFOHEADER);
					lpbi->biCompression = BI_BITFIELDS;
					lpbi->biBitCount = 16;
					lpbi->biClrUsed = 0;
					lpbi->biClrImportant = 0;
					lpbi->biSizeImage = DIBSIZE(*lpbi);

					DWORD *pdw = (DWORD *)(lpbi+1);
					pdw[iRED]	= 0x00F800;
					pdw[iGREEN]	= 0x0007E0;
					pdw[iBLUE]	= 0x00001F;

					pMediaType->SetSubtype(&MEDIASUBTYPE_RGB565);
				}
#ifndef NO_YUV_MODES
				else if (iPosition == 6)
#else
				else if (iPosition == 1)
#endif
				{
					pMediaType->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));
					lpbi = HEADER(pMediaType->Format());
					lpbi->biSize = sizeof(BITMAPINFOHEADER);
					lpbi->biCompression = BI_RGB;
					lpbi->biBitCount = 16;
					lpbi->biClrUsed = 0;
					lpbi->biClrImportant = 0;
					lpbi->biSizeImage = DIBSIZE(*lpbi);
					pMediaType->SetSubtype(&MEDIASUBTYPE_RGB555);
				}
				else
				{
					Hr = VFW_S_NO_MORE_ITEMS;
					goto MyExit;
				}
		        break;
		    }

		    case 8:
		    {
#ifndef NO_YUV_MODES
				if (iPosition == 5)
#else
				if (iPosition == 0)
#endif
				{
					if (FAILED(pMediaType->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER) + SIZE_PALETTE)))
					{
						DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
						Hr = E_OUTOFMEMORY;
						goto MyExit;
					}
					lpbi = HEADER(pMediaType->Format());
					lpbi->biSize = sizeof(BITMAPINFOHEADER);
					lpbi->biCompression = BI_RGB;
					lpbi->biBitCount = 8;
					lpbi->biClrUsed = 0;
					lpbi->biClrImportant = 0;
					lpbi->biSizeImage = DIBSIZE(*lpbi);

					ASSERT(m_pDecoderFilter->m_pInstInfo);

					// Get the Indeo palette from the decoder
#if defined(ICM_LOGGING) && defined(DEBUG)
					OutputDebugString("CTAPIOutputPin::GetMediaType - ICM_DECOMPRESS_GET_PALETTE\r\n");
#endif
					(*m_pDecoderFilter->m_pDriverProc)((DWORD)m_pDecoderFilter->m_pInstInfo, NULL, ICM_DECOMPRESS_GET_PALETTE, (long)HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat), (long)lpbi);

					pMediaType->SetSubtype(&MEDIASUBTYPE_RGB8);
				}
				else
				{
					Hr = VFW_S_NO_MORE_ITEMS;
					goto MyExit;
				}
		        break;
		    }

		    default:
		    {
#ifndef NO_YUV_MODES
				if (iPosition == 5)
#else
				if (iPosition == 0)
#endif
				{
					pMediaType->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));
					lpbi = HEADER(pMediaType->Format());
					lpbi->biSize = sizeof(BITMAPINFOHEADER);
					lpbi->biCompression = BI_RGB;
					lpbi->biBitCount = 24;
					lpbi->biClrUsed = 0;
					lpbi->biClrImportant = 0;
					lpbi->biSizeImage = DIBSIZE(*lpbi);
					pMediaType->SetSubtype(&MEDIASUBTYPE_RGB24);
				}
				else
				{
					Hr = VFW_S_NO_MORE_ITEMS;
					goto MyExit;
				}
		        break;
		    }
		}
#ifndef NO_YUV_MODES
	}
#endif

    // Now set the common things about the media type
    pf = (VIDEOINFOHEADER *)pMediaType->Format();
#if 1
    pf->AvgTimePerFrame = ((VIDEOINFOHEADER *)m_pDecoderFilter->m_pInput->m_mt.pbFormat)->AvgTimePerFrame;
    li.QuadPart = pf->AvgTimePerFrame;
    if (li.LowPart)
        pf->dwBitRate = MulDiv(pf->bmiHeader.biSizeImage, 80000000, li.LowPart);
#else
    pf->AvgTimePerFrame = 0;
    pf->dwBitRate = 0;
#endif
    pf->dwBitErrorRate = 0L;
	pf->rcSource.top = 0;
	pf->rcSource.left = 0;
	pf->rcSource.right = lpbi->biWidth;
	pf->rcSource.bottom = lpbi->biHeight;
	pf->rcTarget = pf->rcSource;
	pMediaType->SetType(&MEDIATYPE_Video);
    pMediaType->SetSampleSize(pf->bmiHeader.biSizeImage);
    pMediaType->SetFormatType(&FORMAT_VideoInfo);
    pMediaType->SetTemporalCompression(FALSE);

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, HEADER(pMediaType->Format())->biCompression, HEADER(pMediaType->Format())->biBitCount, HEADER(pMediaType->Format())->biWidth, HEADER(pMediaType->Format())->biHeight, HEADER(pMediaType->Format())->biSize));

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | SetMediaType | This method is called when
 *    the media type is established for the connection.
 *
 *  @parm const CMediaType* | pmt | Specifies a pointer to a media type
 *    object.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIOutputPin::SetMediaType(IN const CMediaType *pmt)
{
	HRESULT			Hr = NOERROR;
	ICDECOMPRESSEX	icDecompress;

	FX_ENTRY("CTAPIOutputPin::SetMediaType")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameter
	ASSERT(pmt);
	if (!pmt)
	{
		Hr = E_POINTER;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: null pointer argument", _fx_));
		goto MyExit;
	}

	// Save the output format
	if (FAILED(Hr = CBaseOutputPin::SetMediaType(pmt)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: couldn't set format", _fx_));
		goto MyExit;
	}

	if (m_pDecoderFilter->m_pMediaType)
		DeleteMediaType(m_pDecoderFilter->m_pMediaType);

	m_pDecoderFilter->m_pMediaType = CreateMediaType(&m_mt);

	icDecompress.lpbiSrc = HEADER(m_pDecoderFilter->m_pInput->m_mt.Format());
	icDecompress.lpbiDst = HEADER(m_pDecoderFilter->m_pMediaType->pbFormat);
	icDecompress.xSrc = ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcSource.left;
	icDecompress.ySrc = ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcSource.top;
	icDecompress.dxSrc = ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcSource.right - ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcSource.left;
	icDecompress.dySrc = ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcSource.bottom - ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcSource.top;
	icDecompress.xDst = ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcTarget.left;
	icDecompress.yDst = ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcTarget.top;
	icDecompress.dxDst = ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcTarget.right - ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcTarget.left;
	icDecompress.dyDst = ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcTarget.bottom - ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcTarget.top;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input:  biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression, HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biBitCount, HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biWidth, HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biHeight, HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biSize));
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SrcRc:  left = %ld, top = %ld, right = %ld, bottom = %ld", _fx_, ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcSource.left, ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcSource.top, ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcSource.right, ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcSource.bottom));
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output: biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, HEADER(m_pDecoderFilter->m_pMediaType->pbFormat)->biCompression, HEADER(m_pDecoderFilter->m_pMediaType->pbFormat)->biBitCount, HEADER(m_pDecoderFilter->m_pMediaType->pbFormat)->biWidth, HEADER(m_pDecoderFilter->m_pMediaType->pbFormat)->biHeight, HEADER(m_pDecoderFilter->m_pMediaType->pbFormat)->biSize));
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   DstRc:  left = %ld, top = %ld, right = %ld, bottom = %ld", _fx_, ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcTarget.left, ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcTarget.top, ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcTarget.right, ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcTarget.bottom));

	// Terminate current H.26X decompression configuration
	if (m_pDecoderFilter->m_fICMStarted)
	{
#if defined(ICM_LOGGING) && defined(DEBUG)
		OutputDebugString("CTAPIOutputPin::SetMediaType - ICM_DECOMPRESSEX_END\r\n");
#endif
		(*m_pDecoderFilter->m_pDriverProc)((DWORD)m_pDecoderFilter->m_pInstInfo, NULL, ICM_DECOMPRESSEX_END, 0L, 0L);
		m_pDecoderFilter->m_fICMStarted = FALSE;
	}

	// Create a new H.26X decompression configuration
#if defined(ICM_LOGGING) && defined(DEBUG)
	OutputDebugString("CTAPIOutputPin::SetMediaType - ICM_DECOMPRESSEX_BEGIN\r\n");
#endif
	if ((*m_pDecoderFilter->m_pDriverProc)((DWORD)m_pDecoderFilter->m_pInstInfo, NULL, ICM_DECOMPRESSEX_BEGIN, (long)&icDecompress, NULL) != ICERR_OK)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: ICDecompressBegin failed", _fx_));
		Hr = E_FAIL;
	}
	m_pDecoderFilter->m_fICMStarted = TRUE;

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | CheckMediaType | This method is used to
 *    verify that the output pin supports the media types.
 *
 *  @parm const CMediaType* | pmtOut | Specifies a pointer to an output
 *    media type object.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIOutputPin::CheckMediaType(IN const CMediaType* pmtOut)
{
	HRESULT			Hr = NOERROR;
	ICOPEN			icOpen;
	LPINST			pInstInfo;
	BOOL			fOpenedDecoder = FALSE;
    VIDEOINFO		*pDstInfo;
    VIDEOINFO		*pSrcInfo;
	ICDECOMPRESSEX	icDecompress = {0};

	FX_ENTRY("CTAPIOutputPin::CheckMediaType")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pmtOut);
	if (!m_pDecoderFilter->m_pInput->m_mt.pbFormat || !pmtOut || !pmtOut->Format())
	{
		Hr = E_POINTER;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		goto MyExit;
	}

	// We only support the MEDIATYPE_Video type and VIDEOINFOHEADER format type
	ASSERT(!(m_pDecoderFilter->m_pInput->m_mt.majortype != MEDIATYPE_Video || m_pDecoderFilter->m_pInput->m_mt.formattype != FORMAT_VideoInfo || *pmtOut->Type() != MEDIATYPE_Video || *pmtOut->FormatType() != FORMAT_VideoInfo));
	if (m_pDecoderFilter->m_pInput->m_mt.majortype != MEDIATYPE_Video || m_pDecoderFilter->m_pInput->m_mt.formattype != FORMAT_VideoInfo || *pmtOut->Type() != MEDIATYPE_Video || *pmtOut->FormatType() != FORMAT_VideoInfo)
	{
		Hr = E_INVALIDARG;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: input not a valid video format", _fx_));
		goto MyExit;
	}

	// We only support H.263, H.261, RTP packetized H.263 and RTP packetized H.261.
	ASSERT(HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression == FOURCC_M263 || HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression == FOURCC_M261 || HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression == FOURCC_R263 || HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression == FOURCC_R261);
	if (HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression != FOURCC_M263 && HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression != FOURCC_M261 && HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression != FOURCC_R263 && HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression != FOURCC_R261)
	{
		Hr = E_INVALIDARG;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: we only support H.263, H.261, RTP H.261, and RTP H.263", _fx_));
		goto MyExit;
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input:  biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression, HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biBitCount, HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biWidth, HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biHeight, HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biSize));
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SrcRc:  left = %ld, top = %ld, right = %ld, bottom = %ld", _fx_, ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource.left, ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource.top, ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource.right, ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource.bottom));
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output: biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, HEADER(pmtOut->Format())->biCompression, HEADER(pmtOut->Format())->biBitCount, HEADER(pmtOut->Format())->biWidth, HEADER(pmtOut->Format())->biHeight, HEADER(pmtOut->Format())->biSize));
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   DstRc:  left = %ld, top = %ld, right = %ld, bottom = %ld", _fx_, ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget.left, ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget.top, ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget.right, ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget.bottom));

	// Look for a decoder for this format
	if (m_pDecoderFilter->m_FourCCIn != HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression)
	{
#if DXMRTP <= 0
		// Load TAPIH26X.DLL and get a proc address
		if (!m_pDecoderFilter->m_hTAPIH26XDLL)
		{
			if (!(m_pDecoderFilter->m_hTAPIH26XDLL = LoadLibrary(TEXT("TAPIH26X"))))
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s: TAPIH26X.dll load failed!", _fx_));
				Hr = E_FAIL;
				goto MyError;
			}
		}
		if (!m_pDecoderFilter->m_pDriverProc)
		{
			if (!(m_pDecoderFilter->m_pDriverProc = (LPFNDRIVERPROC)GetProcAddress(m_pDecoderFilter->m_hTAPIH26XDLL, "DriverProc")))
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s: Couldn't find DriverProc on TAPIH26X.dll!", _fx_));
				Hr = E_FAIL;
				goto MyError;
			}
		}
#else
		if (!m_pDecoderFilter->m_pDriverProc)
		{
            m_pDecoderFilter->m_pDriverProc = H26XDriverProc; 
        }        
#endif
		// Load decoder
#if defined(ICM_LOGGING) && defined(DEBUG)
		OutputDebugString("CTAPIOutputPin::CheckMediaType - DRV_LOAD\r\n");
#endif
		if (!(*m_pDecoderFilter->m_pDriverProc)(NULL, NULL, DRV_LOAD, 0L, 0L))
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Failed to load decoder", _fx_));
			Hr = E_FAIL;
			goto MyError;
		}

		// Open decoder
		icOpen.fccHandler = HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression;
		icOpen.dwFlags = ICMODE_DECOMPRESS;
#if defined(ICM_LOGGING) && defined(DEBUG)
		OutputDebugString("CTAPIOutputPin::CheckMediaType - DRV_OPEN\r\n");
#endif
		if (!(pInstInfo = (LPINST)(*m_pDecoderFilter->m_pDriverProc)(NULL, NULL, DRV_OPEN, 0L, (LPARAM)&icOpen)))
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Failed to open decoder", _fx_));
			Hr = E_FAIL;
			goto MyError1;
		}

		if (pInstInfo)
			fOpenedDecoder = TRUE;
	}
	else
	{
		pInstInfo = m_pDecoderFilter->m_pInstInfo;
	}

	if (!pInstInfo)
	{
		Hr = VFW_E_NO_DECOMPRESSOR;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: can't open a decoder", _fx_));
		goto MyExit;
	}

	icDecompress.lpbiSrc = HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat);
	icDecompress.lpbiDst = HEADER(pmtOut->Format());
	icDecompress.xSrc = ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource.left;
	icDecompress.ySrc = ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource.top;
	icDecompress.dxSrc = ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource.right - ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource.left;
	icDecompress.dySrc = ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource.bottom - ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource.top;
	icDecompress.xDst = ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget.left;
	icDecompress.yDst = ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget.top;
	icDecompress.dxDst = ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget.right - ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget.left;
	icDecompress.dyDst = ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget.bottom - ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget.top;
#if 0
	if (icDecompress.lpbiDst->biCompression != FOURCC_YUY2)
	{
		Hr = VFW_E_TYPE_NOT_ACCEPTED;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: decoder rejected formats", _fx_));
		goto MyExit;
	}
#endif

#if defined(ICM_LOGGING) && defined(DEBUG)
	OutputDebugString("CTAPIOutputPin::CheckMediaType - ICM_DECOMPRESSEX_QUERY\r\n");
#endif
	if ((*m_pDecoderFilter->m_pDriverProc)((DWORD)pInstInfo, NULL, ICM_DECOMPRESSEX_QUERY, (long)&icDecompress, NULL))
	{
		Hr = VFW_E_TYPE_NOT_ACCEPTED;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: decoder rejected formats", _fx_));
	}

    // See if we can use direct draw.
    pDstInfo = (VIDEOINFO *)pmtOut->Format();
    pSrcInfo = (VIDEOINFO *)m_pDecoderFilter->m_pInput->m_mt.pbFormat;

    // First check that there is a non empty target and source rectangles.
    if (IsRectEmpty(&pDstInfo->rcSource) == TRUE)
	{
        ASSERT(IsRectEmpty(&pDstInfo->rcTarget) == TRUE);
        if (pSrcInfo->bmiHeader.biWidth != HEADER(pmtOut->Format())->biWidth || pSrcInfo->bmiHeader.biHeight != abs(HEADER(pmtOut->Format())->biHeight))
		{
			Hr = VFW_E_TYPE_NOT_ACCEPTED;
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: can't stretch formats", _fx_));
        }
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: Not using DDraw", _fx_));
        }
    }
	else if (!IsRectEmpty(&pDstInfo->rcTarget))
	{
		// Next, check that the source rectangle is the entire image.
		if (pDstInfo->rcSource.left == 0 && pDstInfo->rcSource.top == 0 && pDstInfo->rcSource.right == HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biWidth && pDstInfo->rcSource.bottom == HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biHeight)
		{
			// Now check that the target rectangles size is the same as the image size
			long lWidth = pDstInfo->rcTarget.right - pDstInfo->rcTarget.left;
			long lDepth = pDstInfo->rcTarget.bottom - pDstInfo->rcTarget.top;

			if (lWidth == HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biWidth && lDepth == HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biHeight)
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: Using DDraw", _fx_));
			}
			else
			{
				Hr = VFW_E_TYPE_NOT_ACCEPTED;
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid destination rectangle", _fx_));
			}
		}
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   SUCCESS: Not using DDraw", _fx_));
    }

	// If we just opened it, close it
	if (fOpenedDecoder)
	{
#if defined(ICM_LOGGING) && defined(DEBUG)
		OutputDebugString("CTAPIOutputPin::CheckMediaType - DRV_CLOSE\r\n");
		OutputDebugString("CTAPIOutputPin::CheckMediaType - DRV_FREE\r\n");
#endif
		(*m_pDecoderFilter->m_pDriverProc)((DWORD)pInstInfo, NULL, DRV_CLOSE, 0L, 0L);
		(*m_pDecoderFilter->m_pDriverProc)((DWORD)pInstInfo, NULL, DRV_FREE, 0L, 0L);
	}

	goto MyExit;

MyError1:
	if (m_pDecoderFilter->m_pDriverProc)
	{
#if defined(ICM_LOGGING) && defined(DEBUG)
		OutputDebugString("CTAPIOutputPin::CheckMediaType - DRV_FREE\r\n");
#endif
		(*m_pDecoderFilter->m_pDriverProc)(NULL, NULL, DRV_FREE, 0L, 0L);
	}
MyError:
	m_pDecoderFilter->m_pDriverProc = NULL;
#if DXMRTP <= 0
	if (m_pDecoderFilter->m_hTAPIH26XDLL)
		FreeLibrary(m_pDecoderFilter->m_hTAPIH26XDLL), m_pDecoderFilter->m_hTAPIH26XDLL = NULL;
#endif
MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end  hr=%x", _fx_, Hr));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | DecideBufferSize | This method is
 *    used to set the number and size of buffers required for transfer.
 *
 *  @parm IMemAllocator* | pAlloc | Specifies a pointer to the allocator
 *    assigned to the transfer.
 *
 *  @parm ALLOCATOR_PROPERTIES* | ppropInputRequest | Specifies a pointer to an
 *    <t ALLOCATOR_PROPERTIES> structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIOutputPin::DecideBufferSize(IN IMemAllocator *pAlloc, OUT ALLOCATOR_PROPERTIES *ppropInputRequest)
{
	HRESULT					Hr = NOERROR;
	ALLOCATOR_PROPERTIES	Actual;

	FX_ENTRY("CTAPIOutputPin::DecideBufferSize")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pAlloc);
	ASSERT(ppropInputRequest);
	if (!pAlloc || !ppropInputRequest)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(m_pDecoderFilter->m_pInstInfo);
	ASSERT(m_mt.pbFormat);
	if (!m_mt.pbFormat || !m_pDecoderFilter->m_pInstInfo)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid state", _fx_));
		Hr = E_UNEXPECTED;
		goto MyExit;
	}

	// Fix parameters
	if (ppropInputRequest->cBuffers == 0)
		ppropInputRequest->cBuffers = 1;

	// Set the size of buffers based on the expected output frame size
	ppropInputRequest->cbBuffer = m_mt.GetSampleSize();

	ASSERT(ppropInputRequest->cbBuffer);

	if (FAILED(Hr = pAlloc->SetProperties(ppropInputRequest, &Actual)) || Actual.cbBuffer < ppropInputRequest->cbBuffer)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Can't use allocator", _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: Using %d buffers of size %d", _fx_, Actual.cBuffers, Actual.cbBuffer));

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}


HRESULT CTAPIOutputPin::ChangeMediaTypeHelper(const CMediaType *pmt)
{
    HRESULT hr = m_Connected->ReceiveConnection(this, pmt);
    if(FAILED(hr)) {
        return hr;
    }

    hr = SetMediaType(pmt);
    if(FAILED(hr)) {
        return hr;
    }

    // Does this pin use the local memory transport?
    if(NULL != m_pInputPin) {
        // This function assumes that m_pInputPin and m_Connected are
        // two different interfaces to the same object.
        ASSERT(::IsEqualObject(m_Connected, m_pInputPin));

        ALLOCATOR_PROPERTIES apInputPinRequirements;
        apInputPinRequirements.cbAlign = 0;
        apInputPinRequirements.cbBuffer = 0;
        apInputPinRequirements.cbPrefix = 0;
        apInputPinRequirements.cBuffers = 0;

        m_pInputPin->GetAllocatorRequirements(&apInputPinRequirements);

        // A zero allignment does not make any sense.
        if(0 == apInputPinRequirements.cbAlign) {
            apInputPinRequirements.cbAlign = 1;
        }

        hr = m_pAllocator->Decommit();
        if(FAILED(hr)) {
            return hr;
        }

        hr = DecideBufferSize(m_pAllocator,  &apInputPinRequirements);
        if(FAILED(hr)) {
            return hr;
        }

        hr = m_pAllocator->Commit();
        if(FAILED(hr)) {
            return hr;
        }

        hr = m_pInputPin->NotifyAllocator(m_pAllocator, 0);
        if(FAILED(hr)) {
            return hr;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\outpin.h ===
/****************************************************************************
 *  @doc INTERNAL OUTPIN
 *
 *  @module OutPin.h | Header file for the <c CTAPIOutputPin> class methods
 *    used to implement the TAPI H.26X Video Decoder output pin.
 ***************************************************************************/

#ifndef _OUTPIN_H_
#define _OUTPIN_H_

/****************************************************************************
 *  @doc INTERNAL COUTPINCLASS
 *
 *  @class CTAPIOutputPin | This class implements the TAPI H.26X Video
 *    Decoder output pin.
 *
 *  @mdata CTAPIVDec* | CTAPIOutputPin | m_pDecoderFilter | Pointer to the
 *    filter that owns us.
 *
 *  @mdata REFERENCE_TIME | CTAPIOutputPin | m_MaxProcessingTime | Maximum
 *    processing time.
 *
 *  @mdata REFERENCE_TIME | CTAPIOutputPin | m_CurrentProcessingTime | Current
 *    processing time.
 *
 *  @mdata DWORD | CTAPIOutputPin | m_dwMaxCPULoad | Maximum CPU load.
 *
 *  @mdata DWORD | CTAPIOutputPin | m_dwCurrentCPULoad | Current CPU load.
 *
 *  @mdata REFERENCE_TIME | CTAPIOutputPin | m_AvgTimePerFrameRangeMin | Minimum
 *    target frame rate.
 *
 *  @mdata REFERENCE_TIME | CTAPIOutputPin | m_AvgTimePerFrameRangeMax | Maximum
 *    target frame rate.
 *
 *  @mdata REFERENCE_TIME | CTAPIOutputPin | m_AvgTimePerFrameRangeSteppingDelta | Target
 *    frame rate stepping delta.
 *
 *  @mdata REFERENCE_TIME | CTAPIOutputPin | m_AvgTimePerFrameRangeDefault | Target
 *    frame rate default.
 *
 *  @mdata REFERENCE_TIME | CTAPIOutputPin | m_MaxAvgTimePerFrame | Target
 *    frame rate.
 *
 *  @mdata REFERENCE_TIME | CTAPIOutputPin | m_CurrentAvgTimePerFrame | Current
 *    frame rate.
 *
 *  @mdata DWORD | CTAPIOutputPin | m_dwNumFramesDelivered | Counts number of
 *    frames delivered, reset every second or so.
 *
 *  @mdata DWORD | CTAPIOutputPin | m_dwNumFramesDecompressed | Counts number of
 *    frames decompressed, reset every second or so.
 ***************************************************************************/
#if 0
class CTAPIOutputPin : public CBaseOutputPinEx
#else
class CTAPIOutputPin : public CBaseOutputPin
#endif
#ifdef USE_CPU_CONTROL
, public ICPUControl
#endif
, public IH245DecoderCommand
, public IFrameRateControl
#ifdef USE_PROPERTY_PAGES
,public ISpecifyPropertyPages
#endif
{
	public:
	DECLARE_IUNKNOWN
	STDMETHODIMP NonDelegatingQueryInterface(IN REFIID riid, OUT PVOID *ppv);
	CTAPIOutputPin(IN TCHAR *pObjectName, IN CTAPIVDec *pDecoderFilter, IN CCritSec *pLock, IN HRESULT *pHr, IN LPCWSTR pName);
	virtual ~CTAPIOutputPin();

	// CBasePin stuff
	HRESULT SetMediaType(IN const CMediaType *pmt);
	HRESULT GetMediaType(IN int iPosition, OUT CMediaType *pMediaType);
	HRESULT CheckMediaType(IN const CMediaType *pMediatype);

	// CBaseOutputPin stuff
	HRESULT DecideBufferSize(IMemAllocator * pAlloc, ALLOCATOR_PROPERTIES * ppropInputRequest);

    // helper method for changing media type.
    HRESULT ChangeMediaTypeHelper(const CMediaType *pmt);

	// Inherited from IQualityControl via CBasePin
	STDMETHODIMP Notify(IBaseFilter *pSender, Quality q) {return S_OK;};

#ifdef USE_PROPERTY_PAGES
	// ISpecifyPropertyPages methods
	STDMETHODIMP GetPages(OUT CAUUID *pPages);
#endif

#ifdef USE_CPU_CONTROL
	// Implement ICPUControl
	STDMETHODIMP GetRange(IN CPUControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags);
	STDMETHODIMP Set(IN CPUControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags);
	STDMETHODIMP Get(IN CPUControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags);
#endif

	// Implement IFrameRateControl
	STDMETHODIMP GetRange(IN FrameRateControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags);
	STDMETHODIMP Set(IN FrameRateControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags);
	STDMETHODIMP Get(IN FrameRateControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags);

	// Implement IH245DecoderCommand
	STDMETHODIMP videoFreezePicture();

	protected:

	friend class CTAPIVDec;

	CTAPIVDec *m_pDecoderFilter;

#ifdef USE_CPU_CONTROL
	// CPU control
	LONG  m_lMaxProcessingTime;
	LONG  m_lCurrentProcessingTime;
	LONG  m_lMaxCPULoad;
	LONG  m_lCurrentCPULoad;
#endif

	// Frame rate control
	LONG m_lAvgTimePerFrameRangeMin;
	LONG m_lAvgTimePerFrameRangeMax;
	LONG m_lAvgTimePerFrameRangeSteppingDelta;
	LONG m_lAvgTimePerFrameRangeDefault;
	LONG m_lMaxAvgTimePerFrame;
	LONG m_lCurrentAvgTimePerFrame;
};

#endif // _OUTPIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\outpinp.cpp ===
/****************************************************************************
 *  @doc INTERNAL OUTPINP
 *
 *  @module OutPinP.cpp | Source file for the <c COutputPinProperty>
 *    class used to implement a property page to test the TAPI interfaces
 *    <i IFrameRateControl> and <i ICPUControl>.
 *
 *  @comm This code is only compiled if USE_PROPERTY_PAGES is defined.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_PROPERTY_PAGES

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc void | COutputPinProperty | COutputPinProperty | This
 *    method is the constructor for control property objects. It
 *    calls the base class constructor, calls InitCommonControlsEx, and saves
 *    a pointer to the control interface(s).
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    property progress bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the Ks property.
 *
 *  @parm IFrameRateControl* | pIFrameRateControl | Specifies a pointer to the
 *    <i IFrameRateControl> interface.
 *
 *  @parm ICPUControl* | pICPUControl | Specifies a pointer to the
 *    <i ICPUControl> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
#ifdef USE_CPU_CONTROL
COutputPinProperty::COutputPinProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, IFrameRateControl *pIFrameRateControl, ICPUControl *pICPUControl)
#else
COutputPinProperty::COutputPinProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, IFrameRateControl *pIFrameRateControl)
#endif
: CPropertyEditor(hDlg, IDLabel, IDMinControl, IDMaxControl, IDDefaultControl, IDStepControl, IDEditControl, IDTrackbarControl, IDProgressControl, IDProperty, IDAutoControl)
{
	INITCOMMONCONTROLSEX cc;

	FX_ENTRY("COutputPinProperty::COutputPinProperty")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
	cc.dwICC  = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

	InitCommonControlsEx(&cc);

	// It's fine if the interface pointer is NULL, we'll grey the
	// associated items in the property page
	m_pIFrameRateControl = pIFrameRateControl;
#ifdef USE_CPU_CONTROL
	m_pICPUControl   = pICPUControl;
#endif

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc void | COutputPinProperty | ~COutputPinProperty | This
 *    method is the destructor for camera control property objects. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
COutputPinProperty::~COutputPinProperty()
{
	FX_ENTRY("COutputPinProperty::~COutputPinProperty")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc HRESULT | COutputPinProperty | GetValue | This method queries for
 *    the value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COutputPinProperty::GetValue()
{
	HRESULT Hr = NOERROR;
	LONG CurrentValue;

	FX_ENTRY("COutputPinProperty::GetValue")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	switch (m_IDProperty)
	{									
		case CurrentFrameRate:
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->Get(FrameRateControl_Current, &CurrentValue, (TAPIControlFlags *)&m_CurrentFlags)))
			{
				if (CurrentValue)
					m_CurrentValue = (LONG)(10000000 / CurrentValue);
				else
					m_CurrentValue = 0;
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pAvgTimePerFrame=%ld"), _fx_, CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
#ifdef USE_CPU_CONTROL
		case CurrentDecodingTime:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->Get(CPUControl_CurrentProcessingTime, &CurrentValue, (TAPIControlFlags *)&m_CurrentFlags)))
			{
				// Displayed in ms instead of 100ns
				m_CurrentValue = CurrentValue / 10000;
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pdwCurrentProcessingTime=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case CurrentCPULoad:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->Get(CPUControl_CurrentCPULoad, &m_CurrentValue, (TAPIControlFlags *)&m_CurrentFlags)))
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pdwCurrentCPULoad=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
#endif
		case TargetFrameRate:
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->Get(FrameRateControl_Maximum, &CurrentValue, (TAPIControlFlags *)&m_CurrentFlags)))
			{
				if (CurrentValue)
					m_CurrentValue = (LONG)(10000000 / CurrentValue);
				else
					m_CurrentValue = 0;
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pAvgTimePerFrame=%ld"), _fx_, CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
#ifdef USE_CPU_CONTROL
		case TargetDecodingTime:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->Get(CPUControl_MaxProcessingTime, &CurrentValue, (TAPIControlFlags *)&m_CurrentFlags)))
			{
				// Displayed in ms instead of 100ns
				m_CurrentValue = CurrentValue / 10000;
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pdwProcessingTime=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case TargetCPULoad:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->Get(CPUControl_MaxCPULoad, &m_CurrentValue, (TAPIControlFlags *)&m_CurrentFlags)))
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pdwCPULoad=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
#endif
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Unknown property"), _fx_));
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc HRESULT | COutputPinProperty | SetValue | This method sets the
 *    value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COutputPinProperty::SetValue()
{
	HRESULT Hr = E_NOTIMPL;
	LONG CurrentValue;

	FX_ENTRY("COutputPinProperty::SetValue")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	switch (m_IDProperty)
	{
		case TargetFrameRate:
			if (m_CurrentValue)
				CurrentValue = 10000000L / m_CurrentValue;
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->Set(FrameRateControl_Maximum, CurrentValue, (TAPIControlFlags)m_CurrentFlags)))
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: AvgTimePerFrame=%ld"), _fx_, CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
#ifdef USE_CPU_CONTROL
		case TargetDecodingTime:
			// Displayed in ms instead of 100ns
			CurrentValue = m_CurrentValue * 10000;
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->Set(CPUControl_MaxProcessingTime, CurrentValue, (TAPIControlFlags)m_CurrentFlags)))
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: dwMaxDecodingTime=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case TargetCPULoad:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->Set(CPUControl_MaxCPULoad, m_CurrentValue, (TAPIControlFlags)m_CurrentFlags)))
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: dwMaxCPULoad=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
#endif
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Unknown property"), _fx_));
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc HRESULT | COutputPinProperty | GetRange | This method retrieves
 *    the range information of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COutputPinProperty::GetRange()
{
	HRESULT Hr = E_NOTIMPL;
	LONG Min;
	LONG Max;
	LONG SteppingDelta;
	LONG Default;

	FX_ENTRY("COutputPinProperty::GetRange")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	switch (m_IDProperty)
	{
		case TargetFrameRate:
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->GetRange(FrameRateControl_Maximum, &Min, &Max, &SteppingDelta, &Default, (TAPIControlFlags *)&m_CapsFlags)))
			{
				if (Min)
					m_Max = (LONG)(10000000 / Min);
				else
					m_Max = 0;
				if (Max)
					m_Min = (LONG)(10000000 / Max);
				else
					m_Min = 0;
				if (SteppingDelta)
					m_SteppingDelta = (m_Max - m_Min) / (LONG)((Max - Min) / SteppingDelta);
				else
					m_SteppingDelta = 0;
				if (Default)
					m_DefaultValue = (LONG)(10000000 / Default);
				else
					m_DefaultValue = 0;
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pMin=%ld, *pMax=%ld, *pSteppingDelta=%ld, *pDefault=%ld"), _fx_, Min, Max, SteppingDelta, Default));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
#ifdef USE_CPU_CONTROL
		case TargetDecodingTime:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->GetRange(CPUControl_MaxProcessingTime, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, (TAPIControlFlags *)&m_CapsFlags)))
			{
				// Displayed in ms instead of 100ns
				m_Min /= 10000;
				m_Max /= 10000;
				m_SteppingDelta /= 10000;
				m_DefaultValue /= 10000;
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case TargetCPULoad:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->GetRange(CPUControl_MaxCPULoad, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, (TAPIControlFlags *)&m_CapsFlags)))
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
#endif
		case CurrentFrameRate:
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->GetRange(FrameRateControl_Current, &Min, &Max, &SteppingDelta, &Default, (TAPIControlFlags *)&m_CapsFlags)))
			{
				if (Min)
					m_Max = (LONG)(10000000 / Min);
				else
					m_Max = 0;
				if (Max)
					m_Min = (LONG)(10000000 / Max);
				else
					m_Min = 0;
				if (SteppingDelta)
					m_SteppingDelta = (m_Max - m_Min) / (LONG)((Max - Min) / SteppingDelta);
				else
					m_SteppingDelta = 0;
				if (Default)
					m_DefaultValue = (LONG)(10000000 / Default);
				else
					m_DefaultValue = 0;
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pMin=%ld, *pMax=%ld, *pSteppingDelta=%ld, *pDefault=%ld"), _fx_, Min, Max, SteppingDelta, Default));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
#ifdef USE_CPU_CONTROL
		case CurrentDecodingTime:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->GetRange(CPUControl_CurrentProcessingTime, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, (TAPIControlFlags *)&m_CapsFlags)))
			{
				// Displayed in ms instead of 100ns
				m_Min /= 10000;
				m_Max /= 10000;
				m_SteppingDelta /= 10000;
				m_DefaultValue /= 10000;
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case CurrentCPULoad:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->GetRange(CPUControl_CurrentCPULoad, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, (TAPIControlFlags *)&m_CapsFlags)))
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
#endif
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Unknown property"), _fx_));
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc CUnknown* | COutputPinProperties | CreateInstance | This
 *    method is called by DShow to create an instance of a
 *    Property Page. It is referred to in the global structure <t g_Templates>.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Returns a pointer to the nondelegating CUnknown portion of the
 *    object, or NULL otherwise.
 ***************************************************************************/
CUnknown* CALLBACK COutputPinPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr) 
{
	CUnknown *pUnknown = (CUnknown *)NULL;

	FX_ENTRY("COutputPinPropertiesCreateInstance")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	ASSERT(pHr);
	if (!pHr)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: invalid input parameter"), _fx_));
		goto MyExit;
	}

	if (!(pUnknown = new COutputPinProperties(pUnkOuter, pHr)))
	{
		*pHr = E_OUTOFMEMORY;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: new COutputPinProperties failed"), _fx_));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: new COutputPinProperties created"), _fx_));
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return pUnknown;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc void | COutputPinProperties | COutputPinProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Nada.
 ***************************************************************************/
COutputPinProperties::COutputPinProperties(LPUNKNOWN pUnk, HRESULT *pHr) : CBasePropertyPage(NAME("Output Pin Property Page"), pUnk, IDD_OutputPinProperties, IDS_OUTPUTPINPROPNAME)
{
	FX_ENTRY("COutputPinProperties::COutputPinProperties")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	m_pIFrameRateControl = NULL;
#ifdef USE_CPU_CONTROL
	m_pICPUControl = NULL;
#endif
	m_pIH245DecoderCommand = NULL;
	m_NumProperties = NUM_OUTPUT_PIN_PROPERTIES;
	m_fActivated = FALSE;

	for (int i = 0; i < m_NumProperties; i++)
		m_Controls[i] = NULL;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc void | COutputPinProperties | ~COutputPinProperties | This
 *    method is the destructor for camera control property page. It
 *    simply calls the base class destructor after deleting all the controls.
 *
 *  @rdesc Nada.
 ***************************************************************************/
COutputPinProperties::~COutputPinProperties()
{
	int		j;

	FX_ENTRY("COutputPinProperties::~COutputPinProperties")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX"), _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: control already freed"), _fx_));
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc HRESULT | COutputPinProperties | OnConnect | This
 *    method is called when the property page is connected to the filter.
 *
 *  @parm LPUNKNOWN | pUnknown | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COutputPinProperties::OnConnect(IUnknown *pUnk)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("COutputPinProperties::OnConnect")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	ASSERT(pUnk);
	if (!pUnk)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: invalid input parameter"), _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the frame rate control interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(IFrameRateControl),(void **)&m_pIFrameRateControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_pIFrameRateControl=0x%08lX"), _fx_, m_pIFrameRateControl));
	}
	else
	{
		m_pIFrameRateControl = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: IOCTL failed Hr=0x%08lX"), _fx_, Hr));
	}

#ifdef USE_CPU_CONTROL
	// Get the bitrate control interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(ICPUControl),(void **)&m_pICPUControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_pICPUControl=0x%08lX"), _fx_, m_pICPUControl));
	}
	else
	{
		m_pICPUControl = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: IOCTL failed Hr=0x%08lX"), _fx_, Hr));
	}
#endif

	// Get the H.245 decoder command interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(IH245DecoderCommand),(void **)&m_pIH245DecoderCommand)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_pIH245DecoderCommand=0x%08lX"), _fx_, m_pIH245DecoderCommand));
	}
	else
	{
		m_pIH245DecoderCommand = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: IOCTL failed Hr=0x%08lX"), _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers. We'll just grey the controls in the property page
	// to make it clear to the user that they can't control those properties on the device
	Hr = NOERROR;

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc HRESULT | COutputPinProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COutputPinProperties::OnDisconnect()
{
	FX_ENTRY("COutputPinProperties::OnDisconnect")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Validate input parameters: we seem to get called several times here
	// Make sure the interface pointer is still valid
	if (!m_pIFrameRateControl)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pIFrameRateControl->Release();
		m_pIFrameRateControl = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: releasing m_pIFrameRateControl"), _fx_));
	}

#ifdef USE_CPU_CONTROL
	if (!m_pICPUControl)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pICPUControl->Release();
		m_pICPUControl = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: releasing m_pICPUControl"), _fx_));
	}
#endif

	if (!m_pIH245DecoderCommand)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pIH245DecoderCommand->Release();
		m_pIH245DecoderCommand = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: releasing m_pIH245DecoderCommand"), _fx_));
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc HRESULT | COutputPinProperties | OnActivate | This
 *    method is called when the property page is activated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COutputPinProperties::OnActivate()
{
	HRESULT	Hr = E_OUTOFMEMORY;
	int		j;

	FX_ENTRY("COutputPinProperties::OnActivate")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Create the controls for the properties
#ifdef USE_CPU_CONTROL
	if (!(m_Controls[0] = new COutputPinProperty(m_hwnd, IDC_FrameRateControl_Label, 0, 0, 0, 0, IDC_FrameRateControl_Actual, 0, IDC_FrameRateControl_Meter, CurrentFrameRate, 0, m_pIFrameRateControl, m_pICPUControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: mew m_Controls[CurrentFrameRate] failed - Out of memory"), _fx_));
		goto MyExit;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[CurrentFrameRate]=0x%08lX"), _fx_, m_Controls[0]));
	}

	if (!(m_Controls[1] = new COutputPinProperty(m_hwnd, IDC_MaxProcessingTime_Label, 0, 0, 0, 0, IDC_MaxProcessingTime_Actual, 0, IDC_MaxProcessingTime_Meter, CurrentDecodingTime, 0, m_pIFrameRateControl, m_pICPUControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: mew m_Controls[CurrentDecodingTime] failed - Out of memory"), _fx_));
		goto MyError0;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[CurrentDecodingTime]=0x%08lX"), _fx_, m_Controls[1]));
	}

	if (!(m_Controls[2] = new COutputPinProperty(m_hwnd, IDC_CPULoad_Label, 0, 0, 0, 0, IDC_CPULoad_Actual, 0, IDC_CPULoad_Meter, CurrentCPULoad, 0, m_pIFrameRateControl, m_pICPUControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: mew m_Controls[CurrentCPULoad] failed - Out of memory"), _fx_));
		goto MyError1;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[CurrentCPULoad]=0x%08lX"), _fx_, m_Controls[2]));
	}

	if (!(m_Controls[3] = new COutputPinProperty(m_hwnd, IDC_FrameRateControl_Label, IDC_FrameRateControl_Minimum, IDC_FrameRateControl_Maximum, IDC_FrameRateControl_Default, IDC_FrameRateControl_Stepping, IDC_FrameRateControl_Edit, IDC_FrameRateControl_Slider, 0, TargetFrameRate, 0, m_pIFrameRateControl, m_pICPUControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: mew m_Controls[TargetFrameRate] failed - Out of memory"), _fx_));
		goto MyError2;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[TargetFrameRate]=0x%08lX"), _fx_, m_Controls[3]));
	}

	if (!(m_Controls[4] = new COutputPinProperty(m_hwnd, IDC_MaxProcessingTime_Label, IDC_MaxProcessingTime_Minimum, IDC_MaxProcessingTime_Maximum, IDC_MaxProcessingTime_Default, IDC_MaxProcessingTime_Stepping, IDC_MaxProcessingTime_Edit, IDC_MaxProcessingTime_Slider, 0, TargetDecodingTime, 0, m_pIFrameRateControl, m_pICPUControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: mew m_Controls[TargetDecodingTime] failed - Out of memory"), _fx_));
		goto MyError3;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[TargetDecodingTime]=0x%08lX"), _fx_, m_Controls[4]));
	}

	if (!(m_Controls[5] = new COutputPinProperty(m_hwnd, IDC_CPULoad_Label, IDC_CPULoad_Minimum, IDC_CPULoad_Maximum, IDC_CPULoad_Default, IDC_CPULoad_Stepping, IDC_CPULoad_Edit, IDC_CPULoad_Slider, 0, TargetCPULoad, 0, m_pIFrameRateControl, m_pICPUControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: mew m_Controls[TargetCPULoad] failed - Out of memory"), _fx_));
		goto MyError4;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[TargetCPULoad]=0x%08lX"), _fx_, m_Controls[5]));
	}
#else
	if (!(m_Controls[0] = new COutputPinProperty(m_hwnd, IDC_FrameRateControl_Label, 0, 0, 0, 0, IDC_FrameRateControl_Actual, 0, IDC_FrameRateControl_Meter, CurrentFrameRate, 0, m_pIFrameRateControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: mew m_Controls[CurrentFrameRate] failed - Out of memory"), _fx_));
		goto MyExit;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[CurrentFrameRate]=0x%08lX"), _fx_, m_Controls[0]));
	}

	if (!(m_Controls[1] = new COutputPinProperty(m_hwnd, IDC_FrameRateControl_Label, IDC_FrameRateControl_Minimum, IDC_FrameRateControl_Maximum, IDC_FrameRateControl_Default, IDC_FrameRateControl_Stepping, IDC_FrameRateControl_Edit, IDC_FrameRateControl_Slider, 0, TargetFrameRate, 0, m_pIFrameRateControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: mew m_Controls[TargetFrameRate] failed - Out of memory"), _fx_));
		goto MyError0;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[TargetFrameRate]=0x%08lX"), _fx_, m_Controls[1]));
	}
#endif

	// Initialize all the controls. If the initialization fails, it's Ok. It just means
	// that the TAPI control interface isn't implemented by the filter. The dialog item
	// in the property page will be greyed, showing this to the user.
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j]->Init())
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[%ld]->Init()"), _fx_, j));
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: m_Controls[%ld]->Init() failed"), _fx_, j));
		}
	}

	Hr = NOERROR;
	goto MyExit;

#ifdef USE_CPU_CONTROL
MyError4:
	if (m_Controls[4])
		delete m_Controls[4], m_Controls[4] = NULL;
MyError3:
	if (m_Controls[3])
		delete m_Controls[3], m_Controls[3] = NULL;
MyError2:
	if (m_Controls[2])
		delete m_Controls[2], m_Controls[2] = NULL;
MyError1:
	if (m_Controls[1])
		delete m_Controls[1], m_Controls[1] = NULL;
#endif
MyError0:
	if (m_Controls[0])
		delete m_Controls[0], m_Controls[0] = NULL;
MyExit:
	m_fActivated = TRUE;
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc HRESULT | COutputPinProperties | OnDeactivate | This
 *    method is called when the property page is dismissed.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COutputPinProperties::OnDeactivate()
{
	int		j;

	FX_ENTRY("COutputPinProperties::OnDeactivate")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX"), _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: control already freed"), _fx_));
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	m_fActivated = FALSE;
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc HRESULT | COutputPinProperties | OnApplyChanges | This
 *    method is called when the user applies changes to the property page.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COutputPinProperties::OnApplyChanges()
{
	HRESULT	Hr = NOERROR;

	FX_ENTRY("COutputPinProperties::OnApplyChanges")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	for (int j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			if (m_Controls[j]->HasChanged())
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: calling m_Controls[%ld]=0x%08lX->OnApply"), _fx_, j, m_Controls[j]));
				m_Controls[j]->OnApply();
			}
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: can't call m_Controls[%ld]=NULL->OnApply"), _fx_, j));
			Hr = E_UNEXPECTED;
			break;
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc BOOL | COutputPinProperties | OnReceiveMessage | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
BOOL COutputPinProperties::OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
		case WM_INITDIALOG:
			return TRUE; // Don't call setfocus

		case WM_TIMER:
			if (m_fActivated)
			{
				// Update the Vu-Meters
				for (j = 0; j < m_NumProperties; j++)
				{
					ASSERT(m_Controls[j]);
					if (m_Controls[j]->GetProgressHWnd())
					{
						m_Controls[j]->UpdateProgress();
					}
				}
			}
			break;

		case WM_HSCROLL:
		case WM_VSCROLL:
			if (m_fActivated)
			{
				// Process all of the Trackbar messages
				for (j = 0; j < m_NumProperties; j++)
				{
					ASSERT(m_Controls[j]);
					if (m_Controls[j]->GetTrackbarHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnScroll(uMsg, wParam, lParam);
						SetDirty();
					}
				}
				// OnApplyChanges();
			}
			break;

		case WM_COMMAND:

			// This message gets sent even before OnActivate() has been
			// called(!). We need to test and make sure the controls have
			// beeen initialized before we can use them.

			if (m_fActivated)
			{
				// Process all of the auto checkbox messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetAutoHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnAuto(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				// Process all of the edit box messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetEditHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnEdit(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				switch (LOWORD(wParam))
				{
					case IDC_CONTROL_DEFAULT:
						for (j = 0; j < m_NumProperties; j++)
						{
							if (m_Controls[j])
								m_Controls[j]->OnDefault();
						}
						break;
					case IDC_Freeze_Picture_Request:
						if (m_pIH245DecoderCommand)
							m_pIH245DecoderCommand->videoFreezePicture();
						break;
					default:
						break;
				}

			// OnApplyChanges();
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc BOOL | COutputPinProperties | SetDirty | This
 *    method notifies the property page site of changes.
 *
 *  @rdesc Nada.
 ***************************************************************************/
void COutputPinProperties::SetDirty()
{
	m_bDirty = TRUE;
	if (m_pPageSite)
		m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}

#endif // USE_PROPERTY_PAGES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\outpinp.h ===
/****************************************************************************
 *  @doc INTERNAL OUTPINP
 *
 *  @module OutPinP.h | Header file for the <c COutputPinProperty>
 *    class used to implement a property page to test the TAPI interfaces
 *    <i IFrameRateControl> and <i ICPUControl>.
 *
 *  @comm This code is only compiled if USE_PROPERTY_PAGES is defined.
 ***************************************************************************/

#ifndef _OUTPINP_H_
#define _OUTPINP_H_

#ifdef USE_PROPERTY_PAGES

#ifdef USE_CPU_CONTROL
#define NUM_OUTPUT_PIN_PROPERTIES 6
#define CurrentFrameRate     0
#define CurrentDecodingTime  1
#define CurrentCPULoad       2
#define TargetFrameRate      3
#define TargetDecodingTime   4
#define TargetCPULoad        5
#else
#define NUM_OUTPUT_PIN_PROPERTIES 2
#define CurrentFrameRate     0
#define TargetFrameRate      1
#endif

/****************************************************************************
 *  @doc INTERNAL COUTPINPCLASS
 *
 *  @class COutputPinProperty | This class implements handling of a
 *    single property in a property page.
 *
 *  @mdata int | COutputPinProperty | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata IFrameRateControl * | COutputPinProperty | m_pIFrameRateControl | Pointer
 *    to the <i IFrameRateControl> interface.
 *
 *  @mdata ICPUControl * | COutputPinProperty | m_pICPUControl | Pointer
 *    to the <i ICPUControl> interface.
 *
 *  @comm This code tests the TAPI Video Decoder Filter <i IFrameRateControl>
 *     and <i ICPUControl> implementation. This code is only compiled if
 *     USE_PROPERTY_PAGES is defined.
***************************************************************************/
class COutputPinProperty : public CPropertyEditor 
{
	public:
#ifdef USE_CPU_CONTROL
	COutputPinProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, IFrameRateControl *pIFrameRateControl, ICPUControl *pICPUControl);
#else
	COutputPinProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, IFrameRateControl *pIFrameRateControl);
#endif
	~COutputPinProperty ();

	// CPropertyEditor base class pure virtual overrides
	HRESULT GetValue();
	HRESULT SetValue();
	HRESULT GetRange();
	BOOL CanAutoControl(void);
	BOOL GetAuto(void);
	BOOL SetAuto(BOOL fAuto);

	private:
	IFrameRateControl *m_pIFrameRateControl;
#ifdef USE_CPU_CONTROL
	ICPUControl *m_pICPUControl;
#endif
};

/****************************************************************************
 *  @doc INTERNAL COUTPINPCLASS
 *
 *  @class COutputPinProperties | This class runs a property page to test
 *    the TAPI Video Decoder Filter <i IFrameRateControl> and <i ICPUControl>
 *    implementation.
 *
 *  @mdata int | COutputPinProperties | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata IFrameRateControl * | COutputPinProperties | m_pIFrameRateControl | Pointer
 *    to the <i IFrameRateControl> interface.
 *
 *  @mdata ICPUControl * | COutputPinProperties | m_pICPUControl | Pointer
 *    to the <i ICPUControl> interface.
 *
 *  @mdata COutputPinProperty * | COutputPinProperties | m_Controls[NUM_OUTPUT_PIN_PROPERTIES] | Array
 *    of properties.
 *
 *  @comm This code tests the TAPI Video Decoder Filter <i IFrameRateControl>
 *     and <i ICPUControl> implementation. This code is only compiled if
 *     USE_PROPERTY_PAGES is defined.
***************************************************************************/
class COutputPinProperties : public CBasePropertyPage
{
	public:
	COutputPinProperties(LPUNKNOWN pUnk, HRESULT *pHr);
	~COutputPinProperties();

	HRESULT OnConnect(IUnknown *pUnk);
	HRESULT OnDisconnect();
	HRESULT OnActivate();
	HRESULT OnDeactivate();
	HRESULT OnApplyChanges();
	BOOL    OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	private:

	void SetDirty();

	int m_NumProperties;
	IFrameRateControl *m_pIFrameRateControl;
#ifdef USE_CPU_CONTROL
	ICPUControl *m_pICPUControl;
#endif
	IH245DecoderCommand *m_pIH245DecoderCommand;
	BOOL m_fActivated;
	COutputPinProperty *m_Controls[NUM_OUTPUT_PIN_PROPERTIES];
};

#endif // USE_PROPERTY_PAGES

#endif // _OUTPINP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\procutil.h ===
/****************************************************************************
 *  @doc INTERNAL PROCUTIL
 *
 *  @module ProcUtil.h | Header file for the Processor ID and Speed routines.
 *
 *  @comm Comes from the NM code base.
 ***************************************************************************/

#ifndef _PROCUTIL_H_
#define _PROCUTIL_H_

HRESULT __stdcall GetNormalizedCPUSpeed (int *pdwNormalizedSpeed);

typedef DWORD (CALLBACK *INEXCEPTION)(LPEXCEPTION_RECORD per, PCONTEXT pctx);
typedef DWORD (CALLBACK *EXCEPTPROC)(void* pv);

// CallWithSEH is a utility function to call a function with structured exception handling
extern "C" DWORD WINAPI CallWithSEH(EXCEPTPROC pfn, void* pv, INEXCEPTION InException);
extern "C" WORD _cdecl is_cyrix(void);
extern "C" DWORD _cdecl get_nxcpu_type(void);

#endif // _PROCUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\propedit.h ===
/****************************************************************************
 *  @doc INTERNAL PROPEDIT
 *
 *  @module PropEdit.h | Header file for the <c CPropertyEditor>
 *    class used to implement behavior of a single property to be displayed
 *    in a property page.
 *
 *  @comm This code tests the Ks interface handlers. This code is only
 *    compiled if USE_PROPERTY_PAGES is defined.
 ***************************************************************************/

#ifndef _PROPEDIT_H_
#define _PROPEDIT_H_

#ifdef USE_PROPERTY_PAGES

/****************************************************************************
 *  @doc INTERNAL CPROPEDITCLASS
 *
 *  @class CPropertyEditor | This class implements behavior of a single
 *    property to be displayed in a property page.
 *
 *  @mdata ULONG | CPropertyEditor | m_IDProperty | Property ID
 *
 *  @mdata LONG | CPropertyEditor | m_CurrentValue | Property current value
 *
 *  @mdata LONG | CPropertyEditor | m_Min | Property minimum value
 *
 *  @mdata LONG | CPropertyEditor | m_Max | Property maximum value
 *
 *  @mdata LONG | CPropertyEditor | m_SteppingDelta | Property stepping delta
 *
 *  @mdata LONG | CPropertyEditor | m_DefaultValue | Property default value
 *
 *  @mdata BOOL | CPropertyEditor | m_Active | Set to TRUE after all property values have been initialized
 *
 *  @mdata LONG | CPropertyEditor | m_OriginalValue | Backup of the original value
 *
 *  @mdata HWND | CPropertyEditor | m_hDlg | Window handle to the Parent dialog
 *
 *  @mdata HWND | CPropertyEditor | m_hWndMin | Window handle to the Minimum dialog item
 *
 *  @mdata HWND | CPropertyEditor | m_hWndMax | Window handle to the Maximum dialog item
 *
 *  @mdata HWND | CPropertyEditor | m_hWndDefault | Window handle to the Default dialog item
 *
 *  @mdata HWND | CPropertyEditor | m_hWndStep | Window handle to the Stepping Delta dialog item
 *
 *  @mdata HWND | CPropertyEditor | m_hWndEdit | Window handle to the Target dialog item
 *
 *  @mdata HWND | CPropertyEditor | m_hWndTrackbar | Window handle to the slide bar
 *
 *  @mdata HWND | CPropertyEditor | m_hWndProgress | Window handle to the progress bar
 *
 *  @mdata ULONG | CPropertyEditor | m_IDLabel | Resource ID of the property label
 *
 *  @mdata ULONG | CPropertyEditor | m_IDMinControl | Resource ID of the Minimum dialog item
 *
 *  @mdata ULONG | CPropertyEditor | m_IDMaxControl | Resource ID of the Maximum dialog item
 *
 *  @mdata ULONG | CPropertyEditor | m_IDStepControl | Resource ID of the Stepping Delta dialog item
 *
 *  @mdata ULONG | CPropertyEditor | m_IDDefaultControl | Resource ID of the Default dialog item
 *
 *  @mdata ULONG | CPropertyEditor | m_IDEditControl | Resource ID of the Target dialog item
 *
 *  @mdata ULONG | CPropertyEditor | m_IDTrackbarControl | Resource ID of the slide bar
 *
 *  @mdata ULONG | CPropertyEditor | m_IDProgressControl | Resource ID of the progress bar
 ***************************************************************************/
class CPropertyEditor
{
	public:
	CPropertyEditor(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl);
	virtual ~CPropertyEditor();

	BOOL Init();

	HWND GetTrackbarHWnd();
	HWND GetProgressHWnd();
	HWND GetEditHWnd();
	HWND GetAutoHWnd();

	BOOL UpdateEditBox();
	BOOL UpdateTrackbar();
	BOOL UpdateProgress();
	BOOL UpdateAuto();

	BOOL OnApply();
	BOOL OnDefault();
	BOOL OnScroll(ULONG nCommand, WPARAM wParam, LPARAM lParam);
	BOOL OnEdit(ULONG nCommand, WPARAM wParam, LPARAM lParam);
	BOOL OnAuto(ULONG nCommand, WPARAM wParam, LPARAM lParam);
	BOOL HasChanged();

	protected:

	BOOL CanAutoControl(void);
	BOOL GetAuto(void);
	BOOL SetAuto(BOOL fAuto);

	// Pure virtual functions to set/get actual property values, and the ranges
	virtual HRESULT GetValue(void) PURE;
	virtual HRESULT SetValue(void) PURE;
	virtual HRESULT GetRange(void) PURE; 

	ULONG	m_IDProperty;	// Property ID

	// The following are used by GetValue and SetValue
	LONG	m_CurrentValue;
	LONG	m_CurrentFlags;

	// The following must be set by GetRange
	LONG	m_Min;
	LONG	m_Max;
	LONG	m_SteppingDelta;
	LONG	m_DefaultValue;
	LONG	m_DefaultFlags;
	LONG	m_CapsFlags;

	private:
	BOOL	m_Active;
	BOOL	m_fCheckBox;
	LONG	m_OriginalValue;
	LONG	m_OriginalFlags;
	HWND	m_hDlg;				// Parent
	HWND	m_hWndMin;			// Min window
	HWND	m_hWndMax;			// Max window
	HWND	m_hWndDefault;		// Default window
	HWND	m_hWndStep;			// Step window
	HWND	m_hWndEdit;			// Edit window
	HWND	m_hWndTrackbar;		// Slider
	HWND	m_hWndProgress;		// Progress
	HWND	m_hWndAuto;			// Auto checkbox
	ULONG	m_IDLabel;			// ID of label
	ULONG	m_IDMinControl;		// ID of min control
	ULONG	m_IDMaxControl;		// ID of max control
	ULONG	m_IDStepControl;	// ID of step control
	ULONG	m_IDDefaultControl;	// ID of default control
	ULONG	m_IDEditControl;	// ID of edit control
	ULONG	m_IDTrackbarControl;// ID of trackbar
	ULONG	m_IDProgressControl;// ID of trackbar
	ULONG	m_IDAutoControl;	// ID of auto checkbox
	LONG	m_TrackbarOffset;	// Handles negative trackbar offsets
	LONG	m_ProgressOffset;	// Handles negative trackbar offsets
	BOOL	m_CanAutoControl;

};

#endif // USE_PROPERTY_PAGES

#endif // _PROPEDIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\procampp.h ===
/****************************************************************************
 *  @doc INTERNAL PROCAMPP
 *
 *  @module ProcAmpP.h | Header file for the <c CProcAmpProperty>
 *    class used to implement a property page to test the DShow interface
 *    <i IAMVideoProcAmp>.
 *
 *  @comm This code tests the TAPI Video Decoder Filter <i IAMVideoProcAmp>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/

#ifndef _PROCAMPP_H_
#define _PROCAMPP_H_

#ifdef USE_PROPERTY_PAGES

#ifdef USE_VIDEO_PROCAMP

#define NUM_PROCAMP_CONTROLS (VideoProcAmp_BacklightCompensation + 1)

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPCLASS
 *
 *  @class CProcAmpProperty | This class implements handling of a
 *    single video proc amp control property in a property page.
 *
 *  @mdata int | CProcAmpProperty | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata IAMVideoProcAmp * | CProcAmpProperty | m_pInterface | Pointer
 *    to the <i IAMVideoProcAmp> interface.
 *
 *  @comm This code tests the TAPI Video Decoder Filter <i IAMVideoProcAmp>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
***************************************************************************/
class CProcAmpProperty : public CPropertyEditor 
{
	public:
	CProcAmpProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, IAMVideoProcAmp *pInterface);
	~CProcAmpProperty ();

	// CPropertyEditor base class pure virtual overrides
	HRESULT GetValue();
	HRESULT SetValue();
	HRESULT GetRange();
	BOOL CanAutoControl(void);
	BOOL GetAuto(void);
	BOOL SetAuto(BOOL fAuto);

	private:
	IAMVideoProcAmp *m_pInterface;
};

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPCLASS
 *
 *  @class CProcAmpProperties | This class runs a property page to test
 *    the TAPI Capture Filter <i IAMVideoProcAmp> implementation.
 *
 *  @mdata int | CProcAmpProperties | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata IAMVideoProcAmp * | CProcAmpProperties | m_pIAMVideoProcAmp | Pointer
 *    to the <i IAMVideoProcAmp> interface.
 *
 *  @mdata CProcAmpProperty * | CProcAmpProperties | m_Controls[NUM_PROCAMP_CONTROLS] | Array
 *    of video proc amp properties.
 *
 *  @comm This code tests the TAPI Capture Filter <i IAMVideoProcAmp>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
***************************************************************************/
class CProcAmpProperties : public CBasePropertyPage
{
	public:
	CProcAmpProperties(LPUNKNOWN pUnk, HRESULT *pHr);
	~CProcAmpProperties();

	HRESULT OnConnect(IUnknown *pUnk);
	HRESULT OnDisconnect();
	HRESULT OnActivate();
	HRESULT OnDeactivate();
	HRESULT OnApplyChanges();
	BOOL    OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	private:

	void SetDirty();

	int m_NumProperties;
	IAMVideoProcAmp *m_pIAMVideoProcAmp;
	BOOL m_fActivated;
	CProcAmpProperty *m_Controls[NUM_PROCAMP_CONTROLS];
};

#endif // USE_VIDEO_PROCAMP

#endif // USE_PROPERTY_PAGES

#endif // _PROCAMPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\precomp.h ===
/****************************************************************************
 *  @doc INTERNAL PRECOMP
 *
 *  @module Precomp.h | Master header file.
 ***************************************************************************/
#ifndef _precomp_vdec_h_
#define _precomp_vdec_h

#include <objbase.h>
#include <windows.h>
#include <windowsx.h>
#include <winbase.h>
#include <mmsystem.h>
#include <streams.h>
#include <vfw.h>
#include <stdlib.h>
#include <limits.h>
#include <commctrl.h>
#include <TAPIVid.h>
#include <tptrace.h>
#include <filterid.h>
#include <H26XInc.h>
#include <TAPIH26X.h>
#include <msrtp.h>
#include <ks.h>
#include <ksmedia.h>
#include <RtpHdr.h>
#include "PropEdit.h"
#include "Resource.h"
#include "ProcAmpP.h"
#include "CameraCP.h"
#include "h245vid.h"
#include "TAPIVDec.h"
#include "InPin.h"
#include "OutPin.h"
#include "Formats.h"
#include "InPinP.h"
#include "OutPinP.h"
#include "ProcUtil.h"
#include "viddtemp.h"

#endif /* _precomp_vdec_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\procutil.cpp ===
/****************************************************************************
 *  @doc INTERNAL PROCUTIL
 *
 *  @module ProcUtil.cpp | Source file for the Processor ID and Speed routines.
 *
 *  @comm Comes from the NM code base.
 ***************************************************************************/

#include "Precomp.h"

#define LEGACY_DIVISOR	8

DWORD __stdcall FindTSC (LPVOID pvRefData)
{
	   _asm
	   {
		   mov     eax,1
		   _emit   00Fh     ;; CPUID
		   _emit   0A2h

    // The ref data is 2 DWORDS, the first is the flags,
    // the second the family
		   mov     ecx,pvRefData
		   mov     [ecx],edx
		   mov	   [ecx][4],eax
	   }

	   return 1;
}

DWORD __stdcall NoCPUID (LPEXCEPTION_RECORD per,PCONTEXT pctx)
{
    return 0;
}
//
//  GetProcessorSpeed(dwFamily)
//
//  get the processor speed in MHz, only works on Pentium or better
//  machines.
//
//  Will put 3, or 4 in dwFamily for 386/486, but no speed.
//  returns speed and family for 586+
//
//  - thanks to toddla, modified by mikeg
//

int __stdcall GetProcessorSpeed(int *pdwFamily)
{
    SYSTEM_INFO si;
    __int64	start, end, freq;
    int 	flags,family;
    int 	time;
    int 	clocks;
    DWORD	oldclass;
    HANDLE      hprocess;
    int     pRef[2];

    ZeroMemory(&si, sizeof(si));
    GetSystemInfo(&si);

    //Set the family. If wProcessorLevel is not specified, dig it out of dwProcessorType
    //Because wProcessor level is not implemented on Win95
    if (si.wProcessorLevel) {
	*pdwFamily=si.wProcessorLevel;
    }else {
    	//Ok, we're on Win95
    	switch (si.dwProcessorType) {
    	       case PROCESSOR_INTEL_386:
    		   *pdwFamily=3;
    		   break;

    	       case PROCESSOR_INTEL_486:
    		   *pdwFamily=4;
    		   break;
    	       default:
    		   *pdwFamily=0;
    		   break;
    	}
    }

    // make sure this is a INTEL Pentium (or clone) or higher.
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL)
        return 0;

    if (si.dwProcessorType < PROCESSOR_INTEL_PENTIUM)
        return 0;

    // see if this chip supports rdtsc before using it.
    if (!CallWithSEH (FindTSC,&pRef,NoCPUID))     {
        flags=0;
    } else {
    // The ref data is 2 DWORDS, the first is the flags,
    // the second the family. Pull them out and use them
        flags=pRef[0];
        family=pRef[1];
    }

    if (!(flags & 0x10))
        return 0;

    //If we don't have a family, set it now
    //Family is bits 11:8 of eax from CPU, with eax=1
    if (!(*pdwFamily)) {
       *pdwFamily=(family& 0x0F00) >> 8;
    }

    hprocess = GetCurrentProcess();
    oldclass = GetPriorityClass(hprocess);
    SetPriorityClass(hprocess, REALTIME_PRIORITY_CLASS);
    Sleep(10);

    QueryPerformanceFrequency((LARGE_INTEGER*)&freq);
    QueryPerformanceCounter((LARGE_INTEGER*)&start);
    _asm
    {
        _emit   0Fh     ;; RDTSC
        _emit   31h
        mov     ecx,100000
x:      dec     ecx
        jnz     x
        mov     ebx,eax
        _emit   0Fh     ;; RDTSC
        _emit   31h
        sub     eax,ebx
        mov     dword ptr clocks[0],eax
    }
    QueryPerformanceCounter((LARGE_INTEGER*)&end);
    SetPriorityClass(hprocess, oldclass);

    time = MulDiv((int)(end-start),1000000,(int)freq);

    return (clocks + time/2) / time;
}

HRESULT __stdcall GetNormalizedCPUSpeed (int *pdwNormalizedSpeed)
{
	int dwProcessorSpeed;
	int dwFamily;

	dwProcessorSpeed=GetProcessorSpeed(&dwFamily);

	*pdwNormalizedSpeed=dwProcessorSpeed;

	if (dwFamily > 5) {
	   //Ok, TWO things.
	   // ONE DO NOT DO FP!
	   // Two for the same Mhz assume a 686 is 1.3 times as fast as a 586 and a 786 is 1.6 times, etc.
	   *pdwNormalizedSpeed=(ULONG) (((10+3*(dwFamily-5))*dwProcessorSpeed)/10);
	}

	if (dwFamily < 5) {
	  //bugbug until we have 386/486 timing code, assume
	  //486=50,386=37
	  if (dwFamily > 3) {
           //Cyrix, (5x86)? check before making default assignment
           if (is_cyrix()) {
               if (*pdwNormalizedSpeed==0) {
                   dwFamily=5;
                   *pdwNormalizedSpeed=100;
                   return NOERROR;
               }
           }
      }

	  *pdwNormalizedSpeed= (dwFamily*100)/LEGACY_DIVISOR;

      if (get_nxcpu_type ()) {
        //Double the perceived value on a NexGen
        *pdwNormalizedSpeed *=2;
      }
   }
   return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\procamp.cpp ===
/****************************************************************************
 *  @doc INTERNAL PROCAMP
 *
 *  @module ProcAmp.cpp | Source file for the <c CTAPIVDec>
 *    class methods used to implement the <i IAMVideoProcAmp> interface.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_VIDEO_PROCAMP

#define PROCAMP_MIN		0
#define PROCAMP_MAX		255
#define PROCAMP_DELTA	1
#define PROCAMP_DEFAULT	128

// From TAPIH263\cdrvdefs.h
#define PLAYBACK_CUSTOM_START				(ICM_RESERVED_HIGH     + 1)
#define PLAYBACK_CUSTOM_CHANGE_BRIGHTNESS	(PLAYBACK_CUSTOM_START + 0)
#define PLAYBACK_CUSTOM_CHANGE_CONTRAST		(PLAYBACK_CUSTOM_START + 1)
#define PLAYBACK_CUSTOM_CHANGE_SATURATION	(PLAYBACK_CUSTOM_START + 2)

/****************************************************************************
 *  @doc INTERNAL CPROCAMPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | Set | This method is used to set the value
 *    of a video quality setting.
 *
 *  @parm VideoProcAmpProperty | Property | Used to specify the video
 *    quality setting to set the value of. Use a member of the
 *    <t VideoProcAmpProperty> enumerated type.
 *
 *  @parm long | lValue | Used to specify the new value of the video quality
 *    setting.
 *
 *  @parm TAPIControlFlags | Flags | A member of the <t TAPIControlFlags>
 *    enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::Set(IN VideoProcAmpProperty Property, IN long lValue, IN TAPIControlFlags lFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIVDec::Set (VideoProcAmp)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(Property >= VideoProcAmp_Brightness && Property <= VideoProcAmp_BacklightCompensation);

	// Update the property and flags
	switch (Property)
	{
		case VideoProcAmp_Brightness:
			ASSERT(lValue >= PROCAMP_MIN && lValue <= PROCAMP_MAX);
			if (lValue >= PROCAMP_MIN && lValue <= PROCAMP_MAX)
			{
				m_lVPABrightness = lValue;
				(*m_pDriverProc)((DWORD)m_pInstInfo, NULL, PLAYBACK_CUSTOM_CHANGE_BRIGHTNESS, (LPARAM)lValue, NULL);
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
				Hr = E_INVALIDARG;
			}
			break;
		case VideoProcAmp_Contrast:
			ASSERT(lValue >= PROCAMP_MIN && lValue <= PROCAMP_MAX);
			if (lValue >= PROCAMP_MIN && lValue <= PROCAMP_MAX)
			{
				m_lVPAContrast = lValue;
				(*m_pDriverProc)((DWORD)m_pInstInfo, NULL, PLAYBACK_CUSTOM_CHANGE_CONTRAST, (LPARAM)lValue, NULL);
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
				Hr = E_INVALIDARG;
			}
			break;
		case VideoProcAmp_Saturation:
			ASSERT(lValue >= PROCAMP_MIN && lValue <= PROCAMP_MAX);
			if (lValue >= PROCAMP_MIN && lValue <= PROCAMP_MAX)
			{
				m_lVPASaturation = lValue;
				(*m_pDriverProc)((DWORD)m_pInstInfo, NULL, PLAYBACK_CUSTOM_CHANGE_SATURATION, (LPARAM)lValue, NULL);
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
				Hr = E_INVALIDARG;
			}
			break;
		default:
			Hr = E_PROP_ID_UNSUPPORTED;
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | Get | This method is used to retrieve the
 *    value of a video quality setting.
 *
 *  @parm VideoProcAmpProperty | Property | Used to specify the video
 *    quality setting to get the value of. Use a member of the
 *    <t VideoProcAmpProperty> enumerated type.
 *
 *  @parm long* | plValue | Used to retrieve the current value of the
 *    video quality setting.
 *
 *  @parm TAPIControlFlags* | plFlags | Pointer to a member of the <t TAPIControlFlags>
 *    enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::Get(IN VideoProcAmpProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIVDec::Get (VideoProcAmp)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plValue);
	ASSERT(plFlags);
	if (!plValue || !plFlags)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(Property >= VideoProcAmp_Brightness && Property <= VideoProcAmp_BacklightCompensation);

	// Update the property and flags
	*plFlags = TAPIControl_Flags_Manual;
	switch (Property)
	{
		case VideoProcAmp_Brightness:
			*plValue = m_lVPABrightness;
			break;
		case VideoProcAmp_Contrast:
			*plValue = m_lVPAContrast;
			break;
		case VideoProcAmp_Saturation:
			*plValue = m_lVPASaturation;
			break;
		default:
			Hr = E_PROP_ID_UNSUPPORTED;
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | GetRange | This method is used to retrieve
 *    the minimum, maximum, and default values for specific video quality
 *    settings.
 *
 *  @parm VideoProcAmpProperty | Property | Used to specify the video
 *    quality setting to determine the range of. Use a member of the
 *    <t VideoProcAmpProperty> enumerated type.
 *
 *  @parm long* | plMin | Used to retrieve the minimum value of the video
 *    quality setting range.
 *
 *  @parm long* | plMax | Used to retrieve the maximum value of the video
 *    quality setting range.
 *
 *  @parm long* | plSteppingDelta | Used to retrieve the stepping delta of
 *    the video quality setting range.
 *
 *  @parm long* | plDefault | Used to retrieve the default value of the
 *    video quality setting range.
 *
 *  @parm TAPIControlFlags* | plCapsFlags | Used to retrieve the capabilities of the
 *    video quality setting. Pointer to a member of the
 *    <t TAPIControlFlags> enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::GetRange(IN VideoProcAmpProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIVDec::GetRange (VideoProcAmp)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plMin);
	ASSERT(plMax);
	ASSERT(plSteppingDelta);
	ASSERT(plDefault);
	ASSERT(plCapsFlags);
	if (!plMin || !plMax || !plSteppingDelta || !plDefault || !plCapsFlags)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(Property >= VideoProcAmp_Brightness && Property <= VideoProcAmp_BacklightCompensation);
	if (Property != VideoProcAmp_Brightness && Property != VideoProcAmp_Contrast && Property != VideoProcAmp_Saturation)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
		Hr = E_PROP_ID_UNSUPPORTED;
		goto MyExit;
	}

	// Update the property and flags
	*plCapsFlags = TAPIControl_Flags_Manual;
	*plMin = PROCAMP_MIN;
	*plMax = PROCAMP_MAX;
	*plSteppingDelta = PROCAMP_DELTA;
	*plDefault = PROCAMP_DEFAULT;

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\procampp.cpp ===
/****************************************************************************
 *  @doc INTERNAL PROCAMPP
 *
 *  @module ProcAmpP.cpp | Source file for the <c CProcAmpProperty>
 *    class used to implement a property page to test the DShow interface
 *    <i IAMVideoProcAmp>.
 *
 *  @comm This code tests the TAPI Capture Filter <i IAMVideoProcAmp>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_PROPERTY_PAGES

#ifdef USE_VIDEO_PROCAMP

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc void | CProcAmpProperty | CProcAmpProperty | This
 *    method is the constructor for video proc amp control property objects. It
 *    calls the base class constructor, calls InitCommonControlsEx, and saves
 *    a pointer to the <i IAMVideoProcAmp> interface.
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    property progress bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the Ks property.
 *
 *  @parm IAMVideoProcAmp* | pInterface | Specifies a pointer to the
 *    <i IAMVideoProcAmp> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CProcAmpProperty::CProcAmpProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, IAMVideoProcAmp *pInterface)
: CPropertyEditor(hDlg, IDLabel, IDMinControl, IDMaxControl, IDDefaultControl, IDStepControl, IDEditControl, IDTrackbarControl, IDProgressControl, IDProperty, IDAutoControl)
{
	INITCOMMONCONTROLSEX cc;

	FX_ENTRY("CProcAmpProperty::CProcAmpProperty")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
	cc.dwICC  = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

	InitCommonControlsEx(&cc);

	// It's fine if the interface pointer is NULL, we'll grey the
	// associated items in the property page
	m_pInterface = pInterface;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc void | CProcAmpProperty | ~CProcAmpProperty | This
 *    method is the destructor for video proc amp control property objects. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CProcAmpProperty::~CProcAmpProperty()
{
	FX_ENTRY("CProcAmpProperty::~CProcAmpProperty")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperty | GetValue | This method queries for
 *    the value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperty::GetValue()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CProcAmpProperty::GetValue")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->Get(m_IDProperty, &m_CurrentValue, &m_CurrentFlags)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_CurrentValue=%ld, m_CurrentFlags=%ld", _fx_, m_CurrentValue, m_CurrentFlags));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: m_pIAMVideoProcAmp->Get failed Hr=0x%08lX", _fx_, Hr));
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperty | SetValue | This method sets the
 *    value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperty::SetValue()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CProcAmpProperty::SetValue")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->Set(m_IDProperty, m_CurrentValue, m_CurrentFlags)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_CurrentValue=%ld, m_CurrentFlags=%ld", _fx_, m_CurrentValue, m_CurrentFlags));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: m_pIAMVideoProcAmp->Set failed Hr=0x%08lX", _fx_, Hr));
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperty | GetRange | This method retrieves
 *    the range information of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperty::GetRange()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CProcAmpProperty::GetRange")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->GetRange(m_IDProperty, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, &m_CapsFlags)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Min=%ld, m_Max=%ld, m_SteppingDelta=%ld, m_DefaultValue=%ld, m_CapsFlags=%ld", _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue, m_CapsFlags));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: m_pIAMVideoProcAmp->GetRange failed Hr=0x%08lX", _fx_, Hr));
	}
	m_DefaultFlags = m_CapsFlags;

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc CUnknown* | CProcAmpProperties | CreateInstance | This
 *    method is called by DShow to create an instance of a
 *    Property Page. It is referred to in the global structure <t g_Templates>.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Returns a pointer to the nondelegating CUnknown portion of the
 *    object, or NULL otherwise.
 ***************************************************************************/
CUnknown* CALLBACK CProcAmpPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr)
{
	CUnknown *pUnknown = (CUnknown *)NULL;

	FX_ENTRY("CProcAmpPropertiesCreateInstance")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pHr);
	if (!pHr)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		goto MyExit;
	}

	if (!(pUnknown = new CProcAmpProperties(pUnkOuter, pHr)))
	{
		*pHr = E_OUTOFMEMORY;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: new CProcAmpProperties failed", _fx_));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: new CProcAmpProperties created", _fx_));
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return pUnknown;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc void | CProcAmpProperties | CProcAmpProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CProcAmpProperties::CProcAmpProperties(LPUNKNOWN pUnk, HRESULT *pHr) : CBasePropertyPage(NAME("Video Proc Amp Property Page"), pUnk, IDD_VideoProcAmpProperties, IDS_PROCAMPPROPNAME)
{
	FX_ENTRY("CProcAmpProperties::CProcAmpProperties")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	m_pIAMVideoProcAmp = NULL;
	m_NumProperties = NUM_PROCAMP_CONTROLS;
	m_fActivated = FALSE;

	for (int i = 0; i < m_NumProperties; i++)
		m_Controls[i] = NULL;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc void | CProcAmpProperties | ~CProcAmpProperties | This
 *    method is the destructor for the video proc amp control property page. It
 *    simply calls the base class destructor after deleting all the controls.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CProcAmpProperties::~CProcAmpProperties()
{
	int		j;

	FX_ENTRY("CProcAmpProperties::~CProcAmpProperties")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperties | OnConnect | This
 *    method is called when the property page is connected to the filter.
 *
 *  @parm LPUNKNOWN | pUnknown | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperties::OnConnect(IUnknown *pUnk)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CProcAmpProperties::OnConnect")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pUnk);
	if (!pUnk)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the video proc amp interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(IID_IAMVideoProcAmp,(void **)&m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_pIAMVideoProcAmp=0x%08lX", _fx_, m_pIAMVideoProcAmp));
	}
	else
	{
		m_pIAMVideoProcAmp = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers. We'll just grey the controls in the property page
	// to make it clear to the user that they can't control those properties on the device
	Hr = NOERROR;

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperties::OnDisconnect()
{
	FX_ENTRY("CProcAmpProperties::OnDisconnect")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters: we seem to get called several times here
	// Make sure the interface pointer is still valid
	if (!m_pIAMVideoProcAmp)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   WARNING: already disconnected!", _fx_));
	}
	else
	{
		// Release the interface
		m_pIAMVideoProcAmp->Release();
		m_pIAMVideoProcAmp = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: releasing m_pIAMVideoProcAmp", _fx_));
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperties | OnActivate | This
 *    method is called when the property page is activated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperties::OnActivate()
{
	HRESULT	Hr = E_OUTOFMEMORY;
	int		j;

	FX_ENTRY("CProcAmpProperties::OnActivate")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Create the controls for the properties
	if (!(m_Controls[0] = new CProcAmpProperty(m_hwnd, IDC_Brightness_Label, IDC_Brightness_Minimum, IDC_Brightness_Maximum, IDC_Brightness_Default, IDC_Brightness_Stepping, IDC_Brightness_Edit, IDC_Brightness_Slider, 0, VideoProcAmp_Brightness, IDC_Brightness_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_Brightness] failed - Out of memory", _fx_));
		goto MyExit;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_Brightness]=0x%08lX", _fx_, m_Controls[0]));
	}

	if (!(m_Controls[1] = new CProcAmpProperty(m_hwnd, IDC_Contrast_Label, IDC_Contrast_Minimum, IDC_Contrast_Maximum, IDC_Contrast_Default, IDC_Contrast_Stepping, IDC_Contrast_Edit, IDC_Contrast_Slider, 0, VideoProcAmp_Contrast, IDC_Contrast_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_Contrast] failed - Out of memory", _fx_));
		goto MyError0;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_Contrast]=0x%08lX", _fx_, m_Controls[1]));
	}

	if (!(m_Controls[2] = new CProcAmpProperty(m_hwnd, IDC_Hue_Label, IDC_Hue_Minimum, IDC_Hue_Maximum, IDC_Hue_Default, IDC_Hue_Stepping, IDC_Hue_Edit, IDC_Hue_Slider, 0, VideoProcAmp_Hue, IDC_Hue_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_Hue] failed - Out of memory", _fx_));
		goto MyError1;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_Hue]=0x%08lX", _fx_, m_Controls[2]));
	}

	if (!(m_Controls[3] = new CProcAmpProperty(m_hwnd, IDC_Saturation_Label, IDC_Saturation_Minimum, IDC_Saturation_Maximum, IDC_Saturation_Default, IDC_Saturation_Stepping, IDC_Saturation_Edit, IDC_Saturation_Slider, 0, VideoProcAmp_Saturation, IDC_Saturation_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_Saturation] failed - Out of memory", _fx_));
		goto MyError2;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_Saturation]=0x%08lX", _fx_, m_Controls[3]));
	}

	if (!(m_Controls[4] = new CProcAmpProperty(m_hwnd, IDC_Sharpness_Label, IDC_Sharpness_Minimum, IDC_Sharpness_Maximum, IDC_Sharpness_Default, IDC_Sharpness_Stepping, IDC_Sharpness_Edit, IDC_Sharpness_Slider, 0, VideoProcAmp_Sharpness, IDC_Sharpness_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_Sharpness] failed - Out of memory", _fx_));
		goto MyError3;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_Sharpness]=0x%08lX", _fx_, m_Controls[4]));
	}

	if (!(m_Controls[5] = new CProcAmpProperty(m_hwnd, IDC_Gamma_Label, IDC_Gamma_Minimum, IDC_Gamma_Maximum, IDC_Gamma_Default, IDC_Gamma_Stepping, IDC_Gamma_Edit, IDC_Gamma_Slider, 0, VideoProcAmp_Gamma, IDC_Gamma_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_Gamma] failed - Out of memory", _fx_));
		goto MyError4;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_Gamma]=0x%08lX", _fx_, m_Controls[5]));
	}

	if (!(m_Controls[6] = new CProcAmpProperty(m_hwnd, IDC_ColorEnable_Label, IDC_ColorEnable_Minimum, IDC_ColorEnable_Maximum, IDC_ColorEnable_Default, IDC_ColorEnable_Stepping, IDC_ColorEnable_Edit, IDC_ColorEnable_Slider, 0, VideoProcAmp_ColorEnable, IDC_ColorEnable_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_ColorEnable] failed - Out of memory", _fx_));
		goto MyError5;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_ColorEnable]=0x%08lX", _fx_, m_Controls[6]));
	}

	if (!(m_Controls[7] = new CProcAmpProperty(m_hwnd, IDC_WhiteBalance_Label, IDC_WhiteBalance_Minimum, IDC_WhiteBalance_Maximum, IDC_WhiteBalance_Default, IDC_WhiteBalance_Stepping, IDC_WhiteBalance_Edit, IDC_WhiteBalance_Slider, 0, VideoProcAmp_WhiteBalance, IDC_WhiteBalance_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_WhiteBalance] failed - Out of memory", _fx_));
		goto MyError5;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_WhiteBalance]=0x%08lX", _fx_, m_Controls[6]));
	}

	if (!(m_Controls[8] = new CProcAmpProperty(m_hwnd, IDC_BacklightComp_Label, IDC_BacklightComp_Minimum, IDC_BacklightComp_Maximum, IDC_BacklightComp_Default, IDC_BacklightComp_Stepping, IDC_BacklightComp_Edit, IDC_BacklightComp_Slider, 0, VideoProcAmp_BacklightCompensation, IDC_BacklightComp_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_BacklightComp] failed - Out of memory", _fx_));
		goto MyError5;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_BacklightComp]=0x%08lX", _fx_, m_Controls[6]));
	}

	// Initialize all the controls. If the initialization fails, it's Ok. It just means
	// that the TAPI control interface isn't implemented by the device. The dialog item
	// in the property page will be greyed, showing this to the user.
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j]->Init())
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[%ld]->Init()", _fx_, j));
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   WARNING: m_Controls[%ld]->Init() failed", _fx_, j));
		}
	}

	Hr = NOERROR;
	goto MyExit;

MyError5:
	if (m_Controls[5])
		delete m_Controls[5], m_Controls[5] = NULL;
MyError4:
	if (m_Controls[4])
		delete m_Controls[4], m_Controls[4] = NULL;
MyError3:
	if (m_Controls[3])
		delete m_Controls[3], m_Controls[3] = NULL;
MyError2:
	if (m_Controls[2])
		delete m_Controls[2], m_Controls[2] = NULL;
MyError1:
	if (m_Controls[1])
		delete m_Controls[1], m_Controls[1] = NULL;
MyError0:
	if (m_Controls[0])
		delete m_Controls[0], m_Controls[0] = NULL;
MyExit:
	m_fActivated = TRUE;
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperties | OnDeactivate | This
 *    method is called when the property page is dismissed.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperties::OnDeactivate()
{
	int		j;

	FX_ENTRY("CProcAmpProperties::OnDeactivate")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	m_fActivated = FALSE;
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperties | OnApplyChanges | This
 *    method is called when the user applies changes to the property page.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperties::OnApplyChanges()
{
	HRESULT	Hr = NOERROR;

	FX_ENTRY("CProcAmpProperties::OnApplyChanges")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	for (int j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			if (m_Controls[j]->HasChanged())
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: calling m_Controls[%ld]=0x%08lX->OnApply", _fx_, j, m_Controls[j]));
				m_Controls[j]->OnApply();
			}
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: can't call m_Controls[%ld]=NULL->OnApply", _fx_, j));
			Hr = E_UNEXPECTED;
			break;
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc BOOL | CProcAmpProperties | OnReceiveMessage | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
BOOL CProcAmpProperties::OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
		case WM_INITDIALOG:
			return TRUE; // Don't call setfocus

		case WM_HSCROLL:
		case WM_VSCROLL:
			if (m_fActivated)
			{
				// Process all of the Trackbar messages
				for (j = 0; j < m_NumProperties; j++)
				{
					ASSERT(m_Controls[j]);
					if (m_Controls[j]->GetTrackbarHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnScroll(uMsg, wParam, lParam);
						SetDirty();
					}
				}
				OnApplyChanges();
			}
			break;

		case WM_COMMAND:

			// This message gets sent even before OnActivate() has been
			// called(!). We need to test and make sure the controls have
			// beeen initialized before we can use them.

			if (m_fActivated)
			{
				// Process all of the auto checkbox messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetAutoHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnAuto(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				// Process all of the edit box messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetEditHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnEdit(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				switch (LOWORD(wParam))
				{
					case IDC_CONTROL_DEFAULT:
						for (j = 0; j < m_NumProperties; j++)
						{
							if (m_Controls[j])
								m_Controls[j]->OnDefault();
						}
						break;

					default:
						break;
				}

			OnApplyChanges();
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc BOOL | CProcAmpProperties | SetDirty | This
 *    method notifies the property page site of changes.
 *
 *  @rdesc Nada.
 ***************************************************************************/
void CProcAmpProperties::SetDirty()
{
	m_bDirty = TRUE;
	if (m_pPageSite)
		m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}

#endif // USE_VIDEO_PROCAMP

#endif // USE_PROPERTY_PAGES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\i386\procid.asm ===
;*  Procdi.asm - Processor Identification routines
;*
;*      (C) Copyright Microsoft Corp., 1995
;*
;*      Processor ID
;*
;*  Origin:
;*
;*  Change history:
;*
;*  Date       Who        Description
;*  ---------  ---------  -------------------------------------------------
;*  12-Oct-95  MikeG      Created
;*

.386p
.387

.model  flat


;************************** Include Files ************************

;    include winbase.inc
;    include winerror.inc
;    include kernel32.inc
;    include segs.inc
;    include regstr.inc
;******************** Data Declerations **************************

.data
_DATA SEGMENT
CPU_ID  macro
        db      0fh, 0a2h
        endm

NONE            equ     0
PRESENT         equ     1
Nx586           equ     5
UNKNOWN         equ     0


_nxcpu          db      NONE                    ;default to none
_cputype        db      UNKNOWN                 ;default to unknown
_cpuid_flag     db      NONE                    ;default to no CPUID
_vendor_id      db      "************"
_cpu_signature  dd      0
_features_ecx   dd      0
_features_edx   dd      0
_features_ebx   dd      0
NexGen_id       db      "NexGenDriven"



;*********************** Prototypes ******************************


;************************** Code *********************************

.code

_TEXT	SEGMENT
;==========================================================================
; _get_nxcpu_type
;       This routine identifies NexGen's processor type in following steps:
;
;       if (no AC flag) {       //current Nx586 does not support AC flag
;               set ZF=1;
;               execute DIV to result a none zero value;
;               if (ZF=0) {     //ZF is changed
;                       not a NexGen processor;
;                       exit;
;               } else {        //Nx586 does not change ZF on DIV instruction
;                       if (ID bit not writeable) {
;                               CPU is Nx586 with no CPUID support
;                       } else {                //Nx586 with CPUID support
;                               execute CPUID instruction;
;                               save CPU information;
;                       }
;               }
;       } else {
;               if (ID bit not writeable) {
;                       not a NexGen processor;
;               } else {        //NexGen future processors support CPUID
;                       execute CPUID instruction;
;                       save CPU information;
;               }
;       }
;
;==========================================================================
get_nxcpu_type proc  C cdecl:DWORD
        push    ebx
        push    esi
        push    edi
        mov     byte ptr _nxcpu,PRESENT ; default to present

; test AC bit on EFLAGS register
        mov     bx,sp           ; save the current stack pointer
        and     sp,not 3        ; align the stack to avoid AC fault
        pushfd                  ;
        pop     eax             ; get the original EFLAGS
        mov     ecx,eax         ; save original flag
        xor     eax,40000h      ; flip AC bit in EFLAGS
        push    eax             ; save for EFLAGS
        popfd                   ; copy it to EFLAGS
        pushfd                  ;
        pop     eax             ; get the new EFLAGS value
        mov     sp,bx           ; restore stack pointer
        xor     eax,ecx         ; if the AC bit is unchanged
        je      test_zf         ;       goto second step
        jmp     nx_future_cpu

test_zf:
; test ZF on DIV instruction
        mov     ax,5555h        ; init AX with a non-zero value
        xor     dx,dx           ; set ZF=1
        mov     cx,2
        div     cx              ; Nx586 processor does not modify ZF on DIV
        jnz     not_nx_cpu      ; not a NexGen processor if ZF=0 (modified)

test_cpuid:
; test if CPUID instruction is available
; new Nx586 or future CPU supports CPUID instruction
        pushfd                  ; get EFLAGs
        pop     eax
        mov     ecx,eax         ; save it
        xor     eax,200000h     ; modify ID bit
        push    eax
        popfd                   ; save it in new EFLAGS
        pushfd                  ; get new EFLAGS
        pop     eax             ;
        xor     eax,ecx         ; is ID bit changed?
        jnz     cpuid_present   ; yes

        mov     byte ptr _cputype,Nx586 ; no, current Nx586
	mov	eax,1		; set return code == true
        jz      cpuid_exit      ; stop testing

nx_future_cpu:
; all NexGen's future processors feature a CPUID instruction
        mov     eax,ecx         ; get original EFLAGS
        xor     eax,200000h     ; modify ID bit
        push    eax
        popfd                   ; save it in new EFLAGS
        pushfd                  ; get new EFLAGS
        pop     eax             ;
        xor     eax,ecx         ; is ID bit changed?
        jz      not_nx_cpu      ; no, not a NexGen processor

cpuid_present:
; execute CPUID instruction to get vendor name, stepping and feature info
        xor     eax,eax
        CPU_ID
        mov     dword ptr _vendor_id,ebx
        mov     dword ptr _vendor_id[+4],edx
        mov     dword ptr _vendor_id[+8],ecx

        mov     bx,ds
        mov     es,bx
        mov     esi,offset _vendor_id
        mov     edi,offset NexGen_id
        mov     cx,12
        cld
        repe    cmpsb           ; compare vendor ID string
        jne     not_nx_cpu

        mov     byte ptr _cpuid_flag,PRESENT
        cmp     eax,1           ; check highest level
        jl      cpuid_exit

        mov     eax,1
        CPU_ID
        mov     _cpu_signature,eax
        mov     _features_ecx,ecx
        mov     _features_edx,edx
        mov     _features_ebx,ebx
        shr     eax,8
        and     al,0fh
        mov     _cputype,al
        jmp     cpuid_exit
not_nx_cpu:
        mov     byte ptr _nxcpu,NONE
        xor     eax,eax
cpuid_exit:
        pop     edi
        pop     esi
        pop     ebx
        ret
get_nxcpu_type endp

;**************************************************************************
;       Function:       int is_cyrix ()
;
;       Purpose:        Determine if Cyrix CPU is present
;       Technique:      Cyrix CPUs do not change flags where flags change
;                        in an undefined manner on other CPUs
;       Inputs:         none
;       Output:         ax == 1 Cyrix present, 0 if not
;**************************************************************************
is_cyrix proc C __cdecl:WORD
           .486
           push  bx
           xor   ax, ax         ; clear ax
           sahf                 ; clear flags, bit 1 is always 1 in flags
           mov   ax, 5
           mov   bx, 2
           div   bl             ; do an operation that does not change flags
           lahf                 ; get flags
           cmp   ah, 2          ; check for change in flags
           jne   not_cyrix      ; flags changed not Cyrix
           mov   ax, 1          ; TRUE Cyrix CPU
           jmp   done

not_cyrix:
           mov  ax, 0           ; FALSE NON-Cyrix CPU
done:
           pop  bx
           ret
is_cyrix   endp
_TEXT ends
      end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\i386\seh.c ===
/*****************************************************************************
 *
 *  Seh.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Structured exception handling.
 *
 *****************************************************************************/
#include <windows.h>

typedef DWORD (CALLBACK *INEXCEPTION)(LPEXCEPTION_RECORD per, PCONTEXT pctx);
typedef DWORD (CALLBACK *EXCEPTPROC)(void* pv);

typedef void *PV;

/*****************************************************************************
 *
 *      SEHFRAME
 *
 *      Special stack frame used by lightweight structured exception
 *      handling.
 *
 *****************************************************************************/

typedef struct SEHFRAME {

    PV      pvSEH;              /* Link to previous frame   */
    FARPROC Handler;            /* MyExceptionFilter        */
    FARPROC sehTarget;          /* Where to jump on error   */
    INEXCEPTION InException;    /* In-exception handler     */

} SEHFRAME, *PSEHFRAME;

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | _MyExceptionFilter |
 *
 *          My tiny exception filter.
 *
 *  @parm   LPEXCEPTION_RECORD | pExceptionRecord |
 *
 *          Exception record describing why we were called.
 *
 *  @parm   PV | EstablisherFrame |
 *
 *          The exception frame (pNext, pHandler)
 *          on the stack which is being handled.  This is used so that
 *          the handler can access its local variables and knows how
 *          far to smash the stack if the exception is being eaten.
 *
 *  @parm   PCONTEXT | pContextRecord |
 *
 *          Client context at time of exception.
 *
 *  @parm   PV | DispatcherContext |
 *
 *          Not used.  Which is good, because I don't know what it means.
 *
 ***************************************************************************/

#define EXCEPTION_UNWINDING     0x00000002
#define EXCEPTION_EXIT_UNWIND   0x00000004

WINBASEAPI void WINAPI
RtlUnwind(PV TargetFrame, PV TargetIp, PEXCEPTION_RECORD per, PV ReturnValue);

EXCEPTION_DISPOSITION
__cdecl
_MyExceptionFilter(
    LPEXCEPTION_RECORD pExceptionRecord,
    PV EstablisherFrame,
    PCONTEXT pContextRecord,
    PV DispatcherContext
)
{
    DispatcherContext;
    pContextRecord;

    /* Don't interfere with an unwind */
    if ((pExceptionRecord->ExceptionFlags &
            (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND)) == 0) {
        PSEHFRAME pseh = EstablisherFrame;
        BOOL fRc = pseh->InException(pExceptionRecord, pContextRecord);

        /*
         *  RtlUnwind will tell all exception frames that may have
         *  been created underneath us that they are about to be
         *  blown away and should do their __finally handling.
         *
         *  On return, the nested frames have been unlinked.
         */
        RtlUnwind(EstablisherFrame, 0, 0, 0);

        /*
         *  And jump back to the caller.  It is the caller's
         *  responsibility to restore nonvolatile registers!
         *
         *  We also assume that the caller has nothing on the
         *  stack beneath the exception record!
         *
         *  And the handler address is right after the exception
         *  record!
         */
        __asm {
            mov     eax, fRc;               /* Get return value */
            mov     esp, EstablisherFrame;  /* Restore ESP */
//            jmp     [esp].sehTarget;        /* Back to CallWithSEH */

//We should be doing the above, but it faults VC4.2. Gotta love it.

            jmp     DWORD ptr [esp+8]
        }

    }

    /*
     *  We are unwinding.  Don't interfere.
     */
    return EXCEPTION_CONTINUE_SEARCH;
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | CallWithSEH |
 *
 *          Call the function with an exception frame active.
 *
 *          If the procedure raises an exception, then call
 *          InException and propagate whatever InException returns.
 *
 ***************************************************************************/

#pragma warning(disable:4035)           /* no return value (duh) */

__declspec(naked) DWORD WINAPI
CallWithSEH(EXCEPTPROC pfn, PV pv, INEXCEPTION InException)
{
    __asm {

        /* Function prologue */
        push    ebp;
        mov     ebp, esp;                       /* To keep C compiler happy */
        push    ebx;
        push    edi;
        push    esi;

        /*
         *  Build a SEHFRAME.
         */
        push    InException;                    /* What to handle */
        push    offset Exit;                    /* Where to go on error */

        xor     edx, edx;                       /* Keep zero handy */
        push    offset _MyExceptionFilter;      /* My handler */
        push    dword ptr fs:[edx];             /* Build frame */
        mov     fs:[edx], esp;                  /* Link in */
    }

        pfn(pv);                                /* Call the victim */

    __asm {
        /*
         *  The validation layer jumps here (all registers in a random
         *  state except for ESP) if something went wrong.
         *
         *  We don't need to restore nonvolatile registers now;
         *  that will be done as part of the procedure exit.
         */
Exit:;

        xor     edx, edx;                       /* Keep zero handy */
        pop     dword ptr fs:[edx];             /* Remove frame */

        /*
         *  Discard MyExceptionFilter, Exit, and InException.
         */
        add     esp, 12;

        pop     esi;
        pop     edi;
        pop     ebx;
        pop     ebp;
        ret     12;
    }

}

#pragma warning(default:4035)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TAPIVDec.rc
//

#define IDC_STATIC                      -1

#ifdef USE_PROPERTY_PAGES // { USE_PROPERTY_PAGES

#define IDS_CAMERACONTROLPROPNAME       0
#define IDS_PROCAMPPROPNAME				1
#define IDS_INPUTPINPROPNAME            2
#define IDS_OUTPUTPINPROPNAME           3

#define IDD_CameraControlProperties     100
#define IDD_VideoProcAmpProperties      101
#define IDD_InputPinProperties          102
#define IDD_OutputPinProperties         103

#define IDC_BitrateControl_Label        200
#define IDC_BitrateControl_Minimum      0
#define IDC_BitrateControl_Maximum      0
#define IDC_BitrateControl_Default      0
#define IDC_BitrateControl_Stepping     0
#define IDC_BitrateControl_Edit         0
#define IDC_BitrateControl_Slider       0
#define IDC_BitrateControl_Meter        207
#define IDC_BitrateControl_Actual       208

#define IDC_FrameRateControl_Label      210
#define IDC_FrameRateControl_Minimum    211
#define IDC_FrameRateControl_Maximum    212
#define IDC_FrameRateControl_Default    213
#define IDC_FrameRateControl_Stepping   214
#define IDC_FrameRateControl_Edit       215
#define IDC_FrameRateControl_Slider     216
#define IDC_FrameRateControl_Meter      217
#define IDC_FrameRateControl_Actual     218

#define IDC_VideoStandard_Edit          220

#define IDC_CONTROL_DEFAULT             230

#define IDC_Pan_Label                   400
#define IDC_Pan_Minimum                 0
#define IDC_Pan_Maximum                 0
#define IDC_Pan_Default                 0
#define IDC_Pan_Stepping                0
#define IDC_Pan_Edit                    405
#define IDC_Pan_Slider                  406
#define IDC_Pan_Auto                    407

#define IDC_Tilt_Label                  410
#define IDC_Tilt_Minimum                0
#define IDC_Tilt_Maximum                0
#define IDC_Tilt_Default                0
#define IDC_Tilt_Stepping               0
#define IDC_Tilt_Edit                   415
#define IDC_Tilt_Slider                 416
#define IDC_Tilt_Auto                   417

#define IDC_Roll_Label                  420
#define IDC_Roll_Minimum                0
#define IDC_Roll_Maximum                0
#define IDC_Roll_Default                0
#define IDC_Roll_Stepping               0
#define IDC_Roll_Edit                   425
#define IDC_Roll_Slider                 426
#define IDC_Roll_Auto                   427

#define IDC_Zoom_Label                  430
#define IDC_Zoom_Minimum                0
#define IDC_Zoom_Maximum                0
#define IDC_Zoom_Default                0
#define IDC_Zoom_Stepping               0
#define IDC_Zoom_Edit                   435
#define IDC_Zoom_Slider                 436
#define IDC_Zoom_Auto                   437

#define IDC_Exposure_Label              440
#define IDC_Exposure_Minimum            0
#define IDC_Exposure_Maximum            0
#define IDC_Exposure_Default            0
#define IDC_Exposure_Stepping           0
#define IDC_Exposure_Edit               445
#define IDC_Exposure_Slider             446
#define IDC_Exposure_Auto               447

#define IDC_Iris_Label                  450
#define IDC_Iris_Minimum                0
#define IDC_Iris_Maximum                0
#define IDC_Iris_Default                0
#define IDC_Iris_Stepping               0
#define IDC_Iris_Edit                   455
#define IDC_Iris_Slider                 456
#define IDC_Iris_Auto                   457

#define IDC_Focus_Label                 460
#define IDC_Focus_Minimum               0
#define IDC_Focus_Maximum               0
#define IDC_Focus_Default               0
#define IDC_Focus_Stepping              0
#define IDC_Focus_Edit                  465
#define IDC_Focus_Slider                466
#define IDC_Focus_Auto                  467

#define IDC_FlipVertical_Edit           470

#define IDC_FlipHorizontal_Edit         480

#define IDC_Brightness_Label            500
#define IDC_Brightness_Minimum          0
#define IDC_Brightness_Maximum          0
#define IDC_Brightness_Default          0
#define IDC_Brightness_Stepping         0
#define IDC_Brightness_Edit             505
#define IDC_Brightness_Slider           506
#define IDC_Brightness_Auto             507

#define IDC_Contrast_Label              510
#define IDC_Contrast_Minimum            0
#define IDC_Contrast_Maximum            0
#define IDC_Contrast_Default            0
#define IDC_Contrast_Stepping           0
#define IDC_Contrast_Edit               515
#define IDC_Contrast_Slider             516
#define IDC_Contrast_Auto               517

#define IDC_Hue_Label                   520
#define IDC_Hue_Minimum                 0
#define IDC_Hue_Maximum                 0
#define IDC_Hue_Default                 0
#define IDC_Hue_Stepping                0
#define IDC_Hue_Edit                    525
#define IDC_Hue_Slider                  526
#define IDC_Hue_Auto                    527

#define IDC_Saturation_Label            530
#define IDC_Saturation_Minimum          0
#define IDC_Saturation_Maximum          0
#define IDC_Saturation_Default          0
#define IDC_Saturation_Stepping         0
#define IDC_Saturation_Edit             535
#define IDC_Saturation_Slider           536
#define IDC_Saturation_Auto             537

#define IDC_Sharpness_Label             540
#define IDC_Sharpness_Minimum           0
#define IDC_Sharpness_Maximum           0
#define IDC_Sharpness_Default           0
#define IDC_Sharpness_Stepping          0
#define IDC_Sharpness_Edit              545
#define IDC_Sharpness_Slider            546
#define IDC_Sharpness_Auto              547

#define IDC_Gamma_Label                 550
#define IDC_Gamma_Minimum               0
#define IDC_Gamma_Maximum               0
#define IDC_Gamma_Default               0
#define IDC_Gamma_Stepping              0
#define IDC_Gamma_Edit                  555
#define IDC_Gamma_Slider                556
#define IDC_Gamma_Auto                  557

#define IDC_ColorEnable_Label           560
#define IDC_ColorEnable_Minimum         0
#define IDC_ColorEnable_Maximum         0
#define IDC_ColorEnable_Default         0
#define IDC_ColorEnable_Stepping        0
#define IDC_ColorEnable_Edit            565
#define IDC_ColorEnable_Slider          566
#define IDC_ColorEnable_Auto            567

#define IDC_WhiteBalance_Label          570
#define IDC_WhiteBalance_Minimum        0
#define IDC_WhiteBalance_Maximum        0
#define IDC_WhiteBalance_Default        0
#define IDC_WhiteBalance_Stepping       0
#define IDC_WhiteBalance_Edit           575
#define IDC_WhiteBalance_Slider         576
#define IDC_WhiteBalance_Auto           577

#define IDC_BacklightComp_Label         580
#define IDC_BacklightComp_Minimum       0
#define IDC_BacklightComp_Maximum       0
#define IDC_BacklightComp_Default       0
#define IDC_BacklightComp_Stepping      0
#define IDC_BacklightComp_Edit          585
#define IDC_BacklightComp_Slider        586
#define IDC_BacklightComp_Auto          587

#define IDC_CPULoad_Label               700
#define IDC_CPULoad_Minimum             701
#define IDC_CPULoad_Maximum             702
#define IDC_CPULoad_Default             703
#define IDC_CPULoad_Stepping            704
#define IDC_CPULoad_Edit                705
#define IDC_CPULoad_Slider              706
#define IDC_CPULoad_Meter               707
#define IDC_CPULoad_Actual              708

#define IDC_MaxProcessingTime_Label     710
#define IDC_MaxProcessingTime_Minimum   711
#define IDC_MaxProcessingTime_Maximum   712
#define IDC_MaxProcessingTime_Default   713
#define IDC_MaxProcessingTime_Stepping  714
#define IDC_MaxProcessingTime_Edit      715
#define IDC_MaxProcessingTime_Slider    716
#define IDC_MaxProcessingTime_Meter     717
#define IDC_MaxProcessingTime_Actual    718

#define IDC_Freeze_Picture_Request      720

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         341
#define _APS_NEXT_SYMED_VALUE           116
#endif
#endif

#endif // } USE_PROPERTY_PAGES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\propedit.cpp ===
/****************************************************************************
 *  @doc INTERNAL PROPEDIT
 *
 *  @module PropEdit.cpp | Source file for the <c CPropertyEditor>
 *    class used to implement behavior of a single property to be displayed
 *    in a property page.
 *
 *  @comm This code is only compiled if USE_PROPERTY_PAGES is defined.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_PROPERTY_PAGES

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc void | CPropertyEditor | CPropertyEditor | This
 *    method is the constructor for property objects.
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    progress bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the property.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CPropertyEditor::CPropertyEditor(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl)
: m_hDlg (hDlg), m_hWndMin (NULL), m_hWndMax (NULL), m_hWndDefault (NULL), m_hWndStep (NULL), m_hWndEdit (NULL), m_hWndTrackbar (NULL), m_hWndProgress (NULL), m_IDLabel (IDLabel), m_hWndAuto (NULL), m_IDAutoControl (IDAutoControl)
, m_IDMinControl (IDMinControl), m_IDMaxControl (IDMaxControl), m_IDDefaultControl (IDDefaultControl), m_IDStepControl (IDStepControl), m_IDTrackbarControl (IDTrackbarControl), m_IDProgressControl (IDProgressControl)
, m_IDEditControl (IDEditControl), m_IDProperty (IDProperty), m_Active (FALSE), m_Min (0), m_Max (0), m_DefaultValue (0), m_DefaultFlags (0), m_SteppingDelta (0), m_CurrentValue (0), m_TrackbarOffset (0), m_ProgressOffset (0), m_fCheckBox (0)
, m_CurrentFlags (0), m_CanAutoControl (FALSE)

{
	FX_ENTRY("CPropertyEditor::CPropertyEditor")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | Init | This initializes the controls.
 *
 *  @rdesc TRUE on success, FALSE otherwise.
 ***************************************************************************/
BOOL CPropertyEditor::Init()
{
	HRESULT Hr = NOERROR;
	BOOL	fRes = TRUE;

	FX_ENTRY("CPropertyEditor::Init")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// For now disable all controls, and re-enable only the ones that make sense
	// at the end of this initialization function

	// Those GetDlgItem calls 'd better not fail ;)
	if (m_IDLabel)
		EnableWindow(GetDlgItem(m_hDlg, m_IDLabel), FALSE);
	if (m_IDMinControl)
		EnableWindow(m_hWndMin = GetDlgItem(m_hDlg, m_IDMinControl), FALSE);
	if (m_IDMaxControl)
		EnableWindow(m_hWndMax = GetDlgItem(m_hDlg, m_IDMaxControl), FALSE);
	if (m_IDDefaultControl)
		EnableWindow(m_hWndDefault = GetDlgItem(m_hDlg, m_IDDefaultControl), FALSE);
	if (m_IDStepControl)
		EnableWindow(m_hWndStep = GetDlgItem(m_hDlg, m_IDStepControl), FALSE);
	if (m_IDEditControl)
		EnableWindow(m_hWndEdit = GetDlgItem(m_hDlg, m_IDEditControl), FALSE);
	if (m_IDTrackbarControl)
		EnableWindow(m_hWndTrackbar = GetDlgItem(m_hDlg, m_IDTrackbarControl), FALSE);
	if (m_IDProgressControl)
		EnableWindow(m_hWndProgress = GetDlgItem(m_hDlg, m_IDProgressControl), FALSE);
	if (m_IDAutoControl)
		EnableWindow(m_hWndAuto = GetDlgItem(m_hDlg, m_IDAutoControl), FALSE);

	// Only enable the control if we can read the current value
	if (FAILED(Hr = GetValue()))
	{
		fRes = FALSE;
		goto MyExit;
	}

	// Save original value in case user clicks Cancel
	m_OriginalValue = m_CurrentValue;
	m_OriginalFlags = m_CurrentFlags;

	// Get the range, stepping, default, and capabilities
	if (FAILED(Hr = GetRange()))
	{
		// Special case, if no trackbar and no edit box, treat the
		// autocheck box as a boolean to control the property
		if (m_hWndTrackbar || m_hWndEdit || m_hWndProgress)
		{
			fRes = FALSE;
			goto MyExit;
		}
	}
	else
	{
		ASSERT(!(m_Min > m_Max || m_CurrentValue > m_Max || m_CurrentValue < m_Min || m_DefaultValue > m_Max || m_DefaultValue < m_Min));
		if (m_Min > m_Max || m_CurrentValue > m_Max || m_CurrentValue < m_Min || m_DefaultValue > m_Max || m_DefaultValue < m_Min)
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s: ERROR: Invalid range or current value", _fx_));
			fRes = FALSE;
			goto MyExit;
		}

		if (m_Min == 0 && m_Max == 1 && m_SteppingDelta == 1)
			m_fCheckBox = TRUE;
	}

	// We're ready to rock & roll
	m_Active = TRUE;

	// Re-enable appropriate controls
	if (m_IDLabel)
	{
		EnableWindow(GetDlgItem(m_hDlg, m_IDLabel), TRUE);
	}
	if (m_hWndMin)
	{
		SetDlgItemInt(m_hDlg, m_IDMinControl, m_Min, TRUE);
		EnableWindow(m_hWndMin, TRUE);
	}
	if (m_hWndMax)
	{
		SetDlgItemInt(m_hDlg, m_IDMaxControl, m_Max, TRUE);
		EnableWindow(m_hWndMax, TRUE);
	}
	if (m_hWndDefault)
	{
		SetDlgItemInt(m_hDlg, m_IDDefaultControl, m_DefaultValue, TRUE);
		EnableWindow(m_hWndDefault, TRUE);
	}
	if (m_hWndStep)
	{
		SetDlgItemInt(m_hDlg, m_IDStepControl, m_SteppingDelta, TRUE);
		EnableWindow(m_hWndStep, TRUE);
	}
	if (m_hWndEdit)
	{
		UpdateEditBox();
		EnableWindow(m_hWndEdit, TRUE);
	}
	if (m_hWndTrackbar)
	{
		EnableWindow(m_hWndTrackbar, TRUE);

		// Trackbars don't handle negative values, so slide everything positive
		if (m_Min < 0)
			m_TrackbarOffset = -m_Min;

		SendMessage(m_hWndTrackbar, TBM_SETRANGEMAX, FALSE, m_Max + m_TrackbarOffset);
		SendMessage(m_hWndTrackbar, TBM_SETRANGEMIN, FALSE, m_Min + m_TrackbarOffset);

		// Have fun with the keyboards Page Up, Page Down, and arrows
		SendMessage(m_hWndTrackbar, TBM_SETLINESIZE, FALSE, (LPARAM) m_SteppingDelta);
		SendMessage(m_hWndTrackbar, TBM_SETPAGESIZE, FALSE, (LPARAM) m_SteppingDelta);

		UpdateTrackbar();
	}
	if (m_hWndProgress)
	{
		EnableWindow(m_hWndProgress, TRUE);

		// Progress controls don't handle negative values, so slide everything positive
		if (m_Min < 0)
			m_ProgressOffset = -m_Min;

		SendMessage(m_hWndProgress, PBM_SETRANGE32, m_Min + m_ProgressOffset, m_Max + m_ProgressOffset);

		UpdateProgress();

		// Set a timer to update the progress regularly
		SetTimer(m_hDlg, 123456, 250, NULL);
	}
	if (m_hWndAuto)
	{
		// If the control has an auto setting, enable the auto checkbox
		m_CanAutoControl = CanAutoControl();
		EnableWindow (m_hWndAuto, m_CanAutoControl);
		if (m_CanAutoControl)
		{
			Button_SetCheck (m_hWndAuto, GetAuto ());
		}
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return fRes;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc void | CPropertyEditor | ~CPropertyEditor | Destructor for this class.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CPropertyEditor::~CPropertyEditor()
{
	FX_ENTRY("CPropertyEditor::~CPropertyEditor")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Kill timer if we have a progress bar
	if (m_hWndProgress)
		KillTimer(m_hDlg, 123456);

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc void | CPropertyEditor | OnApply | This member function is
 *    called by the framework when the user chooses the OK or the Apply Now
 *    button. When the framework calls this member function, changes made on
 *    all property pages in the property sheet are accepted, the property
 *    sheet retains focus.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::OnApply()
{
	int nCurrentValue;

	FX_ENTRY("CPropertyEditor::OnApply")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Make sure the value is a multiple of the stepping delta
	if (m_SteppingDelta)
	{
		nCurrentValue = m_CurrentValue;
		m_CurrentValue = m_CurrentValue / m_SteppingDelta * m_SteppingDelta;
		if (m_CurrentValue != nCurrentValue)
		{
			UpdateEditBox();
			UpdateTrackbar();
		}
	}

	// Backup current value in order to only apply changes if something has really changed
	m_OriginalValue = m_CurrentValue;
	m_OriginalFlags = m_CurrentFlags;

	// Set the value on the device
	SetValue();

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc void | CPropertyEditor | HasChanged | This member tests for a
 *    change in value.
 *
 *  @rdesc Returns TRUE if value has changed.
 ***************************************************************************/
BOOL CPropertyEditor::HasChanged()
{
	FX_ENTRY("CPropertyEditor::HasChanged")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));

	return (m_CurrentValue != m_OriginalValue);
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | OnDefault | Resets the position of the
 *    slide bar and updates the content of the Target windows after the user
 *    pressed the Default button.
 *
 *  @rdesc Returns TRUE if Active, FALSE otherwise.
 ***************************************************************************/
BOOL CPropertyEditor::OnDefault()
{
	BOOL fRes = TRUE;

	FX_ENTRY("CPropertyEditor::OnDefault")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	if (!m_Active)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s: WARNING: Control not active yet!", _fx_));
		fRes = FALSE;
		goto MyExit;
	}

	// Backup value in case user goes for the Cancel button
	m_CurrentValue = m_DefaultValue;
    m_CurrentFlags = m_DefaultFlags;

	// Update appropriate controls
	UpdateEditBox();
	UpdateTrackbar();
	UpdateAuto();

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return fRes;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | OnScroll | Reads the position of the
 *    slide bar and updates the content of the Target windows after the user
 *    has messed with the slide bar.
 *
 *  @rdesc Returns TRUE if Active, FALSE otherwise.
 ***************************************************************************/
BOOL CPropertyEditor::OnScroll(ULONG nCommand, WPARAM wParam, LPARAM lParam)
{
	int pos;
	int command = LOWORD(wParam);
	BOOL fRes = TRUE;

	FX_ENTRY("CPropertyEditor::OnScroll")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input params
	if (command != TB_ENDTRACK && command != TB_THUMBTRACK && command != TB_LINEDOWN && command != TB_LINEUP && command != TB_PAGEUP && command != TB_PAGEDOWN)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s: ERROR: Invalid input parameter!", _fx_));
		fRes = FALSE;
		goto MyExit;
	}
	ASSERT (IsWindow((HWND) lParam));
	if (!m_Active)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s: WARNING: Control not active yet!", _fx_));
		fRes = FALSE;
		goto MyExit;
	}

	// Retrieve position in slide bar
	pos = (int)SendMessage((HWND) lParam, TBM_GETPOS, 0, 0L);

	// Make sure the value is a multiple of the stepping delta
	if (m_SteppingDelta)
		m_CurrentValue = (pos - m_TrackbarOffset) / m_SteppingDelta * m_SteppingDelta;
	else
		m_CurrentValue = pos - m_TrackbarOffset;

	// Sync edit box to the slide bar
	UpdateEditBox();

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return fRes;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | OnEdit | Reads the content of the
 *    Target window and updates the postion of the slider after the user
 *    has messed with the Target edit control.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::OnEdit(ULONG nCommand, WPARAM wParam, LPARAM lParam)
{
	BOOL fTranslated;
	int nCurrentValue;

	FX_ENTRY("CPropertyEditor::OnEdit")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// We get called even before init has been done -> test for m_Active
	if (m_Active)
	{
		if (!m_fCheckBox)
		{
			// Read the value from the control
			if (m_hWndEdit)
				nCurrentValue = GetDlgItemInt(m_hDlg, m_IDEditControl, &fTranslated, TRUE);

			// Is the value garbage?
			if (fTranslated)
			{
				if (nCurrentValue > m_Max)
				{
					// The value is already large than its max -> clamp it and update the control
					m_CurrentValue = m_Max;
					UpdateEditBox();
				}
				else if (nCurrentValue < m_Min)
				{
					// The value is already smaller than its min -> clamp it and update the control
					m_CurrentValue = m_Min;
					UpdateEditBox();
				}
				else
					m_CurrentValue = nCurrentValue;
			}
			else
			{
				// It's garbage -> Reset the control to its minimum value
				m_CurrentValue = m_Min;
				UpdateEditBox();
			}

			// Sync slide bar to edit box
			UpdateTrackbar();
		}
		else
		{
			// Read the value from the control
			if (m_hWndEdit)
				m_CurrentValue = Button_GetCheck(m_hWndEdit);
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | OnAuto | Gets the status of the
 *    checkbox.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::OnAuto(ULONG nCommand, WPARAM wParam, LPARAM lParam)
{
	SetAuto(Button_GetCheck(m_hWndAuto));

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HWND | CPropertyEditor | GetTrackbarHWnd | Helper method to allow
 *    the property page code to access the slide bar window (private member) of
 *    a property.
 *
 *  @rdesc Returns a handle to the slide bar window.
 ***************************************************************************/
HWND CPropertyEditor::GetTrackbarHWnd()
{
	return m_hWndTrackbar;
};

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HWND | CPropertyEditor | GetProgressHWnd | Helper method to allow
 *    the property page code to access the progress bar window (private member) of
 *    a property.
 *
 *  @rdesc Returns a handle to the progress window.
 ***************************************************************************/
HWND CPropertyEditor::GetProgressHWnd()
{
	return m_hWndProgress;
};

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HWND | CPropertyEditor | GetEditHWnd | Helper method to allow
 *    the property page code to access the Target window (private member) of
 *    a property.
 *
 *  @rdesc Returns a handle to the Target window.
 ***************************************************************************/
HWND CPropertyEditor::GetEditHWnd()
{
	return m_hWndEdit;
};

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HWND | CPropertyEditor | GetAutoHWnd | Helper method to allow
 *    the property page code to access the auto window (private member) of
 *    a property.
 *
 *  @rdesc Returns a handle to the auto window.
 ***************************************************************************/
HWND CPropertyEditor::GetAutoHWnd()
{
	return m_hWndAuto;
};

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | UpdateEditBox | Updates the content of
 *    the Target window after user has moved the slide bar.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::UpdateEditBox()
{
	if (m_hWndEdit)
	{
		if (!m_fCheckBox)
			SetDlgItemInt(m_hDlg, m_IDEditControl, m_CurrentValue, TRUE);
		else
			Button_SetCheck(m_hWndEdit, m_CurrentValue);
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | UpdateTrackbar | Updates the position of
 *    the slide bar after user has messed with the Target window.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::UpdateTrackbar()
{
	if (m_hWndTrackbar)
		SendMessage(m_hWndTrackbar, TBM_SETPOS, TRUE, (LPARAM) m_CurrentValue + m_TrackbarOffset);

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | UpdateProgress | Updates the position of
 *    the progress bar.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::UpdateProgress()
{
	// Get current value from the device
	GetValue();

	if (m_hWndProgress)
		SendMessage(m_hWndProgress, PBM_SETPOS, (WPARAM) m_CurrentValue + m_ProgressOffset, 0);

	UpdateEditBox();

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | UpdateAuto | Updates the auto checkbox
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::UpdateAuto()
{
	if (m_hWndAuto && CanAutoControl())
	{
		m_CanAutoControl = GetAuto();
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HRESULT | CPropertyEditor | CanAutoControl | This method
 *    retrieves the automatic control capabilities for a property.
 *
 *  @rdesc This method returns TRUE if automatic control is supported, FALSE
 *    otherwise.
 ***************************************************************************/
BOOL CPropertyEditor::CanAutoControl(void)
{
	FX_ENTRY("CPropertyEditor::CanAutoControl")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));

	return m_CapsFlags & TAPIControl_Flags_Auto;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HRESULT | CPropertyEditor | GetAuto | This method
 *    retrieves the current automatic control mode of a property.
 *
 *  @rdesc This method returns TRUE if automatic control is supported, FALSE
 *    otherwise.
 ***************************************************************************/
BOOL CPropertyEditor::GetAuto(void)
{
	FX_ENTRY("CPropertyEditor::GetAuto")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	GetValue();

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));

	return m_CurrentFlags & TAPIControl_Flags_Auto; 
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HRESULT | CPropertyEditor | SetAuto | This method
 *    sets the automatic control mode of a property.
 *
 *  @parm BOOL | fAuto | Specifies the automatic control mode.
 *
 *  @rdesc This method returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::SetAuto(BOOL fAuto)
{
	FX_ENTRY("CPropertyEditor::SetAuto")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	m_CurrentFlags = (fAuto ? TAPIControl_Flags_Auto : (m_CapsFlags & TAPIControl_Flags_Manual) ? TAPIControl_Flags_Manual : TAPIControl_Flags_None);

	SetValue();

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));

	return TRUE; 
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\tapivdec.cpp ===
/****************************************************************************
 *  @doc INTERNAL TAPIVDEC
 *
 *  @module TAPIVDec.cpp | Source file for the <c CTAPIVDec>
 *    class used to implement the TAPI H.26X Video Decoder filter.
 ***************************************************************************/

#include "Precomp.h"

//#define NO_YUV_MODES 1


typedef struct
{
    WORD biWidth;
    WORD biHeight;
} MYFRAMESIZE;

// Array of known ITU sizes
MYFRAMESIZE g_ITUSizes[8] =
{
        {    0,   0 }, {  128,  96 }, {  176, 144 }, {  352, 288 },
        {  704, 576 }, { 1408,1152 }, {    0,   0 }, {    0,   0 }
};

#define MIN_IFRAME_REQUEST_INTERVAL 15000UL

#ifdef DEBUG
// Setup data
const AMOVIESETUP_MEDIATYPE sudInputTypes[] =
{
        {
                &MEDIATYPE_Video,       // Major type
                &MEDIASUBTYPE_NULL      // Minor type
        },
        {
                &MEDIATYPE_RTP_Single_Stream,   // Major type
                &MEDIASUBTYPE_NULL                              // Minor type
        }
};

const AMOVIESETUP_MEDIATYPE sudOutputType[] =
{
        {
                &MEDIATYPE_Video,       // Major type
                &MEDIASUBTYPE_NULL      // Minor type
        }
};

const AMOVIESETUP_PIN sudDecoderPins[] =
{
        {
                L"H26X In",                     // Pin string name
                FALSE,                          // Is it rendered
                FALSE,                          // Is it an output
                FALSE,                          // Can we have none
                FALSE,                          // Can we have many
                &CLSID_NULL,            // Connects to filter
                NULL,                           // Connects to pin
                2,                                      // Number of types
                sudInputTypes           // Pin details
        },
        {
                L"Video Out",           // Pin string name
                FALSE,                          // Is it rendered
                TRUE,                           // Is it an output
                FALSE,                          // Can we have none
                FALSE,                          // Can we have many
                &CLSID_NULL,            // Connects to filter
                NULL,                           // Connects to pin
                1,                                      // Number of types
                sudOutputType           // Pin details
        }
};

const AMOVIESETUP_FILTER sudVideoDecoder =
{
        &__uuidof(TAPIVideoDecoder),// Filter CLSID
        L"TAPI H.26X Video Decoder",// String name
        MERIT_DO_NOT_USE,                       // Filter merit
        2,                                                      // Number pins
        sudDecoderPins                          // Pin details
};
#endif

#if DXMRTP <= 0

// COM global table of objects in this dll
CFactoryTemplate g_Templates[] =
{
    VIDEO_DECODER_TEMPLATE

#ifdef USE_PROPERTY_PAGES
/* Begin properties */

    ,INPUT_PIN_PROP_TEMPLATE

    ,OUTPUT_PIN_PROP_TEMPLATE

#ifdef USE_CAMERA_CONTROL
    ,DECCAMERA_CONTROL_TEMPLATE
#endif

#ifdef USE_VIDEO_PROCAMP
    ,VIDEO_SETTING_PROP_TEMPLATE
#endif

/* End properties */
#endif /* USE_PROPERTY_PAGES */
};
int g_cTemplates = sizeof(g_Templates)/sizeof(g_Templates[0]);

STDAPI DllRegisterServer()
{
        return AMovieDllRegisterServer2(TRUE);
}

STDAPI DllUnregisterServer()
{
        return AMovieDllRegisterServer2(FALSE);
}

EXTERN_C BOOL WINAPI DllEntryPoint( HANDLE hInst, ULONG lReason, LPVOID lpReserved );

BOOL WINAPI DllMain( HANDLE hInst, DWORD dwReason, LPVOID lpReserved )
{
        switch (dwReason)
        {
                case DLL_PROCESS_ATTACH:
                {
                        break;
                }

                case DLL_PROCESS_DETACH:
                {
                        break;
                }
        }

        // Pass the call onto the DShow SDK initialization
        return DllEntryPoint(hInst, dwReason, lpReserved);
}
#endif /* DXMRTP <= 0 */

#if DBG
DWORD g_dwVideoDecoderTraceID = INVALID_TRACEID;
#endif

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc void | CTAPIVDec | CTAPIVDec | This method is the constructor
 *    for the <c CTAPIVDec> object.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CTAPIVDec::CTAPIVDec(IN LPUNKNOWN pUnkOuter, IN TCHAR *pName, OUT HRESULT *pHr)
    : CBaseFilter(pName, pUnkOuter, &m_csFilter, __uuidof(TAPIVideoDecoder))
{
        FX_ENTRY("CTAPIVDec::CTAPIVDec")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        m_pInput = NULL;
        m_pOutput = NULL;

        m_pDriverProc = NULL;
#if DXMRTP <= 0
        m_hTAPIH26XDLL = NULL;
#endif
        m_pInstInfo = NULL;
        m_FourCCIn = 0xFFFFFFFF;
        m_pbyReconstruct = NULL;
        m_fICMStarted = FALSE;

#ifdef USE_CAMERA_CONTROL
        m_lCCPan  = 0L;
        m_lCCTilt = 0L;
        m_lCCZoom = 10L;
        m_fFlipVertical = FALSE;
        m_fFlipHorizontal = FALSE;
#endif

#ifdef USE_VIDEO_PROCAMP
        m_lVPABrightness = 128L;
        m_lVPAContrast   = 128L;
        m_lVPASaturation = 128L;
#endif

        // H.245 Video Decoder & Encoder commands
        m_fFreezePicture = FALSE;
        m_pIH245EncoderCommand = NULL;

        // Current output format
        m_pMediaType = NULL;

        m_bSampleSkipped = FALSE;

        //for the RTP Payload Header Mode (0=draft, 1=RFC2190)
        m_RTPPayloadHeaderMode = RTPPayloadHeaderMode_Draft;


        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc void | CTAPIVDec | ~CTAPIVDec | This method is the destructor
 *    for the <c CTAPIVDec> object.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CTAPIVDec::~CTAPIVDec()
{
        FX_ENTRY("CTAPIVDec::~CTAPIVDec")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        if (m_pInstInfo)
        {
                // Terminate H.26X decompression
                if (m_fICMStarted)
                {
#if defined(ICM_LOGGING) && defined(DEBUG)
                        OutputDebugString("CTAPIVDec::~CTAPIVDec - ICM_DECOMPRESSEX_END\r\n");
#endif
                        (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX_END, 0L, 0L);
                        m_fICMStarted = FALSE;
                }

                // Terminate H.26X decoder
#if defined(ICM_LOGGING) && defined(DEBUG)
                OutputDebugString("CTAPIVDec::~CTAPIVDec - DRV_CLOSE\r\n");
                OutputDebugString("CTAPIVDec::~CTAPIVDec - DRV_FREE\r\n");
#endif
                (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, DRV_CLOSE, 0L, 0L);
                (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, DRV_FREE, 0L, 0L);
                m_pInstInfo = NULL;
                m_pDriverProc = NULL;
        }

#if DXMRTP <= 0
        // Release TAPIH26X.DLL
        if (m_hTAPIH26XDLL)
                FreeLibrary(m_hTAPIH26XDLL), m_hTAPIH26XDLL = NULL;
#endif

        // Release H.245 Encoder command outgoing interface
        if (m_pIH245EncoderCommand)
                m_pIH245EncoderCommand->Release();

        // Current output format
        if (m_pMediaType)
                DeleteMediaType(m_pMediaType); m_pMediaType = NULL;

        // Release the pins
        if (m_pOutput)
                delete m_pOutput;
        if (m_pInput)
                delete m_pInput;

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc CUnknown* | CTAPIVDec | CreateInstance | This
 *    method is called by DShow to create an instance of the TAPI H.26X Video
 *    Decoder Transform filter referred to in the global structure <t g_Templates>.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Returns a pointer to the nondelegating CUnknown portion of the
 *    object, or NULL otherwise.
 ***************************************************************************/
CUnknown *CALLBACK CTAPIVDecCreateInstance(IN LPUNKNOWN pUnkOuter, OUT HRESULT *pHr)
{
#if DBG
    if (g_dwVideoDecoderTraceID == INVALID_TRACEID)
    {
        // if two threads happen to call this method at the same time, it is
        // serialized inside TraceRegister.
        g_dwVideoDecoderTraceID = TraceRegister(TEXT("dxmrtp_VideoDecoder"));
    }
#endif

    CUnknown *pUnknown = NULL;

        FX_ENTRY("CTAPIVDec::CreateInstance")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pHr);
        if (!pHr)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                goto MyExit;
        }

        if (!(pUnknown = new CTAPIVDec(pUnkOuter, NAME("TAPI H.26X Video Decoder"), pHr)))
        {
                *pHr = E_OUTOFMEMORY;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: new CTAPIVDec failed", _fx_));
        }
        else
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: new CTAPIVDec created", _fx_));
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return pUnknown;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | NonDelegatingQueryInterface | This
 *    method is the nondelegating interface query function. It returns a pointer
 *    to the specified interface if supported. The only interfaces explicitly
 *    supported being <i IAMVideoProcAmp>, <i IAMCameraControl>, and
 *    <i IH245Capability>.
 *
 *  @parm REFIID | riid | Specifies the identifier of the interface to return.
 *
 *  @parm PVOID* | ppv | Specifies the place in which to put the interface
 *    pointer.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::NonDelegatingQueryInterface(IN REFIID riid, OUT void **ppv)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIVDec::NonDelegatingQueryInterface")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(ppv);
        if (!ppv)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Retrieve interface pointer
        if (riid == __uuidof(IRTPPayloadHeaderMode))
        {
                if (FAILED(Hr = GetInterface(static_cast<IRTPPayloadHeaderMode*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for IRTPPayloadHeaderMode failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: IRTPPayloadHeaderMode*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#ifdef USE_VIDEO_PROCAMP
        else if (riid == __uuidof(IVideoProcAmp))
        {
                if (FAILED(Hr = GetInterface(static_cast<IVideoProcAmp*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for IVideoProcAmp failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: IVideoProcAmp*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#endif
#ifdef USE_CAMERA_CONTROL
        else if (riid == __uuidof(ICameraControl))
        {
                if (FAILED(Hr = GetInterface(static_cast<ICameraControl*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for ICameraControl failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: ICameraControl*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#endif
#ifdef USE_PROPERTY_PAGES
        else if (riid == IID_ISpecifyPropertyPages)
        {
                if (FAILED(Hr = GetInterface(static_cast<ISpecifyPropertyPages*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for ISpecifyPropertyPages failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: ISpecifyPropertyPages*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#endif

        if (FAILED(Hr = CBaseFilter::NonDelegatingQueryInterface(riid, ppv)))
        {
                if (FAILED(Hr = CUnknown::NonDelegatingQueryInterface(riid, ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, WARN, "%s:   WARNING: NDQI for {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX} failed Hr=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}*=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], *ppv));
                }
        }
        else
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}*=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], *ppv));
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

#ifdef USE_PROPERTY_PAGES
/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | GetPages | This method Fills a counted
 *    array of GUID values where each GUID specifies the CLSID of each
 *    property page that can be displayed in the property sheet for this
 *    object.
 *
 *  @parm CAUUID* | pPages | Specifies a pointer to a caller-allocated CAUUID
 *    structure that must be initialized and filled before returning. The
 *    pElems field in the CAUUID structure is allocated by the callee with
 *    CoTaskMemAlloc and freed by the caller with CoTaskMemFree.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_OUTOFMEMORY | Allocation failed
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::GetPages(OUT CAUUID *pPages)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIVDec::GetPages")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pPages);
        if (!pPages)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

#ifdef USE_CAMERA_CONTROL
#ifdef USE_VIDEO_PROCAMP
        pPages->cElems = 2;
#else
        pPages->cElems = 1;
#endif
#else
#ifdef USE_VIDEO_PROCAMP
        pPages->cElems = 1;
#else
        pPages->cElems = 0;
#endif
#endif
        if (pPages->cElems)
        {
                if (!(pPages->pElems = (GUID *) QzTaskMemAlloc(sizeof(GUID) * pPages->cElems)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                        Hr = E_OUTOFMEMORY;
                }
                else
                {
#ifdef USE_CAMERA_CONTROL
#ifdef USE_VIDEO_PROCAMP
                        pPages->pElems[0] = __uuidof(TAPICameraControlPropertyPage);
                        pPages->pElems[1] = __uuidof(TAPIProcAmpPropertyPage);
#else
                        pPages->pElems[0] = __uuidof(TAPICameraControlPropertyPage);
#endif
#else
#ifdef USE_VIDEO_PROCAMP
                        pPages->pElems[0] = __uuidof(TAPIProcAmpPropertyPage);
#endif
#endif
                }
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
#endif

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | Transform | This method is used
 *    to perform the transform operations supported by this filter.
 *
 *  @parm IMediaSample* | pIn | Specifies a pointer to the input
 *    IMediaSample interface.
 *
 *  @parm IMediaSample** | ppOut | Specifies the address of a pointer to the
 *    output IMediaSample interface.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIVDec::InitializeOutputSample(IMediaSample *pIn, IMediaSample **ppOut)
{
        HRESULT                                 Hr;
        IMediaSample                    *pOutSample;
        AM_SAMPLE2_PROPERTIES   *pProps;
        DWORD                                   dwFlags;
        LONGLONG                                MediaStart, MediaEnd;

        FX_ENTRY("CTAPIVDec::InitializeOutputSample")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pIn);
        ASSERT(ppOut);
        if (!pIn || !ppOut)
        {
                Hr = E_POINTER;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                goto MyExit;
        }

        // default - times are the same
        pProps = m_pInput->SampleProps();
        dwFlags = m_bSampleSkipped ? AM_GBF_PREVFRAMESKIPPED : 0;

        // This will prevent the image renderer from switching us to DirectDraw
        // when we can't do it without skipping frames because we're not on a
        // keyframe. If it really has to switch us, it still will, but then we
        // will have to wait for the next keyframe
        if (!(pProps->dwSampleFlags & AM_SAMPLE_SPLICEPOINT))
        {
                dwFlags |= AM_GBF_NOTASYNCPOINT;
        }

        // Make sure the allocator is alive
        ASSERT(m_pOutput->m_pAllocator != NULL);
        if (!m_pOutput->m_pAllocator)
        {
                Hr = E_UNEXPECTED;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid allocator", _fx_));
                goto MyExit;
        }

        // Get an output sample from the allocator
        if (FAILED(Hr = m_pOutput->m_pAllocator->GetBuffer(&pOutSample, pProps->dwSampleFlags & AM_SAMPLE_TIMEVALID ? &pProps->tStart : NULL, pProps->dwSampleFlags & AM_SAMPLE_STOPVALID ? &pProps->tStop : NULL, dwFlags)) || !pOutSample)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: couldn't get output buffer", _fx_));
                goto MyExit;
        }

        *ppOut = pOutSample;

        // Initialize output sample state
        if (pProps->dwSampleFlags & AM_SAMPLE_TIMEVALID)
        {
                pOutSample->SetTime(&pProps->tStart, &pProps->tStop);
        }
        if (pProps->dwSampleFlags & AM_SAMPLE_SPLICEPOINT)
        {
                pOutSample->SetSyncPoint(TRUE);
        }
        if (pProps->dwSampleFlags & AM_SAMPLE_DATADISCONTINUITY)
        {
                pOutSample->SetDiscontinuity(TRUE);
                m_bSampleSkipped = FALSE;
        }

        // Copy the media times
        if (SUCCEEDED(pIn->GetMediaTime(&MediaStart, &MediaEnd)))
        {
                pOutSample->SetMediaTime(&MediaStart, &MediaEnd);
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}


#ifdef DEBUG
// #define LOGPAYLOAD_TOFILE 1
// #define LOGRTP_ON 1
///#define LOGPAYLOAD_ON 1
// #define LOGIFRAME_ON 1
// #define LOGSTREAMING_ON 1
#endif
#ifdef LOGPAYLOPAD_ON
int g_dbg_LOGPAYLOAD_TAPIVDec=-1;
#endif

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::SetMode(IN RTPPayloadHeaderMode rtpphmMode)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIVDec::SetMode")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(rtpphmMode == RTPPayloadHeaderMode_Draft || rtpphmMode == RTPPayloadHeaderMode_RFC2190);
        if (!(rtpphmMode == RTPPayloadHeaderMode_Draft || rtpphmMode == RTPPayloadHeaderMode_RFC2190))
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Save new target packet size
        m_RTPPayloadHeaderMode = rtpphmMode;

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   New RTP Payload Header mode: %s", _fx_, (rtpphmMode == RTPPayloadHeaderMode_RFC2190)?"RFC2190":"Draft"));

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}



/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | Transform | This method is used
 *    to perform the transform operations supported by this filter.
 *
 *  @parm IMediaSample* | pIn | Specifies a pointer to the input
 *    IMediaSample interface.
 *
 *  @parm LONG | lPrefixSize | Specifies The size of RTP prefix in the sample.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIVDec::Transform(IN IMediaSample *pIn, IN LONG lPrefixSize)
{
        HRESULT                         Hr = NOERROR;
        PBYTE                           pbySrc = NULL;
        PBYTE                           pbyDst = NULL;
        LPBITMAPINFOHEADER      lpbiSrc;
        LPBITMAPINFOHEADER      lpbiDst;
        DWORD                           dwFlags = 0UL;
        DWORD                           dwImageSize = 0UL;
        ICDECOMPRESSEX          icDecompress;
        LRESULT                         lRes;
        FOURCCMap                       fccOut;
        AM_MEDIA_TYPE           *pmtIn = NULL;
        AM_MEDIA_TYPE           *pmtOut = NULL;
        IMediaSample            *pOut = NULL;
        BOOL                            fFormatChanged = FALSE;
        BOOL                            bSkipPacket = FALSE;

        FX_ENTRY("CTAPIVDec::Transform")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pIn);
        if (!pIn)
        {
                Hr = E_POINTER;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                goto MyExit;
        }
        ASSERT(m_pInstInfo);
        ASSERT(m_pInput);
        ASSERT(m_pOutput);
        ASSERT(m_pInput->m_mt.pbFormat);
        ASSERT(m_pOutput->m_mt.pbFormat);
        if (!m_pInstInfo || !m_pInput || !m_pOutput || !m_pInput->m_mt.pbFormat || !m_pOutput->m_mt.pbFormat)
        {
                Hr = E_UNEXPECTED;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Decoder not initialized or not streaming", _fx_));
                goto MyExit;
        }

        // Get an output sample
        if (FAILED(Hr = InitializeOutputSample(pIn, &pOut)))
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Couldn't get output buffer", _fx_));
                goto MyExit;
        }

        // Get pointers to the input and output buffers
        if (FAILED(Hr = pIn->GetPointer(&pbySrc)) || !pbySrc)
        {
                Hr = E_UNEXPECTED;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid input buffer", _fx_));
                goto MyExit;
        }
        if (FAILED(Hr = pOut->GetPointer(&pbyDst)) || !pbyDst)
        {
                Hr = E_UNEXPECTED;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid output buffer", _fx_));
                goto MyExit;
        }

        // Get pointers to the input and output formats
        lpbiSrc = HEADER(m_pInput->m_mt.pbFormat);
        lpbiDst = HEADER(m_pOutput->m_mt.pbFormat);

        // We're getting variable size packets or frames - update the size
        dwImageSize = lpbiSrc->biSizeImage;
        lpbiSrc->biSizeImage = pIn->GetActualDataLength();

#ifdef DEBUG
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input Pin:  biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, HEADER(m_pInput->m_mt.pbFormat)->biCompression, HEADER(m_pInput->m_mt.pbFormat)->biBitCount, HEADER(m_pInput->m_mt.pbFormat)->biWidth, HEADER(m_pInput->m_mt.pbFormat)->biHeight, HEADER(m_pInput->m_mt.pbFormat)->biSize));
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input Rec:  left = %ld, top = %ld, right = %ld, bottom = %ld", _fx_, ((VIDEOINFOHEADER *)(m_pOutput->m_mt.pbFormat))->rcSource.left, ((VIDEOINFOHEADER *)(m_pOutput->m_mt.pbFormat))->rcSource.top, ((VIDEOINFOHEADER *)(m_pOutput->m_mt.pbFormat))->rcSource.right, ((VIDEOINFOHEADER *)(m_pOutput->m_mt.pbFormat))->rcSource.bottom));
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output Pin: biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld, biSizeImage = %ld", _fx_, HEADER(m_pOutput->m_mt.pbFormat)->biCompression, HEADER(m_pOutput->m_mt.pbFormat)->biBitCount, HEADER(m_pOutput->m_mt.pbFormat)->biWidth, HEADER(m_pOutput->m_mt.pbFormat)->biHeight, HEADER(m_pOutput->m_mt.pbFormat)->biSize, HEADER(m_pOutput->m_mt.pbFormat)->biSizeImage));
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output Rec: left = %ld, top = %ld, right = %ld, bottom = %ld", _fx_, ((VIDEOINFOHEADER *)(m_pOutput->m_mt.pbFormat))->rcTarget.left, ((VIDEOINFOHEADER *)(m_pOutput->m_mt.pbFormat))->rcTarget.top, ((VIDEOINFOHEADER *)(m_pOutput->m_mt.pbFormat))->rcTarget.right, ((VIDEOINFOHEADER *)(m_pOutput->m_mt.pbFormat))->rcTarget.bottom));
        pIn->GetMediaType((AM_MEDIA_TYPE **)&pmtIn);
        if (pmtIn != NULL && pmtIn->pbFormat != NULL)
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input Spl:  biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, HEADER(pmtIn->pbFormat)->biCompression, HEADER(pmtIn->pbFormat)->biBitCount, HEADER(pmtIn->pbFormat)->biWidth, HEADER(pmtIn->pbFormat)->biHeight, HEADER(pmtIn->pbFormat)->biSize));
                DeleteMediaType(pmtIn);
        }
        else
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input Spl:  No format", _fx_));
        }
#endif

        // Do we need to switch from GDI to DDraw?
        pOut->GetMediaType((AM_MEDIA_TYPE **)&pmtOut);
        if (pmtOut != NULL && pmtOut->pbFormat != NULL)
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output Spl: biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld, biSizeImage = %ld - Spl size = %ld", _fx_, HEADER(pmtOut->pbFormat)->biCompression, HEADER(pmtOut->pbFormat)->biBitCount, HEADER(pmtOut->pbFormat)->biWidth, HEADER(pmtOut->pbFormat)->biHeight, HEADER(pmtOut->pbFormat)->biSize, HEADER(pmtOut->pbFormat)->biSizeImage, pOut->GetActualDataLength()));
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Src Spl Rec:left = %ld, top = %ld, right = %ld, bottom = %ld", _fx_, ((VIDEOINFOHEADER *)(pmtOut->pbFormat))->rcSource.left, ((VIDEOINFOHEADER *)(pmtOut->pbFormat))->rcSource.top, ((VIDEOINFOHEADER *)(pmtOut->pbFormat))->rcSource.right, ((VIDEOINFOHEADER *)(pmtOut->pbFormat))->rcSource.bottom));
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Dst Spl Rec:left = %ld, top = %ld, right = %ld, bottom = %ld", _fx_, ((VIDEOINFOHEADER *)(pmtOut->pbFormat))->rcTarget.left, ((VIDEOINFOHEADER *)(pmtOut->pbFormat))->rcTarget.top, ((VIDEOINFOHEADER *)(pmtOut->pbFormat))->rcTarget.right, ((VIDEOINFOHEADER *)(pmtOut->pbFormat))->rcTarget.bottom));
        }
        else
        {
                pmtOut = NULL;
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output Spl:  No format - Spl size = %ld", _fx_, pOut->GetActualDataLength()));
        }

#ifdef DEBUG
        // Are we in direct draw mode?
    IDirectDraw *pidd;
    if (SUCCEEDED(pOut->QueryInterface(IID_IDirectDraw, (LPVOID *)&pidd)) && pidd != NULL)
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output Spl:  DDraw ON", _fx_));
        pidd->Release();
    }
    else
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output Spl:  DDraw OFF", _fx_));
    }
#endif

        // Are we decompressing video frames or reassembling RTP packets?
        if (HEADER(m_pInput->m_mt.pbFormat)->biCompression == FOURCC_R263 || HEADER(m_pInput->m_mt.pbFormat)->biCompression == FOURCC_R261)
        {
                // RTP packetized mode - reassemble the frame
                RtpHdr_t        *pRtpHdr;
                DWORD           dwPSCBytes = 0UL;
                DWORD           dwTRandPTYPEbytes = 0UL;
                DWORD           dwPayloadHeaderSize;
                DWORD           dwPreambleSize = 0;
                DWORD           dwITUSize;
                BOOL            fReceivedKeyframe;
                BOOL            fPacketLoss;
                DWORD           dwStartBit;
#if defined(LOGPAYLOAD_ON) || defined(LOGPAYLOAD_TOFILE) || defined(LOGIFRAME_ON) || defined(LOGSTREAMING_ON) || defined(LOGRTP_ON)
                HANDLE          g_TDebugFile;
                char            szTDebug[256];
                DWORD           d, GOBn;
                long            j;
#endif

                // Some inits
                dwITUSize = 0UL;

                // Look for the RTP header in this packet - the prefix contains the size
                // of the RTP header - move src pointer to the data right after it.
        if (lPrefixSize > 0)
        {
            RtpPrefixHdr_t *pPrefixHeader =
                (RtpPrefixHdr_t *)(((BYTE*)pbySrc) - lPrefixSize);

            if (pPrefixHeader->wPrefixID == RTPPREFIXID_HDRSIZE
                && pPrefixHeader->wPrefixLen == sizeof(RtpPrefixHdr_t))
            {
                // this is the prefix header provided by RTP source filter.

                dwPreambleSize = (DWORD)pPrefixHeader->lHdrSize;
            }
        }

        if (dwPreambleSize == 0)
        {
            return E_UNEXPECTED;
        }

                pRtpHdr = (RtpHdr_t *)(pbySrc);
                pbySrc += (DWORD)(dwPreambleSize);
#if defined(LOGPAYLOAD_ON) || defined(LOGRTP_ON)
                wsprintf(szTDebug, "RTP Header: PT=%ld, M=%ld, SEQ=%ld, TS=%lu\r\n", (DWORD)pRtpHdr->pt, (DWORD)pRtpHdr->m, (DWORD)(ntohs(pRtpHdr->seq)), (DWORD)(ntohl(pRtpHdr->ts)));
                OutputDebugString(szTDebug);
#endif

                // Check out the sequence number
                // If there is a gap between the new sequence number and the last
                // one, a frame got lost. Generate an I-Frame request then, but no more
                // often than one every 15 seconds.
                //
                // Is there a discontinuity in sequence numbers that was detected
                // in the past but not handled because an I-Frame request had already
                // been sent less than 15s ago? Is there a new discontinuity?
                fPacketLoss = ((DWORD)(ntohs(pRtpHdr->seq)) > 0UL) && (m_dwLastSeq != 0xFFFFFFFFUL) && (((DWORD)(ntohs(pRtpHdr->seq)) - 1) > m_dwLastSeq);
                if (m_fDiscontinuity || fPacketLoss)
                {
                        // Flush the reassembly buffer after a packet loss
                        if (fPacketLoss)
                        {
#ifdef LOGIFRAME_ON
                                OutputDebugString("Loss detected - Flushing reassembly buffer\r\n");
#endif
                                m_dwCurrFrameSize = 0UL;
                        }

                        // Issue an I-frame request only if we can and it is necessary
                        if (m_pIH245EncoderCommand)
                        {
                                DWORD dwNow = timeGetTime();

                                // Was the last time we issued an I-Frame request more than 15s ago?
                                if ((dwNow > m_dwLastIFrameRequest) && ((dwNow - m_dwLastIFrameRequest) > MIN_IFRAME_REQUEST_INTERVAL))
                                {
                                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: Loss detected - Sending I-Frame request...", _fx_));
#ifdef LOGIFRAME_ON
                                        OutputDebugString("Loss detected - Sending I-Frame request...\r\n");
#endif

                                        m_dwLastIFrameRequest = dwNow;
                                        m_fDiscontinuity = FALSE;
                                        m_fReceivedKeyframe = FALSE;

                                        // Ask the remote endpoint for a refresh
                                        videoFastUpdatePicture();
                                }
                                else
                                {
                                        if (!m_fReceivedKeyframe)
                                        {
                                                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: Loss detected but too soon to send I-Frame request. Wait %ld ms", _fx_, MIN_IFRAME_REQUEST_INTERVAL - (dwNow - m_dwLastIFrameRequest)));
#ifdef LOGIFRAME_ON
                                                wsprintf(szTDebug, "Loss detected but too soon to send I-Frame request. Wait %ld ms\r\n", MIN_IFRAME_REQUEST_INTERVAL - (dwNow - m_dwLastIFrameRequest));
                                                OutputDebugString(szTDebug);
#endif
                                                m_fDiscontinuity = TRUE;
                                        }
                                        else
                                        {
                                                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: Received a keyframe - resetting packet loss detector", _fx_));
#ifdef LOGIFRAME_ON
                                                OutputDebugString("Received a keyframe - resetting packet loss detector\r\n");
#endif
                                                m_fDiscontinuity = FALSE;
                                        }
                                }
                        }
                }
                m_dwLastSeq = (DWORD)(ntohs(pRtpHdr->seq));

                // Does the payload type of this packet matches the type of the video decoder
                // we are currently using - if not, pick up a new one
                if (pRtpHdr->pt == H263_PAYLOAD_TYPE)
                {
#define PF_F_BIT  0x80
#define PF_P_BIT  0x40
#define DRAFT_I_BIT (pbySrc[2] & 0x80)
#define RFC_4_I_BIT (pbySrc[1] & 0x10)
#define RFC_8_I_BIT (pbySrc[4] & 0x80)

                        // Let's reassemble those H.263 packets - strip the header of the packet
                        // and copy the payload in the video buffer

                        // Look for the first two bits to figure out what's the mode used.
                        // This will dictate the size of the header to be removed.
                        // Mode A is 4 bytes: first bit is set to 1,
                        // Mode B is 8 bytes: first bit is set to 0, second bit is set to 0,
                        // Mode C is 12 bytes: first bit is set to 0, second bit is set to 1.
                        dwPayloadHeaderSize = ((*pbySrc & PF_F_BIT) ? ((*pbySrc & PF_P_BIT) ? 12 : 8) : 4);

                        // Look at the payload header to figure out if the frame is a keyframe
                        // Update our flag to always remember this.
                        if(m_RTPPayloadHeaderMode==RTPPayloadHeaderMode_Draft) {  // 0 is the default mode
                            fReceivedKeyframe = (BOOL)DRAFT_I_BIT;
                        } else {
                            if (dwPayloadHeaderSize == 4) {
                                fReceivedKeyframe = (BOOL)RFC_4_I_BIT;
                            } else {    // both dwPayloadHeaderSize 8 and 12
                                fReceivedKeyframe = (BOOL)RFC_8_I_BIT;
                            }
                        }

#ifdef LOGPAYLOAD_ON
                        if(m_RTPPayloadHeaderMode==RTPPayloadHeaderMode_Draft) {
                            OutputDebugString("CTAPIVDec::Transform -- Draft Style Payload Header\r\n");
                        } else {
                            OutputDebugString("CTAPIVDec::Transform -- RFC 2190 Style Payload Header\r\n");
                        }
                        // Output some debug stuff
                        if (dwPayloadHeaderSize == 4)
                        {
                                // Header in mode A (!!! DRAFT VERSION !!!)
                                // 0                   1                   2                   3
                                // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                //|F|P|SBIT |EBIT | SRC | R       |I|A|S|DBQ| TRB |    TR         |
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                // But that's the network byte order...

                                // Header in mode A (*** RFC 2190 VERSION ***)
                                // 0                   1                   2                   3
                                // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                //|F|P|SBIT |EBIT | SRC |I|U|S|A|R      |DBQ| TRB |    TR         |
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


                                GOBn = (DWORD)((BYTE)pbySrc[4]) << 24 | (DWORD)((BYTE)pbySrc[5]) << 16 | (DWORD)((BYTE)pbySrc[6]) << 8 | (DWORD)((BYTE)pbySrc[7]);
                                GOBn >>= (DWORD)(10 - (DWORD)((pbySrc[0] & 0x38) >> 3));
                                GOBn &= 0x0000001F;
                                wsprintf(szTDebug, "Header content: Frame %3ld, GOB %0ld\r\n", (DWORD)(pbySrc[3]), GOBn);
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (pbySrc[0] & 0x80) ? "     F:   '1' => Mode B or C\r\n" : "     F:   '0' => Mode A\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (pbySrc[0] & 0x40) ? "     P:   '1' => PB-frame\r\n" : "     P:   '0' => I or P frame\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "  SBIT:    %01ld\r\n", (DWORD)((pbySrc[0] & 0x38) >> 3));
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "  EBIT:    %01ld\r\n", (DWORD)(pbySrc[0] & 0x07));
                                OutputDebugString(szTDebug);
                                switch ((DWORD)(pbySrc[1] >> 5))
                                {
                                        case 0:
                                                wsprintf(szTDebug, "   SRC: '000' => Source format forbidden!\r\n");
                                                break;
                                        case 1:
                                                wsprintf(szTDebug, "   SRC: '001' => Source format sub-QCIF\r\n");
                                                break;
                                        case 2:
                                                wsprintf(szTDebug, "   SRC: '010' => Source format QCIF\r\n");
                                                break;
                                        case 3:
                                                wsprintf(szTDebug, "   SRC: '011' => Source format CIF\r\n");
                                                break;
                                        case 4:
                                                wsprintf(szTDebug, "   SRC: '100' => Source format 4CIF\r\n");
                                                break;
                                        case 5:
                                                wsprintf(szTDebug, "   SRC: '101' => Source format 16CIF\r\n");
                                                break;
                                        case 6:
                                                wsprintf(szTDebug, "   SRC: '110' => Source format reserved\r\n");
                                                break;
                                        case 7:
                                                wsprintf(szTDebug, "   SRC: '111' => Source format reserved\r\n");
                                                break;
                                        default:
                                                wsprintf(szTDebug, "   SRC: %ld => Source format unknown!\r\n", (DWORD)(pbySrc[1] >> 5));
                                                break;
                                }
                                OutputDebugString(szTDebug);
                                if(m_RTPPayloadHeaderMode==RTPPayloadHeaderMode_Draft) {
                                    OutputDebugString("Draft Style Payload Header flags:\r\n");
                                    wsprintf(szTDebug, "     R:   %02ld  => Reserved, must be 0\r\n", (DWORD)(pbySrc[1] & 0x1F)); // no need for ">> 5"
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[2] & 0x80) ? "     I:   '1' => Intra-coded\r\n" : "     I:   '0' => Not Intra-coded\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[2] & 0x40) ? "     A:   '1' => Optional Advanced Prediction mode ON\r\n" : "     A:   '0' => Optional Advanced Prediction mode OFF\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[2] & 0x20) ? "     S:   '1' => Optional Syntax-based Arithmetic Code mode ON\r\n" : "     S:   '0' => Optional Syntax-based Arithmetic Code mode OFF\r\n");
                                    OutputDebugString(szTDebug);
                                } else {
                                    OutputDebugString("RFC 2190 Style Payload Header flags:\r\n");
                                    wsprintf(szTDebug, "     R:   %02ld  => Reserved, must be 0\r\n", (DWORD)((pbySrc[1] & 0x01) << 3) | (DWORD)((pbySrc[2] & 0xE0) >> 5));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[1] & 0x10) ? "     I:   '1' => Intra-coded\r\n" : "     I:   '0' => Not Intra-coded\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[1] & 0x08) ? "     U:   '1' => Unrestricted Motion Vector (bit10) was set in crt.pic.hdr.\r\n" : "     U:   '0' => Unrestricted Motion Vector (bit10) was 0 in crt.pic.hdr.\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[1] & 0x04) ? "     S:   '1' => Optional Syntax-based Arithmetic Code mode ON\r\n" : "     S:   '0' => Optional Syntax-based Arithmetic Code mode OFF\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[1] & 0x02) ? "     A:   '1' => Optional Advanced Prediction mode ON\r\n" : "     A:   '0' => Optional Advanced Prediction mode OFF\r\n");
                                    OutputDebugString(szTDebug);
                                }
                                wsprintf(szTDebug, "   DBQ:    %01ld  => Should be 0\r\n", (DWORD)((pbySrc[2] & 0x18) >> 3));
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "   TRB:    %01ld  => Should be 0\r\n", (DWORD)(pbySrc[2] & 0x07));
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "    TR:  %03ld\r\n", (DWORD)(pbySrc[3]));
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "Header: %02lX %02lX %02lX %02lX\r\n", (BYTE)pbySrc[0], (BYTE)pbySrc[1], (BYTE)pbySrc[2], (BYTE)pbySrc[3]);
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "dword1: %02lX %02lX %02lX %02lX\r\n", (BYTE)pbySrc[4], (BYTE)pbySrc[5], (BYTE)pbySrc[6], (BYTE)pbySrc[7]);
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "dword2: %02lX %02lX %02lX %02lX\r\n", (BYTE)pbySrc[8], (BYTE)pbySrc[9], (BYTE)pbySrc[10], (BYTE)pbySrc[11]);
                                OutputDebugString(szTDebug);
                        }
                        else if (dwPayloadHeaderSize == 8)
                        {
                                // Header in mode B (!!! DRAFT VERSION !!!)
                                // 0                   1                   2                   3
                                // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                //|F|P|SBIT |EBIT | SRC | QUANT   |I|A|S|  GOBN   |   MBA         |
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                //| HMV1          |  VMV1         |  HMV2         |   VMV2        |
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                                // But that's the network byte order...

                                // Header in mode B (*** RFC 2190 VERSION ***)
                                // 0                   1                   2                   3
                                // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                //|F|P|SBIT |EBIT | SRC | QUANT   |  GOBN   |   MBA           | R |
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                //|I|U|S|A| HMV1        |  VMV1       |  HMV2       |   VMV2      |
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


                                wsprintf(szTDebug, "Header content:\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (pbySrc[0] & 0x80) ? "     F:   '1' => Mode B or C\r\n" : "     F:   '0' => Mode A\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (pbySrc[0] & 0x40) ? "     P:   '1' => PB-frame\r\n" : "     P:   '0' => I or P frame\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "  SBIT:    %01ld\r\n", (DWORD)((pbySrc[0] & 0x38) >> 3));
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "  EBIT:    %01ld\r\n", (DWORD)(pbySrc[0] & 0x07));
                                OutputDebugString(szTDebug);
                                switch ((DWORD)(pbySrc[1] >> 5))
                                {
                                        case 0:
                                                wsprintf(szTDebug, "   SRC: '000' => Source format forbidden!\r\n");
                                                break;
                                        case 1:
                                                wsprintf(szTDebug, "   SRC: '001' => Source format sub-QCIF\r\n");
                                                break;
                                        case 2:
                                                wsprintf(szTDebug, "   SRC: '010' => Source format QCIF\r\n");
                                                break;
                                        case 3:
                                                wsprintf(szTDebug, "   SRC: '011' => Source format CIF\r\n");
                                                break;
                                        case 4:
                                                wsprintf(szTDebug, "   SRC: '100' => Source format 4CIF\r\n");
                                                break;
                                        case 5:
                                                wsprintf(szTDebug, "   SRC: '101' => Source format 16CIF\r\n");
                                                break;
                                        case 6:
                                                wsprintf(szTDebug, "   SRC: '110' => Source format reserved\r\n");
                                                break;
                                        case 7:
                                                wsprintf(szTDebug, "   SRC: '111' => Source format reserved\r\n");
                                                break;
                                        default:
                                                wsprintf(szTDebug, "   SRC: %ld => Source format unknown!\r\n", (DWORD)(pbySrc[1] >> 5));
                                                break;
                                }
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, " QUANT:   %02ld\r\n", (DWORD)((pbySrc[1] & 0x1F) >> 5));
                                OutputDebugString(szTDebug);
                                if(m_RTPPayloadHeaderMode==RTPPayloadHeaderMode_Draft) {
                                    wsprintf(szTDebug, (pbySrc[2] & 0x80) ? "     I:   '1' => Intra-coded\r\n" : "     I:   '0' => Not Intra-coded\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[2] & 0x40) ? "     A:   '1' => Optional Advanced Prediction mode ON\r\n" : "     A:   '0' => Optional Advanced Prediction mode OFF\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[2] & 0x20) ? "     S:   '1' => Optional Syntax-based Arithmetic Code mode ON\r\n" : "     S:   '0' => Optional Syntax-based Arithmetic Code mode OFF\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "  GOBN:  %03ld\r\n", (DWORD)(pbySrc[2] & 0x1F));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "   MBA:  %03ld\r\n", (DWORD)(pbySrc[3]));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "  HMV1:  %03ld\r\n", (DWORD)(pbySrc[7]));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "  VMV1:  %03ld\r\n", (DWORD)(pbySrc[6]));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "  HMV2:  %03ld\r\n", (DWORD)(pbySrc[5]));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "  VMV2:  %03ld\r\n", (DWORD)(pbySrc[4]));
                                    OutputDebugString(szTDebug);
                                } else {
                                    wsprintf(szTDebug, (pbySrc[4] & 0x80) ? "     I:   '1' => Intra-coded\r\n" : "     I:   '0' => Not Intra-coded\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[4] & 0x40) ? "     U:   '1' => Unrestricted Motion Vector (bit10) was set in crt.pic.hdr.\r\n" : "     U:   '1' => Unrestricted Motion Vector (bit10) was 0 in crt.pic.hdr.\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[4] & 0x20) ? "     S:   '1' => Optional Syntax-based Arithmetic Code mode ON\r\n" : "     S:   '0' => Optional Syntax-based Arithmetic Code mode OFF\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[4] & 0x10) ? "     A:   '1' => Optional Advanced Prediction mode ON\r\n" : "     A:   '0' => Optional Advanced Prediction mode OFF\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "  GOBN:  %03ld\r\n", (DWORD)(pbySrc[2] & 0xF8) >>3);
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "   MBA:  %03ld\r\n", (DWORD)((pbySrc[2] & 0x07) << 6) | (DWORD)((pbySrc[3] & 0xFC) >> 2));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "     R:   %02ld  => Reserved, must be 0\r\n", (DWORD)(pbySrc[3] & 0x03));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "  HMV1:  %03ld\r\n", (DWORD)((pbySrc[4] & 0x0F) << 3) | (DWORD)((pbySrc[5] & 0xE0) >> 5));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "  VMV1:  %03ld\r\n", (DWORD)((pbySrc[5] & 0x1F) << 2) | (DWORD)((pbySrc[6] & 0xC0) >> 6));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "  HMV2:  %03ld\r\n", (DWORD)((pbySrc[6] & 0x3F) << 1) | (DWORD)((pbySrc[7] & 0x80) >> 7));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "  VMV2:  %03ld\r\n", (DWORD)(pbySrc[7] & 0x7F));
                                    OutputDebugString(szTDebug);
                                }
                                wsprintf(szTDebug, "Header: %02lX %02lX %02lX %02lX\r\n", (BYTE)pbySrc[0], (BYTE)pbySrc[1], (BYTE)pbySrc[2], (BYTE)pbySrc[3]);
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "dword1: %02lX %02lX %02lX %02lX\r\n", (BYTE)pbySrc[4], (BYTE)pbySrc[5], (BYTE)pbySrc[6], (BYTE)pbySrc[7]);
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "dword2: %02lX %02lX %02lX %02lX\r\n", (BYTE)pbySrc[8], (BYTE)pbySrc[9], (BYTE)pbySrc[10], (BYTE)pbySrc[11]);
                                OutputDebugString(szTDebug);
                        }
                        if(g_dbg_LOGPAYLOAD_TAPIVDec > 0)
                                g_dbg_LOGPAYLOAD_TAPIVDec--;
                        else if(g_dbg_LOGPAYLOAD_TAPIVDec == 0)
                                DebugBreak();
#endif
                        // The purpose of this code is to look for the presence of the
                        // Picture Start Code at the beginning of the frame. If it is
                        // not present, we should break in debug mode.

                        // Only look for PSC at the beginning of the frame
                        if (!m_dwCurrFrameSize)
                        {
                                // The start of the frame may not be at a byte boundary. The SBIT field
                                // of the header ((BYTE)pbySrc[0] & 0xE0) will tell us exactly where
                                // our frame starts. We then look for the PSC (0000 0000 0000 0000 1000 00 bits)
                                *((BYTE *)&dwPSCBytes + 3) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize]);
                                *((BYTE *)&dwPSCBytes + 2) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 1]);
                                *((BYTE *)&dwPSCBytes + 1) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 2]);
                                *((BYTE *)&dwPSCBytes + 0) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 3]);
                                dwPSCBytes = dwPSCBytes << ((DWORD)((BYTE)pbySrc[0] & 0x38) >> 3);
                                if ((dwPSCBytes & 0xFFFFFC00) != 0x00008000)
                                {
                                        DBGOUT((g_dwVideoDecoderTraceID, WARN, "%s:   WARNING: The first packet to reassemble is missing a PSC! - Frame not passed to video render filter", _fx_));
#ifdef LOGIFRAME_ON
                                        OutputDebugString("The first packet to reassemble is missing a PSC! - bailing\r\n");
#endif
                                        m_fDiscontinuity = TRUE;
                                        Hr = S_FALSE;
                                        // DebugBreak();
                                        goto MyExit;
                                }

                                // Look for the format and freeze picture release bits
                                *((BYTE *)&dwTRandPTYPEbytes + 3) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 2]);
                                *((BYTE *)&dwTRandPTYPEbytes + 2) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 3]);
                                *((BYTE *)&dwTRandPTYPEbytes + 1) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 4]);
                                *((BYTE *)&dwTRandPTYPEbytes + 0) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 5]);
                                dwTRandPTYPEbytes = dwTRandPTYPEbytes << (((DWORD)((BYTE)pbySrc[0] & 0x38) >> 3) + 6);
                                if (dwTRandPTYPEbytes & 0x00080000)
                                        m_fFreezePicture = FALSE;

#ifdef LOGPAYLOAD_ON
                                wsprintf(szTDebug, "    TR:    %02ld\r\n", (DWORD)(dwTRandPTYPEbytes & 0xFF000000) >> 24);
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, " PTYPE:  0X%04lX\r\n", (DWORD)(dwTRandPTYPEbytes & 0x00FFF800) >> 11);
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00800000) ? "    Bit1:   '1' => Always '1', in order to avoid start code emulation\r\n" : "    Bit1:   '0' => WRONG: Should always be '1', in order to avoid start code emulation\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00400000) ? "    Bit2:   '1' => WRONG: Should always be '0', for distinction with H.261\r\n" : "    Bit2:   '0' => Always '0', for distinction with H.261\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00200000) ? "    Bit3:   '1' => Split screen indicator ON\r\n" : "    Bit3:   '0' => Split screen indicator OFF\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00100000) ? "    Bit4:   '1' => Document camera indicator ON\r\n" : "    Bit4:   '0' => Document camera indicator OFF\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00080000) ? "    Bit5:   '1' => Freeze picture release ON\r\n" : "    Bit5:   '0' => Freeze picture release OFF\r\n");
                                OutputDebugString(szTDebug);
                                switch ((DWORD)(dwTRandPTYPEbytes & 0x00070000) >> 16)
                                {
                                        case 0:
                                                wsprintf(szTDebug, "  Bit6-8: '000' => Source format forbidden!\r\n");
                                                break;
                                        case 1:
                                                wsprintf(szTDebug, "  Bit6-8: '001' => Source format sub-QCIF\r\n");
                                                break;
                                        case 2:
                                                wsprintf(szTDebug, "  Bit6-8: '010' => Source format QCIF\r\n");
                                                break;
                                        case 3:
                                                wsprintf(szTDebug, "  Bit6-8: '011' => Source format CIF\r\n");
                                                break;
                                        case 4:
                                                wsprintf(szTDebug, "  Bit6-8: '100' => Source format 4CIF\r\n");
                                                break;
                                        case 5:
                                                wsprintf(szTDebug, "  Bit6-8: '101' => Source format 16CIF\r\n");
                                                break;
                                        case 6:
                                                wsprintf(szTDebug, "  Bit6-8: '110' => Source format reserved\r\n");
                                                break;
                                        case 7:
                                                wsprintf(szTDebug, "  Bit6-8: '111' => Source format reserved\r\n");
                                                break;
                                        default:
                                                wsprintf(szTDebug, "  Bit6-8: %ld => Source format unknown!\r\n", (DWORD)(dwTRandPTYPEbytes & 0x00070000) >> 16);
                                                break;
                                }
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00008000) ? "    Bit9:   '1' => Picture Coding Type INTER\r\n" : "    Bit9:   '0' => Picture Coding Type INTRA\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00004000) ? "   Bit10:   '1' => Unrestricted Motion Vector mode ON\r\n" : "   Bit10:   '0' => Unrestricted Motion Vector mode OFF\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00002000) ? "   Bit11:   '1' => Syntax-based Arithmetic Coding mode ON\r\n" : "   Bit11:   '0' => Syntax-based Arithmetic Coding mode OFF\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00001000) ? "   Bit12:   '1' => Advanced Prediction mode ON\r\n" : "   Bit12:   '0' => Advanced Prediction mode OFF\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00000800) ? "   Bit13:   '1' => PB-frame\r\n" : "   Bit13:   '0' => I- or P-frame\r\n");
                                OutputDebugString(szTDebug);
#endif
                                // Which ITU size is this?
                                dwITUSize = (DWORD)(((BYTE)pbySrc[1]) >> 5);
                        }

                        // The end of a buffer and the start of the next buffer could belong to the
                        // same byte. If this is the case, the first byte of the next buffer was already
                        // copied in the video data buffer, with the previous packet. It should not be copied
                        // twice. The SBIT field of the payload header allows us to figure out if this is the case.
                        dwStartBit = (DWORD)((pbySrc[0] & 0x38) >> 3);
                        if (m_dwCurrFrameSize && dwStartBit)
                                dwPayloadHeaderSize++;
                }
                else if (pRtpHdr->pt == H261_PAYLOAD_TYPE)
                {
                        // Let's reassemble those H.261 packets - strip the header of the packet
                        // and copy the payload in the video buffer

                        // 0                   1                   2                   3
                        // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                        //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                        //|SBIT |EBIT |I|V| GOBN  |   MBAP  |  QUANT  |  HMVD   |  VMVD   |
                        //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                        // But that's the network byte order...

                        // The H.261 payload header size is always 4 bytes long
                        dwPayloadHeaderSize = 4;

                        // Look at the payload header to figure out if the frame is a keyframe
                        // Update our flag to always remember this.
                        fReceivedKeyframe = (BOOL)(pbySrc[0] & 0x02);

#ifdef LOGPAYLOAD_ON
                        // Output some debug stuff
                        wsprintf(szTDebug, "Header content: GOB %0ld\r\n", (DWORD)((pbySrc[1] & 0xF0) >> 4));
                        OutputDebugString(szTDebug);
                        wsprintf(szTDebug, "  SBIT:    %01ld\r\n", (DWORD)((pbySrc[0] & 0xE0) >> 5));
                        OutputDebugString(szTDebug);
                        wsprintf(szTDebug, "  EBIT:    %01ld\r\n", (DWORD)((pbySrc[0] & 0x1C) >> 2));
                        OutputDebugString(szTDebug);
                        wsprintf(szTDebug, (pbySrc[0] & 0x02) ? "     I:   '1' => I frame\r\n" : "     I:   '0' => P frame\r\n");
                        OutputDebugString(szTDebug);
                        wsprintf(szTDebug, (pbySrc[0] & 0x01) ? "     V:   '1' => Motion vectors may be used\r\n" : "     V:   '0' => Motion vectors are not used\r\n");
                        OutputDebugString(szTDebug);
                        wsprintf(szTDebug, "  MBAP:    %02ld\r\n", (DWORD)((pbySrc[2] & 0x80) >> 7) | (DWORD)((pbySrc[1] & 0x0F) << 1));
                        OutputDebugString(szTDebug);
                        wsprintf(szTDebug, " QUANT:    %02ld\r\n", (DWORD)((pbySrc[2] & 0x7C) >> 2));
                        OutputDebugString(szTDebug);
                        wsprintf(szTDebug, "  HMVD:    %02ld\r\n", (DWORD)((pbySrc[3] & 0xE0) >> 5) | (DWORD)((pbySrc[2] & 0x03) << 3));
                        OutputDebugString(szTDebug);
                        wsprintf(szTDebug, "  VMVD:    %02ld\r\n", (DWORD)((pbySrc[3] & 0x1F)));
                        OutputDebugString(szTDebug);
#endif
                        // The purpose of this code is to look for the presence of the
                        // Picture Start Code at the beginning of the frame. If it is
                        // not present, we should break in debug mode.

                        // Only look for PSC at the beginning of the frame
                        if (!m_dwCurrFrameSize)
                        {
                                // The start of the frame may not be at a byte boundary. The SBIT field
                                // of the header ((BYTE)pbySrc[0] & 0xE0) will tell us exactly where
                                // our frame starts. We then look for the PSC (0000 0000 0000 0001 0000 bits)
                                *((BYTE *)&dwPSCBytes + 3) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize]);
                                *((BYTE *)&dwPSCBytes + 2) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 1]);
                                *((BYTE *)&dwPSCBytes + 1) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 2]);
                                *((BYTE *)&dwPSCBytes + 0) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 3]);
                                dwPSCBytes <<= ((DWORD)((BYTE)pbySrc[0] & 0xE0) >> 5);
                                if ((dwPSCBytes & 0xFFFFF000) != 0x00010000)
                                {
                                        DBGOUT((g_dwVideoDecoderTraceID, WARN, "%s:   WARNING: The first packet to reassemble is missing a PSC! - Frame not passed to video render filter", _fx_));
#ifdef LOGIFRAME_ON
                                        OutputDebugString("The first packet to reassemble is missing a PSC! - bailing\r\n");
#endif
                                        m_fDiscontinuity = TRUE;
                                        Hr = S_FALSE;
                                        // DebugBreak();
                                        goto MyExit;
                                }

                                // Look for the format and freeze picture release bits
                                *((BYTE *)&dwTRandPTYPEbytes + 3) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 2]);
                                *((BYTE *)&dwTRandPTYPEbytes + 2) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 3]);
                                *((BYTE *)&dwTRandPTYPEbytes + 1) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 4]);
                                *((BYTE *)&dwTRandPTYPEbytes + 0) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 5]);
                                dwTRandPTYPEbytes <<= (((DWORD)((BYTE)pbySrc[0] & 0xE0) >> 5) + 4);
                                if (dwTRandPTYPEbytes & 0x01000000)
                                        m_fFreezePicture = FALSE;

#ifdef LOGPAYLOAD_ON
                                wsprintf(szTDebug, "    TR:    %02ld\r\n", (DWORD)(dwTRandPTYPEbytes & 0xF8000000) >> 27);
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, " PTYPE:  0X%02lX\r\n", (DWORD)(dwTRandPTYPEbytes & 0x07C00000) >> 21);
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x04000000) ? "    Bit1:   '1' => Split screen indicator ON\r\n" : "    Bit1:   '0' => Split screen indicator OFF\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x02000000) ? "    Bit2:   '1' => Document camera indicator ON\r\n" : "    Bit2:   '0' => Document camera indicator OFF\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x01000000) ? "    Bit3:   '1' => Freeze picture release ON\r\n" : "    Bit3:   '0' => Freeze picture release OFF\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00800000) ? "    Bit4:   '1' => Source format CIF\r\n" : "    Bit4:   '0' => Source format QCIF\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00400000) ? "    Bit5:   '1' => HI_RES mode OFF\r\n" : "    Bit5:   '0' => HI_RES mode ON\r\n");
                                OutputDebugString(szTDebug);
#endif
                                // Which ITU size is this?
                                dwITUSize = (DWORD)(dwTRandPTYPEbytes & 0x00800000) ? 3 : 2;
                        }

                        // The end of a buffer and the start of the next buffer could belong to the
                        // same byte. If this is the case, the first byte of the next buffer was already
                        // copied in the video data buffer, with the previous packet. It should not be copied
                        // twice. The SBIT field of the payload header allows us to figure out if this is the case.
                        dwStartBit = (DWORD)((pbySrc[0] & 0xE0) >> 5);
                        if (m_dwCurrFrameSize && dwStartBit)
                                dwPayloadHeaderSize++;
                }
                else
                {
                        // I have no clue how to reassemble and decompress those packets - just bail
                        Hr = VFW_E_TYPE_NOT_ACCEPTED;
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Unknown input format data", _fx_));
                        goto MyExit;
                }


                //**cristiai:
                {   long l;
                    if ((l=pIn->GetActualDataLength()) <= (int)(dwPayloadHeaderSize + dwPreambleSize)) {
                            bSkipPacket = TRUE;
                            DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   WARNING: GetActualDataLength too small: %ld", _fx_,l));
                            goto MyExit;    //note that this is not considered an error; the packet is just ignored
                    }
                }

                if ((pRtpHdr->pt == H263_PAYLOAD_TYPE && HEADER(m_pInput->m_mt.pbFormat)->biCompression != FOURCC_R263)
                        || (pRtpHdr->pt == H261_PAYLOAD_TYPE && HEADER(m_pInput->m_mt.pbFormat)->biCompression != FOURCC_R261)
                        || !((m_dwCurrFrameSize || (g_ITUSizes[dwITUSize].biWidth == HEADER(m_pInput->m_mt.pbFormat)->biWidth
                        && g_ITUSizes[dwITUSize].biHeight == HEADER(m_pInput->m_mt.pbFormat)->biHeight))))
                {
                        // Let's reconfigure our decoder.

                        // Change the relevant parameters in the format description
                        VIDEOINFO *pvi = (VIDEOINFO *)m_pOutput->m_mt.Format();

                        pvi->bmiHeader.biWidth = g_ITUSizes[dwITUSize].biWidth;
                        pvi->bmiHeader.biHeight = g_ITUSizes[dwITUSize].biHeight;
                        pvi->bmiHeader.biSizeImage = DIBSIZE(pvi->bmiHeader);
                        m_pOutput->m_mt.SetSampleSize(pvi->bmiHeader.biSizeImage);

                        if (pvi->rcSource.top || pvi->rcSource.bottom)
                        {
                                pvi->rcSource.bottom = pvi->rcSource.top + pvi->bmiHeader.biHeight;
                        }
                        if (pvi->rcSource.left || pvi->rcSource.right)
                        {
                                pvi->rcSource.right = pvi->rcSource.left + pvi->bmiHeader.biWidth;
                        }
                        if (pvi->rcTarget.top || pvi->rcTarget.bottom)
                        {
                                pvi->rcTarget.bottom = pvi->rcTarget.top + pvi->bmiHeader.biHeight;
                        }
                        if (pvi->rcTarget.left || pvi->rcTarget.right)
                        {
                                pvi->rcTarget.right = pvi->rcTarget.left + pvi->bmiHeader.biWidth;
                        }

                        if (pvi->AvgTimePerFrame)
                                pvi->dwBitRate = (DWORD)((LONGLONG)10000000 * pvi->bmiHeader.biSizeImage / (LONGLONG)pvi->AvgTimePerFrame);

                        // What's the new format of the input packets?
                        for (DWORD dw = 0; dw < NUM_R26X_FORMATS; dw ++)
                        {
                                if (HEADER(R26XFormats[dw]->pbFormat)->biWidth == g_ITUSizes[dwITUSize].biWidth
                                        && HEADER(R26XFormats[dw]->pbFormat)->biHeight == g_ITUSizes[dwITUSize].biHeight
                                        && pRtpHdr->pt == R26XPayloadTypes[dw])
                                        break;
                        }

                        // Remember the new input format if it is a valid one
                        if (dw == NUM_R26X_FORMATS)
                        {
                                Hr = VFW_E_TYPE_NOT_ACCEPTED;
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Unknown input format", _fx_));
                                goto MyExit;
                        }
                        m_pInput->m_mt = *R26XFormats[dw];
                        m_pInput->m_dwRTPPayloadType = R26XPayloadTypes[dw];
            lpbiSrc = HEADER(m_pInput->m_mt.pbFormat);

                        // Reconfigure the H.26X decoder
                        if (m_pMediaType)
                                DeleteMediaType(m_pMediaType);

                        m_pMediaType = CreateMediaType(&m_pOutput->m_mt);

                        icDecompress.lpbiSrc = HEADER(m_pInput->m_mt.pbFormat);
                        icDecompress.lpbiDst = HEADER(m_pMediaType->pbFormat);
                        icDecompress.xSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                        icDecompress.ySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                        icDecompress.dxSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                        icDecompress.dySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                        icDecompress.xDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                        icDecompress.yDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;
                        icDecompress.dxDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                        icDecompress.dyDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;

                        // Re-init color convertors of our decoder if necessary
                        if (m_fICMStarted)
                        {
#if defined(ICM_LOGGING) && defined(DEBUG)
                                OutputDebugString("CTAPIVDec::Transform - ICM_DECOMPRESSEX_END\r\n");
#endif
                                (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX_END, 0L, 0L);
                                m_fICMStarted = FALSE;
                        }

#if defined(ICM_LOGGING) && defined(DEBUG)
                        OutputDebugString("CTAPIVDec::Transform - ICM_DECOMPRESSEX_BEGIN\r\n");
#endif
                        if ((*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX_BEGIN, (long)&icDecompress, NULL) != ICERR_OK)
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: ICDecompressBegin failed", _fx_));
                                Hr = E_FAIL;
                                goto MyExit;
                        }
                        m_fICMStarted = TRUE;

                        // Retry!
                        fFormatChanged = TRUE;

                        // We can't use the current output sample because it has a size that
                        // may be smaller than necessary (example, we just switched from 176x144
                        // to 352x288). We still want to decompress the input buffer though, so
                        // we just let the decoder do the decoding but skip the final color
                        // conversion process used to fill the output buffer.
                        dwFlags |= ICDECOMPRESS_HURRYUP;
                }

                // Decode the frame

                // Re-allocate receive buffer if too small
                if (!(      pIn->GetActualDataLength() >= (int)(dwPayloadHeaderSize + dwPreambleSize)
                        && ((m_dwCurrFrameSize + pIn->GetActualDataLength() - dwPayloadHeaderSize - dwPreambleSize) <= m_dwMaxFrameSize)
                     )
                   )
                {
                        PVOID pvReconstruct;
                        DWORD dwTest;

                        dwTest = pIn->GetActualDataLength();

                        #ifdef LOGPAYLOAD_ON
                         wsprintf(szTDebug, "Buffer start: 0x%08lX, Copying %ld-%ld-%ld=%ld bytes at 0x%08lX (before ReAlloc)\r\n", (DWORD)m_pbyReconstruct,
                                                (DWORD)pIn->GetActualDataLength(), dwPayloadHeaderSize, dwPreambleSize,
                                                (DWORD)pIn->GetActualDataLength() - dwPayloadHeaderSize - dwPreambleSize, (DWORD)m_pbyReconstruct + m_dwCurrFrameSize);
                         OutputDebugString(szTDebug);
                        #endif

                        if ((m_dwCurrFrameSize + pIn->GetActualDataLength() - dwPayloadHeaderSize - dwPreambleSize) > m_dwMaxFrameSize)
                                m_dwMaxFrameSize = m_dwMaxFrameSize + max(1024, m_dwMaxFrameSize - pIn->GetActualDataLength());

                        // Allocate reconstruction buffer - it will be realloced if too small
                        if (!(pvReconstruct = HeapReAlloc(GetProcessHeap(), 0, m_pbyReconstruct, m_dwMaxFrameSize)))
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                                Hr = E_OUTOFMEMORY;
                                goto MyExit;
                        }

                        m_pbyReconstruct = (PBYTE)pvReconstruct;

                }

                // Copy the payload
                if (dwStartBit > 0)
                {
                        // Combine the end and start bytes
                        *(m_pbyReconstruct + m_dwCurrFrameSize - 1) >>= (8 - dwStartBit);
                        *(m_pbyReconstruct + m_dwCurrFrameSize - 1) <<= (8 - dwStartBit);
                        *(pbySrc + dwPayloadHeaderSize - 1) <<= dwStartBit;
                        *(pbySrc + dwPayloadHeaderSize - 1) >>= dwStartBit;
                        *(m_pbyReconstruct + m_dwCurrFrameSize - 1) = *(m_pbyReconstruct + m_dwCurrFrameSize - 1) | *(pbySrc + dwPayloadHeaderSize - 1);
                }

#ifdef LOGPAYLOAD_ON
                wsprintf(szTDebug, "Buffer start: 0x%08lX, Copying %ld-%ld-%ld=%ld bytes at 0x%08lX\r\n", (DWORD)m_pbyReconstruct,
                                                (DWORD)pIn->GetActualDataLength(), dwPayloadHeaderSize, dwPreambleSize,
                                                (DWORD)pIn->GetActualDataLength() - dwPayloadHeaderSize - dwPreambleSize, (DWORD)m_pbyReconstruct + m_dwCurrFrameSize);
                OutputDebugString(szTDebug);
#endif
                CopyMemory(m_pbyReconstruct + m_dwCurrFrameSize, pbySrc + dwPayloadHeaderSize, pIn->GetActualDataLength() - dwPayloadHeaderSize - dwPreambleSize);


                // Update the payload size and pointer to the input video packets
                m_dwCurrFrameSize += (DWORD)(pIn->GetActualDataLength() - dwPayloadHeaderSize - dwPreambleSize);

                // Do we have a complete frame? If so, decompress it
                if (pRtpHdr->m)
                {
                        DWORD dwRefTime;
                        DWORD dwDecodeTime;
                        HEVENT hEvent = (HEVENT)(HANDLE)m_EventAdvise;

#ifdef LOGPAYLOAD_ON
                        OutputDebugString("End marker bit found - calling decompression\r\n");
#endif
                        // Measure the incoming frame rate and bitrate
                        m_dwNumFramesReceived++;
                        m_dwNumBytesReceived += m_dwCurrFrameSize;
                        dwRefTime = timeGetTime();
                        if (m_dwNumFramesReceived && ((dwRefTime - m_dwLastRefReceivedTime) > 1000))
                        {
                                ((CTAPIInputPin *)m_pInput)->m_lCurrentAvgTimePerFrame = (dwRefTime - m_dwLastRefReceivedTime) * 10000 / m_dwNumFramesReceived;
                                ((CTAPIInputPin *)m_pInput)->m_lCurrentBitrate = (DWORD)((LONGLONG)m_dwNumBytesReceived * 8000 / ((REFERENCE_TIME)(dwRefTime - m_dwLastRefReceivedTime)));
                                m_dwNumFramesReceived = 0;
                                m_dwNumBytesReceived = 0;
                                m_dwLastRefReceivedTime = dwRefTime;
                        }

                        // The freeze release bit will be an I-frame, so we don't need to keep on
                        // deocding the data. Actually, something may go wrong, so we still decode
                        // the data, just in case... We time out after 6 seconds, like the H.261
                        // and H.263 specs say we should.
                        if (m_fFreezePicture)
                        {
                                if (dwRefTime - m_dwFreezePictureStartTime > 6000)
                                {
                                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: Freeze picture timed-out (>6s)", _fx_));
                                        m_fFreezePicture = FALSE;
                                }
                                else
                                {
                                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: Received freeze picture command", _fx_));
                                        dwFlags |= ICDECOMPRESS_HURRYUP;
                                }
                        }

                        // Do we have a use for this frame?
                        if (((dwRefTime - m_dwLastRenderTime + (DWORD)(((CTAPIInputPin *)m_pInput)->m_lCurrentAvgTimePerFrame / 10000)) < (DWORD)(((CTAPIOutputPin *)m_pOutput)->m_lMaxAvgTimePerFrame / 10000)))
                                dwFlags |= ICDECOMPRESS_HURRYUP;

                        // Packetized mode - prepare for decompression (I)
                        icDecompress.dwFlags = dwFlags;
                        icDecompress.lpbiSrc = lpbiSrc;
                        lpbiSrc->biSizeImage = m_dwCurrFrameSize;
                        icDecompress.lpSrc = m_pbyReconstruct;
                        icDecompress.lpDst = pbyDst;

#ifdef LOGPAYLOAD_TOFILE
                        g_TDebugFile = CreateFile("C:\\RecvLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
                        SetFilePointer(g_TDebugFile, 0, NULL, FILE_END);
                        wsprintf(szTDebug, "Frame #%03ld\r\n", (DWORD)(pbySrc[3]));
                        WriteFile(g_TDebugFile, szTDebug, strlen(szTDebug), &d, NULL);
                        j=m_dwCurrFrameSize;
                        for (PBYTE p=m_pbyReconstruct; j>0; j-=4, p+=4)
                        {
                                wsprintf(szTDebug, "%02lX %02lX %02lX %02lX\r\n", *((BYTE *)p), *((BYTE *)p+1), *((BYTE *)p+2), *((BYTE *)p+3));
                                WriteFile(g_TDebugFile, szTDebug, strlen(szTDebug), &d, NULL);
                        }
                        CloseHandle(g_TDebugFile);
#endif

                        // Have we been asked to render to a different format?
                        if (pmtOut != NULL && pmtOut->pbFormat != NULL)
                        {
                                // Save the new format
                                if (m_pMediaType)
                                        DeleteMediaType(m_pMediaType);

                                m_pMediaType = CreateMediaType(pmtOut);

                                // Prepare for decompression (II)
                                lpbiDst = HEADER(m_pMediaType->pbFormat);
                                icDecompress.lpbiDst = lpbiDst;
                                icDecompress.lpbiDst = HEADER(m_pMediaType->pbFormat);
                                icDecompress.xSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                                icDecompress.ySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                                icDecompress.dxSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                                icDecompress.dySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                                icDecompress.xDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                                icDecompress.yDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;
                                icDecompress.dxDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                                icDecompress.dyDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;

                                // Re-init color convertors of our decoder if necessary
                                if (m_fICMStarted)
                                {
#if defined(ICM_LOGGING) && defined(DEBUG)
                                        OutputDebugString("CTAPIVDec::Transform - ICM_DECOMPRESSEX_END\r\n");
#endif
                                        (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX_END, 0L, 0L);
                                        m_fICMStarted = FALSE;
                                }

#if defined(ICM_LOGGING) && defined(DEBUG)
                                OutputDebugString("CTAPIVDec::Transform - ICM_DECOMPRESSEX_BEGIN\r\n");
#endif
                                if ((*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX_BEGIN, (long)&icDecompress, NULL) != ICERR_OK)
                                {
                                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: ICDecompressBegin failed", _fx_));
                                        Hr = E_FAIL;
                                        goto MyExit;
                                }
                                m_fICMStarted = TRUE;
                        }
                        else
                        {
                                // Prepare for decompression (II)
                                icDecompress.lpbiDst = HEADER(m_pMediaType->pbFormat);
                                icDecompress.xSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                                icDecompress.ySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                                icDecompress.dxSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                                icDecompress.dySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                                icDecompress.xDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                                icDecompress.yDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;
                                icDecompress.dxDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                                icDecompress.dyDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;
                        }

                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input Fmt:  biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, icDecompress.lpbiSrc->biCompression, icDecompress.lpbiSrc->biBitCount, icDecompress.lpbiSrc->biWidth, icDecompress.lpbiSrc->biHeight, icDecompress.lpbiSrc->biSize));
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input Rec:  xSrc = %ld, ySrc = %ld, dxSrc = %ld, dySrc = %ld", _fx_, icDecompress.xSrc, icDecompress.ySrc, icDecompress.dxSrc, icDecompress.dySrc));
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output Fmt: biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld, biSizeImage = %ld", _fx_, icDecompress.lpbiDst->biCompression, icDecompress.lpbiDst->biBitCount, icDecompress.lpbiDst->biWidth, icDecompress.lpbiDst->biHeight, icDecompress.lpbiDst->biSize, icDecompress.lpbiDst->biSizeImage));
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output Rec: xDst = %ld, yDst = %ld, dxDst = %ld, dyDst = %ld", _fx_, icDecompress.xDst, icDecompress.yDst, icDecompress.dxDst, icDecompress.dyDst));

                        // Decompress the frame
#if defined(ICM_LOGGING) && defined(DEBUG)
                        OutputDebugString("CTAPIVDec::Transform - ICM_DECOMPRESSEX\r\n");
#endif
                        lRes = (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX, (LPARAM)&icDecompress, sizeof(icDecompress));

                        if (lRes != ICERR_OK && lRes != ICERR_DONTDRAW)
                        {
                                Hr = E_FAIL;
                                m_dwCurrFrameSize = 0UL;
                                m_fDiscontinuity = TRUE;
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: ICDecompress failed", _fx_));
                                goto MyExit;
                        }

                        // Measure the outgoing frame rate and decoding time
                        dwDecodeTime = timeGetTime();
                        if (lRes != ICERR_DONTDRAW)
                        {
                                m_dwNumFramesDelivered++;
                        }
                        m_dwNumFramesDecompressed++;
                        m_dwNumMsToDecode += (DWORD)(dwDecodeTime - dwRefTime);
                        if ((dwRefTime - m_dwLastRefDeliveredTime) > 1000)
                        {
                                if (m_dwNumFramesDelivered)
                                        ((CTAPIOutputPin *)m_pOutput)->m_lCurrentAvgTimePerFrame = (dwRefTime - m_dwLastRefDeliveredTime) * 10000 / m_dwNumFramesDelivered;
#ifdef USE_CPU_CONTROL
                                if (m_dwNumFramesDecompressed)
                                        ((CTAPIOutputPin *)m_pOutput)->m_lCurrentProcessingTime = m_dwNumMsToDecode  * 10000 / m_dwNumFramesDecompressed;
                                if (((CTAPIOutputPin *)m_pOutput)->m_lCurrentAvgTimePerFrame)
                                {
                                        ((CTAPIOutputPin *)m_pOutput)->m_lCurrentCPULoad = min((LONG)((LONGLONG)((CTAPIOutputPin *)m_pOutput)->m_lCurrentProcessingTime  * 100 / ((CTAPIOutputPin *)m_pOutput)->m_lCurrentAvgTimePerFrame), 100L);
                                        ((CTAPIOutputPin *)m_pOutput)->m_lCurrentCPULoad = max(((CTAPIOutputPin *)m_pOutput)->m_lCurrentCPULoad, 0L);
                                }
#endif
                                m_dwNumFramesDelivered = 0;
                                m_dwNumFramesDecompressed = 0;
                                m_dwNumMsToDecode = 0;
                                m_dwLastRefDeliveredTime = dwRefTime;
                        }

                        // We've fully decompressed an I-frame - update our flag
                        m_fReceivedKeyframe |= fReceivedKeyframe;
                        if (!m_fReceivedKeyframe)
                        {
                                m_fDiscontinuity = TRUE;
#ifdef LOGIFRAME_ON
                                OutputDebugString("First frame isn't I frame - setting discontinuity\r\n");
#endif
                        }
#ifdef LOGIFRAME_ON
                        else if (fReceivedKeyframe)
                        {
                                OutputDebugString("Received a keyframe\r\n");
                        }
#endif

                        // Reset out RTP reassembly helpers
                        m_dwCurrFrameSize = 0UL;

                        // Check if the decompressor doesn't want this frame drawn
                        // If so, we want to decompress it into the output buffer but not
                        // deliver it. Returning S_FALSE tells the base class not to deliver
                        // this sample.
                        if (lRes == ICERR_DONTDRAW || pIn->GetActualDataLength() <= 0)
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, WARN, "%s:   WARNING: Frame not passed to video render filter", _fx_));
                                Hr = S_FALSE;
                        }
                        else
                        {
                                // Decompressed frames are always key
                                pOut->SetSyncPoint(TRUE);

                                // Update output sample size
                                pOut->SetActualDataLength(lpbiDst->biSizeImage);

                                // Sleep until it is time to deliver a frame downstream
                                // @todo Can't we achieve something similar by messing with the presentation timestamps instead?
                                if (lRes != ICERR_DONTDRAW)
                                {
                                        DWORD dwWaitTime;

                                        if ((dwDecodeTime < (m_dwLastRenderTime + (DWORD)((CTAPIOutputPin *)m_pOutput)->m_lMaxAvgTimePerFrame / 10000UL)) && (((m_dwLastRenderTime + (DWORD)((CTAPIOutputPin *)m_pOutput)->m_lMaxAvgTimePerFrame / 10000 - dwDecodeTime) < (DWORD)(((CTAPIInputPin *)m_pInput)->m_lCurrentAvgTimePerFrame / 10000))))
                                                dwWaitTime = m_dwLastRenderTime + (DWORD)((CTAPIOutputPin *)m_pOutput)->m_lMaxAvgTimePerFrame / 10000 - dwDecodeTime;
                                        else
                                                dwWaitTime = 0;
#ifdef LOGSTREAMING_ON
                                        wsprintf(szTDebug, "Waiting %d ms...\r\n", dwWaitTime);
                                        OutputDebugString(szTDebug);
#endif
                                        if ((dwWaitTime > 1) && (timeSetEvent(dwWaitTime, 1, (LPTIMECALLBACK)hEvent, NULL, TIME_ONESHOT | TIME_CALLBACK_EVENT_SET)))
                                        {
                                                m_EventAdvise.Wait();
                                                dwDecodeTime = timeGetTime();
                                        }
                                        m_dwLastRenderTime = dwDecodeTime;
                                }
                                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: Complete frame passed to video render filter", _fx_));
                        }
                }
                else
                {
#ifdef LOGPAYLOAD_ON
                        OutputDebugString("No end marker bit found - skip decompression\r\n");
#endif
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: Uncomplete frame not passed to video render filter", _fx_));
                        Hr = S_FALSE;
                        goto MyExit;
                }
        }
        else
        {
                // Non-packetized mode - prepare for decompression (I)
                icDecompress.dwFlags = dwFlags;
                icDecompress.lpbiSrc = lpbiSrc;
                icDecompress.lpSrc = pbySrc;
                icDecompress.lpDst = pbyDst;

                // Have we been asked to render to a different format?
                if (pmtOut != NULL && pmtOut->pbFormat != NULL)
                {
                        // Save the new format
                        if (m_pMediaType)
                                DeleteMediaType(m_pMediaType);

                        m_pMediaType = CreateMediaType(pmtOut);

                        // Prepare for decompression (II)
                        lpbiDst = HEADER(m_pMediaType->pbFormat);
                        icDecompress.lpbiDst = lpbiDst;
                        icDecompress.lpbiDst = HEADER(m_pMediaType->pbFormat);
                        icDecompress.xSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                        icDecompress.ySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                        icDecompress.dxSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                        icDecompress.dySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                        icDecompress.xDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                        icDecompress.yDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;
                        icDecompress.dxDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                        icDecompress.dyDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;

                        // Re-init color convertors of our decoder if necessary
                        if (m_fICMStarted)
                        {
#if defined(ICM_LOGGING) && defined(DEBUG)
                                OutputDebugString("CTAPIVDec::Transform - ICM_DECOMPRESSEX_END\r\n");
#endif
                                (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX_END, 0L, 0L);
                                m_fICMStarted = FALSE;
                        }

#if defined(ICM_LOGGING) && defined(DEBUG)
                        OutputDebugString("CTAPIVDec::Transform - ICM_DECOMPRESSEX_BEGIN\r\n");
#endif
                        if ((*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX_BEGIN, (long)&icDecompress, NULL) != ICERR_OK)
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: ICDecompressBegin failed", _fx_));
                                Hr = E_FAIL;
                                goto MyExit;
                        }
                        m_fICMStarted = TRUE;
                }
                else
                {
                        // Prepare for decompression (II)
                        icDecompress.lpbiDst = HEADER(m_pMediaType->pbFormat);
                        icDecompress.xSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                        icDecompress.ySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                        icDecompress.dxSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                        icDecompress.dySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                        icDecompress.xDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                        icDecompress.yDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;
                        icDecompress.dxDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                        icDecompress.dyDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;
                }

                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input Fmt:  biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, icDecompress.lpbiSrc->biCompression, icDecompress.lpbiSrc->biBitCount, icDecompress.lpbiSrc->biWidth, icDecompress.lpbiSrc->biHeight, icDecompress.lpbiSrc->biSize));
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input Rec:  xSrc = %ld, ySrc = %ld, dxSrc = %ld, dySrc = %ld", _fx_, icDecompress.xSrc, icDecompress.ySrc, icDecompress.dxSrc, icDecompress.dySrc));
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output Fmt: biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld, biSizeImage = %ld", _fx_, icDecompress.lpbiDst->biCompression, icDecompress.lpbiDst->biBitCount, icDecompress.lpbiDst->biWidth, icDecompress.lpbiDst->biHeight, icDecompress.lpbiDst->biSize, icDecompress.lpbiDst->biSizeImage));
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output Rec: xDst = %ld, yDst = %ld, dxDst = %ld, dyDst = %ld", _fx_, icDecompress.xDst, icDecompress.yDst, icDecompress.dxDst, icDecompress.dyDst));

                // Decompress the frame
#if defined(ICM_LOGGING) && defined(DEBUG)
                OutputDebugString("CTAPIVDec::Transform - ICM_DECOMPRESSEX\r\n");
#endif
                lRes = (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX, (LPARAM)&icDecompress, sizeof(icDecompress));

                if (lRes != ICERR_OK && lRes != ICERR_DONTDRAW)
                {
                        Hr = E_FAIL;
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: ICDecompress failed", _fx_));
                        goto MyExit;
                }

                // Decompressed frames are always key
                pOut->SetSyncPoint(TRUE);

                // Check if the decompressor doesn't want this frame drawn
                // If so, we want to decompress it into the output buffer but not
                // deliver it. Returning S_FALSE tells the base class not to deliver
                // this sample.
                if (lRes == ICERR_DONTDRAW || pIn->GetActualDataLength() <= 0)
                {
                        DBGOUT((g_dwVideoDecoderTraceID, WARN, "%s:   WARNING: Frame not passed to video render filter", _fx_));
                        Hr = S_FALSE;
                }

                // Update output sample size
                pOut->SetActualDataLength(lpbiDst->biSizeImage);
        }

MyExit:
        if (pmtOut)
                DeleteMediaType(pmtOut);
        if (pOut)
        {
            if(bSkipPacket) {
                pOut->Release();
            }
            else {
                if (fFormatChanged)
                {
#ifdef USE_DFC
                    pOut->Release();
                    pOut = 0;

                    /*  First check if the downstream pin will accept a dynamic
                    format change
                    */

                    QzCComPtr<IPinConnection> pConnection;

                    Hr = m_pOutput->m_Connected->QueryInterface(IID_IPinConnection, (void **)&pConnection);
                    if(SUCCEEDED(Hr))
                    {
                        Hr = pConnection->DynamicQueryAccept(&m_pOutput->m_mt);
                        if(S_OK == Hr)
                        {
                            Hr = m_pOutput->ChangeMediaTypeHelper(&m_pOutput->m_mt);
                        }
                    }

#else
                    Hr = E_FAIL;
#endif
                }
                else
                {
                    if (SUCCEEDED(Hr))
                    {
                            Hr = m_pOutput->Deliver(pOut);
                    }
                    else
                    {
                            // S_FALSE returned from Transform is a PRIVATE agreement
                            // We should return NOERROR from Receive() in this cause because returning S_FALSE
                            // from Receive() means that this is the end of the stream and no more data should
                            // be sent.
                            if (S_FALSE == Hr)
                            {
                                    //  Release the sample before calling notify to avoid
                                    //  deadlocks if the sample holds a lock on the system
                                    //  such as DirectDraw buffers do
                                    m_bSampleSkipped = TRUE;
                                    Hr = NOERROR;
                            }
                    }
                    pOut->Release();
                }
            }
        }
        if (m_pInput && m_pInput->m_mt.pbFormat && dwImageSize)
        {
                HEADER(m_pInput->m_mt.pbFormat)->biSizeImage = dwImageSize;
        }
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | GetPinCount | This method returns our number
 *    of pins.
 *
 *  @rdesc This method returns 2.
 ***************************************************************************/
int CTAPIVDec::GetPinCount()
{
        return 2;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | GetPin | This method returns a non-addrefed
 *    pointer to the <c cBasePin> of a pin.
 *
 *  @parm int | n | Specifies the number of the pin.
 *
 *  @rdesc This method returns NULL or a pointer to a <c CBasePin> object.
 ***************************************************************************/
CBasePin *CTAPIVDec::GetPin(IN int n)
{
        HRESULT         Hr;
        CBasePin        *pCBasePin = NULL;

        FX_ENTRY("CTAPIVDec::GetPin")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

    // Create the pins if necessary
    if (m_pInput == NULL)
        {
                if (!(m_pInput = new CTAPIInputPin(NAME("H26X Input Pin"), this, &m_csFilter, &Hr, L"H26X In")))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                        goto MyExit;
                }

#if 0
                ((CTAPIInputPin *)m_pInput)->TestH245VidC();
#endif

                if (!(m_pOutput = new CTAPIOutputPin(NAME("Video Output Pin"), this, &m_csFilter, &Hr, L"Video Out")))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                        delete m_pInput, m_pInput = NULL;
                        goto MyExit;
                }
    }

    // Return the appropriate pin
        if (n == 0)
        {
                pCBasePin = m_pInput;
        }
        else if (n == 1)
        {
                pCBasePin = m_pOutput;
        }

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: pCBasePin=0x%08lX", _fx_, pCBasePin));

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return pCBasePin;
}


#if 0
// overridden to properly mark buffers read only or not in NotifyAllocator
// !!! base class changes won't get picked up by me
//
HRESULT CDecOutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    HRESULT hr = NOERROR;
    *ppAlloc = NULL;

    // get downstream prop request
    // the derived class may modify this in DecideBufferSize, but
    // we assume that he will consistently modify it the same way,
    // so we only get it once
    ALLOCATOR_PROPERTIES prop;
    ZeroMemory(&prop, sizeof(prop));

    // whatever he returns, we assume prop is either all zeros
    // or he has filled it out.
    pPin->GetAllocatorRequirements(&prop);

    // if he doesn't care about alignment, then set it to 1
    if (prop.cbAlign == 0) {
        prop.cbAlign = 1;
    }

    /* Try the allocator provided by the input pin */

    hr = pPin->GetAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

        hr = DecideBufferSize(*ppAlloc, &prop);
        if (SUCCEEDED(hr)) {
            // temporal compression ==> read only buffers
            hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
            if (SUCCEEDED(hr)) {
                return NOERROR;
            }
        }
    }

    /* If the GetAllocator failed we may not have an interface */

    if (*ppAlloc) {
        (*ppAlloc)->Release();
        *ppAlloc = NULL;
    }

    /* Try the output pin's allocator by the same method */

    hr = InitAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

        // note - the properties passed here are in the same
        // structure as above and may have been modified by
        // the previous call to DecideBufferSize
        hr = DecideBufferSize(*ppAlloc, &prop);
        if (SUCCEEDED(hr)) {
            // temporal compression ==> read only buffers
            hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
            if (SUCCEEDED(hr)) {
                return NOERROR;
            }
        }
    }

    /* Likewise we may not have an interface to release */

    if (*ppAlloc) {
        (*ppAlloc)->Release();
        *ppAlloc = NULL;
    }
    return hr;
}
#endif

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | Pause | This method lets our filter
 *    know that we're in the process of switching to active mode.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIVDec::Pause()
{
        HRESULT                 Hr = NOERROR;
        ICDECOMPRESSEX  icDecompress;

        FX_ENTRY("CTAPIVDec::Pause")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

    CAutoLock Lock(&m_csFilter);

        if (m_State == State_Paused)
        {
        // (This space left deliberately blank)
        }

        // If we have no input pin or it isn't yet connected then when we are
        // asked to pause we deliver an end of stream to the downstream filter.
        // This makes sure that it doesn't sit there forever waiting for
        // samples which we cannot ever deliver without an input connection.

        else if (m_pInput == NULL || m_pInput->IsConnected() == FALSE)
        {
                m_State = State_Paused;
        }

        // We may have an input connection but no output connection
        // However, if we have an input pin we do have an output pin

        else if (m_pOutput->IsConnected() == FALSE)
        {
                m_State = State_Paused;
        }

        else
        {
                if (m_State == State_Stopped)
                {
                        CAutoLock Lock2(&m_csReceive);

                        ASSERT(m_pInput);
                        ASSERT(m_pOutput);
                        ASSERT(m_pInput->m_mt.pbFormat);
                        ASSERT(m_pOutput->m_mt.pbFormat);
                        ASSERT(m_pInstInfo);
                        if (!m_pInstInfo || !m_pInput || !m_pOutput || !m_pInput->m_mt.pbFormat || !m_pOutput->m_mt.pbFormat)
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid state", _fx_));
                                Hr = E_UNEXPECTED;
                                goto MyExit;
                        }

                        // Save the output format
                        if (m_pMediaType)
                                DeleteMediaType(m_pMediaType);

                        m_pMediaType = CreateMediaType(&m_pOutput->m_mt);

                        icDecompress.lpbiSrc = HEADER(m_pInput->m_mt.pbFormat);
                        icDecompress.lpbiDst = HEADER(m_pMediaType->pbFormat);
                        icDecompress.xSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                        icDecompress.ySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                        icDecompress.dxSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                        icDecompress.dySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                        icDecompress.xDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                        icDecompress.yDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;
                        icDecompress.dxDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                        icDecompress.dyDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;

                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input:  biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, icDecompress.lpbiSrc->biCompression, icDecompress.lpbiSrc->biBitCount, icDecompress.lpbiSrc->biWidth, icDecompress.lpbiSrc->biHeight, icDecompress.lpbiSrc->biSize));
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SrcRc:  left = %ld, top = %ld, right = %ld, bottom = %ld", _fx_, ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left, ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top, ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.right, ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.bottom));
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output: biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, icDecompress.lpbiDst->biCompression, icDecompress.lpbiDst->biBitCount, icDecompress.lpbiDst->biWidth, icDecompress.lpbiDst->biHeight, icDecompress.lpbiDst->biSize));
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   DstRc:  left = %ld, top = %ld, right = %ld, bottom = %ld", _fx_, ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left, ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top, ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.right, ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.bottom));

                        if (m_fICMStarted)
                        {
#if defined(ICM_LOGGING) && defined(DEBUG)
                                OutputDebugString("CTAPIVDec::Pause - ICM_DECOMPRESSEX_END\r\n");
#endif
                                (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX_END, 0L, 0L);
                                m_fICMStarted = FALSE;
                        }

#if defined(ICM_LOGGING) && defined(DEBUG)
                        OutputDebugString("CTAPIVDec::Pause - ICM_DECOMPRESSEX_BEGIN\r\n");
#endif
                        if ((*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX_BEGIN, (long)&icDecompress, NULL) != ICERR_OK)
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: ICDecompressBegin failed", _fx_));
                                Hr = E_FAIL;
                                goto MyExit;
                        }
                        m_fICMStarted = TRUE;

                        // Initialize RTP reassembly helpers if necessary
                        if (HEADER(m_pInput->m_mt.pbFormat)->biCompression == FOURCC_R263 || HEADER(m_pInput->m_mt.pbFormat)->biCompression == FOURCC_R261)
                        {
                                // Remember the maximum frame size
                                m_dwMaxFrameSize = HEADER(m_pInput->m_mt.pbFormat)->biSizeImage;

                                // Allocate reconstruction buffer - it will be realloced if too small
                                if (!(m_pbyReconstruct = (PBYTE)HeapAlloc(GetProcessHeap(), 0, m_dwMaxFrameSize)))
                                {
                                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                                        Hr = E_OUTOFMEMORY;
                                        goto MyExit;
                                }
                        }

                        // Reset out RTP reassembly helpers
                        m_dwCurrFrameSize = 0UL;
                        m_fReceivedKeyframe = FALSE;
                        m_fDiscontinuity = FALSE;
                        m_dwLastIFrameRequest = 0UL;
                        m_dwLastSeq = 0xFFFFFFFFUL;

                        // Reset statistics helpers
                        m_dwLastRefReceivedTime = timeGetTime();
                        m_dwNumFramesReceived = 0UL;
                        m_dwNumBytesReceived = 0UL;
                        m_dwLastRefDeliveredTime = m_dwLastRefReceivedTime;
                        m_dwNumFramesDelivered = 0UL;
                        m_dwNumFramesDecompressed = 0UL;
                        m_dwNumMsToDecode = 0;
                        m_EventAdvise.Reset();
                        m_dwLastRenderTime = m_dwLastRefReceivedTime;
                }

                if (SUCCEEDED(Hr))
                {
                        Hr = CBaseFilter::Pause();
                }
        }

    m_bSampleSkipped = FALSE;

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | Stop | This method lets our filter
 *    know that we're in the process of leaving active mode and entering
 *    stopped mode.
 *
 *  @rdesc This method returns NOERROR.
 ***************************************************************************/
HRESULT CTAPIVDec::Stop()
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIVDec::Stop")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        CAutoLock Lock(&m_csFilter);

        if (m_State == State_Stopped)
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
                return Hr;
        }

    // Succeed the Stop if we are not completely connected
    ASSERT(m_pInput == NULL || m_pOutput != NULL);

    if (m_pInput == NULL || m_pInput->IsConnected() == FALSE || m_pOutput->IsConnected() == FALSE)
        {
                m_State = State_Stopped;
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
                return Hr;
    }

    ASSERT(m_pInput);
    ASSERT(m_pOutput);

    // Decommit the input pin before locking or we can deadlock
    m_pInput->Inactive();

    // Synchronize with Receive calls
    CAutoLock Lock2(&m_csReceive);
    m_pOutput->Inactive();

        // Terminate H.26X compression
        ASSERT(m_pInstInfo);
        if (m_pInstInfo)
        {
#if defined(ICM_LOGGING) && defined(DEBUG)
                OutputDebugString("CTAPIVDec::Pause - ICM_DECOMPRESSEX_END\r\n");
#endif
                (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX_END, 0L, 0L);
        }

        if (m_pbyReconstruct)
                HeapFree(GetProcessHeap(), 0, m_pbyReconstruct), m_pbyReconstruct = NULL;

        m_State = State_Stopped;

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | GetState | This method retrieves the current
 *    state of the filter. We override GetState to report that we don't send
 *    any data when paused, so renderers won't starve expecting that
 *
 *  @parm DWORD | dwMSecs | Specifies the duration of the time-out, in
 *    milliseconds.
 *
 *  @parm FILTER_STATE* | State | Specifies the state of the filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag VFW_S_CANT_CUE | Lack of data
 *  @flag S_OK | No error
 ***************************************************************************/
HRESULT CTAPIVDec::GetState(DWORD dwMSecs, FILTER_STATE *pState)
{
        HRESULT Hr = S_OK;

        FX_ENTRY("CTAPIVDec::GetState")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pState);
        if (!pState)
        {
                Hr = E_POINTER;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                goto MyExit;
        }

        *pState = m_State;
        if (m_State == State_Paused)
        {
                Hr = VFW_S_CANT_CUE;
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

#if 0
/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | JoinFilterGraph | This method is used to
 *    inform a filter that it has joined a filter graph.
 *
 *  @parm IFilterGraph | pGraph | Specifies a pointer to the filter graph to
 *    join.
 *
 *  @parm LPCWSTR | pName | Specifies the name of the filter being added.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 *
 *  @comm We don't validate input parameters as both pointers can be
 *    NULL when we leave the graph.
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::JoinFilterGraph(IN IFilterGraph *pGraph, IN LPCWSTR pName)
{
        HRESULT Hr = NOERROR;
        DWORD dwNumDevices = 0UL;
        IGraphConfig *pgc = NULL;

        FX_ENTRY("CTAPIVDec::JoinFilterGraph")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        CAutoLock Lock(&m_csFilter);

        // Verify with the base class
        if (FAILED(Hr = CBaseFilter::JoinFilterGraph(pGraph, pName)))
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: CBaseFilter::JoinFilterGraph failed", _fx_));
                goto MyExit;
        }

        if (pGraph)
        {
                // Create the pins if necessary
                if (m_pInput == NULL)
                {
                        if (!(m_pInput = new CTAPIInputPin(NAME("H26X Input Pin"), this, &m_csFilter, &Hr, L"H26X In")))
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                                goto MyExit;
                        }

#if 0
                        ((CTAPIInputPin *)m_pInput)->TestH245VidC();
#endif

                        if (!(m_pOutput = new CTAPIOutputPin(NAME("Video Output Pin"), this, &m_csFilter, &Hr, L"Video Out")))
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                                delete m_pInput, m_pInput = NULL;
                                goto MyExit;
                        }
                }

                // Get an IGraphConfig interface pointer for our output pin
                if (S_OK == pGraph->QueryInterface(IID_IGraphConfig, (void **)&pgc))
                {
                        m_pOutput->SetConfigInfo(pgc, m_evStop);
                        pgc->Release();
                }
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivdec\tapivdec.h ===
/****************************************************************************
 *  @doc INTERNAL TAPIVDEC
 *
 *  @module TAPIVDec.h | Header file for the <c CTAPIVDec>
 *    class used to implement the TAPI H.26X Video Decoder filter.
 ***************************************************************************/

/****************************************************************************
                                                                Table Of Contents
****************************************************************************/
/****************************************************************************
@doc INTERNAL

@contents1 Contents | To display a list of topics by category, click any
of the contents entries below. To display an alphabetical list of
topics, choose the Index button.

@head2 Introduction |
This DLL implements the TAPI MSP H.26X Video Decoder filter. This filter
differs from traditional Microsoft Windows desktop video codecs:

It operates over unreliable communication channels using RTP/UDP/IP (H.323)
It has many modes of operation (H.263 options)
It needs to handle or generate call control specific (H.245) commands
It implements different decoding algorithms in order to adapt its CPU usage

Like other desktop video decoders, it needs to operate in real-time.

The TAPI incoming video stack relies on this video decoder to expose a
RTP-packetized compressed video pin, and uncompressed video output pin using
the DirectShow model. This video decoder presents its input pins to the network
source filter and is able to reassemble and decompress raw RTP packets, to
deliver uncompressed video frames to the downstream render filter.

Its uncompressed video output pin implements a new H.245 command interface to
receive H.245 picture freeze requests. We also define an H.245 command outgoing
interface to allow the video input pin of this video decoder to issue H.245
commands such as requests for I-frame, group of blocks, or macro-block updates
due to packet loss.

It used extended bitmap info headers for H.261 and H.263 video streams to
retrieve from the compressed video input pin a list of optional mode of
decompression supported by the decoder.

It also exposes interfaces to allow users to control video quality settings
such as brightness, contrast, hue, saturation, gamma and sharpness, by applying
the necessary post-processing operators. It also exposes an interface to
simulate local camera control functionality such as pan, tilt and zoom.

Finally, it implements a new H.245 capability interface. This interface provides
the TAPI TSP/MSP call control components with information needed to resolve
capabilities.

@head2 Implementation |

The TAPI H.26X Video Decoder filter currently loads TAPIH263.DLL or TAPIH261.DLL
dynamically and calls a unique entry point (DriverProc) exposed by those
DLLs to decompress the incoming video data. The video decoder filter is
responsible for re-assembling the incoming RTP packets and watch dynamic format
changes in the content of those packets. If the incoming RTP packets use a
different encoding format (different encoding - H.261 vs H.263, different image
size - SQCIF vs QCIF vs CIF) it dynamically recongures the TAPIH26X DLL and
changes the format of the output media sample to let the downstream filter
know about the format change.

@head2 Video decoder filter application interfaces |
Although the following interfaces are not exposed directly to applications, interfaces
exposed to applications simply delegate to those interfaces.

@head3 IAMVideoProcAmp application interface|
@subindex IAMVideoProcAmp methods
@subindex IAMVideoProcAmp structures and enums

@head3 ICameraControl application interface|
@subindex ICameraControl methods
@subindex ICameraControl structures and enums

@head2 Video decoder filter MSP interfaces |

@head3 IH245Capability application interface|
@subindex IH245Capability methods
@subindex IH245Capability structures and enums

@head2 Video decoder filter output pin TAPI interfaces |

@head3 ICPUControl interface|
@subindex ICPUControl methods

@head3 IFrameRateControl interface (output pin)|
@subindex IFrameRateControl methods (output pin)
@subindex IFrameRateControl structures and enums (output pin)

@head3 IH245DecoderCommand interface|
@subindex IH245DecoderCommand methods

@head2 Video decoder filter input pin TAPI interfaces |

@head3 IFrameRateControl interface (input pin)|
@subindex IFrameRateControl methods (input pin)
@subindex IFrameRateControl structures and enums (input pin)

@head3 IBitrateControl interface|
@subindex IBitrateControl methods
@subindex IBitrateControl structures and enums

@head2 Classes |
@subindex Classes

@head2 Modules |
@subindex Modules
@subindex Constants

@head2 Code information |

The only libraries necessary in retail mode (w/o property pages) are ..\..\..\..\dev\tools\amovsdk.20\lib\strmbase.lib ..\..\..\ddk\lib\i386\ksuser.lib ..\..\..\ddk\lib\i386\ksguid.lib kernel32.lib ole32.lib uuid.lib msvcrt.lib

@head3 Exports |
DllCanUnloadNow
DllGetClassObject
DllRegisterServer
DllUnregisterServer

@head3 Imports |
MSVCRT.DLL:
??2@YAPAXI@Z
??3@YAXPAX@Z
_EH_prolog
__CxxFrameHandler
_purecall
memcmp

WINMM.DLL:
timeGetTime

KERNEL32.DLL:
DeleteCriticalSection
DisableThreadLibraryCalls
EnterCriticalSection
FreeLibrary
GetLastError
GetModuleFileNameA
GetVersionExA
InitializeCriticalSection
InterlockedDecrement
InterlockedIncrement
LeaveCriticalSection
MulDiv
MultiByteToWideChar
lstrlenA

MSVFW32.DLL:
ICClose
ICDecompress
ICLocate
ICSendMessage

USER32.DLL:
GetDC
ReleaseDC
wsprintfA

GDI32.DLL:
GetDeviceCaps

ADVAPI32.DLL:
RegCloseKey
RegCreateKeyA
RegDeleteKeyA
RegEnumKeyExA
RegOpenKeyExA
RegSetValueA
RegSetValueExA

OLE32.DLL:
CoCreateInstance
CoFreeUnusedLibraries
CoInitialize
CoTaskMemAlloc
CoTaskMemFree
CoUninitialize
StringFromGUID2

@head3 Code size |
Compile options: /nologo /MDd /W3 /GX /O1 /X /I "..\..\inc" /I "..\..\..\ddk\inc" /I "..\..\..\..\dev\tools\amovsdk.20\include" /I "..\..\..\..\dev\tools\amovsdk.20\classes\base" /I "..\..\..\..\dev\ntddk\inc" /I "..\..\..\..\dev\inc" /I "..\..\..\..\dev\tools\c32\inc" /D "NDEBUG" /D "WIN32" /D "_WINDOWS" /D "DLL" /D "STRICT" /FR"Release/" /Fp"Release/TAPIKsIf.pch" /YX /Fo"Release/" /Fd"Release/" /FD /c

Link options: ..\..\..\..\dev\tools\amovsdk.20\lib\strmbase.lib ..\..\..\ddk\lib\i386\ksuser.lib ..\..\..\ddk\lib\i386\ksguid.lib comctl32.lib msvcrt.lib winmm.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /base:"0x1e180000" /entry:"DllEntryPoint" /dll /incremental:no /pdb:"Release/TAPIKsIf.pdb" /map:"Release/TAPIKsIf.map" /machine:I386 /nodefaultlib /def:".\TAPIKsIf.def" /out:"Release/TAPIKsIf.ax" /implib:"Release/TAPIKsIf.lib"

Resulting size: 52KB


***********************************************************************
@contents2 IAMVideoProcAmp methods |
@index mfunc | CPROCAMPMETHOD

***********************************************************************
@contents2 IAMVideoProcAmp structures and enums |
@index struct,enum | CPROCAMPSTRUCTENUM

***********************************************************************
@contents2 ICameraControl methods |
@index mfunc | CCAMERACMETHOD

***********************************************************************
@contents2 ICameraControl structures and enums |
@index struct,enum | CCAMERACSTRUCTENUM

***********************************************************************
@contents2 IH245Capability methods |
@index mfunc | CH245VIDCMETHOD

***********************************************************************
@contents2 IH245Capability structures and enums |
@index struct,enum | H245VIDCSTRUCTENUM

***********************************************************************
@contents2 ICPUControl methods |
@index mfunc | CCPUCMETHOD

***********************************************************************
@contents2 IFrameRateControl methods (output pin) |
@index mfunc | CFPSOUTCMETHOD

***********************************************************************
@contents2 IFrameRateControl structures and enums (output pin) |
@index struct,enum | CFPSCSTRUCTENUM

***********************************************************************
@contents2 IH245DecoderCommand methods |
@index mfunc | CH245COMMMETHOD

***********************************************************************
@contents2 IFrameRateControl methods (input pin) |
@index mfunc | CFPSINCMETHOD

***********************************************************************
@contents2 IFrameRateControl structures and enums (input pin) |
@index struct,enum | CFPSCSTRUCTENUM

***********************************************************************
@contents2 IBitrateControl methods |
@index mfunc | CBPSCMETHOD

***********************************************************************
@contents2 IBitrateControl structures and enums |
@index struct,enum | CBPSCSTRUCTENUM

***********************************************************************
@contents2 Modules |
@index module |

***********************************************************************
@contents2 Classes |
@index class |
@index mdata, mfunc | CTAPIVDECCLASS,CTAPIVDECMETHOD
@index mdata, mfunc | COUTPINCLASS,COUTPINMETHOD,CCPUCMETHOD,CFPSOUTCMETHOD
@index mdata, mfunc | CINPINCLASS,CINPINMETHOD,CFPSINCMETHOD,CBITRATECMETHOD
@index mdata, mfunc | CH245COMMMETHOD,CH245VIDCMETHOD
@index mdata, mfunc | CCAMERACPCLASS,CCAMERACMETHOD,CCAMERACPMETHOD
@index mdata, mfunc | CPROCAMPPCLASS,CPROCAMPMETHOD,CPROCAMPPMETHOD
@index mdata, mfunc | CPROPEDITCLASS,CPROPEDITMETHO

***********************************************************************
@contents2 Constants |
@index const |
****************************************************************************/

#ifndef _TAPIVDEC_H_
#define _TAPIVDEC_H_

#ifdef DBG
extern DWORD g_dwVideoDecoderTraceID;

#ifndef FX_ENTRY
#define FX_ENTRY(s) static char _this_fx_ [] = s;
#define _fx_ ((LPSTR) _this_fx_)
#endif
#else
#ifndef FX_ENTRY
#define FX_ENTRY(s)
#endif
#define _fx_
#endif

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECCLASS
 *
 *  @class CTAPIVDec | This class implements the TAPI H.26X Video Decoder
 *    filter.
 *
 *  @mdata HIC | CTAPIVDec | m_hic | ICM handle to the decoder
 *
 *  @mdata FOURCC | CTAPIVDec | m_FourCCIn | FourCC used to get a handle
 *    to the decoder.
 *
 *  @mdata BOOL | CTAPIVDec | m_fStreaming | Streaming state.
 *
 *  @mdata DWORD | CTAPIVDec | m_pIH245EncoderCommand | Pointer to the
 *    outgoing <i IH245EncoderCommand> interface exposed by the channel
 *    controller to send H.245 commands to the remote encoder.
 *
 *  @mdata DWORD | CTAPIVDec | m_dwNumFramesReceived | Counts number of
 *    frames received, reset every second or so.
 *
 *  @mdata DWORD | CTAPIVDec | m_dwNumBytesReceived | Counts number of
 *    bytes received, reset every second or so.
 *
 *  @mdata DWORD | CTAPIVDec | m_dwNumFramesDelivered | Counts number of
 *    frames delivered, reset every second or so.
 *
 *  @mdata DWORD | CTAPIVDec | m_dwNumFramesDecompressed | Counts number of
 *    frames decompressed, reset every second or so.
 ***************************************************************************/
class CTAPIVDec : public CBaseFilter
,public IRTPPayloadHeaderMode
#ifdef USE_PROPERTY_PAGES
,public ISpecifyPropertyPages
#endif
#ifdef USE_CAMERA_CONTROL
,public ICameraControl
#endif
#ifdef USE_VIDEO_PROCAMP
,public IVideoProcAmp
#endif
{
        public:
        DECLARE_IUNKNOWN

        CTAPIVDec(IN LPUNKNOWN pUnkOuter, IN TCHAR *pName, OUT HRESULT *pHr);
        ~CTAPIVDec();
        STDMETHODIMP NonDelegatingQueryInterface(IN REFIID riid, OUT PVOID *ppv);

        // Pin enumeration functions.
        CBasePin* GetPin(IN int n);
        int GetPinCount();

        // Overrides CBaseFilter methods.
        STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);
#if 0
        STDMETHODIMP JoinFilterGraph(IN IFilterGraph *pGraph, IN LPCWSTR pName);
#endif

    // Override state changes to allow derived transform filter to control streaming start/stop
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();

        // Implement IRTPPayloadHeaderMode
        STDMETHODIMP SetMode(IN RTPPayloadHeaderMode rtpphmMode);

#ifdef USE_PROPERTY_PAGES
        // ISpecifyPropertyPages methods
        STDMETHODIMP GetPages(OUT CAUUID *pPages);
#endif

#ifdef USE_VIDEO_PROCAMP
        // Implement IAMVideoProcAmp
        STDMETHODIMP Set(IN VideoProcAmpProperty Property, IN long lValue, IN TAPIControlFlags Flags);
        STDMETHODIMP Get(IN VideoProcAmpProperty Property, OUT long *lValue, OUT TAPIControlFlags *Flags);
        STDMETHODIMP GetRange(IN VideoProcAmpProperty Property, OUT long *pMin, OUT long *pMax, OUT long *pSteppingDelta, OUT long *pDefault, OUT TAPIControlFlags *pCapsFlags);
#endif

#ifdef USE_CAMERA_CONTROL
        // Implement ICameraControl
        STDMETHODIMP Set(IN TAPICameraControlProperty Property, IN long lValue, IN TAPIControlFlags Flags);
        STDMETHODIMP Get(IN TAPICameraControlProperty Property, OUT long *lValue, OUT TAPIControlFlags *Flags);
        STDMETHODIMP GetRange(IN TAPICameraControlProperty Property, OUT long *pMin, OUT long *pMax, OUT long *pSteppingDelta, OUT long *pDefault, OUT TAPIControlFlags *pCapsFlags);
#endif

        private:

        friend class CTAPIInputPin;
        friend class CTAPIOutputPin;

    // These hold our input and output pins
    CTAPIInputPin *m_pInput;
    CTAPIOutputPin *m_pOutput;

        // This method does all the work
        HRESULT Transform(IN IMediaSample *pIn, IN LONG lPrefixSize);

        // Standard setup for output sample
        HRESULT InitializeOutputSample(IMediaSample *pSample, IMediaSample **ppOutSample);

    // Critical section protecting filter state.
    CCritSec m_csFilter;

    // Critical section stopping state changes (ie Stop) while we're
    // processing a sample.
    //
    // This critical section is held when processing
    // events that occur on the receive thread - Receive() and EndOfStream().
    //
    // If you want to hold both m_csReceive and m_csFilter then grab
    // m_csFilter FIRST - like CTransformFilter::Stop() does.
    CCritSec m_csReceive;

#ifdef USE_DFC
        CAMEvent m_evStop;
#endif

        // Did we just skip a frame?
        BOOL m_bSampleSkipped;

        // @todo Use different exports for all the driver proc calls you make!
        LPFNDRIVERPROC  m_pDriverProc;  // DriverProc() function pointer
#if DXMRTP <= 0
        HINSTANCE               m_hTAPIH26XDLL; // DLL Handle to TAPIH263.dll or TAPIH261.dll
#endif
        LPINST                  m_pInstInfo;
        FOURCC                  m_FourCCIn;
        BOOL                    m_fICMStarted;

        // Current output format - content may change when going back and forth
        // between GDI and DDraw
        AM_MEDIA_TYPE   *m_pMediaType;

        // RTP packet reassembly helpers
        BOOL  m_fReceivedKeyframe;
        DWORD m_dwMaxFrameSize;
        DWORD m_dwCurrFrameSize;
        PBYTE m_pbyReconstruct;
        BOOL  m_fDiscontinuity;
        DWORD m_dwLastIFrameRequest;
        DWORD m_dwLastSeq;

#ifdef USE_CAMERA_CONTROL
        LONG m_lCCPan;
        LONG m_lCCTilt;
        LONG m_lCCZoom;
        BOOL m_fFlipVertical;
        BOOL m_fFlipHorizontal;
#endif

#ifdef USE_VIDEO_PROCAMP
        LONG m_lVPABrightness;
        LONG m_lVPAContrast;
        LONG m_lVPASaturation;
#endif

        // H.245 Video Decoder command
        BOOL  m_fFreezePicture;
        DWORD m_dwFreezePictureStartTime;

        // Video channel control interface
        IH245EncoderCommand *m_pIH245EncoderCommand;

        // Called to send an I-frame request
        STDMETHODIMP videoFastUpdatePicture();

        // Frame rate, bitrate, and CPU control helpers
        DWORD           m_dwNumFramesReceived;
        DWORD           m_dwNumBytesReceived;
        DWORD           m_dwNumFramesDelivered;
        DWORD           m_dwNumFramesDecompressed;
        DWORD           m_dwNumMsToDecode;
        DWORD           m_dwLastRefDeliveredTime;
        DWORD           m_dwLastRefReceivedTime;
        CAMEvent        m_EventAdvise;
        DWORD           m_dwLastRenderTime;

        //for the RTP Payload Header Mode (0=draft, 1=RFC2190)
        RTPPayloadHeaderMode m_RTPPayloadHeaderMode;
};

#endif // _TAPIVDEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\asn\h4503pp.c ===
#include <windows.h>
#include "h4503pp.h"

#pragma warning ( disable: 4133 )

ASN1module_t H4503PP_Module = NULL;

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_routing(ASN1encoding_t enc, TransportAddress_ipSourceRoute_routing *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route *val);
static int ASN1CALL ASN1Enc_TransportAddress_ip6Address(ASN1encoding_t enc, TransportAddress_ip6Address *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipxAddress(ASN1encoding_t enc, TransportAddress_ipxAddress *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute(ASN1encoding_t enc, TransportAddress_ipSourceRoute *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipAddress(ASN1encoding_t enc, TransportAddress_ipAddress *val);
static int ASN1CALL ASN1Enc_Reject_problem(ASN1encoding_t enc, Reject_problem *val);
static int ASN1CALL ASN1Enc_EntityType(ASN1encoding_t enc, EntityType *val);
static int ASN1CALL ASN1Enc_InterpretationApdu(ASN1encoding_t enc, InterpretationApdu *val);
static int ASN1CALL ASN1Enc_ServiceApdus(ASN1encoding_t enc, ServiceApdus *val);
static int ASN1CALL ASN1Enc_Reject(ASN1encoding_t enc, Reject *val);
static int ASN1CALL ASN1Enc_EXTENSION(ASN1encoding_t enc, EXTENSION *val);
static int ASN1CALL ASN1Enc_GroupIndicationOnRes(ASN1encoding_t enc, GroupIndicationOnRes *val);
static int ASN1CALL ASN1Enc_GroupIndicationOffRes(ASN1encoding_t enc, GroupIndicationOffRes *val);
static int ASN1CALL ASN1Enc_PickupRes(ASN1encoding_t enc, PickupRes *val);
static int ASN1CALL ASN1Enc_PickExeRes(ASN1encoding_t enc, PickExeRes *val);
static int ASN1CALL ASN1Enc_UserSpecifiedSubaddress(ASN1encoding_t enc, UserSpecifiedSubaddress *val);
static int ASN1CALL ASN1Enc_CODE(ASN1encoding_t enc, CODE *val);
static int ASN1CALL ASN1Enc_H221NonStandard(ASN1encoding_t enc, H221NonStandard *val);
static int ASN1CALL ASN1Enc_H225NonStandardIdentifier(ASN1encoding_t enc, H225NonStandardIdentifier *val);
static int ASN1CALL ASN1Enc_PublicTypeOfNumber(ASN1encoding_t enc, PublicTypeOfNumber *val);
static int ASN1CALL ASN1Enc_PrivateTypeOfNumber(ASN1encoding_t enc, PrivateTypeOfNumber *val);
static int ASN1CALL ASN1Enc_CallIdentifier(ASN1encoding_t enc, CallIdentifier *val);
static int ASN1CALL ASN1Enc_ReturnResult_result(ASN1encoding_t enc, ReturnResult_result *val);
static int ASN1CALL ASN1Enc_Invoke(ASN1encoding_t enc, Invoke *val);
static int ASN1CALL ASN1Enc_ReturnResult(ASN1encoding_t enc, ReturnResult *val);
static int ASN1CALL ASN1Enc_ReturnError(ASN1encoding_t enc, ReturnError *val);
static int ASN1CALL ASN1Enc_ExtensionSeq(ASN1encoding_t enc, PExtensionSeq *val);
static int ASN1CALL ASN1Enc_PickrequRes(ASN1encoding_t enc, PickrequRes *val);
static int ASN1CALL ASN1Enc_PartySubaddress(ASN1encoding_t enc, PartySubaddress *val);
static int ASN1CALL ASN1Enc_H225NonStandardParameter(ASN1encoding_t enc, H225NonStandardParameter *val);
static int ASN1CALL ASN1Enc_PublicPartyNumber(ASN1encoding_t enc, PublicPartyNumber *val);
static int ASN1CALL ASN1Enc_PrivatePartyNumber(ASN1encoding_t enc, PrivatePartyNumber *val);
static int ASN1CALL ASN1Enc_TransportAddress(ASN1encoding_t enc, TransportAddress *val);
static int ASN1CALL ASN1Enc_CTActiveArg_argumentExtension(ASN1encoding_t enc, CTActiveArg_argumentExtension *val);
static int ASN1CALL ASN1Enc_CTCompleteArg_argumentExtension(ASN1encoding_t enc, CTCompleteArg_argumentExtension *val);
static int ASN1CALL ASN1Enc_SubaddressTransferArg_argumentExtension(ASN1encoding_t enc, SubaddressTransferArg_argumentExtension *val);
static int ASN1CALL ASN1Enc_CTUpdateArg_argumentExtension(ASN1encoding_t enc, CTUpdateArg_argumentExtension *val);
static int ASN1CALL ASN1Enc_CTIdentifyRes_resultExtension(ASN1encoding_t enc, CTIdentifyRes_resultExtension *val);
static int ASN1CALL ASN1Enc_CTSetupArg_argumentExtension(ASN1encoding_t enc, CTSetupArg_argumentExtension *val);
static int ASN1CALL ASN1Enc_CTInitiateArg_argumentExtension(ASN1encoding_t enc, CTInitiateArg_argumentExtension *val);
static int ASN1CALL ASN1Enc_IntResult_extension(ASN1encoding_t enc, IntResult_extension *val);
static int ASN1CALL ASN1Enc_DivertingLegInformation4Argument_extension(ASN1encoding_t enc, DivertingLegInformation4Argument_extension *val);
static int ASN1CALL ASN1Enc_DivertingLegInformation3Argument_extension(ASN1encoding_t enc, DivertingLegInformation3Argument_extension *val);
static int ASN1CALL ASN1Enc_DivertingLegInformation2Argument_extension(ASN1encoding_t enc, DivertingLegInformation2Argument_extension *val);
static int ASN1CALL ASN1Enc_DivertingLegInformation1Argument_extension(ASN1encoding_t enc, DivertingLegInformation1Argument_extension *val);
static int ASN1CALL ASN1Enc_CallReroutingArgument_extension(ASN1encoding_t enc, CallReroutingArgument_extension *val);
static int ASN1CALL ASN1Enc_CheckRestrictionArgument_extension(ASN1encoding_t enc, CheckRestrictionArgument_extension *val);
static int ASN1CALL ASN1Enc_InterrogateDiversionQArgument_extension(ASN1encoding_t enc, InterrogateDiversionQArgument_extension *val);
static int ASN1CALL ASN1Enc_DeactivateDiversionQArgument_extension(ASN1encoding_t enc, DeactivateDiversionQArgument_extension *val);
static int ASN1CALL ASN1Enc_ActivateDiversionQArgument_extension(ASN1encoding_t enc, ActivateDiversionQArgument_extension *val);
static int ASN1CALL ASN1Enc_H4503ROS(ASN1encoding_t enc, H4503ROS *val);
static int ASN1CALL ASN1Enc_DummyArg(ASN1encoding_t enc, DummyArg *val);
static int ASN1CALL ASN1Enc_DummyRes(ASN1encoding_t enc, DummyRes *val);
static int ASN1CALL ASN1Enc_SubaddressTransferArg(ASN1encoding_t enc, SubaddressTransferArg *val);
static int ASN1CALL ASN1Enc_MixedExtension(ASN1encoding_t enc, MixedExtension *val);
static int ASN1CALL ASN1Enc_PartyNumber(ASN1encoding_t enc, PartyNumber *val);
static int ASN1CALL ASN1Enc_CpickupNotifyArg_extensionArg(ASN1encoding_t enc, PCpickupNotifyArg_extensionArg *val);
static int ASN1CALL ASN1Enc_CpNotifyArg_extensionArg(ASN1encoding_t enc, PCpNotifyArg_extensionArg *val);
static int ASN1CALL ASN1Enc_PickExeRes_extensionRes(ASN1encoding_t enc, PPickExeRes_extensionRes *val);
static int ASN1CALL ASN1Enc_PickExeArg_extensionArg(ASN1encoding_t enc, PPickExeArg_extensionArg *val);
static int ASN1CALL ASN1Enc_PickupRes_extensionRes(ASN1encoding_t enc, PPickupRes_extensionRes *val);
static int ASN1CALL ASN1Enc_PickupArg_extensionArg(ASN1encoding_t enc, PPickupArg_extensionArg *val);
static int ASN1CALL ASN1Enc_PickrequRes_extensionRes(ASN1encoding_t enc, PPickrequRes_extensionRes *val);
static int ASN1CALL ASN1Enc_PickrequArg_extensionArg(ASN1encoding_t enc, PPickrequArg_extensionArg *val);
static int ASN1CALL ASN1Enc_GroupIndicationOffRes_extensionRes(ASN1encoding_t enc, PGroupIndicationOffRes_extensionRes *val);
static int ASN1CALL ASN1Enc_GroupIndicationOffArg_extensionArg(ASN1encoding_t enc, PGroupIndicationOffArg_extensionArg *val);
static int ASN1CALL ASN1Enc_GroupIndicationOnRes_extensionRes(ASN1encoding_t enc, PGroupIndicationOnRes_extensionRes *val);
static int ASN1CALL ASN1Enc_GroupIndicationOnArg_extensionArg(ASN1encoding_t enc, PGroupIndicationOnArg_extensionArg *val);
static int ASN1CALL ASN1Enc_CpSetupRes_extensionRes(ASN1encoding_t enc, PCpSetupRes_extensionRes *val);
static int ASN1CALL ASN1Enc_CpSetupArg_extensionArg(ASN1encoding_t enc, PCpSetupArg_extensionArg *val);
static int ASN1CALL ASN1Enc_CpRequestRes_extensionRes(ASN1encoding_t enc, PCpRequestRes_extensionRes *val);
static int ASN1CALL ASN1Enc_CpRequestArg_extensionArg(ASN1encoding_t enc, PCpRequestArg_extensionArg *val);
static int ASN1CALL ASN1Enc_ServiceApdus_rosApdus(ASN1encoding_t enc, PServiceApdus_rosApdus *val);
static int ASN1CALL ASN1Enc_AliasAddress(ASN1encoding_t enc, AliasAddress *val);
static int ASN1CALL ASN1Enc_EndpointAddress_destinationAddress(ASN1encoding_t enc, PEndpointAddress_destinationAddress *val);
static int ASN1CALL ASN1Enc_AddressInformation(ASN1encoding_t enc, AddressInformation *val);
static int ASN1CALL ASN1Enc_EndpointAddress(ASN1encoding_t enc, EndpointAddress *val);
static int ASN1CALL ASN1Enc_NetworkFacilityExtension(ASN1encoding_t enc, NetworkFacilityExtension *val);
static int ASN1CALL ASN1Enc_ActivateDiversionQArgument(ASN1encoding_t enc, ActivateDiversionQArgument *val);
static int ASN1CALL ASN1Enc_DeactivateDiversionQArgument(ASN1encoding_t enc, DeactivateDiversionQArgument *val);
static int ASN1CALL ASN1Enc_InterrogateDiversionQArgument(ASN1encoding_t enc, InterrogateDiversionQArgument *val);
static int ASN1CALL ASN1Enc_CheckRestrictionArgument(ASN1encoding_t enc, CheckRestrictionArgument *val);
static int ASN1CALL ASN1Enc_CallReroutingArgument(ASN1encoding_t enc, CallReroutingArgument *val);
static int ASN1CALL ASN1Enc_DivertingLegInformation1Argument(ASN1encoding_t enc, DivertingLegInformation1Argument *val);
static int ASN1CALL ASN1Enc_DivertingLegInformation2Argument(ASN1encoding_t enc, DivertingLegInformation2Argument *val);
static int ASN1CALL ASN1Enc_DivertingLegInformation3Argument(ASN1encoding_t enc, DivertingLegInformation3Argument *val);
static int ASN1CALL ASN1Enc_DivertingLegInformation4Argument(ASN1encoding_t enc, DivertingLegInformation4Argument *val);
static int ASN1CALL ASN1Enc_IntResult(ASN1encoding_t enc, IntResult *val);
static int ASN1CALL ASN1Enc_CTInitiateArg(ASN1encoding_t enc, CTInitiateArg *val);
static int ASN1CALL ASN1Enc_CTSetupArg(ASN1encoding_t enc, CTSetupArg *val);
static int ASN1CALL ASN1Enc_CTIdentifyRes(ASN1encoding_t enc, CTIdentifyRes *val);
static int ASN1CALL ASN1Enc_CTUpdateArg(ASN1encoding_t enc, CTUpdateArg *val);
static int ASN1CALL ASN1Enc_CTCompleteArg(ASN1encoding_t enc, CTCompleteArg *val);
static int ASN1CALL ASN1Enc_CTActiveArg(ASN1encoding_t enc, CTActiveArg *val);
static int ASN1CALL ASN1Enc_CpRequestArg(ASN1encoding_t enc, CpRequestArg *val);
static int ASN1CALL ASN1Enc_CpRequestRes(ASN1encoding_t enc, CpRequestRes *val);
static int ASN1CALL ASN1Enc_CpSetupArg(ASN1encoding_t enc, CpSetupArg *val);
static int ASN1CALL ASN1Enc_CpSetupRes(ASN1encoding_t enc, CpSetupRes *val);
static int ASN1CALL ASN1Enc_GroupIndicationOnArg(ASN1encoding_t enc, GroupIndicationOnArg *val);
static int ASN1CALL ASN1Enc_GroupIndicationOffArg(ASN1encoding_t enc, GroupIndicationOffArg *val);
static int ASN1CALL ASN1Enc_PickrequArg(ASN1encoding_t enc, PickrequArg *val);
static int ASN1CALL ASN1Enc_PickupArg(ASN1encoding_t enc, PickupArg *val);
static int ASN1CALL ASN1Enc_PickExeArg(ASN1encoding_t enc, PickExeArg *val);
static int ASN1CALL ASN1Enc_CpNotifyArg(ASN1encoding_t enc, CpNotifyArg *val);
static int ASN1CALL ASN1Enc_CpickupNotifyArg(ASN1encoding_t enc, CpickupNotifyArg *val);
static int ASN1CALL ASN1Enc_H4501SupplementaryService(ASN1encoding_t enc, H4501SupplementaryService *val);
static int ASN1CALL ASN1Enc_IntResultList(ASN1encoding_t enc, IntResultList *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_routing(ASN1decoding_t dec, TransportAddress_ipSourceRoute_routing *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route *val);
static int ASN1CALL ASN1Dec_TransportAddress_ip6Address(ASN1decoding_t dec, TransportAddress_ip6Address *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipxAddress(ASN1decoding_t dec, TransportAddress_ipxAddress *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute(ASN1decoding_t dec, TransportAddress_ipSourceRoute *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipAddress(ASN1decoding_t dec, TransportAddress_ipAddress *val);
static int ASN1CALL ASN1Dec_Reject_problem(ASN1decoding_t dec, Reject_problem *val);
static int ASN1CALL ASN1Dec_EntityType(ASN1decoding_t dec, EntityType *val);
static int ASN1CALL ASN1Dec_InterpretationApdu(ASN1decoding_t dec, InterpretationApdu *val);
static int ASN1CALL ASN1Dec_ServiceApdus(ASN1decoding_t dec, ServiceApdus *val);
static int ASN1CALL ASN1Dec_Reject(ASN1decoding_t dec, Reject *val);
static int ASN1CALL ASN1Dec_EXTENSION(ASN1decoding_t dec, EXTENSION *val);
static int ASN1CALL ASN1Dec_GroupIndicationOnRes(ASN1decoding_t dec, GroupIndicationOnRes *val);
static int ASN1CALL ASN1Dec_GroupIndicationOffRes(ASN1decoding_t dec, GroupIndicationOffRes *val);
static int ASN1CALL ASN1Dec_PickupRes(ASN1decoding_t dec, PickupRes *val);
static int ASN1CALL ASN1Dec_PickExeRes(ASN1decoding_t dec, PickExeRes *val);
static int ASN1CALL ASN1Dec_UserSpecifiedSubaddress(ASN1decoding_t dec, UserSpecifiedSubaddress *val);
static int ASN1CALL ASN1Dec_CODE(ASN1decoding_t dec, CODE *val);
static int ASN1CALL ASN1Dec_H221NonStandard(ASN1decoding_t dec, H221NonStandard *val);
static int ASN1CALL ASN1Dec_H225NonStandardIdentifier(ASN1decoding_t dec, H225NonStandardIdentifier *val);
static int ASN1CALL ASN1Dec_PublicTypeOfNumber(ASN1decoding_t dec, PublicTypeOfNumber *val);
static int ASN1CALL ASN1Dec_PrivateTypeOfNumber(ASN1decoding_t dec, PrivateTypeOfNumber *val);
static int ASN1CALL ASN1Dec_CallIdentifier(ASN1decoding_t dec, CallIdentifier *val);
static int ASN1CALL ASN1Dec_ReturnResult_result(ASN1decoding_t dec, ReturnResult_result *val);
static int ASN1CALL ASN1Dec_Invoke(ASN1decoding_t dec, Invoke *val);
static int ASN1CALL ASN1Dec_ReturnResult(ASN1decoding_t dec, ReturnResult *val);
static int ASN1CALL ASN1Dec_ReturnError(ASN1decoding_t dec, ReturnError *val);
static int ASN1CALL ASN1Dec_ExtensionSeq(ASN1decoding_t dec, PExtensionSeq *val);
static int ASN1CALL ASN1Dec_PickrequRes(ASN1decoding_t dec, PickrequRes *val);
static int ASN1CALL ASN1Dec_PartySubaddress(ASN1decoding_t dec, PartySubaddress *val);
static int ASN1CALL ASN1Dec_H225NonStandardParameter(ASN1decoding_t dec, H225NonStandardParameter *val);
static int ASN1CALL ASN1Dec_PublicPartyNumber(ASN1decoding_t dec, PublicPartyNumber *val);
static int ASN1CALL ASN1Dec_PrivatePartyNumber(ASN1decoding_t dec, PrivatePartyNumber *val);
static int ASN1CALL ASN1Dec_TransportAddress(ASN1decoding_t dec, TransportAddress *val);
static int ASN1CALL ASN1Dec_CTActiveArg_argumentExtension(ASN1decoding_t dec, CTActiveArg_argumentExtension *val);
static int ASN1CALL ASN1Dec_CTCompleteArg_argumentExtension(ASN1decoding_t dec, CTCompleteArg_argumentExtension *val);
static int ASN1CALL ASN1Dec_SubaddressTransferArg_argumentExtension(ASN1decoding_t dec, SubaddressTransferArg_argumentExtension *val);
static int ASN1CALL ASN1Dec_CTUpdateArg_argumentExtension(ASN1decoding_t dec, CTUpdateArg_argumentExtension *val);
static int ASN1CALL ASN1Dec_CTIdentifyRes_resultExtension(ASN1decoding_t dec, CTIdentifyRes_resultExtension *val);
static int ASN1CALL ASN1Dec_CTSetupArg_argumentExtension(ASN1decoding_t dec, CTSetupArg_argumentExtension *val);
static int ASN1CALL ASN1Dec_CTInitiateArg_argumentExtension(ASN1decoding_t dec, CTInitiateArg_argumentExtension *val);
static int ASN1CALL ASN1Dec_IntResult_extension(ASN1decoding_t dec, IntResult_extension *val);
static int ASN1CALL ASN1Dec_DivertingLegInformation4Argument_extension(ASN1decoding_t dec, DivertingLegInformation4Argument_extension *val);
static int ASN1CALL ASN1Dec_DivertingLegInformation3Argument_extension(ASN1decoding_t dec, DivertingLegInformation3Argument_extension *val);
static int ASN1CALL ASN1Dec_DivertingLegInformation2Argument_extension(ASN1decoding_t dec, DivertingLegInformation2Argument_extension *val);
static int ASN1CALL ASN1Dec_DivertingLegInformation1Argument_extension(ASN1decoding_t dec, DivertingLegInformation1Argument_extension *val);
static int ASN1CALL ASN1Dec_CallReroutingArgument_extension(ASN1decoding_t dec, CallReroutingArgument_extension *val);
static int ASN1CALL ASN1Dec_CheckRestrictionArgument_extension(ASN1decoding_t dec, CheckRestrictionArgument_extension *val);
static int ASN1CALL ASN1Dec_InterrogateDiversionQArgument_extension(ASN1decoding_t dec, InterrogateDiversionQArgument_extension *val);
static int ASN1CALL ASN1Dec_DeactivateDiversionQArgument_extension(ASN1decoding_t dec, DeactivateDiversionQArgument_extension *val);
static int ASN1CALL ASN1Dec_ActivateDiversionQArgument_extension(ASN1decoding_t dec, ActivateDiversionQArgument_extension *val);
static int ASN1CALL ASN1Dec_H4503ROS(ASN1decoding_t dec, H4503ROS *val);
static int ASN1CALL ASN1Dec_DummyArg(ASN1decoding_t dec, DummyArg *val);
static int ASN1CALL ASN1Dec_DummyRes(ASN1decoding_t dec, DummyRes *val);
static int ASN1CALL ASN1Dec_SubaddressTransferArg(ASN1decoding_t dec, SubaddressTransferArg *val);
static int ASN1CALL ASN1Dec_MixedExtension(ASN1decoding_t dec, MixedExtension *val);
static int ASN1CALL ASN1Dec_PartyNumber(ASN1decoding_t dec, PartyNumber *val);
static int ASN1CALL ASN1Dec_CpickupNotifyArg_extensionArg(ASN1decoding_t dec, PCpickupNotifyArg_extensionArg *val);
static int ASN1CALL ASN1Dec_CpNotifyArg_extensionArg(ASN1decoding_t dec, PCpNotifyArg_extensionArg *val);
static int ASN1CALL ASN1Dec_PickExeRes_extensionRes(ASN1decoding_t dec, PPickExeRes_extensionRes *val);
static int ASN1CALL ASN1Dec_PickExeArg_extensionArg(ASN1decoding_t dec, PPickExeArg_extensionArg *val);
static int ASN1CALL ASN1Dec_PickupRes_extensionRes(ASN1decoding_t dec, PPickupRes_extensionRes *val);
static int ASN1CALL ASN1Dec_PickupArg_extensionArg(ASN1decoding_t dec, PPickupArg_extensionArg *val);
static int ASN1CALL ASN1Dec_PickrequRes_extensionRes(ASN1decoding_t dec, PPickrequRes_extensionRes *val);
static int ASN1CALL ASN1Dec_PickrequArg_extensionArg(ASN1decoding_t dec, PPickrequArg_extensionArg *val);
static int ASN1CALL ASN1Dec_GroupIndicationOffRes_extensionRes(ASN1decoding_t dec, PGroupIndicationOffRes_extensionRes *val);
static int ASN1CALL ASN1Dec_GroupIndicationOffArg_extensionArg(ASN1decoding_t dec, PGroupIndicationOffArg_extensionArg *val);
static int ASN1CALL ASN1Dec_GroupIndicationOnRes_extensionRes(ASN1decoding_t dec, PGroupIndicationOnRes_extensionRes *val);
static int ASN1CALL ASN1Dec_GroupIndicationOnArg_extensionArg(ASN1decoding_t dec, PGroupIndicationOnArg_extensionArg *val);
static int ASN1CALL ASN1Dec_CpSetupRes_extensionRes(ASN1decoding_t dec, PCpSetupRes_extensionRes *val);
static int ASN1CALL ASN1Dec_CpSetupArg_extensionArg(ASN1decoding_t dec, PCpSetupArg_extensionArg *val);
static int ASN1CALL ASN1Dec_CpRequestRes_extensionRes(ASN1decoding_t dec, PCpRequestRes_extensionRes *val);
static int ASN1CALL ASN1Dec_CpRequestArg_extensionArg(ASN1decoding_t dec, PCpRequestArg_extensionArg *val);
static int ASN1CALL ASN1Dec_ServiceApdus_rosApdus(ASN1decoding_t dec, PServiceApdus_rosApdus *val);
static int ASN1CALL ASN1Dec_AliasAddress(ASN1decoding_t dec, AliasAddress *val);
static int ASN1CALL ASN1Dec_EndpointAddress_destinationAddress(ASN1decoding_t dec, PEndpointAddress_destinationAddress *val);
static int ASN1CALL ASN1Dec_AddressInformation(ASN1decoding_t dec, AddressInformation *val);
static int ASN1CALL ASN1Dec_EndpointAddress(ASN1decoding_t dec, EndpointAddress *val);
static int ASN1CALL ASN1Dec_NetworkFacilityExtension(ASN1decoding_t dec, NetworkFacilityExtension *val);
static int ASN1CALL ASN1Dec_ActivateDiversionQArgument(ASN1decoding_t dec, ActivateDiversionQArgument *val);
static int ASN1CALL ASN1Dec_DeactivateDiversionQArgument(ASN1decoding_t dec, DeactivateDiversionQArgument *val);
static int ASN1CALL ASN1Dec_InterrogateDiversionQArgument(ASN1decoding_t dec, InterrogateDiversionQArgument *val);
static int ASN1CALL ASN1Dec_CheckRestrictionArgument(ASN1decoding_t dec, CheckRestrictionArgument *val);
static int ASN1CALL ASN1Dec_CallReroutingArgument(ASN1decoding_t dec, CallReroutingArgument *val);
static int ASN1CALL ASN1Dec_DivertingLegInformation1Argument(ASN1decoding_t dec, DivertingLegInformation1Argument *val);
static int ASN1CALL ASN1Dec_DivertingLegInformation2Argument(ASN1decoding_t dec, DivertingLegInformation2Argument *val);
static int ASN1CALL ASN1Dec_DivertingLegInformation3Argument(ASN1decoding_t dec, DivertingLegInformation3Argument *val);
static int ASN1CALL ASN1Dec_DivertingLegInformation4Argument(ASN1decoding_t dec, DivertingLegInformation4Argument *val);
static int ASN1CALL ASN1Dec_IntResult(ASN1decoding_t dec, IntResult *val);
static int ASN1CALL ASN1Dec_CTInitiateArg(ASN1decoding_t dec, CTInitiateArg *val);
static int ASN1CALL ASN1Dec_CTSetupArg(ASN1decoding_t dec, CTSetupArg *val);
static int ASN1CALL ASN1Dec_CTIdentifyRes(ASN1decoding_t dec, CTIdentifyRes *val);
static int ASN1CALL ASN1Dec_CTUpdateArg(ASN1decoding_t dec, CTUpdateArg *val);
static int ASN1CALL ASN1Dec_CTCompleteArg(ASN1decoding_t dec, CTCompleteArg *val);
static int ASN1CALL ASN1Dec_CTActiveArg(ASN1decoding_t dec, CTActiveArg *val);
static int ASN1CALL ASN1Dec_CpRequestArg(ASN1decoding_t dec, CpRequestArg *val);
static int ASN1CALL ASN1Dec_CpRequestRes(ASN1decoding_t dec, CpRequestRes *val);
static int ASN1CALL ASN1Dec_CpSetupArg(ASN1decoding_t dec, CpSetupArg *val);
static int ASN1CALL ASN1Dec_CpSetupRes(ASN1decoding_t dec, CpSetupRes *val);
static int ASN1CALL ASN1Dec_GroupIndicationOnArg(ASN1decoding_t dec, GroupIndicationOnArg *val);
static int ASN1CALL ASN1Dec_GroupIndicationOffArg(ASN1decoding_t dec, GroupIndicationOffArg *val);
static int ASN1CALL ASN1Dec_PickrequArg(ASN1decoding_t dec, PickrequArg *val);
static int ASN1CALL ASN1Dec_PickupArg(ASN1decoding_t dec, PickupArg *val);
static int ASN1CALL ASN1Dec_PickExeArg(ASN1decoding_t dec, PickExeArg *val);
static int ASN1CALL ASN1Dec_CpNotifyArg(ASN1decoding_t dec, CpNotifyArg *val);
static int ASN1CALL ASN1Dec_CpickupNotifyArg(ASN1decoding_t dec, CpickupNotifyArg *val);
static int ASN1CALL ASN1Dec_H4501SupplementaryService(ASN1decoding_t dec, H4501SupplementaryService *val);
static int ASN1CALL ASN1Dec_IntResultList(ASN1decoding_t dec, IntResultList *val);
static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route(PTransportAddress_ipSourceRoute_route *val);
static void ASN1CALL ASN1Free_TransportAddress_ip6Address(TransportAddress_ip6Address *val);
static void ASN1CALL ASN1Free_TransportAddress_ipxAddress(TransportAddress_ipxAddress *val);
static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute(TransportAddress_ipSourceRoute *val);
static void ASN1CALL ASN1Free_TransportAddress_ipAddress(TransportAddress_ipAddress *val);
static void ASN1CALL ASN1Free_ServiceApdus(ServiceApdus *val);
static void ASN1CALL ASN1Free_EXTENSION(EXTENSION *val);
static void ASN1CALL ASN1Free_GroupIndicationOnRes(GroupIndicationOnRes *val);
static void ASN1CALL ASN1Free_GroupIndicationOffRes(GroupIndicationOffRes *val);
static void ASN1CALL ASN1Free_PickupRes(PickupRes *val);
static void ASN1CALL ASN1Free_PickExeRes(PickExeRes *val);
static void ASN1CALL ASN1Free_UserSpecifiedSubaddress(UserSpecifiedSubaddress *val);
static void ASN1CALL ASN1Free_CODE(CODE *val);
static void ASN1CALL ASN1Free_H225NonStandardIdentifier(H225NonStandardIdentifier *val);
static void ASN1CALL ASN1Free_CallIdentifier(CallIdentifier *val);
static void ASN1CALL ASN1Free_ReturnResult_result(ReturnResult_result *val);
static void ASN1CALL ASN1Free_Invoke(Invoke *val);
static void ASN1CALL ASN1Free_ReturnResult(ReturnResult *val);
static void ASN1CALL ASN1Free_ReturnError(ReturnError *val);
static void ASN1CALL ASN1Free_ExtensionSeq(PExtensionSeq *val);
static void ASN1CALL ASN1Free_PickrequRes(PickrequRes *val);
static void ASN1CALL ASN1Free_PartySubaddress(PartySubaddress *val);
static void ASN1CALL ASN1Free_H225NonStandardParameter(H225NonStandardParameter *val);
static void ASN1CALL ASN1Free_PublicPartyNumber(PublicPartyNumber *val);
static void ASN1CALL ASN1Free_PrivatePartyNumber(PrivatePartyNumber *val);
static void ASN1CALL ASN1Free_TransportAddress(TransportAddress *val);
static void ASN1CALL ASN1Free_CTActiveArg_argumentExtension(CTActiveArg_argumentExtension *val);
static void ASN1CALL ASN1Free_CTCompleteArg_argumentExtension(CTCompleteArg_argumentExtension *val);
static void ASN1CALL ASN1Free_SubaddressTransferArg_argumentExtension(SubaddressTransferArg_argumentExtension *val);
static void ASN1CALL ASN1Free_CTUpdateArg_argumentExtension(CTUpdateArg_argumentExtension *val);
static void ASN1CALL ASN1Free_CTIdentifyRes_resultExtension(CTIdentifyRes_resultExtension *val);
static void ASN1CALL ASN1Free_CTSetupArg_argumentExtension(CTSetupArg_argumentExtension *val);
static void ASN1CALL ASN1Free_CTInitiateArg_argumentExtension(CTInitiateArg_argumentExtension *val);
static void ASN1CALL ASN1Free_IntResult_extension(IntResult_extension *val);
static void ASN1CALL ASN1Free_DivertingLegInformation4Argument_extension(DivertingLegInformation4Argument_extension *val);
static void ASN1CALL ASN1Free_DivertingLegInformation3Argument_extension(DivertingLegInformation3Argument_extension *val);
static void ASN1CALL ASN1Free_DivertingLegInformation2Argument_extension(DivertingLegInformation2Argument_extension *val);
static void ASN1CALL ASN1Free_DivertingLegInformation1Argument_extension(DivertingLegInformation1Argument_extension *val);
static void ASN1CALL ASN1Free_CallReroutingArgument_extension(CallReroutingArgument_extension *val);
static void ASN1CALL ASN1Free_CheckRestrictionArgument_extension(CheckRestrictionArgument_extension *val);
static void ASN1CALL ASN1Free_InterrogateDiversionQArgument_extension(InterrogateDiversionQArgument_extension *val);
static void ASN1CALL ASN1Free_DeactivateDiversionQArgument_extension(DeactivateDiversionQArgument_extension *val);
static void ASN1CALL ASN1Free_ActivateDiversionQArgument_extension(ActivateDiversionQArgument_extension *val);
static void ASN1CALL ASN1Free_H4503ROS(H4503ROS *val);
static void ASN1CALL ASN1Free_DummyArg(DummyArg *val);
static void ASN1CALL ASN1Free_DummyRes(DummyRes *val);
static void ASN1CALL ASN1Free_SubaddressTransferArg(SubaddressTransferArg *val);
static void ASN1CALL ASN1Free_MixedExtension(MixedExtension *val);
static void ASN1CALL ASN1Free_PartyNumber(PartyNumber *val);
static void ASN1CALL ASN1Free_CpickupNotifyArg_extensionArg(PCpickupNotifyArg_extensionArg *val);
static void ASN1CALL ASN1Free_CpNotifyArg_extensionArg(PCpNotifyArg_extensionArg *val);
static void ASN1CALL ASN1Free_PickExeRes_extensionRes(PPickExeRes_extensionRes *val);
static void ASN1CALL ASN1Free_PickExeArg_extensionArg(PPickExeArg_extensionArg *val);
static void ASN1CALL ASN1Free_PickupRes_extensionRes(PPickupRes_extensionRes *val);
static void ASN1CALL ASN1Free_PickupArg_extensionArg(PPickupArg_extensionArg *val);
static void ASN1CALL ASN1Free_PickrequRes_extensionRes(PPickrequRes_extensionRes *val);
static void ASN1CALL ASN1Free_PickrequArg_extensionArg(PPickrequArg_extensionArg *val);
static void ASN1CALL ASN1Free_GroupIndicationOffRes_extensionRes(PGroupIndicationOffRes_extensionRes *val);
static void ASN1CALL ASN1Free_GroupIndicationOffArg_extensionArg(PGroupIndicationOffArg_extensionArg *val);
static void ASN1CALL ASN1Free_GroupIndicationOnRes_extensionRes(PGroupIndicationOnRes_extensionRes *val);
static void ASN1CALL ASN1Free_GroupIndicationOnArg_extensionArg(PGroupIndicationOnArg_extensionArg *val);
static void ASN1CALL ASN1Free_CpSetupRes_extensionRes(PCpSetupRes_extensionRes *val);
static void ASN1CALL ASN1Free_CpSetupArg_extensionArg(PCpSetupArg_extensionArg *val);
static void ASN1CALL ASN1Free_CpRequestRes_extensionRes(PCpRequestRes_extensionRes *val);
static void ASN1CALL ASN1Free_CpRequestArg_extensionArg(PCpRequestArg_extensionArg *val);
static void ASN1CALL ASN1Free_ServiceApdus_rosApdus(PServiceApdus_rosApdus *val);
static void ASN1CALL ASN1Free_AliasAddress(AliasAddress *val);
static void ASN1CALL ASN1Free_EndpointAddress_destinationAddress(PEndpointAddress_destinationAddress *val);
static void ASN1CALL ASN1Free_AddressInformation(AddressInformation *val);
static void ASN1CALL ASN1Free_EndpointAddress(EndpointAddress *val);
static void ASN1CALL ASN1Free_NetworkFacilityExtension(NetworkFacilityExtension *val);
static void ASN1CALL ASN1Free_ActivateDiversionQArgument(ActivateDiversionQArgument *val);
static void ASN1CALL ASN1Free_DeactivateDiversionQArgument(DeactivateDiversionQArgument *val);
static void ASN1CALL ASN1Free_InterrogateDiversionQArgument(InterrogateDiversionQArgument *val);
static void ASN1CALL ASN1Free_CheckRestrictionArgument(CheckRestrictionArgument *val);
static void ASN1CALL ASN1Free_CallReroutingArgument(CallReroutingArgument *val);
static void ASN1CALL ASN1Free_DivertingLegInformation1Argument(DivertingLegInformation1Argument *val);
static void ASN1CALL ASN1Free_DivertingLegInformation2Argument(DivertingLegInformation2Argument *val);
static void ASN1CALL ASN1Free_DivertingLegInformation3Argument(DivertingLegInformation3Argument *val);
static void ASN1CALL ASN1Free_DivertingLegInformation4Argument(DivertingLegInformation4Argument *val);
static void ASN1CALL ASN1Free_IntResult(IntResult *val);
static void ASN1CALL ASN1Free_CTInitiateArg(CTInitiateArg *val);
static void ASN1CALL ASN1Free_CTSetupArg(CTSetupArg *val);
static void ASN1CALL ASN1Free_CTIdentifyRes(CTIdentifyRes *val);
static void ASN1CALL ASN1Free_CTUpdateArg(CTUpdateArg *val);
static void ASN1CALL ASN1Free_CTCompleteArg(CTCompleteArg *val);
static void ASN1CALL ASN1Free_CTActiveArg(CTActiveArg *val);
static void ASN1CALL ASN1Free_CpRequestArg(CpRequestArg *val);
static void ASN1CALL ASN1Free_CpRequestRes(CpRequestRes *val);
static void ASN1CALL ASN1Free_CpSetupArg(CpSetupArg *val);
static void ASN1CALL ASN1Free_CpSetupRes(CpSetupRes *val);
static void ASN1CALL ASN1Free_GroupIndicationOnArg(GroupIndicationOnArg *val);
static void ASN1CALL ASN1Free_GroupIndicationOffArg(GroupIndicationOffArg *val);
static void ASN1CALL ASN1Free_PickrequArg(PickrequArg *val);
static void ASN1CALL ASN1Free_PickupArg(PickupArg *val);
static void ASN1CALL ASN1Free_PickExeArg(PickExeArg *val);
static void ASN1CALL ASN1Free_CpNotifyArg(CpNotifyArg *val);
static void ASN1CALL ASN1Free_CpickupNotifyArg(CpickupNotifyArg *val);
static void ASN1CALL ASN1Free_H4501SupplementaryService(H4501SupplementaryService *val);
static void ASN1CALL ASN1Free_IntResultList(IntResultList *val);

typedef ASN1PerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[36] = {
    (ASN1EncFun_t) ASN1Enc_GroupIndicationOnRes,
    (ASN1EncFun_t) ASN1Enc_GroupIndicationOffRes,
    (ASN1EncFun_t) ASN1Enc_PickupRes,
    (ASN1EncFun_t) ASN1Enc_PickExeRes,
    (ASN1EncFun_t) ASN1Enc_PickrequRes,
    (ASN1EncFun_t) ASN1Enc_DummyArg,
    (ASN1EncFun_t) ASN1Enc_DummyRes,
    (ASN1EncFun_t) ASN1Enc_SubaddressTransferArg,
    (ASN1EncFun_t) ASN1Enc_ActivateDiversionQArgument,
    (ASN1EncFun_t) ASN1Enc_DeactivateDiversionQArgument,
    (ASN1EncFun_t) ASN1Enc_InterrogateDiversionQArgument,
    (ASN1EncFun_t) ASN1Enc_CheckRestrictionArgument,
    (ASN1EncFun_t) ASN1Enc_CallReroutingArgument,
    (ASN1EncFun_t) ASN1Enc_DivertingLegInformation1Argument,
    (ASN1EncFun_t) ASN1Enc_DivertingLegInformation2Argument,
    (ASN1EncFun_t) ASN1Enc_DivertingLegInformation3Argument,
    (ASN1EncFun_t) ASN1Enc_DivertingLegInformation4Argument,
    (ASN1EncFun_t) ASN1Enc_CTInitiateArg,
    (ASN1EncFun_t) ASN1Enc_CTSetupArg,
    (ASN1EncFun_t) ASN1Enc_CTIdentifyRes,
    (ASN1EncFun_t) ASN1Enc_CTUpdateArg,
    (ASN1EncFun_t) ASN1Enc_CTCompleteArg,
    (ASN1EncFun_t) ASN1Enc_CTActiveArg,
    (ASN1EncFun_t) ASN1Enc_CpRequestArg,
    (ASN1EncFun_t) ASN1Enc_CpRequestRes,
    (ASN1EncFun_t) ASN1Enc_CpSetupArg,
    (ASN1EncFun_t) ASN1Enc_CpSetupRes,
    (ASN1EncFun_t) ASN1Enc_GroupIndicationOnArg,
    (ASN1EncFun_t) ASN1Enc_GroupIndicationOffArg,
    (ASN1EncFun_t) ASN1Enc_PickrequArg,
    (ASN1EncFun_t) ASN1Enc_PickupArg,
    (ASN1EncFun_t) ASN1Enc_PickExeArg,
    (ASN1EncFun_t) ASN1Enc_CpNotifyArg,
    (ASN1EncFun_t) ASN1Enc_CpickupNotifyArg,
    (ASN1EncFun_t) ASN1Enc_H4501SupplementaryService,
    (ASN1EncFun_t) ASN1Enc_IntResultList,
};
typedef ASN1PerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[36] = {
    (ASN1DecFun_t) ASN1Dec_GroupIndicationOnRes,
    (ASN1DecFun_t) ASN1Dec_GroupIndicationOffRes,
    (ASN1DecFun_t) ASN1Dec_PickupRes,
    (ASN1DecFun_t) ASN1Dec_PickExeRes,
    (ASN1DecFun_t) ASN1Dec_PickrequRes,
    (ASN1DecFun_t) ASN1Dec_DummyArg,
    (ASN1DecFun_t) ASN1Dec_DummyRes,
    (ASN1DecFun_t) ASN1Dec_SubaddressTransferArg,
    (ASN1DecFun_t) ASN1Dec_ActivateDiversionQArgument,
    (ASN1DecFun_t) ASN1Dec_DeactivateDiversionQArgument,
    (ASN1DecFun_t) ASN1Dec_InterrogateDiversionQArgument,
    (ASN1DecFun_t) ASN1Dec_CheckRestrictionArgument,
    (ASN1DecFun_t) ASN1Dec_CallReroutingArgument,
    (ASN1DecFun_t) ASN1Dec_DivertingLegInformation1Argument,
    (ASN1DecFun_t) ASN1Dec_DivertingLegInformation2Argument,
    (ASN1DecFun_t) ASN1Dec_DivertingLegInformation3Argument,
    (ASN1DecFun_t) ASN1Dec_DivertingLegInformation4Argument,
    (ASN1DecFun_t) ASN1Dec_CTInitiateArg,
    (ASN1DecFun_t) ASN1Dec_CTSetupArg,
    (ASN1DecFun_t) ASN1Dec_CTIdentifyRes,
    (ASN1DecFun_t) ASN1Dec_CTUpdateArg,
    (ASN1DecFun_t) ASN1Dec_CTCompleteArg,
    (ASN1DecFun_t) ASN1Dec_CTActiveArg,
    (ASN1DecFun_t) ASN1Dec_CpRequestArg,
    (ASN1DecFun_t) ASN1Dec_CpRequestRes,
    (ASN1DecFun_t) ASN1Dec_CpSetupArg,
    (ASN1DecFun_t) ASN1Dec_CpSetupRes,
    (ASN1DecFun_t) ASN1Dec_GroupIndicationOnArg,
    (ASN1DecFun_t) ASN1Dec_GroupIndicationOffArg,
    (ASN1DecFun_t) ASN1Dec_PickrequArg,
    (ASN1DecFun_t) ASN1Dec_PickupArg,
    (ASN1DecFun_t) ASN1Dec_PickExeArg,
    (ASN1DecFun_t) ASN1Dec_CpNotifyArg,
    (ASN1DecFun_t) ASN1Dec_CpickupNotifyArg,
    (ASN1DecFun_t) ASN1Dec_H4501SupplementaryService,
    (ASN1DecFun_t) ASN1Dec_IntResultList,
};
static const ASN1FreeFun_t freefntab[36] = {
    (ASN1FreeFun_t) ASN1Free_GroupIndicationOnRes,
    (ASN1FreeFun_t) ASN1Free_GroupIndicationOffRes,
    (ASN1FreeFun_t) ASN1Free_PickupRes,
    (ASN1FreeFun_t) ASN1Free_PickExeRes,
    (ASN1FreeFun_t) ASN1Free_PickrequRes,
    (ASN1FreeFun_t) ASN1Free_DummyArg,
    (ASN1FreeFun_t) ASN1Free_DummyRes,
    (ASN1FreeFun_t) ASN1Free_SubaddressTransferArg,
    (ASN1FreeFun_t) ASN1Free_ActivateDiversionQArgument,
    (ASN1FreeFun_t) ASN1Free_DeactivateDiversionQArgument,
    (ASN1FreeFun_t) ASN1Free_InterrogateDiversionQArgument,
    (ASN1FreeFun_t) ASN1Free_CheckRestrictionArgument,
    (ASN1FreeFun_t) ASN1Free_CallReroutingArgument,
    (ASN1FreeFun_t) ASN1Free_DivertingLegInformation1Argument,
    (ASN1FreeFun_t) ASN1Free_DivertingLegInformation2Argument,
    (ASN1FreeFun_t) ASN1Free_DivertingLegInformation3Argument,
    (ASN1FreeFun_t) ASN1Free_DivertingLegInformation4Argument,
    (ASN1FreeFun_t) ASN1Free_CTInitiateArg,
    (ASN1FreeFun_t) ASN1Free_CTSetupArg,
    (ASN1FreeFun_t) ASN1Free_CTIdentifyRes,
    (ASN1FreeFun_t) ASN1Free_CTUpdateArg,
    (ASN1FreeFun_t) ASN1Free_CTCompleteArg,
    (ASN1FreeFun_t) ASN1Free_CTActiveArg,
    (ASN1FreeFun_t) ASN1Free_CpRequestArg,
    (ASN1FreeFun_t) ASN1Free_CpRequestRes,
    (ASN1FreeFun_t) ASN1Free_CpSetupArg,
    (ASN1FreeFun_t) ASN1Free_CpSetupRes,
    (ASN1FreeFun_t) ASN1Free_GroupIndicationOnArg,
    (ASN1FreeFun_t) ASN1Free_GroupIndicationOffArg,
    (ASN1FreeFun_t) ASN1Free_PickrequArg,
    (ASN1FreeFun_t) ASN1Free_PickupArg,
    (ASN1FreeFun_t) ASN1Free_PickExeArg,
    (ASN1FreeFun_t) ASN1Free_CpNotifyArg,
    (ASN1FreeFun_t) ASN1Free_CpickupNotifyArg,
    (ASN1FreeFun_t) ASN1Free_H4501SupplementaryService,
    (ASN1FreeFun_t) ASN1Free_IntResultList,
};
static const ULONG sizetab[36] = {
    SIZE_H4503PP_Module_PDU_0,
    SIZE_H4503PP_Module_PDU_1,
    SIZE_H4503PP_Module_PDU_2,
    SIZE_H4503PP_Module_PDU_3,
    SIZE_H4503PP_Module_PDU_4,
    SIZE_H4503PP_Module_PDU_5,
    SIZE_H4503PP_Module_PDU_6,
    SIZE_H4503PP_Module_PDU_7,
    SIZE_H4503PP_Module_PDU_8,
    SIZE_H4503PP_Module_PDU_9,
    SIZE_H4503PP_Module_PDU_10,
    SIZE_H4503PP_Module_PDU_11,
    SIZE_H4503PP_Module_PDU_12,
    SIZE_H4503PP_Module_PDU_13,
    SIZE_H4503PP_Module_PDU_14,
    SIZE_H4503PP_Module_PDU_15,
    SIZE_H4503PP_Module_PDU_16,
    SIZE_H4503PP_Module_PDU_17,
    SIZE_H4503PP_Module_PDU_18,
    SIZE_H4503PP_Module_PDU_19,
    SIZE_H4503PP_Module_PDU_20,
    SIZE_H4503PP_Module_PDU_21,
    SIZE_H4503PP_Module_PDU_22,
    SIZE_H4503PP_Module_PDU_23,
    SIZE_H4503PP_Module_PDU_24,
    SIZE_H4503PP_Module_PDU_25,
    SIZE_H4503PP_Module_PDU_26,
    SIZE_H4503PP_Module_PDU_27,
    SIZE_H4503PP_Module_PDU_28,
    SIZE_H4503PP_Module_PDU_29,
    SIZE_H4503PP_Module_PDU_30,
    SIZE_H4503PP_Module_PDU_31,
    SIZE_H4503PP_Module_PDU_32,
    SIZE_H4503PP_Module_PDU_33,
    SIZE_H4503PP_Module_PDU_34,
    SIZE_H4503PP_Module_PDU_35,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */
CallStatus CTCompleteArg_callStatus_default = 0;
ASN1bool_t IntResult_remoteEnabled_default = 0;
BasicService InterrogateDiversionQArgument_basicService_default = 0;

void ASN1CALL H4503PP_Module_Startup(void)
{
    H4503PP_Module = ASN1_CreateModule(0x10000, ASN1_PER_RULE_ALIGNED, ASN1FLAGS_NONE, 36, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x30353468);
}

void ASN1CALL H4503PP_Module_Cleanup(void)
{
    ASN1_CloseModule(H4503PP_Module);
    H4503PP_Module = NULL;
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_routing(ASN1encoding_t enc, TransportAddress_ipSourceRoute_routing *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_routing(ASN1decoding_t dec, TransportAddress_ipSourceRoute_routing *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn);
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route(PTransportAddress_ipSourceRoute_route *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn(PTransportAddress_ipSourceRoute_route val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ip6Address(ASN1encoding_t enc, TransportAddress_ip6Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 16))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ip6Address(ASN1decoding_t dec, TransportAddress_ip6Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 16))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ip6Address(TransportAddress_ip6Address *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipxAddress(ASN1encoding_t enc, TransportAddress_ipxAddress *val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->port, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipxAddress(ASN1decoding_t dec, TransportAddress_ipxAddress *val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->port, 2))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipxAddress(TransportAddress_ipxAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute(ASN1encoding_t enc, TransportAddress_ipSourceRoute *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
	return 0;
    if (!ASN1Enc_TransportAddress_ipSourceRoute_route(enc, &(val)->route))
	return 0;
    if (!ASN1Enc_TransportAddress_ipSourceRoute_routing(enc, &(val)->routing))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute(ASN1decoding_t dec, TransportAddress_ipSourceRoute *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
	return 0;
    if (!ASN1Dec_TransportAddress_ipSourceRoute_route(dec, &(val)->route))
	return 0;
    if (!ASN1Dec_TransportAddress_ipSourceRoute_routing(dec, &(val)->routing))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute(TransportAddress_ipSourceRoute *val)
{
    if (val) {
	ASN1Free_TransportAddress_ipSourceRoute_route(&(val)->route);
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipAddress(ASN1encoding_t enc, TransportAddress_ipAddress *val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipAddress(ASN1decoding_t dec, TransportAddress_ipAddress *val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipAddress(TransportAddress_ipAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_Reject_problem(ASN1encoding_t enc, Reject_problem *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncInteger(enc, (val)->u.general))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncInteger(enc, (val)->u.invoke))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncInteger(enc, (val)->u.returnResult))
	    return 0;
	break;
    case 4:
	if (!ASN1PEREncInteger(enc, (val)->u.returnError))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Reject_problem(ASN1decoding_t dec, Reject_problem *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecInteger(dec, &(val)->u.general))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecInteger(dec, &(val)->u.invoke))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecInteger(dec, &(val)->u.returnResult))
	    return 0;
	break;
    case 4:
	if (!ASN1PERDecInteger(dec, &(val)->u.returnError))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_EntityType(ASN1encoding_t enc, EntityType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EntityType(ASN1decoding_t dec, EntityType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_InterpretationApdu(ASN1encoding_t enc, InterpretationApdu *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InterpretationApdu(ASN1decoding_t dec, InterpretationApdu *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ServiceApdus(ASN1encoding_t enc, ServiceApdus *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ServiceApdus_rosApdus(enc, &(val)->u.rosApdus))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ServiceApdus(ASN1decoding_t dec, ServiceApdus *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ServiceApdus_rosApdus(dec, &(val)->u.rosApdus))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ServiceApdus(ServiceApdus *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ServiceApdus_rosApdus(&(val)->u.rosApdus);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_Reject(ASN1encoding_t enc, Reject *val)
{
    if (!ASN1PEREncInteger(enc, (val)->invokeId))
	return 0;
    if (!ASN1Enc_Reject_problem(enc, &(val)->problem))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Reject(ASN1decoding_t dec, Reject *val)
{
    if (!ASN1PERDecInteger(dec, &(val)->invokeId))
	return 0;
    if (!ASN1Dec_Reject_problem(dec, &(val)->problem))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_EXTENSION(ASN1encoding_t enc, EXTENSION *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->argumentType - 1))
	    return 0;
    }
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->extensionID))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EXTENSION(ASN1decoding_t dec, EXTENSION *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->argumentType))
	    return 0;
	(val)->argumentType += 1;
    }
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->extensionID))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EXTENSION(EXTENSION *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->extensionID);
    }
}

static int ASN1CALL ASN1Enc_GroupIndicationOnRes(ASN1encoding_t enc, GroupIndicationOnRes *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_GroupIndicationOnRes_extensionRes(enc, &(val)->extensionRes))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GroupIndicationOnRes(ASN1decoding_t dec, GroupIndicationOnRes *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_GroupIndicationOnRes_extensionRes(dec, &(val)->extensionRes))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GroupIndicationOnRes(GroupIndicationOnRes *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_GroupIndicationOnRes_extensionRes(&(val)->extensionRes);
	}
    }
}

static int ASN1CALL ASN1Enc_GroupIndicationOffRes(ASN1encoding_t enc, GroupIndicationOffRes *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_GroupIndicationOffRes_extensionRes(enc, &(val)->extensionRes))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GroupIndicationOffRes(ASN1decoding_t dec, GroupIndicationOffRes *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_GroupIndicationOffRes_extensionRes(dec, &(val)->extensionRes))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GroupIndicationOffRes(GroupIndicationOffRes *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_GroupIndicationOffRes_extensionRes(&(val)->extensionRes);
	}
    }
}

static int ASN1CALL ASN1Enc_PickupRes(ASN1encoding_t enc, PickupRes *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_PickupRes_extensionRes(enc, &(val)->extensionRes))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PickupRes(ASN1decoding_t dec, PickupRes *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_PickupRes_extensionRes(dec, &(val)->extensionRes))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PickupRes(PickupRes *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_PickupRes_extensionRes(&(val)->extensionRes);
	}
    }
}

static int ASN1CALL ASN1Enc_PickExeRes(ASN1encoding_t enc, PickExeRes *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_PickExeRes_extensionRes(enc, &(val)->extensionRes))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PickExeRes(ASN1decoding_t dec, PickExeRes *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_PickExeRes_extensionRes(dec, &(val)->extensionRes))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PickExeRes(PickExeRes *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_PickExeRes_extensionRes(&(val)->extensionRes);
	}
    }
}

static int ASN1CALL ASN1Enc_UserSpecifiedSubaddress(ASN1encoding_t enc, UserSpecifiedSubaddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->subaddressInformation, 1, 20, 5))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBoolean(enc, (val)->oddCountIndicator))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserSpecifiedSubaddress(ASN1decoding_t dec, UserSpecifiedSubaddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->subaddressInformation, 1, 20, 5))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecBoolean(dec, &(val)->oddCountIndicator))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserSpecifiedSubaddress(UserSpecifiedSubaddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_CODE(ASN1encoding_t enc, CODE *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncInteger(enc, (val)->u.local))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.global))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CODE(ASN1decoding_t dec, CODE *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecInteger(dec, &(val)->u.local))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.global))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CODE(CODE *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1objectidentifier_free(&(val)->u.global);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H221NonStandard(ASN1encoding_t enc, H221NonStandard *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35CountryCode))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35Extension))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->manufacturerCode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H221NonStandard(ASN1decoding_t dec, H221NonStandard *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35CountryCode))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35Extension))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->manufacturerCode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H225NonStandardIdentifier(ASN1encoding_t enc, H225NonStandardIdentifier *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H221NonStandard(enc, &(val)->u.h221NonStandard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardIdentifier(ASN1decoding_t dec, H225NonStandardIdentifier *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H221NonStandard(dec, &(val)->u.h221NonStandard))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardIdentifier(H225NonStandardIdentifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1objectidentifier_free(&(val)->u.object);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_PublicTypeOfNumber(ASN1encoding_t enc, PublicTypeOfNumber *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PublicTypeOfNumber(ASN1decoding_t dec, PublicTypeOfNumber *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_PrivateTypeOfNumber(ASN1encoding_t enc, PrivateTypeOfNumber *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateTypeOfNumber(ASN1decoding_t dec, PrivateTypeOfNumber *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CallIdentifier(ASN1encoding_t enc, CallIdentifier *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->guid, 16))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallIdentifier(ASN1decoding_t dec, CallIdentifier *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->guid, 16))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CallIdentifier(CallIdentifier *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ReturnResult_result(ASN1encoding_t enc, ReturnResult_result *val)
{
    if (!ASN1Enc_CODE(enc, &(val)->opcode))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->result))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ReturnResult_result(ASN1decoding_t dec, ReturnResult_result *val)
{
    if (!ASN1Dec_CODE(dec, &(val)->opcode))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->result))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ReturnResult_result(ReturnResult_result *val)
{
    if (val) {
	ASN1Free_CODE(&(val)->opcode);
	ASN1octetstring_free(&(val)->result);
    }
}

static int ASN1CALL ASN1Enc_Invoke(ASN1encoding_t enc, Invoke *val)
{
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->invokeId))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncInteger(enc, (val)->linkedId))
	    return 0;
    }
    if (!ASN1Enc_CODE(enc, &(val)->opcode))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->argument))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Invoke(ASN1decoding_t dec, Invoke *val)
{
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->invokeId))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecInteger(dec, &(val)->linkedId))
	    return 0;
    }
    if (!ASN1Dec_CODE(dec, &(val)->opcode))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->argument))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Invoke(Invoke *val)
{
    if (val) {
	ASN1Free_CODE(&(val)->opcode);
	if ((val)->o[0] & 0x40) {
	    ASN1octetstring_free(&(val)->argument);
	}
    }
}

static int ASN1CALL ASN1Enc_ReturnResult(ASN1encoding_t enc, ReturnResult *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncInteger(enc, (val)->invokeId))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ReturnResult_result(enc, &(val)->result))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ReturnResult(ASN1decoding_t dec, ReturnResult *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecInteger(dec, &(val)->invokeId))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ReturnResult_result(dec, &(val)->result))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ReturnResult(ReturnResult *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ReturnResult_result(&(val)->result);
	}
    }
}

static int ASN1CALL ASN1Enc_ReturnError(ASN1encoding_t enc, ReturnError *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncInteger(enc, (val)->invokeId))
	return 0;
    if (!ASN1Enc_CODE(enc, &(val)->errcode))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->parameter))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ReturnError(ASN1decoding_t dec, ReturnError *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecInteger(dec, &(val)->invokeId))
	return 0;
    if (!ASN1Dec_CODE(dec, &(val)->errcode))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->parameter))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ReturnError(ReturnError *val)
{
    if (val) {
	ASN1Free_CODE(&(val)->errcode);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->parameter);
	}
    }
}

static int ASN1CALL ASN1Enc_ExtensionSeq(ASN1encoding_t enc, PExtensionSeq *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ExtensionSeq_ElmFn);
}

static int ASN1CALL ASN1Enc_ExtensionSeq_ElmFn(ASN1encoding_t enc, PExtensionSeq val)
{
    if (!ASN1Enc_EXTENSION(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ExtensionSeq(ASN1decoding_t dec, PExtensionSeq *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ExtensionSeq_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ExtensionSeq_ElmFn(ASN1decoding_t dec, PExtensionSeq val)
{
    if (!ASN1Dec_EXTENSION(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ExtensionSeq(PExtensionSeq *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ExtensionSeq_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ExtensionSeq_ElmFn(PExtensionSeq val)
{
    if (val) {
	ASN1Free_EXTENSION(&val->value);
    }
}

static int ASN1CALL ASN1Enc_PickrequRes(ASN1encoding_t enc, PickrequRes *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_CallIdentifier(enc, &(val)->callPickupId))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_PickrequRes_extensionRes(enc, &(val)->extensionRes))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PickrequRes(ASN1decoding_t dec, PickrequRes *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_CallIdentifier(dec, &(val)->callPickupId))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_PickrequRes_extensionRes(dec, &(val)->extensionRes))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PickrequRes(PickrequRes *val)
{
    if (val) {
	ASN1Free_CallIdentifier(&(val)->callPickupId);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_PickrequRes_extensionRes(&(val)->extensionRes);
	}
    }
}

static int ASN1CALL ASN1Enc_PartySubaddress(ASN1encoding_t enc, PartySubaddress *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_UserSpecifiedSubaddress(enc, &(val)->u.userSpecifiedSubaddress))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->u.nsapSubaddress, 1, 20, 5))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PartySubaddress(ASN1decoding_t dec, PartySubaddress *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_UserSpecifiedSubaddress(dec, &(val)->u.userSpecifiedSubaddress))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->u.nsapSubaddress, 1, 20, 5))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PartySubaddress(PartySubaddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_UserSpecifiedSubaddress(&(val)->u.userSpecifiedSubaddress);
	    break;
	case 2:
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H225NonStandardParameter(ASN1encoding_t enc, H225NonStandardParameter *val)
{
    if (!ASN1Enc_H225NonStandardIdentifier(enc, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardParameter(ASN1decoding_t dec, H225NonStandardParameter *val)
{
    if (!ASN1Dec_H225NonStandardIdentifier(dec, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardParameter(H225NonStandardParameter *val)
{
    if (val) {
	ASN1Free_H225NonStandardIdentifier(&(val)->nonStandardIdentifier);
	ASN1octetstring_free(&(val)->data);
    }
}

static ASN1stringtableentry_t PublicPartyNumber_publicNumberDigits_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PublicPartyNumber_publicNumberDigits_StringTable = {
    4, PublicPartyNumber_publicNumberDigits_StringTableEntries
};

static int ASN1CALL ASN1Enc_PublicPartyNumber(ASN1encoding_t enc, PublicPartyNumber *val)
{
    ASN1uint32_t t;
    if (!ASN1Enc_PublicTypeOfNumber(enc, &(val)->publicTypeOfNumber))
	return 0;
    t = lstrlenA((val)->publicNumberDigits);
    if (!ASN1PEREncBitVal(enc, 7, t - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->publicNumberDigits, 4, &PublicPartyNumber_publicNumberDigits_StringTable))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PublicPartyNumber(ASN1decoding_t dec, PublicPartyNumber *val)
{
    ASN1uint32_t l;
    if (!ASN1Dec_PublicTypeOfNumber(dec, &(val)->publicTypeOfNumber))
	return 0;
    if (!ASN1PERDecU32Val(dec, 7, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->publicNumberDigits, 4, &PublicPartyNumber_publicNumberDigits_StringTable))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PublicPartyNumber(PublicPartyNumber *val)
{
    if (val) {
    }
}

static ASN1stringtableentry_t PrivatePartyNumber_privateNumberDigits_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PrivatePartyNumber_privateNumberDigits_StringTable = {
    4, PrivatePartyNumber_privateNumberDigits_StringTableEntries
};

static int ASN1CALL ASN1Enc_PrivatePartyNumber(ASN1encoding_t enc, PrivatePartyNumber *val)
{
    ASN1uint32_t t;
    if (!ASN1Enc_PrivateTypeOfNumber(enc, &(val)->privateTypeOfNumber))
	return 0;
    t = lstrlenA((val)->privateNumberDigits);
    if (!ASN1PEREncBitVal(enc, 7, t - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->privateNumberDigits, 4, &PrivatePartyNumber_privateNumberDigits_StringTable))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivatePartyNumber(ASN1decoding_t dec, PrivatePartyNumber *val)
{
    ASN1uint32_t l;
    if (!ASN1Dec_PrivateTypeOfNumber(dec, &(val)->privateTypeOfNumber))
	return 0;
    if (!ASN1PERDecU32Val(dec, 7, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->privateNumberDigits, 4, &PrivatePartyNumber_privateNumberDigits_StringTable))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivatePartyNumber(PrivatePartyNumber *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress(ASN1encoding_t enc, TransportAddress *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_TransportAddress_ipAddress(enc, &(val)->u.ipAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_TransportAddress_ipSourceRoute(enc, &(val)->u.ipSourceRoute))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_TransportAddress_ipxAddress(enc, &(val)->u.ipxAddress))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_TransportAddress_ip6Address(enc, &(val)->u.ip6Address))
	    return 0;
	break;
    case 5:
	if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
	    return 0;
	break;
    case 6:
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardAddress))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress(ASN1decoding_t dec, TransportAddress *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_TransportAddress_ipAddress(dec, &(val)->u.ipAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_TransportAddress_ipSourceRoute(dec, &(val)->u.ipSourceRoute))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_TransportAddress_ipxAddress(dec, &(val)->u.ipxAddress))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_TransportAddress_ip6Address(dec, &(val)->u.ip6Address))
	    return 0;
	break;
    case 5:
	if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
	    return 0;
	break;
    case 6:
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardAddress))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress(TransportAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_TransportAddress_ipAddress(&(val)->u.ipAddress);
	    break;
	case 2:
	    ASN1Free_TransportAddress_ipSourceRoute(&(val)->u.ipSourceRoute);
	    break;
	case 3:
	    ASN1Free_TransportAddress_ipxAddress(&(val)->u.ipxAddress);
	    break;
	case 4:
	    ASN1Free_TransportAddress_ip6Address(&(val)->u.ip6Address);
	    break;
	case 5:
	    break;
	case 6:
	    break;
	case 7:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardAddress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CTActiveArg_argumentExtension(ASN1encoding_t enc, CTActiveArg_argumentExtension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTActiveArg_argumentExtension(ASN1decoding_t dec, CTActiveArg_argumentExtension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTActiveArg_argumentExtension(CTActiveArg_argumentExtension *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
	    break;
	case 2:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CTCompleteArg_argumentExtension(ASN1encoding_t enc, CTCompleteArg_argumentExtension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTCompleteArg_argumentExtension(ASN1decoding_t dec, CTCompleteArg_argumentExtension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTCompleteArg_argumentExtension(CTCompleteArg_argumentExtension *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
	    break;
	case 2:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_SubaddressTransferArg_argumentExtension(ASN1encoding_t enc, SubaddressTransferArg_argumentExtension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SubaddressTransferArg_argumentExtension(ASN1decoding_t dec, SubaddressTransferArg_argumentExtension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SubaddressTransferArg_argumentExtension(SubaddressTransferArg_argumentExtension *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
	    break;
	case 2:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CTUpdateArg_argumentExtension(ASN1encoding_t enc, CTUpdateArg_argumentExtension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTUpdateArg_argumentExtension(ASN1decoding_t dec, CTUpdateArg_argumentExtension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTUpdateArg_argumentExtension(CTUpdateArg_argumentExtension *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
	    break;
	case 2:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CTIdentifyRes_resultExtension(ASN1encoding_t enc, CTIdentifyRes_resultExtension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTIdentifyRes_resultExtension(ASN1decoding_t dec, CTIdentifyRes_resultExtension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTIdentifyRes_resultExtension(CTIdentifyRes_resultExtension *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
	    break;
	case 2:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CTSetupArg_argumentExtension(ASN1encoding_t enc, CTSetupArg_argumentExtension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTSetupArg_argumentExtension(ASN1decoding_t dec, CTSetupArg_argumentExtension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTSetupArg_argumentExtension(CTSetupArg_argumentExtension *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
	    break;
	case 2:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CTInitiateArg_argumentExtension(ASN1encoding_t enc, CTInitiateArg_argumentExtension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTInitiateArg_argumentExtension(ASN1decoding_t dec, CTInitiateArg_argumentExtension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTInitiateArg_argumentExtension(CTInitiateArg_argumentExtension *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
	    break;
	case 2:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_IntResult_extension(ASN1encoding_t enc, IntResult_extension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IntResult_extension(ASN1decoding_t dec, IntResult_extension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_IntResult_extension(IntResult_extension *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
	    break;
	case 2:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DivertingLegInformation4Argument_extension(ASN1encoding_t enc, DivertingLegInformation4Argument_extension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DivertingLegInformation4Argument_extension(ASN1decoding_t dec, DivertingLegInformation4Argument_extension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DivertingLegInformation4Argument_extension(DivertingLegInformation4Argument_extension *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
	    break;
	case 2:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DivertingLegInformation3Argument_extension(ASN1encoding_t enc, DivertingLegInformation3Argument_extension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DivertingLegInformation3Argument_extension(ASN1decoding_t dec, DivertingLegInformation3Argument_extension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DivertingLegInformation3Argument_extension(DivertingLegInformation3Argument_extension *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
	    break;
	case 2:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DivertingLegInformation2Argument_extension(ASN1encoding_t enc, DivertingLegInformation2Argument_extension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DivertingLegInformation2Argument_extension(ASN1decoding_t dec, DivertingLegInformation2Argument_extension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DivertingLegInformation2Argument_extension(DivertingLegInformation2Argument_extension *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
	    break;
	case 2:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DivertingLegInformation1Argument_extension(ASN1encoding_t enc, DivertingLegInformation1Argument_extension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DivertingLegInformation1Argument_extension(ASN1decoding_t dec, DivertingLegInformation1Argument_extension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DivertingLegInformation1Argument_extension(DivertingLegInformation1Argument_extension *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
	    break;
	case 2:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CallReroutingArgument_extension(ASN1encoding_t enc, CallReroutingArgument_extension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CallReroutingArgument_extension(ASN1decoding_t dec, CallReroutingArgument_extension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CallReroutingArgument_extension(CallReroutingArgument_extension *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
	    break;
	case 2:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CheckRestrictionArgument_extension(ASN1encoding_t enc, CheckRestrictionArgument_extension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CheckRestrictionArgument_extension(ASN1decoding_t dec, CheckRestrictionArgument_extension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CheckRestrictionArgument_extension(CheckRestrictionArgument_extension *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
	    break;
	case 2:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_InterrogateDiversionQArgument_extension(ASN1encoding_t enc, InterrogateDiversionQArgument_extension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InterrogateDiversionQArgument_extension(ASN1decoding_t dec, InterrogateDiversionQArgument_extension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_InterrogateDiversionQArgument_extension(InterrogateDiversionQArgument_extension *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
	    break;
	case 2:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DeactivateDiversionQArgument_extension(ASN1encoding_t enc, DeactivateDiversionQArgument_extension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DeactivateDiversionQArgument_extension(ASN1decoding_t dec, DeactivateDiversionQArgument_extension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DeactivateDiversionQArgument_extension(DeactivateDiversionQArgument_extension *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
	    break;
	case 2:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ActivateDiversionQArgument_extension(ASN1encoding_t enc, ActivateDiversionQArgument_extension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ActivateDiversionQArgument_extension(ASN1decoding_t dec, ActivateDiversionQArgument_extension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ActivateDiversionQArgument_extension(ActivateDiversionQArgument_extension *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
	    break;
	case 2:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H4503ROS(ASN1encoding_t enc, H4503ROS *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_Invoke(enc, &(val)->u.invoke))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ReturnResult(enc, &(val)->u.returnResult))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ReturnError(enc, &(val)->u.returnError))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_Reject(enc, &(val)->u.reject))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H4503ROS(ASN1decoding_t dec, H4503ROS *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_Invoke(dec, &(val)->u.invoke))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ReturnResult(dec, &(val)->u.returnResult))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ReturnError(dec, &(val)->u.returnError))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_Reject(dec, &(val)->u.reject))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H4503ROS(H4503ROS *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_Invoke(&(val)->u.invoke);
	    break;
	case 2:
	    ASN1Free_ReturnResult(&(val)->u.returnResult);
	    break;
	case 3:
	    ASN1Free_ReturnError(&(val)->u.returnError);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DummyArg(ASN1encoding_t enc, DummyArg *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DummyArg(ASN1decoding_t dec, DummyArg *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DummyArg(DummyArg *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
	    break;
	case 2:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DummyRes(ASN1encoding_t enc, DummyRes *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DummyRes(ASN1decoding_t dec, DummyRes *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DummyRes(DummyRes *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
	    break;
	case 2:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_SubaddressTransferArg(ASN1encoding_t enc, SubaddressTransferArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_PartySubaddress(enc, &(val)->redirectionSubaddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SubaddressTransferArg_argumentExtension(enc, &(val)->argumentExtension))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SubaddressTransferArg(ASN1decoding_t dec, SubaddressTransferArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_PartySubaddress(dec, &(val)->redirectionSubaddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_SubaddressTransferArg_argumentExtension(dec, &(val)->argumentExtension))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SubaddressTransferArg(SubaddressTransferArg *val)
{
    if (val) {
	ASN1Free_PartySubaddress(&(val)->redirectionSubaddress);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SubaddressTransferArg_argumentExtension(&(val)->argumentExtension);
	}
    }
}

static int ASN1CALL ASN1Enc_MixedExtension(ASN1encoding_t enc, MixedExtension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MixedExtension(ASN1decoding_t dec, MixedExtension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MixedExtension(MixedExtension *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
	    break;
	case 2:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	}
    }
}

static ASN1stringtableentry_t PartyNumber_dataPartyNumber_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PartyNumber_dataPartyNumber_StringTable = {
    4, PartyNumber_dataPartyNumber_StringTableEntries
};

static ASN1stringtableentry_t PartyNumber_telexPartyNumber_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PartyNumber_telexPartyNumber_StringTable = {
    4, PartyNumber_telexPartyNumber_StringTableEntries
};

static ASN1stringtableentry_t PartyNumber_nationalStandardPartyNumber_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PartyNumber_nationalStandardPartyNumber_StringTable = {
    4, PartyNumber_nationalStandardPartyNumber_StringTableEntries
};

static int ASN1CALL ASN1Enc_PartyNumber(ASN1encoding_t enc, PartyNumber *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_PublicPartyNumber(enc, &(val)->u.publicNumber))
	    return 0;
	break;
    case 2:
	t = lstrlenA((val)->u.dataPartyNumber);
	if (!ASN1PEREncBitVal(enc, 7, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.dataPartyNumber, 4, &PartyNumber_dataPartyNumber_StringTable))
	    return 0;
	break;
    case 3:
	t = lstrlenA((val)->u.telexPartyNumber);
	if (!ASN1PEREncBitVal(enc, 7, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.telexPartyNumber, 4, &PartyNumber_telexPartyNumber_StringTable))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_PrivatePartyNumber(enc, &(val)->u.privateNumber))
	    return 0;
	break;
    case 5:
	t = lstrlenA((val)->u.nationalStandardPartyNumber);
	if (!ASN1PEREncBitVal(enc, 7, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.nationalStandardPartyNumber, 4, &PartyNumber_nationalStandardPartyNumber_StringTable))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PartyNumber(ASN1decoding_t dec, PartyNumber *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_PublicPartyNumber(dec, &(val)->u.publicNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecU32Val(dec, 7, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.dataPartyNumber, 4, &PartyNumber_dataPartyNumber_StringTable))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecU32Val(dec, 7, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.telexPartyNumber, 4, &PartyNumber_telexPartyNumber_StringTable))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_PrivatePartyNumber(dec, &(val)->u.privateNumber))
	    return 0;
	break;
    case 5:
	if (!ASN1PERDecU32Val(dec, 7, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.nationalStandardPartyNumber, 4, &PartyNumber_nationalStandardPartyNumber_StringTable))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PartyNumber(PartyNumber *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_PublicPartyNumber(&(val)->u.publicNumber);
	    break;
	case 2:
	    break;
	case 3:
	    break;
	case 4:
	    ASN1Free_PrivatePartyNumber(&(val)->u.privateNumber);
	    break;
	case 5:
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CpickupNotifyArg_extensionArg(ASN1encoding_t enc, PCpickupNotifyArg_extensionArg *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CpickupNotifyArg_extensionArg_ElmFn);
}

static int ASN1CALL ASN1Enc_CpickupNotifyArg_extensionArg_ElmFn(ASN1encoding_t enc, PCpickupNotifyArg_extensionArg val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CpickupNotifyArg_extensionArg(ASN1decoding_t dec, PCpickupNotifyArg_extensionArg *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CpickupNotifyArg_extensionArg_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CpickupNotifyArg_extensionArg_ElmFn(ASN1decoding_t dec, PCpickupNotifyArg_extensionArg val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CpickupNotifyArg_extensionArg(PCpickupNotifyArg_extensionArg *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CpickupNotifyArg_extensionArg_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CpickupNotifyArg_extensionArg_ElmFn(PCpickupNotifyArg_extensionArg val)
{
    if (val) {
	ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CpNotifyArg_extensionArg(ASN1encoding_t enc, PCpNotifyArg_extensionArg *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CpNotifyArg_extensionArg_ElmFn);
}

static int ASN1CALL ASN1Enc_CpNotifyArg_extensionArg_ElmFn(ASN1encoding_t enc, PCpNotifyArg_extensionArg val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CpNotifyArg_extensionArg(ASN1decoding_t dec, PCpNotifyArg_extensionArg *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CpNotifyArg_extensionArg_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CpNotifyArg_extensionArg_ElmFn(ASN1decoding_t dec, PCpNotifyArg_extensionArg val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CpNotifyArg_extensionArg(PCpNotifyArg_extensionArg *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CpNotifyArg_extensionArg_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CpNotifyArg_extensionArg_ElmFn(PCpNotifyArg_extensionArg val)
{
    if (val) {
	ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_PickExeRes_extensionRes(ASN1encoding_t enc, PPickExeRes_extensionRes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PickExeRes_extensionRes_ElmFn);
}

static int ASN1CALL ASN1Enc_PickExeRes_extensionRes_ElmFn(ASN1encoding_t enc, PPickExeRes_extensionRes val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PickExeRes_extensionRes(ASN1decoding_t dec, PPickExeRes_extensionRes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PickExeRes_extensionRes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_PickExeRes_extensionRes_ElmFn(ASN1decoding_t dec, PPickExeRes_extensionRes val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PickExeRes_extensionRes(PPickExeRes_extensionRes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PickExeRes_extensionRes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PickExeRes_extensionRes_ElmFn(PPickExeRes_extensionRes val)
{
    if (val) {
	ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_PickExeArg_extensionArg(ASN1encoding_t enc, PPickExeArg_extensionArg *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PickExeArg_extensionArg_ElmFn);
}

static int ASN1CALL ASN1Enc_PickExeArg_extensionArg_ElmFn(ASN1encoding_t enc, PPickExeArg_extensionArg val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PickExeArg_extensionArg(ASN1decoding_t dec, PPickExeArg_extensionArg *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PickExeArg_extensionArg_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_PickExeArg_extensionArg_ElmFn(ASN1decoding_t dec, PPickExeArg_extensionArg val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PickExeArg_extensionArg(PPickExeArg_extensionArg *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PickExeArg_extensionArg_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PickExeArg_extensionArg_ElmFn(PPickExeArg_extensionArg val)
{
    if (val) {
	ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_PickupRes_extensionRes(ASN1encoding_t enc, PPickupRes_extensionRes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PickupRes_extensionRes_ElmFn);
}

static int ASN1CALL ASN1Enc_PickupRes_extensionRes_ElmFn(ASN1encoding_t enc, PPickupRes_extensionRes val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PickupRes_extensionRes(ASN1decoding_t dec, PPickupRes_extensionRes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PickupRes_extensionRes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_PickupRes_extensionRes_ElmFn(ASN1decoding_t dec, PPickupRes_extensionRes val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PickupRes_extensionRes(PPickupRes_extensionRes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PickupRes_extensionRes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PickupRes_extensionRes_ElmFn(PPickupRes_extensionRes val)
{
    if (val) {
	ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_PickupArg_extensionArg(ASN1encoding_t enc, PPickupArg_extensionArg *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PickupArg_extensionArg_ElmFn);
}

static int ASN1CALL ASN1Enc_PickupArg_extensionArg_ElmFn(ASN1encoding_t enc, PPickupArg_extensionArg val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PickupArg_extensionArg(ASN1decoding_t dec, PPickupArg_extensionArg *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PickupArg_extensionArg_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_PickupArg_extensionArg_ElmFn(ASN1decoding_t dec, PPickupArg_extensionArg val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PickupArg_extensionArg(PPickupArg_extensionArg *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PickupArg_extensionArg_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PickupArg_extensionArg_ElmFn(PPickupArg_extensionArg val)
{
    if (val) {
	ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_PickrequRes_extensionRes(ASN1encoding_t enc, PPickrequRes_extensionRes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PickrequRes_extensionRes_ElmFn);
}

static int ASN1CALL ASN1Enc_PickrequRes_extensionRes_ElmFn(ASN1encoding_t enc, PPickrequRes_extensionRes val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PickrequRes_extensionRes(ASN1decoding_t dec, PPickrequRes_extensionRes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PickrequRes_extensionRes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_PickrequRes_extensionRes_ElmFn(ASN1decoding_t dec, PPickrequRes_extensionRes val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PickrequRes_extensionRes(PPickrequRes_extensionRes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PickrequRes_extensionRes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PickrequRes_extensionRes_ElmFn(PPickrequRes_extensionRes val)
{
    if (val) {
	ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_PickrequArg_extensionArg(ASN1encoding_t enc, PPickrequArg_extensionArg *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PickrequArg_extensionArg_ElmFn);
}

static int ASN1CALL ASN1Enc_PickrequArg_extensionArg_ElmFn(ASN1encoding_t enc, PPickrequArg_extensionArg val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PickrequArg_extensionArg(ASN1decoding_t dec, PPickrequArg_extensionArg *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PickrequArg_extensionArg_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_PickrequArg_extensionArg_ElmFn(ASN1decoding_t dec, PPickrequArg_extensionArg val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PickrequArg_extensionArg(PPickrequArg_extensionArg *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PickrequArg_extensionArg_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PickrequArg_extensionArg_ElmFn(PPickrequArg_extensionArg val)
{
    if (val) {
	ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GroupIndicationOffRes_extensionRes(ASN1encoding_t enc, PGroupIndicationOffRes_extensionRes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GroupIndicationOffRes_extensionRes_ElmFn);
}

static int ASN1CALL ASN1Enc_GroupIndicationOffRes_extensionRes_ElmFn(ASN1encoding_t enc, PGroupIndicationOffRes_extensionRes val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GroupIndicationOffRes_extensionRes(ASN1decoding_t dec, PGroupIndicationOffRes_extensionRes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GroupIndicationOffRes_extensionRes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GroupIndicationOffRes_extensionRes_ElmFn(ASN1decoding_t dec, PGroupIndicationOffRes_extensionRes val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GroupIndicationOffRes_extensionRes(PGroupIndicationOffRes_extensionRes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GroupIndicationOffRes_extensionRes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GroupIndicationOffRes_extensionRes_ElmFn(PGroupIndicationOffRes_extensionRes val)
{
    if (val) {
	ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GroupIndicationOffArg_extensionArg(ASN1encoding_t enc, PGroupIndicationOffArg_extensionArg *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GroupIndicationOffArg_extensionArg_ElmFn);
}

static int ASN1CALL ASN1Enc_GroupIndicationOffArg_extensionArg_ElmFn(ASN1encoding_t enc, PGroupIndicationOffArg_extensionArg val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GroupIndicationOffArg_extensionArg(ASN1decoding_t dec, PGroupIndicationOffArg_extensionArg *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GroupIndicationOffArg_extensionArg_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GroupIndicationOffArg_extensionArg_ElmFn(ASN1decoding_t dec, PGroupIndicationOffArg_extensionArg val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GroupIndicationOffArg_extensionArg(PGroupIndicationOffArg_extensionArg *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GroupIndicationOffArg_extensionArg_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GroupIndicationOffArg_extensionArg_ElmFn(PGroupIndicationOffArg_extensionArg val)
{
    if (val) {
	ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GroupIndicationOnRes_extensionRes(ASN1encoding_t enc, PGroupIndicationOnRes_extensionRes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GroupIndicationOnRes_extensionRes_ElmFn);
}

static int ASN1CALL ASN1Enc_GroupIndicationOnRes_extensionRes_ElmFn(ASN1encoding_t enc, PGroupIndicationOnRes_extensionRes val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GroupIndicationOnRes_extensionRes(ASN1decoding_t dec, PGroupIndicationOnRes_extensionRes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GroupIndicationOnRes_extensionRes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GroupIndicationOnRes_extensionRes_ElmFn(ASN1decoding_t dec, PGroupIndicationOnRes_extensionRes val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GroupIndicationOnRes_extensionRes(PGroupIndicationOnRes_extensionRes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GroupIndicationOnRes_extensionRes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GroupIndicationOnRes_extensionRes_ElmFn(PGroupIndicationOnRes_extensionRes val)
{
    if (val) {
	ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GroupIndicationOnArg_extensionArg(ASN1encoding_t enc, PGroupIndicationOnArg_extensionArg *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GroupIndicationOnArg_extensionArg_ElmFn);
}

static int ASN1CALL ASN1Enc_GroupIndicationOnArg_extensionArg_ElmFn(ASN1encoding_t enc, PGroupIndicationOnArg_extensionArg val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GroupIndicationOnArg_extensionArg(ASN1decoding_t dec, PGroupIndicationOnArg_extensionArg *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GroupIndicationOnArg_extensionArg_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GroupIndicationOnArg_extensionArg_ElmFn(ASN1decoding_t dec, PGroupIndicationOnArg_extensionArg val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GroupIndicationOnArg_extensionArg(PGroupIndicationOnArg_extensionArg *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GroupIndicationOnArg_extensionArg_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GroupIndicationOnArg_extensionArg_ElmFn(PGroupIndicationOnArg_extensionArg val)
{
    if (val) {
	ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CpSetupRes_extensionRes(ASN1encoding_t enc, PCpSetupRes_extensionRes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CpSetupRes_extensionRes_ElmFn);
}

static int ASN1CALL ASN1Enc_CpSetupRes_extensionRes_ElmFn(ASN1encoding_t enc, PCpSetupRes_extensionRes val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CpSetupRes_extensionRes(ASN1decoding_t dec, PCpSetupRes_extensionRes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CpSetupRes_extensionRes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CpSetupRes_extensionRes_ElmFn(ASN1decoding_t dec, PCpSetupRes_extensionRes val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CpSetupRes_extensionRes(PCpSetupRes_extensionRes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CpSetupRes_extensionRes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CpSetupRes_extensionRes_ElmFn(PCpSetupRes_extensionRes val)
{
    if (val) {
	ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CpSetupArg_extensionArg(ASN1encoding_t enc, PCpSetupArg_extensionArg *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CpSetupArg_extensionArg_ElmFn);
}

static int ASN1CALL ASN1Enc_CpSetupArg_extensionArg_ElmFn(ASN1encoding_t enc, PCpSetupArg_extensionArg val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CpSetupArg_extensionArg(ASN1decoding_t dec, PCpSetupArg_extensionArg *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CpSetupArg_extensionArg_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CpSetupArg_extensionArg_ElmFn(ASN1decoding_t dec, PCpSetupArg_extensionArg val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CpSetupArg_extensionArg(PCpSetupArg_extensionArg *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CpSetupArg_extensionArg_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CpSetupArg_extensionArg_ElmFn(PCpSetupArg_extensionArg val)
{
    if (val) {
	ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CpRequestRes_extensionRes(ASN1encoding_t enc, PCpRequestRes_extensionRes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CpRequestRes_extensionRes_ElmFn);
}

static int ASN1CALL ASN1Enc_CpRequestRes_extensionRes_ElmFn(ASN1encoding_t enc, PCpRequestRes_extensionRes val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CpRequestRes_extensionRes(ASN1decoding_t dec, PCpRequestRes_extensionRes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CpRequestRes_extensionRes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CpRequestRes_extensionRes_ElmFn(ASN1decoding_t dec, PCpRequestRes_extensionRes val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CpRequestRes_extensionRes(PCpRequestRes_extensionRes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CpRequestRes_extensionRes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CpRequestRes_extensionRes_ElmFn(PCpRequestRes_extensionRes val)
{
    if (val) {
	ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CpRequestArg_extensionArg(ASN1encoding_t enc, PCpRequestArg_extensionArg *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CpRequestArg_extensionArg_ElmFn);
}

static int ASN1CALL ASN1Enc_CpRequestArg_extensionArg_ElmFn(ASN1encoding_t enc, PCpRequestArg_extensionArg val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CpRequestArg_extensionArg(ASN1decoding_t dec, PCpRequestArg_extensionArg *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CpRequestArg_extensionArg_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CpRequestArg_extensionArg_ElmFn(ASN1decoding_t dec, PCpRequestArg_extensionArg val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CpRequestArg_extensionArg(PCpRequestArg_extensionArg *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CpRequestArg_extensionArg_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CpRequestArg_extensionArg_ElmFn(PCpRequestArg_extensionArg val)
{
    if (val) {
	ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ServiceApdus_rosApdus(ASN1encoding_t enc, PServiceApdus_rosApdus *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ServiceApdus_rosApdus_ElmFn);
}

static int ASN1CALL ASN1Enc_ServiceApdus_rosApdus_ElmFn(ASN1encoding_t enc, PServiceApdus_rosApdus val)
{
    if (!ASN1Enc_H4503ROS(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ServiceApdus_rosApdus(ASN1decoding_t dec, PServiceApdus_rosApdus *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ServiceApdus_rosApdus_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ServiceApdus_rosApdus_ElmFn(ASN1decoding_t dec, PServiceApdus_rosApdus val)
{
    if (!ASN1Dec_H4503ROS(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ServiceApdus_rosApdus(PServiceApdus_rosApdus *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ServiceApdus_rosApdus_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ServiceApdus_rosApdus_ElmFn(PServiceApdus_rosApdus val)
{
    if (val) {
	ASN1Free_H4503ROS(&val->value);
    }
}

static ASN1stringtableentry_t AliasAddress_e164_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t AliasAddress_e164_StringTable = {
    4, AliasAddress_e164_StringTableEntries
};

static int ASN1CALL ASN1Enc_AliasAddress(ASN1encoding_t enc, AliasAddress *val)
{
    ASN1uint32_t t;
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	t = lstrlenA((val)->u.e164);
	if (!ASN1PEREncBitVal(enc, 7, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.e164, 4, &AliasAddress_e164_StringTable))
	    return 0;
	break;
    case 2:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->u.h323_ID).length - 1))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->u.h323_ID).length, ((val)->u.h323_ID).value, 16))
	    return 0;
	break;
    case 3:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	t = lstrlenA((val)->u.url_ID);
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 16, t - 1))
	    return 0;
	if (!ASN1PEREncCharString(ee, t, (val)->u.url_ID, 8))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 4:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TransportAddress(ee, &(val)->u.transportID))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 5:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	t = lstrlenA((val)->u.email_ID);
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 16, t - 1))
	    return 0;
	if (!ASN1PEREncCharString(ee, t, (val)->u.email_ID, 8))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 6:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_PartyNumber(ee, &(val)->u.partyNumber))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AliasAddress(ASN1decoding_t dec, AliasAddress *val)
{
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU32Val(dec, 7, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.e164, 4, &AliasAddress_e164_StringTable))
	    return 0;
	break;
    case 2:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->u.h323_ID).length))
	    return 0;
	((val)->u.h323_ID).length += 1;
	if (!ASN1PERDecChar16String(dec, ((val)->u.h323_ID).length, &((val)->u.h323_ID).value, 16))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU32Val(dd, 16, &l))
	    return 0;
	l += 1;
	if (!ASN1PERDecZeroCharStringNoAlloc(dd, l, (val)->u.url_ID, 8))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 4:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_TransportAddress(dd, &(val)->u.transportID))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 5:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU32Val(dd, 16, &l))
	    return 0;
	l += 1;
	if (!ASN1PERDecZeroCharStringNoAlloc(dd, l, (val)->u.email_ID, 8))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 6:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_PartyNumber(dd, &(val)->u.partyNumber))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AliasAddress(AliasAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    break;
	case 2:
	    ASN1char16string_free(&(val)->u.h323_ID);
	    break;
	case 3:
	    break;
	case 4:
	    ASN1Free_TransportAddress(&(val)->u.transportID);
	    break;
	case 5:
	    break;
	case 6:
	    ASN1Free_PartyNumber(&(val)->u.partyNumber);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EndpointAddress_destinationAddress(ASN1encoding_t enc, PEndpointAddress_destinationAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EndpointAddress_destinationAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_EndpointAddress_destinationAddress_ElmFn(ASN1encoding_t enc, PEndpointAddress_destinationAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EndpointAddress_destinationAddress(ASN1decoding_t dec, PEndpointAddress_destinationAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EndpointAddress_destinationAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_EndpointAddress_destinationAddress_ElmFn(ASN1decoding_t dec, PEndpointAddress_destinationAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EndpointAddress_destinationAddress(PEndpointAddress_destinationAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EndpointAddress_destinationAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EndpointAddress_destinationAddress_ElmFn(PEndpointAddress_destinationAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AddressInformation(ASN1encoding_t enc, AddressInformation *val)
{
    if (!ASN1Enc_AliasAddress(enc, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AddressInformation(ASN1decoding_t dec, AddressInformation *val)
{
    if (!ASN1Dec_AliasAddress(dec, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AddressInformation(AddressInformation *val)
{
    if (val) {
	ASN1Free_AliasAddress(val);
    }
}

static int ASN1CALL ASN1Enc_EndpointAddress(ASN1encoding_t enc, EndpointAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_EndpointAddress_destinationAddress(enc, &(val)->destinationAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_AliasAddress(enc, &(val)->remoteExtensionAddress))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EndpointAddress(ASN1decoding_t dec, EndpointAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_EndpointAddress_destinationAddress(dec, &(val)->destinationAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_AliasAddress(dec, &(val)->remoteExtensionAddress))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EndpointAddress(EndpointAddress *val)
{
    if (val) {
	ASN1Free_EndpointAddress_destinationAddress(&(val)->destinationAddress);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_AliasAddress(&(val)->remoteExtensionAddress);
	}
    }
}

static int ASN1CALL ASN1Enc_NetworkFacilityExtension(ASN1encoding_t enc, NetworkFacilityExtension *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_EntityType(enc, &(val)->sourceEntity))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_AddressInformation(enc, &(val)->sourceEntityAddress))
	    return 0;
    }
    if (!ASN1Enc_EntityType(enc, &(val)->destinationEntity))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_AddressInformation(enc, &(val)->destinationEntityAddress))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkFacilityExtension(ASN1decoding_t dec, NetworkFacilityExtension *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_EntityType(dec, &(val)->sourceEntity))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_AddressInformation(dec, &(val)->sourceEntityAddress))
	    return 0;
    }
    if (!ASN1Dec_EntityType(dec, &(val)->destinationEntity))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_AddressInformation(dec, &(val)->destinationEntityAddress))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NetworkFacilityExtension(NetworkFacilityExtension *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_AddressInformation(&(val)->sourceEntityAddress);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_AddressInformation(&(val)->destinationEntityAddress);
	}
    }
}

static int ASN1CALL ASN1Enc_ActivateDiversionQArgument(ASN1encoding_t enc, ActivateDiversionQArgument *val)
{
    ASN1uint32_t u;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->procedure))
	return 0;
    switch ((val)->basicService) {
    case 0:
	u = 0;
	break;
    case 1:
	u = 1;
	break;
    case 2:
	u = 2;
	break;
    case 3:
	u = 3;
	break;
    case 32:
	u = 4;
	break;
    case 33:
	u = 5;
	break;
    case 34:
	u = 6;
	break;
    case 35:
	u = 7;
	break;
    case 36:
	u = 8;
	break;
    }
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, u))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->divertedToAddress))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->servedUserNr))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->activatingUserNr))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ActivateDiversionQArgument_extension(enc, &(val)->extension))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ActivateDiversionQArgument(ASN1decoding_t dec, ActivateDiversionQArgument *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    ASN1uint32_t u;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, &(val)->procedure))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 4, &u))
	    return 0;
	switch (u) {
	case 0:
	    (val)->basicService = 0;
	    break;
	case 1:
	    (val)->basicService = 1;
	    break;
	case 2:
	    (val)->basicService = 2;
	    break;
	case 3:
	    (val)->basicService = 3;
	    break;
	case 4:
	    (val)->basicService = 32;
	    break;
	case 5:
	    (val)->basicService = 33;
	    break;
	case 6:
	    (val)->basicService = 34;
	    break;
	case 7:
	    (val)->basicService = 35;
	    break;
	case 8:
	    (val)->basicService = 36;
	    break;
	}
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->divertedToAddress))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->servedUserNr))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->activatingUserNr))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ActivateDiversionQArgument_extension(dec, &(val)->extension))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ActivateDiversionQArgument(ActivateDiversionQArgument *val)
{
    if (val) {
	ASN1Free_EndpointAddress(&(val)->divertedToAddress);
	ASN1Free_EndpointAddress(&(val)->servedUserNr);
	ASN1Free_EndpointAddress(&(val)->activatingUserNr);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ActivateDiversionQArgument_extension(&(val)->extension);
	}
    }
}

static int ASN1CALL ASN1Enc_DeactivateDiversionQArgument(ASN1encoding_t enc, DeactivateDiversionQArgument *val)
{
    ASN1uint32_t u;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->procedure))
	return 0;
    switch ((val)->basicService) {
    case 0:
	u = 0;
	break;
    case 1:
	u = 1;
	break;
    case 2:
	u = 2;
	break;
    case 3:
	u = 3;
	break;
    case 32:
	u = 4;
	break;
    case 33:
	u = 5;
	break;
    case 34:
	u = 6;
	break;
    case 35:
	u = 7;
	break;
    case 36:
	u = 8;
	break;
    }
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, u))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->servedUserNr))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->deactivatingUserNr))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_DeactivateDiversionQArgument_extension(enc, &(val)->extension))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DeactivateDiversionQArgument(ASN1decoding_t dec, DeactivateDiversionQArgument *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    ASN1uint32_t u;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, &(val)->procedure))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 4, &u))
	    return 0;
	switch (u) {
	case 0:
	    (val)->basicService = 0;
	    break;
	case 1:
	    (val)->basicService = 1;
	    break;
	case 2:
	    (val)->basicService = 2;
	    break;
	case 3:
	    (val)->basicService = 3;
	    break;
	case 4:
	    (val)->basicService = 32;
	    break;
	case 5:
	    (val)->basicService = 33;
	    break;
	case 6:
	    (val)->basicService = 34;
	    break;
	case 7:
	    (val)->basicService = 35;
	    break;
	case 8:
	    (val)->basicService = 36;
	    break;
	}
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->servedUserNr))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->deactivatingUserNr))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_DeactivateDiversionQArgument_extension(dec, &(val)->extension))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DeactivateDiversionQArgument(DeactivateDiversionQArgument *val)
{
    if (val) {
	ASN1Free_EndpointAddress(&(val)->servedUserNr);
	ASN1Free_EndpointAddress(&(val)->deactivatingUserNr);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_DeactivateDiversionQArgument_extension(&(val)->extension);
	}
    }
}

static int ASN1CALL ASN1Enc_InterrogateDiversionQArgument(ASN1encoding_t enc, InterrogateDiversionQArgument *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t u;
    CopyMemory(o, (val)->o, 1);
    if ((val)->basicService == 0)
	o[0] &= ~0x80;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, o))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->procedure))
	return 0;
    if (o[0] & 0x80) {
	switch ((val)->basicService) {
	case 0:
	    u = 0;
	    break;
	case 1:
	    u = 1;
	    break;
	case 2:
	    u = 2;
	    break;
	case 3:
	    u = 3;
	    break;
	case 32:
	    u = 4;
	    break;
	case 33:
	    u = 5;
	    break;
	case 34:
	    u = 6;
	    break;
	case 35:
	    u = 7;
	    break;
	case 36:
	    u = 8;
	    break;
	}
	if (!ASN1PEREncExtensionBitClear(enc))
	    return 0;
	if (!ASN1PEREncBitVal(enc, 4, u))
	    return 0;
    }
    if (!ASN1Enc_EndpointAddress(enc, &(val)->servedUserNr))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->interrogatingUserNr))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1Enc_InterrogateDiversionQArgument_extension(enc, &(val)->extension))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InterrogateDiversionQArgument(ASN1decoding_t dec, InterrogateDiversionQArgument *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    ASN1uint32_t u;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, &(val)->procedure))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecExtensionBit(dec, &x))
	    return 0;
	if (!x) {
	    if (!ASN1PERDecU32Val(dec, 4, &u))
		return 0;
	    switch (u) {
	    case 0:
		(val)->basicService = 0;
		break;
	    case 1:
		(val)->basicService = 1;
		break;
	    case 2:
		(val)->basicService = 2;
		break;
	    case 3:
		(val)->basicService = 3;
		break;
	    case 4:
		(val)->basicService = 32;
		break;
	    case 5:
		(val)->basicService = 33;
		break;
	    case 6:
		(val)->basicService = 34;
		break;
	    case 7:
		(val)->basicService = 35;
		break;
	    case 8:
		(val)->basicService = 36;
		break;
	    }
	} else {
	    if (!ASN1PERDecSkipNormallySmall(dec))
		return 0;
	}
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->servedUserNr))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->interrogatingUserNr))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_InterrogateDiversionQArgument_extension(dec, &(val)->extension))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    if (!((val)->o[0] & 0x80))
	(val)->basicService = 0;
    return 1;
}

static void ASN1CALL ASN1Free_InterrogateDiversionQArgument(InterrogateDiversionQArgument *val)
{
    if (val) {
	ASN1Free_EndpointAddress(&(val)->servedUserNr);
	ASN1Free_EndpointAddress(&(val)->interrogatingUserNr);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_InterrogateDiversionQArgument_extension(&(val)->extension);
	}
    }
}

static int ASN1CALL ASN1Enc_CheckRestrictionArgument(ASN1encoding_t enc, CheckRestrictionArgument *val)
{
    ASN1uint32_t u;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->servedUserNr))
	return 0;
    switch ((val)->basicService) {
    case 0:
	u = 0;
	break;
    case 1:
	u = 1;
	break;
    case 2:
	u = 2;
	break;
    case 3:
	u = 3;
	break;
    case 32:
	u = 4;
	break;
    case 33:
	u = 5;
	break;
    case 34:
	u = 6;
	break;
    case 35:
	u = 7;
	break;
    case 36:
	u = 8;
	break;
    }
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, u))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->divertedToNr))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CheckRestrictionArgument_extension(enc, &(val)->extension))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CheckRestrictionArgument(ASN1decoding_t dec, CheckRestrictionArgument *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    ASN1uint32_t u;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->servedUserNr))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 4, &u))
	    return 0;
	switch (u) {
	case 0:
	    (val)->basicService = 0;
	    break;
	case 1:
	    (val)->basicService = 1;
	    break;
	case 2:
	    (val)->basicService = 2;
	    break;
	case 3:
	    (val)->basicService = 3;
	    break;
	case 4:
	    (val)->basicService = 32;
	    break;
	case 5:
	    (val)->basicService = 33;
	    break;
	case 6:
	    (val)->basicService = 34;
	    break;
	case 7:
	    (val)->basicService = 35;
	    break;
	case 8:
	    (val)->basicService = 36;
	    break;
	}
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->divertedToNr))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CheckRestrictionArgument_extension(dec, &(val)->extension))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CheckRestrictionArgument(CheckRestrictionArgument *val)
{
    if (val) {
	ASN1Free_EndpointAddress(&(val)->servedUserNr);
	ASN1Free_EndpointAddress(&(val)->divertedToNr);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CheckRestrictionArgument_extension(&(val)->extension);
	}
    }
}

static int ASN1CALL ASN1Enc_CallReroutingArgument(ASN1encoding_t enc, CallReroutingArgument *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 7, (val)->o))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->reroutingReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncExtensionBitClear(enc))
	    return 0;
	if (!ASN1PEREncBitVal(enc, 2, (val)->originalReroutingReason))
	    return 0;
    }
    if (!ASN1Enc_EndpointAddress(enc, &(val)->calledAddress))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->diversionCounter - 1))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->h225InfoElement))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->lastReroutingNr))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->subscriptionOption))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_PartySubaddress(enc, &(val)->callingPartySubaddress))
	    return 0;
    }
    if (!ASN1Enc_EndpointAddress(enc, &(val)->callingNumber))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->callingInfo).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->callingInfo).length, ((val)->callingInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_EndpointAddress(enc, &(val)->originalCalledNr))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->redirectingInfo).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->redirectingInfo).length, ((val)->redirectingInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->originalCalledInfo).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->originalCalledInfo).length, ((val)->originalCalledInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Enc_CallReroutingArgument_extension(enc, &(val)->extension))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CallReroutingArgument(ASN1decoding_t dec, CallReroutingArgument *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, &(val)->reroutingReason))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecExtensionBit(dec, &x))
	    return 0;
	if (!x) {
	    if (!ASN1PERDecU32Val(dec, 2, &(val)->originalReroutingReason))
		return 0;
	} else {
	    if (!ASN1PERDecSkipNormallySmall(dec))
		return 0;
	}
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->calledAddress))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->diversionCounter))
	return 0;
    (val)->diversionCounter += 1;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->h225InfoElement))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->lastReroutingNr))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, &(val)->subscriptionOption))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_PartySubaddress(dec, &(val)->callingPartySubaddress))
	    return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->callingNumber))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->callingInfo).length))
	    return 0;
	((val)->callingInfo).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->callingInfo).length, &((val)->callingInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_EndpointAddress(dec, &(val)->originalCalledNr))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->redirectingInfo).length))
	    return 0;
	((val)->redirectingInfo).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->redirectingInfo).length, &((val)->redirectingInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->originalCalledInfo).length))
	    return 0;
	((val)->originalCalledInfo).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->originalCalledInfo).length, &((val)->originalCalledInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Dec_CallReroutingArgument_extension(dec, &(val)->extension))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CallReroutingArgument(CallReroutingArgument *val)
{
    if (val) {
	ASN1Free_EndpointAddress(&(val)->calledAddress);
	ASN1octetstring_free(&(val)->h225InfoElement);
	ASN1Free_EndpointAddress(&(val)->lastReroutingNr);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_PartySubaddress(&(val)->callingPartySubaddress);
	}
	ASN1Free_EndpointAddress(&(val)->callingNumber);
	if ((val)->o[0] & 0x20) {
	    ASN1char16string_free(&(val)->callingInfo);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_EndpointAddress(&(val)->originalCalledNr);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1char16string_free(&(val)->redirectingInfo);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1char16string_free(&(val)->originalCalledInfo);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1Free_CallReroutingArgument_extension(&(val)->extension);
	}
    }
}

static int ASN1CALL ASN1Enc_DivertingLegInformation1Argument(ASN1encoding_t enc, DivertingLegInformation1Argument *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->diversionReason))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->subscriptionOption))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->nominatedNr))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->nominatedInfo).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->nominatedInfo).length, ((val)->nominatedInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_EndpointAddress(enc, &(val)->redirectingNr))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->redirectingInfo).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->redirectingInfo).length, ((val)->redirectingInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_DivertingLegInformation1Argument_extension(enc, &(val)->extension))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DivertingLegInformation1Argument(ASN1decoding_t dec, DivertingLegInformation1Argument *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, &(val)->diversionReason))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, &(val)->subscriptionOption))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->nominatedNr))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->nominatedInfo).length))
	    return 0;
	((val)->nominatedInfo).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->nominatedInfo).length, &((val)->nominatedInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_EndpointAddress(dec, &(val)->redirectingNr))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->redirectingInfo).length))
	    return 0;
	((val)->redirectingInfo).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->redirectingInfo).length, &((val)->redirectingInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_DivertingLegInformation1Argument_extension(dec, &(val)->extension))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DivertingLegInformation1Argument(DivertingLegInformation1Argument *val)
{
    if (val) {
	ASN1Free_EndpointAddress(&(val)->nominatedNr);
	if ((val)->o[0] & 0x80) {
	    ASN1char16string_free(&(val)->nominatedInfo);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_EndpointAddress(&(val)->redirectingNr);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1char16string_free(&(val)->redirectingInfo);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_DivertingLegInformation1Argument_extension(&(val)->extension);
	}
    }
}

static int ASN1CALL ASN1Enc_DivertingLegInformation2Argument(ASN1encoding_t enc, DivertingLegInformation2Argument *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->diversionCounter - 1))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->diversionReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncExtensionBitClear(enc))
	    return 0;
	if (!ASN1PEREncBitVal(enc, 2, (val)->originalDiversionReason))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_EndpointAddress(enc, &(val)->divertingNr))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_EndpointAddress(enc, &(val)->originalCalledNr))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->redirectingInfo).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->redirectingInfo).length, ((val)->redirectingInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->originalCalledInfo).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->originalCalledInfo).length, ((val)->originalCalledInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_DivertingLegInformation2Argument_extension(enc, &(val)->extension))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DivertingLegInformation2Argument(ASN1decoding_t dec, DivertingLegInformation2Argument *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->diversionCounter))
	return 0;
    (val)->diversionCounter += 1;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, &(val)->diversionReason))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecExtensionBit(dec, &x))
	    return 0;
	if (!x) {
	    if (!ASN1PERDecU32Val(dec, 2, &(val)->originalDiversionReason))
		return 0;
	} else {
	    if (!ASN1PERDecSkipNormallySmall(dec))
		return 0;
	}
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_EndpointAddress(dec, &(val)->divertingNr))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_EndpointAddress(dec, &(val)->originalCalledNr))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->redirectingInfo).length))
	    return 0;
	((val)->redirectingInfo).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->redirectingInfo).length, &((val)->redirectingInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->originalCalledInfo).length))
	    return 0;
	((val)->originalCalledInfo).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->originalCalledInfo).length, &((val)->originalCalledInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_DivertingLegInformation2Argument_extension(dec, &(val)->extension))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DivertingLegInformation2Argument(DivertingLegInformation2Argument *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_EndpointAddress(&(val)->divertingNr);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_EndpointAddress(&(val)->originalCalledNr);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1char16string_free(&(val)->redirectingInfo);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1char16string_free(&(val)->originalCalledInfo);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_DivertingLegInformation2Argument_extension(&(val)->extension);
	}
    }
}

static int ASN1CALL ASN1Enc_DivertingLegInformation3Argument(ASN1encoding_t enc, DivertingLegInformation3Argument *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->presentationAllowedIndicator))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_EndpointAddress(enc, &(val)->redirectionNr))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->redirectionInfo).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->redirectionInfo).length, ((val)->redirectionInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_DivertingLegInformation3Argument_extension(enc, &(val)->extension))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DivertingLegInformation3Argument(ASN1decoding_t dec, DivertingLegInformation3Argument *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->presentationAllowedIndicator))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_EndpointAddress(dec, &(val)->redirectionNr))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->redirectionInfo).length))
	    return 0;
	((val)->redirectionInfo).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->redirectionInfo).length, &((val)->redirectionInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_DivertingLegInformation3Argument_extension(dec, &(val)->extension))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DivertingLegInformation3Argument(DivertingLegInformation3Argument *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_EndpointAddress(&(val)->redirectionNr);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->redirectionInfo);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_DivertingLegInformation3Argument_extension(&(val)->extension);
	}
    }
}

static int ASN1CALL ASN1Enc_DivertingLegInformation4Argument(ASN1encoding_t enc, DivertingLegInformation4Argument *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->diversionReason))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->subscriptionOption))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->callingNr))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->callingInfo).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->callingInfo).length, ((val)->callingInfo).value, 16))
	    return 0;
    }
    if (!ASN1Enc_EndpointAddress(enc, &(val)->nominatedNr))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->nominatedInfo).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->nominatedInfo).length, ((val)->nominatedInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_DivertingLegInformation4Argument_extension(enc, &(val)->extension))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DivertingLegInformation4Argument(ASN1decoding_t dec, DivertingLegInformation4Argument *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, &(val)->diversionReason))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, &(val)->subscriptionOption))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->callingNr))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->callingInfo).length))
	    return 0;
	((val)->callingInfo).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->callingInfo).length, &((val)->callingInfo).value, 16))
	    return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->nominatedNr))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->nominatedInfo).length))
	    return 0;
	((val)->nominatedInfo).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->nominatedInfo).length, &((val)->nominatedInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_DivertingLegInformation4Argument_extension(dec, &(val)->extension))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DivertingLegInformation4Argument(DivertingLegInformation4Argument *val)
{
    if (val) {
	ASN1Free_EndpointAddress(&(val)->callingNr);
	if ((val)->o[0] & 0x80) {
	    ASN1char16string_free(&(val)->callingInfo);
	}
	ASN1Free_EndpointAddress(&(val)->nominatedNr);
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->nominatedInfo);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_DivertingLegInformation4Argument_extension(&(val)->extension);
	}
    }
}

static int ASN1CALL ASN1Enc_IntResult(ASN1encoding_t enc, IntResult *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t u;
    CopyMemory(o, (val)->o, 1);
    if (!(val)->remoteEnabled)
	o[0] &= ~0x80;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, o))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->servedUserNr))
	return 0;
    switch ((val)->basicService) {
    case 0:
	u = 0;
	break;
    case 1:
	u = 1;
	break;
    case 2:
	u = 2;
	break;
    case 3:
	u = 3;
	break;
    case 32:
	u = 4;
	break;
    case 33:
	u = 5;
	break;
    case 34:
	u = 6;
	break;
    case 35:
	u = 7;
	break;
    case 36:
	u = 8;
	break;
    }
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, u))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->procedure))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->divertedToAddress))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1PEREncBoolean(enc, (val)->remoteEnabled))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1Enc_IntResult_extension(enc, &(val)->extension))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IntResult(ASN1decoding_t dec, IntResult *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    ASN1uint32_t u;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->servedUserNr))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 4, &u))
	    return 0;
	switch (u) {
	case 0:
	    (val)->basicService = 0;
	    break;
	case 1:
	    (val)->basicService = 1;
	    break;
	case 2:
	    (val)->basicService = 2;
	    break;
	case 3:
	    (val)->basicService = 3;
	    break;
	case 4:
	    (val)->basicService = 32;
	    break;
	case 5:
	    (val)->basicService = 33;
	    break;
	case 6:
	    (val)->basicService = 34;
	    break;
	case 7:
	    (val)->basicService = 35;
	    break;
	case 8:
	    (val)->basicService = 36;
	    break;
	}
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, &(val)->procedure))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->divertedToAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecBoolean(dec, &(val)->remoteEnabled))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_IntResult_extension(dec, &(val)->extension))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    if (!((val)->o[0] & 0x80))
	(val)->remoteEnabled = 0;
    return 1;
}

static void ASN1CALL ASN1Free_IntResult(IntResult *val)
{
    if (val) {
	ASN1Free_EndpointAddress(&(val)->servedUserNr);
	ASN1Free_EndpointAddress(&(val)->divertedToAddress);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_IntResult_extension(&(val)->extension);
	}
    }
}

static ASN1stringtableentry_t CTInitiateArg_callIdentity_StringTableEntries[] = {
    { 32, 32, 0 }, { 48, 57, 1 }, 
};

static ASN1stringtable_t CTInitiateArg_callIdentity_StringTable = {
    2, CTInitiateArg_callIdentity_StringTableEntries
};

static int ASN1CALL ASN1Enc_CTInitiateArg(ASN1encoding_t enc, CTInitiateArg *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    t = lstrlenA((val)->callIdentity);
    if (!ASN1PEREncBitVal(enc, 3, t))
	return 0;
    //nik
    if (t!=0) ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->callIdentity, 4, &CTInitiateArg_callIdentity_StringTable))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->reroutingNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CTInitiateArg_argumentExtension(enc, &(val)->argumentExtension))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTInitiateArg(ASN1decoding_t dec, CTInitiateArg *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 3, &l))
	return 0;
    //nik
    if (l!=0) ASN1PERDecAlignment(dec);
    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->callIdentity, 4, &CTInitiateArg_callIdentity_StringTable))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->reroutingNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CTInitiateArg_argumentExtension(dec, &(val)->argumentExtension))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTInitiateArg(CTInitiateArg *val)
{
    if (val) {
	ASN1Free_EndpointAddress(&(val)->reroutingNumber);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CTInitiateArg_argumentExtension(&(val)->argumentExtension);
	}
    }
}

static ASN1stringtableentry_t CTSetupArg_callIdentity_StringTableEntries[] = {
    { 32, 32, 0 }, { 48, 57, 1 }, 
};

static ASN1stringtable_t CTSetupArg_callIdentity_StringTable = {
    2, CTSetupArg_callIdentity_StringTableEntries
};

static int ASN1CALL ASN1Enc_CTSetupArg(ASN1encoding_t enc, CTSetupArg *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    t = lstrlenA((val)->callIdentity);
    if (!ASN1PEREncBitVal(enc, 3, t))
	return 0;
    //nik
    if (t!=0) ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->callIdentity, 4, &CTSetupArg_callIdentity_StringTable))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_EndpointAddress(enc, &(val)->transferringNumber))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CTSetupArg_argumentExtension(enc, &(val)->argumentExtension))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTSetupArg(ASN1decoding_t dec, CTSetupArg *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 3, &l))
	return 0;
    //nik
    if (l!=0) ASN1PERDecAlignment(dec);
    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->callIdentity, 4, &CTSetupArg_callIdentity_StringTable))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_EndpointAddress(dec, &(val)->transferringNumber))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_CTSetupArg_argumentExtension(dec, &(val)->argumentExtension))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTSetupArg(CTSetupArg *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_EndpointAddress(&(val)->transferringNumber);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CTSetupArg_argumentExtension(&(val)->argumentExtension);
	}
    }
}

static ASN1stringtableentry_t CTIdentifyRes_callIdentity_StringTableEntries[] = {
    { 32, 32, 0 }, { 48, 57, 1 }, 
};

static ASN1stringtable_t CTIdentifyRes_callIdentity_StringTable = {
    2, CTIdentifyRes_callIdentity_StringTableEntries
};

static int ASN1CALL ASN1Enc_CTIdentifyRes(ASN1encoding_t enc, CTIdentifyRes *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    t = lstrlenA((val)->callIdentity);
    if (!ASN1PEREncBitVal(enc, 3, t))
	return 0;
    //nik
    if (t!=0) ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->callIdentity, 4, &CTIdentifyRes_callIdentity_StringTable))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->reroutingNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CTIdentifyRes_resultExtension(enc, &(val)->resultExtension))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTIdentifyRes(ASN1decoding_t dec, CTIdentifyRes *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 3, &l))
	return 0;
    //nik
    if (l!=0) ASN1PERDecAlignment(dec);
    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->callIdentity, 4, &CTIdentifyRes_callIdentity_StringTable))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->reroutingNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CTIdentifyRes_resultExtension(dec, &(val)->resultExtension))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTIdentifyRes(CTIdentifyRes *val)
{
    if (val) {
	ASN1Free_EndpointAddress(&(val)->reroutingNumber);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CTIdentifyRes_resultExtension(&(val)->resultExtension);
	}
    }
}

static int ASN1CALL ASN1Enc_CTUpdateArg(ASN1encoding_t enc, CTUpdateArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->redirectionNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->redirectionInfo).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->redirectionInfo).length, ((val)->redirectionInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->basicCallInfoElements))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_CTUpdateArg_argumentExtension(enc, &(val)->argumentExtension))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTUpdateArg(ASN1decoding_t dec, CTUpdateArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->redirectionNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->redirectionInfo).length))
	    return 0;
	((val)->redirectionInfo).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->redirectionInfo).length, &((val)->redirectionInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->basicCallInfoElements))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_CTUpdateArg_argumentExtension(dec, &(val)->argumentExtension))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTUpdateArg(CTUpdateArg *val)
{
    if (val) {
	ASN1Free_EndpointAddress(&(val)->redirectionNumber);
	if ((val)->o[0] & 0x80) {
	    ASN1char16string_free(&(val)->redirectionInfo);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1octetstring_free(&(val)->basicCallInfoElements);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_CTUpdateArg_argumentExtension(&(val)->argumentExtension);
	}
    }
}

static int ASN1CALL ASN1Enc_CTCompleteArg(ASN1encoding_t enc, CTCompleteArg *val)
{
    ASN1octet_t o[1];
    CopyMemory(o, (val)->o, 1);
    if ((val)->callStatus == 0)
	o[0] &= ~0x20;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, o))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->endDesignation))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->redirectionNumber))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->basicCallInfoElements))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->redirectionInfo).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->redirectionInfo).length, ((val)->redirectionInfo).value, 16))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1PEREncExtensionBitClear(enc))
	    return 0;
	if (!ASN1PEREncBitVal(enc, 1, (val)->callStatus))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1Enc_CTCompleteArg_argumentExtension(enc, &(val)->argumentExtension))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTCompleteArg(ASN1decoding_t dec, CTCompleteArg *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, &(val)->endDesignation))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->redirectionNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->basicCallInfoElements))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->redirectionInfo).length))
	    return 0;
	((val)->redirectionInfo).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->redirectionInfo).length, &((val)->redirectionInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecExtensionBit(dec, &x))
	    return 0;
	if (!x) {
	    if (!ASN1PERDecU32Val(dec, 1, &(val)->callStatus))
		return 0;
	} else {
	    if (!ASN1PERDecSkipNormallySmall(dec))
		return 0;
	}
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_CTCompleteArg_argumentExtension(dec, &(val)->argumentExtension))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    if (!((val)->o[0] & 0x20))
	(val)->callStatus = 0;
    return 1;
}

static void ASN1CALL ASN1Free_CTCompleteArg(CTCompleteArg *val)
{
    if (val) {
	ASN1Free_EndpointAddress(&(val)->redirectionNumber);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->basicCallInfoElements);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->redirectionInfo);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_CTCompleteArg_argumentExtension(&(val)->argumentExtension);
	}
    }
}

static int ASN1CALL ASN1Enc_CTActiveArg(ASN1encoding_t enc, CTActiveArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->connectedAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->basicCallInfoElements))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->connectedInfo).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->connectedInfo).length, ((val)->connectedInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_CTActiveArg_argumentExtension(enc, &(val)->argumentExtension))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTActiveArg(ASN1decoding_t dec, CTActiveArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->connectedAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->basicCallInfoElements))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->connectedInfo).length))
	    return 0;
	((val)->connectedInfo).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->connectedInfo).length, &((val)->connectedInfo).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_CTActiveArg_argumentExtension(dec, &(val)->argumentExtension))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTActiveArg(CTActiveArg *val)
{
    if (val) {
	ASN1Free_EndpointAddress(&(val)->connectedAddress);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->basicCallInfoElements);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->connectedInfo);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_CTActiveArg_argumentExtension(&(val)->argumentExtension);
	}
    }
}

static int ASN1CALL ASN1Enc_CpRequestArg(ASN1encoding_t enc, CpRequestArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->parkingNumber))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->parkedNumber))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->parkedToNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->parkedToPosition))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CpRequestArg_extensionArg(enc, &(val)->extensionArg))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CpRequestArg(ASN1decoding_t dec, CpRequestArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->parkingNumber))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->parkedNumber))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->parkedToNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->parkedToPosition))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_CpRequestArg_extensionArg(dec, &(val)->extensionArg))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CpRequestArg(CpRequestArg *val)
{
    if (val) {
	ASN1Free_EndpointAddress(&(val)->parkingNumber);
	ASN1Free_EndpointAddress(&(val)->parkedNumber);
	ASN1Free_EndpointAddress(&(val)->parkedToNumber);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CpRequestArg_extensionArg(&(val)->extensionArg);
	}
    }
}

static int ASN1CALL ASN1Enc_CpRequestRes(ASN1encoding_t enc, CpRequestRes *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->parkedToNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->parkedToPosition))
	    return 0;
    }
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->parkCondition))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CpRequestRes_extensionRes(enc, &(val)->extensionRes))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CpRequestRes(ASN1decoding_t dec, CpRequestRes *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->parkedToNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->parkedToPosition))
	    return 0;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, &(val)->parkCondition))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_CpRequestRes_extensionRes(dec, &(val)->extensionRes))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CpRequestRes(CpRequestRes *val)
{
    if (val) {
	ASN1Free_EndpointAddress(&(val)->parkedToNumber);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CpRequestRes_extensionRes(&(val)->extensionRes);
	}
    }
}

static int ASN1CALL ASN1Enc_CpSetupArg(ASN1encoding_t enc, CpSetupArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->parkingNumber))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->parkedNumber))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->parkedToNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->parkedToPosition))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CpSetupArg_extensionArg(enc, &(val)->extensionArg))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CpSetupArg(ASN1decoding_t dec, CpSetupArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->parkingNumber))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->parkedNumber))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->parkedToNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->parkedToPosition))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_CpSetupArg_extensionArg(dec, &(val)->extensionArg))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CpSetupArg(CpSetupArg *val)
{
    if (val) {
	ASN1Free_EndpointAddress(&(val)->parkingNumber);
	ASN1Free_EndpointAddress(&(val)->parkedNumber);
	ASN1Free_EndpointAddress(&(val)->parkedToNumber);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CpSetupArg_extensionArg(&(val)->extensionArg);
	}
    }
}

static int ASN1CALL ASN1Enc_CpSetupRes(ASN1encoding_t enc, CpSetupRes *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->parkedToNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->parkedToPosition))
	    return 0;
    }
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->parkCondition))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CpSetupRes_extensionRes(enc, &(val)->extensionRes))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CpSetupRes(ASN1decoding_t dec, CpSetupRes *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->parkedToNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->parkedToPosition))
	    return 0;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, &(val)->parkCondition))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_CpSetupRes_extensionRes(dec, &(val)->extensionRes))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CpSetupRes(CpSetupRes *val)
{
    if (val) {
	ASN1Free_EndpointAddress(&(val)->parkedToNumber);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CpSetupRes_extensionRes(&(val)->extensionRes);
	}
    }
}

static int ASN1CALL ASN1Enc_GroupIndicationOnArg(ASN1encoding_t enc, GroupIndicationOnArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_CallIdentifier(enc, &(val)->callPickupId))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->groupMemberUserNr))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->retrieveCallType))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->partyToRetrieve))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->retrieveAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->parkPosition))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_GroupIndicationOnArg_extensionArg(enc, &(val)->extensionArg))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GroupIndicationOnArg(ASN1decoding_t dec, GroupIndicationOnArg *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_CallIdentifier(dec, &(val)->callPickupId))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->groupMemberUserNr))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, &(val)->retrieveCallType))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->partyToRetrieve))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->retrieveAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->parkPosition))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_GroupIndicationOnArg_extensionArg(dec, &(val)->extensionArg))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GroupIndicationOnArg(GroupIndicationOnArg *val)
{
    if (val) {
	ASN1Free_CallIdentifier(&(val)->callPickupId);
	ASN1Free_EndpointAddress(&(val)->groupMemberUserNr);
	ASN1Free_EndpointAddress(&(val)->partyToRetrieve);
	ASN1Free_EndpointAddress(&(val)->retrieveAddress);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_GroupIndicationOnArg_extensionArg(&(val)->extensionArg);
	}
    }
}

static int ASN1CALL ASN1Enc_GroupIndicationOffArg(ASN1encoding_t enc, GroupIndicationOffArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_CallIdentifier(enc, &(val)->callPickupId))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->groupMemberUserNr))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_GroupIndicationOffArg_extensionArg(enc, &(val)->extensionArg))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GroupIndicationOffArg(ASN1decoding_t dec, GroupIndicationOffArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_CallIdentifier(dec, &(val)->callPickupId))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->groupMemberUserNr))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_GroupIndicationOffArg_extensionArg(dec, &(val)->extensionArg))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GroupIndicationOffArg(GroupIndicationOffArg *val)
{
    if (val) {
	ASN1Free_CallIdentifier(&(val)->callPickupId);
	ASN1Free_EndpointAddress(&(val)->groupMemberUserNr);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_GroupIndicationOffArg_extensionArg(&(val)->extensionArg);
	}
    }
}

static int ASN1CALL ASN1Enc_PickrequArg(ASN1encoding_t enc, PickrequArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->picking_upNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CallIdentifier(enc, &(val)->callPickupId))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_EndpointAddress(enc, &(val)->partyToRetrieve))
	    return 0;
    }
    if (!ASN1Enc_EndpointAddress(enc, &(val)->retrieveAddress))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->parkPosition))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_PickrequArg_extensionArg(enc, &(val)->extensionArg))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PickrequArg(ASN1decoding_t dec, PickrequArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->picking_upNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CallIdentifier(dec, &(val)->callPickupId))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_EndpointAddress(dec, &(val)->partyToRetrieve))
	    return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->retrieveAddress))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->parkPosition))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_PickrequArg_extensionArg(dec, &(val)->extensionArg))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PickrequArg(PickrequArg *val)
{
    if (val) {
	ASN1Free_EndpointAddress(&(val)->picking_upNumber);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callPickupId);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_EndpointAddress(&(val)->partyToRetrieve);
	}
	ASN1Free_EndpointAddress(&(val)->retrieveAddress);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PickrequArg_extensionArg(&(val)->extensionArg);
	}
    }
}

static int ASN1CALL ASN1Enc_PickupArg(ASN1encoding_t enc, PickupArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_CallIdentifier(enc, &(val)->callPickupId))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->picking_upNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_PickupArg_extensionArg(enc, &(val)->extensionArg))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PickupArg(ASN1decoding_t dec, PickupArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_CallIdentifier(dec, &(val)->callPickupId))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->picking_upNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_PickupArg_extensionArg(dec, &(val)->extensionArg))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PickupArg(PickupArg *val)
{
    if (val) {
	ASN1Free_CallIdentifier(&(val)->callPickupId);
	ASN1Free_EndpointAddress(&(val)->picking_upNumber);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_PickupArg_extensionArg(&(val)->extensionArg);
	}
    }
}

static int ASN1CALL ASN1Enc_PickExeArg(ASN1encoding_t enc, PickExeArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_CallIdentifier(enc, &(val)->callPickupId))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->picking_upNumber))
	return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->partyToRetrieve))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_PickExeArg_extensionArg(enc, &(val)->extensionArg))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PickExeArg(ASN1decoding_t dec, PickExeArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_CallIdentifier(dec, &(val)->callPickupId))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->picking_upNumber))
	return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->partyToRetrieve))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_PickExeArg_extensionArg(dec, &(val)->extensionArg))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PickExeArg(PickExeArg *val)
{
    if (val) {
	ASN1Free_CallIdentifier(&(val)->callPickupId);
	ASN1Free_EndpointAddress(&(val)->picking_upNumber);
	ASN1Free_EndpointAddress(&(val)->partyToRetrieve);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_PickExeArg_extensionArg(&(val)->extensionArg);
	}
    }
}

static int ASN1CALL ASN1Enc_CpNotifyArg(ASN1encoding_t enc, CpNotifyArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_EndpointAddress(enc, &(val)->parkingNumber))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CpNotifyArg_extensionArg(enc, &(val)->extensionArg))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CpNotifyArg(ASN1decoding_t dec, CpNotifyArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_EndpointAddress(dec, &(val)->parkingNumber))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_CpNotifyArg_extensionArg(dec, &(val)->extensionArg))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CpNotifyArg(CpNotifyArg *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_EndpointAddress(&(val)->parkingNumber);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CpNotifyArg_extensionArg(&(val)->extensionArg);
	}
    }
}

static int ASN1CALL ASN1Enc_CpickupNotifyArg(ASN1encoding_t enc, CpickupNotifyArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_EndpointAddress(enc, &(val)->picking_upNumber))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CpickupNotifyArg_extensionArg(enc, &(val)->extensionArg))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CpickupNotifyArg(ASN1decoding_t dec, CpickupNotifyArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_EndpointAddress(dec, &(val)->picking_upNumber))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_CpickupNotifyArg_extensionArg(dec, &(val)->extensionArg))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CpickupNotifyArg(CpickupNotifyArg *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_EndpointAddress(&(val)->picking_upNumber);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CpickupNotifyArg_extensionArg(&(val)->extensionArg);
	}
    }
}

static int ASN1CALL ASN1Enc_H4501SupplementaryService(ASN1encoding_t enc, H4501SupplementaryService *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NetworkFacilityExtension(enc, &(val)->networkFacilityExtension))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_InterpretationApdu(enc, &(val)->interpretationApdu))
	    return 0;
    }
    if (!ASN1Enc_ServiceApdus(enc, &(val)->serviceApdu))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H4501SupplementaryService(ASN1decoding_t dec, H4501SupplementaryService *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NetworkFacilityExtension(dec, &(val)->networkFacilityExtension))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_InterpretationApdu(dec, &(val)->interpretationApdu))
	    return 0;
    }
    if (!ASN1Dec_ServiceApdus(dec, &(val)->serviceApdu))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H4501SupplementaryService(H4501SupplementaryService *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NetworkFacilityExtension(&(val)->networkFacilityExtension);
	}
	ASN1Free_ServiceApdus(&(val)->serviceApdu);
    }
}

static int ASN1CALL ASN1Enc_IntResultList(ASN1encoding_t enc, IntResultList *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 5, (val)->count))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_IntResult(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IntResultList(ASN1decoding_t dec, IntResultList *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 5, &(val)->count))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_IntResult(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_IntResultList(IntResultList *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (val)->count; i++) {
	    ASN1Free_IntResult(&(val)->value[i]);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\asn\h225asn.c ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for H.235 Security Messages v1 (H.235) */
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for Multimedia System Control (H.245) */
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for H.323 Messages v2 (H.225) */

#include <windows.h>
#include "h225asn.h"

ASN1module_t H225ASN_Module = NULL;

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_routing(ASN1encoding_t enc, TransportAddress_ipSourceRoute_routing *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route *val);
static int ASN1CALL ASN1Enc_RTPSession_associatedSessionIds(ASN1encoding_t enc, PRTPSession_associatedSessionIds *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_preGrantedARQ(ASN1encoding_t enc, RegistrationConfirm_preGrantedARQ *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_algorithmOIDs(ASN1encoding_t enc, PGatekeeperRequest_algorithmOIDs *val);
static int ASN1CALL ASN1Enc_TransportAddress_ip6Address(ASN1encoding_t enc, TransportAddress_ip6Address *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipxAddress(ASN1encoding_t enc, TransportAddress_ipxAddress *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute(ASN1encoding_t enc, TransportAddress_ipSourceRoute *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipAddress(ASN1encoding_t enc, TransportAddress_ipAddress *val);
static int ASN1CALL ASN1Enc_Progress_UUIE_fastStart(ASN1encoding_t enc, PProgress_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_fastStart(ASN1encoding_t enc, PFacility_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_fastStart(ASN1encoding_t enc, PSetup_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_conferenceGoal(ASN1encoding_t enc, Setup_UUIE_conferenceGoal *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCRV(ASN1encoding_t enc, PSetup_UUIE_destExtraCRV *val);
static int ASN1CALL ASN1Enc_Connect_UUIE_fastStart(ASN1encoding_t enc, PConnect_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_CallProceeding_UUIE_fastStart(ASN1encoding_t enc, PCallProceeding_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_Alerting_UUIE_fastStart(ASN1encoding_t enc, PAlerting_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU_h245Control(ASN1encoding_t enc, PH323_UU_PDU_h245Control *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU_h4501SupplementaryService(ASN1encoding_t enc, PH323_UU_PDU_h4501SupplementaryService *val);
static int ASN1CALL ASN1Enc_H323_UserInformation_user_data(ASN1encoding_t enc, H323_UserInformation_user_data *val);
static int ASN1CALL ASN1Enc_H235NonStandardParameter(ASN1encoding_t enc, H235NonStandardParameter *val);
static int ASN1CALL ASN1Enc_DHset(ASN1encoding_t enc, DHset *val);
static int ASN1CALL ASN1Enc_TypedCertificate(ASN1encoding_t enc, TypedCertificate *val);
static int ASN1CALL ASN1Enc_AuthenticationMechanism(ASN1encoding_t enc, AuthenticationMechanism *val);
static int ASN1CALL ASN1Enc_ClearToken(ASN1encoding_t enc, ClearToken *val);
static int ASN1CALL ASN1Enc_Params(ASN1encoding_t enc, Params *val);
static int ASN1CALL ASN1Enc_EncodedGeneralToken(ASN1encoding_t enc, EncodedGeneralToken *val);
static int ASN1CALL ASN1Enc_PwdCertToken(ASN1encoding_t enc, PwdCertToken *val);
static int ASN1CALL ASN1Enc_EncodedPwdCertToken(ASN1encoding_t enc, EncodedPwdCertToken *val);
static int ASN1CALL ASN1Enc_ReleaseCompleteReason(ASN1encoding_t enc, ReleaseCompleteReason *val);
static int ASN1CALL ASN1Enc_FacilityReason(ASN1encoding_t enc, FacilityReason *val);
static int ASN1CALL ASN1Enc_H221NonStandard(ASN1encoding_t enc, H221NonStandard *val);
static int ASN1CALL ASN1Enc_H225NonStandardIdentifier(ASN1encoding_t enc, H225NonStandardIdentifier *val);
static int ASN1CALL ASN1Enc_PublicTypeOfNumber(ASN1encoding_t enc, PublicTypeOfNumber *val);
static int ASN1CALL ASN1Enc_PrivateTypeOfNumber(ASN1encoding_t enc, PrivateTypeOfNumber *val);
static int ASN1CALL ASN1Enc_AltGKInfo(ASN1encoding_t enc, AltGKInfo *val);
static int ASN1CALL ASN1Enc_Q954Details(ASN1encoding_t enc, Q954Details *val);
static int ASN1CALL ASN1Enc_CallIdentifier(ASN1encoding_t enc, CallIdentifier *val);
static int ASN1CALL ASN1Enc_ICV(ASN1encoding_t enc, ICV *val);
static int ASN1CALL ASN1Enc_GatekeeperRejectReason(ASN1encoding_t enc, GatekeeperRejectReason *val);
static int ASN1CALL ASN1Enc_RegistrationRejectReason(ASN1encoding_t enc, RegistrationRejectReason *val);
static int ASN1CALL ASN1Enc_UnregRequestReason(ASN1encoding_t enc, UnregRequestReason *val);
static int ASN1CALL ASN1Enc_UnregRejectReason(ASN1encoding_t enc, UnregRejectReason *val);
static int ASN1CALL ASN1Enc_CallType(ASN1encoding_t enc, CallType *val);
static int ASN1CALL ASN1Enc_CallModel(ASN1encoding_t enc, CallModel *val);
static int ASN1CALL ASN1Enc_TransportQOS(ASN1encoding_t enc, TransportQOS *val);
static int ASN1CALL ASN1Enc_UUIEsRequested(ASN1encoding_t enc, UUIEsRequested *val);
static int ASN1CALL ASN1Enc_AdmissionRejectReason(ASN1encoding_t enc, AdmissionRejectReason *val);
static int ASN1CALL ASN1Enc_BandRejectReason(ASN1encoding_t enc, BandRejectReason *val);
static int ASN1CALL ASN1Enc_LocationRejectReason(ASN1encoding_t enc, LocationRejectReason *val);
static int ASN1CALL ASN1Enc_DisengageReason(ASN1encoding_t enc, DisengageReason *val);
static int ASN1CALL ASN1Enc_DisengageRejectReason(ASN1encoding_t enc, DisengageRejectReason *val);
static int ASN1CALL ASN1Enc_InfoRequestNakReason(ASN1encoding_t enc, InfoRequestNakReason *val);
static int ASN1CALL ASN1Enc_UnknownMessageResponse(ASN1encoding_t enc, UnknownMessageResponse *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_tokens *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_tokens(ASN1encoding_t enc, PResourcesAvailableConfirm_tokens *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_tokens(ASN1encoding_t enc, PResourcesAvailableIndicate_tokens *val);
static int ASN1CALL ASN1Enc_RequestInProgress_tokens(ASN1encoding_t enc, PRequestInProgress_tokens *val);
static int ASN1CALL ASN1Enc_UnknownMessageResponse_tokens(ASN1encoding_t enc, PUnknownMessageResponse_tokens *val);
static int ASN1CALL ASN1Enc_H225NonStandardMessage_tokens(ASN1encoding_t enc, PH225NonStandardMessage_tokens *val);
static int ASN1CALL ASN1Enc_InfoRequestNak_tokens(ASN1encoding_t enc, PInfoRequestNak_tokens *val);
static int ASN1CALL ASN1Enc_InfoRequestAck_tokens(ASN1encoding_t enc, PInfoRequestAck_tokens *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_tokens(ASN1encoding_t enc, PInfoRequestResponse_tokens *val);
static int ASN1CALL ASN1Enc_InfoRequest_tokens(ASN1encoding_t enc, PInfoRequest_tokens *val);
static int ASN1CALL ASN1Enc_DisengageReject_tokens(ASN1encoding_t enc, PDisengageReject_tokens *val);
static int ASN1CALL ASN1Enc_DisengageConfirm_tokens(ASN1encoding_t enc, PDisengageConfirm_tokens *val);
static int ASN1CALL ASN1Enc_DisengageRequest_tokens(ASN1encoding_t enc, PDisengageRequest_tokens *val);
static int ASN1CALL ASN1Enc_LocationReject_tokens(ASN1encoding_t enc, PLocationReject_tokens *val);
static int ASN1CALL ASN1Enc_LocationConfirm_tokens(ASN1encoding_t enc, PLocationConfirm_tokens *val);
static int ASN1CALL ASN1Enc_LocationRequest_tokens(ASN1encoding_t enc, PLocationRequest_tokens *val);
static int ASN1CALL ASN1Enc_BandwidthReject_tokens(ASN1encoding_t enc, PBandwidthReject_tokens *val);
static int ASN1CALL ASN1Enc_BandwidthConfirm_tokens(ASN1encoding_t enc, PBandwidthConfirm_tokens *val);
static int ASN1CALL ASN1Enc_BandwidthRequest_tokens(ASN1encoding_t enc, PBandwidthRequest_tokens *val);
static int ASN1CALL ASN1Enc_AdmissionReject_tokens(ASN1encoding_t enc, PAdmissionReject_tokens *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_tokens(ASN1encoding_t enc, PAdmissionConfirm_tokens *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_tokens(ASN1encoding_t enc, PAdmissionRequest_tokens *val);
static int ASN1CALL ASN1Enc_UnregistrationReject_tokens(ASN1encoding_t enc, PUnregistrationReject_tokens *val);
static int ASN1CALL ASN1Enc_UnregistrationConfirm_tokens(ASN1encoding_t enc, PUnregistrationConfirm_tokens *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest_tokens(ASN1encoding_t enc, PUnregistrationRequest_tokens *val);
static int ASN1CALL ASN1Enc_RegistrationReject_tokens(ASN1encoding_t enc, PRegistrationReject_tokens *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_tokens(ASN1encoding_t enc, PRegistrationConfirm_tokens *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_tokens(ASN1encoding_t enc, PRegistrationRequest_tokens *val);
static int ASN1CALL ASN1Enc_GatekeeperReject_tokens(ASN1encoding_t enc, PGatekeeperReject_tokens *val);
static int ASN1CALL ASN1Enc_GatekeeperConfirm_tokens(ASN1encoding_t enc, PGatekeeperConfirm_tokens *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_authenticationCapability(ASN1encoding_t enc, PGatekeeperRequest_authenticationCapability *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_tokens(ASN1encoding_t enc, PGatekeeperRequest_tokens *val);
static int ASN1CALL ASN1Enc_Endpoint_tokens(ASN1encoding_t enc, PEndpoint_tokens *val);
static int ASN1CALL ASN1Enc_Progress_UUIE_tokens(ASN1encoding_t enc, PProgress_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_tokens(ASN1encoding_t enc, PFacility_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_tokens(ASN1encoding_t enc, PSetup_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_Connect_UUIE_tokens(ASN1encoding_t enc, PConnect_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_CallProceeding_UUIE_tokens(ASN1encoding_t enc, PCallProceeding_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_Alerting_UUIE_tokens(ASN1encoding_t enc, PAlerting_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_SIGNED_EncodedGeneralToken(ASN1encoding_t enc, SIGNED_EncodedGeneralToken *val);
static int ASN1CALL ASN1Enc_ENCRYPTED(ASN1encoding_t enc, ENCRYPTED *val);
static int ASN1CALL ASN1Enc_HASHED(ASN1encoding_t enc, HASHED *val);
static int ASN1CALL ASN1Enc_SIGNED_EncodedPwdCertToken(ASN1encoding_t enc, SIGNED_EncodedPwdCertToken *val);
static int ASN1CALL ASN1Enc_Information_UUIE(ASN1encoding_t enc, Information_UUIE *val);
static int ASN1CALL ASN1Enc_ReleaseComplete_UUIE(ASN1encoding_t enc, ReleaseComplete_UUIE *val);
static int ASN1CALL ASN1Enc_VendorIdentifier(ASN1encoding_t enc, VendorIdentifier *val);
static int ASN1CALL ASN1Enc_H225NonStandardParameter(ASN1encoding_t enc, H225NonStandardParameter *val);
static int ASN1CALL ASN1Enc_PublicPartyNumber(ASN1encoding_t enc, PublicPartyNumber *val);
static int ASN1CALL ASN1Enc_PrivatePartyNumber(ASN1encoding_t enc, PrivatePartyNumber *val);
static int ASN1CALL ASN1Enc_SecurityServiceMode(ASN1encoding_t enc, SecurityServiceMode *val);
static int ASN1CALL ASN1Enc_SecurityCapabilities(ASN1encoding_t enc, SecurityCapabilities *val);
static int ASN1CALL ASN1Enc_H245Security(ASN1encoding_t enc, H245Security *val);
static int ASN1CALL ASN1Enc_QseriesOptions(ASN1encoding_t enc, QseriesOptions *val);
static int ASN1CALL ASN1Enc_EncryptIntAlg(ASN1encoding_t enc, EncryptIntAlg *val);
static int ASN1CALL ASN1Enc_NonIsoIntegrityMechanism(ASN1encoding_t enc, NonIsoIntegrityMechanism *val);
static int ASN1CALL ASN1Enc_IntegrityMechanism(ASN1encoding_t enc, IntegrityMechanism *val);
#define ASN1Enc_FastStartToken(x,y)      0
static int ASN1CALL ASN1Enc_EncodedFastStartToken(ASN1encoding_t enc, EncodedFastStartToken *val);
static int ASN1CALL ASN1Enc_DataRate(ASN1encoding_t enc, DataRate *val);
static int ASN1CALL ASN1Enc_GatekeeperReject(ASN1encoding_t enc, GatekeeperReject *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm(ASN1encoding_t enc, RegistrationConfirm *val);
static int ASN1CALL ASN1Enc_RegistrationReject(ASN1encoding_t enc, RegistrationReject *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest(ASN1encoding_t enc, UnregistrationRequest *val);
static int ASN1CALL ASN1Enc_UnregistrationConfirm(ASN1encoding_t enc, UnregistrationConfirm *val);
static int ASN1CALL ASN1Enc_UnregistrationReject(ASN1encoding_t enc, UnregistrationReject *val);
static int ASN1CALL ASN1Enc_AdmissionReject(ASN1encoding_t enc, AdmissionReject *val);
static int ASN1CALL ASN1Enc_BandwidthRequest(ASN1encoding_t enc, BandwidthRequest *val);
static int ASN1CALL ASN1Enc_BandwidthConfirm(ASN1encoding_t enc, BandwidthConfirm *val);
static int ASN1CALL ASN1Enc_BandwidthReject(ASN1encoding_t enc, BandwidthReject *val);
static int ASN1CALL ASN1Enc_LocationReject(ASN1encoding_t enc, LocationReject *val);
static int ASN1CALL ASN1Enc_DisengageRequest(ASN1encoding_t enc, DisengageRequest *val);
static int ASN1CALL ASN1Enc_DisengageConfirm(ASN1encoding_t enc, DisengageConfirm *val);
static int ASN1CALL ASN1Enc_DisengageReject(ASN1encoding_t enc, DisengageReject *val);
static int ASN1CALL ASN1Enc_InfoRequestAck(ASN1encoding_t enc, InfoRequestAck *val);
static int ASN1CALL ASN1Enc_InfoRequestNak(ASN1encoding_t enc, InfoRequestNak *val);
static int ASN1CALL ASN1Enc_H225NonStandardMessage(ASN1encoding_t enc, H225NonStandardMessage *val);
static int ASN1CALL ASN1Enc_RequestInProgress(ASN1encoding_t enc, RequestInProgress *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate(ASN1encoding_t enc, ResourcesAvailableIndicate *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm(ASN1encoding_t enc, ResourcesAvailableConfirm *val);
static int ASN1CALL ASN1Enc_GatekeeperConfirm_integrity(ASN1encoding_t enc, PGatekeeperConfirm_integrity *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_integrity(ASN1encoding_t enc, PGatekeeperRequest_integrity *val);
static int ASN1CALL ASN1Enc_CryptoH323Token_cryptoGKPwdHash(ASN1encoding_t enc, CryptoH323Token_cryptoGKPwdHash *val);
static int ASN1CALL ASN1Enc_NonStandardProtocol_dataRatesSupported(ASN1encoding_t enc, PNonStandardProtocol_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_T120OnlyCaps_dataRatesSupported(ASN1encoding_t enc, PT120OnlyCaps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_VoiceCaps_dataRatesSupported(ASN1encoding_t enc, PVoiceCaps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H324Caps_dataRatesSupported(ASN1encoding_t enc, PH324Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H323Caps_dataRatesSupported(ASN1encoding_t enc, PH323Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H322Caps_dataRatesSupported(ASN1encoding_t enc, PH322Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H321Caps_dataRatesSupported(ASN1encoding_t enc, PH321Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H320Caps_dataRatesSupported(ASN1encoding_t enc, PH320Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H310Caps_dataRatesSupported(ASN1encoding_t enc, PH310Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_h245SecurityCapability(ASN1encoding_t enc, PSetup_UUIE_h245SecurityCapability *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU_nonStandardControl(ASN1encoding_t enc, PH323_UU_PDU_nonStandardControl *val);
static int ASN1CALL ASN1Enc_CryptoToken_cryptoHashedToken(ASN1encoding_t enc, CryptoToken_cryptoHashedToken *val);
static int ASN1CALL ASN1Enc_CryptoToken_cryptoSignedToken(ASN1encoding_t enc, CryptoToken_cryptoSignedToken *val);
static int ASN1CALL ASN1Enc_CryptoToken_cryptoEncryptedToken(ASN1encoding_t enc, CryptoToken_cryptoEncryptedToken *val);
static int ASN1CALL ASN1Enc_CryptoToken(ASN1encoding_t enc, CryptoToken *val);
static int ASN1CALL ASN1Enc_SIGNED_EncodedFastStartToken(ASN1encoding_t enc, SIGNED_EncodedFastStartToken *val);
static int ASN1CALL ASN1Enc_TransportAddress(ASN1encoding_t enc, TransportAddress *val);
static int ASN1CALL ASN1Enc_GatewayInfo(ASN1encoding_t enc, GatewayInfo *val);
static int ASN1CALL ASN1Enc_H310Caps(ASN1encoding_t enc, H310Caps *val);
static int ASN1CALL ASN1Enc_H320Caps(ASN1encoding_t enc, H320Caps *val);
static int ASN1CALL ASN1Enc_H321Caps(ASN1encoding_t enc, H321Caps *val);
static int ASN1CALL ASN1Enc_H322Caps(ASN1encoding_t enc, H322Caps *val);
static int ASN1CALL ASN1Enc_H323Caps(ASN1encoding_t enc, H323Caps *val);
static int ASN1CALL ASN1Enc_H324Caps(ASN1encoding_t enc, H324Caps *val);
static int ASN1CALL ASN1Enc_VoiceCaps(ASN1encoding_t enc, VoiceCaps *val);
static int ASN1CALL ASN1Enc_T120OnlyCaps(ASN1encoding_t enc, T120OnlyCaps *val);
static int ASN1CALL ASN1Enc_NonStandardProtocol(ASN1encoding_t enc, NonStandardProtocol *val);
static int ASN1CALL ASN1Enc_McuInfo(ASN1encoding_t enc, McuInfo *val);
static int ASN1CALL ASN1Enc_TerminalInfo(ASN1encoding_t enc, TerminalInfo *val);
static int ASN1CALL ASN1Enc_GatekeeperInfo(ASN1encoding_t enc, GatekeeperInfo *val);
static int ASN1CALL ASN1Enc_PartyNumber(ASN1encoding_t enc, PartyNumber *val);
static int ASN1CALL ASN1Enc_AlternateGK(ASN1encoding_t enc, AlternateGK *val);
static int ASN1CALL ASN1Enc_GatekeeperConfirm(ASN1encoding_t enc, GatekeeperConfirm *val);
static int ASN1CALL ASN1Enc_AdmissionRequest(ASN1encoding_t enc, AdmissionRequest *val);
static int ASN1CALL ASN1Enc_LocationRequest(ASN1encoding_t enc, LocationRequest *val);
static int ASN1CALL ASN1Enc_InfoRequest(ASN1encoding_t enc, InfoRequest *val);
static int ASN1CALL ASN1Enc_TransportChannelInfo(ASN1encoding_t enc, TransportChannelInfo *val);
static int ASN1CALL ASN1Enc_RTPSession(ASN1encoding_t enc, RTPSession *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_data *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_video *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_audio *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq(ASN1encoding_t enc, InfoRequestResponse_perCallInfo_Seq *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_callSignalAddress(ASN1encoding_t enc, PInfoRequestResponse_callSignalAddress *val);
static int ASN1CALL ASN1Enc_AdmissionReject_callSignalAddress(ASN1encoding_t enc, PAdmissionReject_callSignalAddress *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest_callSignalAddress(ASN1encoding_t enc, PUnregistrationRequest_callSignalAddress *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_alternateGatekeeper(ASN1encoding_t enc, PRegistrationConfirm_alternateGatekeeper *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_callSignalAddress(ASN1encoding_t enc, PRegistrationConfirm_callSignalAddress *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_rasAddress(ASN1encoding_t enc, PRegistrationRequest_rasAddress *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_callSignalAddress(ASN1encoding_t enc, PRegistrationRequest_callSignalAddress *val);
static int ASN1CALL ASN1Enc_GatekeeperConfirm_alternateGatekeeper(ASN1encoding_t enc, PGatekeeperConfirm_alternateGatekeeper *val);
static int ASN1CALL ASN1Enc_AltGKInfo_alternateGatekeeper(ASN1encoding_t enc, PAltGKInfo_alternateGatekeeper *val);
static int ASN1CALL ASN1Enc_Endpoint_rasAddress(ASN1encoding_t enc, PEndpoint_rasAddress *val);
static int ASN1CALL ASN1Enc_Endpoint_callSignalAddress(ASN1encoding_t enc, PEndpoint_callSignalAddress *val);
static int ASN1CALL ASN1Enc_EndpointType(ASN1encoding_t enc, EndpointType *val);
static int ASN1CALL ASN1Enc_SupportedProtocols(ASN1encoding_t enc, SupportedProtocols *val);
static int ASN1CALL ASN1Enc_AliasAddress(ASN1encoding_t enc, AliasAddress *val);
static int ASN1CALL ASN1Enc_Endpoint(ASN1encoding_t enc, Endpoint *val);
static int ASN1CALL ASN1Enc_SupportedPrefix(ASN1encoding_t enc, SupportedPrefix *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest(ASN1encoding_t enc, GatekeeperRequest *val);
static int ASN1CALL ASN1Enc_RegistrationRequest(ASN1encoding_t enc, RegistrationRequest *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm(ASN1encoding_t enc, AdmissionConfirm *val);
static int ASN1CALL ASN1Enc_LocationConfirm(ASN1encoding_t enc, LocationConfirm *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse(ASN1encoding_t enc, InfoRequestResponse *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_protocols(ASN1encoding_t enc, PResourcesAvailableIndicate_protocols *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_endpointAlias(ASN1encoding_t enc, PInfoRequestResponse_endpointAlias *val);
static int ASN1CALL ASN1Enc_LocationConfirm_alternateEndpoints(ASN1encoding_t enc, PLocationConfirm_alternateEndpoints *val);
static int ASN1CALL ASN1Enc_LocationConfirm_remoteExtensionAddress(ASN1encoding_t enc, PLocationConfirm_remoteExtensionAddress *val);
static int ASN1CALL ASN1Enc_LocationConfirm_destExtraCallInfo(ASN1encoding_t enc, PLocationConfirm_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_LocationConfirm_destinationInfo(ASN1encoding_t enc, PLocationConfirm_destinationInfo *val);
static int ASN1CALL ASN1Enc_LocationRequest_sourceInfo(ASN1encoding_t enc, PLocationRequest_sourceInfo *val);
static int ASN1CALL ASN1Enc_LocationRequest_destinationInfo(ASN1encoding_t enc, PLocationRequest_destinationInfo *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_alternateEndpoints(ASN1encoding_t enc, PAdmissionConfirm_alternateEndpoints *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_remoteExtensionAddress(ASN1encoding_t enc, PAdmissionConfirm_remoteExtensionAddress *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_destExtraCallInfo(ASN1encoding_t enc, PAdmissionConfirm_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_destinationInfo(ASN1encoding_t enc, PAdmissionConfirm_destinationInfo *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_destAlternatives(ASN1encoding_t enc, PAdmissionRequest_destAlternatives *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_srcAlternatives(ASN1encoding_t enc, PAdmissionRequest_srcAlternatives *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_srcInfo(ASN1encoding_t enc, PAdmissionRequest_srcInfo *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_destExtraCallInfo(ASN1encoding_t enc, PAdmissionRequest_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_destinationInfo(ASN1encoding_t enc, PAdmissionRequest_destinationInfo *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest_alternateEndpoints(ASN1encoding_t enc, PUnregistrationRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest_endpointAlias(ASN1encoding_t enc, PUnregistrationRequest_endpointAlias *val);
static int ASN1CALL ASN1Enc_RegistrationRejectReason_duplicateAlias(ASN1encoding_t enc, PRegistrationRejectReason_duplicateAlias *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_terminalAlias(ASN1encoding_t enc, PRegistrationConfirm_terminalAlias *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_alternateEndpoints(ASN1encoding_t enc, PRegistrationRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_terminalAlias(ASN1encoding_t enc, PRegistrationRequest_terminalAlias *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_alternateEndpoints(ASN1encoding_t enc, PGatekeeperRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_endpointAlias(ASN1encoding_t enc, PGatekeeperRequest_endpointAlias *val);
static int ASN1CALL ASN1Enc_CryptoH323Token_cryptoEPPwdHash(ASN1encoding_t enc, CryptoH323Token_cryptoEPPwdHash *val);
static int ASN1CALL ASN1Enc_Endpoint_destExtraCallInfo(ASN1encoding_t enc, PEndpoint_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_Endpoint_remoteExtensionAddress(ASN1encoding_t enc, PEndpoint_remoteExtensionAddress *val);
static int ASN1CALL ASN1Enc_Endpoint_aliasAddress(ASN1encoding_t enc, PEndpoint_aliasAddress *val);
static int ASN1CALL ASN1Enc_NonStandardProtocol_supportedPrefixes(ASN1encoding_t enc, PNonStandardProtocol_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_T120OnlyCaps_supportedPrefixes(ASN1encoding_t enc, PT120OnlyCaps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_VoiceCaps_supportedPrefixes(ASN1encoding_t enc, PVoiceCaps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H324Caps_supportedPrefixes(ASN1encoding_t enc, PH324Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H323Caps_supportedPrefixes(ASN1encoding_t enc, PH323Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H322Caps_supportedPrefixes(ASN1encoding_t enc, PH322Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H321Caps_supportedPrefixes(ASN1encoding_t enc, PH321Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H320Caps_supportedPrefixes(ASN1encoding_t enc, PH320Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H310Caps_supportedPrefixes(ASN1encoding_t enc, PH310Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_GatewayInfo_protocol(ASN1encoding_t enc, PGatewayInfo_protocol *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_destExtraCallInfo(ASN1encoding_t enc, PFacility_UUIE_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_alternativeAliasAddress(ASN1encoding_t enc, PFacility_UUIE_alternativeAliasAddress *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCallInfo(ASN1encoding_t enc, PSetup_UUIE_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_destinationAddress(ASN1encoding_t enc, PSetup_UUIE_destinationAddress *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_sourceAddress(ASN1encoding_t enc, PSetup_UUIE_sourceAddress *val);
static int ASN1CALL ASN1Enc_Alerting_UUIE(ASN1encoding_t enc, Alerting_UUIE *val);
static int ASN1CALL ASN1Enc_CallProceeding_UUIE(ASN1encoding_t enc, CallProceeding_UUIE *val);
static int ASN1CALL ASN1Enc_Connect_UUIE(ASN1encoding_t enc, Connect_UUIE *val);
static int ASN1CALL ASN1Enc_Setup_UUIE(ASN1encoding_t enc, Setup_UUIE *val);
static int ASN1CALL ASN1Enc_Facility_UUIE(ASN1encoding_t enc, Facility_UUIE *val);
static int ASN1CALL ASN1Enc_ConferenceList(ASN1encoding_t enc, ConferenceList *val);
static int ASN1CALL ASN1Enc_Progress_UUIE(ASN1encoding_t enc, Progress_UUIE *val);
static int ASN1CALL ASN1Enc_CryptoH323Token(ASN1encoding_t enc, CryptoH323Token *val);
static int ASN1CALL ASN1Enc_RasMessage(ASN1encoding_t enc, RasMessage *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_cryptoTokens(ASN1encoding_t enc, PResourcesAvailableConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_cryptoTokens(ASN1encoding_t enc, PResourcesAvailableIndicate_cryptoTokens *val);
static int ASN1CALL ASN1Enc_RequestInProgress_cryptoTokens(ASN1encoding_t enc, PRequestInProgress_cryptoTokens *val);
static int ASN1CALL ASN1Enc_UnknownMessageResponse_cryptoTokens(ASN1encoding_t enc, PUnknownMessageResponse_cryptoTokens *val);
static int ASN1CALL ASN1Enc_H225NonStandardMessage_cryptoTokens(ASN1encoding_t enc, PH225NonStandardMessage_cryptoTokens *val);
static int ASN1CALL ASN1Enc_InfoRequestNak_cryptoTokens(ASN1encoding_t enc, PInfoRequestNak_cryptoTokens *val);
static int ASN1CALL ASN1Enc_InfoRequestAck_cryptoTokens(ASN1encoding_t enc, PInfoRequestAck_cryptoTokens *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_cryptoTokens(ASN1encoding_t enc, PInfoRequestResponse_cryptoTokens *val);
static int ASN1CALL ASN1Enc_InfoRequest_cryptoTokens(ASN1encoding_t enc, PInfoRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_DisengageReject_cryptoTokens(ASN1encoding_t enc, PDisengageReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_DisengageConfirm_cryptoTokens(ASN1encoding_t enc, PDisengageConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_DisengageRequest_cryptoTokens(ASN1encoding_t enc, PDisengageRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_LocationReject_cryptoTokens(ASN1encoding_t enc, PLocationReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_LocationConfirm_cryptoTokens(ASN1encoding_t enc, PLocationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_LocationRequest_cryptoTokens(ASN1encoding_t enc, PLocationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_BandwidthReject_cryptoTokens(ASN1encoding_t enc, PBandwidthReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_BandwidthConfirm_cryptoTokens(ASN1encoding_t enc, PBandwidthConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_BandwidthRequest_cryptoTokens(ASN1encoding_t enc, PBandwidthRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_AdmissionReject_cryptoTokens(ASN1encoding_t enc, PAdmissionReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_cryptoTokens(ASN1encoding_t enc, PAdmissionConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_cryptoTokens(ASN1encoding_t enc, PAdmissionRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_UnregistrationReject_cryptoTokens(ASN1encoding_t enc, PUnregistrationReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_UnregistrationConfirm_cryptoTokens(ASN1encoding_t enc, PUnregistrationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest_cryptoTokens(ASN1encoding_t enc, PUnregistrationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_RegistrationReject_cryptoTokens(ASN1encoding_t enc, PRegistrationReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_cryptoTokens(ASN1encoding_t enc, PRegistrationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_cryptoTokens(ASN1encoding_t enc, PRegistrationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_GatekeeperReject_cryptoTokens(ASN1encoding_t enc, PGatekeeperReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_GatekeeperConfirm_cryptoTokens(ASN1encoding_t enc, PGatekeeperConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_cryptoTokens(ASN1encoding_t enc, PGatekeeperRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Endpoint_cryptoTokens(ASN1encoding_t enc, PEndpoint_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Progress_UUIE_cryptoTokens(ASN1encoding_t enc, PProgress_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_conferences(ASN1encoding_t enc, PFacility_UUIE_conferences *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_cryptoTokens(ASN1encoding_t enc, PFacility_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_cryptoTokens(ASN1encoding_t enc, PSetup_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Connect_UUIE_cryptoTokens(ASN1encoding_t enc, PConnect_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_CallProceeding_UUIE_cryptoTokens(ASN1encoding_t enc, PCallProceeding_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Alerting_UUIE_cryptoTokens(ASN1encoding_t enc, PAlerting_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU_h323_message_body(ASN1encoding_t enc, H323_UU_PDU_h323_message_body *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU(ASN1encoding_t enc, H323_UU_PDU *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(ASN1encoding_t enc, InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_pdu *val);
static int ASN1CALL ASN1Enc_H323_UserInformation(ASN1encoding_t enc, H323_UserInformation *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_routing(ASN1decoding_t dec, TransportAddress_ipSourceRoute_routing *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route *val);
static int ASN1CALL ASN1Dec_RTPSession_associatedSessionIds(ASN1decoding_t dec, PRTPSession_associatedSessionIds *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_preGrantedARQ(ASN1decoding_t dec, RegistrationConfirm_preGrantedARQ *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_algorithmOIDs(ASN1decoding_t dec, PGatekeeperRequest_algorithmOIDs *val);
static int ASN1CALL ASN1Dec_TransportAddress_ip6Address(ASN1decoding_t dec, TransportAddress_ip6Address *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipxAddress(ASN1decoding_t dec, TransportAddress_ipxAddress *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute(ASN1decoding_t dec, TransportAddress_ipSourceRoute *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipAddress(ASN1decoding_t dec, TransportAddress_ipAddress *val);
static int ASN1CALL ASN1Dec_Progress_UUIE_fastStart(ASN1decoding_t dec, PProgress_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_fastStart(ASN1decoding_t dec, PFacility_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_fastStart(ASN1decoding_t dec, PSetup_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_conferenceGoal(ASN1decoding_t dec, Setup_UUIE_conferenceGoal *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCRV(ASN1decoding_t dec, PSetup_UUIE_destExtraCRV *val);
static int ASN1CALL ASN1Dec_Connect_UUIE_fastStart(ASN1decoding_t dec, PConnect_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_CallProceeding_UUIE_fastStart(ASN1decoding_t dec, PCallProceeding_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_Alerting_UUIE_fastStart(ASN1decoding_t dec, PAlerting_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU_h245Control(ASN1decoding_t dec, PH323_UU_PDU_h245Control *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU_h4501SupplementaryService(ASN1decoding_t dec, PH323_UU_PDU_h4501SupplementaryService *val);
static int ASN1CALL ASN1Dec_H323_UserInformation_user_data(ASN1decoding_t dec, H323_UserInformation_user_data *val);
static int ASN1CALL ASN1Dec_H235NonStandardParameter(ASN1decoding_t dec, H235NonStandardParameter *val);
static int ASN1CALL ASN1Dec_DHset(ASN1decoding_t dec, DHset *val);
static int ASN1CALL ASN1Dec_TypedCertificate(ASN1decoding_t dec, TypedCertificate *val);
static int ASN1CALL ASN1Dec_AuthenticationMechanism(ASN1decoding_t dec, AuthenticationMechanism *val);
static int ASN1CALL ASN1Dec_ClearToken(ASN1decoding_t dec, ClearToken *val);
static int ASN1CALL ASN1Dec_Params(ASN1decoding_t dec, Params *val);
static int ASN1CALL ASN1Dec_EncodedGeneralToken(ASN1decoding_t dec, EncodedGeneralToken *val);
static int ASN1CALL ASN1Dec_PwdCertToken(ASN1decoding_t dec, PwdCertToken *val);
static int ASN1CALL ASN1Dec_EncodedPwdCertToken(ASN1decoding_t dec, EncodedPwdCertToken *val);
static int ASN1CALL ASN1Dec_ReleaseCompleteReason(ASN1decoding_t dec, ReleaseCompleteReason *val);
static int ASN1CALL ASN1Dec_FacilityReason(ASN1decoding_t dec, FacilityReason *val);
static int ASN1CALL ASN1Dec_H221NonStandard(ASN1decoding_t dec, H221NonStandard *val);
static int ASN1CALL ASN1Dec_H225NonStandardIdentifier(ASN1decoding_t dec, H225NonStandardIdentifier *val);
static int ASN1CALL ASN1Dec_PublicTypeOfNumber(ASN1decoding_t dec, PublicTypeOfNumber *val);
static int ASN1CALL ASN1Dec_PrivateTypeOfNumber(ASN1decoding_t dec, PrivateTypeOfNumber *val);
static int ASN1CALL ASN1Dec_AltGKInfo(ASN1decoding_t dec, AltGKInfo *val);
static int ASN1CALL ASN1Dec_Q954Details(ASN1decoding_t dec, Q954Details *val);
static int ASN1CALL ASN1Dec_CallIdentifier(ASN1decoding_t dec, CallIdentifier *val);
static int ASN1CALL ASN1Dec_ICV(ASN1decoding_t dec, ICV *val);
static int ASN1CALL ASN1Dec_GatekeeperRejectReason(ASN1decoding_t dec, GatekeeperRejectReason *val);
static int ASN1CALL ASN1Dec_RegistrationRejectReason(ASN1decoding_t dec, RegistrationRejectReason *val);
static int ASN1CALL ASN1Dec_UnregRequestReason(ASN1decoding_t dec, UnregRequestReason *val);
static int ASN1CALL ASN1Dec_UnregRejectReason(ASN1decoding_t dec, UnregRejectReason *val);
static int ASN1CALL ASN1Dec_CallType(ASN1decoding_t dec, CallType *val);
static int ASN1CALL ASN1Dec_CallModel(ASN1decoding_t dec, CallModel *val);
static int ASN1CALL ASN1Dec_TransportQOS(ASN1decoding_t dec, TransportQOS *val);
static int ASN1CALL ASN1Dec_UUIEsRequested(ASN1decoding_t dec, UUIEsRequested *val);
static int ASN1CALL ASN1Dec_AdmissionRejectReason(ASN1decoding_t dec, AdmissionRejectReason *val);
static int ASN1CALL ASN1Dec_BandRejectReason(ASN1decoding_t dec, BandRejectReason *val);
static int ASN1CALL ASN1Dec_LocationRejectReason(ASN1decoding_t dec, LocationRejectReason *val);
static int ASN1CALL ASN1Dec_DisengageReason(ASN1decoding_t dec, DisengageReason *val);
static int ASN1CALL ASN1Dec_DisengageRejectReason(ASN1decoding_t dec, DisengageRejectReason *val);
static int ASN1CALL ASN1Dec_InfoRequestNakReason(ASN1decoding_t dec, InfoRequestNakReason *val);
static int ASN1CALL ASN1Dec_UnknownMessageResponse(ASN1decoding_t dec, UnknownMessageResponse *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_tokens *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_tokens(ASN1decoding_t dec, PResourcesAvailableConfirm_tokens *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_tokens(ASN1decoding_t dec, PResourcesAvailableIndicate_tokens *val);
static int ASN1CALL ASN1Dec_RequestInProgress_tokens(ASN1decoding_t dec, PRequestInProgress_tokens *val);
static int ASN1CALL ASN1Dec_UnknownMessageResponse_tokens(ASN1decoding_t dec, PUnknownMessageResponse_tokens *val);
static int ASN1CALL ASN1Dec_H225NonStandardMessage_tokens(ASN1decoding_t dec, PH225NonStandardMessage_tokens *val);
static int ASN1CALL ASN1Dec_InfoRequestNak_tokens(ASN1decoding_t dec, PInfoRequestNak_tokens *val);
static int ASN1CALL ASN1Dec_InfoRequestAck_tokens(ASN1decoding_t dec, PInfoRequestAck_tokens *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_tokens(ASN1decoding_t dec, PInfoRequestResponse_tokens *val);
static int ASN1CALL ASN1Dec_InfoRequest_tokens(ASN1decoding_t dec, PInfoRequest_tokens *val);
static int ASN1CALL ASN1Dec_DisengageReject_tokens(ASN1decoding_t dec, PDisengageReject_tokens *val);
static int ASN1CALL ASN1Dec_DisengageConfirm_tokens(ASN1decoding_t dec, PDisengageConfirm_tokens *val);
static int ASN1CALL ASN1Dec_DisengageRequest_tokens(ASN1decoding_t dec, PDisengageRequest_tokens *val);
static int ASN1CALL ASN1Dec_LocationReject_tokens(ASN1decoding_t dec, PLocationReject_tokens *val);
static int ASN1CALL ASN1Dec_LocationConfirm_tokens(ASN1decoding_t dec, PLocationConfirm_tokens *val);
static int ASN1CALL ASN1Dec_LocationRequest_tokens(ASN1decoding_t dec, PLocationRequest_tokens *val);
static int ASN1CALL ASN1Dec_BandwidthReject_tokens(ASN1decoding_t dec, PBandwidthReject_tokens *val);
static int ASN1CALL ASN1Dec_BandwidthConfirm_tokens(ASN1decoding_t dec, PBandwidthConfirm_tokens *val);
static int ASN1CALL ASN1Dec_BandwidthRequest_tokens(ASN1decoding_t dec, PBandwidthRequest_tokens *val);
static int ASN1CALL ASN1Dec_AdmissionReject_tokens(ASN1decoding_t dec, PAdmissionReject_tokens *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_tokens(ASN1decoding_t dec, PAdmissionConfirm_tokens *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_tokens(ASN1decoding_t dec, PAdmissionRequest_tokens *val);
static int ASN1CALL ASN1Dec_UnregistrationReject_tokens(ASN1decoding_t dec, PUnregistrationReject_tokens *val);
static int ASN1CALL ASN1Dec_UnregistrationConfirm_tokens(ASN1decoding_t dec, PUnregistrationConfirm_tokens *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest_tokens(ASN1decoding_t dec, PUnregistrationRequest_tokens *val);
static int ASN1CALL ASN1Dec_RegistrationReject_tokens(ASN1decoding_t dec, PRegistrationReject_tokens *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_tokens(ASN1decoding_t dec, PRegistrationConfirm_tokens *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_tokens(ASN1decoding_t dec, PRegistrationRequest_tokens *val);
static int ASN1CALL ASN1Dec_GatekeeperReject_tokens(ASN1decoding_t dec, PGatekeeperReject_tokens *val);
static int ASN1CALL ASN1Dec_GatekeeperConfirm_tokens(ASN1decoding_t dec, PGatekeeperConfirm_tokens *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_authenticationCapability(ASN1decoding_t dec, PGatekeeperRequest_authenticationCapability *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_tokens(ASN1decoding_t dec, PGatekeeperRequest_tokens *val);
static int ASN1CALL ASN1Dec_Endpoint_tokens(ASN1decoding_t dec, PEndpoint_tokens *val);
static int ASN1CALL ASN1Dec_Progress_UUIE_tokens(ASN1decoding_t dec, PProgress_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_tokens(ASN1decoding_t dec, PFacility_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_tokens(ASN1decoding_t dec, PSetup_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_Connect_UUIE_tokens(ASN1decoding_t dec, PConnect_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_CallProceeding_UUIE_tokens(ASN1decoding_t dec, PCallProceeding_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_Alerting_UUIE_tokens(ASN1decoding_t dec, PAlerting_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_SIGNED_EncodedGeneralToken(ASN1decoding_t dec, SIGNED_EncodedGeneralToken *val);
static int ASN1CALL ASN1Dec_ENCRYPTED(ASN1decoding_t dec, ENCRYPTED *val);
static int ASN1CALL ASN1Dec_HASHED(ASN1decoding_t dec, HASHED *val);
static int ASN1CALL ASN1Dec_SIGNED_EncodedPwdCertToken(ASN1decoding_t dec, SIGNED_EncodedPwdCertToken *val);
static int ASN1CALL ASN1Dec_Information_UUIE(ASN1decoding_t dec, Information_UUIE *val);
static int ASN1CALL ASN1Dec_ReleaseComplete_UUIE(ASN1decoding_t dec, ReleaseComplete_UUIE *val);
static int ASN1CALL ASN1Dec_VendorIdentifier(ASN1decoding_t dec, VendorIdentifier *val);
static int ASN1CALL ASN1Dec_H225NonStandardParameter(ASN1decoding_t dec, H225NonStandardParameter *val);
static int ASN1CALL ASN1Dec_PublicPartyNumber(ASN1decoding_t dec, PublicPartyNumber *val);
static int ASN1CALL ASN1Dec_PrivatePartyNumber(ASN1decoding_t dec, PrivatePartyNumber *val);
static int ASN1CALL ASN1Dec_SecurityServiceMode(ASN1decoding_t dec, SecurityServiceMode *val);
static int ASN1CALL ASN1Dec_SecurityCapabilities(ASN1decoding_t dec, SecurityCapabilities *val);
static int ASN1CALL ASN1Dec_H245Security(ASN1decoding_t dec, H245Security *val);
static int ASN1CALL ASN1Dec_QseriesOptions(ASN1decoding_t dec, QseriesOptions *val);
static int ASN1CALL ASN1Dec_EncryptIntAlg(ASN1decoding_t dec, EncryptIntAlg *val);
static int ASN1CALL ASN1Dec_NonIsoIntegrityMechanism(ASN1decoding_t dec, NonIsoIntegrityMechanism *val);
static int ASN1CALL ASN1Dec_IntegrityMechanism(ASN1decoding_t dec, IntegrityMechanism *val);
#define ASN1Dec_FastStartToken(x,y)      0
static int ASN1CALL ASN1Dec_EncodedFastStartToken(ASN1decoding_t dec, EncodedFastStartToken *val);
static int ASN1CALL ASN1Dec_DataRate(ASN1decoding_t dec, DataRate *val);
static int ASN1CALL ASN1Dec_GatekeeperReject(ASN1decoding_t dec, GatekeeperReject *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm(ASN1decoding_t dec, RegistrationConfirm *val);
static int ASN1CALL ASN1Dec_RegistrationReject(ASN1decoding_t dec, RegistrationReject *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest(ASN1decoding_t dec, UnregistrationRequest *val);
static int ASN1CALL ASN1Dec_UnregistrationConfirm(ASN1decoding_t dec, UnregistrationConfirm *val);
static int ASN1CALL ASN1Dec_UnregistrationReject(ASN1decoding_t dec, UnregistrationReject *val);
static int ASN1CALL ASN1Dec_AdmissionReject(ASN1decoding_t dec, AdmissionReject *val);
static int ASN1CALL ASN1Dec_BandwidthRequest(ASN1decoding_t dec, BandwidthRequest *val);
static int ASN1CALL ASN1Dec_BandwidthConfirm(ASN1decoding_t dec, BandwidthConfirm *val);
static int ASN1CALL ASN1Dec_BandwidthReject(ASN1decoding_t dec, BandwidthReject *val);
static int ASN1CALL ASN1Dec_LocationReject(ASN1decoding_t dec, LocationReject *val);
static int ASN1CALL ASN1Dec_DisengageRequest(ASN1decoding_t dec, DisengageRequest *val);
static int ASN1CALL ASN1Dec_DisengageConfirm(ASN1decoding_t dec, DisengageConfirm *val);
static int ASN1CALL ASN1Dec_DisengageReject(ASN1decoding_t dec, DisengageReject *val);
static int ASN1CALL ASN1Dec_InfoRequestAck(ASN1decoding_t dec, InfoRequestAck *val);
static int ASN1CALL ASN1Dec_InfoRequestNak(ASN1decoding_t dec, InfoRequestNak *val);
static int ASN1CALL ASN1Dec_H225NonStandardMessage(ASN1decoding_t dec, H225NonStandardMessage *val);
static int ASN1CALL ASN1Dec_RequestInProgress(ASN1decoding_t dec, RequestInProgress *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate(ASN1decoding_t dec, ResourcesAvailableIndicate *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm(ASN1decoding_t dec, ResourcesAvailableConfirm *val);
static int ASN1CALL ASN1Dec_GatekeeperConfirm_integrity(ASN1decoding_t dec, PGatekeeperConfirm_integrity *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_integrity(ASN1decoding_t dec, PGatekeeperRequest_integrity *val);
static int ASN1CALL ASN1Dec_CryptoH323Token_cryptoGKPwdHash(ASN1decoding_t dec, CryptoH323Token_cryptoGKPwdHash *val);
static int ASN1CALL ASN1Dec_NonStandardProtocol_dataRatesSupported(ASN1decoding_t dec, PNonStandardProtocol_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_T120OnlyCaps_dataRatesSupported(ASN1decoding_t dec, PT120OnlyCaps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_VoiceCaps_dataRatesSupported(ASN1decoding_t dec, PVoiceCaps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H324Caps_dataRatesSupported(ASN1decoding_t dec, PH324Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H323Caps_dataRatesSupported(ASN1decoding_t dec, PH323Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H322Caps_dataRatesSupported(ASN1decoding_t dec, PH322Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H321Caps_dataRatesSupported(ASN1decoding_t dec, PH321Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H320Caps_dataRatesSupported(ASN1decoding_t dec, PH320Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H310Caps_dataRatesSupported(ASN1decoding_t dec, PH310Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_h245SecurityCapability(ASN1decoding_t dec, PSetup_UUIE_h245SecurityCapability *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU_nonStandardControl(ASN1decoding_t dec, PH323_UU_PDU_nonStandardControl *val);
static int ASN1CALL ASN1Dec_CryptoToken_cryptoHashedToken(ASN1decoding_t dec, CryptoToken_cryptoHashedToken *val);
static int ASN1CALL ASN1Dec_CryptoToken_cryptoSignedToken(ASN1decoding_t dec, CryptoToken_cryptoSignedToken *val);
static int ASN1CALL ASN1Dec_CryptoToken_cryptoEncryptedToken(ASN1decoding_t dec, CryptoToken_cryptoEncryptedToken *val);
static int ASN1CALL ASN1Dec_CryptoToken(ASN1decoding_t dec, CryptoToken *val);
static int ASN1CALL ASN1Dec_SIGNED_EncodedFastStartToken(ASN1decoding_t dec, SIGNED_EncodedFastStartToken *val);
static int ASN1CALL ASN1Dec_TransportAddress(ASN1decoding_t dec, TransportAddress *val);
static int ASN1CALL ASN1Dec_GatewayInfo(ASN1decoding_t dec, GatewayInfo *val);
static int ASN1CALL ASN1Dec_H310Caps(ASN1decoding_t dec, H310Caps *val);
static int ASN1CALL ASN1Dec_H320Caps(ASN1decoding_t dec, H320Caps *val);
static int ASN1CALL ASN1Dec_H321Caps(ASN1decoding_t dec, H321Caps *val);
static int ASN1CALL ASN1Dec_H322Caps(ASN1decoding_t dec, H322Caps *val);
static int ASN1CALL ASN1Dec_H323Caps(ASN1decoding_t dec, H323Caps *val);
static int ASN1CALL ASN1Dec_H324Caps(ASN1decoding_t dec, H324Caps *val);
static int ASN1CALL ASN1Dec_VoiceCaps(ASN1decoding_t dec, VoiceCaps *val);
static int ASN1CALL ASN1Dec_T120OnlyCaps(ASN1decoding_t dec, T120OnlyCaps *val);
static int ASN1CALL ASN1Dec_NonStandardProtocol(ASN1decoding_t dec, NonStandardProtocol *val);
static int ASN1CALL ASN1Dec_McuInfo(ASN1decoding_t dec, McuInfo *val);
static int ASN1CALL ASN1Dec_TerminalInfo(ASN1decoding_t dec, TerminalInfo *val);
static int ASN1CALL ASN1Dec_GatekeeperInfo(ASN1decoding_t dec, GatekeeperInfo *val);
static int ASN1CALL ASN1Dec_PartyNumber(ASN1decoding_t dec, PartyNumber *val);
static int ASN1CALL ASN1Dec_AlternateGK(ASN1decoding_t dec, AlternateGK *val);
static int ASN1CALL ASN1Dec_GatekeeperConfirm(ASN1decoding_t dec, GatekeeperConfirm *val);
static int ASN1CALL ASN1Dec_AdmissionRequest(ASN1decoding_t dec, AdmissionRequest *val);
static int ASN1CALL ASN1Dec_LocationRequest(ASN1decoding_t dec, LocationRequest *val);
static int ASN1CALL ASN1Dec_InfoRequest(ASN1decoding_t dec, InfoRequest *val);
static int ASN1CALL ASN1Dec_TransportChannelInfo(ASN1decoding_t dec, TransportChannelInfo *val);
static int ASN1CALL ASN1Dec_RTPSession(ASN1decoding_t dec, RTPSession *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_data *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_video *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_audio *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq(ASN1decoding_t dec, InfoRequestResponse_perCallInfo_Seq *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_callSignalAddress(ASN1decoding_t dec, PInfoRequestResponse_callSignalAddress *val);
static int ASN1CALL ASN1Dec_AdmissionReject_callSignalAddress(ASN1decoding_t dec, PAdmissionReject_callSignalAddress *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest_callSignalAddress(ASN1decoding_t dec, PUnregistrationRequest_callSignalAddress *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_alternateGatekeeper(ASN1decoding_t dec, PRegistrationConfirm_alternateGatekeeper *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_callSignalAddress(ASN1decoding_t dec, PRegistrationConfirm_callSignalAddress *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_rasAddress(ASN1decoding_t dec, PRegistrationRequest_rasAddress *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_callSignalAddress(ASN1decoding_t dec, PRegistrationRequest_callSignalAddress *val);
static int ASN1CALL ASN1Dec_GatekeeperConfirm_alternateGatekeeper(ASN1decoding_t dec, PGatekeeperConfirm_alternateGatekeeper *val);
static int ASN1CALL ASN1Dec_AltGKInfo_alternateGatekeeper(ASN1decoding_t dec, PAltGKInfo_alternateGatekeeper *val);
static int ASN1CALL ASN1Dec_Endpoint_rasAddress(ASN1decoding_t dec, PEndpoint_rasAddress *val);
static int ASN1CALL ASN1Dec_Endpoint_callSignalAddress(ASN1decoding_t dec, PEndpoint_callSignalAddress *val);
static int ASN1CALL ASN1Dec_EndpointType(ASN1decoding_t dec, EndpointType *val);
static int ASN1CALL ASN1Dec_SupportedProtocols(ASN1decoding_t dec, SupportedProtocols *val);
static int ASN1CALL ASN1Dec_AliasAddress(ASN1decoding_t dec, AliasAddress *val);
static int ASN1CALL ASN1Dec_Endpoint(ASN1decoding_t dec, Endpoint *val);
static int ASN1CALL ASN1Dec_SupportedPrefix(ASN1decoding_t dec, SupportedPrefix *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest(ASN1decoding_t dec, GatekeeperRequest *val);
static int ASN1CALL ASN1Dec_RegistrationRequest(ASN1decoding_t dec, RegistrationRequest *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm(ASN1decoding_t dec, AdmissionConfirm *val);
static int ASN1CALL ASN1Dec_LocationConfirm(ASN1decoding_t dec, LocationConfirm *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse(ASN1decoding_t dec, InfoRequestResponse *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_protocols(ASN1decoding_t dec, PResourcesAvailableIndicate_protocols *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_endpointAlias(ASN1decoding_t dec, PInfoRequestResponse_endpointAlias *val);
static int ASN1CALL ASN1Dec_LocationConfirm_alternateEndpoints(ASN1decoding_t dec, PLocationConfirm_alternateEndpoints *val);
static int ASN1CALL ASN1Dec_LocationConfirm_remoteExtensionAddress(ASN1decoding_t dec, PLocationConfirm_remoteExtensionAddress *val);
static int ASN1CALL ASN1Dec_LocationConfirm_destExtraCallInfo(ASN1decoding_t dec, PLocationConfirm_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_LocationConfirm_destinationInfo(ASN1decoding_t dec, PLocationConfirm_destinationInfo *val);
static int ASN1CALL ASN1Dec_LocationRequest_sourceInfo(ASN1decoding_t dec, PLocationRequest_sourceInfo *val);
static int ASN1CALL ASN1Dec_LocationRequest_destinationInfo(ASN1decoding_t dec, PLocationRequest_destinationInfo *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_alternateEndpoints(ASN1decoding_t dec, PAdmissionConfirm_alternateEndpoints *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_remoteExtensionAddress(ASN1decoding_t dec, PAdmissionConfirm_remoteExtensionAddress *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_destExtraCallInfo(ASN1decoding_t dec, PAdmissionConfirm_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_destinationInfo(ASN1decoding_t dec, PAdmissionConfirm_destinationInfo *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_destAlternatives(ASN1decoding_t dec, PAdmissionRequest_destAlternatives *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_srcAlternatives(ASN1decoding_t dec, PAdmissionRequest_srcAlternatives *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_srcInfo(ASN1decoding_t dec, PAdmissionRequest_srcInfo *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_destExtraCallInfo(ASN1decoding_t dec, PAdmissionRequest_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_destinationInfo(ASN1decoding_t dec, PAdmissionRequest_destinationInfo *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest_alternateEndpoints(ASN1decoding_t dec, PUnregistrationRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest_endpointAlias(ASN1decoding_t dec, PUnregistrationRequest_endpointAlias *val);
static int ASN1CALL ASN1Dec_RegistrationRejectReason_duplicateAlias(ASN1decoding_t dec, PRegistrationRejectReason_duplicateAlias *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_terminalAlias(ASN1decoding_t dec, PRegistrationConfirm_terminalAlias *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_alternateEndpoints(ASN1decoding_t dec, PRegistrationRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_terminalAlias(ASN1decoding_t dec, PRegistrationRequest_terminalAlias *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_alternateEndpoints(ASN1decoding_t dec, PGatekeeperRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_endpointAlias(ASN1decoding_t dec, PGatekeeperRequest_endpointAlias *val);
static int ASN1CALL ASN1Dec_CryptoH323Token_cryptoEPPwdHash(ASN1decoding_t dec, CryptoH323Token_cryptoEPPwdHash *val);
static int ASN1CALL ASN1Dec_Endpoint_destExtraCallInfo(ASN1decoding_t dec, PEndpoint_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_Endpoint_remoteExtensionAddress(ASN1decoding_t dec, PEndpoint_remoteExtensionAddress *val);
static int ASN1CALL ASN1Dec_Endpoint_aliasAddress(ASN1decoding_t dec, PEndpoint_aliasAddress *val);
static int ASN1CALL ASN1Dec_NonStandardProtocol_supportedPrefixes(ASN1decoding_t dec, PNonStandardProtocol_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_T120OnlyCaps_supportedPrefixes(ASN1decoding_t dec, PT120OnlyCaps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_VoiceCaps_supportedPrefixes(ASN1decoding_t dec, PVoiceCaps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H324Caps_supportedPrefixes(ASN1decoding_t dec, PH324Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H323Caps_supportedPrefixes(ASN1decoding_t dec, PH323Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H322Caps_supportedPrefixes(ASN1decoding_t dec, PH322Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H321Caps_supportedPrefixes(ASN1decoding_t dec, PH321Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H320Caps_supportedPrefixes(ASN1decoding_t dec, PH320Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H310Caps_supportedPrefixes(ASN1decoding_t dec, PH310Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_GatewayInfo_protocol(ASN1decoding_t dec, PGatewayInfo_protocol *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_destExtraCallInfo(ASN1decoding_t dec, PFacility_UUIE_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_alternativeAliasAddress(ASN1decoding_t dec, PFacility_UUIE_alternativeAliasAddress *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCallInfo(ASN1decoding_t dec, PSetup_UUIE_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_destinationAddress(ASN1decoding_t dec, PSetup_UUIE_destinationAddress *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_sourceAddress(ASN1decoding_t dec, PSetup_UUIE_sourceAddress *val);
static int ASN1CALL ASN1Dec_Alerting_UUIE(ASN1decoding_t dec, Alerting_UUIE *val);
static int ASN1CALL ASN1Dec_CallProceeding_UUIE(ASN1decoding_t dec, CallProceeding_UUIE *val);
static int ASN1CALL ASN1Dec_Connect_UUIE(ASN1decoding_t dec, Connect_UUIE *val);
static int ASN1CALL ASN1Dec_Setup_UUIE(ASN1decoding_t dec, Setup_UUIE *val);
static int ASN1CALL ASN1Dec_Facility_UUIE(ASN1decoding_t dec, Facility_UUIE *val);
static int ASN1CALL ASN1Dec_ConferenceList(ASN1decoding_t dec, ConferenceList *val);
static int ASN1CALL ASN1Dec_Progress_UUIE(ASN1decoding_t dec, Progress_UUIE *val);
static int ASN1CALL ASN1Dec_CryptoH323Token(ASN1decoding_t dec, CryptoH323Token *val);
static int ASN1CALL ASN1Dec_RasMessage(ASN1decoding_t dec, RasMessage *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_cryptoTokens(ASN1decoding_t dec, PResourcesAvailableConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_cryptoTokens(ASN1decoding_t dec, PResourcesAvailableIndicate_cryptoTokens *val);
static int ASN1CALL ASN1Dec_RequestInProgress_cryptoTokens(ASN1decoding_t dec, PRequestInProgress_cryptoTokens *val);
static int ASN1CALL ASN1Dec_UnknownMessageResponse_cryptoTokens(ASN1decoding_t dec, PUnknownMessageResponse_cryptoTokens *val);
static int ASN1CALL ASN1Dec_H225NonStandardMessage_cryptoTokens(ASN1decoding_t dec, PH225NonStandardMessage_cryptoTokens *val);
static int ASN1CALL ASN1Dec_InfoRequestNak_cryptoTokens(ASN1decoding_t dec, PInfoRequestNak_cryptoTokens *val);
static int ASN1CALL ASN1Dec_InfoRequestAck_cryptoTokens(ASN1decoding_t dec, PInfoRequestAck_cryptoTokens *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_cryptoTokens(ASN1decoding_t dec, PInfoRequestResponse_cryptoTokens *val);
static int ASN1CALL ASN1Dec_InfoRequest_cryptoTokens(ASN1decoding_t dec, PInfoRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_DisengageReject_cryptoTokens(ASN1decoding_t dec, PDisengageReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_DisengageConfirm_cryptoTokens(ASN1decoding_t dec, PDisengageConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_DisengageRequest_cryptoTokens(ASN1decoding_t dec, PDisengageRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_LocationReject_cryptoTokens(ASN1decoding_t dec, PLocationReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_LocationConfirm_cryptoTokens(ASN1decoding_t dec, PLocationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_LocationRequest_cryptoTokens(ASN1decoding_t dec, PLocationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_BandwidthReject_cryptoTokens(ASN1decoding_t dec, PBandwidthReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_BandwidthConfirm_cryptoTokens(ASN1decoding_t dec, PBandwidthConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_BandwidthRequest_cryptoTokens(ASN1decoding_t dec, PBandwidthRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_AdmissionReject_cryptoTokens(ASN1decoding_t dec, PAdmissionReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_cryptoTokens(ASN1decoding_t dec, PAdmissionConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_cryptoTokens(ASN1decoding_t dec, PAdmissionRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_UnregistrationReject_cryptoTokens(ASN1decoding_t dec, PUnregistrationReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_UnregistrationConfirm_cryptoTokens(ASN1decoding_t dec, PUnregistrationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest_cryptoTokens(ASN1decoding_t dec, PUnregistrationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_RegistrationReject_cryptoTokens(ASN1decoding_t dec, PRegistrationReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_cryptoTokens(ASN1decoding_t dec, PRegistrationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_cryptoTokens(ASN1decoding_t dec, PRegistrationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_GatekeeperReject_cryptoTokens(ASN1decoding_t dec, PGatekeeperReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_GatekeeperConfirm_cryptoTokens(ASN1decoding_t dec, PGatekeeperConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_cryptoTokens(ASN1decoding_t dec, PGatekeeperRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Endpoint_cryptoTokens(ASN1decoding_t dec, PEndpoint_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Progress_UUIE_cryptoTokens(ASN1decoding_t dec, PProgress_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_conferences(ASN1decoding_t dec, PFacility_UUIE_conferences *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_cryptoTokens(ASN1decoding_t dec, PFacility_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_cryptoTokens(ASN1decoding_t dec, PSetup_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Connect_UUIE_cryptoTokens(ASN1decoding_t dec, PConnect_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_CallProceeding_UUIE_cryptoTokens(ASN1decoding_t dec, PCallProceeding_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Alerting_UUIE_cryptoTokens(ASN1decoding_t dec, PAlerting_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU_h323_message_body(ASN1decoding_t dec, H323_UU_PDU_h323_message_body *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU(ASN1decoding_t dec, H323_UU_PDU *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(ASN1decoding_t dec, InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_pdu *val);
static int ASN1CALL ASN1Dec_H323_UserInformation(ASN1decoding_t dec, H323_UserInformation *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val);
static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route(PTransportAddress_ipSourceRoute_route *val);
static void ASN1CALL ASN1Free_RTPSession_associatedSessionIds(PRTPSession_associatedSessionIds *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_algorithmOIDs(PGatekeeperRequest_algorithmOIDs *val);
static void ASN1CALL ASN1Free_TransportAddress_ip6Address(TransportAddress_ip6Address *val);
static void ASN1CALL ASN1Free_TransportAddress_ipxAddress(TransportAddress_ipxAddress *val);
static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute(TransportAddress_ipSourceRoute *val);
static void ASN1CALL ASN1Free_TransportAddress_ipAddress(TransportAddress_ipAddress *val);
static void ASN1CALL ASN1Free_Progress_UUIE_fastStart(PProgress_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_Facility_UUIE_fastStart(PFacility_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_Setup_UUIE_fastStart(PSetup_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCRV(PSetup_UUIE_destExtraCRV *val);
static void ASN1CALL ASN1Free_Connect_UUIE_fastStart(PConnect_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_CallProceeding_UUIE_fastStart(PCallProceeding_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_Alerting_UUIE_fastStart(PAlerting_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_H323_UU_PDU_h245Control(PH323_UU_PDU_h245Control *val);
static void ASN1CALL ASN1Free_H323_UU_PDU_h4501SupplementaryService(PH323_UU_PDU_h4501SupplementaryService *val);
static void ASN1CALL ASN1Free_H323_UserInformation_user_data(H323_UserInformation_user_data *val);
static void ASN1CALL ASN1Free_H235NonStandardParameter(H235NonStandardParameter *val);
static void ASN1CALL ASN1Free_DHset(DHset *val);
static void ASN1CALL ASN1Free_TypedCertificate(TypedCertificate *val);
static void ASN1CALL ASN1Free_AuthenticationMechanism(AuthenticationMechanism *val);
static void ASN1CALL ASN1Free_ClearToken(ClearToken *val);
static void ASN1CALL ASN1Free_Params(Params *val);
static void ASN1CALL ASN1Free_EncodedGeneralToken(EncodedGeneralToken *val);
static void ASN1CALL ASN1Free_PwdCertToken(PwdCertToken *val);
static void ASN1CALL ASN1Free_EncodedPwdCertToken(EncodedPwdCertToken *val);
static void ASN1CALL ASN1Free_H225NonStandardIdentifier(H225NonStandardIdentifier *val);
static void ASN1CALL ASN1Free_AltGKInfo(AltGKInfo *val);
static void ASN1CALL ASN1Free_CallIdentifier(CallIdentifier *val);
static void ASN1CALL ASN1Free_ICV(ICV *val);
static void ASN1CALL ASN1Free_RegistrationRejectReason(RegistrationRejectReason *val);
static void ASN1CALL ASN1Free_UnknownMessageResponse(UnknownMessageResponse *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens(PInfoRequestResponse_perCallInfo_Seq_tokens *val);
static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_tokens(PResourcesAvailableConfirm_tokens *val);
static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_tokens(PResourcesAvailableIndicate_tokens *val);
static void ASN1CALL ASN1Free_RequestInProgress_tokens(PRequestInProgress_tokens *val);
static void ASN1CALL ASN1Free_UnknownMessageResponse_tokens(PUnknownMessageResponse_tokens *val);
static void ASN1CALL ASN1Free_H225NonStandardMessage_tokens(PH225NonStandardMessage_tokens *val);
static void ASN1CALL ASN1Free_InfoRequestNak_tokens(PInfoRequestNak_tokens *val);
static void ASN1CALL ASN1Free_InfoRequestAck_tokens(PInfoRequestAck_tokens *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_tokens(PInfoRequestResponse_tokens *val);
static void ASN1CALL ASN1Free_InfoRequest_tokens(PInfoRequest_tokens *val);
static void ASN1CALL ASN1Free_DisengageReject_tokens(PDisengageReject_tokens *val);
static void ASN1CALL ASN1Free_DisengageConfirm_tokens(PDisengageConfirm_tokens *val);
static void ASN1CALL ASN1Free_DisengageRequest_tokens(PDisengageRequest_tokens *val);
static void ASN1CALL ASN1Free_LocationReject_tokens(PLocationReject_tokens *val);
static void ASN1CALL ASN1Free_LocationConfirm_tokens(PLocationConfirm_tokens *val);
static void ASN1CALL ASN1Free_LocationRequest_tokens(PLocationRequest_tokens *val);
static void ASN1CALL ASN1Free_BandwidthReject_tokens(PBandwidthReject_tokens *val);
static void ASN1CALL ASN1Free_BandwidthConfirm_tokens(PBandwidthConfirm_tokens *val);
static void ASN1CALL ASN1Free_BandwidthRequest_tokens(PBandwidthRequest_tokens *val);
static void ASN1CALL ASN1Free_AdmissionReject_tokens(PAdmissionReject_tokens *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_tokens(PAdmissionConfirm_tokens *val);
static void ASN1CALL ASN1Free_AdmissionRequest_tokens(PAdmissionRequest_tokens *val);
static void ASN1CALL ASN1Free_UnregistrationReject_tokens(PUnregistrationReject_tokens *val);
static void ASN1CALL ASN1Free_UnregistrationConfirm_tokens(PUnregistrationConfirm_tokens *val);
static void ASN1CALL ASN1Free_UnregistrationRequest_tokens(PUnregistrationRequest_tokens *val);
static void ASN1CALL ASN1Free_RegistrationReject_tokens(PRegistrationReject_tokens *val);
static void ASN1CALL ASN1Free_RegistrationConfirm_tokens(PRegistrationConfirm_tokens *val);
static void ASN1CALL ASN1Free_RegistrationRequest_tokens(PRegistrationRequest_tokens *val);
static void ASN1CALL ASN1Free_GatekeeperReject_tokens(PGatekeeperReject_tokens *val);
static void ASN1CALL ASN1Free_GatekeeperConfirm_tokens(PGatekeeperConfirm_tokens *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_authenticationCapability(PGatekeeperRequest_authenticationCapability *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_tokens(PGatekeeperRequest_tokens *val);
static void ASN1CALL ASN1Free_Endpoint_tokens(PEndpoint_tokens *val);
static void ASN1CALL ASN1Free_Progress_UUIE_tokens(PProgress_UUIE_tokens *val);
static void ASN1CALL ASN1Free_Facility_UUIE_tokens(PFacility_UUIE_tokens *val);
static void ASN1CALL ASN1Free_Setup_UUIE_tokens(PSetup_UUIE_tokens *val);
static void ASN1CALL ASN1Free_Connect_UUIE_tokens(PConnect_UUIE_tokens *val);
static void ASN1CALL ASN1Free_CallProceeding_UUIE_tokens(PCallProceeding_UUIE_tokens *val);
static void ASN1CALL ASN1Free_Alerting_UUIE_tokens(PAlerting_UUIE_tokens *val);
static void ASN1CALL ASN1Free_SIGNED_EncodedGeneralToken(SIGNED_EncodedGeneralToken *val);
static void ASN1CALL ASN1Free_ENCRYPTED(ENCRYPTED *val);
static void ASN1CALL ASN1Free_HASHED(HASHED *val);
static void ASN1CALL ASN1Free_SIGNED_EncodedPwdCertToken(SIGNED_EncodedPwdCertToken *val);
static void ASN1CALL ASN1Free_Information_UUIE(Information_UUIE *val);
static void ASN1CALL ASN1Free_ReleaseComplete_UUIE(ReleaseComplete_UUIE *val);
static void ASN1CALL ASN1Free_VendorIdentifier(VendorIdentifier *val);
static void ASN1CALL ASN1Free_H225NonStandardParameter(H225NonStandardParameter *val);
static void ASN1CALL ASN1Free_PublicPartyNumber(PublicPartyNumber *val);
static void ASN1CALL ASN1Free_PrivatePartyNumber(PrivatePartyNumber *val);
static void ASN1CALL ASN1Free_SecurityServiceMode(SecurityServiceMode *val);
static void ASN1CALL ASN1Free_SecurityCapabilities(SecurityCapabilities *val);
static void ASN1CALL ASN1Free_H245Security(H245Security *val);
static void ASN1CALL ASN1Free_EncryptIntAlg(EncryptIntAlg *val);
static void ASN1CALL ASN1Free_NonIsoIntegrityMechanism(NonIsoIntegrityMechanism *val);
static void ASN1CALL ASN1Free_IntegrityMechanism(IntegrityMechanism *val);
#define ASN1Free_FastStartToken(x)     
static void ASN1CALL ASN1Free_EncodedFastStartToken(EncodedFastStartToken *val);
static void ASN1CALL ASN1Free_DataRate(DataRate *val);
static void ASN1CALL ASN1Free_GatekeeperReject(GatekeeperReject *val);
static void ASN1CALL ASN1Free_RegistrationConfirm(RegistrationConfirm *val);
static void ASN1CALL ASN1Free_RegistrationReject(RegistrationReject *val);
static void ASN1CALL ASN1Free_UnregistrationRequest(UnregistrationRequest *val);
static void ASN1CALL ASN1Free_UnregistrationConfirm(UnregistrationConfirm *val);
static void ASN1CALL ASN1Free_UnregistrationReject(UnregistrationReject *val);
static void ASN1CALL ASN1Free_AdmissionReject(AdmissionReject *val);
static void ASN1CALL ASN1Free_BandwidthRequest(BandwidthRequest *val);
static void ASN1CALL ASN1Free_BandwidthConfirm(BandwidthConfirm *val);
static void ASN1CALL ASN1Free_BandwidthReject(BandwidthReject *val);
static void ASN1CALL ASN1Free_LocationReject(LocationReject *val);
static void ASN1CALL ASN1Free_DisengageRequest(DisengageRequest *val);
static void ASN1CALL ASN1Free_DisengageConfirm(DisengageConfirm *val);
static void ASN1CALL ASN1Free_DisengageReject(DisengageReject *val);
static void ASN1CALL ASN1Free_InfoRequestAck(InfoRequestAck *val);
static void ASN1CALL ASN1Free_InfoRequestNak(InfoRequestNak *val);
static void ASN1CALL ASN1Free_H225NonStandardMessage(H225NonStandardMessage *val);
static void ASN1CALL ASN1Free_RequestInProgress(RequestInProgress *val);
static void ASN1CALL ASN1Free_ResourcesAvailableIndicate(ResourcesAvailableIndicate *val);
static void ASN1CALL ASN1Free_ResourcesAvailableConfirm(ResourcesAvailableConfirm *val);
static void ASN1CALL ASN1Free_GatekeeperConfirm_integrity(PGatekeeperConfirm_integrity *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_integrity(PGatekeeperRequest_integrity *val);
static void ASN1CALL ASN1Free_CryptoH323Token_cryptoGKPwdHash(CryptoH323Token_cryptoGKPwdHash *val);
static void ASN1CALL ASN1Free_NonStandardProtocol_dataRatesSupported(PNonStandardProtocol_dataRatesSupported *val);
static void ASN1CALL ASN1Free_T120OnlyCaps_dataRatesSupported(PT120OnlyCaps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_VoiceCaps_dataRatesSupported(PVoiceCaps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H324Caps_dataRatesSupported(PH324Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H323Caps_dataRatesSupported(PH323Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H322Caps_dataRatesSupported(PH322Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H321Caps_dataRatesSupported(PH321Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H320Caps_dataRatesSupported(PH320Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H310Caps_dataRatesSupported(PH310Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_Setup_UUIE_h245SecurityCapability(PSetup_UUIE_h245SecurityCapability *val);
static void ASN1CALL ASN1Free_H323_UU_PDU_nonStandardControl(PH323_UU_PDU_nonStandardControl *val);
static void ASN1CALL ASN1Free_CryptoToken_cryptoHashedToken(CryptoToken_cryptoHashedToken *val);
static void ASN1CALL ASN1Free_CryptoToken_cryptoSignedToken(CryptoToken_cryptoSignedToken *val);
static void ASN1CALL ASN1Free_CryptoToken_cryptoEncryptedToken(CryptoToken_cryptoEncryptedToken *val);
static void ASN1CALL ASN1Free_CryptoToken(CryptoToken *val);
static void ASN1CALL ASN1Free_SIGNED_EncodedFastStartToken(SIGNED_EncodedFastStartToken *val);
static void ASN1CALL ASN1Free_TransportAddress(TransportAddress *val);
static void ASN1CALL ASN1Free_GatewayInfo(GatewayInfo *val);
static void ASN1CALL ASN1Free_H310Caps(H310Caps *val);
static void ASN1CALL ASN1Free_H320Caps(H320Caps *val);
static void ASN1CALL ASN1Free_H321Caps(H321Caps *val);
static void ASN1CALL ASN1Free_H322Caps(H322Caps *val);
static void ASN1CALL ASN1Free_H323Caps(H323Caps *val);
static void ASN1CALL ASN1Free_H324Caps(H324Caps *val);
static void ASN1CALL ASN1Free_VoiceCaps(VoiceCaps *val);
static void ASN1CALL ASN1Free_T120OnlyCaps(T120OnlyCaps *val);
static void ASN1CALL ASN1Free_NonStandardProtocol(NonStandardProtocol *val);
static void ASN1CALL ASN1Free_McuInfo(McuInfo *val);
static void ASN1CALL ASN1Free_TerminalInfo(TerminalInfo *val);
static void ASN1CALL ASN1Free_GatekeeperInfo(GatekeeperInfo *val);
static void ASN1CALL ASN1Free_PartyNumber(PartyNumber *val);
static void ASN1CALL ASN1Free_AlternateGK(AlternateGK *val);
static void ASN1CALL ASN1Free_GatekeeperConfirm(GatekeeperConfirm *val);
static void ASN1CALL ASN1Free_AdmissionRequest(AdmissionRequest *val);
static void ASN1CALL ASN1Free_LocationRequest(LocationRequest *val);
static void ASN1CALL ASN1Free_InfoRequest(InfoRequest *val);
static void ASN1CALL ASN1Free_TransportChannelInfo(TransportChannelInfo *val);
static void ASN1CALL ASN1Free_RTPSession(RTPSession *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_data(PInfoRequestResponse_perCallInfo_Seq_data *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_video(PInfoRequestResponse_perCallInfo_Seq_video *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio(PInfoRequestResponse_perCallInfo_Seq_audio *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq(InfoRequestResponse_perCallInfo_Seq *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo(PInfoRequestResponse_perCallInfo *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_callSignalAddress(PInfoRequestResponse_callSignalAddress *val);
static void ASN1CALL ASN1Free_AdmissionReject_callSignalAddress(PAdmissionReject_callSignalAddress *val);
static void ASN1CALL ASN1Free_UnregistrationRequest_callSignalAddress(PUnregistrationRequest_callSignalAddress *val);
static void ASN1CALL ASN1Free_RegistrationConfirm_alternateGatekeeper(PRegistrationConfirm_alternateGatekeeper *val);
static void ASN1CALL ASN1Free_RegistrationConfirm_callSignalAddress(PRegistrationConfirm_callSignalAddress *val);
static void ASN1CALL ASN1Free_RegistrationRequest_rasAddress(PRegistrationRequest_rasAddress *val);
static void ASN1CALL ASN1Free_RegistrationRequest_callSignalAddress(PRegistrationRequest_callSignalAddress *val);
static void ASN1CALL ASN1Free_GatekeeperConfirm_alternateGatekeeper(PGatekeeperConfirm_alternateGatekeeper *val);
static void ASN1CALL ASN1Free_AltGKInfo_alternateGatekeeper(PAltGKInfo_alternateGatekeeper *val);
static void ASN1CALL ASN1Free_Endpoint_rasAddress(PEndpoint_rasAddress *val);
static void ASN1CALL ASN1Free_Endpoint_callSignalAddress(PEndpoint_callSignalAddress *val);
static void ASN1CALL ASN1Free_EndpointType(EndpointType *val);
static void ASN1CALL ASN1Free_SupportedProtocols(SupportedProtocols *val);
static void ASN1CALL ASN1Free_AliasAddress(AliasAddress *val);
static void ASN1CALL ASN1Free_Endpoint(Endpoint *val);
static void ASN1CALL ASN1Free_SupportedPrefix(SupportedPrefix *val);
static void ASN1CALL ASN1Free_GatekeeperRequest(GatekeeperRequest *val);
static void ASN1CALL ASN1Free_RegistrationRequest(RegistrationRequest *val);
static void ASN1CALL ASN1Free_AdmissionConfirm(AdmissionConfirm *val);
static void ASN1CALL ASN1Free_LocationConfirm(LocationConfirm *val);
static void ASN1CALL ASN1Free_InfoRequestResponse(InfoRequestResponse *val);
static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_protocols(PResourcesAvailableIndicate_protocols *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_endpointAlias(PInfoRequestResponse_endpointAlias *val);
static void ASN1CALL ASN1Free_LocationConfirm_alternateEndpoints(PLocationConfirm_alternateEndpoints *val);
static void ASN1CALL ASN1Free_LocationConfirm_remoteExtensionAddress(PLocationConfirm_remoteExtensionAddress *val);
static void ASN1CALL ASN1Free_LocationConfirm_destExtraCallInfo(PLocationConfirm_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_LocationConfirm_destinationInfo(PLocationConfirm_destinationInfo *val);
static void ASN1CALL ASN1Free_LocationRequest_sourceInfo(PLocationRequest_sourceInfo *val);
static void ASN1CALL ASN1Free_LocationRequest_destinationInfo(PLocationRequest_destinationInfo *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_alternateEndpoints(PAdmissionConfirm_alternateEndpoints *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_remoteExtensionAddress(PAdmissionConfirm_remoteExtensionAddress *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_destExtraCallInfo(PAdmissionConfirm_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_destinationInfo(PAdmissionConfirm_destinationInfo *val);
static void ASN1CALL ASN1Free_AdmissionRequest_destAlternatives(PAdmissionRequest_destAlternatives *val);
static void ASN1CALL ASN1Free_AdmissionRequest_srcAlternatives(PAdmissionRequest_srcAlternatives *val);
static void ASN1CALL ASN1Free_AdmissionRequest_srcInfo(PAdmissionRequest_srcInfo *val);
static void ASN1CALL ASN1Free_AdmissionRequest_destExtraCallInfo(PAdmissionRequest_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_AdmissionRequest_destinationInfo(PAdmissionRequest_destinationInfo *val);
static void ASN1CALL ASN1Free_UnregistrationRequest_alternateEndpoints(PUnregistrationRequest_alternateEndpoints *val);
static void ASN1CALL ASN1Free_UnregistrationRequest_endpointAlias(PUnregistrationRequest_endpointAlias *val);
static void ASN1CALL ASN1Free_RegistrationRejectReason_duplicateAlias(PRegistrationRejectReason_duplicateAlias *val);
static void ASN1CALL ASN1Free_RegistrationConfirm_terminalAlias(PRegistrationConfirm_terminalAlias *val);
static void ASN1CALL ASN1Free_RegistrationRequest_alternateEndpoints(PRegistrationRequest_alternateEndpoints *val);
static void ASN1CALL ASN1Free_RegistrationRequest_terminalAlias(PRegistrationRequest_terminalAlias *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_alternateEndpoints(PGatekeeperRequest_alternateEndpoints *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_endpointAlias(PGatekeeperRequest_endpointAlias *val);
static void ASN1CALL ASN1Free_CryptoH323Token_cryptoEPPwdHash(CryptoH323Token_cryptoEPPwdHash *val);
static void ASN1CALL ASN1Free_Endpoint_destExtraCallInfo(PEndpoint_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_Endpoint_remoteExtensionAddress(PEndpoint_remoteExtensionAddress *val);
static void ASN1CALL ASN1Free_Endpoint_aliasAddress(PEndpoint_aliasAddress *val);
static void ASN1CALL ASN1Free_NonStandardProtocol_supportedPrefixes(PNonStandardProtocol_supportedPrefixes *val);
static void ASN1CALL ASN1Free_T120OnlyCaps_supportedPrefixes(PT120OnlyCaps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_VoiceCaps_supportedPrefixes(PVoiceCaps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H324Caps_supportedPrefixes(PH324Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H323Caps_supportedPrefixes(PH323Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H322Caps_supportedPrefixes(PH322Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H321Caps_supportedPrefixes(PH321Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H320Caps_supportedPrefixes(PH320Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H310Caps_supportedPrefixes(PH310Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_GatewayInfo_protocol(PGatewayInfo_protocol *val);
static void ASN1CALL ASN1Free_Facility_UUIE_destExtraCallInfo(PFacility_UUIE_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_Facility_UUIE_alternativeAliasAddress(PFacility_UUIE_alternativeAliasAddress *val);
static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCallInfo(PSetup_UUIE_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_Setup_UUIE_destinationAddress(PSetup_UUIE_destinationAddress *val);
static void ASN1CALL ASN1Free_Setup_UUIE_sourceAddress(PSetup_UUIE_sourceAddress *val);
static void ASN1CALL ASN1Free_Alerting_UUIE(Alerting_UUIE *val);
static void ASN1CALL ASN1Free_CallProceeding_UUIE(CallProceeding_UUIE *val);
static void ASN1CALL ASN1Free_Connect_UUIE(Connect_UUIE *val);
static void ASN1CALL ASN1Free_Setup_UUIE(Setup_UUIE *val);
static void ASN1CALL ASN1Free_Facility_UUIE(Facility_UUIE *val);
static void ASN1CALL ASN1Free_ConferenceList(ConferenceList *val);
static void ASN1CALL ASN1Free_Progress_UUIE(Progress_UUIE *val);
static void ASN1CALL ASN1Free_CryptoH323Token(CryptoH323Token *val);
static void ASN1CALL ASN1Free_RasMessage(RasMessage *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val);
static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_cryptoTokens(PResourcesAvailableConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_cryptoTokens(PResourcesAvailableIndicate_cryptoTokens *val);
static void ASN1CALL ASN1Free_RequestInProgress_cryptoTokens(PRequestInProgress_cryptoTokens *val);
static void ASN1CALL ASN1Free_UnknownMessageResponse_cryptoTokens(PUnknownMessageResponse_cryptoTokens *val);
static void ASN1CALL ASN1Free_H225NonStandardMessage_cryptoTokens(PH225NonStandardMessage_cryptoTokens *val);
static void ASN1CALL ASN1Free_InfoRequestNak_cryptoTokens(PInfoRequestNak_cryptoTokens *val);
static void ASN1CALL ASN1Free_InfoRequestAck_cryptoTokens(PInfoRequestAck_cryptoTokens *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_cryptoTokens(PInfoRequestResponse_cryptoTokens *val);
static void ASN1CALL ASN1Free_InfoRequest_cryptoTokens(PInfoRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_DisengageReject_cryptoTokens(PDisengageReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_DisengageConfirm_cryptoTokens(PDisengageConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_DisengageRequest_cryptoTokens(PDisengageRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_LocationReject_cryptoTokens(PLocationReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_LocationConfirm_cryptoTokens(PLocationConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_LocationRequest_cryptoTokens(PLocationRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_BandwidthReject_cryptoTokens(PBandwidthReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_BandwidthConfirm_cryptoTokens(PBandwidthConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_BandwidthRequest_cryptoTokens(PBandwidthRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_AdmissionReject_cryptoTokens(PAdmissionReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_cryptoTokens(PAdmissionConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_AdmissionRequest_cryptoTokens(PAdmissionRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_UnregistrationReject_cryptoTokens(PUnregistrationReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_UnregistrationConfirm_cryptoTokens(PUnregistrationConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_UnregistrationRequest_cryptoTokens(PUnregistrationRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_RegistrationReject_cryptoTokens(PRegistrationReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_RegistrationConfirm_cryptoTokens(PRegistrationConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_RegistrationRequest_cryptoTokens(PRegistrationRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_GatekeeperReject_cryptoTokens(PGatekeeperReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_GatekeeperConfirm_cryptoTokens(PGatekeeperConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_cryptoTokens(PGatekeeperRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_Endpoint_cryptoTokens(PEndpoint_cryptoTokens *val);
static void ASN1CALL ASN1Free_Progress_UUIE_cryptoTokens(PProgress_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_Facility_UUIE_conferences(PFacility_UUIE_conferences *val);
static void ASN1CALL ASN1Free_Facility_UUIE_cryptoTokens(PFacility_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_Setup_UUIE_cryptoTokens(PSetup_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_Connect_UUIE_cryptoTokens(PConnect_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_CallProceeding_UUIE_cryptoTokens(PCallProceeding_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_Alerting_UUIE_cryptoTokens(PAlerting_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_H323_UU_PDU_h323_message_body(H323_UU_PDU_h323_message_body *val);
static void ASN1CALL ASN1Free_H323_UU_PDU(H323_UU_PDU *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu(PInfoRequestResponse_perCallInfo_Seq_pdu *val);
static void ASN1CALL ASN1Free_H323_UserInformation(H323_UserInformation *val);

typedef ASN1PerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[2] = {
    (ASN1EncFun_t) ASN1Enc_RasMessage,
    (ASN1EncFun_t) ASN1Enc_H323_UserInformation,
};
typedef ASN1PerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[2] = {
    (ASN1DecFun_t) ASN1Dec_RasMessage,
    (ASN1DecFun_t) ASN1Dec_H323_UserInformation,
};
static const ASN1FreeFun_t freefntab[2] = {
    (ASN1FreeFun_t) ASN1Free_RasMessage,
    (ASN1FreeFun_t) ASN1Free_H323_UserInformation,
};
static const ULONG sizetab[2] = {
    SIZE_H225ASN_Module_PDU_0,
    SIZE_H225ASN_Module_PDU_1,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL H225ASN_Module_Startup(void)
{
    H225ASN_Module = ASN1_CreateModule(0x10000, ASN1_PER_RULE_ALIGNED, ASN1FLAGS_NONE, 2, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x35323268);
}

void ASN1CALL H225ASN_Module_Cleanup(void)
{
    ASN1_CloseModule(H225ASN_Module);
    H225ASN_Module = NULL;
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &val->value, 16))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &val->value, 16))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_routing(ASN1encoding_t enc, TransportAddress_ipSourceRoute_routing *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_routing(ASN1decoding_t dec, TransportAddress_ipSourceRoute_routing *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn);
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route(PTransportAddress_ipSourceRoute_route *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn(PTransportAddress_ipSourceRoute_route val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RTPSession_associatedSessionIds(ASN1encoding_t enc, PRTPSession_associatedSessionIds *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RTPSession_associatedSessionIds_ElmFn);
}

static int ASN1CALL ASN1Enc_RTPSession_associatedSessionIds_ElmFn(ASN1encoding_t enc, PRTPSession_associatedSessionIds val)
{
    if (!ASN1PEREncBitVal(enc, 8, val->value - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RTPSession_associatedSessionIds(ASN1decoding_t dec, PRTPSession_associatedSessionIds *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RTPSession_associatedSessionIds_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RTPSession_associatedSessionIds_ElmFn(ASN1decoding_t dec, PRTPSession_associatedSessionIds val)
{
    if (!ASN1PERDecU16Val(dec, 8, &val->value))
	return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_RTPSession_associatedSessionIds(PRTPSession_associatedSessionIds *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RTPSession_associatedSessionIds_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RTPSession_associatedSessionIds_ElmFn(PRTPSession_associatedSessionIds val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_preGrantedARQ(ASN1encoding_t enc, RegistrationConfirm_preGrantedARQ *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->makeCall))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->useGKCallSignalAddressToMakeCall))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->answerCall))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->useGKCallSignalAddressToAnswer))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_preGrantedARQ(ASN1decoding_t dec, RegistrationConfirm_preGrantedARQ *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->makeCall))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->useGKCallSignalAddressToMakeCall))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->answerCall))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->useGKCallSignalAddressToAnswer))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_algorithmOIDs(ASN1encoding_t enc, PGatekeeperRequest_algorithmOIDs *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_algorithmOIDs_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_algorithmOIDs_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_algorithmOIDs val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_algorithmOIDs(ASN1decoding_t dec, PGatekeeperRequest_algorithmOIDs *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_algorithmOIDs_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_algorithmOIDs_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_algorithmOIDs val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_algorithmOIDs(PGatekeeperRequest_algorithmOIDs *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_algorithmOIDs_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_algorithmOIDs_ElmFn(PGatekeeperRequest_algorithmOIDs val)
{
    if (val) {
	ASN1objectidentifier_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ip6Address(ASN1encoding_t enc, TransportAddress_ip6Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 16))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ip6Address(ASN1decoding_t dec, TransportAddress_ip6Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 16))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ip6Address(TransportAddress_ip6Address *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipxAddress(ASN1encoding_t enc, TransportAddress_ipxAddress *val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->port, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipxAddress(ASN1decoding_t dec, TransportAddress_ipxAddress *val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->port, 2))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipxAddress(TransportAddress_ipxAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute(ASN1encoding_t enc, TransportAddress_ipSourceRoute *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
	return 0;
    if (!ASN1Enc_TransportAddress_ipSourceRoute_route(enc, &(val)->route))
	return 0;
    if (!ASN1Enc_TransportAddress_ipSourceRoute_routing(enc, &(val)->routing))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute(ASN1decoding_t dec, TransportAddress_ipSourceRoute *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
	return 0;
    if (!ASN1Dec_TransportAddress_ipSourceRoute_route(dec, &(val)->route))
	return 0;
    if (!ASN1Dec_TransportAddress_ipSourceRoute_routing(dec, &(val)->routing))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute(TransportAddress_ipSourceRoute *val)
{
    if (val) {
	ASN1Free_TransportAddress_ipSourceRoute_route(&(val)->route);
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipAddress(ASN1encoding_t enc, TransportAddress_ipAddress *val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipAddress(ASN1decoding_t dec, TransportAddress_ipAddress *val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipAddress(TransportAddress_ipAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_Progress_UUIE_fastStart(ASN1encoding_t enc, PProgress_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Progress_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_Progress_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PProgress_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Progress_UUIE_fastStart(ASN1decoding_t dec, PProgress_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Progress_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Progress_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PProgress_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Progress_UUIE_fastStart(PProgress_UUIE_fastStart *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Progress_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Progress_UUIE_fastStart_ElmFn(PProgress_UUIE_fastStart val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_fastStart(ASN1encoding_t enc, PFacility_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PFacility_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_fastStart(ASN1decoding_t dec, PFacility_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PFacility_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_fastStart(PFacility_UUIE_fastStart *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_fastStart_ElmFn(PFacility_UUIE_fastStart val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_fastStart(ASN1encoding_t enc, PSetup_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PSetup_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_fastStart(ASN1decoding_t dec, PSetup_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PSetup_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_fastStart(PSetup_UUIE_fastStart *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_fastStart_ElmFn(PSetup_UUIE_fastStart val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_conferenceGoal(ASN1encoding_t enc, Setup_UUIE_conferenceGoal *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 3))
	return 0;
    return 1;
}

//nik:change to fix the bug in decoding the extension filds in the CHOICE structure.
int MyASN1PERDecComplexChoice(ASN1decoding_t dec, ASN1choice_t *pChoiceVal, ASN1int32_t cChoiceBits, ASN1choice_t ExtensionChoice)
{
    ASN1uint32_t x;
    ASN1uint16_t tempVal;

    if (ASN1PERDecExtensionBit(dec, &x))
    {
        if (!x)
        {
            *pChoiceVal = ASN1_CHOICE_BASE; // default choice
            if (cChoiceBits)
            {
                if (ASN1PERDecU16Val(dec, cChoiceBits, pChoiceVal))
                {
                    *pChoiceVal += ASN1_CHOICE_BASE;
                    return 1;
                }
                return 0;
            }
            return 1;
        }

        if (ASN1PERDecN16Val(dec, pChoiceVal))
        {
            *pChoiceVal += ExtensionChoice + ASN1_CHOICE_BASE;
            
            /*skip 2 bytes*/
            return ASN1PERDecS16Val( dec, 16, &tempVal );
        }
    }
    return 0;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_conferenceGoal(ASN1decoding_t dec, Setup_UUIE_conferenceGoal *val)
{
    //nik:
    if (!MyASN1PERDecComplexChoice(dec, &(val)->choice, 2, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCRV(ASN1encoding_t enc, PSetup_UUIE_destExtraCRV *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_destExtraCRV_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCRV_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destExtraCRV val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCRV(ASN1decoding_t dec, PSetup_UUIE_destExtraCRV *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_destExtraCRV_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCRV_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destExtraCRV val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCRV(PSetup_UUIE_destExtraCRV *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_destExtraCRV_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCRV_ElmFn(PSetup_UUIE_destExtraCRV val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_Connect_UUIE_fastStart(ASN1encoding_t enc, PConnect_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Connect_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_Connect_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PConnect_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Connect_UUIE_fastStart(ASN1decoding_t dec, PConnect_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Connect_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Connect_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PConnect_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Connect_UUIE_fastStart(PConnect_UUIE_fastStart *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Connect_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Connect_UUIE_fastStart_ElmFn(PConnect_UUIE_fastStart val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_fastStart(ASN1encoding_t enc, PCallProceeding_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CallProceeding_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_fastStart(ASN1decoding_t dec, PCallProceeding_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CallProceeding_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_fastStart(PCallProceeding_UUIE_fastStart *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CallProceeding_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_fastStart_ElmFn(PCallProceeding_UUIE_fastStart val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_fastStart(ASN1encoding_t enc, PAlerting_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Alerting_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_fastStart(ASN1decoding_t dec, PAlerting_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Alerting_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Alerting_UUIE_fastStart(PAlerting_UUIE_fastStart *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Alerting_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Alerting_UUIE_fastStart_ElmFn(PAlerting_UUIE_fastStart val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_h245Control(ASN1encoding_t enc, PH323_UU_PDU_h245Control *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H323_UU_PDU_h245Control_ElmFn);
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_h245Control_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_h245Control val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_h245Control(ASN1decoding_t dec, PH323_UU_PDU_h245Control *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H323_UU_PDU_h245Control_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_h245Control_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_h245Control val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU_h245Control(PH323_UU_PDU_h245Control *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H323_UU_PDU_h245Control_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H323_UU_PDU_h245Control_ElmFn(PH323_UU_PDU_h245Control val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_h4501SupplementaryService(ASN1encoding_t enc, PH323_UU_PDU_h4501SupplementaryService *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H323_UU_PDU_h4501SupplementaryService_ElmFn);
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_h4501SupplementaryService_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_h4501SupplementaryService val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_h4501SupplementaryService(ASN1decoding_t dec, PH323_UU_PDU_h4501SupplementaryService *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H323_UU_PDU_h4501SupplementaryService_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_h4501SupplementaryService_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_h4501SupplementaryService val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU_h4501SupplementaryService(PH323_UU_PDU_h4501SupplementaryService *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H323_UU_PDU_h4501SupplementaryService_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H323_UU_PDU_h4501SupplementaryService_ElmFn(PH323_UU_PDU_h4501SupplementaryService val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UserInformation_user_data(ASN1encoding_t enc, H323_UserInformation_user_data *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->protocol_discriminator))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->user_information, 1, 131, 8))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UserInformation_user_data(ASN1decoding_t dec, H323_UserInformation_user_data *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->protocol_discriminator))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->user_information, 1, 131, 8))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323_UserInformation_user_data(H323_UserInformation_user_data *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H235NonStandardParameter(ASN1encoding_t enc, H235NonStandardParameter *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H235NonStandardParameter(ASN1decoding_t dec, H235NonStandardParameter *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H235NonStandardParameter(H235NonStandardParameter *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->nonStandardIdentifier);
	ASN1octetstring_free(&(val)->data);
    }
}

static int ASN1CALL ASN1Enc_DHset(ASN1encoding_t enc, DHset *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, ((val)->halfkey).length))
	return 0;
    if (!ASN1PEREncBits(enc, ((val)->halfkey).length, ((val)->halfkey).value))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, ((val)->modSize).length))
	return 0;
    if (!ASN1PEREncBits(enc, ((val)->modSize).length, ((val)->modSize).value))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, ((val)->generator).length))
	return 0;
    if (!ASN1PEREncBits(enc, ((val)->generator).length, ((val)->generator).value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DHset(ASN1decoding_t dec, DHset *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &((val)->halfkey).length))
	return 0;
    if (!ASN1PERDecBits(dec, ((val)->halfkey).length, &((val)->halfkey).value))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &((val)->modSize).length))
	return 0;
    if (!ASN1PERDecBits(dec, ((val)->modSize).length, &((val)->modSize).value))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &((val)->generator).length))
	return 0;
    if (!ASN1PERDecBits(dec, ((val)->generator).length, &((val)->generator).value))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DHset(DHset *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->halfkey);
	ASN1bitstring_free(&(val)->modSize);
	ASN1bitstring_free(&(val)->generator);
    }
}

static int ASN1CALL ASN1Enc_TypedCertificate(ASN1encoding_t enc, TypedCertificate *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->type))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->certificate))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TypedCertificate(ASN1decoding_t dec, TypedCertificate *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->type))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->certificate))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TypedCertificate(TypedCertificate *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->type);
	ASN1octetstring_free(&(val)->certificate);
    }
}

static int ASN1CALL ASN1Enc_AuthenticationMechanism(ASN1encoding_t enc, AuthenticationMechanism *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Enc_H235NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AuthenticationMechanism(ASN1decoding_t dec, AuthenticationMechanism *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Dec_H235NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AuthenticationMechanism(AuthenticationMechanism *val)
{
    if (val) {
	switch ((val)->choice) {
	case 7:
	    ASN1Free_H235NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ClearToken(ASN1encoding_t enc, ClearToken *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 8, (val)->o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->tokenOID))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->timeStamp - 1);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->timeStamp - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->password).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->password).length, ((val)->password).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_DHset(enc, &(val)->dhkey))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->challenge, 8, 128, 7))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncInteger(enc, (val)->random))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_TypedCertificate(enc, &(val)->certificate))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->generalID).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->generalID).length, ((val)->generalID).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1Enc_H235NonStandardParameter(enc, &(val)->nonStandard))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ClearToken(ASN1decoding_t dec, ClearToken *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 8, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->tokenOID))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->timeStamp))
	    return 0;
	(val)->timeStamp += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->password).length))
	    return 0;
	((val)->password).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->password).length, &((val)->password).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_DHset(dec, &(val)->dhkey))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->challenge, 8, 128, 7))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecInteger(dec, &(val)->random))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_TypedCertificate(dec, &(val)->certificate))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->generalID).length))
	    return 0;
	((val)->generalID).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->generalID).length, &((val)->generalID).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1Dec_H235NonStandardParameter(dec, &(val)->nonStandard))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ClearToken(ClearToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->tokenOID);
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->password);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_DHset(&(val)->dhkey);
	}
	if ((val)->o[0] & 0x10) {
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_TypedCertificate(&(val)->certificate);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1char16string_free(&(val)->generalID);
	}
	if ((val)->o[0] & 0x1) {
	    ASN1Free_H235NonStandardParameter(&(val)->nonStandard);
	}
    }
}

static int ASN1CALL ASN1Enc_Params(ASN1encoding_t enc, Params *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncInteger(enc, (val)->ranInt))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->iv8, 8))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Params(ASN1decoding_t dec, Params *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecInteger(dec, &(val)->ranInt))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->iv8, 8))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Params(Params *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_EncodedGeneralToken(ASN1encoding_t enc, EncodedGeneralToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->id))
	return 0;
    if (!ASN1Enc_ClearToken(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncodedGeneralToken(ASN1decoding_t dec, EncodedGeneralToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->id))
	return 0;
    if (!ASN1Dec_ClearToken(dec, &(val)->type))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncodedGeneralToken(EncodedGeneralToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->id);
	ASN1Free_ClearToken(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_PwdCertToken(ASN1encoding_t enc, PwdCertToken *val)
{
    if (!ASN1Enc_ClearToken(enc, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PwdCertToken(ASN1decoding_t dec, PwdCertToken *val)
{
    if (!ASN1Dec_ClearToken(dec, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PwdCertToken(PwdCertToken *val)
{
    if (val) {
	ASN1Free_ClearToken(val);
    }
}

static int ASN1CALL ASN1Enc_EncodedPwdCertToken(ASN1encoding_t enc, EncodedPwdCertToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->id))
	return 0;
    if (!ASN1Enc_PwdCertToken(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncodedPwdCertToken(ASN1decoding_t dec, EncodedPwdCertToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->id))
	return 0;
    if (!ASN1Dec_PwdCertToken(dec, &(val)->type))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncodedPwdCertToken(EncodedPwdCertToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->id);
	ASN1Free_PwdCertToken(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_ReleaseCompleteReason(ASN1encoding_t enc, ReleaseCompleteReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 12))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ReleaseCompleteReason(ASN1decoding_t dec, ReleaseCompleteReason *val)
{
    //nik:
    if (!MyASN1PERDecComplexChoice(dec, &(val)->choice, 4, 12))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_FacilityReason(ASN1encoding_t enc, FacilityReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FacilityReason(ASN1decoding_t dec, FacilityReason *val)
{
    //nik:
    if (!MyASN1PERDecComplexChoice(dec, &(val)->choice, 2, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H221NonStandard(ASN1encoding_t enc, H221NonStandard *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35CountryCode))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35Extension))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->manufacturerCode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H221NonStandard(ASN1decoding_t dec, H221NonStandard *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35CountryCode))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35Extension))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->manufacturerCode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H225NonStandardIdentifier(ASN1encoding_t enc, H225NonStandardIdentifier *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H221NonStandard(enc, &(val)->u.h221NonStandard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardIdentifier(ASN1decoding_t dec, H225NonStandardIdentifier *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H221NonStandard(dec, &(val)->u.h221NonStandard))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardIdentifier(H225NonStandardIdentifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1objectidentifier_free(&(val)->u.object);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_PublicTypeOfNumber(ASN1encoding_t enc, PublicTypeOfNumber *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PublicTypeOfNumber(ASN1decoding_t dec, PublicTypeOfNumber *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_PrivateTypeOfNumber(ASN1encoding_t enc, PrivateTypeOfNumber *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateTypeOfNumber(ASN1decoding_t dec, PrivateTypeOfNumber *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_AltGKInfo(ASN1encoding_t enc, AltGKInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_AltGKInfo_alternateGatekeeper(enc, &(val)->alternateGatekeeper))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->altGKisPermanent))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AltGKInfo(ASN1decoding_t dec, AltGKInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_AltGKInfo_alternateGatekeeper(dec, &(val)->alternateGatekeeper))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->altGKisPermanent))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AltGKInfo(AltGKInfo *val)
{
    if (val) {
	ASN1Free_AltGKInfo_alternateGatekeeper(&(val)->alternateGatekeeper);
    }
}

static int ASN1CALL ASN1Enc_Q954Details(ASN1encoding_t enc, Q954Details *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->conferenceCalling))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->threePartyService))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Q954Details(ASN1decoding_t dec, Q954Details *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->conferenceCalling))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->threePartyService))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CallIdentifier(ASN1encoding_t enc, CallIdentifier *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->guid, 16))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallIdentifier(ASN1decoding_t dec, CallIdentifier *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->guid, 16))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CallIdentifier(CallIdentifier *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ICV(ASN1encoding_t enc, ICV *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
	return 0;
    if (!ASN1PEREncFragmented(enc, ((val)->icv).length, ((val)->icv).value, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ICV(ASN1decoding_t dec, ICV *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
	return 0;
    if (!ASN1PERDecFragmented(dec, &((val)->icv).length, &((val)->icv).value, 1))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ICV(ICV *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->algorithmOID);
	ASN1bitstring_free(&(val)->icv);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRejectReason(ASN1encoding_t enc, GatekeeperRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRejectReason(ASN1decoding_t dec, GatekeeperRejectReason *val)
{
    //nik:
    if (!MyASN1PERDecComplexChoice(dec, &(val)->choice, 2, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RegistrationRejectReason(ASN1encoding_t enc, RegistrationRejectReason *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 8))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Enc_RegistrationRejectReason_duplicateAlias(enc, &(val)->u.duplicateAlias))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 10:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRejectReason(ASN1decoding_t dec, RegistrationRejectReason *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 8))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Dec_RegistrationRejectReason_duplicateAlias(dec, &(val)->u.duplicateAlias))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 10:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRejectReason(RegistrationRejectReason *val)
{
    if (val) {
	switch ((val)->choice) {
	case 5:
	    ASN1Free_RegistrationRejectReason_duplicateAlias(&(val)->u.duplicateAlias);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_UnregRequestReason(ASN1encoding_t enc, UnregRequestReason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregRequestReason(ASN1decoding_t dec, UnregRequestReason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_UnregRejectReason(ASN1encoding_t enc, UnregRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregRejectReason(ASN1decoding_t dec, UnregRejectReason *val)
{
    //nik:
    if (!MyASN1PERDecComplexChoice(dec, &(val)->choice, 2, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CallType(ASN1encoding_t enc, CallType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallType(ASN1decoding_t dec, CallType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CallModel(ASN1encoding_t enc, CallModel *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallModel(ASN1decoding_t dec, CallModel *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TransportQOS(ASN1encoding_t enc, TransportQOS *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportQOS(ASN1decoding_t dec, TransportQOS *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_UUIEsRequested(ASN1encoding_t enc, UUIEsRequested *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->setup))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->callProceeding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->connect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alerting))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->information))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->releaseComplete))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->facility))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->progress))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->empty))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UUIEsRequested(ASN1decoding_t dec, UUIEsRequested *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->setup))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->callProceeding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->connect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alerting))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->information))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->releaseComplete))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->facility))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->progress))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->empty))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_AdmissionRejectReason(ASN1encoding_t enc, AdmissionRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 8))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRejectReason(ASN1decoding_t dec, AdmissionRejectReason *val)
{
    //nik:
    if (!MyASN1PERDecComplexChoice(dec, &(val)->choice, 3, 8))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_BandRejectReason(ASN1encoding_t enc, BandRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 6))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandRejectReason(ASN1decoding_t dec, BandRejectReason *val)
{
    //nik:
    if (!MyASN1PERDecComplexChoice(dec, &(val)->choice, 3, 6))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_LocationRejectReason(ASN1encoding_t enc, LocationRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRejectReason(ASN1decoding_t dec, LocationRejectReason *val)
{
    //nik:
    if (!MyASN1PERDecComplexChoice(dec, &(val)->choice, 2, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_DisengageReason(ASN1encoding_t enc, DisengageReason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageReason(ASN1decoding_t dec, DisengageReason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_DisengageRejectReason(ASN1encoding_t enc, DisengageRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageRejectReason(ASN1decoding_t dec, DisengageRejectReason *val)
{
    //nik:
    if (!MyASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_InfoRequestNakReason(ASN1encoding_t enc, InfoRequestNakReason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestNakReason(ASN1decoding_t dec, InfoRequestNakReason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_UnknownMessageResponse(ASN1encoding_t enc, UnknownMessageResponse *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1Enc_UnknownMessageResponse_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1Enc_UnknownMessageResponse_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[0] & 0x20) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UnknownMessageResponse(ASN1decoding_t dec, UnknownMessageResponse *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_UnknownMessageResponse_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_UnknownMessageResponse_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[0] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnknownMessageResponse(UnknownMessageResponse *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_UnknownMessageResponse_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_UnknownMessageResponse_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens(PInfoRequestResponse_perCallInfo_Seq_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(PInfoRequestResponse_perCallInfo_Seq_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_tokens(ASN1encoding_t enc, PResourcesAvailableConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ResourcesAvailableConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_tokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_tokens(ASN1decoding_t dec, PResourcesAvailableConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ResourcesAvailableConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_tokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_tokens(PResourcesAvailableConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ResourcesAvailableConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_tokens_ElmFn(PResourcesAvailableConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_tokens(ASN1encoding_t enc, PResourcesAvailableIndicate_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ResourcesAvailableIndicate_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_tokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_tokens(ASN1decoding_t dec, PResourcesAvailableIndicate_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ResourcesAvailableIndicate_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_tokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_tokens(PResourcesAvailableIndicate_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ResourcesAvailableIndicate_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_tokens_ElmFn(PResourcesAvailableIndicate_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RequestInProgress_tokens(ASN1encoding_t enc, PRequestInProgress_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RequestInProgress_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RequestInProgress_tokens_ElmFn(ASN1encoding_t enc, PRequestInProgress_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestInProgress_tokens(ASN1decoding_t dec, PRequestInProgress_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RequestInProgress_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RequestInProgress_tokens_ElmFn(ASN1decoding_t dec, PRequestInProgress_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RequestInProgress_tokens(PRequestInProgress_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RequestInProgress_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RequestInProgress_tokens_ElmFn(PRequestInProgress_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnknownMessageResponse_tokens(ASN1encoding_t enc, PUnknownMessageResponse_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnknownMessageResponse_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnknownMessageResponse_tokens_ElmFn(ASN1encoding_t enc, PUnknownMessageResponse_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnknownMessageResponse_tokens(ASN1decoding_t dec, PUnknownMessageResponse_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnknownMessageResponse_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnknownMessageResponse_tokens_ElmFn(ASN1decoding_t dec, PUnknownMessageResponse_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnknownMessageResponse_tokens(PUnknownMessageResponse_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnknownMessageResponse_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnknownMessageResponse_tokens_ElmFn(PUnknownMessageResponse_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H225NonStandardMessage_tokens(ASN1encoding_t enc, PH225NonStandardMessage_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H225NonStandardMessage_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_H225NonStandardMessage_tokens_ElmFn(ASN1encoding_t enc, PH225NonStandardMessage_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardMessage_tokens(ASN1decoding_t dec, PH225NonStandardMessage_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H225NonStandardMessage_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H225NonStandardMessage_tokens_ElmFn(ASN1decoding_t dec, PH225NonStandardMessage_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardMessage_tokens(PH225NonStandardMessage_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H225NonStandardMessage_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H225NonStandardMessage_tokens_ElmFn(PH225NonStandardMessage_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestNak_tokens(ASN1encoding_t enc, PInfoRequestNak_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestNak_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestNak_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestNak_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestNak_tokens(ASN1decoding_t dec, PInfoRequestNak_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestNak_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestNak_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestNak_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestNak_tokens(PInfoRequestNak_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestNak_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestNak_tokens_ElmFn(PInfoRequestNak_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestAck_tokens(ASN1encoding_t enc, PInfoRequestAck_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestAck_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestAck_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestAck_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestAck_tokens(ASN1decoding_t dec, PInfoRequestAck_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestAck_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestAck_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestAck_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestAck_tokens(PInfoRequestAck_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestAck_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestAck_tokens_ElmFn(PInfoRequestAck_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_tokens(ASN1encoding_t enc, PInfoRequestResponse_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_tokens(ASN1decoding_t dec, PInfoRequestResponse_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_tokens(PInfoRequestResponse_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_tokens_ElmFn(PInfoRequestResponse_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequest_tokens(ASN1encoding_t enc, PInfoRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequest_tokens_ElmFn(ASN1encoding_t enc, PInfoRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequest_tokens(ASN1decoding_t dec, PInfoRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequest_tokens_ElmFn(ASN1decoding_t dec, PInfoRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequest_tokens(PInfoRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequest_tokens_ElmFn(PInfoRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageReject_tokens(ASN1encoding_t enc, PDisengageReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageReject_tokens_ElmFn(ASN1encoding_t enc, PDisengageReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageReject_tokens(ASN1decoding_t dec, PDisengageReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageReject_tokens_ElmFn(ASN1decoding_t dec, PDisengageReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageReject_tokens(PDisengageReject_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageReject_tokens_ElmFn(PDisengageReject_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageConfirm_tokens(ASN1encoding_t enc, PDisengageConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageConfirm_tokens_ElmFn(ASN1encoding_t enc, PDisengageConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageConfirm_tokens(ASN1decoding_t dec, PDisengageConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageConfirm_tokens_ElmFn(ASN1decoding_t dec, PDisengageConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageConfirm_tokens(PDisengageConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageConfirm_tokens_ElmFn(PDisengageConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageRequest_tokens(ASN1encoding_t enc, PDisengageRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageRequest_tokens_ElmFn(ASN1encoding_t enc, PDisengageRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageRequest_tokens(ASN1decoding_t dec, PDisengageRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageRequest_tokens_ElmFn(ASN1decoding_t dec, PDisengageRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageRequest_tokens(PDisengageRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageRequest_tokens_ElmFn(PDisengageRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationReject_tokens(ASN1encoding_t enc, PLocationReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationReject_tokens_ElmFn(ASN1encoding_t enc, PLocationReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationReject_tokens(ASN1decoding_t dec, PLocationReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationReject_tokens_ElmFn(ASN1decoding_t dec, PLocationReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationReject_tokens(PLocationReject_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationReject_tokens_ElmFn(PLocationReject_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_tokens(ASN1encoding_t enc, PLocationConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_tokens_ElmFn(ASN1encoding_t enc, PLocationConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_tokens(ASN1decoding_t dec, PLocationConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_tokens_ElmFn(ASN1decoding_t dec, PLocationConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_tokens(PLocationConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_tokens_ElmFn(PLocationConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationRequest_tokens(ASN1encoding_t enc, PLocationRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationRequest_tokens_ElmFn(ASN1encoding_t enc, PLocationRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRequest_tokens(ASN1decoding_t dec, PLocationRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationRequest_tokens_ElmFn(ASN1decoding_t dec, PLocationRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationRequest_tokens(PLocationRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationRequest_tokens_ElmFn(PLocationRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthReject_tokens(ASN1encoding_t enc, PBandwidthReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthReject_tokens_ElmFn(ASN1encoding_t enc, PBandwidthReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthReject_tokens(ASN1decoding_t dec, PBandwidthReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthReject_tokens_ElmFn(ASN1decoding_t dec, PBandwidthReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthReject_tokens(PBandwidthReject_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthReject_tokens_ElmFn(PBandwidthReject_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthConfirm_tokens(ASN1encoding_t enc, PBandwidthConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthConfirm_tokens_ElmFn(ASN1encoding_t enc, PBandwidthConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthConfirm_tokens(ASN1decoding_t dec, PBandwidthConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthConfirm_tokens_ElmFn(ASN1decoding_t dec, PBandwidthConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthConfirm_tokens(PBandwidthConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthConfirm_tokens_ElmFn(PBandwidthConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthRequest_tokens(ASN1encoding_t enc, PBandwidthRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthRequest_tokens_ElmFn(ASN1encoding_t enc, PBandwidthRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthRequest_tokens(ASN1decoding_t dec, PBandwidthRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthRequest_tokens_ElmFn(ASN1decoding_t dec, PBandwidthRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthRequest_tokens(PBandwidthRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthRequest_tokens_ElmFn(PBandwidthRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionReject_tokens(ASN1encoding_t enc, PAdmissionReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionReject_tokens_ElmFn(ASN1encoding_t enc, PAdmissionReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionReject_tokens(ASN1decoding_t dec, PAdmissionReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionReject_tokens_ElmFn(ASN1decoding_t dec, PAdmissionReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionReject_tokens(PAdmissionReject_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionReject_tokens_ElmFn(PAdmissionReject_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_tokens(ASN1encoding_t enc, PAdmissionConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_tokens_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_tokens(ASN1decoding_t dec, PAdmissionConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_tokens_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_tokens(PAdmissionConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_tokens_ElmFn(PAdmissionConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_tokens(ASN1encoding_t enc, PAdmissionRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_tokens_ElmFn(ASN1encoding_t enc, PAdmissionRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_tokens(ASN1decoding_t dec, PAdmissionRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_tokens_ElmFn(ASN1decoding_t dec, PAdmissionRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_tokens(PAdmissionRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_tokens_ElmFn(PAdmissionRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationReject_tokens(ASN1encoding_t enc, PUnregistrationReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationReject_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationReject_tokens(ASN1decoding_t dec, PUnregistrationReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationReject_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationReject_tokens(PUnregistrationReject_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationReject_tokens_ElmFn(PUnregistrationReject_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationConfirm_tokens(ASN1encoding_t enc, PUnregistrationConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationConfirm_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationConfirm_tokens(ASN1decoding_t dec, PUnregistrationConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationConfirm_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationConfirm_tokens(PUnregistrationConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationConfirm_tokens_ElmFn(PUnregistrationConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_tokens(ASN1encoding_t enc, PUnregistrationRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_tokens(ASN1decoding_t dec, PUnregistrationRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest_tokens(PUnregistrationRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationRequest_tokens_ElmFn(PUnregistrationRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationReject_tokens(ASN1encoding_t enc, PRegistrationReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationReject_tokens_ElmFn(ASN1encoding_t enc, PRegistrationReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationReject_tokens(ASN1decoding_t dec, PRegistrationReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationReject_tokens_ElmFn(ASN1decoding_t dec, PRegistrationReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationReject_tokens(PRegistrationReject_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationReject_tokens_ElmFn(PRegistrationReject_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_tokens(ASN1encoding_t enc, PRegistrationConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_tokens_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_tokens(ASN1decoding_t dec, PRegistrationConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_tokens_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm_tokens(PRegistrationConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationConfirm_tokens_ElmFn(PRegistrationConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_tokens(ASN1encoding_t enc, PRegistrationRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_tokens_ElmFn(ASN1encoding_t enc, PRegistrationRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_tokens(ASN1decoding_t dec, PRegistrationRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_tokens_ElmFn(ASN1decoding_t dec, PRegistrationRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_tokens(PRegistrationRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_tokens_ElmFn(PRegistrationRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperReject_tokens(ASN1encoding_t enc, PGatekeeperReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperReject_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperReject_tokens(ASN1decoding_t dec, PGatekeeperReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperReject_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperReject_tokens(PGatekeeperReject_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperReject_tokens_ElmFn(PGatekeeperReject_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_tokens(ASN1encoding_t enc, PGatekeeperConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_tokens(ASN1decoding_t dec, PGatekeeperConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_tokens(PGatekeeperConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_tokens_ElmFn(PGatekeeperConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_authenticationCapability(ASN1encoding_t enc, PGatekeeperRequest_authenticationCapability *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_authenticationCapability_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_authenticationCapability_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_authenticationCapability val)
{
    if (!ASN1Enc_AuthenticationMechanism(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_authenticationCapability(ASN1decoding_t dec, PGatekeeperRequest_authenticationCapability *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_authenticationCapability_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_authenticationCapability_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_authenticationCapability val)
{
    if (!ASN1Dec_AuthenticationMechanism(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_authenticationCapability(PGatekeeperRequest_authenticationCapability *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_authenticationCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_authenticationCapability_ElmFn(PGatekeeperRequest_authenticationCapability val)
{
    if (val) {
	ASN1Free_AuthenticationMechanism(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_tokens(ASN1encoding_t enc, PGatekeeperRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_tokens(ASN1decoding_t dec, PGatekeeperRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_tokens(PGatekeeperRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_tokens_ElmFn(PGatekeeperRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_tokens(ASN1encoding_t enc, PEndpoint_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_tokens_ElmFn(ASN1encoding_t enc, PEndpoint_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_tokens(ASN1decoding_t dec, PEndpoint_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_tokens_ElmFn(ASN1decoding_t dec, PEndpoint_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_tokens(PEndpoint_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_tokens_ElmFn(PEndpoint_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Progress_UUIE_tokens(ASN1encoding_t enc, PProgress_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Progress_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Progress_UUIE_tokens_ElmFn(ASN1encoding_t enc, PProgress_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Progress_UUIE_tokens(ASN1decoding_t dec, PProgress_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Progress_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Progress_UUIE_tokens_ElmFn(ASN1decoding_t dec, PProgress_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Progress_UUIE_tokens(PProgress_UUIE_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Progress_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Progress_UUIE_tokens_ElmFn(PProgress_UUIE_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_tokens(ASN1encoding_t enc, PFacility_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_tokens_ElmFn(ASN1encoding_t enc, PFacility_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_tokens(ASN1decoding_t dec, PFacility_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_tokens_ElmFn(ASN1decoding_t dec, PFacility_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_tokens(PFacility_UUIE_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_tokens_ElmFn(PFacility_UUIE_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_tokens(ASN1encoding_t enc, PSetup_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_tokens_ElmFn(ASN1encoding_t enc, PSetup_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_tokens(ASN1decoding_t dec, PSetup_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_tokens_ElmFn(ASN1decoding_t dec, PSetup_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_tokens(PSetup_UUIE_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_tokens_ElmFn(PSetup_UUIE_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Connect_UUIE_tokens(ASN1encoding_t enc, PConnect_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Connect_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Connect_UUIE_tokens_ElmFn(ASN1encoding_t enc, PConnect_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Connect_UUIE_tokens(ASN1decoding_t dec, PConnect_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Connect_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Connect_UUIE_tokens_ElmFn(ASN1decoding_t dec, PConnect_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Connect_UUIE_tokens(PConnect_UUIE_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Connect_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Connect_UUIE_tokens_ElmFn(PConnect_UUIE_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_tokens(ASN1encoding_t enc, PCallProceeding_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CallProceeding_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_tokens_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_tokens(ASN1decoding_t dec, PCallProceeding_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CallProceeding_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_tokens_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_tokens(PCallProceeding_UUIE_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CallProceeding_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_tokens_ElmFn(PCallProceeding_UUIE_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_tokens(ASN1encoding_t enc, PAlerting_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Alerting_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_tokens_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_tokens(ASN1decoding_t dec, PAlerting_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Alerting_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_tokens_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Alerting_UUIE_tokens(PAlerting_UUIE_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Alerting_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Alerting_UUIE_tokens_ElmFn(PAlerting_UUIE_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SIGNED_EncodedGeneralToken(ASN1encoding_t enc, SIGNED_EncodedGeneralToken *val)
{
    if (!ASN1Enc_EncodedGeneralToken(enc, &(val)->toBeSigned))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
	return 0;
    if (!ASN1Enc_Params(enc, &(val)->paramS))
	return 0;
    if (!ASN1PEREncFragmented(enc, ((val)->signature).length, ((val)->signature).value, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SIGNED_EncodedGeneralToken(ASN1decoding_t dec, SIGNED_EncodedGeneralToken *val)
{
    if (!ASN1Dec_EncodedGeneralToken(dec, &(val)->toBeSigned))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
	return 0;
    if (!ASN1Dec_Params(dec, &(val)->paramS))
	return 0;
    if (!ASN1PERDecFragmented(dec, &((val)->signature).length, &((val)->signature).value, 1))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SIGNED_EncodedGeneralToken(SIGNED_EncodedGeneralToken *val)
{
    if (val) {
	ASN1Free_EncodedGeneralToken(&(val)->toBeSigned);
	ASN1objectidentifier_free(&(val)->algorithmOID);
	ASN1Free_Params(&(val)->paramS);
	ASN1bitstring_free(&(val)->signature);
    }
}

static int ASN1CALL ASN1Enc_ENCRYPTED(ASN1encoding_t enc, ENCRYPTED *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
	return 0;
    if (!ASN1Enc_Params(enc, &(val)->paramS))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->encryptedData))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ENCRYPTED(ASN1decoding_t dec, ENCRYPTED *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
	return 0;
    if (!ASN1Dec_Params(dec, &(val)->paramS))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->encryptedData))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ENCRYPTED(ENCRYPTED *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->algorithmOID);
	ASN1Free_Params(&(val)->paramS);
	ASN1octetstring_free(&(val)->encryptedData);
    }
}

static int ASN1CALL ASN1Enc_HASHED(ASN1encoding_t enc, HASHED *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
	return 0;
    if (!ASN1Enc_Params(enc, &(val)->paramS))
	return 0;
    if (!ASN1PEREncFragmented(enc, ((val)->hash).length, ((val)->hash).value, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_HASHED(ASN1decoding_t dec, HASHED *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
	return 0;
    if (!ASN1Dec_Params(dec, &(val)->paramS))
	return 0;
    if (!ASN1PERDecFragmented(dec, &((val)->hash).length, &((val)->hash).value, 1))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_HASHED(HASHED *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->algorithmOID);
	ASN1Free_Params(&(val)->paramS);
	ASN1bitstring_free(&(val)->hash);
    }
}

static int ASN1CALL ASN1Enc_SIGNED_EncodedPwdCertToken(ASN1encoding_t enc, SIGNED_EncodedPwdCertToken *val)
{
    if (!ASN1Enc_EncodedPwdCertToken(enc, &(val)->toBeSigned))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
	return 0;
    if (!ASN1Enc_Params(enc, &(val)->paramS))
	return 0;
    if (!ASN1PEREncFragmented(enc, ((val)->signature).length, ((val)->signature).value, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SIGNED_EncodedPwdCertToken(ASN1decoding_t dec, SIGNED_EncodedPwdCertToken *val)
{
    if (!ASN1Dec_EncodedPwdCertToken(dec, &(val)->toBeSigned))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
	return 0;
    if (!ASN1Dec_Params(dec, &(val)->paramS))
	return 0;
    if (!ASN1PERDecFragmented(dec, &((val)->signature).length, &((val)->signature).value, 1))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SIGNED_EncodedPwdCertToken(SIGNED_EncodedPwdCertToken *val)
{
    if (val) {
	ASN1Free_EncodedPwdCertToken(&(val)->toBeSigned);
	ASN1objectidentifier_free(&(val)->algorithmOID);
	ASN1Free_Params(&(val)->paramS);
	ASN1bitstring_free(&(val)->signature);
    }
}

static int ASN1CALL ASN1Enc_Information_UUIE(ASN1encoding_t enc, Information_UUIE *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x80;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Information_UUIE(ASN1decoding_t dec, Information_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_Information_UUIE(Information_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
    }
}

static int ASN1CALL ASN1Enc_ReleaseComplete_UUIE(ASN1encoding_t enc, ReleaseComplete_UUIE *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_ReleaseCompleteReason(enc, &(val)->reason))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ReleaseComplete_UUIE(ASN1decoding_t dec, ReleaseComplete_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ReleaseCompleteReason(dec, &(val)->reason))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_ReleaseComplete_UUIE(ReleaseComplete_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
    }
}

static int ASN1CALL ASN1Enc_VendorIdentifier(ASN1encoding_t enc, VendorIdentifier *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_H221NonStandard(enc, &(val)->vendor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->productId, 1, 256, 8))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->versionId, 1, 256, 8))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VendorIdentifier(ASN1decoding_t dec, VendorIdentifier *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_H221NonStandard(dec, &(val)->vendor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->productId, 1, 256, 8))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->versionId, 1, 256, 8))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_VendorIdentifier(VendorIdentifier *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_H225NonStandardParameter(ASN1encoding_t enc, H225NonStandardParameter *val)
{
    if (!ASN1Enc_H225NonStandardIdentifier(enc, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardParameter(ASN1decoding_t dec, H225NonStandardParameter *val)
{
    if (!ASN1Dec_H225NonStandardIdentifier(dec, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardParameter(H225NonStandardParameter *val)
{
    if (val) {
	ASN1Free_H225NonStandardIdentifier(&(val)->nonStandardIdentifier);
	ASN1octetstring_free(&(val)->data);
    }
}

static ASN1stringtableentry_t PublicPartyNumber_publicNumberDigits_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PublicPartyNumber_publicNumberDigits_StringTable = {
    4, PublicPartyNumber_publicNumberDigits_StringTableEntries
};

static int ASN1CALL ASN1Enc_PublicPartyNumber(ASN1encoding_t enc, PublicPartyNumber *val)
{
    ASN1uint32_t t;
    if (!ASN1Enc_PublicTypeOfNumber(enc, &(val)->publicTypeOfNumber))
	return 0;
    t = lstrlenA((val)->publicNumberDigits);
    if (!ASN1PEREncBitVal(enc, 7, t - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->publicNumberDigits, 4, &PublicPartyNumber_publicNumberDigits_StringTable))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PublicPartyNumber(ASN1decoding_t dec, PublicPartyNumber *val)
{
    ASN1uint32_t l;
    if (!ASN1Dec_PublicTypeOfNumber(dec, &(val)->publicTypeOfNumber))
	return 0;
    if (!ASN1PERDecU32Val(dec, 7, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->publicNumberDigits, 4, &PublicPartyNumber_publicNumberDigits_StringTable))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PublicPartyNumber(PublicPartyNumber *val)
{
    if (val) {
    }
}

static ASN1stringtableentry_t PrivatePartyNumber_privateNumberDigits_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PrivatePartyNumber_privateNumberDigits_StringTable = {
    4, PrivatePartyNumber_privateNumberDigits_StringTableEntries
};

static int ASN1CALL ASN1Enc_PrivatePartyNumber(ASN1encoding_t enc, PrivatePartyNumber *val)
{
    ASN1uint32_t t;
    if (!ASN1Enc_PrivateTypeOfNumber(enc, &(val)->privateTypeOfNumber))
	return 0;
    t = lstrlenA((val)->privateNumberDigits);
    if (!ASN1PEREncBitVal(enc, 7, t - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->privateNumberDigits, 4, &PrivatePartyNumber_privateNumberDigits_StringTable))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivatePartyNumber(ASN1decoding_t dec, PrivatePartyNumber *val)
{
    ASN1uint32_t l;
    if (!ASN1Dec_PrivateTypeOfNumber(dec, &(val)->privateTypeOfNumber))
	return 0;
    if (!ASN1PERDecU32Val(dec, 7, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->privateNumberDigits, 4, &PrivatePartyNumber_privateNumberDigits_StringTable))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivatePartyNumber(PrivatePartyNumber *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SecurityServiceMode(ASN1encoding_t enc, SecurityServiceMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SecurityServiceMode(ASN1decoding_t dec, SecurityServiceMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SecurityServiceMode(SecurityServiceMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_SecurityCapabilities(ASN1encoding_t enc, SecurityCapabilities *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandard))
	    return 0;
    }
    if (!ASN1Enc_SecurityServiceMode(enc, &(val)->encryption))
	return 0;
    if (!ASN1Enc_SecurityServiceMode(enc, &(val)->authenticaton))
	return 0;
    if (!ASN1Enc_SecurityServiceMode(enc, &(val)->integrity))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SecurityCapabilities(ASN1decoding_t dec, SecurityCapabilities *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandard))
	    return 0;
    }
    if (!ASN1Dec_SecurityServiceMode(dec, &(val)->encryption))
	return 0;
    if (!ASN1Dec_SecurityServiceMode(dec, &(val)->authenticaton))
	return 0;
    if (!ASN1Dec_SecurityServiceMode(dec, &(val)->integrity))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SecurityCapabilities(SecurityCapabilities *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandard);
	}
	ASN1Free_SecurityServiceMode(&(val)->encryption);
	ASN1Free_SecurityServiceMode(&(val)->authenticaton);
	ASN1Free_SecurityServiceMode(&(val)->integrity);
    }
}

static int ASN1CALL ASN1Enc_H245Security(ASN1encoding_t enc, H245Security *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_SecurityCapabilities(enc, &(val)->u.tls))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_SecurityCapabilities(enc, &(val)->u.ipsec))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H245Security(ASN1decoding_t dec, H245Security *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_SecurityCapabilities(dec, &(val)->u.tls))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_SecurityCapabilities(dec, &(val)->u.ipsec))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H245Security(H245Security *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 3:
	    ASN1Free_SecurityCapabilities(&(val)->u.tls);
	    break;
	case 4:
	    ASN1Free_SecurityCapabilities(&(val)->u.ipsec);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_QseriesOptions(ASN1encoding_t enc, QseriesOptions *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q932Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q951Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q952Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q953Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q955Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q956Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q957Full))
	return 0;
    if (!ASN1Enc_Q954Details(enc, &(val)->q954Info))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_QseriesOptions(ASN1decoding_t dec, QseriesOptions *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q932Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q951Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q952Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q953Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q955Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q956Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q957Full))
	return 0;
    if (!ASN1Dec_Q954Details(dec, &(val)->q954Info))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_EncryptIntAlg(ASN1encoding_t enc, EncryptIntAlg *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.isoAlgorithm))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptIntAlg(ASN1decoding_t dec, EncryptIntAlg *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.isoAlgorithm))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptIntAlg(EncryptIntAlg *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1objectidentifier_free(&(val)->u.isoAlgorithm);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_NonIsoIntegrityMechanism(ASN1encoding_t enc, NonIsoIntegrityMechanism *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_EncryptIntAlg(enc, &(val)->u.hMAC_iso10118_2_s))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_EncryptIntAlg(enc, &(val)->u.hMAC_iso10118_2_l))
	    return 0;
	break;
    case 4:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.hMAC_iso10118_3))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NonIsoIntegrityMechanism(ASN1decoding_t dec, NonIsoIntegrityMechanism *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_EncryptIntAlg(dec, &(val)->u.hMAC_iso10118_2_s))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_EncryptIntAlg(dec, &(val)->u.hMAC_iso10118_2_l))
	    return 0;
	break;
    case 4:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.hMAC_iso10118_3))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonIsoIntegrityMechanism(NonIsoIntegrityMechanism *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_EncryptIntAlg(&(val)->u.hMAC_iso10118_2_s);
	    break;
	case 3:
	    ASN1Free_EncryptIntAlg(&(val)->u.hMAC_iso10118_2_l);
	    break;
	case 4:
	    ASN1objectidentifier_free(&(val)->u.hMAC_iso10118_3);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_IntegrityMechanism(ASN1encoding_t enc, IntegrityMechanism *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.iso9797))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_NonIsoIntegrityMechanism(enc, &(val)->u.nonIsoIM))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IntegrityMechanism(ASN1decoding_t dec, IntegrityMechanism *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.iso9797))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_NonIsoIntegrityMechanism(dec, &(val)->u.nonIsoIM))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_IntegrityMechanism(IntegrityMechanism *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 3:
	    ASN1objectidentifier_free(&(val)->u.iso9797);
	    break;
	case 4:
	    ASN1Free_NonIsoIntegrityMechanism(&(val)->u.nonIsoIM);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EncodedFastStartToken(ASN1encoding_t enc, EncodedFastStartToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->id))
	return 0;
    if (!ASN1Enc_FastStartToken(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncodedFastStartToken(ASN1decoding_t dec, EncodedFastStartToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->id))
	return 0;
    if (!ASN1Dec_FastStartToken(dec, &(val)->type))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncodedFastStartToken(EncodedFastStartToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->id);
	ASN1Free_FastStartToken(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_DataRate(ASN1encoding_t enc, DataRate *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    l = ASN1uint32_uoctets((val)->channelRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->channelRate))
	return 0;
    if ((val)->o[0] & 0x40) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->channelMultiplier - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataRate(ASN1decoding_t dec, DataRate *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->channelRate))
	return 0;
    if ((val)->o[0] & 0x40) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->channelMultiplier))
	    return 0;
	(val)->channelMultiplier += 1;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataRate(DataRate *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_GatekeeperReject(ASN1encoding_t enc, GatekeeperReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Enc_GatekeeperRejectReason(enc, &(val)->rejectReason))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_GatekeeperReject_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_GatekeeperReject_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperReject(ASN1decoding_t dec, GatekeeperReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
	    return 0;
	((val)->gatekeeperIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Dec_GatekeeperRejectReason(dec, &(val)->rejectReason))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperReject_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperReject_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperReject(GatekeeperReject *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_GatekeeperReject_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_GatekeeperReject_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm(ASN1encoding_t enc, RegistrationConfirm *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    ASN1uint32_t l;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x4;
    y = ASN1PEREncCheckExtensions(7, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 3, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Enc_RegistrationConfirm_callSignalAddress(enc, &(val)->callSignalAddress))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1Enc_RegistrationConfirm_terminalAlias(enc, &(val)->terminalAlias))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 7, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_RegistrationConfirm_alternateGatekeeper(ee, &(val)->alternateGatekeeper))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    l = ASN1uint32_uoctets((val)->timeToLive - 1);
	    if (!ASN1PEREncBitVal(ee, 2, l - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncBitVal(ee, l * 8, (val)->timeToLive - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_RegistrationConfirm_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_RegistrationConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1PEREncBoolean(ee, (val)->willRespondToIRR))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x2) {
	    if (!ASN1Enc_RegistrationConfirm_preGrantedARQ(ee, &(val)->preGrantedARQ))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm(ASN1decoding_t dec, RegistrationConfirm *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t l;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Dec_RegistrationConfirm_callSignalAddress(dec, &(val)->callSignalAddress))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_RegistrationConfirm_terminalAlias(dec, &(val)->terminalAlias))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
	    return 0;
	((val)->gatekeeperIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 7, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationConfirm_alternateGatekeeper(dd, &(val)->alternateGatekeeper))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 2, &l))
		return 0;
	    l += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecU32Val(dd, l * 8, &(val)->timeToLive))
		return 0;
	    (val)->timeToLive += 1;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationConfirm_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->willRespondToIRR))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationConfirm_preGrantedARQ(dd, &(val)->preGrantedARQ))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm(RegistrationConfirm *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1Free_RegistrationConfirm_callSignalAddress(&(val)->callSignalAddress);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_RegistrationConfirm_terminalAlias(&(val)->terminalAlias);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	ASN1char16string_free(&(val)->endpointIdentifier);
	if ((val)->o[1] & 0x80) {
	    ASN1Free_RegistrationConfirm_alternateGatekeeper(&(val)->alternateGatekeeper);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_RegistrationConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_RegistrationConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_RegistrationReject(ASN1encoding_t enc, RegistrationReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Enc_RegistrationRejectReason(enc, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_RegistrationReject_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_RegistrationReject_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationReject(ASN1decoding_t dec, RegistrationReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Dec_RegistrationRejectReason(dec, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
	    return 0;
	((val)->gatekeeperIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationReject_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationReject_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationReject(RegistrationReject *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1Free_RegistrationRejectReason(&(val)->rejectReason);
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_RegistrationReject_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_RegistrationReject_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest(ASN1encoding_t enc, UnregistrationRequest *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(6, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_UnregistrationRequest_callSignalAddress(enc, &(val)->callSignalAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_UnregistrationRequest_endpointAlias(enc, &(val)->endpointAlias))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 6, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_UnregistrationRequest_alternateEndpoints(ee, &(val)->alternateEndpoints))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PEREncBitVal(ee, 7, ((val)->gatekeeperIdentifier).length - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncChar16String(ee, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_UnregistrationRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_UnregistrationRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1Enc_UnregRequestReason(ee, &(val)->reason))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest(ASN1decoding_t dec, UnregistrationRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_UnregistrationRequest_callSignalAddress(dec, &(val)->callSignalAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_UnregistrationRequest_endpointAlias(dec, &(val)->endpointAlias))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	    return 0;
	((val)->endpointIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 6, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_UnregistrationRequest_alternateEndpoints(dd, &(val)->alternateEndpoints))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 7, &((val)->gatekeeperIdentifier).length))
		return 0;
	    ((val)->gatekeeperIdentifier).length += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecChar16String(dd, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_UnregistrationRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_UnregistrationRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_UnregRequestReason(dd, &(val)->reason))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest(UnregistrationRequest *val)
{
    if (val) {
	ASN1Free_UnregistrationRequest_callSignalAddress(&(val)->callSignalAddress);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_UnregistrationRequest_endpointAlias(&(val)->endpointAlias);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1char16string_free(&(val)->endpointIdentifier);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_UnregistrationRequest_alternateEndpoints(&(val)->alternateEndpoints);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_UnregistrationRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_UnregistrationRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_UnregistrationConfirm(ASN1encoding_t enc, UnregistrationConfirm *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_UnregistrationConfirm_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_UnregistrationConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationConfirm(ASN1decoding_t dec, UnregistrationConfirm *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_UnregistrationConfirm_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_UnregistrationConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationConfirm(UnregistrationConfirm *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_UnregistrationConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_UnregistrationConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_UnregistrationReject(ASN1encoding_t enc, UnregistrationReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_UnregRejectReason(enc, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_UnregistrationReject_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_UnregistrationReject_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationReject(ASN1decoding_t dec, UnregistrationReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_UnregRejectReason(dec, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_UnregistrationReject_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_UnregistrationReject_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationReject(UnregistrationReject *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_UnregistrationReject_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_UnregistrationReject_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_AdmissionReject(ASN1encoding_t enc, AdmissionReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_AdmissionRejectReason(enc, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 5, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_AdmissionReject_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_AdmissionReject_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_AdmissionReject_callSignalAddress(ee, &(val)->callSignalAddress))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionReject(ASN1decoding_t dec, AdmissionReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_AdmissionRejectReason(dec, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionReject_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionReject_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionReject_callSignalAddress(dd, &(val)->callSignalAddress))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionReject(AdmissionReject *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_AdmissionReject_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_AdmissionReject_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_AdmissionReject_callSignalAddress(&(val)->callSignalAddress);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_BandwidthRequest(ASN1encoding_t enc, BandwidthRequest *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    o[1] |= 0x4;
    y = ASN1PEREncCheckExtensions(6, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->callReferenceValue))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_CallType(enc, &(val)->callType))
	    return 0;
    }
    l = ASN1uint32_uoctets((val)->bandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bandWidth))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 6, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1PEREncBitVal(ee, 7, ((val)->gatekeeperIdentifier).length - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncChar16String(ee, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_BandwidthRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_BandwidthRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1PEREncBoolean(ee, (val)->answeredCall))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthRequest(ASN1decoding_t dec, BandwidthRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->callReferenceValue))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CallType(dec, &(val)->callType))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bandWidth))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 6, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 7, &((val)->gatekeeperIdentifier).length))
		return 0;
	    ((val)->gatekeeperIdentifier).length += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecChar16String(dd, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_BandwidthRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_BandwidthRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->answeredCall))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthRequest(BandwidthRequest *val)
{
    if (val) {
	ASN1char16string_free(&(val)->endpointIdentifier);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_BandwidthRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_BandwidthRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_BandwidthConfirm(ASN1encoding_t enc, BandwidthConfirm *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    l = ASN1uint32_uoctets((val)->bandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bandWidth))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_BandwidthConfirm_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_BandwidthConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthConfirm(ASN1decoding_t dec, BandwidthConfirm *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bandWidth))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_BandwidthConfirm_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_BandwidthConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthConfirm(BandwidthConfirm *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_BandwidthConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_BandwidthConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_BandwidthReject(ASN1encoding_t enc, BandwidthReject *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_BandRejectReason(enc, &(val)->rejectReason))
	return 0;
    l = ASN1uint32_uoctets((val)->allowedBandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->allowedBandWidth))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_BandwidthReject_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_BandwidthReject_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthReject(ASN1decoding_t dec, BandwidthReject *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_BandRejectReason(dec, &(val)->rejectReason))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->allowedBandWidth))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_BandwidthReject_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_BandwidthReject_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthReject(BandwidthReject *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_BandwidthReject_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_BandwidthReject_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_LocationReject(ASN1encoding_t enc, LocationReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_LocationRejectReason(enc, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_LocationReject_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_LocationReject_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_LocationReject(ASN1decoding_t dec, LocationReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_LocationRejectReason(dec, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_LocationReject_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_LocationReject_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_LocationReject(LocationReject *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_LocationReject_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_LocationReject_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_DisengageRequest(ASN1encoding_t enc, DisengageRequest *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    o[1] |= 0x4;
    y = ASN1PEREncCheckExtensions(6, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->callReferenceValue))
	return 0;
    if (!ASN1Enc_DisengageReason(enc, &(val)->disengageReason))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 6, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1PEREncBitVal(ee, 7, ((val)->gatekeeperIdentifier).length - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncChar16String(ee, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_DisengageRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_DisengageRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1PEREncBoolean(ee, (val)->answeredCall))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageRequest(ASN1decoding_t dec, DisengageRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->callReferenceValue))
	return 0;
    if (!ASN1Dec_DisengageReason(dec, &(val)->disengageReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 6, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 7, &((val)->gatekeeperIdentifier).length))
		return 0;
	    ((val)->gatekeeperIdentifier).length += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecChar16String(dd, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_DisengageRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_DisengageRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->answeredCall))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_DisengageRequest(DisengageRequest *val)
{
    if (val) {
	ASN1char16string_free(&(val)->endpointIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_DisengageRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_DisengageRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_DisengageConfirm(ASN1encoding_t enc, DisengageConfirm *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_DisengageConfirm_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_DisengageConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageConfirm(ASN1decoding_t dec, DisengageConfirm *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_DisengageConfirm_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_DisengageConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_DisengageConfirm(DisengageConfirm *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_DisengageConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_DisengageConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_DisengageReject(ASN1encoding_t enc, DisengageReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_DisengageRejectReason(enc, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_DisengageReject_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_DisengageReject_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageReject(ASN1decoding_t dec, DisengageReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_DisengageRejectReason(dec, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_DisengageReject_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_DisengageReject_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_DisengageReject(DisengageReject *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_DisengageReject_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_DisengageReject_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequestAck(ASN1encoding_t enc, InfoRequestAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_InfoRequestAck_tokens(enc, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_InfoRequestAck_cryptoTokens(enc, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_ICV(enc, &(val)->integrityCheckValue))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestAck(ASN1decoding_t dec, InfoRequestAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_InfoRequestAck_tokens(dec, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_InfoRequestAck_cryptoTokens(dec, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_ICV(dec, &(val)->integrityCheckValue))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestAck(InfoRequestAck *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_InfoRequestAck_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_InfoRequestAck_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequestNak(ASN1encoding_t enc, InfoRequestNak *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Enc_InfoRequestNakReason(enc, &(val)->nakReason))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_AltGKInfo(enc, &(val)->altGKInfo))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_InfoRequestNak_tokens(enc, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_InfoRequestNak_cryptoTokens(enc, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_ICV(enc, &(val)->integrityCheckValue))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestNak(ASN1decoding_t dec, InfoRequestNak *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Dec_InfoRequestNakReason(dec, &(val)->nakReason))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_AltGKInfo(dec, &(val)->altGKInfo))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_InfoRequestNak_tokens(dec, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_InfoRequestNak_cryptoTokens(dec, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_ICV(dec, &(val)->integrityCheckValue))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestNak(InfoRequestNak *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_InfoRequestNak_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_InfoRequestNak_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_H225NonStandardMessage(ASN1encoding_t enc, H225NonStandardMessage *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1Enc_H225NonStandardMessage_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1Enc_H225NonStandardMessage_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[0] & 0x20) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardMessage(ASN1decoding_t dec, H225NonStandardMessage *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H225NonStandardMessage_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H225NonStandardMessage_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[0] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardMessage(H225NonStandardMessage *val)
{
    if (val) {
	ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardMessage_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H225NonStandardMessage_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_RequestInProgress(ASN1encoding_t enc, RequestInProgress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_RequestInProgress_tokens(enc, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_RequestInProgress_cryptoTokens(enc, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_ICV(enc, &(val)->integrityCheckValue))
	    return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->delay - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestInProgress(ASN1decoding_t dec, RequestInProgress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_RequestInProgress_tokens(dec, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_RequestInProgress_cryptoTokens(dec, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_ICV(dec, &(val)->integrityCheckValue))
	    return 0;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->delay))
	return 0;
    (val)->delay += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestInProgress(RequestInProgress *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_RequestInProgress_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_RequestInProgress_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate(ASN1encoding_t enc, ResourcesAvailableIndicate *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1Enc_ResourcesAvailableIndicate_protocols(enc, &(val)->protocols))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->almostOutOfResources))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ResourcesAvailableIndicate_tokens(enc, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_ResourcesAvailableIndicate_cryptoTokens(enc, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_ICV(enc, &(val)->integrityCheckValue))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate(ASN1decoding_t dec, ResourcesAvailableIndicate *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1Dec_ResourcesAvailableIndicate_protocols(dec, &(val)->protocols))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->almostOutOfResources))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_ResourcesAvailableIndicate_tokens(dec, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_ResourcesAvailableIndicate_cryptoTokens(dec, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_ICV(dec, &(val)->integrityCheckValue))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate(ResourcesAvailableIndicate *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1char16string_free(&(val)->endpointIdentifier);
	ASN1Free_ResourcesAvailableIndicate_protocols(&(val)->protocols);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_ResourcesAvailableIndicate_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_ResourcesAvailableIndicate_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm(ASN1encoding_t enc, ResourcesAvailableConfirm *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ResourcesAvailableConfirm_tokens(enc, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_ResourcesAvailableConfirm_cryptoTokens(enc, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_ICV(enc, &(val)->integrityCheckValue))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm(ASN1decoding_t dec, ResourcesAvailableConfirm *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_ResourcesAvailableConfirm_tokens(dec, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_ResourcesAvailableConfirm_cryptoTokens(dec, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_ICV(dec, &(val)->integrityCheckValue))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableConfirm(ResourcesAvailableConfirm *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_ResourcesAvailableConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_ResourcesAvailableConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_integrity(ASN1encoding_t enc, PGatekeeperConfirm_integrity *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperConfirm_integrity_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_integrity_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_integrity val)
{
    if (!ASN1Enc_IntegrityMechanism(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_integrity(ASN1decoding_t dec, PGatekeeperConfirm_integrity *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperConfirm_integrity_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_integrity_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_integrity val)
{
    if (!ASN1Dec_IntegrityMechanism(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_integrity(PGatekeeperConfirm_integrity *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperConfirm_integrity_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_integrity_ElmFn(PGatekeeperConfirm_integrity val)
{
    if (val) {
	ASN1Free_IntegrityMechanism(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_integrity(ASN1encoding_t enc, PGatekeeperRequest_integrity *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_integrity_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_integrity_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_integrity val)
{
    if (!ASN1Enc_IntegrityMechanism(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_integrity(ASN1decoding_t dec, PGatekeeperRequest_integrity *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_integrity_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_integrity_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_integrity val)
{
    if (!ASN1Dec_IntegrityMechanism(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_integrity(PGatekeeperRequest_integrity *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_integrity_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_integrity_ElmFn(PGatekeeperRequest_integrity val)
{
    if (val) {
	ASN1Free_IntegrityMechanism(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CryptoH323Token_cryptoGKPwdHash(ASN1encoding_t enc, CryptoH323Token_cryptoGKPwdHash *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperId).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperId).length, ((val)->gatekeeperId).value, 16))
	return 0;
    l = ASN1uint32_uoctets((val)->timeStamp - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->timeStamp - 1))
	return 0;
    if (!ASN1Enc_HASHED(enc, &(val)->token))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoH323Token_cryptoGKPwdHash(ASN1decoding_t dec, CryptoH323Token_cryptoGKPwdHash *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperId).length))
	return 0;
    ((val)->gatekeeperId).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperId).length, &((val)->gatekeeperId).value, 16))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->timeStamp))
	return 0;
    (val)->timeStamp += 1;
    if (!ASN1Dec_HASHED(dec, &(val)->token))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CryptoH323Token_cryptoGKPwdHash(CryptoH323Token_cryptoGKPwdHash *val)
{
    if (val) {
	ASN1char16string_free(&(val)->gatekeeperId);
	ASN1Free_HASHED(&(val)->token);
    }
}

static int ASN1CALL ASN1Enc_NonStandardProtocol_dataRatesSupported(ASN1encoding_t enc, PNonStandardProtocol_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_NonStandardProtocol_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_NonStandardProtocol_dataRatesSupported_ElmFn(ASN1encoding_t enc, PNonStandardProtocol_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardProtocol_dataRatesSupported(ASN1decoding_t dec, PNonStandardProtocol_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_NonStandardProtocol_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_NonStandardProtocol_dataRatesSupported_ElmFn(ASN1decoding_t dec, PNonStandardProtocol_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardProtocol_dataRatesSupported(PNonStandardProtocol_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_NonStandardProtocol_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_NonStandardProtocol_dataRatesSupported_ElmFn(PNonStandardProtocol_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_T120OnlyCaps_dataRatesSupported(ASN1encoding_t enc, PT120OnlyCaps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_T120OnlyCaps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_T120OnlyCaps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PT120OnlyCaps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_T120OnlyCaps_dataRatesSupported(ASN1decoding_t dec, PT120OnlyCaps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_T120OnlyCaps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_T120OnlyCaps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PT120OnlyCaps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_T120OnlyCaps_dataRatesSupported(PT120OnlyCaps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_T120OnlyCaps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_T120OnlyCaps_dataRatesSupported_ElmFn(PT120OnlyCaps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_VoiceCaps_dataRatesSupported(ASN1encoding_t enc, PVoiceCaps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_VoiceCaps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_VoiceCaps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PVoiceCaps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VoiceCaps_dataRatesSupported(ASN1decoding_t dec, PVoiceCaps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_VoiceCaps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_VoiceCaps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PVoiceCaps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VoiceCaps_dataRatesSupported(PVoiceCaps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_VoiceCaps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_VoiceCaps_dataRatesSupported_ElmFn(PVoiceCaps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H324Caps_dataRatesSupported(ASN1encoding_t enc, PH324Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H324Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H324Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH324Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H324Caps_dataRatesSupported(ASN1decoding_t dec, PH324Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H324Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H324Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH324Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H324Caps_dataRatesSupported(PH324Caps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H324Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H324Caps_dataRatesSupported_ElmFn(PH324Caps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323Caps_dataRatesSupported(ASN1encoding_t enc, PH323Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H323Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H323Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH323Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323Caps_dataRatesSupported(ASN1decoding_t dec, PH323Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H323Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H323Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH323Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H323Caps_dataRatesSupported(PH323Caps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H323Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H323Caps_dataRatesSupported_ElmFn(PH323Caps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H322Caps_dataRatesSupported(ASN1encoding_t enc, PH322Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H322Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H322Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH322Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H322Caps_dataRatesSupported(ASN1decoding_t dec, PH322Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H322Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H322Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH322Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H322Caps_dataRatesSupported(PH322Caps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H322Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H322Caps_dataRatesSupported_ElmFn(PH322Caps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H321Caps_dataRatesSupported(ASN1encoding_t enc, PH321Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H321Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H321Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH321Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H321Caps_dataRatesSupported(ASN1decoding_t dec, PH321Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H321Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H321Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH321Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H321Caps_dataRatesSupported(PH321Caps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H321Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H321Caps_dataRatesSupported_ElmFn(PH321Caps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H320Caps_dataRatesSupported(ASN1encoding_t enc, PH320Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H320Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H320Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH320Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H320Caps_dataRatesSupported(ASN1decoding_t dec, PH320Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H320Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H320Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH320Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H320Caps_dataRatesSupported(PH320Caps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H320Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H320Caps_dataRatesSupported_ElmFn(PH320Caps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H310Caps_dataRatesSupported(ASN1encoding_t enc, PH310Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H310Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H310Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH310Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H310Caps_dataRatesSupported(ASN1decoding_t dec, PH310Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H310Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H310Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH310Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H310Caps_dataRatesSupported(PH310Caps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H310Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H310Caps_dataRatesSupported_ElmFn(PH310Caps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_h245SecurityCapability(ASN1encoding_t enc, PSetup_UUIE_h245SecurityCapability *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_h245SecurityCapability_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_h245SecurityCapability_ElmFn(ASN1encoding_t enc, PSetup_UUIE_h245SecurityCapability val)
{
    if (!ASN1Enc_H245Security(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_h245SecurityCapability(ASN1decoding_t dec, PSetup_UUIE_h245SecurityCapability *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_h245SecurityCapability_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_h245SecurityCapability_ElmFn(ASN1decoding_t dec, PSetup_UUIE_h245SecurityCapability val)
{
    if (!ASN1Dec_H245Security(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_h245SecurityCapability(PSetup_UUIE_h245SecurityCapability *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_h245SecurityCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_h245SecurityCapability_ElmFn(PSetup_UUIE_h245SecurityCapability val)
{
    if (val) {
	ASN1Free_H245Security(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_nonStandardControl(ASN1encoding_t enc, PH323_UU_PDU_nonStandardControl *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H323_UU_PDU_nonStandardControl_ElmFn);
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_nonStandardControl_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_nonStandardControl val)
{
    if (!ASN1Enc_H225NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_nonStandardControl(ASN1decoding_t dec, PH323_UU_PDU_nonStandardControl *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H323_UU_PDU_nonStandardControl_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_nonStandardControl_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_nonStandardControl val)
{
    if (!ASN1Dec_H225NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU_nonStandardControl(PH323_UU_PDU_nonStandardControl *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H323_UU_PDU_nonStandardControl_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H323_UU_PDU_nonStandardControl_ElmFn(PH323_UU_PDU_nonStandardControl val)
{
    if (val) {
	ASN1Free_H225NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CryptoToken_cryptoHashedToken(ASN1encoding_t enc, CryptoToken_cryptoHashedToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->tokenOID))
	return 0;
    if (!ASN1Enc_ClearToken(enc, &(val)->hashedVals))
	return 0;
    if (!ASN1Enc_HASHED(enc, &(val)->token))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoToken_cryptoHashedToken(ASN1decoding_t dec, CryptoToken_cryptoHashedToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->tokenOID))
	return 0;
    if (!ASN1Dec_ClearToken(dec, &(val)->hashedVals))
	return 0;
    if (!ASN1Dec_HASHED(dec, &(val)->token))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CryptoToken_cryptoHashedToken(CryptoToken_cryptoHashedToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->tokenOID);
	ASN1Free_ClearToken(&(val)->hashedVals);
	ASN1Free_HASHED(&(val)->token);
    }
}

static int ASN1CALL ASN1Enc_CryptoToken_cryptoSignedToken(ASN1encoding_t enc, CryptoToken_cryptoSignedToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->tokenOID))
	return 0;
    if (!ASN1Enc_SIGNED_EncodedGeneralToken(enc, &(val)->token))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoToken_cryptoSignedToken(ASN1decoding_t dec, CryptoToken_cryptoSignedToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->tokenOID))
	return 0;
    if (!ASN1Dec_SIGNED_EncodedGeneralToken(dec, &(val)->token))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CryptoToken_cryptoSignedToken(CryptoToken_cryptoSignedToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->tokenOID);
	ASN1Free_SIGNED_EncodedGeneralToken(&(val)->token);
    }
}

static int ASN1CALL ASN1Enc_CryptoToken_cryptoEncryptedToken(ASN1encoding_t enc, CryptoToken_cryptoEncryptedToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->tokenOID))
	return 0;
    if (!ASN1Enc_ENCRYPTED(enc, &(val)->token))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoToken_cryptoEncryptedToken(ASN1decoding_t dec, CryptoToken_cryptoEncryptedToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->tokenOID))
	return 0;
    if (!ASN1Dec_ENCRYPTED(dec, &(val)->token))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CryptoToken_cryptoEncryptedToken(CryptoToken_cryptoEncryptedToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->tokenOID);
	ASN1Free_ENCRYPTED(&(val)->token);
    }
}

static int ASN1CALL ASN1Enc_CryptoToken(ASN1encoding_t enc, CryptoToken *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_CryptoToken_cryptoEncryptedToken(enc, &(val)->u.cryptoEncryptedToken))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_CryptoToken_cryptoSignedToken(enc, &(val)->u.cryptoSignedToken))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_CryptoToken_cryptoHashedToken(enc, &(val)->u.cryptoHashedToken))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ENCRYPTED(enc, &(val)->u.cryptoPwdEncr))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoToken(ASN1decoding_t dec, CryptoToken *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_CryptoToken_cryptoEncryptedToken(dec, &(val)->u.cryptoEncryptedToken))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_CryptoToken_cryptoSignedToken(dec, &(val)->u.cryptoSignedToken))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_CryptoToken_cryptoHashedToken(dec, &(val)->u.cryptoHashedToken))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ENCRYPTED(dec, &(val)->u.cryptoPwdEncr))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CryptoToken(CryptoToken *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_CryptoToken_cryptoEncryptedToken(&(val)->u.cryptoEncryptedToken);
	    break;
	case 2:
	    ASN1Free_CryptoToken_cryptoSignedToken(&(val)->u.cryptoSignedToken);
	    break;
	case 3:
	    ASN1Free_CryptoToken_cryptoHashedToken(&(val)->u.cryptoHashedToken);
	    break;
	case 4:
	    ASN1Free_ENCRYPTED(&(val)->u.cryptoPwdEncr);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_SIGNED_EncodedFastStartToken(ASN1encoding_t enc, SIGNED_EncodedFastStartToken *val)
{
    if (!ASN1Enc_EncodedFastStartToken(enc, &(val)->toBeSigned))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
	return 0;
    if (!ASN1Enc_Params(enc, &(val)->paramS))
	return 0;
    if (!ASN1PEREncFragmented(enc, ((val)->signature).length, ((val)->signature).value, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SIGNED_EncodedFastStartToken(ASN1decoding_t dec, SIGNED_EncodedFastStartToken *val)
{
    if (!ASN1Dec_EncodedFastStartToken(dec, &(val)->toBeSigned))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
	return 0;
    if (!ASN1Dec_Params(dec, &(val)->paramS))
	return 0;
    if (!ASN1PERDecFragmented(dec, &((val)->signature).length, &((val)->signature).value, 1))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SIGNED_EncodedFastStartToken(SIGNED_EncodedFastStartToken *val)
{
    if (val) {
	ASN1Free_EncodedFastStartToken(&(val)->toBeSigned);
	ASN1objectidentifier_free(&(val)->algorithmOID);
	ASN1Free_Params(&(val)->paramS);
	ASN1bitstring_free(&(val)->signature);
    }
}

static int ASN1CALL ASN1Enc_TransportAddress(ASN1encoding_t enc, TransportAddress *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_TransportAddress_ipAddress(enc, &(val)->u.ipAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_TransportAddress_ipSourceRoute(enc, &(val)->u.ipSourceRoute))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_TransportAddress_ipxAddress(enc, &(val)->u.ipxAddress))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_TransportAddress_ip6Address(enc, &(val)->u.ip6Address))
	    return 0;
	break;
    case 5:
	if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
	    return 0;
	break;
    case 6:
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardAddress))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress(ASN1decoding_t dec, TransportAddress *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_TransportAddress_ipAddress(dec, &(val)->u.ipAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_TransportAddress_ipSourceRoute(dec, &(val)->u.ipSourceRoute))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_TransportAddress_ipxAddress(dec, &(val)->u.ipxAddress))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_TransportAddress_ip6Address(dec, &(val)->u.ip6Address))
	    return 0;
	break;
    case 5:
	if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
	    return 0;
	break;
    case 6:
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardAddress))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress(TransportAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_TransportAddress_ipAddress(&(val)->u.ipAddress);
	    break;
	case 2:
	    ASN1Free_TransportAddress_ipSourceRoute(&(val)->u.ipSourceRoute);
	    break;
	case 3:
	    ASN1Free_TransportAddress_ipxAddress(&(val)->u.ipxAddress);
	    break;
	case 4:
	    ASN1Free_TransportAddress_ip6Address(&(val)->u.ip6Address);
	    break;
	case 5:
	    break;
	case 6:
	    break;
	case 7:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardAddress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_GatewayInfo(ASN1encoding_t enc, GatewayInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_GatewayInfo_protocol(enc, &(val)->protocol))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatewayInfo(ASN1decoding_t dec, GatewayInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_GatewayInfo_protocol(dec, &(val)->protocol))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatewayInfo(GatewayInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_GatewayInfo_protocol(&(val)->protocol);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_H310Caps(ASN1encoding_t enc, H310Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_H310Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H310Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H310Caps(ASN1decoding_t dec, H310Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H310Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H310Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H310Caps(H310Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_H310Caps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H310Caps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_H320Caps(ASN1encoding_t enc, H320Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_H320Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H320Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H320Caps(ASN1decoding_t dec, H320Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H320Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H320Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H320Caps(H320Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_H320Caps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H320Caps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_H321Caps(ASN1encoding_t enc, H321Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_H321Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H321Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H321Caps(ASN1decoding_t dec, H321Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H321Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H321Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H321Caps(H321Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_H321Caps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H321Caps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_H322Caps(ASN1encoding_t enc, H322Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_H322Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H322Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H322Caps(ASN1decoding_t dec, H322Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H322Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H322Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H322Caps(H322Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_H322Caps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H322Caps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_H323Caps(ASN1encoding_t enc, H323Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_H323Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H323Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H323Caps(ASN1decoding_t dec, H323Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H323Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H323Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323Caps(H323Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_H323Caps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H323Caps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_H324Caps(ASN1encoding_t enc, H324Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_H324Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H324Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H324Caps(ASN1decoding_t dec, H324Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H324Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H324Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H324Caps(H324Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_H324Caps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H324Caps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_VoiceCaps(ASN1encoding_t enc, VoiceCaps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_VoiceCaps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_VoiceCaps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VoiceCaps(ASN1decoding_t dec, VoiceCaps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_VoiceCaps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_VoiceCaps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_VoiceCaps(VoiceCaps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_VoiceCaps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_VoiceCaps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_T120OnlyCaps(ASN1encoding_t enc, T120OnlyCaps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_T120OnlyCaps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_T120OnlyCaps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_T120OnlyCaps(ASN1decoding_t dec, T120OnlyCaps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_T120OnlyCaps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_T120OnlyCaps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_T120OnlyCaps(T120OnlyCaps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_T120OnlyCaps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_T120OnlyCaps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_NonStandardProtocol(ASN1encoding_t enc, NonStandardProtocol *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_NonStandardProtocol_dataRatesSupported(enc, &(val)->dataRatesSupported))
	    return 0;
    }
    if (!ASN1Enc_NonStandardProtocol_supportedPrefixes(enc, &(val)->supportedPrefixes))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardProtocol(ASN1decoding_t dec, NonStandardProtocol *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_NonStandardProtocol_dataRatesSupported(dec, &(val)->dataRatesSupported))
	    return 0;
    }
    if (!ASN1Dec_NonStandardProtocol_supportedPrefixes(dec, &(val)->supportedPrefixes))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardProtocol(NonStandardProtocol *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_NonStandardProtocol_dataRatesSupported(&(val)->dataRatesSupported);
	}
	ASN1Free_NonStandardProtocol_supportedPrefixes(&(val)->supportedPrefixes);
    }
}

static int ASN1CALL ASN1Enc_McuInfo(ASN1encoding_t enc, McuInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_McuInfo(ASN1decoding_t dec, McuInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_McuInfo(McuInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_TerminalInfo(ASN1encoding_t enc, TerminalInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalInfo(ASN1decoding_t dec, TerminalInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TerminalInfo(TerminalInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_GatekeeperInfo(ASN1encoding_t enc, GatekeeperInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperInfo(ASN1decoding_t dec, GatekeeperInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperInfo(GatekeeperInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static ASN1stringtableentry_t PartyNumber_dataPartyNumber_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PartyNumber_dataPartyNumber_StringTable = {
    4, PartyNumber_dataPartyNumber_StringTableEntries
};

static ASN1stringtableentry_t PartyNumber_telexPartyNumber_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PartyNumber_telexPartyNumber_StringTable = {
    4, PartyNumber_telexPartyNumber_StringTableEntries
};

static ASN1stringtableentry_t PartyNumber_nationalStandardPartyNumber_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PartyNumber_nationalStandardPartyNumber_StringTable = {
    4, PartyNumber_nationalStandardPartyNumber_StringTableEntries
};

static int ASN1CALL ASN1Enc_PartyNumber(ASN1encoding_t enc, PartyNumber *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_PublicPartyNumber(enc, &(val)->u.publicNumber))
	    return 0;
	break;
    case 2:
	t = lstrlenA((val)->u.dataPartyNumber);
	if (!ASN1PEREncBitVal(enc, 7, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.dataPartyNumber, 4, &PartyNumber_dataPartyNumber_StringTable))
	    return 0;
	break;
    case 3:
	t = lstrlenA((val)->u.telexPartyNumber);
	if (!ASN1PEREncBitVal(enc, 7, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.telexPartyNumber, 4, &PartyNumber_telexPartyNumber_StringTable))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_PrivatePartyNumber(enc, &(val)->u.privateNumber))
	    return 0;
	break;
    case 5:
	t = lstrlenA((val)->u.nationalStandardPartyNumber);
	if (!ASN1PEREncBitVal(enc, 7, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.nationalStandardPartyNumber, 4, &PartyNumber_nationalStandardPartyNumber_StringTable))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PartyNumber(ASN1decoding_t dec, PartyNumber *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_PublicPartyNumber(dec, &(val)->u.publicNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecU32Val(dec, 7, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.dataPartyNumber, 4, &PartyNumber_dataPartyNumber_StringTable))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecU32Val(dec, 7, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.telexPartyNumber, 4, &PartyNumber_telexPartyNumber_StringTable))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_PrivatePartyNumber(dec, &(val)->u.privateNumber))
	    return 0;
	break;
    case 5:
	if (!ASN1PERDecU32Val(dec, 7, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.nationalStandardPartyNumber, 4, &PartyNumber_nationalStandardPartyNumber_StringTable))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PartyNumber(PartyNumber *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_PublicPartyNumber(&(val)->u.publicNumber);
	    break;
	case 2:
	    break;
	case 3:
	    break;
	case 4:
	    ASN1Free_PrivatePartyNumber(&(val)->u.privateNumber);
	    break;
	case 5:
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_AlternateGK(ASN1encoding_t enc, AlternateGK *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_TransportAddress(enc, &(val)->rasAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->needToRegister))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->priority))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlternateGK(ASN1decoding_t dec, AlternateGK *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_TransportAddress(dec, &(val)->rasAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
	    return 0;
	((val)->gatekeeperIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->needToRegister))
	return 0;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->priority))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AlternateGK(AlternateGK *val)
{
    if (val) {
	ASN1Free_TransportAddress(&(val)->rasAddress);
	if ((val)->o[0] & 0x80) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
    }
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm(ASN1encoding_t enc, GatekeeperConfirm *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(7, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Enc_TransportAddress(enc, &(val)->rasAddress))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 7, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_GatekeeperConfirm_alternateGatekeeper(ee, &(val)->alternateGatekeeper))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_AuthenticationMechanism(ee, &(val)->authenticationMode))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_GatekeeperConfirm_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_GatekeeperConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PEREncObjectIdentifier(ee, &(val)->algorithmOID))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1Enc_GatekeeperConfirm_integrity(ee, &(val)->integrity))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm(ASN1decoding_t dec, GatekeeperConfirm *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
	    return 0;
	((val)->gatekeeperIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Dec_TransportAddress(dec, &(val)->rasAddress))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 7, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperConfirm_alternateGatekeeper(dd, &(val)->alternateGatekeeper))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AuthenticationMechanism(dd, &(val)->authenticationMode))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperConfirm_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecObjectIdentifier(dd, &(val)->algorithmOID))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperConfirm_integrity(dd, &(val)->integrity))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperConfirm(GatekeeperConfirm *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	ASN1Free_TransportAddress(&(val)->rasAddress);
	if ((val)->o[1] & 0x80) {
	    ASN1Free_GatekeeperConfirm_alternateGatekeeper(&(val)->alternateGatekeeper);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_AuthenticationMechanism(&(val)->authenticationMode);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_GatekeeperConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_GatekeeperConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1objectidentifier_free(&(val)->algorithmOID);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_GatekeeperConfirm_integrity(&(val)->integrity);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest(ASN1encoding_t enc, AdmissionRequest *val)
{
    ASN1octet_t o[3];
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 3);
    o[1] |= 0x80;
    o[1] |= 0x40;
    o[2] |= 0x40;
    y = ASN1PEREncCheckExtensions(10, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 7, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_CallType(enc, &(val)->callType))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_CallModel(enc, &(val)->callModel))
	    return 0;
    }
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1Enc_AdmissionRequest_destinationInfo(enc, &(val)->destinationInfo))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->destCallSignalAddress))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1Enc_AdmissionRequest_destExtraCallInfo(enc, &(val)->destExtraCallInfo))
	    return 0;
    }
    if (!ASN1Enc_AdmissionRequest_srcInfo(enc, &(val)->srcInfo))
	return 0;
    if (o[0] & 0x8) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->srcCallSignalAddress))
	    return 0;
    }
    l = ASN1uint32_uoctets((val)->bandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bandWidth))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->callReferenceValue))
	return 0;
    if (o[0] & 0x4) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (o[0] & 0x2) {
	if (!ASN1Enc_QseriesOptions(enc, &(val)->callServices))
	    return 0;
    }
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->activeMC))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->answerCall))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 10, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1PEREncBoolean(ee, (val)->canMapAlias))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_AdmissionRequest_srcAlternatives(ee, &(val)->srcAlternatives))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_AdmissionRequest_destAlternatives(ee, &(val)->destAlternatives))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1PEREncBitVal(ee, 7, ((val)->gatekeeperIdentifier).length - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncChar16String(ee, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1Enc_AdmissionRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x2) {
	    if (!ASN1Enc_AdmissionRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x1) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[2] & 0x80) {
	    if (!ASN1Enc_TransportQOS(ee, &(val)->transportQOS))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[2] & 0x40) {
	    if (!ASN1PEREncBoolean(ee, (val)->willSupplyUUIEs))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest(ASN1decoding_t dec, AdmissionRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_CallType(dec, &(val)->callType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CallModel(dec, &(val)->callModel))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_AdmissionRequest_destinationInfo(dec, &(val)->destinationInfo))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->destCallSignalAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_AdmissionRequest_destExtraCallInfo(dec, &(val)->destExtraCallInfo))
	    return 0;
    }
    if (!ASN1Dec_AdmissionRequest_srcInfo(dec, &(val)->srcInfo))
	return 0;
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->srcCallSignalAddress))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bandWidth))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->callReferenceValue))
	return 0;
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Dec_QseriesOptions(dec, &(val)->callServices))
	    return 0;
    }
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->activeMC))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->answerCall))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 2);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 10, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->canMapAlias))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionRequest_srcAlternatives(dd, &(val)->srcAlternatives))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionRequest_destAlternatives(dd, &(val)->destAlternatives))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 7, &((val)->gatekeeperIdentifier).length))
		return 0;
	    ((val)->gatekeeperIdentifier).length += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecChar16String(dd, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[2] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_TransportQOS(dd, &(val)->transportQOS))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[2] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->willSupplyUUIEs))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest(AdmissionRequest *val)
{
    if (val) {
	ASN1char16string_free(&(val)->endpointIdentifier);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_AdmissionRequest_destinationInfo(&(val)->destinationInfo);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_TransportAddress(&(val)->destCallSignalAddress);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_AdmissionRequest_destExtraCallInfo(&(val)->destExtraCallInfo);
	}
	ASN1Free_AdmissionRequest_srcInfo(&(val)->srcInfo);
	if ((val)->o[0] & 0x8) {
	    ASN1Free_TransportAddress(&(val)->srcCallSignalAddress);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_AdmissionRequest_srcAlternatives(&(val)->srcAlternatives);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_AdmissionRequest_destAlternatives(&(val)->destAlternatives);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_AdmissionRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1Free_AdmissionRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x1) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_LocationRequest(ASN1encoding_t enc, LocationRequest *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(6, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Enc_LocationRequest_destinationInfo(enc, &(val)->destinationInfo))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Enc_TransportAddress(enc, &(val)->replyAddress))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 6, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_LocationRequest_sourceInfo(ee, &(val)->sourceInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1PEREncBoolean(ee, (val)->canMapAlias))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1PEREncBitVal(ee, 7, ((val)->gatekeeperIdentifier).length - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncChar16String(ee, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_LocationRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_LocationRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRequest(ASN1decoding_t dec, LocationRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	    return 0;
	((val)->endpointIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Dec_LocationRequest_destinationInfo(dec, &(val)->destinationInfo))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Dec_TransportAddress(dec, &(val)->replyAddress))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 6, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_LocationRequest_sourceInfo(dd, &(val)->sourceInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->canMapAlias))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 7, &((val)->gatekeeperIdentifier).length))
		return 0;
	    ((val)->gatekeeperIdentifier).length += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecChar16String(dd, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_LocationRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_LocationRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_LocationRequest(LocationRequest *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1char16string_free(&(val)->endpointIdentifier);
	}
	ASN1Free_LocationRequest_destinationInfo(&(val)->destinationInfo);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1Free_TransportAddress(&(val)->replyAddress);
	if ((val)->o[1] & 0x80) {
	    ASN1Free_LocationRequest_sourceInfo(&(val)->sourceInfo);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_LocationRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_LocationRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequest(ASN1encoding_t enc, InfoRequest *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->callReferenceValue))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->replyAddress))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 5, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_InfoRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_InfoRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_UUIEsRequested(ee, &(val)->uuiesRequested))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequest(ASN1decoding_t dec, InfoRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->callReferenceValue))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->replyAddress))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_UUIEsRequested(dd, &(val)->uuiesRequested))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequest(InfoRequest *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_TransportAddress(&(val)->replyAddress);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_InfoRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_InfoRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_TransportChannelInfo(ASN1encoding_t enc, TransportChannelInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->sendAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->recvAddress))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportChannelInfo(ASN1decoding_t dec, TransportChannelInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->sendAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->recvAddress))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportChannelInfo(TransportChannelInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->sendAddress);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_TransportAddress(&(val)->recvAddress);
	}
    }
}

static int ASN1CALL ASN1Enc_RTPSession(ASN1encoding_t enc, RTPSession *val)
{
    ASN1uint32_t t;
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TransportChannelInfo(enc, &(val)->rtpAddress))
	return 0;
    if (!ASN1Enc_TransportChannelInfo(enc, &(val)->rtcpAddress))
	return 0;
    t = lstrlenA((val)->cname);
    if (!ASN1PEREncFragmentedCharString(enc, t, (val)->cname, 8))
	return 0;
    l = ASN1uint32_uoctets((val)->ssrc - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->ssrc - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->sessionId - 1))
	return 0;
    if (!ASN1Enc_RTPSession_associatedSessionIds(enc, &(val)->associatedSessionIds))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RTPSession(ASN1decoding_t dec, RTPSession *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TransportChannelInfo(dec, &(val)->rtpAddress))
	return 0;
    if (!ASN1Dec_TransportChannelInfo(dec, &(val)->rtcpAddress))
	return 0;
    if (!ASN1PERDecFragmentedZeroCharString(dec, &(val)->cname, 8))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->ssrc))
	return 0;
    (val)->ssrc += 1;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sessionId))
	return 0;
    (val)->sessionId += 1;
    if (!ASN1Dec_RTPSession_associatedSessionIds(dec, &(val)->associatedSessionIds))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPSession(RTPSession *val)
{
    if (val) {
	ASN1Free_TransportChannelInfo(&(val)->rtpAddress);
	ASN1Free_TransportChannelInfo(&(val)->rtcpAddress);
	ASN1ztcharstring_free((val)->cname);
	ASN1Free_RTPSession_associatedSessionIds(&(val)->associatedSessionIds);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_data *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_data val)
{
    if (!ASN1Enc_TransportChannelInfo(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_data *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_data val)
{
    if (!ASN1Dec_TransportChannelInfo(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_data(PInfoRequestResponse_perCallInfo_Seq_data *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_data_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(PInfoRequestResponse_perCallInfo_Seq_data val)
{
    if (val) {
	ASN1Free_TransportChannelInfo(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_video *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_video val)
{
    if (!ASN1Enc_RTPSession(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_video *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_video val)
{
    if (!ASN1Dec_RTPSession(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_video(PInfoRequestResponse_perCallInfo_Seq_video *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_video_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(PInfoRequestResponse_perCallInfo_Seq_video val)
{
    if (val) {
	ASN1Free_RTPSession(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_audio *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_audio val)
{
    if (!ASN1Enc_RTPSession(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_audio *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_audio val)
{
    if (!ASN1Dec_RTPSession(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio(PInfoRequestResponse_perCallInfo_Seq_audio *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(PInfoRequestResponse_perCallInfo_Seq_audio val)
{
    if (val) {
	ASN1Free_RTPSession(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq(ASN1encoding_t enc, InfoRequestResponse_perCallInfo_Seq *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    o[1] |= 0x10;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 5, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->callReferenceValue))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1PEREncBoolean(enc, (val)->originator))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio(enc, &(val)->audio))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video(enc, &(val)->video))
	    return 0;
    }
    if (o[0] & 0x8) {
	if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data(enc, &(val)->data))
	    return 0;
    }
    if (!ASN1Enc_TransportChannelInfo(enc, &(val)->h245))
	return 0;
    if (!ASN1Enc_TransportChannelInfo(enc, &(val)->callSignaling))
	return 0;
    if (!ASN1Enc_CallType(enc, &(val)->callType))
	return 0;
    l = ASN1uint32_uoctets((val)->bandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bandWidth))
	return 0;
    if (!ASN1Enc_CallModel(enc, &(val)->callModel))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 5, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(ee, &(val)->substituteConfIDs))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu(ee, &(val)->pdu))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq(ASN1decoding_t dec, InfoRequestResponse_perCallInfo_Seq *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->callReferenceValue))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecBoolean(dec, &(val)->originator))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio(dec, &(val)->audio))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video(dec, &(val)->video))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data(dec, &(val)->data))
	    return 0;
    }
    if (!ASN1Dec_TransportChannelInfo(dec, &(val)->h245))
	return 0;
    if (!ASN1Dec_TransportChannelInfo(dec, &(val)->callSignaling))
	return 0;
    if (!ASN1Dec_CallType(dec, &(val)->callType))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bandWidth))
	return 0;
    if (!ASN1Dec_CallModel(dec, &(val)->callModel))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(dd, &(val)->substituteConfIDs))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu(dd, &(val)->pdu))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq(InfoRequestResponse_perCallInfo_Seq *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio(&(val)->audio);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_InfoRequestResponse_perCallInfo_Seq_video(&(val)->video);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_InfoRequestResponse_perCallInfo_Seq_data(&(val)->data);
	}
	ASN1Free_TransportChannelInfo(&(val)->h245);
	ASN1Free_TransportChannelInfo(&(val)->callSignaling);
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(&(val)->substituteConfIDs);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu(&(val)->pdu);
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo val)
{
    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo val)
{
    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo(PInfoRequestResponse_perCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_ElmFn(PInfoRequestResponse_perCallInfo val)
{
    if (val) {
	ASN1Free_InfoRequestResponse_perCallInfo_Seq(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_callSignalAddress(ASN1encoding_t enc, PInfoRequestResponse_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_callSignalAddress_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_callSignalAddress(ASN1decoding_t dec, PInfoRequestResponse_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_callSignalAddress_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_callSignalAddress(PInfoRequestResponse_callSignalAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_callSignalAddress_ElmFn(PInfoRequestResponse_callSignalAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionReject_callSignalAddress(ASN1encoding_t enc, PAdmissionReject_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionReject_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionReject_callSignalAddress_ElmFn(ASN1encoding_t enc, PAdmissionReject_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionReject_callSignalAddress(ASN1decoding_t dec, PAdmissionReject_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionReject_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionReject_callSignalAddress_ElmFn(ASN1decoding_t dec, PAdmissionReject_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionReject_callSignalAddress(PAdmissionReject_callSignalAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionReject_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionReject_callSignalAddress_ElmFn(PAdmissionReject_callSignalAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_callSignalAddress(ASN1encoding_t enc, PUnregistrationRequest_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationRequest_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_callSignalAddress_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_callSignalAddress(ASN1decoding_t dec, PUnregistrationRequest_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationRequest_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_callSignalAddress_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest_callSignalAddress(PUnregistrationRequest_callSignalAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationRequest_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationRequest_callSignalAddress_ElmFn(PUnregistrationRequest_callSignalAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_alternateGatekeeper(ASN1encoding_t enc, PRegistrationConfirm_alternateGatekeeper *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationConfirm_alternateGatekeeper_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_alternateGatekeeper val)
{
    if (!ASN1Enc_AlternateGK(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_alternateGatekeeper(ASN1decoding_t dec, PRegistrationConfirm_alternateGatekeeper *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationConfirm_alternateGatekeeper_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_alternateGatekeeper val)
{
    if (!ASN1Dec_AlternateGK(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm_alternateGatekeeper(PRegistrationConfirm_alternateGatekeeper *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationConfirm_alternateGatekeeper_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationConfirm_alternateGatekeeper_ElmFn(PRegistrationConfirm_alternateGatekeeper val)
{
    if (val) {
	ASN1Free_AlternateGK(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_callSignalAddress(ASN1encoding_t enc, PRegistrationConfirm_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationConfirm_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_callSignalAddress_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_callSignalAddress(ASN1decoding_t dec, PRegistrationConfirm_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationConfirm_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_callSignalAddress_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm_callSignalAddress(PRegistrationConfirm_callSignalAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationConfirm_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationConfirm_callSignalAddress_ElmFn(PRegistrationConfirm_callSignalAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_rasAddress(ASN1encoding_t enc, PRegistrationRequest_rasAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_rasAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_rasAddress_ElmFn(ASN1encoding_t enc, PRegistrationRequest_rasAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_rasAddress(ASN1decoding_t dec, PRegistrationRequest_rasAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_rasAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_rasAddress_ElmFn(ASN1decoding_t dec, PRegistrationRequest_rasAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_rasAddress(PRegistrationRequest_rasAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_rasAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_rasAddress_ElmFn(PRegistrationRequest_rasAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_callSignalAddress(ASN1encoding_t enc, PRegistrationRequest_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_callSignalAddress_ElmFn(ASN1encoding_t enc, PRegistrationRequest_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_callSignalAddress(ASN1decoding_t dec, PRegistrationRequest_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_callSignalAddress_ElmFn(ASN1decoding_t dec, PRegistrationRequest_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_callSignalAddress(PRegistrationRequest_callSignalAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_callSignalAddress_ElmFn(PRegistrationRequest_callSignalAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_alternateGatekeeper(ASN1encoding_t enc, PGatekeeperConfirm_alternateGatekeeper *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperConfirm_alternateGatekeeper_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_alternateGatekeeper val)
{
    if (!ASN1Enc_AlternateGK(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_alternateGatekeeper(ASN1decoding_t dec, PGatekeeperConfirm_alternateGatekeeper *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperConfirm_alternateGatekeeper_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_alternateGatekeeper val)
{
    if (!ASN1Dec_AlternateGK(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_alternateGatekeeper(PGatekeeperConfirm_alternateGatekeeper *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperConfirm_alternateGatekeeper_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_alternateGatekeeper_ElmFn(PGatekeeperConfirm_alternateGatekeeper val)
{
    if (val) {
	ASN1Free_AlternateGK(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AltGKInfo_alternateGatekeeper(ASN1encoding_t enc, PAltGKInfo_alternateGatekeeper *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AltGKInfo_alternateGatekeeper_ElmFn);
}

static int ASN1CALL ASN1Enc_AltGKInfo_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PAltGKInfo_alternateGatekeeper val)
{
    if (!ASN1Enc_AlternateGK(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AltGKInfo_alternateGatekeeper(ASN1decoding_t dec, PAltGKInfo_alternateGatekeeper *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AltGKInfo_alternateGatekeeper_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AltGKInfo_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PAltGKInfo_alternateGatekeeper val)
{
    if (!ASN1Dec_AlternateGK(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AltGKInfo_alternateGatekeeper(PAltGKInfo_alternateGatekeeper *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AltGKInfo_alternateGatekeeper_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AltGKInfo_alternateGatekeeper_ElmFn(PAltGKInfo_alternateGatekeeper val)
{
    if (val) {
	ASN1Free_AlternateGK(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_rasAddress(ASN1encoding_t enc, PEndpoint_rasAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_rasAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_rasAddress_ElmFn(ASN1encoding_t enc, PEndpoint_rasAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_rasAddress(ASN1decoding_t dec, PEndpoint_rasAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_rasAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_rasAddress_ElmFn(ASN1decoding_t dec, PEndpoint_rasAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_rasAddress(PEndpoint_rasAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_rasAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_rasAddress_ElmFn(PEndpoint_rasAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_callSignalAddress(ASN1encoding_t enc, PEndpoint_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_callSignalAddress_ElmFn(ASN1encoding_t enc, PEndpoint_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_callSignalAddress(ASN1decoding_t dec, PEndpoint_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_callSignalAddress_ElmFn(ASN1decoding_t dec, PEndpoint_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_callSignalAddress(PEndpoint_callSignalAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_callSignalAddress_ElmFn(PEndpoint_callSignalAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_EndpointType(ASN1encoding_t enc, EndpointType *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_VendorIdentifier(enc, &(val)->vendor))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_GatekeeperInfo(enc, &(val)->gatekeeper))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_GatewayInfo(enc, &(val)->gateway))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_McuInfo(enc, &(val)->mcu))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_TerminalInfo(enc, &(val)->terminal))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->mc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->undefinedNode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EndpointType(ASN1decoding_t dec, EndpointType *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_VendorIdentifier(dec, &(val)->vendor))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_GatekeeperInfo(dec, &(val)->gatekeeper))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_GatewayInfo(dec, &(val)->gateway))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_McuInfo(dec, &(val)->mcu))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_TerminalInfo(dec, &(val)->terminal))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->mc))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->undefinedNode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EndpointType(EndpointType *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_VendorIdentifier(&(val)->vendor);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_GatekeeperInfo(&(val)->gatekeeper);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_GatewayInfo(&(val)->gateway);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_McuInfo(&(val)->mcu);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_TerminalInfo(&(val)->terminal);
	}
    }
}

static int ASN1CALL ASN1Enc_SupportedProtocols(ASN1encoding_t enc, SupportedProtocols *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 9))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H310Caps(enc, &(val)->u.h310))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H320Caps(enc, &(val)->u.h320))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_H321Caps(enc, &(val)->u.h321))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_H322Caps(enc, &(val)->u.h322))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_H323Caps(enc, &(val)->u.h323))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_H324Caps(enc, &(val)->u.h324))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_VoiceCaps(enc, &(val)->u.voice))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_T120OnlyCaps(enc, &(val)->u.t120_only))
	    return 0;
	break;
    case 10:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_NonStandardProtocol(ee, &(val)->u.nonStandardProtocol))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SupportedProtocols(ASN1decoding_t dec, SupportedProtocols *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 9))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H310Caps(dec, &(val)->u.h310))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H320Caps(dec, &(val)->u.h320))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_H321Caps(dec, &(val)->u.h321))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_H322Caps(dec, &(val)->u.h322))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_H323Caps(dec, &(val)->u.h323))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_H324Caps(dec, &(val)->u.h324))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_VoiceCaps(dec, &(val)->u.voice))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_T120OnlyCaps(dec, &(val)->u.t120_only))
	    return 0;
	break;
    case 10:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_NonStandardProtocol(dd, &(val)->u.nonStandardProtocol))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SupportedProtocols(SupportedProtocols *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	case 2:
	    ASN1Free_H310Caps(&(val)->u.h310);
	    break;
	case 3:
	    ASN1Free_H320Caps(&(val)->u.h320);
	    break;
	case 4:
	    ASN1Free_H321Caps(&(val)->u.h321);
	    break;
	case 5:
	    ASN1Free_H322Caps(&(val)->u.h322);
	    break;
	case 6:
	    ASN1Free_H323Caps(&(val)->u.h323);
	    break;
	case 7:
	    ASN1Free_H324Caps(&(val)->u.h324);
	    break;
	case 8:
	    ASN1Free_VoiceCaps(&(val)->u.voice);
	    break;
	case 9:
	    ASN1Free_T120OnlyCaps(&(val)->u.t120_only);
	    break;
	case 10:
	    ASN1Free_NonStandardProtocol(&(val)->u.nonStandardProtocol);
	    break;
	}
    }
}

static ASN1stringtableentry_t AliasAddress_e164_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t AliasAddress_e164_StringTable = {
    4, AliasAddress_e164_StringTableEntries
};

static int ASN1CALL ASN1Enc_AliasAddress(ASN1encoding_t enc, AliasAddress *val)
{
    ASN1uint32_t t;
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	t = lstrlenA((val)->u.e164);
	if (!ASN1PEREncBitVal(enc, 7, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.e164, 4, &AliasAddress_e164_StringTable))
	    return 0;
	break;
    case 2:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->u.h323_ID).length - 1))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->u.h323_ID).length, ((val)->u.h323_ID).value, 16))
	    return 0;
	break;
    case 3:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	t = lstrlenA((val)->u.url_ID);
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 16, t - 1))
	    return 0;
	if (!ASN1PEREncCharString(ee, t, (val)->u.url_ID, 8))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 4:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TransportAddress(ee, &(val)->u.transportID))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 5:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	t = lstrlenA((val)->u.email_ID);
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 16, t - 1))
	    return 0;
	if (!ASN1PEREncCharString(ee, t, (val)->u.email_ID, 8))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 6:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_PartyNumber(ee, &(val)->u.partyNumber))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AliasAddress(ASN1decoding_t dec, AliasAddress *val)
{
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU32Val(dec, 7, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.e164, 4, &AliasAddress_e164_StringTable))
	    return 0;
	break;
    case 2:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->u.h323_ID).length))
	    return 0;
	((val)->u.h323_ID).length += 1;
	if (!ASN1PERDecChar16String(dec, ((val)->u.h323_ID).length, &((val)->u.h323_ID).value, 16))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU32Val(dd, 16, &l))
	    return 0;
	l += 1;
	if (!ASN1PERDecZeroCharStringNoAlloc(dd, l, (val)->u.url_ID, 8))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 4:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_TransportAddress(dd, &(val)->u.transportID))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 5:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU32Val(dd, 16, &l))
	    return 0;
	l += 1;
	if (!ASN1PERDecZeroCharStringNoAlloc(dd, l, (val)->u.email_ID, 8))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 6:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_PartyNumber(dd, &(val)->u.partyNumber))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AliasAddress(AliasAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    break;
	case 2:
	    ASN1char16string_free(&(val)->u.h323_ID);
	    break;
	case 3:
	    break;
	case 4:
	    ASN1Free_TransportAddress(&(val)->u.transportID);
	    break;
	case 5:
	    break;
	case 6:
	    ASN1Free_PartyNumber(&(val)->u.partyNumber);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_Endpoint(ASN1encoding_t enc, Endpoint *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 10, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Endpoint_aliasAddress(enc, &(val)->aliasAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_Endpoint_callSignalAddress(enc, &(val)->callSignalAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_Endpoint_rasAddress(enc, &(val)->rasAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_EndpointType(enc, &(val)->endpointType))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_Endpoint_tokens(enc, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Enc_Endpoint_cryptoTokens(enc, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1PEREncBitVal(enc, 7, (val)->priority))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1Enc_Endpoint_remoteExtensionAddress(enc, &(val)->remoteExtensionAddress))
	    return 0;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1Enc_Endpoint_destExtraCallInfo(enc, &(val)->destExtraCallInfo))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint(ASN1decoding_t dec, Endpoint *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 10, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_Endpoint_aliasAddress(dec, &(val)->aliasAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_Endpoint_callSignalAddress(dec, &(val)->callSignalAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_Endpoint_rasAddress(dec, &(val)->rasAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_EndpointType(dec, &(val)->endpointType))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_Endpoint_tokens(dec, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Dec_Endpoint_cryptoTokens(dec, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1PERDecU16Val(dec, 7, &(val)->priority))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1Dec_Endpoint_remoteExtensionAddress(dec, &(val)->remoteExtensionAddress))
	    return 0;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1Dec_Endpoint_destExtraCallInfo(dec, &(val)->destExtraCallInfo))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint(Endpoint *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Endpoint_aliasAddress(&(val)->aliasAddress);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_Endpoint_callSignalAddress(&(val)->callSignalAddress);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_Endpoint_rasAddress(&(val)->rasAddress);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_EndpointType(&(val)->endpointType);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_Endpoint_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1Free_Endpoint_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_Endpoint_remoteExtensionAddress(&(val)->remoteExtensionAddress);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_Endpoint_destExtraCallInfo(&(val)->destExtraCallInfo);
	}
    }
}

static int ASN1CALL ASN1Enc_SupportedPrefix(ASN1encoding_t enc, SupportedPrefix *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Enc_AliasAddress(enc, &(val)->prefix))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SupportedPrefix(ASN1decoding_t dec, SupportedPrefix *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Dec_AliasAddress(dec, &(val)->prefix))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SupportedPrefix(SupportedPrefix *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1Free_AliasAddress(&(val)->prefix);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest(ASN1encoding_t enc, GatekeeperRequest *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(7, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Enc_TransportAddress(enc, &(val)->rasAddress))
	return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->endpointType))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_QseriesOptions(enc, &(val)->callServices))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_GatekeeperRequest_endpointAlias(enc, &(val)->endpointAlias))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 7, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_GatekeeperRequest_alternateEndpoints(ee, &(val)->alternateEndpoints))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_GatekeeperRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_GatekeeperRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_GatekeeperRequest_authenticationCapability(ee, &(val)->authenticationCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1Enc_GatekeeperRequest_algorithmOIDs(ee, &(val)->algorithmOIDs))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1Enc_GatekeeperRequest_integrity(ee, &(val)->integrity))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest(ASN1decoding_t dec, GatekeeperRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Dec_TransportAddress(dec, &(val)->rasAddress))
	return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->endpointType))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
	    return 0;
	((val)->gatekeeperIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_QseriesOptions(dec, &(val)->callServices))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_GatekeeperRequest_endpointAlias(dec, &(val)->endpointAlias))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 7, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperRequest_alternateEndpoints(dd, &(val)->alternateEndpoints))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperRequest_authenticationCapability(dd, &(val)->authenticationCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperRequest_algorithmOIDs(dd, &(val)->algorithmOIDs))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperRequest_integrity(dd, &(val)->integrity))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest(GatekeeperRequest *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1Free_TransportAddress(&(val)->rasAddress);
	ASN1Free_EndpointType(&(val)->endpointType);
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_GatekeeperRequest_endpointAlias(&(val)->endpointAlias);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_GatekeeperRequest_alternateEndpoints(&(val)->alternateEndpoints);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_GatekeeperRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_GatekeeperRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_GatekeeperRequest_authenticationCapability(&(val)->authenticationCapability);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_GatekeeperRequest_algorithmOIDs(&(val)->algorithmOIDs);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_GatekeeperRequest_integrity(&(val)->integrity);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest(ASN1encoding_t enc, RegistrationRequest *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    ASN1uint32_t l;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x4;
    o[1] |= 0x1;
    y = ASN1PEREncCheckExtensions(8, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 3, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->discoveryComplete))
	return 0;
    if (!ASN1Enc_RegistrationRequest_callSignalAddress(enc, &(val)->callSignalAddress))
	return 0;
    if (!ASN1Enc_RegistrationRequest_rasAddress(enc, &(val)->rasAddress))
	return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->terminalType))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1Enc_RegistrationRequest_terminalAlias(enc, &(val)->terminalAlias))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Enc_VendorIdentifier(enc, &(val)->endpointVendor))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 8, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_RegistrationRequest_alternateEndpoints(ee, &(val)->alternateEndpoints))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    l = ASN1uint32_uoctets((val)->timeToLive - 1);
	    if (!ASN1PEREncBitVal(ee, 2, l - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncBitVal(ee, l * 8, (val)->timeToLive - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_RegistrationRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_RegistrationRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1PEREncBoolean(ee, (val)->keepAlive))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x2) {
	    if (!ASN1PEREncBitVal(ee, 7, ((val)->endpointIdentifier).length - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncChar16String(ee, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x1) {
	    if (!ASN1PEREncBoolean(ee, (val)->willSupplyUUIEs))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest(ASN1decoding_t dec, RegistrationRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t l;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->discoveryComplete))
	return 0;
    if (!ASN1Dec_RegistrationRequest_callSignalAddress(dec, &(val)->callSignalAddress))
	return 0;
    if (!ASN1Dec_RegistrationRequest_rasAddress(dec, &(val)->rasAddress))
	return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->terminalType))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_RegistrationRequest_terminalAlias(dec, &(val)->terminalAlias))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
	    return 0;
	((val)->gatekeeperIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Dec_VendorIdentifier(dec, &(val)->endpointVendor))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 8, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationRequest_alternateEndpoints(dd, &(val)->alternateEndpoints))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 2, &l))
		return 0;
	    l += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecU32Val(dd, l * 8, &(val)->timeToLive))
		return 0;
	    (val)->timeToLive += 1;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->keepAlive))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 7, &((val)->endpointIdentifier).length))
		return 0;
	    ((val)->endpointIdentifier).length += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecChar16String(dd, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->willSupplyUUIEs))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest(RegistrationRequest *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1Free_RegistrationRequest_callSignalAddress(&(val)->callSignalAddress);
	ASN1Free_RegistrationRequest_rasAddress(&(val)->rasAddress);
	ASN1Free_EndpointType(&(val)->terminalType);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_RegistrationRequest_terminalAlias(&(val)->terminalAlias);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	ASN1Free_VendorIdentifier(&(val)->endpointVendor);
	if ((val)->o[1] & 0x80) {
	    ASN1Free_RegistrationRequest_alternateEndpoints(&(val)->alternateEndpoints);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_RegistrationRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_RegistrationRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1char16string_free(&(val)->endpointIdentifier);
	}
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm(ASN1encoding_t enc, AdmissionConfirm *val)
{
    ASN1octet_t o[3];
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 3);
    o[2] |= 0x40;
    o[2] |= 0x20;
    y = ASN1PEREncCheckExtensions(11, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    l = ASN1uint32_uoctets((val)->bandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bandWidth))
	return 0;
    if (!ASN1Enc_CallModel(enc, &(val)->callModel))
	return 0;
    if (!ASN1Enc_TransportAddress(enc, &(val)->destCallSignalAddress))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->irrFrequency - 1))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 11, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_AdmissionConfirm_destinationInfo(ee, &(val)->destinationInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_AdmissionConfirm_destExtraCallInfo(ee, &(val)->destExtraCallInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_EndpointType(ee, &(val)->destinationType))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_AdmissionConfirm_remoteExtensionAddress(ee, &(val)->remoteExtensionAddress))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_AdmissionConfirm_alternateEndpoints(ee, &(val)->alternateEndpoints))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1Enc_AdmissionConfirm_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x2) {
	    if (!ASN1Enc_AdmissionConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x1) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[2] & 0x80) {
	    if (!ASN1Enc_TransportQOS(ee, &(val)->transportQOS))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[2] & 0x40) {
	    if (!ASN1PEREncBoolean(ee, (val)->willRespondToIRR))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[2] & 0x20) {
	    if (!ASN1Enc_UUIEsRequested(ee, &(val)->uuiesRequested))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm(ASN1decoding_t dec, AdmissionConfirm *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bandWidth))
	return 0;
    if (!ASN1Dec_CallModel(dec, &(val)->callModel))
	return 0;
    if (!ASN1Dec_TransportAddress(dec, &(val)->destCallSignalAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->irrFrequency))
	    return 0;
	(val)->irrFrequency += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 2);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 11, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionConfirm_destinationInfo(dd, &(val)->destinationInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionConfirm_destExtraCallInfo(dd, &(val)->destExtraCallInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_EndpointType(dd, &(val)->destinationType))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionConfirm_remoteExtensionAddress(dd, &(val)->remoteExtensionAddress))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionConfirm_alternateEndpoints(dd, &(val)->alternateEndpoints))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionConfirm_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[2] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_TransportQOS(dd, &(val)->transportQOS))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[2] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->willRespondToIRR))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[2] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_UUIEsRequested(dd, &(val)->uuiesRequested))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm(AdmissionConfirm *val)
{
    if (val) {
	ASN1Free_TransportAddress(&(val)->destCallSignalAddress);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AdmissionConfirm_destinationInfo(&(val)->destinationInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_AdmissionConfirm_destExtraCallInfo(&(val)->destExtraCallInfo);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_EndpointType(&(val)->destinationType);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_AdmissionConfirm_remoteExtensionAddress(&(val)->remoteExtensionAddress);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_AdmissionConfirm_alternateEndpoints(&(val)->alternateEndpoints);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_AdmissionConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1Free_AdmissionConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x1) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm(ASN1encoding_t enc, LocationConfirm *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(8, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_TransportAddress(enc, &(val)->callSignalAddress))
	return 0;
    if (!ASN1Enc_TransportAddress(enc, &(val)->rasAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 8, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_LocationConfirm_destinationInfo(ee, &(val)->destinationInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_LocationConfirm_destExtraCallInfo(ee, &(val)->destExtraCallInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_EndpointType(ee, &(val)->destinationType))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_LocationConfirm_remoteExtensionAddress(ee, &(val)->remoteExtensionAddress))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1Enc_LocationConfirm_alternateEndpoints(ee, &(val)->alternateEndpoints))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1Enc_LocationConfirm_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1Enc_LocationConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm(ASN1decoding_t dec, LocationConfirm *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_TransportAddress(dec, &(val)->callSignalAddress))
	return 0;
    if (!ASN1Dec_TransportAddress(dec, &(val)->rasAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 8, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_LocationConfirm_destinationInfo(dd, &(val)->destinationInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_LocationConfirm_destExtraCallInfo(dd, &(val)->destExtraCallInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_EndpointType(dd, &(val)->destinationType))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_LocationConfirm_remoteExtensionAddress(dd, &(val)->remoteExtensionAddress))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_LocationConfirm_alternateEndpoints(dd, &(val)->alternateEndpoints))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_LocationConfirm_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_LocationConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm(LocationConfirm *val)
{
    if (val) {
	ASN1Free_TransportAddress(&(val)->callSignalAddress);
	ASN1Free_TransportAddress(&(val)->rasAddress);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_LocationConfirm_destinationInfo(&(val)->destinationInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_LocationConfirm_destExtraCallInfo(&(val)->destExtraCallInfo);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_EndpointType(&(val)->destinationType);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_LocationConfirm_remoteExtensionAddress(&(val)->remoteExtensionAddress);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_LocationConfirm_alternateEndpoints(&(val)->alternateEndpoints);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_LocationConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1Free_LocationConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x1) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse(ASN1encoding_t enc, InfoRequestResponse *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x10;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 3, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->endpointType))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1Enc_TransportAddress(enc, &(val)->rasAddress))
	return 0;
    if (!ASN1Enc_InfoRequestResponse_callSignalAddress(enc, &(val)->callSignalAddress))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1Enc_InfoRequestResponse_endpointAlias(enc, &(val)->endpointAlias))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1Enc_InfoRequestResponse_perCallInfo(enc, &(val)->perCallInfo))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_InfoRequestResponse_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_InfoRequestResponse_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1PEREncBoolean(ee, (val)->needResponse))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse(ASN1decoding_t dec, InfoRequestResponse *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_EndpointType(dec, &(val)->endpointType))
	return 0;
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1Dec_TransportAddress(dec, &(val)->rasAddress))
	return 0;
    if (!ASN1Dec_InfoRequestResponse_callSignalAddress(dec, &(val)->callSignalAddress))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_InfoRequestResponse_endpointAlias(dec, &(val)->endpointAlias))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_InfoRequestResponse_perCallInfo(dec, &(val)->perCallInfo))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequestResponse_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequestResponse_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->needResponse))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse(InfoRequestResponse *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1Free_EndpointType(&(val)->endpointType);
	ASN1char16string_free(&(val)->endpointIdentifier);
	ASN1Free_TransportAddress(&(val)->rasAddress);
	ASN1Free_InfoRequestResponse_callSignalAddress(&(val)->callSignalAddress);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_InfoRequestResponse_endpointAlias(&(val)->endpointAlias);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_InfoRequestResponse_perCallInfo(&(val)->perCallInfo);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_InfoRequestResponse_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_InfoRequestResponse_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_protocols(ASN1encoding_t enc, PResourcesAvailableIndicate_protocols *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ResourcesAvailableIndicate_protocols_ElmFn);
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_protocols_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_protocols val)
{
    if (!ASN1Enc_SupportedProtocols(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_protocols(ASN1decoding_t dec, PResourcesAvailableIndicate_protocols *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ResourcesAvailableIndicate_protocols_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_protocols_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_protocols val)
{
    if (!ASN1Dec_SupportedProtocols(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_protocols(PResourcesAvailableIndicate_protocols *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ResourcesAvailableIndicate_protocols_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_protocols_ElmFn(PResourcesAvailableIndicate_protocols val)
{
    if (val) {
	ASN1Free_SupportedProtocols(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_endpointAlias(ASN1encoding_t enc, PInfoRequestResponse_endpointAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_endpointAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_endpointAlias_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_endpointAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_endpointAlias(ASN1decoding_t dec, PInfoRequestResponse_endpointAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_endpointAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_endpointAlias_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_endpointAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_endpointAlias(PInfoRequestResponse_endpointAlias *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_endpointAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_endpointAlias_ElmFn(PInfoRequestResponse_endpointAlias val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_alternateEndpoints(ASN1encoding_t enc, PLocationConfirm_alternateEndpoints *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_alternateEndpoints_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_alternateEndpoints_ElmFn(ASN1encoding_t enc, PLocationConfirm_alternateEndpoints val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_alternateEndpoints(ASN1decoding_t dec, PLocationConfirm_alternateEndpoints *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_alternateEndpoints_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_alternateEndpoints_ElmFn(ASN1decoding_t dec, PLocationConfirm_alternateEndpoints val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_alternateEndpoints(PLocationConfirm_alternateEndpoints *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_alternateEndpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_alternateEndpoints_ElmFn(PLocationConfirm_alternateEndpoints val)
{
    if (val) {
	ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_remoteExtensionAddress(ASN1encoding_t enc, PLocationConfirm_remoteExtensionAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_remoteExtensionAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PLocationConfirm_remoteExtensionAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_remoteExtensionAddress(ASN1decoding_t dec, PLocationConfirm_remoteExtensionAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_remoteExtensionAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PLocationConfirm_remoteExtensionAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_remoteExtensionAddress(PLocationConfirm_remoteExtensionAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_remoteExtensionAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_remoteExtensionAddress_ElmFn(PLocationConfirm_remoteExtensionAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_destExtraCallInfo(ASN1encoding_t enc, PLocationConfirm_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PLocationConfirm_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_destExtraCallInfo(ASN1decoding_t dec, PLocationConfirm_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PLocationConfirm_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_destExtraCallInfo(PLocationConfirm_destExtraCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_destExtraCallInfo_ElmFn(PLocationConfirm_destExtraCallInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_destinationInfo(ASN1encoding_t enc, PLocationConfirm_destinationInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_destinationInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_destinationInfo_ElmFn(ASN1encoding_t enc, PLocationConfirm_destinationInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_destinationInfo(ASN1decoding_t dec, PLocationConfirm_destinationInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_destinationInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_destinationInfo_ElmFn(ASN1decoding_t dec, PLocationConfirm_destinationInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_destinationInfo(PLocationConfirm_destinationInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_destinationInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_destinationInfo_ElmFn(PLocationConfirm_destinationInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationRequest_sourceInfo(ASN1encoding_t enc, PLocationRequest_sourceInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationRequest_sourceInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationRequest_sourceInfo_ElmFn(ASN1encoding_t enc, PLocationRequest_sourceInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRequest_sourceInfo(ASN1decoding_t dec, PLocationRequest_sourceInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationRequest_sourceInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationRequest_sourceInfo_ElmFn(ASN1decoding_t dec, PLocationRequest_sourceInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationRequest_sourceInfo(PLocationRequest_sourceInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationRequest_sourceInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationRequest_sourceInfo_ElmFn(PLocationRequest_sourceInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationRequest_destinationInfo(ASN1encoding_t enc, PLocationRequest_destinationInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationRequest_destinationInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationRequest_destinationInfo_ElmFn(ASN1encoding_t enc, PLocationRequest_destinationInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRequest_destinationInfo(ASN1decoding_t dec, PLocationRequest_destinationInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationRequest_destinationInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationRequest_destinationInfo_ElmFn(ASN1decoding_t dec, PLocationRequest_destinationInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationRequest_destinationInfo(PLocationRequest_destinationInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationRequest_destinationInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationRequest_destinationInfo_ElmFn(PLocationRequest_destinationInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_alternateEndpoints(ASN1encoding_t enc, PAdmissionConfirm_alternateEndpoints *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_alternateEndpoints_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_alternateEndpoints_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_alternateEndpoints val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_alternateEndpoints(ASN1decoding_t dec, PAdmissionConfirm_alternateEndpoints *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_alternateEndpoints_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_alternateEndpoints_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_alternateEndpoints val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_alternateEndpoints(PAdmissionConfirm_alternateEndpoints *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_alternateEndpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_alternateEndpoints_ElmFn(PAdmissionConfirm_alternateEndpoints val)
{
    if (val) {
	ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_remoteExtensionAddress(ASN1encoding_t enc, PAdmissionConfirm_remoteExtensionAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_remoteExtensionAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_remoteExtensionAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_remoteExtensionAddress(ASN1decoding_t dec, PAdmissionConfirm_remoteExtensionAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_remoteExtensionAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_remoteExtensionAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_remoteExtensionAddress(PAdmissionConfirm_remoteExtensionAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_remoteExtensionAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_remoteExtensionAddress_ElmFn(PAdmissionConfirm_remoteExtensionAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_destExtraCallInfo(ASN1encoding_t enc, PAdmissionConfirm_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_destExtraCallInfo(ASN1decoding_t dec, PAdmissionConfirm_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_destExtraCallInfo(PAdmissionConfirm_destExtraCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_destExtraCallInfo_ElmFn(PAdmissionConfirm_destExtraCallInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_destinationInfo(ASN1encoding_t enc, PAdmissionConfirm_destinationInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_destinationInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_destinationInfo_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_destinationInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_destinationInfo(ASN1decoding_t dec, PAdmissionConfirm_destinationInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_destinationInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_destinationInfo_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_destinationInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_destinationInfo(PAdmissionConfirm_destinationInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_destinationInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_destinationInfo_ElmFn(PAdmissionConfirm_destinationInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destAlternatives(ASN1encoding_t enc, PAdmissionRequest_destAlternatives *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_destAlternatives_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destAlternatives_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destAlternatives val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destAlternatives(ASN1decoding_t dec, PAdmissionRequest_destAlternatives *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_destAlternatives_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destAlternatives_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destAlternatives val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_destAlternatives(PAdmissionRequest_destAlternatives *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_destAlternatives_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_destAlternatives_ElmFn(PAdmissionRequest_destAlternatives val)
{
    if (val) {
	ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_srcAlternatives(ASN1encoding_t enc, PAdmissionRequest_srcAlternatives *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_srcAlternatives_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_srcAlternatives_ElmFn(ASN1encoding_t enc, PAdmissionRequest_srcAlternatives val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_srcAlternatives(ASN1decoding_t dec, PAdmissionRequest_srcAlternatives *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_srcAlternatives_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_srcAlternatives_ElmFn(ASN1decoding_t dec, PAdmissionRequest_srcAlternatives val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_srcAlternatives(PAdmissionRequest_srcAlternatives *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_srcAlternatives_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_srcAlternatives_ElmFn(PAdmissionRequest_srcAlternatives val)
{
    if (val) {
	ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_srcInfo(ASN1encoding_t enc, PAdmissionRequest_srcInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_srcInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_srcInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_srcInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_srcInfo(ASN1decoding_t dec, PAdmissionRequest_srcInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_srcInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_srcInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_srcInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_srcInfo(PAdmissionRequest_srcInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_srcInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_srcInfo_ElmFn(PAdmissionRequest_srcInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destExtraCallInfo(ASN1encoding_t enc, PAdmissionRequest_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destExtraCallInfo(ASN1decoding_t dec, PAdmissionRequest_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_destExtraCallInfo(PAdmissionRequest_destExtraCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_destExtraCallInfo_ElmFn(PAdmissionRequest_destExtraCallInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destinationInfo(ASN1encoding_t enc, PAdmissionRequest_destinationInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_destinationInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destinationInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destinationInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destinationInfo(ASN1decoding_t dec, PAdmissionRequest_destinationInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_destinationInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destinationInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destinationInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_destinationInfo(PAdmissionRequest_destinationInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_destinationInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_destinationInfo_ElmFn(PAdmissionRequest_destinationInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_alternateEndpoints(ASN1encoding_t enc, PUnregistrationRequest_alternateEndpoints *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationRequest_alternateEndpoints_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_alternateEndpoints val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_alternateEndpoints(ASN1decoding_t dec, PUnregistrationRequest_alternateEndpoints *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationRequest_alternateEndpoints_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_alternateEndpoints val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest_alternateEndpoints(PUnregistrationRequest_alternateEndpoints *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationRequest_alternateEndpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationRequest_alternateEndpoints_ElmFn(PUnregistrationRequest_alternateEndpoints val)
{
    if (val) {
	ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_endpointAlias(ASN1encoding_t enc, PUnregistrationRequest_endpointAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationRequest_endpointAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_endpointAlias_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_endpointAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_endpointAlias(ASN1decoding_t dec, PUnregistrationRequest_endpointAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationRequest_endpointAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_endpointAlias_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_endpointAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest_endpointAlias(PUnregistrationRequest_endpointAlias *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationRequest_endpointAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationRequest_endpointAlias_ElmFn(PUnregistrationRequest_endpointAlias val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRejectReason_duplicateAlias(ASN1encoding_t enc, PRegistrationRejectReason_duplicateAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRejectReason_duplicateAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRejectReason_duplicateAlias_ElmFn(ASN1encoding_t enc, PRegistrationRejectReason_duplicateAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRejectReason_duplicateAlias(ASN1decoding_t dec, PRegistrationRejectReason_duplicateAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRejectReason_duplicateAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRejectReason_duplicateAlias_ElmFn(ASN1decoding_t dec, PRegistrationRejectReason_duplicateAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRejectReason_duplicateAlias(PRegistrationRejectReason_duplicateAlias *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRejectReason_duplicateAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRejectReason_duplicateAlias_ElmFn(PRegistrationRejectReason_duplicateAlias val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_terminalAlias(ASN1encoding_t enc, PRegistrationConfirm_terminalAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationConfirm_terminalAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_terminalAlias_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_terminalAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_terminalAlias(ASN1decoding_t dec, PRegistrationConfirm_terminalAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationConfirm_terminalAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_terminalAlias_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_terminalAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm_terminalAlias(PRegistrationConfirm_terminalAlias *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationConfirm_terminalAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationConfirm_terminalAlias_ElmFn(PRegistrationConfirm_terminalAlias val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_alternateEndpoints(ASN1encoding_t enc, PRegistrationRequest_alternateEndpoints *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_alternateEndpoints_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PRegistrationRequest_alternateEndpoints val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_alternateEndpoints(ASN1decoding_t dec, PRegistrationRequest_alternateEndpoints *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_alternateEndpoints_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PRegistrationRequest_alternateEndpoints val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_alternateEndpoints(PRegistrationRequest_alternateEndpoints *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_alternateEndpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_alternateEndpoints_ElmFn(PRegistrationRequest_alternateEndpoints val)
{
    if (val) {
	ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_terminalAlias(ASN1encoding_t enc, PRegistrationRequest_terminalAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_terminalAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_terminalAlias_ElmFn(ASN1encoding_t enc, PRegistrationRequest_terminalAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_terminalAlias(ASN1decoding_t dec, PRegistrationRequest_terminalAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_terminalAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_terminalAlias_ElmFn(ASN1decoding_t dec, PRegistrationRequest_terminalAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_terminalAlias(PRegistrationRequest_terminalAlias *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_terminalAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_terminalAlias_ElmFn(PRegistrationRequest_terminalAlias val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_alternateEndpoints(ASN1encoding_t enc, PGatekeeperRequest_alternateEndpoints *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_alternateEndpoints_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_alternateEndpoints val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_alternateEndpoints(ASN1decoding_t dec, PGatekeeperRequest_alternateEndpoints *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_alternateEndpoints_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_alternateEndpoints val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_alternateEndpoints(PGatekeeperRequest_alternateEndpoints *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_alternateEndpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_alternateEndpoints_ElmFn(PGatekeeperRequest_alternateEndpoints val)
{
    if (val) {
	ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_endpointAlias(ASN1encoding_t enc, PGatekeeperRequest_endpointAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_endpointAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_endpointAlias_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_endpointAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_endpointAlias(ASN1decoding_t dec, PGatekeeperRequest_endpointAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_endpointAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_endpointAlias_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_endpointAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_endpointAlias(PGatekeeperRequest_endpointAlias *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_endpointAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_endpointAlias_ElmFn(PGatekeeperRequest_endpointAlias val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CryptoH323Token_cryptoEPPwdHash(ASN1encoding_t enc, CryptoH323Token_cryptoEPPwdHash *val)
{
    ASN1uint32_t l;
    if (!ASN1Enc_AliasAddress(enc, &(val)->alias))
	return 0;
    l = ASN1uint32_uoctets((val)->timeStamp - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->timeStamp - 1))
	return 0;
    if (!ASN1Enc_HASHED(enc, &(val)->token))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoH323Token_cryptoEPPwdHash(ASN1decoding_t dec, CryptoH323Token_cryptoEPPwdHash *val)
{
    ASN1uint32_t l;
    if (!ASN1Dec_AliasAddress(dec, &(val)->alias))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->timeStamp))
	return 0;
    (val)->timeStamp += 1;
    if (!ASN1Dec_HASHED(dec, &(val)->token))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CryptoH323Token_cryptoEPPwdHash(CryptoH323Token_cryptoEPPwdHash *val)
{
    if (val) {
	ASN1Free_AliasAddress(&(val)->alias);
	ASN1Free_HASHED(&(val)->token);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_destExtraCallInfo(ASN1encoding_t enc, PEndpoint_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PEndpoint_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_destExtraCallInfo(ASN1decoding_t dec, PEndpoint_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PEndpoint_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_destExtraCallInfo(PEndpoint_destExtraCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_destExtraCallInfo_ElmFn(PEndpoint_destExtraCallInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_remoteExtensionAddress(ASN1encoding_t enc, PEndpoint_remoteExtensionAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_remoteExtensionAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PEndpoint_remoteExtensionAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_remoteExtensionAddress(ASN1decoding_t dec, PEndpoint_remoteExtensionAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_remoteExtensionAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PEndpoint_remoteExtensionAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_remoteExtensionAddress(PEndpoint_remoteExtensionAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_remoteExtensionAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_remoteExtensionAddress_ElmFn(PEndpoint_remoteExtensionAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_aliasAddress(ASN1encoding_t enc, PEndpoint_aliasAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_aliasAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_aliasAddress_ElmFn(ASN1encoding_t enc, PEndpoint_aliasAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_aliasAddress(ASN1decoding_t dec, PEndpoint_aliasAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_aliasAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_aliasAddress_ElmFn(ASN1decoding_t dec, PEndpoint_aliasAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_aliasAddress(PEndpoint_aliasAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_aliasAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_aliasAddress_ElmFn(PEndpoint_aliasAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_NonStandardProtocol_supportedPrefixes(ASN1encoding_t enc, PNonStandardProtocol_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_NonStandardProtocol_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_NonStandardProtocol_supportedPrefixes_ElmFn(ASN1encoding_t enc, PNonStandardProtocol_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardProtocol_supportedPrefixes(ASN1decoding_t dec, PNonStandardProtocol_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_NonStandardProtocol_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_NonStandardProtocol_supportedPrefixes_ElmFn(ASN1decoding_t dec, PNonStandardProtocol_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardProtocol_supportedPrefixes(PNonStandardProtocol_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_NonStandardProtocol_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_NonStandardProtocol_supportedPrefixes_ElmFn(PNonStandardProtocol_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_T120OnlyCaps_supportedPrefixes(ASN1encoding_t enc, PT120OnlyCaps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_T120OnlyCaps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_T120OnlyCaps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PT120OnlyCaps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_T120OnlyCaps_supportedPrefixes(ASN1decoding_t dec, PT120OnlyCaps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_T120OnlyCaps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_T120OnlyCaps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PT120OnlyCaps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_T120OnlyCaps_supportedPrefixes(PT120OnlyCaps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_T120OnlyCaps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_T120OnlyCaps_supportedPrefixes_ElmFn(PT120OnlyCaps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_VoiceCaps_supportedPrefixes(ASN1encoding_t enc, PVoiceCaps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_VoiceCaps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_VoiceCaps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PVoiceCaps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VoiceCaps_supportedPrefixes(ASN1decoding_t dec, PVoiceCaps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_VoiceCaps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_VoiceCaps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PVoiceCaps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VoiceCaps_supportedPrefixes(PVoiceCaps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_VoiceCaps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_VoiceCaps_supportedPrefixes_ElmFn(PVoiceCaps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H324Caps_supportedPrefixes(ASN1encoding_t enc, PH324Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H324Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H324Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH324Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H324Caps_supportedPrefixes(ASN1decoding_t dec, PH324Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H324Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H324Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH324Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H324Caps_supportedPrefixes(PH324Caps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H324Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H324Caps_supportedPrefixes_ElmFn(PH324Caps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323Caps_supportedPrefixes(ASN1encoding_t enc, PH323Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H323Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H323Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH323Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323Caps_supportedPrefixes(ASN1decoding_t dec, PH323Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H323Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H323Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH323Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H323Caps_supportedPrefixes(PH323Caps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H323Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H323Caps_supportedPrefixes_ElmFn(PH323Caps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H322Caps_supportedPrefixes(ASN1encoding_t enc, PH322Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H322Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H322Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH322Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H322Caps_supportedPrefixes(ASN1decoding_t dec, PH322Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H322Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H322Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH322Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H322Caps_supportedPrefixes(PH322Caps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H322Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H322Caps_supportedPrefixes_ElmFn(PH322Caps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H321Caps_supportedPrefixes(ASN1encoding_t enc, PH321Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H321Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H321Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH321Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H321Caps_supportedPrefixes(ASN1decoding_t dec, PH321Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H321Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H321Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH321Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H321Caps_supportedPrefixes(PH321Caps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H321Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H321Caps_supportedPrefixes_ElmFn(PH321Caps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H320Caps_supportedPrefixes(ASN1encoding_t enc, PH320Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H320Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H320Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH320Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H320Caps_supportedPrefixes(ASN1decoding_t dec, PH320Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H320Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H320Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH320Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H320Caps_supportedPrefixes(PH320Caps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H320Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H320Caps_supportedPrefixes_ElmFn(PH320Caps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H310Caps_supportedPrefixes(ASN1encoding_t enc, PH310Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H310Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H310Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH310Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H310Caps_supportedPrefixes(ASN1decoding_t dec, PH310Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H310Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H310Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH310Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H310Caps_supportedPrefixes(PH310Caps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H310Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H310Caps_supportedPrefixes_ElmFn(PH310Caps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatewayInfo_protocol(ASN1encoding_t enc, PGatewayInfo_protocol *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatewayInfo_protocol_ElmFn);
}

static int ASN1CALL ASN1Enc_GatewayInfo_protocol_ElmFn(ASN1encoding_t enc, PGatewayInfo_protocol val)
{
    if (!ASN1Enc_SupportedProtocols(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatewayInfo_protocol(ASN1decoding_t dec, PGatewayInfo_protocol *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatewayInfo_protocol_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatewayInfo_protocol_ElmFn(ASN1decoding_t dec, PGatewayInfo_protocol val)
{
    if (!ASN1Dec_SupportedProtocols(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatewayInfo_protocol(PGatewayInfo_protocol *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatewayInfo_protocol_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatewayInfo_protocol_ElmFn(PGatewayInfo_protocol val)
{
    if (val) {
	ASN1Free_SupportedProtocols(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_destExtraCallInfo(ASN1encoding_t enc, PFacility_UUIE_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PFacility_UUIE_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_destExtraCallInfo(ASN1decoding_t dec, PFacility_UUIE_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PFacility_UUIE_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_destExtraCallInfo(PFacility_UUIE_destExtraCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_destExtraCallInfo_ElmFn(PFacility_UUIE_destExtraCallInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_alternativeAliasAddress(ASN1encoding_t enc, PFacility_UUIE_alternativeAliasAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_alternativeAliasAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_alternativeAliasAddress_ElmFn(ASN1encoding_t enc, PFacility_UUIE_alternativeAliasAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_alternativeAliasAddress(ASN1decoding_t dec, PFacility_UUIE_alternativeAliasAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_alternativeAliasAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_alternativeAliasAddress_ElmFn(ASN1decoding_t dec, PFacility_UUIE_alternativeAliasAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_alternativeAliasAddress(PFacility_UUIE_alternativeAliasAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_alternativeAliasAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_alternativeAliasAddress_ElmFn(PFacility_UUIE_alternativeAliasAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCallInfo(ASN1encoding_t enc, PSetup_UUIE_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCallInfo(ASN1decoding_t dec, PSetup_UUIE_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCallInfo(PSetup_UUIE_destExtraCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCallInfo_ElmFn(PSetup_UUIE_destExtraCallInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destinationAddress(ASN1encoding_t enc, PSetup_UUIE_destinationAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_destinationAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destinationAddress_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destinationAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destinationAddress(ASN1decoding_t dec, PSetup_UUIE_destinationAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_destinationAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destinationAddress_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destinationAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_destinationAddress(PSetup_UUIE_destinationAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_destinationAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_destinationAddress_ElmFn(PSetup_UUIE_destinationAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_sourceAddress(ASN1encoding_t enc, PSetup_UUIE_sourceAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_sourceAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_sourceAddress_ElmFn(ASN1encoding_t enc, PSetup_UUIE_sourceAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_sourceAddress(ASN1decoding_t dec, PSetup_UUIE_sourceAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_sourceAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_sourceAddress_ElmFn(ASN1decoding_t dec, PSetup_UUIE_sourceAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_sourceAddress(PSetup_UUIE_sourceAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_sourceAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_sourceAddress_ElmFn(PSetup_UUIE_sourceAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Alerting_UUIE(ASN1encoding_t enc, Alerting_UUIE *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->destinationInfo))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 5, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H245Security(ee, &(val)->h245SecurityMode))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_Alerting_UUIE_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_Alerting_UUIE_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_Alerting_UUIE_fastStart(ee, &(val)->fastStart))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Alerting_UUIE(ASN1decoding_t dec, Alerting_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->destinationInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H245Security(dd, &(val)->h245SecurityMode))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_Alerting_UUIE_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_Alerting_UUIE_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_Alerting_UUIE_fastStart(dd, &(val)->fastStart))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_Alerting_UUIE(Alerting_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	ASN1Free_EndpointType(&(val)->destinationInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H245Security(&(val)->h245SecurityMode);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_Alerting_UUIE_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_Alerting_UUIE_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_Alerting_UUIE_fastStart(&(val)->fastStart);
	}
    }
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE(ASN1encoding_t enc, CallProceeding_UUIE *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->destinationInfo))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 5, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H245Security(ee, &(val)->h245SecurityMode))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_CallProceeding_UUIE_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_CallProceeding_UUIE_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_CallProceeding_UUIE_fastStart(ee, &(val)->fastStart))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE(ASN1decoding_t dec, CallProceeding_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->destinationInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H245Security(dd, &(val)->h245SecurityMode))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_CallProceeding_UUIE_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_CallProceeding_UUIE_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_CallProceeding_UUIE_fastStart(dd, &(val)->fastStart))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE(CallProceeding_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	ASN1Free_EndpointType(&(val)->destinationInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H245Security(&(val)->h245SecurityMode);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_CallProceeding_UUIE_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_CallProceeding_UUIE_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_CallProceeding_UUIE_fastStart(&(val)->fastStart);
	}
    }
}

static int ASN1CALL ASN1Enc_Connect_UUIE(ASN1encoding_t enc, Connect_UUIE *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
	    return 0;
    }
    if (!ASN1Enc_EndpointType(enc, &(val)->destinationInfo))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 5, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H245Security(ee, &(val)->h245SecurityMode))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_Connect_UUIE_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_Connect_UUIE_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_Connect_UUIE_fastStart(ee, &(val)->fastStart))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Connect_UUIE(ASN1decoding_t dec, Connect_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
	    return 0;
    }
    if (!ASN1Dec_EndpointType(dec, &(val)->destinationInfo))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H245Security(dd, &(val)->h245SecurityMode))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_Connect_UUIE_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_Connect_UUIE_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_Connect_UUIE_fastStart(dd, &(val)->fastStart))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_Connect_UUIE(Connect_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
	ASN1Free_EndpointType(&(val)->destinationInfo);
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H245Security(&(val)->h245SecurityMode);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_Connect_UUIE_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_Connect_UUIE_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_Connect_UUIE_fastStart(&(val)->fastStart);
	}
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE(ASN1encoding_t enc, Setup_UUIE *val)
{
    ASN1octet_t o[3];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 3);
    o[1] |= 0x20;
    o[1] |= 0x1;
    o[2] |= 0x80;
    y = ASN1PEREncCheckExtensions(9, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 7, o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1Enc_Setup_UUIE_sourceAddress(enc, &(val)->sourceAddress))
	    return 0;
    }
    if (!ASN1Enc_EndpointType(enc, &(val)->sourceInfo))
	return 0;
    if (o[0] & 0x20) {
	if (!ASN1Enc_Setup_UUIE_destinationAddress(enc, &(val)->destinationAddress))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->destCallSignalAddress))
	    return 0;
    }
    if (o[0] & 0x8) {
	if (!ASN1Enc_Setup_UUIE_destExtraCallInfo(enc, &(val)->destExtraCallInfo))
	    return 0;
    }
    if (o[0] & 0x4) {
	if (!ASN1Enc_Setup_UUIE_destExtraCRV(enc, &(val)->destExtraCRV))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->activeMC))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1Enc_Setup_UUIE_conferenceGoal(enc, &(val)->conferenceGoal))
	return 0;
    if (o[0] & 0x2) {
	if (!ASN1Enc_QseriesOptions(enc, &(val)->callServices))
	    return 0;
    }
    if (!ASN1Enc_CallType(enc, &(val)->callType))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 9, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_TransportAddress(ee, &(val)->sourceCallSignalAddress))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_AliasAddress(ee, &(val)->remoteExtensionAddress))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_Setup_UUIE_h245SecurityCapability(ee, &(val)->h245SecurityCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_Setup_UUIE_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1Enc_Setup_UUIE_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x2) {
	    if (!ASN1Enc_Setup_UUIE_fastStart(ee, &(val)->fastStart))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x1) {
	    if (!ASN1PEREncBoolean(ee, (val)->mediaWaitForConnect))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[2] & 0x80) {
	    if (!ASN1PEREncBoolean(ee, (val)->canOverlapSend))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE(ASN1decoding_t dec, Setup_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_Setup_UUIE_sourceAddress(dec, &(val)->sourceAddress))
	    return 0;
    }
    if (!ASN1Dec_EndpointType(dec, &(val)->sourceInfo))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_Setup_UUIE_destinationAddress(dec, &(val)->destinationAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->destCallSignalAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_Setup_UUIE_destExtraCallInfo(dec, &(val)->destExtraCallInfo))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_Setup_UUIE_destExtraCRV(dec, &(val)->destExtraCRV))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->activeMC))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1Dec_Setup_UUIE_conferenceGoal(dec, &(val)->conferenceGoal))
	return 0;
    if ((val)->o[0] & 0x2) {
	if (!ASN1Dec_QseriesOptions(dec, &(val)->callServices))
	    return 0;
    }
    if (!ASN1Dec_CallType(dec, &(val)->callType))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 2);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 9, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_TransportAddress(dd, &(val)->sourceCallSignalAddress))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AliasAddress(dd, &(val)->remoteExtensionAddress))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_Setup_UUIE_h245SecurityCapability(dd, &(val)->h245SecurityCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_Setup_UUIE_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_Setup_UUIE_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_Setup_UUIE_fastStart(dd, &(val)->fastStart))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->mediaWaitForConnect))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[2] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->canOverlapSend))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE(Setup_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Setup_UUIE_sourceAddress(&(val)->sourceAddress);
	}
	ASN1Free_EndpointType(&(val)->sourceInfo);
	if ((val)->o[0] & 0x20) {
	    ASN1Free_Setup_UUIE_destinationAddress(&(val)->destinationAddress);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_TransportAddress(&(val)->destCallSignalAddress);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_Setup_UUIE_destExtraCallInfo(&(val)->destExtraCallInfo);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_Setup_UUIE_destExtraCRV(&(val)->destExtraCRV);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->sourceCallSignalAddress);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_AliasAddress(&(val)->remoteExtensionAddress);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_Setup_UUIE_h245SecurityCapability(&(val)->h245SecurityCapability);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_Setup_UUIE_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_Setup_UUIE_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1Free_Setup_UUIE_fastStart(&(val)->fastStart);
	}
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE(ASN1encoding_t enc, Facility_UUIE *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(8, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 3, o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->alternativeAddress))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1Enc_Facility_UUIE_alternativeAliasAddress(enc, &(val)->alternativeAliasAddress))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	    return 0;
    }
    if (!ASN1Enc_FacilityReason(enc, &(val)->reason))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 8, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_Facility_UUIE_destExtraCallInfo(ee, &(val)->destExtraCallInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_AliasAddress(ee, &(val)->remoteExtensionAddress))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_Facility_UUIE_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_Facility_UUIE_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1Enc_Facility_UUIE_conferences(ee, &(val)->conferences))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x2) {
	    if (!ASN1Enc_TransportAddress(ee, &(val)->h245Address))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x1) {
	    if (!ASN1Enc_Facility_UUIE_fastStart(ee, &(val)->fastStart))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE(ASN1decoding_t dec, Facility_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->alternativeAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_Facility_UUIE_alternativeAliasAddress(dec, &(val)->alternativeAliasAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	    return 0;
    }
    if (!ASN1Dec_FacilityReason(dec, &(val)->reason))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 8, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_Facility_UUIE_destExtraCallInfo(dd, &(val)->destExtraCallInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_AliasAddress(dd, &(val)->remoteExtensionAddress))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_Facility_UUIE_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_Facility_UUIE_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_Facility_UUIE_conferences(dd, &(val)->conferences))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_TransportAddress(dd, &(val)->h245Address))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_Facility_UUIE_fastStart(dd, &(val)->fastStart))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE(Facility_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->alternativeAddress);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Facility_UUIE_alternativeAliasAddress(&(val)->alternativeAliasAddress);
	}
	if ((val)->o[0] & 0x20) {
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_Facility_UUIE_destExtraCallInfo(&(val)->destExtraCallInfo);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_AliasAddress(&(val)->remoteExtensionAddress);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_Facility_UUIE_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_Facility_UUIE_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_Facility_UUIE_conferences(&(val)->conferences);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
	if ((val)->o[1] & 0x1) {
	    ASN1Free_Facility_UUIE_fastStart(&(val)->fastStart);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceList(ASN1encoding_t enc, ConferenceList *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_AliasAddress(enc, &(val)->conferenceAlias))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceList(ASN1decoding_t dec, ConferenceList *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_AliasAddress(dec, &(val)->conferenceAlias))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceList(ConferenceList *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_AliasAddress(&(val)->conferenceAlias);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_Progress_UUIE(ASN1encoding_t enc, Progress_UUIE *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->destinationInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
	    return 0;
    }
    if (!ASN1Enc_CallIdentifier(enc, &(val)->callIdentifier))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_H245Security(enc, &(val)->h245SecurityMode))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_Progress_UUIE_tokens(enc, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_Progress_UUIE_cryptoTokens(enc, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_Progress_UUIE_fastStart(enc, &(val)->fastStart))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Progress_UUIE(ASN1decoding_t dec, Progress_UUIE *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->destinationInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
	    return 0;
    }
    if (!ASN1Dec_CallIdentifier(dec, &(val)->callIdentifier))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_H245Security(dec, &(val)->h245SecurityMode))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_Progress_UUIE_tokens(dec, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_Progress_UUIE_cryptoTokens(dec, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_Progress_UUIE_fastStart(dec, &(val)->fastStart))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Progress_UUIE(Progress_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	ASN1Free_EndpointType(&(val)->destinationInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
	ASN1Free_CallIdentifier(&(val)->callIdentifier);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H245Security(&(val)->h245SecurityMode);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_Progress_UUIE_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_Progress_UUIE_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_Progress_UUIE_fastStart(&(val)->fastStart);
	}
    }
}

static int ASN1CALL ASN1Enc_CryptoH323Token(ASN1encoding_t enc, CryptoH323Token *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_CryptoH323Token_cryptoEPPwdHash(enc, &(val)->u.cryptoEPPwdHash))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_CryptoH323Token_cryptoGKPwdHash(enc, &(val)->u.cryptoGKPwdHash))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ENCRYPTED(enc, &(val)->u.cryptoEPPwdEncr))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ENCRYPTED(enc, &(val)->u.cryptoGKPwdEncr))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_SIGNED_EncodedPwdCertToken(enc, &(val)->u.cryptoEPCert))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_SIGNED_EncodedPwdCertToken(enc, &(val)->u.cryptoGKCert))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_SIGNED_EncodedFastStartToken(enc, &(val)->u.cryptoFastStart))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_CryptoToken(enc, &(val)->u.nestedcryptoToken))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoH323Token(ASN1decoding_t dec, CryptoH323Token *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_CryptoH323Token_cryptoEPPwdHash(dec, &(val)->u.cryptoEPPwdHash))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_CryptoH323Token_cryptoGKPwdHash(dec, &(val)->u.cryptoGKPwdHash))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ENCRYPTED(dec, &(val)->u.cryptoEPPwdEncr))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ENCRYPTED(dec, &(val)->u.cryptoGKPwdEncr))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_SIGNED_EncodedPwdCertToken(dec, &(val)->u.cryptoEPCert))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_SIGNED_EncodedPwdCertToken(dec, &(val)->u.cryptoGKCert))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_SIGNED_EncodedFastStartToken(dec, &(val)->u.cryptoFastStart))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_CryptoToken(dec, &(val)->u.nestedcryptoToken))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CryptoH323Token(CryptoH323Token *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_CryptoH323Token_cryptoEPPwdHash(&(val)->u.cryptoEPPwdHash);
	    break;
	case 2:
	    ASN1Free_CryptoH323Token_cryptoGKPwdHash(&(val)->u.cryptoGKPwdHash);
	    break;
	case 3:
	    ASN1Free_ENCRYPTED(&(val)->u.cryptoEPPwdEncr);
	    break;
	case 4:
	    ASN1Free_ENCRYPTED(&(val)->u.cryptoGKPwdEncr);
	    break;
	case 5:
	    ASN1Free_SIGNED_EncodedPwdCertToken(&(val)->u.cryptoEPCert);
	    break;
	case 6:
	    ASN1Free_SIGNED_EncodedPwdCertToken(&(val)->u.cryptoGKCert);
	    break;
	case 7:
	    ASN1Free_SIGNED_EncodedFastStartToken(&(val)->u.cryptoFastStart);
	    break;
	case 8:
	    ASN1Free_CryptoToken(&(val)->u.nestedcryptoToken);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RasMessage(ASN1encoding_t enc, RasMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 5, 25))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_GatekeeperRequest(enc, &(val)->u.gatekeeperRequest))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_GatekeeperConfirm(enc, &(val)->u.gatekeeperConfirm))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_GatekeeperReject(enc, &(val)->u.gatekeeperReject))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_RegistrationRequest(enc, &(val)->u.registrationRequest))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_RegistrationConfirm(enc, &(val)->u.registrationConfirm))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_RegistrationReject(enc, &(val)->u.registrationReject))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_UnregistrationRequest(enc, &(val)->u.unregistrationRequest))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_UnregistrationConfirm(enc, &(val)->u.unregistrationConfirm))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_UnregistrationReject(enc, &(val)->u.unregistrationReject))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_AdmissionRequest(enc, &(val)->u.admissionRequest))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_AdmissionConfirm(enc, &(val)->u.admissionConfirm))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_AdmissionReject(enc, &(val)->u.admissionReject))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_BandwidthRequest(enc, &(val)->u.bandwidthRequest))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_BandwidthConfirm(enc, &(val)->u.bandwidthConfirm))
	    return 0;
	break;
    case 15:
	if (!ASN1Enc_BandwidthReject(enc, &(val)->u.bandwidthReject))
	    return 0;
	break;
    case 16:
	if (!ASN1Enc_DisengageRequest(enc, &(val)->u.disengageRequest))
	    return 0;
	break;
    case 17:
	if (!ASN1Enc_DisengageConfirm(enc, &(val)->u.disengageConfirm))
	    return 0;
	break;
    case 18:
	if (!ASN1Enc_DisengageReject(enc, &(val)->u.disengageReject))
	    return 0;
	break;
    case 19:
	if (!ASN1Enc_LocationRequest(enc, &(val)->u.locationRequest))
	    return 0;
	break;
    case 20:
	if (!ASN1Enc_LocationConfirm(enc, &(val)->u.locationConfirm))
	    return 0;
	break;
    case 21:
	if (!ASN1Enc_LocationReject(enc, &(val)->u.locationReject))
	    return 0;
	break;
    case 22:
	if (!ASN1Enc_InfoRequest(enc, &(val)->u.infoRequest))
	    return 0;
	break;
    case 23:
	if (!ASN1Enc_InfoRequestResponse(enc, &(val)->u.infoRequestResponse))
	    return 0;
	break;
    case 24:
	if (!ASN1Enc_H225NonStandardMessage(enc, &(val)->u.nonStandardMessage))
	    return 0;
	break;
    case 25:
	if (!ASN1Enc_UnknownMessageResponse(enc, &(val)->u.unknownMessageResponse))
	    return 0;
	break;
    case 26:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_RequestInProgress(ee, &(val)->u.requestInProgress))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 27:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ResourcesAvailableIndicate(ee, &(val)->u.resourcesAvailableIndicate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 28:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ResourcesAvailableConfirm(ee, &(val)->u.resourcesAvailableConfirm))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 29:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_InfoRequestAck(ee, &(val)->u.infoRequestAck))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 30:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_InfoRequestNak(ee, &(val)->u.infoRequestNak))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RasMessage(ASN1decoding_t dec, RasMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 5, 25))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_GatekeeperRequest(dec, &(val)->u.gatekeeperRequest))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_GatekeeperConfirm(dec, &(val)->u.gatekeeperConfirm))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_GatekeeperReject(dec, &(val)->u.gatekeeperReject))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_RegistrationRequest(dec, &(val)->u.registrationRequest))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_RegistrationConfirm(dec, &(val)->u.registrationConfirm))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_RegistrationReject(dec, &(val)->u.registrationReject))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_UnregistrationRequest(dec, &(val)->u.unregistrationRequest))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_UnregistrationConfirm(dec, &(val)->u.unregistrationConfirm))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_UnregistrationReject(dec, &(val)->u.unregistrationReject))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_AdmissionRequest(dec, &(val)->u.admissionRequest))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_AdmissionConfirm(dec, &(val)->u.admissionConfirm))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_AdmissionReject(dec, &(val)->u.admissionReject))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_BandwidthRequest(dec, &(val)->u.bandwidthRequest))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_BandwidthConfirm(dec, &(val)->u.bandwidthConfirm))
	    return 0;
	break;
    case 15:
	if (!ASN1Dec_BandwidthReject(dec, &(val)->u.bandwidthReject))
	    return 0;
	break;
    case 16:
	if (!ASN1Dec_DisengageRequest(dec, &(val)->u.disengageRequest))
	    return 0;
	break;
    case 17:
	if (!ASN1Dec_DisengageConfirm(dec, &(val)->u.disengageConfirm))
	    return 0;
	break;
    case 18:
	if (!ASN1Dec_DisengageReject(dec, &(val)->u.disengageReject))
	    return 0;
	break;
    case 19:
	if (!ASN1Dec_LocationRequest(dec, &(val)->u.locationRequest))
	    return 0;
	break;
    case 20:
	if (!ASN1Dec_LocationConfirm(dec, &(val)->u.locationConfirm))
	    return 0;
	break;
    case 21:
	if (!ASN1Dec_LocationReject(dec, &(val)->u.locationReject))
	    return 0;
	break;
    case 22:
	if (!ASN1Dec_InfoRequest(dec, &(val)->u.infoRequest))
	    return 0;
	break;
    case 23:
	if (!ASN1Dec_InfoRequestResponse(dec, &(val)->u.infoRequestResponse))
	    return 0;
	break;
    case 24:
	if (!ASN1Dec_H225NonStandardMessage(dec, &(val)->u.nonStandardMessage))
	    return 0;
	break;
    case 25:
	if (!ASN1Dec_UnknownMessageResponse(dec, &(val)->u.unknownMessageResponse))
	    return 0;
	break;
    case 26:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_RequestInProgress(dd, &(val)->u.requestInProgress))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 27:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_ResourcesAvailableIndicate(dd, &(val)->u.resourcesAvailableIndicate))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 28:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_ResourcesAvailableConfirm(dd, &(val)->u.resourcesAvailableConfirm))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 29:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_InfoRequestAck(dd, &(val)->u.infoRequestAck))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 30:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_InfoRequestNak(dd, &(val)->u.infoRequestNak))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RasMessage(RasMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_GatekeeperRequest(&(val)->u.gatekeeperRequest);
	    break;
	case 2:
	    ASN1Free_GatekeeperConfirm(&(val)->u.gatekeeperConfirm);
	    break;
	case 3:
	    ASN1Free_GatekeeperReject(&(val)->u.gatekeeperReject);
	    break;
	case 4:
	    ASN1Free_RegistrationRequest(&(val)->u.registrationRequest);
	    break;
	case 5:
	    ASN1Free_RegistrationConfirm(&(val)->u.registrationConfirm);
	    break;
	case 6:
	    ASN1Free_RegistrationReject(&(val)->u.registrationReject);
	    break;
	case 7:
	    ASN1Free_UnregistrationRequest(&(val)->u.unregistrationRequest);
	    break;
	case 8:
	    ASN1Free_UnregistrationConfirm(&(val)->u.unregistrationConfirm);
	    break;
	case 9:
	    ASN1Free_UnregistrationReject(&(val)->u.unregistrationReject);
	    break;
	case 10:
	    ASN1Free_AdmissionRequest(&(val)->u.admissionRequest);
	    break;
	case 11:
	    ASN1Free_AdmissionConfirm(&(val)->u.admissionConfirm);
	    break;
	case 12:
	    ASN1Free_AdmissionReject(&(val)->u.admissionReject);
	    break;
	case 13:
	    ASN1Free_BandwidthRequest(&(val)->u.bandwidthRequest);
	    break;
	case 14:
	    ASN1Free_BandwidthConfirm(&(val)->u.bandwidthConfirm);
	    break;
	case 15:
	    ASN1Free_BandwidthReject(&(val)->u.bandwidthReject);
	    break;
	case 16:
	    ASN1Free_DisengageRequest(&(val)->u.disengageRequest);
	    break;
	case 17:
	    ASN1Free_DisengageConfirm(&(val)->u.disengageConfirm);
	    break;
	case 18:
	    ASN1Free_DisengageReject(&(val)->u.disengageReject);
	    break;
	case 19:
	    ASN1Free_LocationRequest(&(val)->u.locationRequest);
	    break;
	case 20:
	    ASN1Free_LocationConfirm(&(val)->u.locationConfirm);
	    break;
	case 21:
	    ASN1Free_LocationReject(&(val)->u.locationReject);
	    break;
	case 22:
	    ASN1Free_InfoRequest(&(val)->u.infoRequest);
	    break;
	case 23:
	    ASN1Free_InfoRequestResponse(&(val)->u.infoRequestResponse);
	    break;
	case 24:
	    ASN1Free_H225NonStandardMessage(&(val)->u.nonStandardMessage);
	    break;
	case 25:
	    ASN1Free_UnknownMessageResponse(&(val)->u.unknownMessageResponse);
	    break;
	case 26:
	    ASN1Free_RequestInProgress(&(val)->u.requestInProgress);
	    break;
	case 27:
	    ASN1Free_ResourcesAvailableIndicate(&(val)->u.resourcesAvailableIndicate);
	    break;
	case 28:
	    ASN1Free_ResourcesAvailableConfirm(&(val)->u.resourcesAvailableConfirm);
	    break;
	case 29:
	    ASN1Free_InfoRequestAck(&(val)->u.infoRequestAck);
	    break;
	case 30:
	    ASN1Free_InfoRequestNak(&(val)->u.infoRequestNak);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_cryptoTokens(ASN1encoding_t enc, PResourcesAvailableConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ResourcesAvailableConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_cryptoTokens(ASN1decoding_t dec, PResourcesAvailableConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ResourcesAvailableConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_cryptoTokens(PResourcesAvailableConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ResourcesAvailableConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_cryptoTokens_ElmFn(PResourcesAvailableConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_cryptoTokens(ASN1encoding_t enc, PResourcesAvailableIndicate_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ResourcesAvailableIndicate_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_cryptoTokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_cryptoTokens(ASN1decoding_t dec, PResourcesAvailableIndicate_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ResourcesAvailableIndicate_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_cryptoTokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_cryptoTokens(PResourcesAvailableIndicate_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ResourcesAvailableIndicate_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_cryptoTokens_ElmFn(PResourcesAvailableIndicate_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RequestInProgress_cryptoTokens(ASN1encoding_t enc, PRequestInProgress_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RequestInProgress_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RequestInProgress_cryptoTokens_ElmFn(ASN1encoding_t enc, PRequestInProgress_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestInProgress_cryptoTokens(ASN1decoding_t dec, PRequestInProgress_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RequestInProgress_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RequestInProgress_cryptoTokens_ElmFn(ASN1decoding_t dec, PRequestInProgress_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RequestInProgress_cryptoTokens(PRequestInProgress_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RequestInProgress_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RequestInProgress_cryptoTokens_ElmFn(PRequestInProgress_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnknownMessageResponse_cryptoTokens(ASN1encoding_t enc, PUnknownMessageResponse_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnknownMessageResponse_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnknownMessageResponse_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnknownMessageResponse_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnknownMessageResponse_cryptoTokens(ASN1decoding_t dec, PUnknownMessageResponse_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnknownMessageResponse_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnknownMessageResponse_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnknownMessageResponse_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnknownMessageResponse_cryptoTokens(PUnknownMessageResponse_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnknownMessageResponse_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnknownMessageResponse_cryptoTokens_ElmFn(PUnknownMessageResponse_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H225NonStandardMessage_cryptoTokens(ASN1encoding_t enc, PH225NonStandardMessage_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H225NonStandardMessage_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_H225NonStandardMessage_cryptoTokens_ElmFn(ASN1encoding_t enc, PH225NonStandardMessage_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardMessage_cryptoTokens(ASN1decoding_t dec, PH225NonStandardMessage_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H225NonStandardMessage_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H225NonStandardMessage_cryptoTokens_ElmFn(ASN1decoding_t dec, PH225NonStandardMessage_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardMessage_cryptoTokens(PH225NonStandardMessage_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H225NonStandardMessage_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H225NonStandardMessage_cryptoTokens_ElmFn(PH225NonStandardMessage_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestNak_cryptoTokens(ASN1encoding_t enc, PInfoRequestNak_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestNak_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestNak_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestNak_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestNak_cryptoTokens(ASN1decoding_t dec, PInfoRequestNak_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestNak_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestNak_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestNak_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestNak_cryptoTokens(PInfoRequestNak_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestNak_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestNak_cryptoTokens_ElmFn(PInfoRequestNak_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestAck_cryptoTokens(ASN1encoding_t enc, PInfoRequestAck_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestAck_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestAck_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestAck_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestAck_cryptoTokens(ASN1decoding_t dec, PInfoRequestAck_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestAck_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestAck_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestAck_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestAck_cryptoTokens(PInfoRequestAck_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestAck_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestAck_cryptoTokens_ElmFn(PInfoRequestAck_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_cryptoTokens(ASN1encoding_t enc, PInfoRequestResponse_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_cryptoTokens(ASN1decoding_t dec, PInfoRequestResponse_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_cryptoTokens(PInfoRequestResponse_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_cryptoTokens_ElmFn(PInfoRequestResponse_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequest_cryptoTokens(ASN1encoding_t enc, PInfoRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequest_cryptoTokens(ASN1decoding_t dec, PInfoRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequest_cryptoTokens(PInfoRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequest_cryptoTokens_ElmFn(PInfoRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageReject_cryptoTokens(ASN1encoding_t enc, PDisengageReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageReject_cryptoTokens(ASN1decoding_t dec, PDisengageReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageReject_cryptoTokens(PDisengageReject_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageReject_cryptoTokens_ElmFn(PDisengageReject_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageConfirm_cryptoTokens(ASN1encoding_t enc, PDisengageConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageConfirm_cryptoTokens(ASN1decoding_t dec, PDisengageConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageConfirm_cryptoTokens(PDisengageConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageConfirm_cryptoTokens_ElmFn(PDisengageConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageRequest_cryptoTokens(ASN1encoding_t enc, PDisengageRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageRequest_cryptoTokens(ASN1decoding_t dec, PDisengageRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageRequest_cryptoTokens(PDisengageRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageRequest_cryptoTokens_ElmFn(PDisengageRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationReject_cryptoTokens(ASN1encoding_t enc, PLocationReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationReject_cryptoTokens(ASN1decoding_t dec, PLocationReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationReject_cryptoTokens(PLocationReject_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationReject_cryptoTokens_ElmFn(PLocationReject_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_cryptoTokens(ASN1encoding_t enc, PLocationConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_cryptoTokens(ASN1decoding_t dec, PLocationConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_cryptoTokens(PLocationConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_cryptoTokens_ElmFn(PLocationConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationRequest_cryptoTokens(ASN1encoding_t enc, PLocationRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRequest_cryptoTokens(ASN1decoding_t dec, PLocationRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationRequest_cryptoTokens(PLocationRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationRequest_cryptoTokens_ElmFn(PLocationRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthReject_cryptoTokens(ASN1encoding_t enc, PBandwidthReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthReject_cryptoTokens(ASN1decoding_t dec, PBandwidthReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthReject_cryptoTokens(PBandwidthReject_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthReject_cryptoTokens_ElmFn(PBandwidthReject_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthConfirm_cryptoTokens(ASN1encoding_t enc, PBandwidthConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthConfirm_cryptoTokens(ASN1decoding_t dec, PBandwidthConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthConfirm_cryptoTokens(PBandwidthConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthConfirm_cryptoTokens_ElmFn(PBandwidthConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthRequest_cryptoTokens(ASN1encoding_t enc, PBandwidthRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthRequest_cryptoTokens(ASN1decoding_t dec, PBandwidthRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthRequest_cryptoTokens(PBandwidthRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthRequest_cryptoTokens_ElmFn(PBandwidthRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionReject_cryptoTokens(ASN1encoding_t enc, PAdmissionReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionReject_cryptoTokens(ASN1decoding_t dec, PAdmissionReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionReject_cryptoTokens(PAdmissionReject_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionReject_cryptoTokens_ElmFn(PAdmissionReject_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_cryptoTokens(ASN1encoding_t enc, PAdmissionConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_cryptoTokens(ASN1decoding_t dec, PAdmissionConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_cryptoTokens(PAdmissionConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_cryptoTokens_ElmFn(PAdmissionConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_cryptoTokens(ASN1encoding_t enc, PAdmissionRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_cryptoTokens(ASN1decoding_t dec, PAdmissionRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_cryptoTokens(PAdmissionRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_cryptoTokens_ElmFn(PAdmissionRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationReject_cryptoTokens(ASN1encoding_t enc, PUnregistrationReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationReject_cryptoTokens(ASN1decoding_t dec, PUnregistrationReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationReject_cryptoTokens(PUnregistrationReject_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationReject_cryptoTokens_ElmFn(PUnregistrationReject_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationConfirm_cryptoTokens(ASN1encoding_t enc, PUnregistrationConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationConfirm_cryptoTokens(ASN1decoding_t dec, PUnregistrationConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationConfirm_cryptoTokens(PUnregistrationConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationConfirm_cryptoTokens_ElmFn(PUnregistrationConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_cryptoTokens(ASN1encoding_t enc, PUnregistrationRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_cryptoTokens(ASN1decoding_t dec, PUnregistrationRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest_cryptoTokens(PUnregistrationRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationRequest_cryptoTokens_ElmFn(PUnregistrationRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationReject_cryptoTokens(ASN1encoding_t enc, PRegistrationReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationReject_cryptoTokens(ASN1decoding_t dec, PRegistrationReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationReject_cryptoTokens(PRegistrationReject_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationReject_cryptoTokens_ElmFn(PRegistrationReject_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_cryptoTokens(ASN1encoding_t enc, PRegistrationConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_cryptoTokens(ASN1decoding_t dec, PRegistrationConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm_cryptoTokens(PRegistrationConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationConfirm_cryptoTokens_ElmFn(PRegistrationConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_cryptoTokens(ASN1encoding_t enc, PRegistrationRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_cryptoTokens(ASN1decoding_t dec, PRegistrationRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_cryptoTokens(PRegistrationRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_cryptoTokens_ElmFn(PRegistrationRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperReject_cryptoTokens(ASN1encoding_t enc, PGatekeeperReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperReject_cryptoTokens(ASN1decoding_t dec, PGatekeeperReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperReject_cryptoTokens(PGatekeeperReject_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperReject_cryptoTokens_ElmFn(PGatekeeperReject_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_cryptoTokens(ASN1encoding_t enc, PGatekeeperConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_cryptoTokens(ASN1decoding_t dec, PGatekeeperConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_cryptoTokens(PGatekeeperConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_cryptoTokens_ElmFn(PGatekeeperConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_cryptoTokens(ASN1encoding_t enc, PGatekeeperRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_cryptoTokens(ASN1decoding_t dec, PGatekeeperRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_cryptoTokens(PGatekeeperRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_cryptoTokens_ElmFn(PGatekeeperRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_cryptoTokens(ASN1encoding_t enc, PEndpoint_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_cryptoTokens_ElmFn(ASN1encoding_t enc, PEndpoint_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_cryptoTokens(ASN1decoding_t dec, PEndpoint_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_cryptoTokens_ElmFn(ASN1decoding_t dec, PEndpoint_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_cryptoTokens(PEndpoint_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_cryptoTokens_ElmFn(PEndpoint_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Progress_UUIE_cryptoTokens(ASN1encoding_t enc, PProgress_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Progress_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Progress_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PProgress_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Progress_UUIE_cryptoTokens(ASN1decoding_t dec, PProgress_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Progress_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Progress_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PProgress_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Progress_UUIE_cryptoTokens(PProgress_UUIE_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Progress_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Progress_UUIE_cryptoTokens_ElmFn(PProgress_UUIE_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_conferences(ASN1encoding_t enc, PFacility_UUIE_conferences *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_conferences_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_conferences_ElmFn(ASN1encoding_t enc, PFacility_UUIE_conferences val)
{
    if (!ASN1Enc_ConferenceList(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_conferences(ASN1decoding_t dec, PFacility_UUIE_conferences *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_conferences_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_conferences_ElmFn(ASN1decoding_t dec, PFacility_UUIE_conferences val)
{
    if (!ASN1Dec_ConferenceList(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_conferences(PFacility_UUIE_conferences *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_conferences_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_conferences_ElmFn(PFacility_UUIE_conferences val)
{
    if (val) {
	ASN1Free_ConferenceList(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_cryptoTokens(ASN1encoding_t enc, PFacility_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PFacility_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_cryptoTokens(ASN1decoding_t dec, PFacility_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PFacility_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_cryptoTokens(PFacility_UUIE_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_cryptoTokens_ElmFn(PFacility_UUIE_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_cryptoTokens(ASN1encoding_t enc, PSetup_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PSetup_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_cryptoTokens(ASN1decoding_t dec, PSetup_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PSetup_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_cryptoTokens(PSetup_UUIE_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_cryptoTokens_ElmFn(PSetup_UUIE_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Connect_UUIE_cryptoTokens(ASN1encoding_t enc, PConnect_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Connect_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Connect_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PConnect_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Connect_UUIE_cryptoTokens(ASN1decoding_t dec, PConnect_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Connect_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Connect_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PConnect_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Connect_UUIE_cryptoTokens(PConnect_UUIE_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Connect_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Connect_UUIE_cryptoTokens_ElmFn(PConnect_UUIE_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_cryptoTokens(ASN1encoding_t enc, PCallProceeding_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CallProceeding_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_cryptoTokens(ASN1decoding_t dec, PCallProceeding_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CallProceeding_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_cryptoTokens(PCallProceeding_UUIE_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CallProceeding_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_cryptoTokens_ElmFn(PCallProceeding_UUIE_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_cryptoTokens(ASN1encoding_t enc, PAlerting_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Alerting_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_cryptoTokens(ASN1decoding_t dec, PAlerting_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Alerting_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Alerting_UUIE_cryptoTokens(PAlerting_UUIE_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Alerting_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Alerting_UUIE_cryptoTokens_ElmFn(PAlerting_UUIE_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_h323_message_body(ASN1encoding_t enc, H323_UU_PDU_h323_message_body *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_Setup_UUIE(enc, &(val)->u.setup))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_CallProceeding_UUIE(enc, &(val)->u.callProceeding))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_Connect_UUIE(enc, &(val)->u.connect))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_Alerting_UUIE(enc, &(val)->u.alerting))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_Information_UUIE(enc, &(val)->u.information))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_ReleaseComplete_UUIE(enc, &(val)->u.releaseComplete))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_Facility_UUIE(enc, &(val)->u.facility))
	    return 0;
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_Progress_UUIE(ee, &(val)->u.progress))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_h323_message_body(ASN1decoding_t dec, H323_UU_PDU_h323_message_body *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_Setup_UUIE(dec, &(val)->u.setup))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_CallProceeding_UUIE(dec, &(val)->u.callProceeding))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_Connect_UUIE(dec, &(val)->u.connect))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_Alerting_UUIE(dec, &(val)->u.alerting))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_Information_UUIE(dec, &(val)->u.information))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_ReleaseComplete_UUIE(dec, &(val)->u.releaseComplete))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_Facility_UUIE(dec, &(val)->u.facility))
	    return 0;
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_Progress_UUIE(dd, &(val)->u.progress))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU_h323_message_body(H323_UU_PDU_h323_message_body *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_Setup_UUIE(&(val)->u.setup);
	    break;
	case 2:
	    ASN1Free_CallProceeding_UUIE(&(val)->u.callProceeding);
	    break;
	case 3:
	    ASN1Free_Connect_UUIE(&(val)->u.connect);
	    break;
	case 4:
	    ASN1Free_Alerting_UUIE(&(val)->u.alerting);
	    break;
	case 5:
	    ASN1Free_Information_UUIE(&(val)->u.information);
	    break;
	case 6:
	    ASN1Free_ReleaseComplete_UUIE(&(val)->u.releaseComplete);
	    break;
	case 7:
	    ASN1Free_Facility_UUIE(&(val)->u.facility);
	    break;
	case 8:
	    ASN1Free_Progress_UUIE(&(val)->u.progress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU(ASN1encoding_t enc, H323_UU_PDU *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (!ASN1Enc_H323_UU_PDU_h323_message_body(enc, &(val)->h323_message_body))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_H323_UU_PDU_h4501SupplementaryService(ee, &(val)->h4501SupplementaryService))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1PEREncBoolean(ee, (val)->h245Tunneling))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_H323_UU_PDU_h245Control(ee, &(val)->h245Control))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_H323_UU_PDU_nonStandardControl(ee, &(val)->nonStandardControl))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU(ASN1decoding_t dec, H323_UU_PDU *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_H323_UU_PDU_h323_message_body(dec, &(val)->h323_message_body))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H323_UU_PDU_h4501SupplementaryService(dd, &(val)->h4501SupplementaryService))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->h245Tunneling))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H323_UU_PDU_h245Control(dd, &(val)->h245Control))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H323_UU_PDU_nonStandardControl(dd, &(val)->nonStandardControl))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU(H323_UU_PDU *val)
{
    if (val) {
	ASN1Free_H323_UU_PDU_h323_message_body(&(val)->h323_message_body);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_H323_UU_PDU_h4501SupplementaryService(&(val)->h4501SupplementaryService);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_H323_UU_PDU_h245Control(&(val)->h245Control);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_H323_UU_PDU_nonStandardControl(&(val)->nonStandardControl);
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(ASN1encoding_t enc, InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val)
{
    if (!ASN1Enc_H323_UU_PDU(enc, &(val)->h323pdu))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->sent))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(ASN1decoding_t dec, InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val)
{
    if (!ASN1Dec_H323_UU_PDU(dec, &(val)->h323pdu))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->sent))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val)
{
    if (val) {
	ASN1Free_H323_UU_PDU(&(val)->h323pdu);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_pdu *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_pdu val)
{
    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_pdu *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_pdu val)
{
    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu(PInfoRequestResponse_perCallInfo_Seq_pdu *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(PInfoRequestResponse_perCallInfo_Seq_pdu val)
{
    if (val) {
	ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UserInformation(ASN1encoding_t enc, H323_UserInformation *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_H323_UU_PDU(enc, &(val)->h323_uu_pdu))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H323_UserInformation_user_data(enc, &(val)->user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UserInformation(ASN1decoding_t dec, H323_UserInformation *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_H323_UU_PDU(dec, &(val)->h323_uu_pdu))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H323_UserInformation_user_data(dec, &(val)->user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323_UserInformation(H323_UserInformation *val)
{
    if (val) {
	ASN1Free_H323_UU_PDU(&(val)->h323_uu_pdu);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H323_UserInformation_user_data(&(val)->user_data);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\inc\cctostrm.h ===
/*++

Copyright ) ( c) 1997 Microsoft Corporation

Module Name:

    cctostrm.h

Abstract:

    defines interfaces between the stream object and the cc module

Author:
    
    Mu Han (muhan) 10-JUNE-1999

--*/
#ifndef __CCTOSTRM_H_
#define __CCTOSTRM_H_

typedef struct tag_H323MSPEndpointVersion
{
	BYTE bH221CountryCode;
	BYTE bH221CountryExtension;
	WORD wH221MfrCode;
	BSTR *pProductIdentifier;
	BSTR *pVersionIdentifier;
} H323MSPEndpointVersion;

// {4ab1fe8c-1f97-11d3-a577-00c04f8ef6e3}
DEFINE_GUID(IID_IH245ChannelControl,
0x4ab1fe8c, 0x1f97, 0x11d3, 0xa5, 0x77, 0x00, 0xc0, 0x4f, 0x8e, 0xf6, 0xe3);

struct DECLSPEC_UUID("4ab1fe8c-1f97-11d3-a577-00c04f8ef6e3") DECLSPEC_NOVTABLE
IH245ChannelControl : public IUnknown
{
    STDMETHOD (SetFormat) (
        IN   AM_MEDIA_TYPE *pMediaType
        ) PURE;

    STDMETHOD (GetNumberOfCapabilities) (
        OUT DWORD *pdwCount
        ) PURE;

    STDMETHOD (GetStreamCaps) (
        IN   DWORD dwIndex, 
        OUT  AM_MEDIA_TYPE **ppMediaType, 
        OUT  TAPI_STREAM_CONFIG_CAPS *pStreamConfigCaps, 
        OUT  BOOL *pfEnabled
        ) PURE;


    STDMETHOD (Start) (BOOL fRequestedByApplication) PURE;

    STDMETHOD (Stop) (BOOL fRequestedByApplication) PURE;

    STDMETHOD (Pause) (
        IN   BOOL fPause
        ) PURE;

    STDMETHOD (SetMaxBitrate) (
        IN   DWORD dwMaxBitrate
        ) PURE;


    STDMETHOD (GetRemoteVersion) (
        OUT  H323MSPEndpointVersion *pEndpointVersion
        ) PURE;
        
    STDMETHOD (SelectTerminal) (
        IN   ITTerminal *pTerminal
        ) PURE;

    STDMETHOD (UnselectTerminal) (
        IN   ITTerminal *pTerminal
        ) PURE;

    STDMETHOD (ReOrderCapabilities) (
        IN DWORD *pdwIndices, 
        IN BOOL *pfEnabled, 
        IN BOOL *pfPublicize, 
        IN DWORD dwNumIndices
        ) PURE;
};

// {4ab1fe8d-1f97-11d3-a577-00c04f8ef6e3}
DEFINE_GUID(IID_ISubstreamControl,
0x4ab1fe8d, 0x1f97, 0x11d3, 0xa5, 0x77, 0x00, 0xc0, 0x4f, 0x8e, 0xf6, 0xe3);

struct DECLSPEC_UUID("4ab1fe8d-1f97-11d3-a577-00c04f8ef6e3") DECLSPEC_NOVTABLE
ISubstreamControl : public IUnknown
{
    STDMETHOD (SC_SetFormat) ( 
        IN   AM_MEDIA_TYPE *pMediaType,
        IN   DWORD dwFormatID,
        IN   DWORD dwPayloadType  
        ) PURE;
        
    STDMETHOD (SC_Start) (BOOL fRequestedByApplication) PURE;
    
    STDMETHOD (SC_Stop) (BOOL fRequestedByApplication) PURE;
    
    STDMETHOD (SC_Pause) (VOID) PURE;

    STDMETHOD (SC_SetBitrate) ( 
        IN   DWORD dwBitsPerSecond
        ) PURE;
        
    STDMETHOD (SC_RemoteTemporalSpatialTradeoff) ( 
        IN   USHORT uTSRemoteValue
        ) PURE;
    
    STDMETHOD (SC_CreateSubstream) ( 
        OUT  ISubstreamControl *pSubStream
        ) PURE;

    STDMETHOD (SC_SetRemoteAddress) ( 
        IN OUT HANDLE * phRTPSession,           // handle to the shared RTP session.
        IN   PSOCKADDR_IN pRemoteMediaAddr,
        IN   PSOCKADDR_IN pRemoteControlAddr
        ) PURE;
        
    STDMETHOD (SC_SetSource) (  
        // indicates the low 8 bits of the local SSRC (if this is a send substream)  
        // or the low 8 bits of the senders SSRC (if this is a receive substream)
        IN   BYTE bSource
        ) PURE;

    STDMETHOD (SC_SelectLocalAddress) ( 
        IN OUT HANDLE * phRTPSession,           // handle to the shared RTP session.
        IN   PSOCKADDR_IN pLocalAddress,            // local IP address (same as H.245)
        OUT  PSOCKADDR_IN pLocalMediaAddress, // NULL if opening TX channel, else we want to know the local RTP receive address
        OUT  PSOCKADDR_IN pLocalControlAddress    // We want to know the local RTCP address
        ) PURE;

    STDMETHOD (SC_SetLocalReceiveAddress) (             // only called when the receive address is non-negotiable (e.g. multicast case)
        IN OUT HANDLE * phRTPSession,           // handle to the shared RTP session.
        IN   PSOCKADDR_IN pLocalMediaAddr,  // local IP address (same as H.245)
        IN   PSOCKADDR_IN pLocalControlAddress, 
        IN   PSOCKADDR_IN pRemoteControlAddress
        ) PURE;

    STDMETHOD (SC_SendDTMF) ( 
        IN   LPWSTR pwstrDialChars
        ) PURE;
        
    STDMETHOD (SC_SetDESKey52) ( 
        IN   BYTE *pKey
        ) PURE;

    STDMETHOD (SC_SelectTerminal) ( 
        IN   ITTerminal *pTerminal
        ) PURE;
        
    STDMETHOD (SC_UnselectTerminal) (  
        IN   ITTerminal *pTerminal
        ) PURE;

};

// {4ab1fe8e-1f97-11d3-a577-00c04f8ef6e3}
DEFINE_GUID(IID_IH245SubstreamControl,
0x4ab1fe8e, 0x1f97, 0x11d3, 0xa5, 0x77, 0x00, 0xc0, 0x4f, 0x8e, 0xf6, 0xe3);

struct DECLSPEC_UUID("4ab1fe8e-1f97-11d3-a577-00c04f8ef6e3") DECLSPEC_NOVTABLE
IH245SubstreamControl : public IUnknown
{
    STDMETHOD (H245SC_BeginControlSession) ( 
        IN   IH245ChannelControl *pIChannelControl
        ) PURE;
    
    STDMETHOD (H245SC_EndControlSession) (VOID) PURE;   
    
    STDMETHOD (H245SC_GetNumberOfCapabilities) ( 
        OUT DWORD *pdwTemplateCount, 
        OUT DWORD *pdwFormatCount
        ) PURE;

    STDMETHOD (H245SC_GetStreamCaps) ( 
        IN   DWORD dwIndex, 
        OUT  const H245MediaCapability** pph245Capability, 
        OUT  AM_MEDIA_TYPE **ppMediaType, 
        OUT  TAPI_STREAM_CONFIG_CAPS *pStreamConfigCaps, 
        OUT  DWORD *pdwUniqueID,
        OUT  UINT *puResourceBoundArrayEntries,
        OUT  const FormatResourceBounds **ppResourceBoundArray    
        ) PURE;

    STDMETHOD (H245SC_RefineStreamCap) ( 
        IN   DWORD dwUniqueID,
        IN   DWORD dwResourceBoundIndex,
        IN OUT H245MediaCapability* ph245Capability
        ) PURE;
     
    STDMETHOD (H245SC_SetIDBase) ( 
        IN   UINT uNewBase
        ) PURE;
    
    STDMETHOD (H245SC_FindIDByRange) ( 
        IN   AM_MEDIA_TYPE *pAMMediaType,
        OUT  DWORD *pdwUniqueID
        ) PURE;     

    STDMETHOD (H245SC_FindIDByMode) ( 
        IN   H245_MODE_ELEMENT *pModeElement,
        OUT  DWORD *pdwUniqueID
        ) PURE;

    STDMETHOD (H245SC_IntersectFormats) ( 
        IN   const H245MediaCapability *pLocalCapability, 
        IN   DWORD dwUniqueID,
        IN   const H245MediaCapability *pRemoteCapability, 
        OUT  const H245MediaCapability **pIntersectedCapability,
        OUT  DWORD *pdwPayloadType
        ) PURE;

	STDMETHOD (H245SC_GetLocalFormat) (
        IN  DWORD dwUniqueID,
        IN  const H245MediaCapability *pIntersectedCapability, 
		OUT AM_MEDIA_TYPE **ppAMMediaType
		) PURE;
		
    STDMETHOD (H245SC_ReleaseNegotiatedCapability) ( 
        IN  DWORD dwUniqueID,
        IN  const H245MediaCapability *pIntersectedCapability 
        ) PURE;
};


// {20A0D46A-2D95-11d3-89D1-00C04F8EC972}
DEFINE_GUID(IID_IVidEncChannelControl,
0x20A0D46A, 0x2D95, 0x11d3, 0x89, 0xD1, 0x00, 0xc0, 0x4f, 0x8e, 0xC9, 0x72);

struct DECLSPEC_UUID("20A0D46A-2D95-11d3-89D1-00C04F8EC972") DECLSPEC_NOVTABLE
IVidEncChannelControl : IUnknown  
{

	STDMETHOD (VideoFastUpdatePicture)(void) PURE;

	STDMETHOD (VideoFastUpdateGOB)(
		IN  DWORD dwFirstGOB, 
		IN  DWORD dwNumberOfGOBs
		) PURE;

	STDMETHOD (VideoFastUpdateMB)(
		IN  DWORD dwFirstGOB, 
		IN  DWORD dwFirstMB, 
		IN  DWORD dwNumberOfMBs
		) PURE;

	STDMETHOD (VideoSendSyncEveryGOB)(
		IN  BOOL fEnable
		) PURE;

	STDMETHOD (VideoNotDecodedMBs)(
		IN  DWORD dwFirstMB, 
		IN  DWORD dwNumberOfMBs, 
		IN  DWORD dwTemporalReference
		) PURE;


	STDMETHOD (VideoEncTemporalSpatialTradeoff)(
		IN  USHORT uTSValue
		) PURE;

};


// {0276FFED-3590-11d3-89D1-00C04F8EC972}
DEFINE_GUID(IID_IVidDecChannelControl, 
0x276ffed, 0x3590, 0x11d3, 0x89, 0xd1, 0x0, 0xc0, 0x4f, 0x8e, 0xc9, 0x72);

struct DECLSPEC_UUID("0276FFED-3590-11d3-89D1-00C04F8EC972") DECLSPEC_NOVTABLE
IVidDecChannelControl : IUnknown  
{

	STDMETHOD (VideoFreezePicture)(void) PURE;

	STDMETHOD (VideoDecTemporalSpatialTradeoff)(
		IN  USHORT uTSValue
		) PURE;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\inc\h225asn.h ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for H.235 Security Messages v1 (H.235) */
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for Multimedia System Control (H.245) */
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for H.323 Messages v2 (H.225) */

#ifndef _H225ASN_Module_H_
#define _H225ASN_Module_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct InfoRequestResponse_perCallInfo_Seq_substituteConfIDs * PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs;

typedef struct TransportAddress_ipSourceRoute_route * PTransportAddress_ipSourceRoute_route;

typedef struct RTPSession_associatedSessionIds * PRTPSession_associatedSessionIds;

typedef struct GatekeeperRequest_algorithmOIDs * PGatekeeperRequest_algorithmOIDs;

typedef struct Progress_UUIE_fastStart * PProgress_UUIE_fastStart;

typedef struct Facility_UUIE_fastStart * PFacility_UUIE_fastStart;

typedef struct Setup_UUIE_fastStart * PSetup_UUIE_fastStart;

typedef struct Setup_UUIE_destExtraCRV * PSetup_UUIE_destExtraCRV;

typedef struct Connect_UUIE_fastStart * PConnect_UUIE_fastStart;

typedef struct CallProceeding_UUIE_fastStart * PCallProceeding_UUIE_fastStart;

typedef struct Alerting_UUIE_fastStart * PAlerting_UUIE_fastStart;

typedef struct H323_UU_PDU_h245Control * PH323_UU_PDU_h245Control;

typedef struct H323_UU_PDU_h4501SupplementaryService * PH323_UU_PDU_h4501SupplementaryService;

typedef struct InfoRequestResponse_perCallInfo_Seq_tokens * PInfoRequestResponse_perCallInfo_Seq_tokens;

typedef struct ResourcesAvailableConfirm_tokens * PResourcesAvailableConfirm_tokens;

typedef struct ResourcesAvailableIndicate_tokens * PResourcesAvailableIndicate_tokens;

typedef struct RequestInProgress_tokens * PRequestInProgress_tokens;

typedef struct UnknownMessageResponse_tokens * PUnknownMessageResponse_tokens;

typedef struct H225NonStandardMessage_tokens * PH225NonStandardMessage_tokens;

typedef struct InfoRequestNak_tokens * PInfoRequestNak_tokens;

typedef struct InfoRequestAck_tokens * PInfoRequestAck_tokens;

typedef struct InfoRequestResponse_tokens * PInfoRequestResponse_tokens;

typedef struct InfoRequest_tokens * PInfoRequest_tokens;

typedef struct DisengageReject_tokens * PDisengageReject_tokens;

typedef struct DisengageConfirm_tokens * PDisengageConfirm_tokens;

typedef struct DisengageRequest_tokens * PDisengageRequest_tokens;

typedef struct LocationReject_tokens * PLocationReject_tokens;

typedef struct LocationConfirm_tokens * PLocationConfirm_tokens;

typedef struct LocationRequest_tokens * PLocationRequest_tokens;

typedef struct BandwidthReject_tokens * PBandwidthReject_tokens;

typedef struct BandwidthConfirm_tokens * PBandwidthConfirm_tokens;

typedef struct BandwidthRequest_tokens * PBandwidthRequest_tokens;

typedef struct AdmissionReject_tokens * PAdmissionReject_tokens;

typedef struct AdmissionConfirm_tokens * PAdmissionConfirm_tokens;

typedef struct AdmissionRequest_tokens * PAdmissionRequest_tokens;

typedef struct UnregistrationReject_tokens * PUnregistrationReject_tokens;

typedef struct UnregistrationConfirm_tokens * PUnregistrationConfirm_tokens;

typedef struct UnregistrationRequest_tokens * PUnregistrationRequest_tokens;

typedef struct RegistrationReject_tokens * PRegistrationReject_tokens;

typedef struct RegistrationConfirm_tokens * PRegistrationConfirm_tokens;

typedef struct RegistrationRequest_tokens * PRegistrationRequest_tokens;

typedef struct GatekeeperReject_tokens * PGatekeeperReject_tokens;

typedef struct GatekeeperConfirm_tokens * PGatekeeperConfirm_tokens;

typedef struct GatekeeperRequest_authenticationCapability * PGatekeeperRequest_authenticationCapability;

typedef struct GatekeeperRequest_tokens * PGatekeeperRequest_tokens;

typedef struct Endpoint_tokens * PEndpoint_tokens;

typedef struct Progress_UUIE_tokens * PProgress_UUIE_tokens;

typedef struct Facility_UUIE_tokens * PFacility_UUIE_tokens;

typedef struct Setup_UUIE_tokens * PSetup_UUIE_tokens;

typedef struct Connect_UUIE_tokens * PConnect_UUIE_tokens;

typedef struct CallProceeding_UUIE_tokens * PCallProceeding_UUIE_tokens;

typedef struct Alerting_UUIE_tokens * PAlerting_UUIE_tokens;

typedef struct GatekeeperConfirm_integrity * PGatekeeperConfirm_integrity;

typedef struct GatekeeperRequest_integrity * PGatekeeperRequest_integrity;

typedef struct NonStandardProtocol_dataRatesSupported * PNonStandardProtocol_dataRatesSupported;

typedef struct T120OnlyCaps_dataRatesSupported * PT120OnlyCaps_dataRatesSupported;

typedef struct VoiceCaps_dataRatesSupported * PVoiceCaps_dataRatesSupported;

typedef struct H324Caps_dataRatesSupported * PH324Caps_dataRatesSupported;

typedef struct H323Caps_dataRatesSupported * PH323Caps_dataRatesSupported;

typedef struct H322Caps_dataRatesSupported * PH322Caps_dataRatesSupported;

typedef struct H321Caps_dataRatesSupported * PH321Caps_dataRatesSupported;

typedef struct H320Caps_dataRatesSupported * PH320Caps_dataRatesSupported;

typedef struct H310Caps_dataRatesSupported * PH310Caps_dataRatesSupported;

typedef struct Setup_UUIE_h245SecurityCapability * PSetup_UUIE_h245SecurityCapability;

typedef struct H323_UU_PDU_nonStandardControl * PH323_UU_PDU_nonStandardControl;

typedef struct InfoRequestResponse_perCallInfo_Seq_data * PInfoRequestResponse_perCallInfo_Seq_data;

typedef struct InfoRequestResponse_perCallInfo_Seq_video * PInfoRequestResponse_perCallInfo_Seq_video;

typedef struct InfoRequestResponse_perCallInfo_Seq_audio * PInfoRequestResponse_perCallInfo_Seq_audio;

typedef struct InfoRequestResponse_perCallInfo * PInfoRequestResponse_perCallInfo;

typedef struct InfoRequestResponse_callSignalAddress * PInfoRequestResponse_callSignalAddress;

typedef struct AdmissionReject_callSignalAddress * PAdmissionReject_callSignalAddress;

typedef struct UnregistrationRequest_callSignalAddress * PUnregistrationRequest_callSignalAddress;

typedef struct RegistrationConfirm_alternateGatekeeper * PRegistrationConfirm_alternateGatekeeper;

typedef struct RegistrationConfirm_callSignalAddress * PRegistrationConfirm_callSignalAddress;

typedef struct RegistrationRequest_rasAddress * PRegistrationRequest_rasAddress;

typedef struct RegistrationRequest_callSignalAddress * PRegistrationRequest_callSignalAddress;

typedef struct GatekeeperConfirm_alternateGatekeeper * PGatekeeperConfirm_alternateGatekeeper;

typedef struct AltGKInfo_alternateGatekeeper * PAltGKInfo_alternateGatekeeper;

typedef struct Endpoint_rasAddress * PEndpoint_rasAddress;

typedef struct Endpoint_callSignalAddress * PEndpoint_callSignalAddress;

typedef struct ResourcesAvailableIndicate_protocols * PResourcesAvailableIndicate_protocols;

typedef struct InfoRequestResponse_endpointAlias * PInfoRequestResponse_endpointAlias;

typedef struct LocationConfirm_alternateEndpoints * PLocationConfirm_alternateEndpoints;

typedef struct LocationConfirm_remoteExtensionAddress * PLocationConfirm_remoteExtensionAddress;

typedef struct LocationConfirm_destExtraCallInfo * PLocationConfirm_destExtraCallInfo;

typedef struct LocationConfirm_destinationInfo * PLocationConfirm_destinationInfo;

typedef struct LocationRequest_sourceInfo * PLocationRequest_sourceInfo;

typedef struct LocationRequest_destinationInfo * PLocationRequest_destinationInfo;

typedef struct AdmissionConfirm_alternateEndpoints * PAdmissionConfirm_alternateEndpoints;

typedef struct AdmissionConfirm_remoteExtensionAddress * PAdmissionConfirm_remoteExtensionAddress;

typedef struct AdmissionConfirm_destExtraCallInfo * PAdmissionConfirm_destExtraCallInfo;

typedef struct AdmissionConfirm_destinationInfo * PAdmissionConfirm_destinationInfo;

typedef struct AdmissionRequest_destAlternatives * PAdmissionRequest_destAlternatives;

typedef struct AdmissionRequest_srcAlternatives * PAdmissionRequest_srcAlternatives;

typedef struct AdmissionRequest_srcInfo * PAdmissionRequest_srcInfo;

typedef struct AdmissionRequest_destExtraCallInfo * PAdmissionRequest_destExtraCallInfo;

typedef struct AdmissionRequest_destinationInfo * PAdmissionRequest_destinationInfo;

typedef struct UnregistrationRequest_alternateEndpoints * PUnregistrationRequest_alternateEndpoints;

typedef struct UnregistrationRequest_endpointAlias * PUnregistrationRequest_endpointAlias;

typedef struct RegistrationRejectReason_duplicateAlias * PRegistrationRejectReason_duplicateAlias;

typedef struct RegistrationConfirm_terminalAlias * PRegistrationConfirm_terminalAlias;

typedef struct RegistrationRequest_alternateEndpoints * PRegistrationRequest_alternateEndpoints;

typedef struct RegistrationRequest_terminalAlias * PRegistrationRequest_terminalAlias;

typedef struct GatekeeperRequest_alternateEndpoints * PGatekeeperRequest_alternateEndpoints;

typedef struct GatekeeperRequest_endpointAlias * PGatekeeperRequest_endpointAlias;

typedef struct Endpoint_destExtraCallInfo * PEndpoint_destExtraCallInfo;

typedef struct Endpoint_remoteExtensionAddress * PEndpoint_remoteExtensionAddress;

typedef struct Endpoint_aliasAddress * PEndpoint_aliasAddress;

typedef struct NonStandardProtocol_supportedPrefixes * PNonStandardProtocol_supportedPrefixes;

typedef struct T120OnlyCaps_supportedPrefixes * PT120OnlyCaps_supportedPrefixes;

typedef struct VoiceCaps_supportedPrefixes * PVoiceCaps_supportedPrefixes;

typedef struct H324Caps_supportedPrefixes * PH324Caps_supportedPrefixes;

typedef struct H323Caps_supportedPrefixes * PH323Caps_supportedPrefixes;

typedef struct H322Caps_supportedPrefixes * PH322Caps_supportedPrefixes;

typedef struct H321Caps_supportedPrefixes * PH321Caps_supportedPrefixes;

typedef struct H320Caps_supportedPrefixes * PH320Caps_supportedPrefixes;

typedef struct H310Caps_supportedPrefixes * PH310Caps_supportedPrefixes;

typedef struct GatewayInfo_protocol * PGatewayInfo_protocol;

typedef struct Facility_UUIE_destExtraCallInfo * PFacility_UUIE_destExtraCallInfo;

typedef struct Facility_UUIE_alternativeAliasAddress * PFacility_UUIE_alternativeAliasAddress;

typedef struct Setup_UUIE_destExtraCallInfo * PSetup_UUIE_destExtraCallInfo;

typedef struct Setup_UUIE_destinationAddress * PSetup_UUIE_destinationAddress;

typedef struct Setup_UUIE_sourceAddress * PSetup_UUIE_sourceAddress;

typedef struct InfoRequestResponse_perCallInfo_Seq_cryptoTokens * PInfoRequestResponse_perCallInfo_Seq_cryptoTokens;

typedef struct ResourcesAvailableConfirm_cryptoTokens * PResourcesAvailableConfirm_cryptoTokens;

typedef struct ResourcesAvailableIndicate_cryptoTokens * PResourcesAvailableIndicate_cryptoTokens;

typedef struct RequestInProgress_cryptoTokens * PRequestInProgress_cryptoTokens;

typedef struct UnknownMessageResponse_cryptoTokens * PUnknownMessageResponse_cryptoTokens;

typedef struct H225NonStandardMessage_cryptoTokens * PH225NonStandardMessage_cryptoTokens;

typedef struct InfoRequestNak_cryptoTokens * PInfoRequestNak_cryptoTokens;

typedef struct InfoRequestAck_cryptoTokens * PInfoRequestAck_cryptoTokens;

typedef struct InfoRequestResponse_cryptoTokens * PInfoRequestResponse_cryptoTokens;

typedef struct InfoRequest_cryptoTokens * PInfoRequest_cryptoTokens;

typedef struct DisengageReject_cryptoTokens * PDisengageReject_cryptoTokens;

typedef struct DisengageConfirm_cryptoTokens * PDisengageConfirm_cryptoTokens;

typedef struct DisengageRequest_cryptoTokens * PDisengageRequest_cryptoTokens;

typedef struct LocationReject_cryptoTokens * PLocationReject_cryptoTokens;

typedef struct LocationConfirm_cryptoTokens * PLocationConfirm_cryptoTokens;

typedef struct LocationRequest_cryptoTokens * PLocationRequest_cryptoTokens;

typedef struct BandwidthReject_cryptoTokens * PBandwidthReject_cryptoTokens;

typedef struct BandwidthConfirm_cryptoTokens * PBandwidthConfirm_cryptoTokens;

typedef struct BandwidthRequest_cryptoTokens * PBandwidthRequest_cryptoTokens;

typedef struct AdmissionReject_cryptoTokens * PAdmissionReject_cryptoTokens;

typedef struct AdmissionConfirm_cryptoTokens * PAdmissionConfirm_cryptoTokens;

typedef struct AdmissionRequest_cryptoTokens * PAdmissionRequest_cryptoTokens;

typedef struct UnregistrationReject_cryptoTokens * PUnregistrationReject_cryptoTokens;

typedef struct UnregistrationConfirm_cryptoTokens * PUnregistrationConfirm_cryptoTokens;

typedef struct UnregistrationRequest_cryptoTokens * PUnregistrationRequest_cryptoTokens;

typedef struct RegistrationReject_cryptoTokens * PRegistrationReject_cryptoTokens;

typedef struct RegistrationConfirm_cryptoTokens * PRegistrationConfirm_cryptoTokens;

typedef struct RegistrationRequest_cryptoTokens * PRegistrationRequest_cryptoTokens;

typedef struct GatekeeperReject_cryptoTokens * PGatekeeperReject_cryptoTokens;

typedef struct GatekeeperConfirm_cryptoTokens * PGatekeeperConfirm_cryptoTokens;

typedef struct GatekeeperRequest_cryptoTokens * PGatekeeperRequest_cryptoTokens;

typedef struct Endpoint_cryptoTokens * PEndpoint_cryptoTokens;

typedef struct Progress_UUIE_cryptoTokens * PProgress_UUIE_cryptoTokens;

typedef struct Facility_UUIE_conferences * PFacility_UUIE_conferences;

typedef struct Facility_UUIE_cryptoTokens * PFacility_UUIE_cryptoTokens;

typedef struct Setup_UUIE_cryptoTokens * PSetup_UUIE_cryptoTokens;

typedef struct Connect_UUIE_cryptoTokens * PConnect_UUIE_cryptoTokens;

typedef struct CallProceeding_UUIE_cryptoTokens * PCallProceeding_UUIE_cryptoTokens;

typedef struct Alerting_UUIE_cryptoTokens * PAlerting_UUIE_cryptoTokens;

typedef struct InfoRequestResponse_perCallInfo_Seq_pdu * PInfoRequestResponse_perCallInfo_Seq_pdu;

typedef struct TransportAddress_ipSourceRoute_route_Seq {
    ASN1uint32_t length;
    ASN1octet_t value[4];
} TransportAddress_ipSourceRoute_route_Seq;

typedef ASN1octetstring_t H323_UU_PDU_h4501SupplementaryService_Seq;

typedef ASN1octetstring_t H323_UU_PDU_h245Control_Seq;

typedef ASN1octetstring_t Alerting_UUIE_fastStart_Seq;

typedef ASN1octetstring_t CallProceeding_UUIE_fastStart_Seq;

typedef ASN1octetstring_t Connect_UUIE_fastStart_Seq;

typedef ASN1octetstring_t Setup_UUIE_fastStart_Seq;

typedef ASN1octetstring_t Facility_UUIE_fastStart_Seq;

typedef ASN1octetstring_t Progress_UUIE_fastStart_Seq;

typedef ASN1objectidentifier_t GatekeeperRequest_algorithmOIDs_Seq;

typedef ASN1uint16_t RTPSession_associatedSessionIds_Seq;

typedef struct ChallengeString {
    ASN1uint32_t length;
    ASN1octet_t value[128];
} ChallengeString;

typedef ASN1uint32_t TimeStamp;

typedef ASN1int32_t RandomVal;

typedef ASN1char16string_t Password;

typedef ASN1char16string_t Identifier;

typedef struct IV8 {
    ASN1uint32_t length;
    ASN1octet_t value[8];
} IV8;

typedef ASN1char_t NumberDigits[129];

typedef struct GloballyUniqueID {
    ASN1uint32_t length;
    ASN1octet_t value[16];
} GloballyUniqueID;

typedef GloballyUniqueID ConferenceIdentifier;

typedef ASN1uint16_t RequestSeqNum;

typedef ASN1char16string_t GatekeeperIdentifier;

typedef ASN1uint32_t BandWidth;

typedef ASN1uint16_t CallReferenceValue;

typedef ASN1char16string_t EndpointIdentifier;

typedef ASN1objectidentifier_t ProtocolIdentifier;

typedef ASN1uint32_t TimeToLive;

typedef struct InfoRequestResponse_perCallInfo_Seq_substituteConfIDs {
    PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs next;
    ConferenceIdentifier value;
} InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_Element;

typedef struct TransportAddress_ipSourceRoute_routing {
    ASN1choice_t choice;
#   define TransportAddress_ipSourceRoute_routing_strict_chosen 1
#   define TransportAddress_ipSourceRoute_routing_loose_chosen 2
} TransportAddress_ipSourceRoute_routing;

typedef struct TransportAddress_ipSourceRoute_route {
    PTransportAddress_ipSourceRoute_route next;
    TransportAddress_ipSourceRoute_route_Seq value;
} TransportAddress_ipSourceRoute_route_Element;

typedef struct RTPSession_associatedSessionIds {
    PRTPSession_associatedSessionIds next;
    RTPSession_associatedSessionIds_Seq value;
} RTPSession_associatedSessionIds_Element;

typedef struct RegistrationConfirm_preGrantedARQ {
    ASN1bool_t makeCall;
    ASN1bool_t useGKCallSignalAddressToMakeCall;
    ASN1bool_t answerCall;
    ASN1bool_t useGKCallSignalAddressToAnswer;
} RegistrationConfirm_preGrantedARQ;

typedef struct GatekeeperRequest_algorithmOIDs {
    PGatekeeperRequest_algorithmOIDs next;
    GatekeeperRequest_algorithmOIDs_Seq value;
} GatekeeperRequest_algorithmOIDs_Element;

typedef struct TransportAddress_ip6Address {
    struct TransportAddress_ip6Address_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } ip;
    ASN1uint16_t port;
} TransportAddress_ip6Address;

typedef struct TransportAddress_ipxAddress {
    struct TransportAddress_ipxAddress_node_node {
	ASN1uint32_t length;
	ASN1octet_t value[6];
    } node;
    struct TransportAddress_ipxAddress_netnum_netnum {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } netnum;
    struct TransportAddress_ipxAddress_port_port {
	ASN1uint32_t length;
	ASN1octet_t value[2];
    } port;
} TransportAddress_ipxAddress;

typedef struct TransportAddress_ipSourceRoute {
    struct TransportAddress_ipSourceRoute_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
    PTransportAddress_ipSourceRoute_route route;
    TransportAddress_ipSourceRoute_routing routing;
} TransportAddress_ipSourceRoute;

typedef struct TransportAddress_ipAddress {
    struct TransportAddress_ipAddress_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
} TransportAddress_ipAddress;

typedef struct Progress_UUIE_fastStart {
    PProgress_UUIE_fastStart next;
    Progress_UUIE_fastStart_Seq value;
} Progress_UUIE_fastStart_Element;

typedef struct Facility_UUIE_fastStart {
    PFacility_UUIE_fastStart next;
    Facility_UUIE_fastStart_Seq value;
} Facility_UUIE_fastStart_Element;

typedef struct Setup_UUIE_fastStart {
    PSetup_UUIE_fastStart next;
    Setup_UUIE_fastStart_Seq value;
} Setup_UUIE_fastStart_Element;

typedef struct Setup_UUIE_conferenceGoal {
    ASN1choice_t choice;
#   define create_chosen 1
#   define join_chosen 2
#   define invite_chosen 3
#   define capability_negotiation_chosen 4
#   define callIndependentSupplementaryService_chosen 5
} Setup_UUIE_conferenceGoal;

typedef struct Setup_UUIE_destExtraCRV {
    PSetup_UUIE_destExtraCRV next;
    CallReferenceValue value;
} Setup_UUIE_destExtraCRV_Element;

typedef struct Connect_UUIE_fastStart {
    PConnect_UUIE_fastStart next;
    Connect_UUIE_fastStart_Seq value;
} Connect_UUIE_fastStart_Element;

typedef struct CallProceeding_UUIE_fastStart {
    PCallProceeding_UUIE_fastStart next;
    CallProceeding_UUIE_fastStart_Seq value;
} CallProceeding_UUIE_fastStart_Element;

typedef struct Alerting_UUIE_fastStart {
    PAlerting_UUIE_fastStart next;
    Alerting_UUIE_fastStart_Seq value;
} Alerting_UUIE_fastStart_Element;

typedef struct H323_UU_PDU_h245Control {
    PH323_UU_PDU_h245Control next;
    H323_UU_PDU_h245Control_Seq value;
} H323_UU_PDU_h245Control_Element;

typedef struct H323_UU_PDU_h4501SupplementaryService {
    PH323_UU_PDU_h4501SupplementaryService next;
    H323_UU_PDU_h4501SupplementaryService_Seq value;
} H323_UU_PDU_h4501SupplementaryService_Element;

typedef struct H323_UserInformation_user_data {
    ASN1uint16_t protocol_discriminator;
    struct H323_UserInformation_user_data_user_information_user_information {
	ASN1uint32_t length;
	ASN1octet_t value[131];
    } user_information;
} H323_UserInformation_user_data;

typedef struct H235NonStandardParameter {
    ASN1objectidentifier_t nonStandardIdentifier;
    ASN1octetstring_t data;
} H235NonStandardParameter;

typedef struct DHset {
    ASN1bitstring_t halfkey;
    ASN1bitstring_t modSize;
    ASN1bitstring_t generator;
} DHset;

typedef struct TypedCertificate {
    ASN1objectidentifier_t type;
    ASN1octetstring_t certificate;
} TypedCertificate;

typedef struct AuthenticationMechanism {
    ASN1choice_t choice;
    union {
#	define dhExch_chosen 1
#	define pwdSymEnc_chosen 2
#	define pwdHash_chosen 3
#	define certSign_chosen 4
#	define AuthenticationMechanism_ipsec_chosen 5
#	define AuthenticationMechanism_tls_chosen 6
#	define AuthenticationMechanism_nonStandard_chosen 7
	H235NonStandardParameter nonStandard;
    } u;
} AuthenticationMechanism;

typedef struct ClearToken {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1objectidentifier_t tokenOID;
#   define ClearToken_timeStamp_present 0x80
    TimeStamp timeStamp;
#   define password_present 0x40
    Password password;
#   define dhkey_present 0x20
    DHset dhkey;
#   define challenge_present 0x10
    ChallengeString challenge;
#   define random_present 0x8
    RandomVal random;
#   define ClearToken_certificate_present 0x4
    TypedCertificate certificate;
#   define generalID_present 0x2
    Identifier generalID;
#   define ClearToken_nonStandard_present 0x1
    H235NonStandardParameter nonStandard;
} ClearToken;

typedef struct Params {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ranInt_present 0x80
    ASN1int32_t ranInt;
#   define iv8_present 0x40
    IV8 iv8;
} Params;

typedef struct EncodedGeneralToken {
    ASN1objectidentifier_t id;
    ClearToken type;
} EncodedGeneralToken;

typedef ClearToken PwdCertToken;

typedef struct EncodedPwdCertToken {
    ASN1objectidentifier_t id;
    PwdCertToken type;
} EncodedPwdCertToken;

typedef struct ReleaseCompleteReason {
    ASN1choice_t choice;
#   define noBandwidth_chosen 1
#   define gatekeeperResources_chosen 2
#   define unreachableDestination_chosen 3
#   define destinationRejection_chosen 4
#   define ReleaseCompleteReason_invalidRevision_chosen 5
#   define noPermission_chosen 6
#   define unreachableGatekeeper_chosen 7
#   define gatewayResources_chosen 8
#   define badFormatAddress_chosen 9
#   define adaptiveBusy_chosen 10
#   define inConf_chosen 11
#   define ReleaseCompleteReason_undefinedReason_chosen 12
#   define facilityCallDeflection_chosen 13
#   define securityDenied_chosen 14
#   define ReleaseCompleteReason_calledPartyNotRegistered_chosen 15
#   define ReleaseCompleteReason_callerNotRegistered_chosen 16
} ReleaseCompleteReason;

typedef struct FacilityReason {
    ASN1choice_t choice;
#   define FacilityReason_routeCallToGatekeeper_chosen 1
#   define callForwarded_chosen 2
#   define routeCallToMC_chosen 3
#   define FacilityReason_undefinedReason_chosen 4
#   define conferenceListChoice_chosen 5
#   define startH245_chosen 6
} FacilityReason;

typedef struct H221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} H221NonStandard;

typedef struct H225NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define H225NonStandardIdentifier_object_chosen 1
	ASN1objectidentifier_t object;
#	define H225NonStandardIdentifier_h221NonStandard_chosen 2
	H221NonStandard h221NonStandard;
    } u;
} H225NonStandardIdentifier;

typedef struct PublicTypeOfNumber {
    ASN1choice_t choice;
#   define PublicTypeOfNumber_unknown_chosen 1
#   define PublicTypeOfNumber_internationalNumber_chosen 2
#   define nationalNumber_chosen 3
#   define networkSpecificNumber_chosen 4
#   define subscriberNumber_chosen 5
#   define PublicTypeOfNumber_abbreviatedNumber_chosen 6
} PublicTypeOfNumber;

typedef struct PrivateTypeOfNumber {
    ASN1choice_t choice;
#   define PrivateTypeOfNumber_unknown_chosen 1
#   define level2RegionalNumber_chosen 2
#   define level1RegionalNumber_chosen 3
#   define pISNSpecificNumber_chosen 4
#   define localNumber_chosen 5
#   define PrivateTypeOfNumber_abbreviatedNumber_chosen 6
} PrivateTypeOfNumber;

typedef struct AltGKInfo {
    PAltGKInfo_alternateGatekeeper alternateGatekeeper;
    ASN1bool_t altGKisPermanent;
} AltGKInfo;

typedef struct Q954Details {
    ASN1bool_t conferenceCalling;
    ASN1bool_t threePartyService;
} Q954Details;

typedef struct CallIdentifier {
    GloballyUniqueID guid;
} CallIdentifier;

typedef struct ICV {
    ASN1objectidentifier_t algorithmOID;
    ASN1bitstring_t icv;
} ICV;

typedef struct GatekeeperRejectReason {
    ASN1choice_t choice;
#   define GatekeeperRejectReason_resourceUnavailable_chosen 1
#   define terminalExcluded_chosen 2
#   define GatekeeperRejectReason_invalidRevision_chosen 3
#   define GatekeeperRejectReason_undefinedReason_chosen 4
#   define GatekeeperRejectReason_securityDenial_chosen 5
} GatekeeperRejectReason;

typedef struct RegistrationRejectReason {
    ASN1choice_t choice;
    union {
#	define discoveryRequired_chosen 1
#	define RegistrationRejectReason_invalidRevision_chosen 2
#	define invalidCallSignalAddress_chosen 3
#	define invalidRASAddress_chosen 4
#	define duplicateAlias_chosen 5
	PRegistrationRejectReason_duplicateAlias duplicateAlias;
#	define invalidTerminalType_chosen 6
#	define RegistrationRejectReason_undefinedReason_chosen 7
#	define transportNotSupported_chosen 8
#	define transportQOSNotSupported_chosen 9
#	define RegistrationRejectReason_resourceUnavailable_chosen 10
#	define invalidAlias_chosen 11
#	define RegistrationRejectReason_securityDenial_chosen 12
    } u;
} RegistrationRejectReason;

typedef struct UnregRequestReason {
    ASN1choice_t choice;
#   define reregistrationRequired_chosen 1
#   define ttlExpired_chosen 2
#   define UnregRequestReason_securityDenial_chosen 3
#   define UnregRequestReason_undefinedReason_chosen 4
} UnregRequestReason;

typedef struct UnregRejectReason {
    ASN1choice_t choice;
#   define notCurrentlyRegistered_chosen 1
#   define callInProgress_chosen 2
#   define UnregRejectReason_undefinedReason_chosen 3
#   define permissionDenied_chosen 4
#   define UnregRejectReason_securityDenial_chosen 5
} UnregRejectReason;

typedef struct CallType {
    ASN1choice_t choice;
#   define pointToPoint_chosen 1
#   define oneToN_chosen 2
#   define nToOne_chosen 3
#   define nToN_chosen 4
} CallType;

typedef struct CallModel {
    ASN1choice_t choice;
#   define direct_chosen 1
#   define gatekeeperRouted_chosen 2
} CallModel;

typedef struct TransportQOS {
    ASN1choice_t choice;
#   define endpointControlled_chosen 1
#   define gatekeeperControlled_chosen 2
#   define noControl_chosen 3
} TransportQOS;

typedef struct UUIEsRequested {
    ASN1bool_t setup;
    ASN1bool_t callProceeding;
    ASN1bool_t connect;
    ASN1bool_t alerting;
    ASN1bool_t information;
    ASN1bool_t releaseComplete;
    ASN1bool_t facility;
    ASN1bool_t progress;
    ASN1bool_t empty;
} UUIEsRequested;

typedef struct AdmissionRejectReason {
    ASN1choice_t choice;
#   define AdmissionRejectReason_calledPartyNotRegistered_chosen 1
#   define AdmissionRejectReason_invalidPermission_chosen 2
#   define AdmissionRejectReason_requestDenied_chosen 3
#   define AdmissionRejectReason_undefinedReason_chosen 4
#   define AdmissionRejectReason_callerNotRegistered_chosen 5
#   define AdmissionRejectReason_routeCallToGatekeeper_chosen 6
#   define invalidEndpointIdentifier_chosen 7
#   define AdmissionRejectReason_resourceUnavailable_chosen 8
#   define AdmissionRejectReason_securityDenial_chosen 9
#   define qosControlNotSupported_chosen 10
#   define incompleteAddress_chosen 11
} AdmissionRejectReason;

typedef struct BandRejectReason {
    ASN1choice_t choice;
#   define notBound_chosen 1
#   define invalidConferenceID_chosen 2
#   define BandRejectReason_invalidPermission_chosen 3
#   define insufficientResources_chosen 4
#   define BandRejectReason_invalidRevision_chosen 5
#   define BandRejectReason_undefinedReason_chosen 6
#   define BandRejectReason_securityDenial_chosen 7
} BandRejectReason;

typedef struct LocationRejectReason {
    ASN1choice_t choice;
#   define LocationRejectReason_notRegistered_chosen 1
#   define LocationRejectReason_invalidPermission_chosen 2
#   define LocationRejectReason_requestDenied_chosen 3
#   define LocationRejectReason_undefinedReason_chosen 4
#   define LocationRejectReason_securityDenial_chosen 5
} LocationRejectReason;

typedef struct DisengageReason {
    ASN1choice_t choice;
#   define forcedDrop_chosen 1
#   define normalDrop_chosen 2
#   define DisengageReason_undefinedReason_chosen 3
} DisengageReason;

typedef struct DisengageRejectReason {
    ASN1choice_t choice;
#   define DisengageRejectReason_notRegistered_chosen 1
#   define requestToDropOther_chosen 2
#   define DisengageRejectReason_securityDenial_chosen 3
} DisengageRejectReason;

typedef struct InfoRequestNakReason {
    ASN1choice_t choice;
#   define InfoRequestNakReason_notRegistered_chosen 1
#   define InfoRequestNakReason_securityDenial_chosen 2
#   define InfoRequestNakReason_undefinedReason_chosen 3
} InfoRequestNakReason;

typedef struct UnknownMessageResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define UnknownMessageResponse_tokens_present 0x80
    PUnknownMessageResponse_tokens tokens;
#   define UnknownMessageResponse_cryptoTokens_present 0x40
    PUnknownMessageResponse_cryptoTokens cryptoTokens;
#   define UnknownMessageResponse_integrityCheckValue_present 0x20
    ICV integrityCheckValue;
} UnknownMessageResponse;

typedef struct InfoRequestResponse_perCallInfo_Seq_tokens {
    PInfoRequestResponse_perCallInfo_Seq_tokens next;
    ClearToken value;
} InfoRequestResponse_perCallInfo_Seq_tokens_Element;

typedef struct ResourcesAvailableConfirm_tokens {
    PResourcesAvailableConfirm_tokens next;
    ClearToken value;
} ResourcesAvailableConfirm_tokens_Element;

typedef struct ResourcesAvailableIndicate_tokens {
    PResourcesAvailableIndicate_tokens next;
    ClearToken value;
} ResourcesAvailableIndicate_tokens_Element;

typedef struct RequestInProgress_tokens {
    PRequestInProgress_tokens next;
    ClearToken value;
} RequestInProgress_tokens_Element;

typedef struct UnknownMessageResponse_tokens {
    PUnknownMessageResponse_tokens next;
    ClearToken value;
} UnknownMessageResponse_tokens_Element;

typedef struct H225NonStandardMessage_tokens {
    PH225NonStandardMessage_tokens next;
    ClearToken value;
} H225NonStandardMessage_tokens_Element;

typedef struct InfoRequestNak_tokens {
    PInfoRequestNak_tokens next;
    ClearToken value;
} InfoRequestNak_tokens_Element;

typedef struct InfoRequestAck_tokens {
    PInfoRequestAck_tokens next;
    ClearToken value;
} InfoRequestAck_tokens_Element;

typedef struct InfoRequestResponse_tokens {
    PInfoRequestResponse_tokens next;
    ClearToken value;
} InfoRequestResponse_tokens_Element;

typedef struct InfoRequest_tokens {
    PInfoRequest_tokens next;
    ClearToken value;
} InfoRequest_tokens_Element;

typedef struct DisengageReject_tokens {
    PDisengageReject_tokens next;
    ClearToken value;
} DisengageReject_tokens_Element;

typedef struct DisengageConfirm_tokens {
    PDisengageConfirm_tokens next;
    ClearToken value;
} DisengageConfirm_tokens_Element;

typedef struct DisengageRequest_tokens {
    PDisengageRequest_tokens next;
    ClearToken value;
} DisengageRequest_tokens_Element;

typedef struct LocationReject_tokens {
    PLocationReject_tokens next;
    ClearToken value;
} LocationReject_tokens_Element;

typedef struct LocationConfirm_tokens {
    PLocationConfirm_tokens next;
    ClearToken value;
} LocationConfirm_tokens_Element;

typedef struct LocationRequest_tokens {
    PLocationRequest_tokens next;
    ClearToken value;
} LocationRequest_tokens_Element;

typedef struct BandwidthReject_tokens {
    PBandwidthReject_tokens next;
    ClearToken value;
} BandwidthReject_tokens_Element;

typedef struct BandwidthConfirm_tokens {
    PBandwidthConfirm_tokens next;
    ClearToken value;
} BandwidthConfirm_tokens_Element;

typedef struct BandwidthRequest_tokens {
    PBandwidthRequest_tokens next;
    ClearToken value;
} BandwidthRequest_tokens_Element;

typedef struct AdmissionReject_tokens {
    PAdmissionReject_tokens next;
    ClearToken value;
} AdmissionReject_tokens_Element;

typedef struct AdmissionConfirm_tokens {
    PAdmissionConfirm_tokens next;
    ClearToken value;
} AdmissionConfirm_tokens_Element;

typedef struct AdmissionRequest_tokens {
    PAdmissionRequest_tokens next;
    ClearToken value;
} AdmissionRequest_tokens_Element;

typedef struct UnregistrationReject_tokens {
    PUnregistrationReject_tokens next;
    ClearToken value;
} UnregistrationReject_tokens_Element;

typedef struct UnregistrationConfirm_tokens {
    PUnregistrationConfirm_tokens next;
    ClearToken value;
} UnregistrationConfirm_tokens_Element;

typedef struct UnregistrationRequest_tokens {
    PUnregistrationRequest_tokens next;
    ClearToken value;
} UnregistrationRequest_tokens_Element;

typedef struct RegistrationReject_tokens {
    PRegistrationReject_tokens next;
    ClearToken value;
} RegistrationReject_tokens_Element;

typedef struct RegistrationConfirm_tokens {
    PRegistrationConfirm_tokens next;
    ClearToken value;
} RegistrationConfirm_tokens_Element;

typedef struct RegistrationRequest_tokens {
    PRegistrationRequest_tokens next;
    ClearToken value;
} RegistrationRequest_tokens_Element;

typedef struct GatekeeperReject_tokens {
    PGatekeeperReject_tokens next;
    ClearToken value;
} GatekeeperReject_tokens_Element;

typedef struct GatekeeperConfirm_tokens {
    PGatekeeperConfirm_tokens next;
    ClearToken value;
} GatekeeperConfirm_tokens_Element;

typedef struct GatekeeperRequest_authenticationCapability {
    PGatekeeperRequest_authenticationCapability next;
    AuthenticationMechanism value;
} GatekeeperRequest_authenticationCapability_Element;

typedef struct GatekeeperRequest_tokens {
    PGatekeeperRequest_tokens next;
    ClearToken value;
} GatekeeperRequest_tokens_Element;

typedef struct Endpoint_tokens {
    PEndpoint_tokens next;
    ClearToken value;
} Endpoint_tokens_Element;

typedef struct Progress_UUIE_tokens {
    PProgress_UUIE_tokens next;
    ClearToken value;
} Progress_UUIE_tokens_Element;

typedef struct Facility_UUIE_tokens {
    PFacility_UUIE_tokens next;
    ClearToken value;
} Facility_UUIE_tokens_Element;

typedef struct Setup_UUIE_tokens {
    PSetup_UUIE_tokens next;
    ClearToken value;
} Setup_UUIE_tokens_Element;

typedef struct Connect_UUIE_tokens {
    PConnect_UUIE_tokens next;
    ClearToken value;
} Connect_UUIE_tokens_Element;

typedef struct CallProceeding_UUIE_tokens {
    PCallProceeding_UUIE_tokens next;
    ClearToken value;
} CallProceeding_UUIE_tokens_Element;

typedef struct Alerting_UUIE_tokens {
    PAlerting_UUIE_tokens next;
    ClearToken value;
} Alerting_UUIE_tokens_Element;

typedef struct SIGNED_EncodedGeneralToken {
    EncodedGeneralToken toBeSigned;
    ASN1objectidentifier_t algorithmOID;
    Params paramS;
    ASN1bitstring_t signature;
} SIGNED_EncodedGeneralToken;

typedef struct ENCRYPTED {
    ASN1objectidentifier_t algorithmOID;
    Params paramS;
    ASN1octetstring_t encryptedData;
} ENCRYPTED;

typedef struct HASHED {
    ASN1objectidentifier_t algorithmOID;
    Params paramS;
    ASN1bitstring_t hash;
} HASHED;

typedef struct SIGNED_EncodedPwdCertToken {
    EncodedPwdCertToken toBeSigned;
    ASN1objectidentifier_t algorithmOID;
    Params paramS;
    ASN1bitstring_t signature;
} SIGNED_EncodedPwdCertToken;

typedef struct Information_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ProtocolIdentifier protocolIdentifier;
#   define Information_UUIE_callIdentifier_present 0x80
    CallIdentifier callIdentifier;
} Information_UUIE;

typedef struct ReleaseComplete_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ProtocolIdentifier protocolIdentifier;
#   define ReleaseComplete_UUIE_reason_present 0x80
    ReleaseCompleteReason reason;
#   define ReleaseComplete_UUIE_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
} ReleaseComplete_UUIE;

typedef struct VendorIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H221NonStandard vendor;
#   define productId_present 0x80
    struct VendorIdentifier_productId_productId {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } productId;
#   define versionId_present 0x40
    struct VendorIdentifier_versionId_versionId {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } versionId;
} VendorIdentifier;

typedef struct H225NonStandardParameter {
    H225NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} H225NonStandardParameter;

typedef struct PublicPartyNumber {
    PublicTypeOfNumber publicTypeOfNumber;
    NumberDigits publicNumberDigits;
} PublicPartyNumber;

typedef struct PrivatePartyNumber {
    PrivateTypeOfNumber privateTypeOfNumber;
    NumberDigits privateNumberDigits;
} PrivatePartyNumber;

typedef struct SecurityServiceMode {
    ASN1choice_t choice;
    union {
#	define SecurityServiceMode_nonStandard_chosen 1
	H225NonStandardParameter nonStandard;
#	define SecurityServiceMode_none_chosen 2
#	define SecurityServiceMode_default_chosen 3
    } u;
} SecurityServiceMode;

typedef struct SecurityCapabilities {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define SecurityCapabilities_nonStandard_present 0x80
    H225NonStandardParameter nonStandard;
    SecurityServiceMode encryption;
    SecurityServiceMode authenticaton;
    SecurityServiceMode integrity;
} SecurityCapabilities;

typedef struct H245Security {
    ASN1choice_t choice;
    union {
#	define H245Security_nonStandard_chosen 1
	H225NonStandardParameter nonStandard;
#	define noSecurity_chosen 2
#	define H245Security_tls_chosen 3
	SecurityCapabilities tls;
#	define H245Security_ipsec_chosen 4
	SecurityCapabilities ipsec;
    } u;
} H245Security;

typedef struct QseriesOptions {
    ASN1bool_t q932Full;
    ASN1bool_t q951Full;
    ASN1bool_t q952Full;
    ASN1bool_t q953Full;
    ASN1bool_t q955Full;
    ASN1bool_t q956Full;
    ASN1bool_t q957Full;
    Q954Details q954Info;
} QseriesOptions;

typedef struct EncryptIntAlg {
    ASN1choice_t choice;
    union {
#	define EncryptIntAlg_nonStandard_chosen 1
	H225NonStandardParameter nonStandard;
#	define isoAlgorithm_chosen 2
	ASN1objectidentifier_t isoAlgorithm;
    } u;
} EncryptIntAlg;

typedef struct NonIsoIntegrityMechanism {
    ASN1choice_t choice;
    union {
#	define hMAC_MD5_chosen 1
#	define hMAC_iso10118_2_s_chosen 2
	EncryptIntAlg hMAC_iso10118_2_s;
#	define hMAC_iso10118_2_l_chosen 3
	EncryptIntAlg hMAC_iso10118_2_l;
#	define hMAC_iso10118_3_chosen 4
	ASN1objectidentifier_t hMAC_iso10118_3;
    } u;
} NonIsoIntegrityMechanism;

typedef struct IntegrityMechanism {
    ASN1choice_t choice;
    union {
#	define IntegrityMechanism_nonStandard_chosen 1
	H225NonStandardParameter nonStandard;
#	define digSig_chosen 2
#	define iso9797_chosen 3
	ASN1objectidentifier_t iso9797;
#	define nonIsoIM_chosen 4
	NonIsoIntegrityMechanism nonIsoIM;
    } u;
} IntegrityMechanism;

typedef ClearToken FastStartToken;

typedef struct EncodedFastStartToken {
    ASN1objectidentifier_t id;
    FastStartToken type;
} EncodedFastStartToken;

typedef struct DataRate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define DataRate_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    BandWidth channelRate;
#   define channelMultiplier_present 0x40
    ASN1uint16_t channelMultiplier;
} DataRate;

typedef struct GatekeeperReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define GatekeeperReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define GatekeeperReject_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
    GatekeeperRejectReason rejectReason;
#   define GatekeeperReject_altGKInfo_present 0x8000
    AltGKInfo altGKInfo;
#   define GatekeeperReject_tokens_present 0x4000
    PGatekeeperReject_tokens tokens;
#   define GatekeeperReject_cryptoTokens_present 0x2000
    PGatekeeperReject_cryptoTokens cryptoTokens;
#   define GatekeeperReject_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
} GatekeeperReject;

typedef struct RegistrationConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define RegistrationConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    PRegistrationConfirm_callSignalAddress callSignalAddress;
#   define RegistrationConfirm_terminalAlias_present 0x40
    PRegistrationConfirm_terminalAlias terminalAlias;
#   define RegistrationConfirm_gatekeeperIdentifier_present 0x20
    GatekeeperIdentifier gatekeeperIdentifier;
    EndpointIdentifier endpointIdentifier;
#   define RegistrationConfirm_alternateGatekeeper_present 0x8000
    PRegistrationConfirm_alternateGatekeeper alternateGatekeeper;
#   define RegistrationConfirm_timeToLive_present 0x4000
    TimeToLive timeToLive;
#   define RegistrationConfirm_tokens_present 0x2000
    PRegistrationConfirm_tokens tokens;
#   define RegistrationConfirm_cryptoTokens_present 0x1000
    PRegistrationConfirm_cryptoTokens cryptoTokens;
#   define RegistrationConfirm_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
#   define RegistrationConfirm_willRespondToIRR_present 0x400
    ASN1bool_t willRespondToIRR;
#   define preGrantedARQ_present 0x200
    RegistrationConfirm_preGrantedARQ preGrantedARQ;
} RegistrationConfirm;

typedef struct RegistrationReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define RegistrationReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    RegistrationRejectReason rejectReason;
#   define RegistrationReject_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
#   define RegistrationReject_altGKInfo_present 0x8000
    AltGKInfo altGKInfo;
#   define RegistrationReject_tokens_present 0x4000
    PRegistrationReject_tokens tokens;
#   define RegistrationReject_cryptoTokens_present 0x2000
    PRegistrationReject_cryptoTokens cryptoTokens;
#   define RegistrationReject_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
} RegistrationReject;

typedef struct UnregistrationRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    PUnregistrationRequest_callSignalAddress callSignalAddress;
#   define UnregistrationRequest_endpointAlias_present 0x80
    PUnregistrationRequest_endpointAlias endpointAlias;
#   define UnregistrationRequest_nonStandardData_present 0x40
    H225NonStandardParameter nonStandardData;
#   define UnregistrationRequest_endpointIdentifier_present 0x20
    EndpointIdentifier endpointIdentifier;
#   define UnregistrationRequest_alternateEndpoints_present 0x8000
    PUnregistrationRequest_alternateEndpoints alternateEndpoints;
#   define UnregistrationRequest_gatekeeperIdentifier_present 0x4000
    GatekeeperIdentifier gatekeeperIdentifier;
#   define UnregistrationRequest_tokens_present 0x2000
    PUnregistrationRequest_tokens tokens;
#   define UnregistrationRequest_cryptoTokens_present 0x1000
    PUnregistrationRequest_cryptoTokens cryptoTokens;
#   define UnregistrationRequest_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
#   define UnregistrationRequest_reason_present 0x400
    UnregRequestReason reason;
} UnregistrationRequest;

typedef struct UnregistrationConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
#   define UnregistrationConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define UnregistrationConfirm_tokens_present 0x8000
    PUnregistrationConfirm_tokens tokens;
#   define UnregistrationConfirm_cryptoTokens_present 0x4000
    PUnregistrationConfirm_cryptoTokens cryptoTokens;
#   define UnregistrationConfirm_integrityCheckValue_present 0x2000
    ICV integrityCheckValue;
} UnregistrationConfirm;

typedef struct UnregistrationReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    UnregRejectReason rejectReason;
#   define UnregistrationReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define UnregistrationReject_altGKInfo_present 0x8000
    AltGKInfo altGKInfo;
#   define UnregistrationReject_tokens_present 0x4000
    PUnregistrationReject_tokens tokens;
#   define UnregistrationReject_cryptoTokens_present 0x2000
    PUnregistrationReject_cryptoTokens cryptoTokens;
#   define UnregistrationReject_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
} UnregistrationReject;

typedef struct AdmissionReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    AdmissionRejectReason rejectReason;
#   define AdmissionReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define AdmissionReject_altGKInfo_present 0x8000
    AltGKInfo altGKInfo;
#   define AdmissionReject_tokens_present 0x4000
    PAdmissionReject_tokens tokens;
#   define AdmissionReject_cryptoTokens_present 0x2000
    PAdmissionReject_cryptoTokens cryptoTokens;
#   define AdmissionReject_callSignalAddress_present 0x1000
    PAdmissionReject_callSignalAddress callSignalAddress;
#   define AdmissionReject_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
} AdmissionReject;

typedef struct BandwidthRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    EndpointIdentifier endpointIdentifier;
    ConferenceIdentifier conferenceID;
    CallReferenceValue callReferenceValue;
#   define callType_present 0x80
    CallType callType;
    BandWidth bandWidth;
#   define BandwidthRequest_nonStandardData_present 0x40
    H225NonStandardParameter nonStandardData;
#   define BandwidthRequest_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define BandwidthRequest_gatekeeperIdentifier_present 0x4000
    GatekeeperIdentifier gatekeeperIdentifier;
#   define BandwidthRequest_tokens_present 0x2000
    PBandwidthRequest_tokens tokens;
#   define BandwidthRequest_cryptoTokens_present 0x1000
    PBandwidthRequest_cryptoTokens cryptoTokens;
#   define BandwidthRequest_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
#   define BandwidthRequest_answeredCall_present 0x400
    ASN1bool_t answeredCall;
} BandwidthRequest;

typedef struct BandwidthConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    BandWidth bandWidth;
#   define BandwidthConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define BandwidthConfirm_tokens_present 0x8000
    PBandwidthConfirm_tokens tokens;
#   define BandwidthConfirm_cryptoTokens_present 0x4000
    PBandwidthConfirm_cryptoTokens cryptoTokens;
#   define BandwidthConfirm_integrityCheckValue_present 0x2000
    ICV integrityCheckValue;
} BandwidthConfirm;

typedef struct BandwidthReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    BandRejectReason rejectReason;
    BandWidth allowedBandWidth;
#   define BandwidthReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define BandwidthReject_altGKInfo_present 0x8000
    AltGKInfo altGKInfo;
#   define BandwidthReject_tokens_present 0x4000
    PBandwidthReject_tokens tokens;
#   define BandwidthReject_cryptoTokens_present 0x2000
    PBandwidthReject_cryptoTokens cryptoTokens;
#   define BandwidthReject_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
} BandwidthReject;

typedef struct LocationReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    LocationRejectReason rejectReason;
#   define LocationReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define LocationReject_altGKInfo_present 0x8000
    AltGKInfo altGKInfo;
#   define LocationReject_tokens_present 0x4000
    PLocationReject_tokens tokens;
#   define LocationReject_cryptoTokens_present 0x2000
    PLocationReject_cryptoTokens cryptoTokens;
#   define LocationReject_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
} LocationReject;

typedef struct DisengageRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    EndpointIdentifier endpointIdentifier;
    ConferenceIdentifier conferenceID;
    CallReferenceValue callReferenceValue;
    DisengageReason disengageReason;
#   define DisengageRequest_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define DisengageRequest_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define DisengageRequest_gatekeeperIdentifier_present 0x4000
    GatekeeperIdentifier gatekeeperIdentifier;
#   define DisengageRequest_tokens_present 0x2000
    PDisengageRequest_tokens tokens;
#   define DisengageRequest_cryptoTokens_present 0x1000
    PDisengageRequest_cryptoTokens cryptoTokens;
#   define DisengageRequest_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
#   define DisengageRequest_answeredCall_present 0x400
    ASN1bool_t answeredCall;
} DisengageRequest;

typedef struct DisengageConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
#   define DisengageConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define DisengageConfirm_tokens_present 0x8000
    PDisengageConfirm_tokens tokens;
#   define DisengageConfirm_cryptoTokens_present 0x4000
    PDisengageConfirm_cryptoTokens cryptoTokens;
#   define DisengageConfirm_integrityCheckValue_present 0x2000
    ICV integrityCheckValue;
} DisengageConfirm;

typedef struct DisengageReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    DisengageRejectReason rejectReason;
#   define DisengageReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define DisengageReject_altGKInfo_present 0x8000
    AltGKInfo altGKInfo;
#   define DisengageReject_tokens_present 0x4000
    PDisengageReject_tokens tokens;
#   define DisengageReject_cryptoTokens_present 0x2000
    PDisengageReject_cryptoTokens cryptoTokens;
#   define DisengageReject_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
} DisengageReject;

typedef struct InfoRequestAck {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define InfoRequestAck_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define InfoRequestAck_tokens_present 0x40
    PInfoRequestAck_tokens tokens;
#   define InfoRequestAck_cryptoTokens_present 0x20
    PInfoRequestAck_cryptoTokens cryptoTokens;
#   define InfoRequestAck_integrityCheckValue_present 0x10
    ICV integrityCheckValue;
} InfoRequestAck;

typedef struct InfoRequestNak {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define InfoRequestNak_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    InfoRequestNakReason nakReason;
#   define InfoRequestNak_altGKInfo_present 0x40
    AltGKInfo altGKInfo;
#   define InfoRequestNak_tokens_present 0x20
    PInfoRequestNak_tokens tokens;
#   define InfoRequestNak_cryptoTokens_present 0x10
    PInfoRequestNak_cryptoTokens cryptoTokens;
#   define InfoRequestNak_integrityCheckValue_present 0x8
    ICV integrityCheckValue;
} InfoRequestNak;

typedef struct H225NonStandardMessage {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    H225NonStandardParameter nonStandardData;
#   define H225NonStandardMessage_tokens_present 0x80
    PH225NonStandardMessage_tokens tokens;
#   define H225NonStandardMessage_cryptoTokens_present 0x40
    PH225NonStandardMessage_cryptoTokens cryptoTokens;
#   define H225NonStandardMessage_integrityCheckValue_present 0x20
    ICV integrityCheckValue;
} H225NonStandardMessage;

typedef struct RequestInProgress {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define RequestInProgress_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define RequestInProgress_tokens_present 0x40
    PRequestInProgress_tokens tokens;
#   define RequestInProgress_cryptoTokens_present 0x20
    PRequestInProgress_cryptoTokens cryptoTokens;
#   define RequestInProgress_integrityCheckValue_present 0x10
    ICV integrityCheckValue;
    ASN1uint16_t delay;
} RequestInProgress;

typedef struct ResourcesAvailableIndicate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define ResourcesAvailableIndicate_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    EndpointIdentifier endpointIdentifier;
    PResourcesAvailableIndicate_protocols protocols;
    ASN1bool_t almostOutOfResources;
#   define ResourcesAvailableIndicate_tokens_present 0x40
    PResourcesAvailableIndicate_tokens tokens;
#   define ResourcesAvailableIndicate_cryptoTokens_present 0x20
    PResourcesAvailableIndicate_cryptoTokens cryptoTokens;
#   define ResourcesAvailableIndicate_integrityCheckValue_present 0x10
    ICV integrityCheckValue;
} ResourcesAvailableIndicate;

typedef struct ResourcesAvailableConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define ResourcesAvailableConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define ResourcesAvailableConfirm_tokens_present 0x40
    PResourcesAvailableConfirm_tokens tokens;
#   define ResourcesAvailableConfirm_cryptoTokens_present 0x20
    PResourcesAvailableConfirm_cryptoTokens cryptoTokens;
#   define ResourcesAvailableConfirm_integrityCheckValue_present 0x10
    ICV integrityCheckValue;
} ResourcesAvailableConfirm;

typedef struct GatekeeperConfirm_integrity {
    PGatekeeperConfirm_integrity next;
    IntegrityMechanism value;
} GatekeeperConfirm_integrity_Element;

typedef struct GatekeeperRequest_integrity {
    PGatekeeperRequest_integrity next;
    IntegrityMechanism value;
} GatekeeperRequest_integrity_Element;

typedef struct CryptoH323Token_cryptoGKPwdHash {
    GatekeeperIdentifier gatekeeperId;
    TimeStamp timeStamp;
    HASHED token;
} CryptoH323Token_cryptoGKPwdHash;

typedef struct NonStandardProtocol_dataRatesSupported {
    PNonStandardProtocol_dataRatesSupported next;
    DataRate value;
} NonStandardProtocol_dataRatesSupported_Element;

typedef struct T120OnlyCaps_dataRatesSupported {
    PT120OnlyCaps_dataRatesSupported next;
    DataRate value;
} T120OnlyCaps_dataRatesSupported_Element;

typedef struct VoiceCaps_dataRatesSupported {
    PVoiceCaps_dataRatesSupported next;
    DataRate value;
} VoiceCaps_dataRatesSupported_Element;

typedef struct H324Caps_dataRatesSupported {
    PH324Caps_dataRatesSupported next;
    DataRate value;
} H324Caps_dataRatesSupported_Element;

typedef struct H323Caps_dataRatesSupported {
    PH323Caps_dataRatesSupported next;
    DataRate value;
} H323Caps_dataRatesSupported_Element;

typedef struct H322Caps_dataRatesSupported {
    PH322Caps_dataRatesSupported next;
    DataRate value;
} H322Caps_dataRatesSupported_Element;

typedef struct H321Caps_dataRatesSupported {
    PH321Caps_dataRatesSupported next;
    DataRate value;
} H321Caps_dataRatesSupported_Element;

typedef struct H320Caps_dataRatesSupported {
    PH320Caps_dataRatesSupported next;
    DataRate value;
} H320Caps_dataRatesSupported_Element;

typedef struct H310Caps_dataRatesSupported {
    PH310Caps_dataRatesSupported next;
    DataRate value;
} H310Caps_dataRatesSupported_Element;

typedef struct Setup_UUIE_h245SecurityCapability {
    PSetup_UUIE_h245SecurityCapability next;
    H245Security value;
} Setup_UUIE_h245SecurityCapability_Element;

typedef struct H323_UU_PDU_nonStandardControl {
    PH323_UU_PDU_nonStandardControl next;
    H225NonStandardParameter value;
} H323_UU_PDU_nonStandardControl_Element;

typedef struct CryptoToken_cryptoHashedToken {
    ASN1objectidentifier_t tokenOID;
    ClearToken hashedVals;
    HASHED token;
} CryptoToken_cryptoHashedToken;

typedef struct CryptoToken_cryptoSignedToken {
    ASN1objectidentifier_t tokenOID;
    SIGNED_EncodedGeneralToken token;
} CryptoToken_cryptoSignedToken;

typedef struct CryptoToken_cryptoEncryptedToken {
    ASN1objectidentifier_t tokenOID;
    ENCRYPTED token;
} CryptoToken_cryptoEncryptedToken;

typedef struct CryptoToken {
    ASN1choice_t choice;
    union {
#	define cryptoEncryptedToken_chosen 1
	CryptoToken_cryptoEncryptedToken cryptoEncryptedToken;
#	define cryptoSignedToken_chosen 2
	CryptoToken_cryptoSignedToken cryptoSignedToken;
#	define cryptoHashedToken_chosen 3
	CryptoToken_cryptoHashedToken cryptoHashedToken;
#	define cryptoPwdEncr_chosen 4
	ENCRYPTED cryptoPwdEncr;
    } u;
} CryptoToken;

typedef struct SIGNED_EncodedFastStartToken {
    EncodedFastStartToken toBeSigned;
    ASN1objectidentifier_t algorithmOID;
    Params paramS;
    ASN1bitstring_t signature;
} SIGNED_EncodedFastStartToken;

typedef struct TransportAddress {
    ASN1choice_t choice;
    union {
#	define ipAddress_chosen 1
	TransportAddress_ipAddress ipAddress;
#	define ipSourceRoute_chosen 2
	TransportAddress_ipSourceRoute ipSourceRoute;
#	define ipxAddress_chosen 3
	TransportAddress_ipxAddress ipxAddress;
#	define ip6Address_chosen 4
	TransportAddress_ip6Address ip6Address;
#	define TransportAddress_netBios_chosen 5
	struct TransportAddress_netBios_netBios {
	    ASN1uint32_t length;
	    ASN1octet_t value[16];
	} netBios;
#	define TransportAddress_nsap_chosen 6
	struct TransportAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define TransportAddress_nonStandardAddress_chosen 7
	H225NonStandardParameter nonStandardAddress;
    } u;
} TransportAddress;

typedef struct GatewayInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define protocol_present 0x80
    PGatewayInfo_protocol protocol;
#   define GatewayInfo_nonStandardData_present 0x40
    H225NonStandardParameter nonStandardData;
} GatewayInfo;

typedef struct H310Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H310Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H310Caps_dataRatesSupported_present 0x8000
    PH310Caps_dataRatesSupported dataRatesSupported;
#   define H310Caps_supportedPrefixes_present 0x4000
    PH310Caps_supportedPrefixes supportedPrefixes;
} H310Caps;

typedef struct H320Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H320Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H320Caps_dataRatesSupported_present 0x8000
    PH320Caps_dataRatesSupported dataRatesSupported;
#   define H320Caps_supportedPrefixes_present 0x4000
    PH320Caps_supportedPrefixes supportedPrefixes;
} H320Caps;

typedef struct H321Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H321Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H321Caps_dataRatesSupported_present 0x8000
    PH321Caps_dataRatesSupported dataRatesSupported;
#   define H321Caps_supportedPrefixes_present 0x4000
    PH321Caps_supportedPrefixes supportedPrefixes;
} H321Caps;

typedef struct H322Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H322Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H322Caps_dataRatesSupported_present 0x8000
    PH322Caps_dataRatesSupported dataRatesSupported;
#   define H322Caps_supportedPrefixes_present 0x4000
    PH322Caps_supportedPrefixes supportedPrefixes;
} H322Caps;

typedef struct H323Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H323Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H323Caps_dataRatesSupported_present 0x8000
    PH323Caps_dataRatesSupported dataRatesSupported;
#   define H323Caps_supportedPrefixes_present 0x4000
    PH323Caps_supportedPrefixes supportedPrefixes;
} H323Caps;

typedef struct H324Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H324Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H324Caps_dataRatesSupported_present 0x8000
    PH324Caps_dataRatesSupported dataRatesSupported;
#   define H324Caps_supportedPrefixes_present 0x4000
    PH324Caps_supportedPrefixes supportedPrefixes;
} H324Caps;

typedef struct VoiceCaps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define VoiceCaps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define VoiceCaps_dataRatesSupported_present 0x8000
    PVoiceCaps_dataRatesSupported dataRatesSupported;
#   define VoiceCaps_supportedPrefixes_present 0x4000
    PVoiceCaps_supportedPrefixes supportedPrefixes;
} VoiceCaps;

typedef struct T120OnlyCaps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define T120OnlyCaps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define T120OnlyCaps_dataRatesSupported_present 0x8000
    PT120OnlyCaps_dataRatesSupported dataRatesSupported;
#   define T120OnlyCaps_supportedPrefixes_present 0x4000
    PT120OnlyCaps_supportedPrefixes supportedPrefixes;
} T120OnlyCaps;

typedef struct NonStandardProtocol {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define NonStandardProtocol_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define NonStandardProtocol_dataRatesSupported_present 0x40
    PNonStandardProtocol_dataRatesSupported dataRatesSupported;
    PNonStandardProtocol_supportedPrefixes supportedPrefixes;
} NonStandardProtocol;

typedef struct McuInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define McuInfo_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
} McuInfo;

typedef struct TerminalInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define TerminalInfo_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
} TerminalInfo;

typedef struct GatekeeperInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define GatekeeperInfo_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
} GatekeeperInfo;

typedef struct PartyNumber {
    ASN1choice_t choice;
    union {
#	define publicNumber_chosen 1
	PublicPartyNumber publicNumber;
#	define dataPartyNumber_chosen 2
	NumberDigits dataPartyNumber;
#	define telexPartyNumber_chosen 3
	NumberDigits telexPartyNumber;
#	define privateNumber_chosen 4
	PrivatePartyNumber privateNumber;
#	define nationalStandardPartyNumber_chosen 5
	NumberDigits nationalStandardPartyNumber;
    } u;
} PartyNumber;

typedef struct AlternateGK {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    TransportAddress rasAddress;
#   define AlternateGK_gatekeeperIdentifier_present 0x80
    GatekeeperIdentifier gatekeeperIdentifier;
    ASN1bool_t needToRegister;
    ASN1uint16_t priority;
} AlternateGK;

typedef struct GatekeeperConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define GatekeeperConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define GatekeeperConfirm_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
    TransportAddress rasAddress;
#   define GatekeeperConfirm_alternateGatekeeper_present 0x8000
    PGatekeeperConfirm_alternateGatekeeper alternateGatekeeper;
#   define authenticationMode_present 0x4000
    AuthenticationMechanism authenticationMode;
#   define GatekeeperConfirm_tokens_present 0x2000
    PGatekeeperConfirm_tokens tokens;
#   define GatekeeperConfirm_cryptoTokens_present 0x1000
    PGatekeeperConfirm_cryptoTokens cryptoTokens;
#   define algorithmOID_present 0x800
    ASN1objectidentifier_t algorithmOID;
#   define GatekeeperConfirm_integrity_present 0x400
    PGatekeeperConfirm_integrity integrity;
#   define GatekeeperConfirm_integrityCheckValue_present 0x200
    ICV integrityCheckValue;
} GatekeeperConfirm;

typedef struct AdmissionRequest {
    union {
	ASN1uint32_t bit_mask;
	ASN1octet_t o[3];
    };
    RequestSeqNum requestSeqNum;
    CallType callType;
#   define callModel_present 0x80
    CallModel callModel;
    EndpointIdentifier endpointIdentifier;
#   define AdmissionRequest_destinationInfo_present 0x40
    PAdmissionRequest_destinationInfo destinationInfo;
#   define AdmissionRequest_destCallSignalAddress_present 0x20
    TransportAddress destCallSignalAddress;
#   define AdmissionRequest_destExtraCallInfo_present 0x10
    PAdmissionRequest_destExtraCallInfo destExtraCallInfo;
    PAdmissionRequest_srcInfo srcInfo;
#   define srcCallSignalAddress_present 0x8
    TransportAddress srcCallSignalAddress;
    BandWidth bandWidth;
    CallReferenceValue callReferenceValue;
#   define AdmissionRequest_nonStandardData_present 0x4
    H225NonStandardParameter nonStandardData;
#   define AdmissionRequest_callServices_present 0x2
    QseriesOptions callServices;
    ConferenceIdentifier conferenceID;
    ASN1bool_t activeMC;
    ASN1bool_t answerCall;
#   define AdmissionRequest_canMapAlias_present 0x8000
    ASN1bool_t canMapAlias;
#   define AdmissionRequest_callIdentifier_present 0x4000
    CallIdentifier callIdentifier;
#   define srcAlternatives_present 0x2000
    PAdmissionRequest_srcAlternatives srcAlternatives;
#   define destAlternatives_present 0x1000
    PAdmissionRequest_destAlternatives destAlternatives;
#   define AdmissionRequest_gatekeeperIdentifier_present 0x800
    GatekeeperIdentifier gatekeeperIdentifier;
#   define AdmissionRequest_tokens_present 0x400
    PAdmissionRequest_tokens tokens;
#   define AdmissionRequest_cryptoTokens_present 0x200
    PAdmissionRequest_cryptoTokens cryptoTokens;
#   define AdmissionRequest_integrityCheckValue_present 0x100
    ICV integrityCheckValue;
#   define AdmissionRequest_transportQOS_present 0x800000
    TransportQOS transportQOS;
#   define AdmissionRequest_willSupplyUUIEs_present 0x400000
    ASN1bool_t willSupplyUUIEs;
} AdmissionRequest;

typedef struct LocationRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
#   define LocationRequest_endpointIdentifier_present 0x80
    EndpointIdentifier endpointIdentifier;
    PLocationRequest_destinationInfo destinationInfo;
#   define LocationRequest_nonStandardData_present 0x40
    H225NonStandardParameter nonStandardData;
    TransportAddress replyAddress;
#   define sourceInfo_present 0x8000
    PLocationRequest_sourceInfo sourceInfo;
#   define LocationRequest_canMapAlias_present 0x4000
    ASN1bool_t canMapAlias;
#   define LocationRequest_gatekeeperIdentifier_present 0x2000
    GatekeeperIdentifier gatekeeperIdentifier;
#   define LocationRequest_tokens_present 0x1000
    PLocationRequest_tokens tokens;
#   define LocationRequest_cryptoTokens_present 0x800
    PLocationRequest_cryptoTokens cryptoTokens;
#   define LocationRequest_integrityCheckValue_present 0x400
    ICV integrityCheckValue;
} LocationRequest;

typedef struct InfoRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    CallReferenceValue callReferenceValue;
#   define InfoRequest_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define replyAddress_present 0x40
    TransportAddress replyAddress;
#   define InfoRequest_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define InfoRequest_tokens_present 0x4000
    PInfoRequest_tokens tokens;
#   define InfoRequest_cryptoTokens_present 0x2000
    PInfoRequest_cryptoTokens cryptoTokens;
#   define InfoRequest_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
#   define InfoRequest_uuiesRequested_present 0x800
    UUIEsRequested uuiesRequested;
} InfoRequest;

typedef struct TransportChannelInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define sendAddress_present 0x80
    TransportAddress sendAddress;
#   define recvAddress_present 0x40
    TransportAddress recvAddress;
} TransportChannelInfo;

typedef struct RTPSession {
    TransportChannelInfo rtpAddress;
    TransportChannelInfo rtcpAddress;
    ASN1ztcharstring_t cname;
    ASN1uint32_t ssrc;
    ASN1uint16_t sessionId;
    PRTPSession_associatedSessionIds associatedSessionIds;
} RTPSession;

typedef struct InfoRequestResponse_perCallInfo_Seq_data {
    PInfoRequestResponse_perCallInfo_Seq_data next;
    TransportChannelInfo value;
} InfoRequestResponse_perCallInfo_Seq_data_Element;

typedef struct InfoRequestResponse_perCallInfo_Seq_video {
    PInfoRequestResponse_perCallInfo_Seq_video next;
    RTPSession value;
} InfoRequestResponse_perCallInfo_Seq_video_Element;

typedef struct InfoRequestResponse_perCallInfo_Seq_audio {
    PInfoRequestResponse_perCallInfo_Seq_audio next;
    RTPSession value;
} InfoRequestResponse_perCallInfo_Seq_audio_Element;

typedef struct InfoRequestResponse_perCallInfo_Seq {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define InfoRequestResponse_perCallInfo_Seq_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    CallReferenceValue callReferenceValue;
    ConferenceIdentifier conferenceID;
#   define originator_present 0x40
    ASN1bool_t originator;
#   define audio_present 0x20
    PInfoRequestResponse_perCallInfo_Seq_audio audio;
#   define video_present 0x10
    PInfoRequestResponse_perCallInfo_Seq_video video;
#   define data_present 0x8
    PInfoRequestResponse_perCallInfo_Seq_data data;
    TransportChannelInfo h245;
    TransportChannelInfo callSignaling;
    CallType callType;
    BandWidth bandWidth;
    CallModel callModel;
#   define InfoRequestResponse_perCallInfo_Seq_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define InfoRequestResponse_perCallInfo_Seq_tokens_present 0x4000
    PInfoRequestResponse_perCallInfo_Seq_tokens tokens;
#   define InfoRequestResponse_perCallInfo_Seq_cryptoTokens_present 0x2000
    PInfoRequestResponse_perCallInfo_Seq_cryptoTokens cryptoTokens;
#   define substituteConfIDs_present 0x1000
    PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs substituteConfIDs;
#   define pdu_present 0x800
    PInfoRequestResponse_perCallInfo_Seq_pdu pdu;
} InfoRequestResponse_perCallInfo_Seq;

typedef struct InfoRequestResponse_perCallInfo {
    PInfoRequestResponse_perCallInfo next;
    InfoRequestResponse_perCallInfo_Seq value;
} InfoRequestResponse_perCallInfo_Element;

typedef struct InfoRequestResponse_callSignalAddress {
    PInfoRequestResponse_callSignalAddress next;
    TransportAddress value;
} InfoRequestResponse_callSignalAddress_Element;

typedef struct AdmissionReject_callSignalAddress {
    PAdmissionReject_callSignalAddress next;
    TransportAddress value;
} AdmissionReject_callSignalAddress_Element;

typedef struct UnregistrationRequest_callSignalAddress {
    PUnregistrationRequest_callSignalAddress next;
    TransportAddress value;
} UnregistrationRequest_callSignalAddress_Element;

typedef struct RegistrationConfirm_alternateGatekeeper {
    PRegistrationConfirm_alternateGatekeeper next;
    AlternateGK value;
} RegistrationConfirm_alternateGatekeeper_Element;

typedef struct RegistrationConfirm_callSignalAddress {
    PRegistrationConfirm_callSignalAddress next;
    TransportAddress value;
} RegistrationConfirm_callSignalAddress_Element;

typedef struct RegistrationRequest_rasAddress {
    PRegistrationRequest_rasAddress next;
    TransportAddress value;
} RegistrationRequest_rasAddress_Element;

typedef struct RegistrationRequest_callSignalAddress {
    PRegistrationRequest_callSignalAddress next;
    TransportAddress value;
} RegistrationRequest_callSignalAddress_Element;

typedef struct GatekeeperConfirm_alternateGatekeeper {
    PGatekeeperConfirm_alternateGatekeeper next;
    AlternateGK value;
} GatekeeperConfirm_alternateGatekeeper_Element;

typedef struct AltGKInfo_alternateGatekeeper {
    PAltGKInfo_alternateGatekeeper next;
    AlternateGK value;
} AltGKInfo_alternateGatekeeper_Element;

typedef struct Endpoint_rasAddress {
    PEndpoint_rasAddress next;
    TransportAddress value;
} Endpoint_rasAddress_Element;

typedef struct Endpoint_callSignalAddress {
    PEndpoint_callSignalAddress next;
    TransportAddress value;
} Endpoint_callSignalAddress_Element;

typedef struct EndpointType {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define EndpointType_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define vendor_present 0x40
    VendorIdentifier vendor;
#   define gatekeeper_present 0x20
    GatekeeperInfo gatekeeper;
#   define gateway_present 0x10
    GatewayInfo gateway;
#   define mcu_present 0x8
    McuInfo mcu;
#   define terminal_present 0x4
    TerminalInfo terminal;
    ASN1bool_t mc;
    ASN1bool_t undefinedNode;
} EndpointType;

typedef struct SupportedProtocols {
    ASN1choice_t choice;
    union {
#	define nonStandardData_chosen 1
	H225NonStandardParameter nonStandardData;
#	define h310_chosen 2
	H310Caps h310;
#	define h320_chosen 3
	H320Caps h320;
#	define h321_chosen 4
	H321Caps h321;
#	define h322_chosen 5
	H322Caps h322;
#	define h323_chosen 6
	H323Caps h323;
#	define h324_chosen 7
	H324Caps h324;
#	define voice_chosen 8
	VoiceCaps voice;
#	define t120_only_chosen 9
	T120OnlyCaps t120_only;
#	define nonStandardProtocol_chosen 10
	NonStandardProtocol nonStandardProtocol;
    } u;
} SupportedProtocols;

typedef struct AliasAddress {
    ASN1choice_t choice;
    union {
#	define e164_chosen 1
	ASN1char_t e164[129];
#	define h323_ID_chosen 2
	ASN1char16string_t h323_ID;
#	define url_ID_chosen 3
	ASN1char_t url_ID[513];
#	define transportID_chosen 4
	TransportAddress transportID;
#	define email_ID_chosen 5
	ASN1char_t email_ID[513];
#	define partyNumber_chosen 6
	PartyNumber partyNumber;
    } u;
} AliasAddress;

typedef struct Endpoint {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define Endpoint_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define aliasAddress_present 0x40
    PEndpoint_aliasAddress aliasAddress;
#   define Endpoint_callSignalAddress_present 0x20
    PEndpoint_callSignalAddress callSignalAddress;
#   define rasAddress_present 0x10
    PEndpoint_rasAddress rasAddress;
#   define endpointType_present 0x8
    EndpointType endpointType;
#   define Endpoint_tokens_present 0x4
    PEndpoint_tokens tokens;
#   define Endpoint_cryptoTokens_present 0x2
    PEndpoint_cryptoTokens cryptoTokens;
#   define priority_present 0x1
    ASN1uint16_t priority;
#   define Endpoint_remoteExtensionAddress_present 0x8000
    PEndpoint_remoteExtensionAddress remoteExtensionAddress;
#   define Endpoint_destExtraCallInfo_present 0x4000
    PEndpoint_destExtraCallInfo destExtraCallInfo;
} Endpoint;

typedef struct SupportedPrefix {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define SupportedPrefix_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    AliasAddress prefix;
} SupportedPrefix;

typedef struct GatekeeperRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define GatekeeperRequest_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    TransportAddress rasAddress;
    EndpointType endpointType;
#   define GatekeeperRequest_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
#   define GatekeeperRequest_callServices_present 0x20
    QseriesOptions callServices;
#   define GatekeeperRequest_endpointAlias_present 0x10
    PGatekeeperRequest_endpointAlias endpointAlias;
#   define GatekeeperRequest_alternateEndpoints_present 0x8000
    PGatekeeperRequest_alternateEndpoints alternateEndpoints;
#   define GatekeeperRequest_tokens_present 0x4000
    PGatekeeperRequest_tokens tokens;
#   define GatekeeperRequest_cryptoTokens_present 0x2000
    PGatekeeperRequest_cryptoTokens cryptoTokens;
#   define GatekeeperRequest_authenticationCapability_present 0x1000
    PGatekeeperRequest_authenticationCapability authenticationCapability;
#   define algorithmOIDs_present 0x800
    PGatekeeperRequest_algorithmOIDs algorithmOIDs;
#   define GatekeeperRequest_integrity_present 0x400
    PGatekeeperRequest_integrity integrity;
#   define GatekeeperRequest_integrityCheckValue_present 0x200
    ICV integrityCheckValue;
} GatekeeperRequest;

typedef struct RegistrationRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define RegistrationRequest_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    ASN1bool_t discoveryComplete;
    PRegistrationRequest_callSignalAddress callSignalAddress;
    PRegistrationRequest_rasAddress rasAddress;
    EndpointType terminalType;
#   define RegistrationRequest_terminalAlias_present 0x40
    PRegistrationRequest_terminalAlias terminalAlias;
#   define RegistrationRequest_gatekeeperIdentifier_present 0x20
    GatekeeperIdentifier gatekeeperIdentifier;
    VendorIdentifier endpointVendor;
#   define RegistrationRequest_alternateEndpoints_present 0x8000
    PRegistrationRequest_alternateEndpoints alternateEndpoints;
#   define RegistrationRequest_timeToLive_present 0x4000
    TimeToLive timeToLive;
#   define RegistrationRequest_tokens_present 0x2000
    PRegistrationRequest_tokens tokens;
#   define RegistrationRequest_cryptoTokens_present 0x1000
    PRegistrationRequest_cryptoTokens cryptoTokens;
#   define RegistrationRequest_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
#   define keepAlive_present 0x400
    ASN1bool_t keepAlive;
#   define RegistrationRequest_endpointIdentifier_present 0x200
    EndpointIdentifier endpointIdentifier;
#   define RegistrationRequest_willSupplyUUIEs_present 0x100
    ASN1bool_t willSupplyUUIEs;
} RegistrationRequest;

typedef struct AdmissionConfirm {
    union {
	ASN1uint32_t bit_mask;
	ASN1octet_t o[3];
    };
    RequestSeqNum requestSeqNum;
    BandWidth bandWidth;
    CallModel callModel;
    TransportAddress destCallSignalAddress;
#   define irrFrequency_present 0x80
    ASN1uint16_t irrFrequency;
#   define AdmissionConfirm_nonStandardData_present 0x40
    H225NonStandardParameter nonStandardData;
#   define AdmissionConfirm_destinationInfo_present 0x8000
    PAdmissionConfirm_destinationInfo destinationInfo;
#   define AdmissionConfirm_destExtraCallInfo_present 0x4000
    PAdmissionConfirm_destExtraCallInfo destExtraCallInfo;
#   define AdmissionConfirm_destinationType_present 0x2000
    EndpointType destinationType;
#   define AdmissionConfirm_remoteExtensionAddress_present 0x1000
    PAdmissionConfirm_remoteExtensionAddress remoteExtensionAddress;
#   define AdmissionConfirm_alternateEndpoints_present 0x800
    PAdmissionConfirm_alternateEndpoints alternateEndpoints;
#   define AdmissionConfirm_tokens_present 0x400
    PAdmissionConfirm_tokens tokens;
#   define AdmissionConfirm_cryptoTokens_present 0x200
    PAdmissionConfirm_cryptoTokens cryptoTokens;
#   define AdmissionConfirm_integrityCheckValue_present 0x100
    ICV integrityCheckValue;
#   define AdmissionConfirm_transportQOS_present 0x800000
    TransportQOS transportQOS;
#   define AdmissionConfirm_willRespondToIRR_present 0x400000
    ASN1bool_t willRespondToIRR;
#   define AdmissionConfirm_uuiesRequested_present 0x200000
    UUIEsRequested uuiesRequested;
} AdmissionConfirm;

typedef struct LocationConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    TransportAddress callSignalAddress;
    TransportAddress rasAddress;
#   define LocationConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define LocationConfirm_destinationInfo_present 0x8000
    PLocationConfirm_destinationInfo destinationInfo;
#   define LocationConfirm_destExtraCallInfo_present 0x4000
    PLocationConfirm_destExtraCallInfo destExtraCallInfo;
#   define LocationConfirm_destinationType_present 0x2000
    EndpointType destinationType;
#   define LocationConfirm_remoteExtensionAddress_present 0x1000
    PLocationConfirm_remoteExtensionAddress remoteExtensionAddress;
#   define LocationConfirm_alternateEndpoints_present 0x800
    PLocationConfirm_alternateEndpoints alternateEndpoints;
#   define LocationConfirm_tokens_present 0x400
    PLocationConfirm_tokens tokens;
#   define LocationConfirm_cryptoTokens_present 0x200
    PLocationConfirm_cryptoTokens cryptoTokens;
#   define LocationConfirm_integrityCheckValue_present 0x100
    ICV integrityCheckValue;
} LocationConfirm;

typedef struct InfoRequestResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define InfoRequestResponse_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    RequestSeqNum requestSeqNum;
    EndpointType endpointType;
    EndpointIdentifier endpointIdentifier;
    TransportAddress rasAddress;
    PInfoRequestResponse_callSignalAddress callSignalAddress;
#   define InfoRequestResponse_endpointAlias_present 0x40
    PInfoRequestResponse_endpointAlias endpointAlias;
#   define perCallInfo_present 0x20
    PInfoRequestResponse_perCallInfo perCallInfo;
#   define InfoRequestResponse_tokens_present 0x8000
    PInfoRequestResponse_tokens tokens;
#   define InfoRequestResponse_cryptoTokens_present 0x4000
    PInfoRequestResponse_cryptoTokens cryptoTokens;
#   define InfoRequestResponse_integrityCheckValue_present 0x2000
    ICV integrityCheckValue;
#   define needResponse_present 0x1000
    ASN1bool_t needResponse;
} InfoRequestResponse;

typedef struct ResourcesAvailableIndicate_protocols {
    PResourcesAvailableIndicate_protocols next;
    SupportedProtocols value;
} ResourcesAvailableIndicate_protocols_Element;

typedef struct InfoRequestResponse_endpointAlias {
    PInfoRequestResponse_endpointAlias next;
    AliasAddress value;
} InfoRequestResponse_endpointAlias_Element;

typedef struct LocationConfirm_alternateEndpoints {
    PLocationConfirm_alternateEndpoints next;
    Endpoint value;
} LocationConfirm_alternateEndpoints_Element;

typedef struct LocationConfirm_remoteExtensionAddress {
    PLocationConfirm_remoteExtensionAddress next;
    AliasAddress value;
} LocationConfirm_remoteExtensionAddress_Element;

typedef struct LocationConfirm_destExtraCallInfo {
    PLocationConfirm_destExtraCallInfo next;
    AliasAddress value;
} LocationConfirm_destExtraCallInfo_Element;

typedef struct LocationConfirm_destinationInfo {
    PLocationConfirm_destinationInfo next;
    AliasAddress value;
} LocationConfirm_destinationInfo_Element;

typedef struct LocationRequest_sourceInfo {
    PLocationRequest_sourceInfo next;
    AliasAddress value;
} LocationRequest_sourceInfo_Element;

typedef struct LocationRequest_destinationInfo {
    PLocationRequest_destinationInfo next;
    AliasAddress value;
} LocationRequest_destinationInfo_Element;

typedef struct AdmissionConfirm_alternateEndpoints {
    PAdmissionConfirm_alternateEndpoints next;
    Endpoint value;
} AdmissionConfirm_alternateEndpoints_Element;

typedef struct AdmissionConfirm_remoteExtensionAddress {
    PAdmissionConfirm_remoteExtensionAddress next;
    AliasAddress value;
} AdmissionConfirm_remoteExtensionAddress_Element;

typedef struct AdmissionConfirm_destExtraCallInfo {
    PAdmissionConfirm_destExtraCallInfo next;
    AliasAddress value;
} AdmissionConfirm_destExtraCallInfo_Element;

typedef struct AdmissionConfirm_destinationInfo {
    PAdmissionConfirm_destinationInfo next;
    AliasAddress value;
} AdmissionConfirm_destinationInfo_Element;

typedef struct AdmissionRequest_destAlternatives {
    PAdmissionRequest_destAlternatives next;
    Endpoint value;
} AdmissionRequest_destAlternatives_Element;

typedef struct AdmissionRequest_srcAlternatives {
    PAdmissionRequest_srcAlternatives next;
    Endpoint value;
} AdmissionRequest_srcAlternatives_Element;

typedef struct AdmissionRequest_srcInfo {
    PAdmissionRequest_srcInfo next;
    AliasAddress value;
} AdmissionRequest_srcInfo_Element;

typedef struct AdmissionRequest_destExtraCallInfo {
    PAdmissionRequest_destExtraCallInfo next;
    AliasAddress value;
} AdmissionRequest_destExtraCallInfo_Element;

typedef struct AdmissionRequest_destinationInfo {
    PAdmissionRequest_destinationInfo next;
    AliasAddress value;
} AdmissionRequest_destinationInfo_Element;

typedef struct UnregistrationRequest_alternateEndpoints {
    PUnregistrationRequest_alternateEndpoints next;
    Endpoint value;
} UnregistrationRequest_alternateEndpoints_Element;

typedef struct UnregistrationRequest_endpointAlias {
    PUnregistrationRequest_endpointAlias next;
    AliasAddress value;
} UnregistrationRequest_endpointAlias_Element;

typedef struct RegistrationRejectReason_duplicateAlias {
    PRegistrationRejectReason_duplicateAlias next;
    AliasAddress value;
} RegistrationRejectReason_duplicateAlias_Element;

typedef struct RegistrationConfirm_terminalAlias {
    PRegistrationConfirm_terminalAlias next;
    AliasAddress value;
} RegistrationConfirm_terminalAlias_Element;

typedef struct RegistrationRequest_alternateEndpoints {
    PRegistrationRequest_alternateEndpoints next;
    Endpoint value;
} RegistrationRequest_alternateEndpoints_Element;

typedef struct RegistrationRequest_terminalAlias {
    PRegistrationRequest_terminalAlias next;
    AliasAddress value;
} RegistrationRequest_terminalAlias_Element;

typedef struct GatekeeperRequest_alternateEndpoints {
    PGatekeeperRequest_alternateEndpoints next;
    Endpoint value;
} GatekeeperRequest_alternateEndpoints_Element;

typedef struct GatekeeperRequest_endpointAlias {
    PGatekeeperRequest_endpointAlias next;
    AliasAddress value;
} GatekeeperRequest_endpointAlias_Element;

typedef struct CryptoH323Token_cryptoEPPwdHash {
    AliasAddress alias;
    TimeStamp timeStamp;
    HASHED token;
} CryptoH323Token_cryptoEPPwdHash;

typedef struct Endpoint_destExtraCallInfo {
    PEndpoint_destExtraCallInfo next;
    AliasAddress value;
} Endpoint_destExtraCallInfo_Element;

typedef struct Endpoint_remoteExtensionAddress {
    PEndpoint_remoteExtensionAddress next;
    AliasAddress value;
} Endpoint_remoteExtensionAddress_Element;

typedef struct Endpoint_aliasAddress {
    PEndpoint_aliasAddress next;
    AliasAddress value;
} Endpoint_aliasAddress_Element;

typedef struct NonStandardProtocol_supportedPrefixes {
    PNonStandardProtocol_supportedPrefixes next;
    SupportedPrefix value;
} NonStandardProtocol_supportedPrefixes_Element;

typedef struct T120OnlyCaps_supportedPrefixes {
    PT120OnlyCaps_supportedPrefixes next;
    SupportedPrefix value;
} T120OnlyCaps_supportedPrefixes_Element;

typedef struct VoiceCaps_supportedPrefixes {
    PVoiceCaps_supportedPrefixes next;
    SupportedPrefix value;
} VoiceCaps_supportedPrefixes_Element;

typedef struct H324Caps_supportedPrefixes {
    PH324Caps_supportedPrefixes next;
    SupportedPrefix value;
} H324Caps_supportedPrefixes_Element;

typedef struct H323Caps_supportedPrefixes {
    PH323Caps_supportedPrefixes next;
    SupportedPrefix value;
} H323Caps_supportedPrefixes_Element;

typedef struct H322Caps_supportedPrefixes {
    PH322Caps_supportedPrefixes next;
    SupportedPrefix value;
} H322Caps_supportedPrefixes_Element;

typedef struct H321Caps_supportedPrefixes {
    PH321Caps_supportedPrefixes next;
    SupportedPrefix value;
} H321Caps_supportedPrefixes_Element;

typedef struct H320Caps_supportedPrefixes {
    PH320Caps_supportedPrefixes next;
    SupportedPrefix value;
} H320Caps_supportedPrefixes_Element;

typedef struct H310Caps_supportedPrefixes {
    PH310Caps_supportedPrefixes next;
    SupportedPrefix value;
} H310Caps_supportedPrefixes_Element;

typedef struct GatewayInfo_protocol {
    PGatewayInfo_protocol next;
    SupportedProtocols value;
} GatewayInfo_protocol_Element;

typedef struct Facility_UUIE_destExtraCallInfo {
    PFacility_UUIE_destExtraCallInfo next;
    AliasAddress value;
} Facility_UUIE_destExtraCallInfo_Element;

typedef struct Facility_UUIE_alternativeAliasAddress {
    PFacility_UUIE_alternativeAliasAddress next;
    AliasAddress value;
} Facility_UUIE_alternativeAliasAddress_Element;

typedef struct Setup_UUIE_destExtraCallInfo {
    PSetup_UUIE_destExtraCallInfo next;
    AliasAddress value;
} Setup_UUIE_destExtraCallInfo_Element;

typedef struct Setup_UUIE_destinationAddress {
    PSetup_UUIE_destinationAddress next;
    AliasAddress value;
} Setup_UUIE_destinationAddress_Element;

typedef struct Setup_UUIE_sourceAddress {
    PSetup_UUIE_sourceAddress next;
    AliasAddress value;
} Setup_UUIE_sourceAddress_Element;

typedef struct Alerting_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ProtocolIdentifier protocolIdentifier;
    EndpointType destinationInfo;
#   define Alerting_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
#   define Alerting_UUIE_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define Alerting_UUIE_h245SecurityMode_present 0x4000
    H245Security h245SecurityMode;
#   define Alerting_UUIE_tokens_present 0x2000
    PAlerting_UUIE_tokens tokens;
#   define Alerting_UUIE_cryptoTokens_present 0x1000
    PAlerting_UUIE_cryptoTokens cryptoTokens;
#   define Alerting_UUIE_fastStart_present 0x800
    PAlerting_UUIE_fastStart fastStart;
} Alerting_UUIE;

typedef struct CallProceeding_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ProtocolIdentifier protocolIdentifier;
    EndpointType destinationInfo;
#   define CallProceeding_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
#   define CallProceeding_UUIE_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define CallProceeding_UUIE_h245SecurityMode_present 0x4000
    H245Security h245SecurityMode;
#   define CallProceeding_UUIE_tokens_present 0x2000
    PCallProceeding_UUIE_tokens tokens;
#   define CallProceeding_UUIE_cryptoTokens_present 0x1000
    PCallProceeding_UUIE_cryptoTokens cryptoTokens;
#   define CallProceeding_UUIE_fastStart_present 0x800
    PCallProceeding_UUIE_fastStart fastStart;
} CallProceeding_UUIE;

typedef struct Connect_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ProtocolIdentifier protocolIdentifier;
#   define Connect_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
    EndpointType destinationInfo;
    ConferenceIdentifier conferenceID;
#   define Connect_UUIE_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define Connect_UUIE_h245SecurityMode_present 0x4000
    H245Security h245SecurityMode;
#   define Connect_UUIE_tokens_present 0x2000
    PConnect_UUIE_tokens tokens;
#   define Connect_UUIE_cryptoTokens_present 0x1000
    PConnect_UUIE_cryptoTokens cryptoTokens;
#   define Connect_UUIE_fastStart_present 0x800
    PConnect_UUIE_fastStart fastStart;
} Connect_UUIE;

typedef struct Setup_UUIE {
    union {
	ASN1uint32_t bit_mask;
	ASN1octet_t o[3];
    };
    ProtocolIdentifier protocolIdentifier;
#   define Setup_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
#   define sourceAddress_present 0x40
    PSetup_UUIE_sourceAddress sourceAddress;
    EndpointType sourceInfo;
#   define destinationAddress_present 0x20
    PSetup_UUIE_destinationAddress destinationAddress;
#   define Setup_UUIE_destCallSignalAddress_present 0x10
    TransportAddress destCallSignalAddress;
#   define Setup_UUIE_destExtraCallInfo_present 0x8
    PSetup_UUIE_destExtraCallInfo destExtraCallInfo;
#   define destExtraCRV_present 0x4
    PSetup_UUIE_destExtraCRV destExtraCRV;
    ASN1bool_t activeMC;
    ConferenceIdentifier conferenceID;
    Setup_UUIE_conferenceGoal conferenceGoal;
#   define Setup_UUIE_callServices_present 0x2
    QseriesOptions callServices;
    CallType callType;
#   define sourceCallSignalAddress_present 0x8000
    TransportAddress sourceCallSignalAddress;
#   define Setup_UUIE_remoteExtensionAddress_present 0x4000
    AliasAddress remoteExtensionAddress;
#   define Setup_UUIE_callIdentifier_present 0x2000
    CallIdentifier callIdentifier;
#   define h245SecurityCapability_present 0x1000
    PSetup_UUIE_h245SecurityCapability h245SecurityCapability;
#   define Setup_UUIE_tokens_present 0x800
    PSetup_UUIE_tokens tokens;
#   define Setup_UUIE_cryptoTokens_present 0x400
    PSetup_UUIE_cryptoTokens cryptoTokens;
#   define Setup_UUIE_fastStart_present 0x200
    PSetup_UUIE_fastStart fastStart;
#   define mediaWaitForConnect_present 0x100
    ASN1bool_t mediaWaitForConnect;
#   define canOverlapSend_present 0x800000
    ASN1bool_t canOverlapSend;
} Setup_UUIE;

typedef struct Facility_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ProtocolIdentifier protocolIdentifier;
#   define alternativeAddress_present 0x80
    TransportAddress alternativeAddress;
#   define alternativeAliasAddress_present 0x40
    PFacility_UUIE_alternativeAliasAddress alternativeAliasAddress;
#   define Facility_UUIE_conferenceID_present 0x20
    ConferenceIdentifier conferenceID;
    FacilityReason reason;
#   define Facility_UUIE_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define Facility_UUIE_destExtraCallInfo_present 0x4000
    PFacility_UUIE_destExtraCallInfo destExtraCallInfo;
#   define Facility_UUIE_remoteExtensionAddress_present 0x2000
    AliasAddress remoteExtensionAddress;
#   define Facility_UUIE_tokens_present 0x1000
    PFacility_UUIE_tokens tokens;
#   define Facility_UUIE_cryptoTokens_present 0x800
    PFacility_UUIE_cryptoTokens cryptoTokens;
#   define conferences_present 0x400
    PFacility_UUIE_conferences conferences;
#   define Facility_UUIE_h245Address_present 0x200
    TransportAddress h245Address;
#   define Facility_UUIE_fastStart_present 0x100
    PFacility_UUIE_fastStart fastStart;
} Facility_UUIE;

typedef struct ConferenceList {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ConferenceList_conferenceID_present 0x80
    ConferenceIdentifier conferenceID;
#   define conferenceAlias_present 0x40
    AliasAddress conferenceAlias;
#   define ConferenceList_nonStandardData_present 0x20
    H225NonStandardParameter nonStandardData;
} ConferenceList;

typedef struct Progress_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ProtocolIdentifier protocolIdentifier;
    EndpointType destinationInfo;
#   define Progress_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
    CallIdentifier callIdentifier;
#   define Progress_UUIE_h245SecurityMode_present 0x40
    H245Security h245SecurityMode;
#   define Progress_UUIE_tokens_present 0x20
    PProgress_UUIE_tokens tokens;
#   define Progress_UUIE_cryptoTokens_present 0x10
    PProgress_UUIE_cryptoTokens cryptoTokens;
#   define Progress_UUIE_fastStart_present 0x8
    PProgress_UUIE_fastStart fastStart;
} Progress_UUIE;

typedef struct CryptoH323Token {
    ASN1choice_t choice;
    union {
#	define cryptoEPPwdHash_chosen 1
	CryptoH323Token_cryptoEPPwdHash cryptoEPPwdHash;
#	define cryptoGKPwdHash_chosen 2
	CryptoH323Token_cryptoGKPwdHash cryptoGKPwdHash;
#	define cryptoEPPwdEncr_chosen 3
	ENCRYPTED cryptoEPPwdEncr;
#	define cryptoGKPwdEncr_chosen 4
	ENCRYPTED cryptoGKPwdEncr;
#	define cryptoEPCert_chosen 5
	SIGNED_EncodedPwdCertToken cryptoEPCert;
#	define cryptoGKCert_chosen 6
	SIGNED_EncodedPwdCertToken cryptoGKCert;
#	define cryptoFastStart_chosen 7
	SIGNED_EncodedFastStartToken cryptoFastStart;
#	define nestedcryptoToken_chosen 8
	CryptoToken nestedcryptoToken;
    } u;
} CryptoH323Token;

typedef struct RasMessage {
    ASN1choice_t choice;
    union {
#	define gatekeeperRequest_chosen 1
	GatekeeperRequest gatekeeperRequest;
#	define gatekeeperConfirm_chosen 2
	GatekeeperConfirm gatekeeperConfirm;
#	define gatekeeperReject_chosen 3
	GatekeeperReject gatekeeperReject;
#	define registrationRequest_chosen 4
	RegistrationRequest registrationRequest;
#	define registrationConfirm_chosen 5
	RegistrationConfirm registrationConfirm;
#	define registrationReject_chosen 6
	RegistrationReject registrationReject;
#	define unregistrationRequest_chosen 7
	UnregistrationRequest unregistrationRequest;
#	define unregistrationConfirm_chosen 8
	UnregistrationConfirm unregistrationConfirm;
#	define unregistrationReject_chosen 9
	UnregistrationReject unregistrationReject;
#	define admissionRequest_chosen 10
	AdmissionRequest admissionRequest;
#	define admissionConfirm_chosen 11
	AdmissionConfirm admissionConfirm;
#	define admissionReject_chosen 12
	AdmissionReject admissionReject;
#	define bandwidthRequest_chosen 13
	BandwidthRequest bandwidthRequest;
#	define bandwidthConfirm_chosen 14
	BandwidthConfirm bandwidthConfirm;
#	define bandwidthReject_chosen 15
	BandwidthReject bandwidthReject;
#	define disengageRequest_chosen 16
	DisengageRequest disengageRequest;
#	define disengageConfirm_chosen 17
	DisengageConfirm disengageConfirm;
#	define disengageReject_chosen 18
	DisengageReject disengageReject;
#	define locationRequest_chosen 19
	LocationRequest locationRequest;
#	define locationConfirm_chosen 20
	LocationConfirm locationConfirm;
#	define locationReject_chosen 21
	LocationReject locationReject;
#	define infoRequest_chosen 22
	InfoRequest infoRequest;
#	define infoRequestResponse_chosen 23
	InfoRequestResponse infoRequestResponse;
#	define nonStandardMessage_chosen 24
	H225NonStandardMessage nonStandardMessage;
#	define unknownMessageResponse_chosen 25
	UnknownMessageResponse unknownMessageResponse;
#	define requestInProgress_chosen 26
	RequestInProgress requestInProgress;
#	define resourcesAvailableIndicate_chosen 27
	ResourcesAvailableIndicate resourcesAvailableIndicate;
#	define resourcesAvailableConfirm_chosen 28
	ResourcesAvailableConfirm resourcesAvailableConfirm;
#	define infoRequestAck_chosen 29
	InfoRequestAck infoRequestAck;
#	define infoRequestNak_chosen 30
	InfoRequestNak infoRequestNak;
    } u;
} RasMessage;
#define RasMessage_PDU 0
#define SIZE_H225ASN_Module_PDU_0 sizeof(RasMessage)

typedef struct InfoRequestResponse_perCallInfo_Seq_cryptoTokens {
    PInfoRequestResponse_perCallInfo_Seq_cryptoTokens next;
    CryptoH323Token value;
} InfoRequestResponse_perCallInfo_Seq_cryptoTokens_Element;

typedef struct ResourcesAvailableConfirm_cryptoTokens {
    PResourcesAvailableConfirm_cryptoTokens next;
    CryptoH323Token value;
} ResourcesAvailableConfirm_cryptoTokens_Element;

typedef struct ResourcesAvailableIndicate_cryptoTokens {
    PResourcesAvailableIndicate_cryptoTokens next;
    CryptoH323Token value;
} ResourcesAvailableIndicate_cryptoTokens_Element;

typedef struct RequestInProgress_cryptoTokens {
    PRequestInProgress_cryptoTokens next;
    CryptoH323Token value;
} RequestInProgress_cryptoTokens_Element;

typedef struct UnknownMessageResponse_cryptoTokens {
    PUnknownMessageResponse_cryptoTokens next;
    CryptoH323Token value;
} UnknownMessageResponse_cryptoTokens_Element;

typedef struct H225NonStandardMessage_cryptoTokens {
    PH225NonStandardMessage_cryptoTokens next;
    CryptoH323Token value;
} H225NonStandardMessage_cryptoTokens_Element;

typedef struct InfoRequestNak_cryptoTokens {
    PInfoRequestNak_cryptoTokens next;
    CryptoH323Token value;
} InfoRequestNak_cryptoTokens_Element;

typedef struct InfoRequestAck_cryptoTokens {
    PInfoRequestAck_cryptoTokens next;
    CryptoH323Token value;
} InfoRequestAck_cryptoTokens_Element;

typedef struct InfoRequestResponse_cryptoTokens {
    PInfoRequestResponse_cryptoTokens next;
    CryptoH323Token value;
} InfoRequestResponse_cryptoTokens_Element;

typedef struct InfoRequest_cryptoTokens {
    PInfoRequest_cryptoTokens next;
    CryptoH323Token value;
} InfoRequest_cryptoTokens_Element;

typedef struct DisengageReject_cryptoTokens {
    PDisengageReject_cryptoTokens next;
    CryptoH323Token value;
} DisengageReject_cryptoTokens_Element;

typedef struct DisengageConfirm_cryptoTokens {
    PDisengageConfirm_cryptoTokens next;
    CryptoH323Token value;
} DisengageConfirm_cryptoTokens_Element;

typedef struct DisengageRequest_cryptoTokens {
    PDisengageRequest_cryptoTokens next;
    CryptoH323Token value;
} DisengageRequest_cryptoTokens_Element;

typedef struct LocationReject_cryptoTokens {
    PLocationReject_cryptoTokens next;
    CryptoH323Token value;
} LocationReject_cryptoTokens_Element;

typedef struct LocationConfirm_cryptoTokens {
    PLocationConfirm_cryptoTokens next;
    CryptoH323Token value;
} LocationConfirm_cryptoTokens_Element;

typedef struct LocationRequest_cryptoTokens {
    PLocationRequest_cryptoTokens next;
    CryptoH323Token value;
} LocationRequest_cryptoTokens_Element;

typedef struct BandwidthReject_cryptoTokens {
    PBandwidthReject_cryptoTokens next;
    CryptoH323Token value;
} BandwidthReject_cryptoTokens_Element;

typedef struct BandwidthConfirm_cryptoTokens {
    PBandwidthConfirm_cryptoTokens next;
    CryptoH323Token value;
} BandwidthConfirm_cryptoTokens_Element;

typedef struct BandwidthRequest_cryptoTokens {
    PBandwidthRequest_cryptoTokens next;
    CryptoH323Token value;
} BandwidthRequest_cryptoTokens_Element;

typedef struct AdmissionReject_cryptoTokens {
    PAdmissionReject_cryptoTokens next;
    CryptoH323Token value;
} AdmissionReject_cryptoTokens_Element;

typedef struct AdmissionConfirm_cryptoTokens {
    PAdmissionConfirm_cryptoTokens next;
    CryptoH323Token value;
} AdmissionConfirm_cryptoTokens_Element;

typedef struct AdmissionRequest_cryptoTokens {
    PAdmissionRequest_cryptoTokens next;
    CryptoH323Token value;
} AdmissionRequest_cryptoTokens_Element;

typedef struct UnregistrationReject_cryptoTokens {
    PUnregistrationReject_cryptoTokens next;
    CryptoH323Token value;
} UnregistrationReject_cryptoTokens_Element;

typedef struct UnregistrationConfirm_cryptoTokens {
    PUnregistrationConfirm_cryptoTokens next;
    CryptoH323Token value;
} UnregistrationConfirm_cryptoTokens_Element;

typedef struct UnregistrationRequest_cryptoTokens {
    PUnregistrationRequest_cryptoTokens next;
    CryptoH323Token value;
} UnregistrationRequest_cryptoTokens_Element;

typedef struct RegistrationReject_cryptoTokens {
    PRegistrationReject_cryptoTokens next;
    CryptoH323Token value;
} RegistrationReject_cryptoTokens_Element;

typedef struct RegistrationConfirm_cryptoTokens {
    PRegistrationConfirm_cryptoTokens next;
    CryptoH323Token value;
} RegistrationConfirm_cryptoTokens_Element;

typedef struct RegistrationRequest_cryptoTokens {
    PRegistrationRequest_cryptoTokens next;
    CryptoH323Token value;
} RegistrationRequest_cryptoTokens_Element;

typedef struct GatekeeperReject_cryptoTokens {
    PGatekeeperReject_cryptoTokens next;
    CryptoH323Token value;
} GatekeeperReject_cryptoTokens_Element;

typedef struct GatekeeperConfirm_cryptoTokens {
    PGatekeeperConfirm_cryptoTokens next;
    CryptoH323Token value;
} GatekeeperConfirm_cryptoTokens_Element;

typedef struct GatekeeperRequest_cryptoTokens {
    PGatekeeperRequest_cryptoTokens next;
    CryptoH323Token value;
} GatekeeperRequest_cryptoTokens_Element;

typedef struct Endpoint_cryptoTokens {
    PEndpoint_cryptoTokens next;
    CryptoH323Token value;
} Endpoint_cryptoTokens_Element;

typedef struct Progress_UUIE_cryptoTokens {
    PProgress_UUIE_cryptoTokens next;
    CryptoH323Token value;
} Progress_UUIE_cryptoTokens_Element;

typedef struct Facility_UUIE_conferences {
    PFacility_UUIE_conferences next;
    ConferenceList value;
} Facility_UUIE_conferences_Element;

typedef struct Facility_UUIE_cryptoTokens {
    PFacility_UUIE_cryptoTokens next;
    CryptoH323Token value;
} Facility_UUIE_cryptoTokens_Element;

typedef struct Setup_UUIE_cryptoTokens {
    PSetup_UUIE_cryptoTokens next;
    CryptoH323Token value;
} Setup_UUIE_cryptoTokens_Element;

typedef struct Connect_UUIE_cryptoTokens {
    PConnect_UUIE_cryptoTokens next;
    CryptoH323Token value;
} Connect_UUIE_cryptoTokens_Element;

typedef struct CallProceeding_UUIE_cryptoTokens {
    PCallProceeding_UUIE_cryptoTokens next;
    CryptoH323Token value;
} CallProceeding_UUIE_cryptoTokens_Element;

typedef struct Alerting_UUIE_cryptoTokens {
    PAlerting_UUIE_cryptoTokens next;
    CryptoH323Token value;
} Alerting_UUIE_cryptoTokens_Element;

typedef struct H323_UU_PDU_h323_message_body {
    ASN1choice_t choice;
    union {
#	define setup_chosen 1
	Setup_UUIE setup;
#	define callProceeding_chosen 2
	CallProceeding_UUIE callProceeding;
#	define connect_chosen 3
	Connect_UUIE connect;
#	define alerting_chosen 4
	Alerting_UUIE alerting;
#	define information_chosen 5
	Information_UUIE information;
#	define releaseComplete_chosen 6
	ReleaseComplete_UUIE releaseComplete;
#	define facility_chosen 7
	Facility_UUIE facility;
#	define progress_chosen 8
	Progress_UUIE progress;
#	define empty_chosen 9
    } u;
} H323_UU_PDU_h323_message_body;

typedef struct H323_UU_PDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    H323_UU_PDU_h323_message_body h323_message_body;
#   define H323_UU_PDU_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define h4501SupplementaryService_present 0x8000
    PH323_UU_PDU_h4501SupplementaryService h4501SupplementaryService;
#   define h245Tunneling_present 0x4000
    ASN1bool_t h245Tunneling;
#   define h245Control_present 0x2000
    PH323_UU_PDU_h245Control h245Control;
#   define nonStandardControl_present 0x1000
    PH323_UU_PDU_nonStandardControl nonStandardControl;
} H323_UU_PDU;

typedef struct InfoRequestResponse_perCallInfo_Seq_pdu_Seq {
    H323_UU_PDU h323pdu;
    ASN1bool_t sent;
} InfoRequestResponse_perCallInfo_Seq_pdu_Seq;

typedef struct InfoRequestResponse_perCallInfo_Seq_pdu {
    PInfoRequestResponse_perCallInfo_Seq_pdu next;
    InfoRequestResponse_perCallInfo_Seq_pdu_Seq value;
} InfoRequestResponse_perCallInfo_Seq_pdu_Element;

typedef struct H323_UserInformation {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H323_UU_PDU h323_uu_pdu;
#   define user_data_present 0x80
    H323_UserInformation_user_data user_data;
} H323_UserInformation;
#define H323_UserInformation_PDU 1
#define SIZE_H225ASN_Module_PDU_1 sizeof(H323_UserInformation)


extern ASN1module_t H225ASN_Module;
extern void ASN1CALL H225ASN_Module_Startup(void);
extern void ASN1CALL H225ASN_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val);
    extern int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route val);
	extern void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn(PTransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Enc_RTPSession_associatedSessionIds_ElmFn(ASN1encoding_t enc, PRTPSession_associatedSessionIds val);
    extern int ASN1CALL ASN1Dec_RTPSession_associatedSessionIds_ElmFn(ASN1decoding_t dec, PRTPSession_associatedSessionIds val);
	extern void ASN1CALL ASN1Free_RTPSession_associatedSessionIds_ElmFn(PRTPSession_associatedSessionIds val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_algorithmOIDs_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_algorithmOIDs val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_algorithmOIDs_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_algorithmOIDs val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_algorithmOIDs_ElmFn(PGatekeeperRequest_algorithmOIDs val);
    extern int ASN1CALL ASN1Enc_Progress_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PProgress_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_Progress_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PProgress_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_Progress_UUIE_fastStart_ElmFn(PProgress_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PFacility_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PFacility_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_fastStart_ElmFn(PFacility_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PSetup_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PSetup_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_fastStart_ElmFn(PSetup_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCRV_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destExtraCRV val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCRV_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destExtraCRV val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_destExtraCRV_ElmFn(PSetup_UUIE_destExtraCRV val);
    extern int ASN1CALL ASN1Enc_Connect_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PConnect_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_Connect_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PConnect_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_Connect_UUIE_fastStart_ElmFn(PConnect_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_CallProceeding_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_CallProceeding_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_CallProceeding_UUIE_fastStart_ElmFn(PCallProceeding_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_Alerting_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_Alerting_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_Alerting_UUIE_fastStart_ElmFn(PAlerting_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_H323_UU_PDU_h245Control_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_h245Control val);
    extern int ASN1CALL ASN1Dec_H323_UU_PDU_h245Control_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_h245Control val);
	extern void ASN1CALL ASN1Free_H323_UU_PDU_h245Control_ElmFn(PH323_UU_PDU_h245Control val);
    extern int ASN1CALL ASN1Enc_H323_UU_PDU_h4501SupplementaryService_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_h4501SupplementaryService val);
    extern int ASN1CALL ASN1Dec_H323_UU_PDU_h4501SupplementaryService_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_h4501SupplementaryService val);
	extern void ASN1CALL ASN1Free_H323_UU_PDU_h4501SupplementaryService_ElmFn(PH323_UU_PDU_h4501SupplementaryService val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_tokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_tokens val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(PInfoRequestResponse_perCallInfo_Seq_tokens val);
    extern int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_tokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_tokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableConfirm_tokens val);
	extern void ASN1CALL ASN1Free_ResourcesAvailableConfirm_tokens_ElmFn(PResourcesAvailableConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_tokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_tokens val);
    extern int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_tokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_tokens val);
	extern void ASN1CALL ASN1Free_ResourcesAvailableIndicate_tokens_ElmFn(PResourcesAvailableIndicate_tokens val);
    extern int ASN1CALL ASN1Enc_RequestInProgress_tokens_ElmFn(ASN1encoding_t enc, PRequestInProgress_tokens val);
    extern int ASN1CALL ASN1Dec_RequestInProgress_tokens_ElmFn(ASN1decoding_t dec, PRequestInProgress_tokens val);
	extern void ASN1CALL ASN1Free_RequestInProgress_tokens_ElmFn(PRequestInProgress_tokens val);
    extern int ASN1CALL ASN1Enc_UnknownMessageResponse_tokens_ElmFn(ASN1encoding_t enc, PUnknownMessageResponse_tokens val);
    extern int ASN1CALL ASN1Dec_UnknownMessageResponse_tokens_ElmFn(ASN1decoding_t dec, PUnknownMessageResponse_tokens val);
	extern void ASN1CALL ASN1Free_UnknownMessageResponse_tokens_ElmFn(PUnknownMessageResponse_tokens val);
    extern int ASN1CALL ASN1Enc_H225NonStandardMessage_tokens_ElmFn(ASN1encoding_t enc, PH225NonStandardMessage_tokens val);
    extern int ASN1CALL ASN1Dec_H225NonStandardMessage_tokens_ElmFn(ASN1decoding_t dec, PH225NonStandardMessage_tokens val);
	extern void ASN1CALL ASN1Free_H225NonStandardMessage_tokens_ElmFn(PH225NonStandardMessage_tokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestNak_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestNak_tokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestNak_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestNak_tokens val);
	extern void ASN1CALL ASN1Free_InfoRequestNak_tokens_ElmFn(PInfoRequestNak_tokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestAck_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestAck_tokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestAck_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestAck_tokens val);
	extern void ASN1CALL ASN1Free_InfoRequestAck_tokens_ElmFn(PInfoRequestAck_tokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_tokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_tokens val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_tokens_ElmFn(PInfoRequestResponse_tokens val);
    extern int ASN1CALL ASN1Enc_InfoRequest_tokens_ElmFn(ASN1encoding_t enc, PInfoRequest_tokens val);
    extern int ASN1CALL ASN1Dec_InfoRequest_tokens_ElmFn(ASN1decoding_t dec, PInfoRequest_tokens val);
	extern void ASN1CALL ASN1Free_InfoRequest_tokens_ElmFn(PInfoRequest_tokens val);
    extern int ASN1CALL ASN1Enc_DisengageReject_tokens_ElmFn(ASN1encoding_t enc, PDisengageReject_tokens val);
    extern int ASN1CALL ASN1Dec_DisengageReject_tokens_ElmFn(ASN1decoding_t dec, PDisengageReject_tokens val);
	extern void ASN1CALL ASN1Free_DisengageReject_tokens_ElmFn(PDisengageReject_tokens val);
    extern int ASN1CALL ASN1Enc_DisengageConfirm_tokens_ElmFn(ASN1encoding_t enc, PDisengageConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_DisengageConfirm_tokens_ElmFn(ASN1decoding_t dec, PDisengageConfirm_tokens val);
	extern void ASN1CALL ASN1Free_DisengageConfirm_tokens_ElmFn(PDisengageConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_DisengageRequest_tokens_ElmFn(ASN1encoding_t enc, PDisengageRequest_tokens val);
    extern int ASN1CALL ASN1Dec_DisengageRequest_tokens_ElmFn(ASN1decoding_t dec, PDisengageRequest_tokens val);
	extern void ASN1CALL ASN1Free_DisengageRequest_tokens_ElmFn(PDisengageRequest_tokens val);
    extern int ASN1CALL ASN1Enc_LocationReject_tokens_ElmFn(ASN1encoding_t enc, PLocationReject_tokens val);
    extern int ASN1CALL ASN1Dec_LocationReject_tokens_ElmFn(ASN1decoding_t dec, PLocationReject_tokens val);
	extern void ASN1CALL ASN1Free_LocationReject_tokens_ElmFn(PLocationReject_tokens val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_tokens_ElmFn(ASN1encoding_t enc, PLocationConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_tokens_ElmFn(ASN1decoding_t dec, PLocationConfirm_tokens val);
	extern void ASN1CALL ASN1Free_LocationConfirm_tokens_ElmFn(PLocationConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_LocationRequest_tokens_ElmFn(ASN1encoding_t enc, PLocationRequest_tokens val);
    extern int ASN1CALL ASN1Dec_LocationRequest_tokens_ElmFn(ASN1decoding_t dec, PLocationRequest_tokens val);
	extern void ASN1CALL ASN1Free_LocationRequest_tokens_ElmFn(PLocationRequest_tokens val);
    extern int ASN1CALL ASN1Enc_BandwidthReject_tokens_ElmFn(ASN1encoding_t enc, PBandwidthReject_tokens val);
    extern int ASN1CALL ASN1Dec_BandwidthReject_tokens_ElmFn(ASN1decoding_t dec, PBandwidthReject_tokens val);
	extern void ASN1CALL ASN1Free_BandwidthReject_tokens_ElmFn(PBandwidthReject_tokens val);
    extern int ASN1CALL ASN1Enc_BandwidthConfirm_tokens_ElmFn(ASN1encoding_t enc, PBandwidthConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_BandwidthConfirm_tokens_ElmFn(ASN1decoding_t dec, PBandwidthConfirm_tokens val);
	extern void ASN1CALL ASN1Free_BandwidthConfirm_tokens_ElmFn(PBandwidthConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_BandwidthRequest_tokens_ElmFn(ASN1encoding_t enc, PBandwidthRequest_tokens val);
    extern int ASN1CALL ASN1Dec_BandwidthRequest_tokens_ElmFn(ASN1decoding_t dec, PBandwidthRequest_tokens val);
	extern void ASN1CALL ASN1Free_BandwidthRequest_tokens_ElmFn(PBandwidthRequest_tokens val);
    extern int ASN1CALL ASN1Enc_AdmissionReject_tokens_ElmFn(ASN1encoding_t enc, PAdmissionReject_tokens val);
    extern int ASN1CALL ASN1Dec_AdmissionReject_tokens_ElmFn(ASN1decoding_t dec, PAdmissionReject_tokens val);
	extern void ASN1CALL ASN1Free_AdmissionReject_tokens_ElmFn(PAdmissionReject_tokens val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_tokens_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_tokens_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_tokens val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_tokens_ElmFn(PAdmissionConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_tokens_ElmFn(ASN1encoding_t enc, PAdmissionRequest_tokens val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_tokens_ElmFn(ASN1decoding_t dec, PAdmissionRequest_tokens val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_tokens_ElmFn(PAdmissionRequest_tokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationReject_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationReject_tokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationReject_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationReject_tokens val);
	extern void ASN1CALL ASN1Free_UnregistrationReject_tokens_ElmFn(PUnregistrationReject_tokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationConfirm_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationConfirm_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationConfirm_tokens val);
	extern void ASN1CALL ASN1Free_UnregistrationConfirm_tokens_ElmFn(PUnregistrationConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_tokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_tokens val);
	extern void ASN1CALL ASN1Free_UnregistrationRequest_tokens_ElmFn(PUnregistrationRequest_tokens val);
    extern int ASN1CALL ASN1Enc_RegistrationReject_tokens_ElmFn(ASN1encoding_t enc, PRegistrationReject_tokens val);
    extern int ASN1CALL ASN1Dec_RegistrationReject_tokens_ElmFn(ASN1decoding_t dec, PRegistrationReject_tokens val);
	extern void ASN1CALL ASN1Free_RegistrationReject_tokens_ElmFn(PRegistrationReject_tokens val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_tokens_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_tokens_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_tokens val);
	extern void ASN1CALL ASN1Free_RegistrationConfirm_tokens_ElmFn(PRegistrationConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_tokens_ElmFn(ASN1encoding_t enc, PRegistrationRequest_tokens val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_tokens_ElmFn(ASN1decoding_t dec, PRegistrationRequest_tokens val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_tokens_ElmFn(PRegistrationRequest_tokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperReject_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperReject_tokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperReject_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperReject_tokens val);
	extern void ASN1CALL ASN1Free_GatekeeperReject_tokens_ElmFn(PGatekeeperReject_tokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperConfirm_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperConfirm_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_tokens val);
	extern void ASN1CALL ASN1Free_GatekeeperConfirm_tokens_ElmFn(PGatekeeperConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_authenticationCapability_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_authenticationCapability val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_authenticationCapability_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_authenticationCapability val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_authenticationCapability_ElmFn(PGatekeeperRequest_authenticationCapability val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_tokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_tokens val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_tokens_ElmFn(PGatekeeperRequest_tokens val);
    extern int ASN1CALL ASN1Enc_Endpoint_tokens_ElmFn(ASN1encoding_t enc, PEndpoint_tokens val);
    extern int ASN1CALL ASN1Dec_Endpoint_tokens_ElmFn(ASN1decoding_t dec, PEndpoint_tokens val);
	extern void ASN1CALL ASN1Free_Endpoint_tokens_ElmFn(PEndpoint_tokens val);
    extern int ASN1CALL ASN1Enc_Progress_UUIE_tokens_ElmFn(ASN1encoding_t enc, PProgress_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_Progress_UUIE_tokens_ElmFn(ASN1decoding_t dec, PProgress_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_Progress_UUIE_tokens_ElmFn(PProgress_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_tokens_ElmFn(ASN1encoding_t enc, PFacility_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_tokens_ElmFn(ASN1decoding_t dec, PFacility_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_tokens_ElmFn(PFacility_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_tokens_ElmFn(ASN1encoding_t enc, PSetup_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_tokens_ElmFn(ASN1decoding_t dec, PSetup_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_tokens_ElmFn(PSetup_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_Connect_UUIE_tokens_ElmFn(ASN1encoding_t enc, PConnect_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_Connect_UUIE_tokens_ElmFn(ASN1decoding_t dec, PConnect_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_Connect_UUIE_tokens_ElmFn(PConnect_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_CallProceeding_UUIE_tokens_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_CallProceeding_UUIE_tokens_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_CallProceeding_UUIE_tokens_ElmFn(PCallProceeding_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_Alerting_UUIE_tokens_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_Alerting_UUIE_tokens_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_Alerting_UUIE_tokens_ElmFn(PAlerting_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperConfirm_integrity_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_integrity val);
    extern int ASN1CALL ASN1Dec_GatekeeperConfirm_integrity_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_integrity val);
	extern void ASN1CALL ASN1Free_GatekeeperConfirm_integrity_ElmFn(PGatekeeperConfirm_integrity val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_integrity_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_integrity val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_integrity_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_integrity val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_integrity_ElmFn(PGatekeeperRequest_integrity val);
    extern int ASN1CALL ASN1Enc_NonStandardProtocol_dataRatesSupported_ElmFn(ASN1encoding_t enc, PNonStandardProtocol_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_NonStandardProtocol_dataRatesSupported_ElmFn(ASN1decoding_t dec, PNonStandardProtocol_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_NonStandardProtocol_dataRatesSupported_ElmFn(PNonStandardProtocol_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_T120OnlyCaps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PT120OnlyCaps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_T120OnlyCaps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PT120OnlyCaps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_T120OnlyCaps_dataRatesSupported_ElmFn(PT120OnlyCaps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_VoiceCaps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PVoiceCaps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_VoiceCaps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PVoiceCaps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_VoiceCaps_dataRatesSupported_ElmFn(PVoiceCaps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H324Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH324Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H324Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH324Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H324Caps_dataRatesSupported_ElmFn(PH324Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H323Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH323Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H323Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH323Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H323Caps_dataRatesSupported_ElmFn(PH323Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H322Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH322Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H322Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH322Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H322Caps_dataRatesSupported_ElmFn(PH322Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H321Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH321Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H321Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH321Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H321Caps_dataRatesSupported_ElmFn(PH321Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H320Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH320Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H320Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH320Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H320Caps_dataRatesSupported_ElmFn(PH320Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H310Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH310Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H310Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH310Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H310Caps_dataRatesSupported_ElmFn(PH310Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_h245SecurityCapability_ElmFn(ASN1encoding_t enc, PSetup_UUIE_h245SecurityCapability val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_h245SecurityCapability_ElmFn(ASN1decoding_t dec, PSetup_UUIE_h245SecurityCapability val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_h245SecurityCapability_ElmFn(PSetup_UUIE_h245SecurityCapability val);
    extern int ASN1CALL ASN1Enc_H323_UU_PDU_nonStandardControl_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_nonStandardControl val);
    extern int ASN1CALL ASN1Dec_H323_UU_PDU_nonStandardControl_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_nonStandardControl val);
	extern void ASN1CALL ASN1Free_H323_UU_PDU_nonStandardControl_ElmFn(PH323_UU_PDU_nonStandardControl val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_data val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_data val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(PInfoRequestResponse_perCallInfo_Seq_data val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_video val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_video val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(PInfoRequestResponse_perCallInfo_Seq_video val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_audio val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_audio val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(PInfoRequestResponse_perCallInfo_Seq_audio val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_ElmFn(PInfoRequestResponse_perCallInfo val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_callSignalAddress_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_callSignalAddress_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_callSignalAddress val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_callSignalAddress_ElmFn(PInfoRequestResponse_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_AdmissionReject_callSignalAddress_ElmFn(ASN1encoding_t enc, PAdmissionReject_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_AdmissionReject_callSignalAddress_ElmFn(ASN1decoding_t dec, PAdmissionReject_callSignalAddress val);
	extern void ASN1CALL ASN1Free_AdmissionReject_callSignalAddress_ElmFn(PAdmissionReject_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_callSignalAddress_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_callSignalAddress_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_callSignalAddress val);
	extern void ASN1CALL ASN1Free_UnregistrationRequest_callSignalAddress_ElmFn(PUnregistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_alternateGatekeeper val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_alternateGatekeeper val);
	extern void ASN1CALL ASN1Free_RegistrationConfirm_alternateGatekeeper_ElmFn(PRegistrationConfirm_alternateGatekeeper val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_callSignalAddress_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_callSignalAddress_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_callSignalAddress val);
	extern void ASN1CALL ASN1Free_RegistrationConfirm_callSignalAddress_ElmFn(PRegistrationConfirm_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_rasAddress_ElmFn(ASN1encoding_t enc, PRegistrationRequest_rasAddress val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_rasAddress_ElmFn(ASN1decoding_t dec, PRegistrationRequest_rasAddress val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_rasAddress_ElmFn(PRegistrationRequest_rasAddress val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_callSignalAddress_ElmFn(ASN1encoding_t enc, PRegistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_callSignalAddress_ElmFn(ASN1decoding_t dec, PRegistrationRequest_callSignalAddress val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_callSignalAddress_ElmFn(PRegistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_GatekeeperConfirm_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_alternateGatekeeper val);
    extern int ASN1CALL ASN1Dec_GatekeeperConfirm_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_alternateGatekeeper val);
	extern void ASN1CALL ASN1Free_GatekeeperConfirm_alternateGatekeeper_ElmFn(PGatekeeperConfirm_alternateGatekeeper val);
    extern int ASN1CALL ASN1Enc_AltGKInfo_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PAltGKInfo_alternateGatekeeper val);
    extern int ASN1CALL ASN1Dec_AltGKInfo_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PAltGKInfo_alternateGatekeeper val);
	extern void ASN1CALL ASN1Free_AltGKInfo_alternateGatekeeper_ElmFn(PAltGKInfo_alternateGatekeeper val);
    extern int ASN1CALL ASN1Enc_Endpoint_rasAddress_ElmFn(ASN1encoding_t enc, PEndpoint_rasAddress val);
    extern int ASN1CALL ASN1Dec_Endpoint_rasAddress_ElmFn(ASN1decoding_t dec, PEndpoint_rasAddress val);
	extern void ASN1CALL ASN1Free_Endpoint_rasAddress_ElmFn(PEndpoint_rasAddress val);
    extern int ASN1CALL ASN1Enc_Endpoint_callSignalAddress_ElmFn(ASN1encoding_t enc, PEndpoint_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_Endpoint_callSignalAddress_ElmFn(ASN1decoding_t dec, PEndpoint_callSignalAddress val);
	extern void ASN1CALL ASN1Free_Endpoint_callSignalAddress_ElmFn(PEndpoint_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_protocols_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_protocols val);
    extern int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_protocols_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_protocols val);
	extern void ASN1CALL ASN1Free_ResourcesAvailableIndicate_protocols_ElmFn(PResourcesAvailableIndicate_protocols val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_endpointAlias_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_endpointAlias val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_endpointAlias_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_endpointAlias val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_endpointAlias_ElmFn(PInfoRequestResponse_endpointAlias val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_alternateEndpoints_ElmFn(ASN1encoding_t enc, PLocationConfirm_alternateEndpoints val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_alternateEndpoints_ElmFn(ASN1decoding_t dec, PLocationConfirm_alternateEndpoints val);
	extern void ASN1CALL ASN1Free_LocationConfirm_alternateEndpoints_ElmFn(PLocationConfirm_alternateEndpoints val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PLocationConfirm_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PLocationConfirm_remoteExtensionAddress val);
	extern void ASN1CALL ASN1Free_LocationConfirm_remoteExtensionAddress_ElmFn(PLocationConfirm_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PLocationConfirm_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PLocationConfirm_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_LocationConfirm_destExtraCallInfo_ElmFn(PLocationConfirm_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_destinationInfo_ElmFn(ASN1encoding_t enc, PLocationConfirm_destinationInfo val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_destinationInfo_ElmFn(ASN1decoding_t dec, PLocationConfirm_destinationInfo val);
	extern void ASN1CALL ASN1Free_LocationConfirm_destinationInfo_ElmFn(PLocationConfirm_destinationInfo val);
    extern int ASN1CALL ASN1Enc_LocationRequest_sourceInfo_ElmFn(ASN1encoding_t enc, PLocationRequest_sourceInfo val);
    extern int ASN1CALL ASN1Dec_LocationRequest_sourceInfo_ElmFn(ASN1decoding_t dec, PLocationRequest_sourceInfo val);
	extern void ASN1CALL ASN1Free_LocationRequest_sourceInfo_ElmFn(PLocationRequest_sourceInfo val);
    extern int ASN1CALL ASN1Enc_LocationRequest_destinationInfo_ElmFn(ASN1encoding_t enc, PLocationRequest_destinationInfo val);
    extern int ASN1CALL ASN1Dec_LocationRequest_destinationInfo_ElmFn(ASN1decoding_t dec, PLocationRequest_destinationInfo val);
	extern void ASN1CALL ASN1Free_LocationRequest_destinationInfo_ElmFn(PLocationRequest_destinationInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_alternateEndpoints_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_alternateEndpoints val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_alternateEndpoints_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_alternateEndpoints val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_alternateEndpoints_ElmFn(PAdmissionConfirm_alternateEndpoints val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_remoteExtensionAddress val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_remoteExtensionAddress_ElmFn(PAdmissionConfirm_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_destExtraCallInfo_ElmFn(PAdmissionConfirm_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_destinationInfo_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_destinationInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_destinationInfo_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_destinationInfo val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_destinationInfo_ElmFn(PAdmissionConfirm_destinationInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_destAlternatives_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destAlternatives val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_destAlternatives_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destAlternatives val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_destAlternatives_ElmFn(PAdmissionRequest_destAlternatives val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_srcAlternatives_ElmFn(ASN1encoding_t enc, PAdmissionRequest_srcAlternatives val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_srcAlternatives_ElmFn(ASN1decoding_t dec, PAdmissionRequest_srcAlternatives val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_srcAlternatives_ElmFn(PAdmissionRequest_srcAlternatives val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_srcInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_srcInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_srcInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_srcInfo val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_srcInfo_ElmFn(PAdmissionRequest_srcInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_destExtraCallInfo_ElmFn(PAdmissionRequest_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_destinationInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destinationInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_destinationInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destinationInfo val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_destinationInfo_ElmFn(PAdmissionRequest_destinationInfo val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_alternateEndpoints val);
	extern void ASN1CALL ASN1Free_UnregistrationRequest_alternateEndpoints_ElmFn(PUnregistrationRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_endpointAlias_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_endpointAlias val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_endpointAlias_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_endpointAlias val);
	extern void ASN1CALL ASN1Free_UnregistrationRequest_endpointAlias_ElmFn(PUnregistrationRequest_endpointAlias val);
    extern int ASN1CALL ASN1Enc_RegistrationRejectReason_duplicateAlias_ElmFn(ASN1encoding_t enc, PRegistrationRejectReason_duplicateAlias val);
    extern int ASN1CALL ASN1Dec_RegistrationRejectReason_duplicateAlias_ElmFn(ASN1decoding_t dec, PRegistrationRejectReason_duplicateAlias val);
	extern void ASN1CALL ASN1Free_RegistrationRejectReason_duplicateAlias_ElmFn(PRegistrationRejectReason_duplicateAlias val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_terminalAlias_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_terminalAlias val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_terminalAlias_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_terminalAlias val);
	extern void ASN1CALL ASN1Free_RegistrationConfirm_terminalAlias_ElmFn(PRegistrationConfirm_terminalAlias val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PRegistrationRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PRegistrationRequest_alternateEndpoints val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_alternateEndpoints_ElmFn(PRegistrationRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_terminalAlias_ElmFn(ASN1encoding_t enc, PRegistrationRequest_terminalAlias val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_terminalAlias_ElmFn(ASN1decoding_t dec, PRegistrationRequest_terminalAlias val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_terminalAlias_ElmFn(PRegistrationRequest_terminalAlias val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_alternateEndpoints val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_alternateEndpoints_ElmFn(PGatekeeperRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_endpointAlias_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_endpointAlias val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_endpointAlias_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_endpointAlias val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_endpointAlias_ElmFn(PGatekeeperRequest_endpointAlias val);
    extern int ASN1CALL ASN1Enc_Endpoint_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PEndpoint_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_Endpoint_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PEndpoint_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_Endpoint_destExtraCallInfo_ElmFn(PEndpoint_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_Endpoint_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PEndpoint_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Dec_Endpoint_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PEndpoint_remoteExtensionAddress val);
	extern void ASN1CALL ASN1Free_Endpoint_remoteExtensionAddress_ElmFn(PEndpoint_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Enc_Endpoint_aliasAddress_ElmFn(ASN1encoding_t enc, PEndpoint_aliasAddress val);
    extern int ASN1CALL ASN1Dec_Endpoint_aliasAddress_ElmFn(ASN1decoding_t dec, PEndpoint_aliasAddress val);
	extern void ASN1CALL ASN1Free_Endpoint_aliasAddress_ElmFn(PEndpoint_aliasAddress val);
    extern int ASN1CALL ASN1Enc_NonStandardProtocol_supportedPrefixes_ElmFn(ASN1encoding_t enc, PNonStandardProtocol_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_NonStandardProtocol_supportedPrefixes_ElmFn(ASN1decoding_t dec, PNonStandardProtocol_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_NonStandardProtocol_supportedPrefixes_ElmFn(PNonStandardProtocol_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_T120OnlyCaps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PT120OnlyCaps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_T120OnlyCaps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PT120OnlyCaps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_T120OnlyCaps_supportedPrefixes_ElmFn(PT120OnlyCaps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_VoiceCaps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PVoiceCaps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_VoiceCaps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PVoiceCaps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_VoiceCaps_supportedPrefixes_ElmFn(PVoiceCaps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H324Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH324Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H324Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH324Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H324Caps_supportedPrefixes_ElmFn(PH324Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H323Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH323Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H323Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH323Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H323Caps_supportedPrefixes_ElmFn(PH323Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H322Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH322Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H322Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH322Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H322Caps_supportedPrefixes_ElmFn(PH322Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H321Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH321Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H321Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH321Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H321Caps_supportedPrefixes_ElmFn(PH321Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H320Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH320Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H320Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH320Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H320Caps_supportedPrefixes_ElmFn(PH320Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H310Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH310Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H310Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH310Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H310Caps_supportedPrefixes_ElmFn(PH310Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_GatewayInfo_protocol_ElmFn(ASN1encoding_t enc, PGatewayInfo_protocol val);
    extern int ASN1CALL ASN1Dec_GatewayInfo_protocol_ElmFn(ASN1decoding_t dec, PGatewayInfo_protocol val);
	extern void ASN1CALL ASN1Free_GatewayInfo_protocol_ElmFn(PGatewayInfo_protocol val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PFacility_UUIE_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PFacility_UUIE_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_destExtraCallInfo_ElmFn(PFacility_UUIE_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_alternativeAliasAddress_ElmFn(ASN1encoding_t enc, PFacility_UUIE_alternativeAliasAddress val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_alternativeAliasAddress_ElmFn(ASN1decoding_t dec, PFacility_UUIE_alternativeAliasAddress val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_alternativeAliasAddress_ElmFn(PFacility_UUIE_alternativeAliasAddress val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_destExtraCallInfo_ElmFn(PSetup_UUIE_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_destinationAddress_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destinationAddress val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_destinationAddress_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destinationAddress val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_destinationAddress_ElmFn(PSetup_UUIE_destinationAddress val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_sourceAddress_ElmFn(ASN1encoding_t enc, PSetup_UUIE_sourceAddress val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_sourceAddress_ElmFn(ASN1decoding_t dec, PSetup_UUIE_sourceAddress val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_sourceAddress_ElmFn(PSetup_UUIE_sourceAddress val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_ResourcesAvailableConfirm_cryptoTokens_ElmFn(PResourcesAvailableConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_cryptoTokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_cryptoTokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_cryptoTokens val);
	extern void ASN1CALL ASN1Free_ResourcesAvailableIndicate_cryptoTokens_ElmFn(PResourcesAvailableIndicate_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_RequestInProgress_cryptoTokens_ElmFn(ASN1encoding_t enc, PRequestInProgress_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_RequestInProgress_cryptoTokens_ElmFn(ASN1decoding_t dec, PRequestInProgress_cryptoTokens val);
	extern void ASN1CALL ASN1Free_RequestInProgress_cryptoTokens_ElmFn(PRequestInProgress_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_UnknownMessageResponse_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnknownMessageResponse_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_UnknownMessageResponse_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnknownMessageResponse_cryptoTokens val);
	extern void ASN1CALL ASN1Free_UnknownMessageResponse_cryptoTokens_ElmFn(PUnknownMessageResponse_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_H225NonStandardMessage_cryptoTokens_ElmFn(ASN1encoding_t enc, PH225NonStandardMessage_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_H225NonStandardMessage_cryptoTokens_ElmFn(ASN1decoding_t dec, PH225NonStandardMessage_cryptoTokens val);
	extern void ASN1CALL ASN1Free_H225NonStandardMessage_cryptoTokens_ElmFn(PH225NonStandardMessage_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestNak_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestNak_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestNak_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestNak_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequestNak_cryptoTokens_ElmFn(PInfoRequestNak_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestAck_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestAck_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestAck_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestAck_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequestAck_cryptoTokens_ElmFn(PInfoRequestAck_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_cryptoTokens_ElmFn(PInfoRequestResponse_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequest_cryptoTokens_ElmFn(PInfoRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_DisengageReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_DisengageReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_DisengageReject_cryptoTokens_ElmFn(PDisengageReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_DisengageConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_DisengageConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_DisengageConfirm_cryptoTokens_ElmFn(PDisengageConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_DisengageRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_DisengageRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_DisengageRequest_cryptoTokens_ElmFn(PDisengageRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_LocationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_LocationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_LocationReject_cryptoTokens_ElmFn(PLocationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_LocationConfirm_cryptoTokens_ElmFn(PLocationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_LocationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_LocationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_LocationRequest_cryptoTokens_ElmFn(PLocationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_BandwidthReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_BandwidthReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_BandwidthReject_cryptoTokens_ElmFn(PBandwidthReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_BandwidthConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_BandwidthConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_BandwidthConfirm_cryptoTokens_ElmFn(PBandwidthConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_BandwidthRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_BandwidthRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_BandwidthRequest_cryptoTokens_ElmFn(PBandwidthRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_AdmissionReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_AdmissionReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_AdmissionReject_cryptoTokens_ElmFn(PAdmissionReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_cryptoTokens_ElmFn(PAdmissionConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_cryptoTokens_ElmFn(PAdmissionRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_UnregistrationReject_cryptoTokens_ElmFn(PUnregistrationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_UnregistrationConfirm_cryptoTokens_ElmFn(PUnregistrationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_UnregistrationRequest_cryptoTokens_ElmFn(PUnregistrationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_RegistrationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_RegistrationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_RegistrationReject_cryptoTokens_ElmFn(PRegistrationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_RegistrationConfirm_cryptoTokens_ElmFn(PRegistrationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_cryptoTokens_ElmFn(PRegistrationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_GatekeeperReject_cryptoTokens_ElmFn(PGatekeeperReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_GatekeeperConfirm_cryptoTokens_ElmFn(PGatekeeperConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_cryptoTokens_ElmFn(PGatekeeperRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Endpoint_cryptoTokens_ElmFn(ASN1encoding_t enc, PEndpoint_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Endpoint_cryptoTokens_ElmFn(ASN1decoding_t dec, PEndpoint_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Endpoint_cryptoTokens_ElmFn(PEndpoint_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Progress_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PProgress_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Progress_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PProgress_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Progress_UUIE_cryptoTokens_ElmFn(PProgress_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_conferences_ElmFn(ASN1encoding_t enc, PFacility_UUIE_conferences val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_conferences_ElmFn(ASN1decoding_t dec, PFacility_UUIE_conferences val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_conferences_ElmFn(PFacility_UUIE_conferences val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PFacility_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PFacility_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_cryptoTokens_ElmFn(PFacility_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PSetup_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PSetup_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_cryptoTokens_ElmFn(PSetup_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Connect_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PConnect_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Connect_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PConnect_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Connect_UUIE_cryptoTokens_ElmFn(PConnect_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_CallProceeding_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_CallProceeding_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_CallProceeding_UUIE_cryptoTokens_ElmFn(PCallProceeding_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Alerting_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Alerting_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Alerting_UUIE_cryptoTokens_ElmFn(PAlerting_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_pdu val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_pdu val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(PInfoRequestResponse_perCallInfo_Seq_pdu val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _H225ASN_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\asn\h245asn.c ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for Multimedia System Control (H.245) */

#include <windows.h>
#include "h245asn.h"

ASN1module_t H245ASN_Module = NULL;

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1_errorCorrection(ASN1encoding_t enc, NewATMVCIndication_aal_aal1_errorCorrection *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1_clockRecovery(ASN1encoding_t enc, NewATMVCIndication_aal_aal1_clockRecovery *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(ASN1encoding_t enc, MiscellaneousCommand_type_progressiveRefinementStart_repeatCount *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode_eRM_recovery(ASN1encoding_t enc, V76LogicalChannelParameters_mode_eRM_recovery *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_extendedPAR_Set *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI_customPCF_Set(ASN1encoding_t enc, CustomPictureFormat_mPI_customPCF_Set *val);
static int ASN1CALL ASN1Enc_VCCapability_availableBitRates_type_rangeOfBitRates(ASN1encoding_t enc, VCCapability_availableBitRates_type_rangeOfBitRates *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(ASN1encoding_t enc, TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *val);
static int ASN1CALL ASN1Enc_VCCapability_availableBitRates_type(ASN1encoding_t enc, VCCapability_availableBitRates_type *val);
static int ASN1CALL ASN1Enc_H223Capability_h223MultiplexTableCapability_enhanced(ASN1encoding_t enc, H223Capability_h223MultiplexTableCapability_enhanced *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI_customPCF(ASN1encoding_t enc, CustomPictureFormat_mPI_customPCF *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_extendedPAR *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val);
static int ASN1CALL ASN1Enc_H223LogicalChannelParameters_adaptationLayerType_al3(ASN1encoding_t enc, H223LogicalChannelParameters_adaptationLayerType_al3 *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode_eRM(ASN1encoding_t enc, V76LogicalChannelParameters_mode_eRM *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_routing(ASN1encoding_t enc, UnicastAddress_iPSourceRouteAddress_routing *val);
static int ASN1CALL ASN1Enc_H223ModeParameters_adaptationLayerType_al3(ASN1encoding_t enc, H223ModeParameters_adaptationLayerType_al3 *val);
static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(ASN1encoding_t enc, SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val);
static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart(ASN1encoding_t enc, MiscellaneousCommand_type_progressiveRefinementStart *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_videoFastUpdateMB(ASN1encoding_t enc, MiscellaneousCommand_type_videoFastUpdateMB *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_videoFastUpdateGOB(ASN1encoding_t enc, MiscellaneousCommand_type_videoFastUpdateGOB *val);
static int ASN1CALL ASN1Enc_MiscellaneousIndication_type_videoNotDecodedMBs(ASN1encoding_t enc, MiscellaneousIndication_type_videoNotDecodedMBs *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal5(ASN1encoding_t enc, NewATMVCIndication_aal_aal5 *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1(ASN1encoding_t enc, NewATMVCIndication_aal_aal1 *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_reverseParameters_multiplex(ASN1encoding_t enc, NewATMVCIndication_reverseParameters_multiplex *val);
static int ASN1CALL ASN1Enc_UserInputIndication_signal_rtp(ASN1encoding_t enc, UserInputIndication_signal_rtp *val);
static int ASN1CALL ASN1Enc_UserInputIndication_signalUpdate_rtp(ASN1encoding_t enc, UserInputIndication_signalUpdate_rtp *val);
static int ASN1CALL ASN1Enc_UserInputIndication_signalUpdate(ASN1encoding_t enc, UserInputIndication_signalUpdate *val);
static int ASN1CALL ASN1Enc_UserInputIndication_signal(ASN1encoding_t enc, UserInputIndication_signal *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_reverseParameters(ASN1encoding_t enc, NewATMVCIndication_reverseParameters *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_multiplex(ASN1encoding_t enc, NewATMVCIndication_multiplex *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_aal(ASN1encoding_t enc, NewATMVCIndication_aal *val);
static int ASN1CALL ASN1Enc_JitterIndication_scope(ASN1encoding_t enc, JitterIndication_scope *val);
static int ASN1CALL ASN1Enc_FunctionNotSupported_cause(ASN1encoding_t enc, FunctionNotSupported_cause *val);
static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration_h223AnnexADoubleFlag(ASN1encoding_t enc, H223MultiplexReconfiguration_h223AnnexADoubleFlag *val);
static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration_h223ModeChange(ASN1encoding_t enc, H223MultiplexReconfiguration_h223ModeChange *val);
static int ASN1CALL ASN1Enc_EndSessionCommand_isdnOptions(ASN1encoding_t enc, EndSessionCommand_isdnOptions *val);
static int ASN1CALL ASN1Enc_EndSessionCommand_gstnOptions(ASN1encoding_t enc, EndSessionCommand_gstnOptions *val);
static int ASN1CALL ASN1Enc_FlowControlCommand_restriction(ASN1encoding_t enc, FlowControlCommand_restriction *val);
static int ASN1CALL ASN1Enc_FlowControlCommand_scope(ASN1encoding_t enc, FlowControlCommand_scope *val);
static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest(ASN1encoding_t enc, SendTerminalCapabilitySet_specificRequest *val);
static int ASN1CALL ASN1Enc_RemoteMCResponse_reject(ASN1encoding_t enc, RemoteMCResponse_reject *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_sendThisSourceResponse(ASN1encoding_t enc, ConferenceResponse_sendThisSourceResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_makeTerminalBroadcasterResponse(ASN1encoding_t enc, ConferenceResponse_makeTerminalBroadcasterResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_broadcastMyLogicalChannelResponse(ASN1encoding_t enc, ConferenceResponse_broadcastMyLogicalChannelResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_extensionAddressResponse(ASN1encoding_t enc, ConferenceResponse_extensionAddressResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_makeMeChairResponse(ASN1encoding_t enc, ConferenceResponse_makeMeChairResponse *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopReject_cause(ASN1encoding_t enc, MaintenanceLoopReject_cause *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopReject_type(ASN1encoding_t enc, MaintenanceLoopReject_type *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopAck_type(ASN1encoding_t enc, MaintenanceLoopAck_type *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopRequest_type(ASN1encoding_t enc, MaintenanceLoopRequest_type *val);
static int ASN1CALL ASN1Enc_G7231AnnexCMode_g723AnnexCAudioMode(ASN1encoding_t enc, G7231AnnexCMode_g723AnnexCAudioMode *val);
static int ASN1CALL ASN1Enc_IS13818AudioMode_multichannelType(ASN1encoding_t enc, IS13818AudioMode_multichannelType *val);
static int ASN1CALL ASN1Enc_IS13818AudioMode_audioSampling(ASN1encoding_t enc, IS13818AudioMode_audioSampling *val);
static int ASN1CALL ASN1Enc_IS13818AudioMode_audioLayer(ASN1encoding_t enc, IS13818AudioMode_audioLayer *val);
static int ASN1CALL ASN1Enc_IS11172AudioMode_multichannelType(ASN1encoding_t enc, IS11172AudioMode_multichannelType *val);
static int ASN1CALL ASN1Enc_IS11172AudioMode_audioSampling(ASN1encoding_t enc, IS11172AudioMode_audioSampling *val);
static int ASN1CALL ASN1Enc_IS11172AudioMode_audioLayer(ASN1encoding_t enc, IS11172AudioMode_audioLayer *val);
static int ASN1CALL ASN1Enc_AudioMode_g7231(ASN1encoding_t enc, AudioMode_g7231 *val);
static int ASN1CALL ASN1Enc_H263VideoMode_resolution(ASN1encoding_t enc, H263VideoMode_resolution *val);
static int ASN1CALL ASN1Enc_H262VideoMode_profileAndLevel(ASN1encoding_t enc, H262VideoMode_profileAndLevel *val);
static int ASN1CALL ASN1Enc_H261VideoMode_resolution(ASN1encoding_t enc, H261VideoMode_resolution *val);
static int ASN1CALL ASN1Enc_RequestModeReject_cause(ASN1encoding_t enc, RequestModeReject_cause *val);
static int ASN1CALL ASN1Enc_RequestModeAck_response(ASN1encoding_t enc, RequestModeAck_response *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryRelease_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryRelease_entryNumbers *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryRejectionDescriptions_cause(ASN1encoding_t enc, RequestMultiplexEntryRejectionDescriptions_cause *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryReject_entryNumbers *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryAck_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryAck_entryNumbers *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntry_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntry_entryNumbers *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendRelease_multiplexTableEntryNumber(ASN1encoding_t enc, MultiplexEntrySendRelease_multiplexTableEntryNumber *val);
static int ASN1CALL ASN1Enc_MultiplexEntryRejectionDescriptions_cause(ASN1encoding_t enc, MultiplexEntryRejectionDescriptions_cause *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendAck_multiplexTableEntryNumber(ASN1encoding_t enc, MultiplexEntrySendAck_multiplexTableEntryNumber *val);
static int ASN1CALL ASN1Enc_MultiplexElement_repeatCount(ASN1encoding_t enc, MultiplexElement_repeatCount *val);
static int ASN1CALL ASN1Enc_MultiplexElement_type(ASN1encoding_t enc, MultiplexElement_type *val);
static int ASN1CALL ASN1Enc_RequestChannelCloseReject_cause(ASN1encoding_t enc, RequestChannelCloseReject_cause *val);
static int ASN1CALL ASN1Enc_RequestChannelClose_reason(ASN1encoding_t enc, RequestChannelClose_reason *val);
static int ASN1CALL ASN1Enc_CloseLogicalChannel_reason(ASN1encoding_t enc, CloseLogicalChannel_reason *val);
static int ASN1CALL ASN1Enc_CloseLogicalChannel_source(ASN1encoding_t enc, CloseLogicalChannel_source *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelReject_cause(ASN1encoding_t enc, OpenLogicalChannelReject_cause *val);
static int ASN1CALL ASN1Enc_MulticastAddress_iP6Address(ASN1encoding_t enc, MulticastAddress_iP6Address *val);
static int ASN1CALL ASN1Enc_MulticastAddress_iPAddress(ASN1encoding_t enc, MulticastAddress_iPAddress *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress(ASN1encoding_t enc, UnicastAddress_iPSourceRouteAddress *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iP6Address(ASN1encoding_t enc, UnicastAddress_iP6Address *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPXAddress(ASN1encoding_t enc, UnicastAddress_iPXAddress *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPAddress(ASN1encoding_t enc, UnicastAddress_iPAddress *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode(ASN1encoding_t enc, V76LogicalChannelParameters_mode *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_suspendResume(ASN1encoding_t enc, V76LogicalChannelParameters_suspendResume *val);
static int ASN1CALL ASN1Enc_H223AnnexCArqParameters_numberOfRetransmissions(ASN1encoding_t enc, H223AnnexCArqParameters_numberOfRetransmissions *val);
static int ASN1CALL ASN1Enc_H223AL3MParameters_crcLength(ASN1encoding_t enc, H223AL3MParameters_crcLength *val);
static int ASN1CALL ASN1Enc_H223AL3MParameters_headerFormat(ASN1encoding_t enc, H223AL3MParameters_headerFormat *val);
static int ASN1CALL ASN1Enc_H223AL2MParameters_headerFEC(ASN1encoding_t enc, H223AL2MParameters_headerFEC *val);
static int ASN1CALL ASN1Enc_H223AL1MParameters_crcLength(ASN1encoding_t enc, H223AL1MParameters_crcLength *val);
static int ASN1CALL ASN1Enc_H223AL1MParameters_headerFEC(ASN1encoding_t enc, H223AL1MParameters_headerFEC *val);
static int ASN1CALL ASN1Enc_H223AL1MParameters_transferMode(ASN1encoding_t enc, H223AL1MParameters_transferMode *val);
static int ASN1CALL ASN1Enc_Q2931Address_address(ASN1encoding_t enc, Q2931Address_address *val);
static int ASN1CALL ASN1Enc_NetworkAccessParameters_t120SetupProcedure(ASN1encoding_t enc, NetworkAccessParameters_t120SetupProcedure *val);
static int ASN1CALL ASN1Enc_NetworkAccessParameters_distribution(ASN1encoding_t enc, NetworkAccessParameters_distribution *val);
static int ASN1CALL ASN1Enc_T84Profile_t84Restricted(ASN1encoding_t enc, T84Profile_t84Restricted *val);
static int ASN1CALL ASN1Enc_G7231AnnexCCapability_g723AnnexCAudioMode(ASN1encoding_t enc, G7231AnnexCCapability_g723AnnexCAudioMode *val);
static int ASN1CALL ASN1Enc_AudioCapability_g7231(ASN1encoding_t enc, AudioCapability_g7231 *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI(ASN1encoding_t enc, CustomPictureFormat_mPI *val);
static int ASN1CALL ASN1Enc_RefPictureSelection_videoBackChannelSend(ASN1encoding_t enc, RefPictureSelection_videoBackChannelSend *val);
static int ASN1CALL ASN1Enc_RefPictureSelection_additionalPictureMemory(ASN1encoding_t enc, RefPictureSelection_additionalPictureMemory *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyFrameMapping_frameSequence(ASN1encoding_t enc, RTPH263VideoRedundancyFrameMapping_frameSequence *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_containedThreads(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding_containedThreads *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding_frameToThreadMapping *val);
static int ASN1CALL ASN1Enc_RedundancyEncodingCapability_secondaryEncoding(ASN1encoding_t enc, PRedundancyEncodingCapability_secondaryEncoding *val);
static int ASN1CALL ASN1Enc_H2250Capability_mcCapability(ASN1encoding_t enc, H2250Capability_mcCapability *val);
static int ASN1CALL ASN1Enc_H223Capability_mobileOperationTransmitCapability(ASN1encoding_t enc, H223Capability_mobileOperationTransmitCapability *val);
static int ASN1CALL ASN1Enc_H223Capability_h223MultiplexTableCapability(ASN1encoding_t enc, H223Capability_h223MultiplexTableCapability *val);
static int ASN1CALL ASN1Enc_VCCapability_availableBitRates(ASN1encoding_t enc, VCCapability_availableBitRates *val);
static int ASN1CALL ASN1Enc_VCCapability_aal5(ASN1encoding_t enc, VCCapability_aal5 *val);
static int ASN1CALL ASN1Enc_VCCapability_aal1(ASN1encoding_t enc, VCCapability_aal1 *val);
static int ASN1CALL ASN1Enc_Capability_h233EncryptionReceiveCapability(ASN1encoding_t enc, Capability_h233EncryptionReceiveCapability *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject_cause(ASN1encoding_t enc, TerminalCapabilitySetReject_cause *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationReject_cause(ASN1encoding_t enc, MasterSlaveDeterminationReject_cause *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationAck_decision(ASN1encoding_t enc, MasterSlaveDeterminationAck_decision *val);
static int ASN1CALL ASN1Enc_NonStandardIdentifier_h221NonStandard(ASN1encoding_t enc, NonStandardIdentifier_h221NonStandard *val);
static int ASN1CALL ASN1Enc_NonStandardIdentifier(ASN1encoding_t enc, NonStandardIdentifier *val);
static int ASN1CALL ASN1Enc_MasterSlaveDetermination(ASN1encoding_t enc, MasterSlaveDetermination *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationAck(ASN1encoding_t enc, MasterSlaveDeterminationAck *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationReject(ASN1encoding_t enc, MasterSlaveDeterminationReject *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationRelease(ASN1encoding_t enc, MasterSlaveDeterminationRelease *val);
static int ASN1CALL ASN1Enc_CapabilityDescriptor(ASN1encoding_t enc, CapabilityDescriptor *val);
static int ASN1CALL ASN1Enc_AlternativeCapabilitySet(ASN1encoding_t enc, AlternativeCapabilitySet *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetAck(ASN1encoding_t enc, TerminalCapabilitySetAck *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject(ASN1encoding_t enc, TerminalCapabilitySetReject *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetRelease(ASN1encoding_t enc, TerminalCapabilitySetRelease *val);
static int ASN1CALL ASN1Enc_H222Capability(ASN1encoding_t enc, H222Capability *val);
static int ASN1CALL ASN1Enc_VCCapability(ASN1encoding_t enc, VCCapability *val);
static int ASN1CALL ASN1Enc_H223AnnexCCapability(ASN1encoding_t enc, H223AnnexCCapability *val);
static int ASN1CALL ASN1Enc_V75Capability(ASN1encoding_t enc, V75Capability *val);
static int ASN1CALL ASN1Enc_QOSMode(ASN1encoding_t enc, QOSMode *val);
static int ASN1CALL ASN1Enc_ATMParameters(ASN1encoding_t enc, ATMParameters *val);
static int ASN1CALL ASN1Enc_MediaTransportType(ASN1encoding_t enc, MediaTransportType *val);
static int ASN1CALL ASN1Enc_MediaChannelCapability(ASN1encoding_t enc, MediaChannelCapability *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyFrameMapping(ASN1encoding_t enc, RTPH263VideoRedundancyFrameMapping *val);
static int ASN1CALL ASN1Enc_MultipointCapability(ASN1encoding_t enc, MultipointCapability *val);
static int ASN1CALL ASN1Enc_MediaDistributionCapability(ASN1encoding_t enc, MediaDistributionCapability *val);
static int ASN1CALL ASN1Enc_H261VideoCapability(ASN1encoding_t enc, H261VideoCapability *val);
static int ASN1CALL ASN1Enc_H262VideoCapability(ASN1encoding_t enc, H262VideoCapability *val);
static int ASN1CALL ASN1Enc_EnhancementLayerInfo(ASN1encoding_t enc, EnhancementLayerInfo *val);
static int ASN1CALL ASN1Enc_TransparencyParameters(ASN1encoding_t enc, TransparencyParameters *val);
static int ASN1CALL ASN1Enc_RefPictureSelection(ASN1encoding_t enc, RefPictureSelection *val);
static int ASN1CALL ASN1Enc_CustomPictureClockFrequency(ASN1encoding_t enc, CustomPictureClockFrequency *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat(ASN1encoding_t enc, CustomPictureFormat *val);
static int ASN1CALL ASN1Enc_H263ModeComboFlags(ASN1encoding_t enc, H263ModeComboFlags *val);
static int ASN1CALL ASN1Enc_IS11172VideoCapability(ASN1encoding_t enc, IS11172VideoCapability *val);
static int ASN1CALL ASN1Enc_G7231AnnexCCapability(ASN1encoding_t enc, G7231AnnexCCapability *val);
static int ASN1CALL ASN1Enc_IS11172AudioCapability(ASN1encoding_t enc, IS11172AudioCapability *val);
static int ASN1CALL ASN1Enc_IS13818AudioCapability(ASN1encoding_t enc, IS13818AudioCapability *val);
static int ASN1CALL ASN1Enc_GSMAudioCapability(ASN1encoding_t enc, GSMAudioCapability *val);
static int ASN1CALL ASN1Enc_V42bis(ASN1encoding_t enc, V42bis *val);
static int ASN1CALL ASN1Enc_T84Profile(ASN1encoding_t enc, T84Profile *val);
static int ASN1CALL ASN1Enc_ConferenceCapability(ASN1encoding_t enc, ConferenceCapability *val);
static int ASN1CALL ASN1Enc_Q2931Address(ASN1encoding_t enc, Q2931Address *val);
static int ASN1CALL ASN1Enc_V75Parameters(ASN1encoding_t enc, V75Parameters *val);
static int ASN1CALL ASN1Enc_H222LogicalChannelParameters(ASN1encoding_t enc, H222LogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_H223AL2MParameters(ASN1encoding_t enc, H223AL2MParameters *val);
static int ASN1CALL ASN1Enc_H223AnnexCArqParameters(ASN1encoding_t enc, H223AnnexCArqParameters *val);
static int ASN1CALL ASN1Enc_CRCLength(ASN1encoding_t enc, CRCLength *val);
static int ASN1CALL ASN1Enc_EscrowData(ASN1encoding_t enc, EscrowData *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelReject(ASN1encoding_t enc, OpenLogicalChannelReject *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelConfirm(ASN1encoding_t enc, OpenLogicalChannelConfirm *val);
static int ASN1CALL ASN1Enc_CloseLogicalChannel(ASN1encoding_t enc, CloseLogicalChannel *val);
static int ASN1CALL ASN1Enc_CloseLogicalChannelAck(ASN1encoding_t enc, CloseLogicalChannelAck *val);
static int ASN1CALL ASN1Enc_RequestChannelCloseAck(ASN1encoding_t enc, RequestChannelCloseAck *val);
static int ASN1CALL ASN1Enc_RequestChannelCloseReject(ASN1encoding_t enc, RequestChannelCloseReject *val);
static int ASN1CALL ASN1Enc_RequestChannelCloseRelease(ASN1encoding_t enc, RequestChannelCloseRelease *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySend(ASN1encoding_t enc, MultiplexEntrySend *val);
static int ASN1CALL ASN1Enc_MultiplexElement(ASN1encoding_t enc, MultiplexElement *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendAck(ASN1encoding_t enc, MultiplexEntrySendAck *val);
static int ASN1CALL ASN1Enc_MultiplexEntryRejectionDescriptions(ASN1encoding_t enc, MultiplexEntryRejectionDescriptions *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendRelease(ASN1encoding_t enc, MultiplexEntrySendRelease *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntry(ASN1encoding_t enc, RequestMultiplexEntry *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryAck(ASN1encoding_t enc, RequestMultiplexEntryAck *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryRejectionDescriptions(ASN1encoding_t enc, RequestMultiplexEntryRejectionDescriptions *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryRelease(ASN1encoding_t enc, RequestMultiplexEntryRelease *val);
static int ASN1CALL ASN1Enc_RequestMode(ASN1encoding_t enc, RequestMode *val);
static int ASN1CALL ASN1Enc_RequestModeAck(ASN1encoding_t enc, RequestModeAck *val);
static int ASN1CALL ASN1Enc_RequestModeReject(ASN1encoding_t enc, RequestModeReject *val);
static int ASN1CALL ASN1Enc_RequestModeRelease(ASN1encoding_t enc, RequestModeRelease *val);
static int ASN1CALL ASN1Enc_V76ModeParameters(ASN1encoding_t enc, V76ModeParameters *val);
static int ASN1CALL ASN1Enc_H261VideoMode(ASN1encoding_t enc, H261VideoMode *val);
static int ASN1CALL ASN1Enc_H262VideoMode(ASN1encoding_t enc, H262VideoMode *val);
static int ASN1CALL ASN1Enc_IS11172VideoMode(ASN1encoding_t enc, IS11172VideoMode *val);
static int ASN1CALL ASN1Enc_IS11172AudioMode(ASN1encoding_t enc, IS11172AudioMode *val);
static int ASN1CALL ASN1Enc_IS13818AudioMode(ASN1encoding_t enc, IS13818AudioMode *val);
static int ASN1CALL ASN1Enc_G7231AnnexCMode(ASN1encoding_t enc, G7231AnnexCMode *val);
static int ASN1CALL ASN1Enc_RoundTripDelayRequest(ASN1encoding_t enc, RoundTripDelayRequest *val);
static int ASN1CALL ASN1Enc_RoundTripDelayResponse(ASN1encoding_t enc, RoundTripDelayResponse *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopRequest(ASN1encoding_t enc, MaintenanceLoopRequest *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopAck(ASN1encoding_t enc, MaintenanceLoopAck *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopReject(ASN1encoding_t enc, MaintenanceLoopReject *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopOffCommand(ASN1encoding_t enc, MaintenanceLoopOffCommand *val);
static int ASN1CALL ASN1Enc_CommunicationModeCommand(ASN1encoding_t enc, CommunicationModeCommand *val);
static int ASN1CALL ASN1Enc_CommunicationModeRequest(ASN1encoding_t enc, CommunicationModeRequest *val);
static int ASN1CALL ASN1Enc_CommunicationModeResponse(ASN1encoding_t enc, CommunicationModeResponse *val);
static int ASN1CALL ASN1Enc_Criteria(ASN1encoding_t enc, Criteria *val);
static int ASN1CALL ASN1Enc_TerminalLabel(ASN1encoding_t enc, TerminalLabel *val);
static int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse(ASN1encoding_t enc, RequestAllTerminalIDsResponse *val);
static int ASN1CALL ASN1Enc_TerminalInformation(ASN1encoding_t enc, TerminalInformation *val);
static int ASN1CALL ASN1Enc_RemoteMCRequest(ASN1encoding_t enc, RemoteMCRequest *val);
static int ASN1CALL ASN1Enc_RemoteMCResponse(ASN1encoding_t enc, RemoteMCResponse *val);
static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet(ASN1encoding_t enc, SendTerminalCapabilitySet *val);
static int ASN1CALL ASN1Enc_FlowControlCommand(ASN1encoding_t enc, FlowControlCommand *val);
static int ASN1CALL ASN1Enc_SubstituteConferenceIDCommand(ASN1encoding_t enc, SubstituteConferenceIDCommand *val);
static int ASN1CALL ASN1Enc_KeyProtectionMethod(ASN1encoding_t enc, KeyProtectionMethod *val);
static int ASN1CALL ASN1Enc_EncryptionUpdateRequest(ASN1encoding_t enc, EncryptionUpdateRequest *val);
static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration(ASN1encoding_t enc, H223MultiplexReconfiguration *val);
static int ASN1CALL ASN1Enc_FunctionNotSupported(ASN1encoding_t enc, FunctionNotSupported *val);
static int ASN1CALL ASN1Enc_TerminalYouAreSeeingInSubPictureNumber(ASN1encoding_t enc, TerminalYouAreSeeingInSubPictureNumber *val);
static int ASN1CALL ASN1Enc_VideoIndicateCompose(ASN1encoding_t enc, VideoIndicateCompose *val);
static int ASN1CALL ASN1Enc_ConferenceIndication(ASN1encoding_t enc, ConferenceIndication *val);
static int ASN1CALL ASN1Enc_JitterIndication(ASN1encoding_t enc, JitterIndication *val);
static int ASN1CALL ASN1Enc_H223SkewIndication(ASN1encoding_t enc, H223SkewIndication *val);
static int ASN1CALL ASN1Enc_H2250MaximumSkewIndication(ASN1encoding_t enc, H2250MaximumSkewIndication *val);
static int ASN1CALL ASN1Enc_VendorIdentification(ASN1encoding_t enc, VendorIdentification *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication(ASN1encoding_t enc, NewATMVCIndication *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(ASN1encoding_t enc, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val);
static int ASN1CALL ASN1Enc_MultiplexElement_type_subElementList(ASN1encoding_t enc, PMultiplexElement_type_subElementList *val);
static int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation(ASN1encoding_t enc, PRequestAllTerminalIDsResponse_terminalInformation *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_terminalCertificateResponse(ASN1encoding_t enc, ConferenceResponse_terminalCertificateResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_chairTokenOwnerResponse(ASN1encoding_t enc, ConferenceResponse_chairTokenOwnerResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_terminalListResponse(ASN1encoding_t enc, ConferenceResponse_terminalListResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_passwordResponse(ASN1encoding_t enc, ConferenceResponse_passwordResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_conferenceIDResponse(ASN1encoding_t enc, ConferenceResponse_conferenceIDResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_terminalIDResponse(ASN1encoding_t enc, ConferenceResponse_terminalIDResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_mCTerminalIDResponse(ASN1encoding_t enc, ConferenceResponse_mCTerminalIDResponse *val);
static int ASN1CALL ASN1Enc_ConferenceRequest_requestTerminalCertificate(ASN1encoding_t enc, ConferenceRequest_requestTerminalCertificate *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject_rejectionDescriptions(ASN1encoding_t enc, RequestMultiplexEntryReject_rejectionDescriptions *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendReject_rejectionDescriptions(ASN1encoding_t enc, MultiplexEntrySendReject_rejectionDescriptions *val);
static int ASN1CALL ASN1Enc_MultiplexEntryDescriptor_elementList(ASN1encoding_t enc, MultiplexEntryDescriptor_elementList *val);
static int ASN1CALL ASN1Enc_EncryptionSync_escrowentry(ASN1encoding_t enc, PEncryptionSync_escrowentry *val);
static int ASN1CALL ASN1Enc_H223AL3MParameters_arqType(ASN1encoding_t enc, H223AL3MParameters_arqType *val);
static int ASN1CALL ASN1Enc_H223AL1MParameters_arqType(ASN1encoding_t enc, H223AL1MParameters_arqType *val);
static int ASN1CALL ASN1Enc_H263VideoModeCombos_h263VideoCoupledModes(ASN1encoding_t enc, H263VideoModeCombos_h263VideoCoupledModes *val);
static int ASN1CALL ASN1Enc_H263Options_customPictureFormat(ASN1encoding_t enc, PH263Options_customPictureFormat *val);
static int ASN1CALL ASN1Enc_H263Options_customPictureClockFrequency(ASN1encoding_t enc, PH263Options_customPictureClockFrequency *val);
static int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability *val);
static int ASN1CALL ASN1Enc_TransportCapability_mediaChannelCapabilities(ASN1encoding_t enc, TransportCapability_mediaChannelCapabilities *val);
static int ASN1CALL ASN1Enc_H222Capability_vcCapability(ASN1encoding_t enc, PH222Capability_vcCapability *val);
static int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityDescriptors(ASN1encoding_t enc, TerminalCapabilitySet_capabilityDescriptors *val);
static int ASN1CALL ASN1Enc_NonStandardParameter(ASN1encoding_t enc, NonStandardParameter *val);
static int ASN1CALL ASN1Enc_H223Capability(ASN1encoding_t enc, H223Capability *val);
static int ASN1CALL ASN1Enc_V76Capability(ASN1encoding_t enc, V76Capability *val);
static int ASN1CALL ASN1Enc_RSVPParameters(ASN1encoding_t enc, RSVPParameters *val);
static int ASN1CALL ASN1Enc_QOSCapability(ASN1encoding_t enc, QOSCapability *val);
static int ASN1CALL ASN1Enc_TransportCapability(ASN1encoding_t enc, TransportCapability *val);
static int ASN1CALL ASN1Enc_RedundancyEncodingMethod(ASN1encoding_t enc, RedundancyEncodingMethod *val);
static int ASN1CALL ASN1Enc_H263Options(ASN1encoding_t enc, H263Options *val);
static int ASN1CALL ASN1Enc_H263VideoModeCombos(ASN1encoding_t enc, H263VideoModeCombos *val);
static int ASN1CALL ASN1Enc_AudioCapability(ASN1encoding_t enc, AudioCapability *val);
static int ASN1CALL ASN1Enc_CompressionType(ASN1encoding_t enc, CompressionType *val);
static int ASN1CALL ASN1Enc_MediaEncryptionAlgorithm(ASN1encoding_t enc, MediaEncryptionAlgorithm *val);
static int ASN1CALL ASN1Enc_AuthenticationCapability(ASN1encoding_t enc, AuthenticationCapability *val);
static int ASN1CALL ASN1Enc_IntegrityCapability(ASN1encoding_t enc, IntegrityCapability *val);
static int ASN1CALL ASN1Enc_H223AL1MParameters(ASN1encoding_t enc, H223AL1MParameters *val);
static int ASN1CALL ASN1Enc_H223AL3MParameters(ASN1encoding_t enc, H223AL3MParameters *val);
static int ASN1CALL ASN1Enc_V76HDLCParameters(ASN1encoding_t enc, V76HDLCParameters *val);
static int ASN1CALL ASN1Enc_UnicastAddress(ASN1encoding_t enc, UnicastAddress *val);
static int ASN1CALL ASN1Enc_MulticastAddress(ASN1encoding_t enc, MulticastAddress *val);
static int ASN1CALL ASN1Enc_EncryptionSync(ASN1encoding_t enc, EncryptionSync *val);
static int ASN1CALL ASN1Enc_RequestChannelClose(ASN1encoding_t enc, RequestChannelClose *val);
static int ASN1CALL ASN1Enc_MultiplexEntryDescriptor(ASN1encoding_t enc, MultiplexEntryDescriptor *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendReject(ASN1encoding_t enc, MultiplexEntrySendReject *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject(ASN1encoding_t enc, RequestMultiplexEntryReject *val);
static int ASN1CALL ASN1Enc_H263VideoMode(ASN1encoding_t enc, H263VideoMode *val);
static int ASN1CALL ASN1Enc_AudioMode(ASN1encoding_t enc, AudioMode *val);
static int ASN1CALL ASN1Enc_EncryptionMode(ASN1encoding_t enc, EncryptionMode *val);
static int ASN1CALL ASN1Enc_ConferenceRequest(ASN1encoding_t enc, ConferenceRequest *val);
static int ASN1CALL ASN1Enc_CertSelectionCriteria(ASN1encoding_t enc, PCertSelectionCriteria *val);
static int ASN1CALL ASN1Enc_ConferenceResponse(ASN1encoding_t enc, ConferenceResponse *val);
static int ASN1CALL ASN1Enc_EndSessionCommand(ASN1encoding_t enc, EndSessionCommand *val);
static int ASN1CALL ASN1Enc_ConferenceCommand(ASN1encoding_t enc, ConferenceCommand *val);
static int ASN1CALL ASN1Enc_UserInputIndication_userInputSupportIndication(ASN1encoding_t enc, UserInputIndication_userInputSupportIndication *val);
static int ASN1CALL ASN1Enc_MiscellaneousIndication_type(ASN1encoding_t enc, MiscellaneousIndication_type *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type(ASN1encoding_t enc, MiscellaneousCommand_type *val);
static int ASN1CALL ASN1Enc_EncryptionCommand_encryptionAlgorithmID(ASN1encoding_t enc, EncryptionCommand_encryptionAlgorithmID *val);
static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard *val);
static int ASN1CALL ASN1Enc_RedundancyEncodingMode_secondaryEncoding(ASN1encoding_t enc, RedundancyEncodingMode_secondaryEncoding *val);
static int ASN1CALL ASN1Enc_H223ModeParameters_adaptationLayerType(ASN1encoding_t enc, H223ModeParameters_adaptationLayerType *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard *val);
static int ASN1CALL ASN1Enc_RTPPayloadType_payloadDescriptor(ASN1encoding_t enc, RTPPayloadType_payloadDescriptor *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard *val);
static int ASN1CALL ASN1Enc_H223LogicalChannelParameters_adaptationLayerType(ASN1encoding_t enc, H223LogicalChannelParameters_adaptationLayerType *val);
static int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData(ASN1encoding_t enc, PConferenceCapability_nonStandardData *val);
static int ASN1CALL ASN1Enc_UserInputCapability_nonStandard(ASN1encoding_t enc, UserInputCapability_nonStandard *val);
static int ASN1CALL ASN1Enc_DataProtocolCapability_v76wCompression(ASN1encoding_t enc, DataProtocolCapability_v76wCompression *val);
static int ASN1CALL ASN1Enc_H263Options_modeCombos(ASN1encoding_t enc, PH263Options_modeCombos *val);
static int ASN1CALL ASN1Enc_TransportCapability_qOSCapabilities(ASN1encoding_t enc, PTransportCapability_qOSCapabilities *val);
static int ASN1CALL ASN1Enc_NonStandardMessage(ASN1encoding_t enc, NonStandardMessage *val);
static int ASN1CALL ASN1Enc_RedundancyEncodingCapability(ASN1encoding_t enc, RedundancyEncodingCapability *val);
static int ASN1CALL ASN1Enc_H263VideoCapability(ASN1encoding_t enc, H263VideoCapability *val);
static int ASN1CALL ASN1Enc_EnhancementOptions(ASN1encoding_t enc, EnhancementOptions *val);
static int ASN1CALL ASN1Enc_DataProtocolCapability(ASN1encoding_t enc, DataProtocolCapability *val);
static int ASN1CALL ASN1Enc_EncryptionAuthenticationAndIntegrity(ASN1encoding_t enc, EncryptionAuthenticationAndIntegrity *val);
static int ASN1CALL ASN1Enc_EncryptionCapability(ASN1encoding_t enc, PEncryptionCapability *val);
static int ASN1CALL ASN1Enc_UserInputCapability(ASN1encoding_t enc, UserInputCapability *val);
static int ASN1CALL ASN1Enc_H223LogicalChannelParameters(ASN1encoding_t enc, H223LogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters(ASN1encoding_t enc, V76LogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_RTPPayloadType(ASN1encoding_t enc, RTPPayloadType *val);
static int ASN1CALL ASN1Enc_H245TransportAddress(ASN1encoding_t enc, H245TransportAddress *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters(ASN1encoding_t enc, H2250LogicalChannelAckParameters *val);
static int ASN1CALL ASN1Enc_H223ModeParameters(ASN1encoding_t enc, H223ModeParameters *val);
static int ASN1CALL ASN1Enc_RedundancyEncodingMode(ASN1encoding_t enc, RedundancyEncodingMode *val);
static int ASN1CALL ASN1Enc_VideoMode(ASN1encoding_t enc, VideoMode *val);
static int ASN1CALL ASN1Enc_EncryptionCommand(ASN1encoding_t enc, EncryptionCommand *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand(ASN1encoding_t enc, MiscellaneousCommand *val);
static int ASN1CALL ASN1Enc_MiscellaneousIndication(ASN1encoding_t enc, MiscellaneousIndication *val);
static int ASN1CALL ASN1Enc_MCLocationIndication(ASN1encoding_t enc, MCLocationIndication *val);
static int ASN1CALL ASN1Enc_UserInputIndication(ASN1encoding_t enc, UserInputIndication *val);
static int ASN1CALL ASN1Enc_DataApplicationCapability_application_nlpid(ASN1encoding_t enc, DataApplicationCapability_application_nlpid *val);
static int ASN1CALL ASN1Enc_DataApplicationCapability_application_t84(ASN1encoding_t enc, DataApplicationCapability_application_t84 *val);
static int ASN1CALL ASN1Enc_DataMode_application_nlpid(ASN1encoding_t enc, DataMode_application_nlpid *val);
static int ASN1CALL ASN1Enc_DataMode_application(ASN1encoding_t enc, DataMode_application *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_forwardMultiplexAckParameters(ASN1encoding_t enc, OpenLogicalChannelAck_forwardMultiplexAckParameters *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_mediaPacketization(ASN1encoding_t enc, H2250LogicalChannelParameters_mediaPacketization *val);
static int ASN1CALL ASN1Enc_NetworkAccessParameters_networkAddress(ASN1encoding_t enc, NetworkAccessParameters_networkAddress *val);
static int ASN1CALL ASN1Enc_DataApplicationCapability_application(ASN1encoding_t enc, DataApplicationCapability_application *val);
static int ASN1CALL ASN1Enc_EnhancementLayerInfo_spatialEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_spatialEnhancement *val);
static int ASN1CALL ASN1Enc_EnhancementLayerInfo_snrEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_snrEnhancement *val);
static int ASN1CALL ASN1Enc_MediaPacketizationCapability_rtpPayloadType(ASN1encoding_t enc, MediaPacketizationCapability_rtpPayloadType *val);
static int ASN1CALL ASN1Enc_H2250Capability_redundancyEncodingCapability(ASN1encoding_t enc, PH2250Capability_redundancyEncodingCapability *val);
static int ASN1CALL ASN1Enc_CommandMessage(ASN1encoding_t enc, CommandMessage *val);
static int ASN1CALL ASN1Enc_H235SecurityCapability(ASN1encoding_t enc, H235SecurityCapability *val);
static int ASN1CALL ASN1Enc_MediaPacketizationCapability(ASN1encoding_t enc, MediaPacketizationCapability *val);
static int ASN1CALL ASN1Enc_VideoCapability(ASN1encoding_t enc, VideoCapability *val);
static int ASN1CALL ASN1Enc_BEnhancementParameters(ASN1encoding_t enc, BEnhancementParameters *val);
static int ASN1CALL ASN1Enc_DataApplicationCapability(ASN1encoding_t enc, DataApplicationCapability *val);
static int ASN1CALL ASN1Enc_NetworkAccessParameters(ASN1encoding_t enc, NetworkAccessParameters *val);
static int ASN1CALL ASN1Enc_H2250ModeParameters(ASN1encoding_t enc, H2250ModeParameters *val);
static int ASN1CALL ASN1Enc_DataMode(ASN1encoding_t enc, DataMode *val);
static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_dataType(ASN1encoding_t enc, CommunicationModeTableEntry_dataType *val);
static int ASN1CALL ASN1Enc_H235Mode_mediaMode(ASN1encoding_t enc, H235Mode_mediaMode *val);
static int ASN1CALL ASN1Enc_H235Media_mediaType(ASN1encoding_t enc, H235Media_mediaType *val);
static int ASN1CALL ASN1Enc_EnhancementLayerInfo_bPictureEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_bPictureEnhancement *val);
static int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData(ASN1encoding_t enc, PMediaDistributionCapability_distributedData *val);
static int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData *val);
static int ASN1CALL ASN1Enc_Capability(ASN1encoding_t enc, Capability *val);
static int ASN1CALL ASN1Enc_H2250Capability(ASN1encoding_t enc, H2250Capability *val);
static int ASN1CALL ASN1Enc_H235Media(ASN1encoding_t enc, H235Media *val);
static int ASN1CALL ASN1Enc_H235Mode(ASN1encoding_t enc, H235Mode *val);
static int ASN1CALL ASN1Enc_ModeElement_type(ASN1encoding_t enc, ModeElement_type *val);
static int ASN1CALL ASN1Enc_CapabilityTableEntry(ASN1encoding_t enc, CapabilityTableEntry *val);
static int ASN1CALL ASN1Enc_MultiplexCapability(ASN1encoding_t enc, MultiplexCapability *val);
static int ASN1CALL ASN1Enc_DataType(ASN1encoding_t enc, DataType *val);
static int ASN1CALL ASN1Enc_RedundancyEncoding(ASN1encoding_t enc, RedundancyEncoding *val);
static int ASN1CALL ASN1Enc_ModeElement(ASN1encoding_t enc, ModeElement *val);
static int ASN1CALL ASN1Enc_CommunicationModeTableEntry(ASN1encoding_t enc, CommunicationModeTableEntry *val);
static int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable *val);
static int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySet(ASN1encoding_t enc, TerminalCapabilitySet *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters(ASN1encoding_t enc, H2250LogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_ModeDescription(ASN1encoding_t enc, ModeDescription *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Enc_RequestMode_requestedModes(ASN1encoding_t enc, PRequestMode_requestedModes *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannelAck_reverseLogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannel_reverseLogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannel_forwardLogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel(ASN1encoding_t enc, OpenLogicalChannel *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelAck(ASN1encoding_t enc, OpenLogicalChannelAck *val);
static int ASN1CALL ASN1Enc_RequestMessage(ASN1encoding_t enc, RequestMessage *val);
static int ASN1CALL ASN1Enc_ResponseMessage(ASN1encoding_t enc, ResponseMessage *val);
static int ASN1CALL ASN1Enc_FastConnectOLC(ASN1encoding_t enc, FastConnectOLC *val);
static int ASN1CALL ASN1Enc_FunctionNotUnderstood(ASN1encoding_t enc, FunctionNotUnderstood *val);
static int ASN1CALL ASN1Enc_IndicationMessage(ASN1encoding_t enc, IndicationMessage *val);
static int ASN1CALL ASN1Enc_MultimediaSystemControlMessage(ASN1encoding_t enc, MultimediaSystemControlMessage *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1_errorCorrection(ASN1decoding_t dec, NewATMVCIndication_aal_aal1_errorCorrection *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1_clockRecovery(ASN1decoding_t dec, NewATMVCIndication_aal_aal1_clockRecovery *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(ASN1decoding_t dec, MiscellaneousCommand_type_progressiveRefinementStart_repeatCount *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode_eRM_recovery(ASN1decoding_t dec, V76LogicalChannelParameters_mode_eRM_recovery *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_extendedPAR_Set *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI_customPCF_Set(ASN1decoding_t dec, CustomPictureFormat_mPI_customPCF_Set *val);
static int ASN1CALL ASN1Dec_VCCapability_availableBitRates_type_rangeOfBitRates(ASN1decoding_t dec, VCCapability_availableBitRates_type_rangeOfBitRates *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(ASN1decoding_t dec, TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *val);
static int ASN1CALL ASN1Dec_VCCapability_availableBitRates_type(ASN1decoding_t dec, VCCapability_availableBitRates_type *val);
static int ASN1CALL ASN1Dec_H223Capability_h223MultiplexTableCapability_enhanced(ASN1decoding_t dec, H223Capability_h223MultiplexTableCapability_enhanced *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI_customPCF(ASN1decoding_t dec, CustomPictureFormat_mPI_customPCF *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_extendedPAR *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val);
static int ASN1CALL ASN1Dec_H223LogicalChannelParameters_adaptationLayerType_al3(ASN1decoding_t dec, H223LogicalChannelParameters_adaptationLayerType_al3 *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode_eRM(ASN1decoding_t dec, V76LogicalChannelParameters_mode_eRM *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_routing(ASN1decoding_t dec, UnicastAddress_iPSourceRouteAddress_routing *val);
static int ASN1CALL ASN1Dec_H223ModeParameters_adaptationLayerType_al3(ASN1decoding_t dec, H223ModeParameters_adaptationLayerType_al3 *val);
static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(ASN1decoding_t dec, SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val);
static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart(ASN1decoding_t dec, MiscellaneousCommand_type_progressiveRefinementStart *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_videoFastUpdateMB(ASN1decoding_t dec, MiscellaneousCommand_type_videoFastUpdateMB *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_videoFastUpdateGOB(ASN1decoding_t dec, MiscellaneousCommand_type_videoFastUpdateGOB *val);
static int ASN1CALL ASN1Dec_MiscellaneousIndication_type_videoNotDecodedMBs(ASN1decoding_t dec, MiscellaneousIndication_type_videoNotDecodedMBs *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal5(ASN1decoding_t dec, NewATMVCIndication_aal_aal5 *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1(ASN1decoding_t dec, NewATMVCIndication_aal_aal1 *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_reverseParameters_multiplex(ASN1decoding_t dec, NewATMVCIndication_reverseParameters_multiplex *val);
static int ASN1CALL ASN1Dec_UserInputIndication_signal_rtp(ASN1decoding_t dec, UserInputIndication_signal_rtp *val);
static int ASN1CALL ASN1Dec_UserInputIndication_signalUpdate_rtp(ASN1decoding_t dec, UserInputIndication_signalUpdate_rtp *val);
static int ASN1CALL ASN1Dec_UserInputIndication_signalUpdate(ASN1decoding_t dec, UserInputIndication_signalUpdate *val);
static int ASN1CALL ASN1Dec_UserInputIndication_signal(ASN1decoding_t dec, UserInputIndication_signal *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_reverseParameters(ASN1decoding_t dec, NewATMVCIndication_reverseParameters *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_multiplex(ASN1decoding_t dec, NewATMVCIndication_multiplex *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal(ASN1decoding_t dec, NewATMVCIndication_aal *val);
static int ASN1CALL ASN1Dec_JitterIndication_scope(ASN1decoding_t dec, JitterIndication_scope *val);
static int ASN1CALL ASN1Dec_FunctionNotSupported_cause(ASN1decoding_t dec, FunctionNotSupported_cause *val);
static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration_h223AnnexADoubleFlag(ASN1decoding_t dec, H223MultiplexReconfiguration_h223AnnexADoubleFlag *val);
static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration_h223ModeChange(ASN1decoding_t dec, H223MultiplexReconfiguration_h223ModeChange *val);
static int ASN1CALL ASN1Dec_EndSessionCommand_isdnOptions(ASN1decoding_t dec, EndSessionCommand_isdnOptions *val);
static int ASN1CALL ASN1Dec_EndSessionCommand_gstnOptions(ASN1decoding_t dec, EndSessionCommand_gstnOptions *val);
static int ASN1CALL ASN1Dec_FlowControlCommand_restriction(ASN1decoding_t dec, FlowControlCommand_restriction *val);
static int ASN1CALL ASN1Dec_FlowControlCommand_scope(ASN1decoding_t dec, FlowControlCommand_scope *val);
static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest(ASN1decoding_t dec, SendTerminalCapabilitySet_specificRequest *val);
static int ASN1CALL ASN1Dec_RemoteMCResponse_reject(ASN1decoding_t dec, RemoteMCResponse_reject *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_sendThisSourceResponse(ASN1decoding_t dec, ConferenceResponse_sendThisSourceResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_makeTerminalBroadcasterResponse(ASN1decoding_t dec, ConferenceResponse_makeTerminalBroadcasterResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_broadcastMyLogicalChannelResponse(ASN1decoding_t dec, ConferenceResponse_broadcastMyLogicalChannelResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_extensionAddressResponse(ASN1decoding_t dec, ConferenceResponse_extensionAddressResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_makeMeChairResponse(ASN1decoding_t dec, ConferenceResponse_makeMeChairResponse *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopReject_cause(ASN1decoding_t dec, MaintenanceLoopReject_cause *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopReject_type(ASN1decoding_t dec, MaintenanceLoopReject_type *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopAck_type(ASN1decoding_t dec, MaintenanceLoopAck_type *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopRequest_type(ASN1decoding_t dec, MaintenanceLoopRequest_type *val);
static int ASN1CALL ASN1Dec_G7231AnnexCMode_g723AnnexCAudioMode(ASN1decoding_t dec, G7231AnnexCMode_g723AnnexCAudioMode *val);
static int ASN1CALL ASN1Dec_IS13818AudioMode_multichannelType(ASN1decoding_t dec, IS13818AudioMode_multichannelType *val);
static int ASN1CALL ASN1Dec_IS13818AudioMode_audioSampling(ASN1decoding_t dec, IS13818AudioMode_audioSampling *val);
static int ASN1CALL ASN1Dec_IS13818AudioMode_audioLayer(ASN1decoding_t dec, IS13818AudioMode_audioLayer *val);
static int ASN1CALL ASN1Dec_IS11172AudioMode_multichannelType(ASN1decoding_t dec, IS11172AudioMode_multichannelType *val);
static int ASN1CALL ASN1Dec_IS11172AudioMode_audioSampling(ASN1decoding_t dec, IS11172AudioMode_audioSampling *val);
static int ASN1CALL ASN1Dec_IS11172AudioMode_audioLayer(ASN1decoding_t dec, IS11172AudioMode_audioLayer *val);
static int ASN1CALL ASN1Dec_AudioMode_g7231(ASN1decoding_t dec, AudioMode_g7231 *val);
static int ASN1CALL ASN1Dec_H263VideoMode_resolution(ASN1decoding_t dec, H263VideoMode_resolution *val);
static int ASN1CALL ASN1Dec_H262VideoMode_profileAndLevel(ASN1decoding_t dec, H262VideoMode_profileAndLevel *val);
static int ASN1CALL ASN1Dec_H261VideoMode_resolution(ASN1decoding_t dec, H261VideoMode_resolution *val);
static int ASN1CALL ASN1Dec_RequestModeReject_cause(ASN1decoding_t dec, RequestModeReject_cause *val);
static int ASN1CALL ASN1Dec_RequestModeAck_response(ASN1decoding_t dec, RequestModeAck_response *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryRelease_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryRelease_entryNumbers *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryRejectionDescriptions_cause(ASN1decoding_t dec, RequestMultiplexEntryRejectionDescriptions_cause *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryReject_entryNumbers *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryAck_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryAck_entryNumbers *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntry_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntry_entryNumbers *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendRelease_multiplexTableEntryNumber(ASN1decoding_t dec, MultiplexEntrySendRelease_multiplexTableEntryNumber *val);
static int ASN1CALL ASN1Dec_MultiplexEntryRejectionDescriptions_cause(ASN1decoding_t dec, MultiplexEntryRejectionDescriptions_cause *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendAck_multiplexTableEntryNumber(ASN1decoding_t dec, MultiplexEntrySendAck_multiplexTableEntryNumber *val);
static int ASN1CALL ASN1Dec_MultiplexElement_repeatCount(ASN1decoding_t dec, MultiplexElement_repeatCount *val);
static int ASN1CALL ASN1Dec_MultiplexElement_type(ASN1decoding_t dec, MultiplexElement_type *val);
static int ASN1CALL ASN1Dec_RequestChannelCloseReject_cause(ASN1decoding_t dec, RequestChannelCloseReject_cause *val);
static int ASN1CALL ASN1Dec_RequestChannelClose_reason(ASN1decoding_t dec, RequestChannelClose_reason *val);
static int ASN1CALL ASN1Dec_CloseLogicalChannel_reason(ASN1decoding_t dec, CloseLogicalChannel_reason *val);
static int ASN1CALL ASN1Dec_CloseLogicalChannel_source(ASN1decoding_t dec, CloseLogicalChannel_source *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelReject_cause(ASN1decoding_t dec, OpenLogicalChannelReject_cause *val);
static int ASN1CALL ASN1Dec_MulticastAddress_iP6Address(ASN1decoding_t dec, MulticastAddress_iP6Address *val);
static int ASN1CALL ASN1Dec_MulticastAddress_iPAddress(ASN1decoding_t dec, MulticastAddress_iPAddress *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress(ASN1decoding_t dec, UnicastAddress_iPSourceRouteAddress *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iP6Address(ASN1decoding_t dec, UnicastAddress_iP6Address *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPXAddress(ASN1decoding_t dec, UnicastAddress_iPXAddress *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPAddress(ASN1decoding_t dec, UnicastAddress_iPAddress *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode(ASN1decoding_t dec, V76LogicalChannelParameters_mode *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_suspendResume(ASN1decoding_t dec, V76LogicalChannelParameters_suspendResume *val);
static int ASN1CALL ASN1Dec_H223AnnexCArqParameters_numberOfRetransmissions(ASN1decoding_t dec, H223AnnexCArqParameters_numberOfRetransmissions *val);
static int ASN1CALL ASN1Dec_H223AL3MParameters_crcLength(ASN1decoding_t dec, H223AL3MParameters_crcLength *val);
static int ASN1CALL ASN1Dec_H223AL3MParameters_headerFormat(ASN1decoding_t dec, H223AL3MParameters_headerFormat *val);
static int ASN1CALL ASN1Dec_H223AL2MParameters_headerFEC(ASN1decoding_t dec, H223AL2MParameters_headerFEC *val);
static int ASN1CALL ASN1Dec_H223AL1MParameters_crcLength(ASN1decoding_t dec, H223AL1MParameters_crcLength *val);
static int ASN1CALL ASN1Dec_H223AL1MParameters_headerFEC(ASN1decoding_t dec, H223AL1MParameters_headerFEC *val);
static int ASN1CALL ASN1Dec_H223AL1MParameters_transferMode(ASN1decoding_t dec, H223AL1MParameters_transferMode *val);
static int ASN1CALL ASN1Dec_Q2931Address_address(ASN1decoding_t dec, Q2931Address_address *val);
static int ASN1CALL ASN1Dec_NetworkAccessParameters_t120SetupProcedure(ASN1decoding_t dec, NetworkAccessParameters_t120SetupProcedure *val);
static int ASN1CALL ASN1Dec_NetworkAccessParameters_distribution(ASN1decoding_t dec, NetworkAccessParameters_distribution *val);
static int ASN1CALL ASN1Dec_T84Profile_t84Restricted(ASN1decoding_t dec, T84Profile_t84Restricted *val);
static int ASN1CALL ASN1Dec_G7231AnnexCCapability_g723AnnexCAudioMode(ASN1decoding_t dec, G7231AnnexCCapability_g723AnnexCAudioMode *val);
static int ASN1CALL ASN1Dec_AudioCapability_g7231(ASN1decoding_t dec, AudioCapability_g7231 *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI(ASN1decoding_t dec, CustomPictureFormat_mPI *val);
static int ASN1CALL ASN1Dec_RefPictureSelection_videoBackChannelSend(ASN1decoding_t dec, RefPictureSelection_videoBackChannelSend *val);
static int ASN1CALL ASN1Dec_RefPictureSelection_additionalPictureMemory(ASN1decoding_t dec, RefPictureSelection_additionalPictureMemory *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyFrameMapping_frameSequence(ASN1decoding_t dec, RTPH263VideoRedundancyFrameMapping_frameSequence *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_containedThreads(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding_containedThreads *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding_frameToThreadMapping *val);
static int ASN1CALL ASN1Dec_RedundancyEncodingCapability_secondaryEncoding(ASN1decoding_t dec, PRedundancyEncodingCapability_secondaryEncoding *val);
static int ASN1CALL ASN1Dec_H2250Capability_mcCapability(ASN1decoding_t dec, H2250Capability_mcCapability *val);
static int ASN1CALL ASN1Dec_H223Capability_mobileOperationTransmitCapability(ASN1decoding_t dec, H223Capability_mobileOperationTransmitCapability *val);
static int ASN1CALL ASN1Dec_H223Capability_h223MultiplexTableCapability(ASN1decoding_t dec, H223Capability_h223MultiplexTableCapability *val);
static int ASN1CALL ASN1Dec_VCCapability_availableBitRates(ASN1decoding_t dec, VCCapability_availableBitRates *val);
static int ASN1CALL ASN1Dec_VCCapability_aal5(ASN1decoding_t dec, VCCapability_aal5 *val);
static int ASN1CALL ASN1Dec_VCCapability_aal1(ASN1decoding_t dec, VCCapability_aal1 *val);
static int ASN1CALL ASN1Dec_Capability_h233EncryptionReceiveCapability(ASN1decoding_t dec, Capability_h233EncryptionReceiveCapability *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject_cause(ASN1decoding_t dec, TerminalCapabilitySetReject_cause *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationReject_cause(ASN1decoding_t dec, MasterSlaveDeterminationReject_cause *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationAck_decision(ASN1decoding_t dec, MasterSlaveDeterminationAck_decision *val);
static int ASN1CALL ASN1Dec_NonStandardIdentifier_h221NonStandard(ASN1decoding_t dec, NonStandardIdentifier_h221NonStandard *val);
static int ASN1CALL ASN1Dec_NonStandardIdentifier(ASN1decoding_t dec, NonStandardIdentifier *val);
static int ASN1CALL ASN1Dec_MasterSlaveDetermination(ASN1decoding_t dec, MasterSlaveDetermination *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationAck(ASN1decoding_t dec, MasterSlaveDeterminationAck *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationReject(ASN1decoding_t dec, MasterSlaveDeterminationReject *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationRelease(ASN1decoding_t dec, MasterSlaveDeterminationRelease *val);
static int ASN1CALL ASN1Dec_CapabilityDescriptor(ASN1decoding_t dec, CapabilityDescriptor *val);
static int ASN1CALL ASN1Dec_AlternativeCapabilitySet(ASN1decoding_t dec, AlternativeCapabilitySet *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetAck(ASN1decoding_t dec, TerminalCapabilitySetAck *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject(ASN1decoding_t dec, TerminalCapabilitySetReject *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetRelease(ASN1decoding_t dec, TerminalCapabilitySetRelease *val);
static int ASN1CALL ASN1Dec_H222Capability(ASN1decoding_t dec, H222Capability *val);
static int ASN1CALL ASN1Dec_VCCapability(ASN1decoding_t dec, VCCapability *val);
static int ASN1CALL ASN1Dec_H223AnnexCCapability(ASN1decoding_t dec, H223AnnexCCapability *val);
static int ASN1CALL ASN1Dec_V75Capability(ASN1decoding_t dec, V75Capability *val);
static int ASN1CALL ASN1Dec_QOSMode(ASN1decoding_t dec, QOSMode *val);
static int ASN1CALL ASN1Dec_ATMParameters(ASN1decoding_t dec, ATMParameters *val);
static int ASN1CALL ASN1Dec_MediaTransportType(ASN1decoding_t dec, MediaTransportType *val);
static int ASN1CALL ASN1Dec_MediaChannelCapability(ASN1decoding_t dec, MediaChannelCapability *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyFrameMapping(ASN1decoding_t dec, RTPH263VideoRedundancyFrameMapping *val);
static int ASN1CALL ASN1Dec_MultipointCapability(ASN1decoding_t dec, MultipointCapability *val);
static int ASN1CALL ASN1Dec_MediaDistributionCapability(ASN1decoding_t dec, MediaDistributionCapability *val);
static int ASN1CALL ASN1Dec_H261VideoCapability(ASN1decoding_t dec, H261VideoCapability *val);
static int ASN1CALL ASN1Dec_H262VideoCapability(ASN1decoding_t dec, H262VideoCapability *val);
static int ASN1CALL ASN1Dec_EnhancementLayerInfo(ASN1decoding_t dec, EnhancementLayerInfo *val);
static int ASN1CALL ASN1Dec_TransparencyParameters(ASN1decoding_t dec, TransparencyParameters *val);
static int ASN1CALL ASN1Dec_RefPictureSelection(ASN1decoding_t dec, RefPictureSelection *val);
static int ASN1CALL ASN1Dec_CustomPictureClockFrequency(ASN1decoding_t dec, CustomPictureClockFrequency *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat(ASN1decoding_t dec, CustomPictureFormat *val);
static int ASN1CALL ASN1Dec_H263ModeComboFlags(ASN1decoding_t dec, H263ModeComboFlags *val);
static int ASN1CALL ASN1Dec_IS11172VideoCapability(ASN1decoding_t dec, IS11172VideoCapability *val);
static int ASN1CALL ASN1Dec_G7231AnnexCCapability(ASN1decoding_t dec, G7231AnnexCCapability *val);
static int ASN1CALL ASN1Dec_IS11172AudioCapability(ASN1decoding_t dec, IS11172AudioCapability *val);
static int ASN1CALL ASN1Dec_IS13818AudioCapability(ASN1decoding_t dec, IS13818AudioCapability *val);
static int ASN1CALL ASN1Dec_GSMAudioCapability(ASN1decoding_t dec, GSMAudioCapability *val);
static int ASN1CALL ASN1Dec_V42bis(ASN1decoding_t dec, V42bis *val);
static int ASN1CALL ASN1Dec_T84Profile(ASN1decoding_t dec, T84Profile *val);
static int ASN1CALL ASN1Dec_ConferenceCapability(ASN1decoding_t dec, ConferenceCapability *val);
static int ASN1CALL ASN1Dec_Q2931Address(ASN1decoding_t dec, Q2931Address *val);
static int ASN1CALL ASN1Dec_V75Parameters(ASN1decoding_t dec, V75Parameters *val);
static int ASN1CALL ASN1Dec_H222LogicalChannelParameters(ASN1decoding_t dec, H222LogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_H223AL2MParameters(ASN1decoding_t dec, H223AL2MParameters *val);
static int ASN1CALL ASN1Dec_H223AnnexCArqParameters(ASN1decoding_t dec, H223AnnexCArqParameters *val);
static int ASN1CALL ASN1Dec_CRCLength(ASN1decoding_t dec, CRCLength *val);
static int ASN1CALL ASN1Dec_EscrowData(ASN1decoding_t dec, EscrowData *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelReject(ASN1decoding_t dec, OpenLogicalChannelReject *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelConfirm(ASN1decoding_t dec, OpenLogicalChannelConfirm *val);
static int ASN1CALL ASN1Dec_CloseLogicalChannel(ASN1decoding_t dec, CloseLogicalChannel *val);
static int ASN1CALL ASN1Dec_CloseLogicalChannelAck(ASN1decoding_t dec, CloseLogicalChannelAck *val);
static int ASN1CALL ASN1Dec_RequestChannelCloseAck(ASN1decoding_t dec, RequestChannelCloseAck *val);
static int ASN1CALL ASN1Dec_RequestChannelCloseReject(ASN1decoding_t dec, RequestChannelCloseReject *val);
static int ASN1CALL ASN1Dec_RequestChannelCloseRelease(ASN1decoding_t dec, RequestChannelCloseRelease *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySend(ASN1decoding_t dec, MultiplexEntrySend *val);
static int ASN1CALL ASN1Dec_MultiplexElement(ASN1decoding_t dec, MultiplexElement *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendAck(ASN1decoding_t dec, MultiplexEntrySendAck *val);
static int ASN1CALL ASN1Dec_MultiplexEntryRejectionDescriptions(ASN1decoding_t dec, MultiplexEntryRejectionDescriptions *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendRelease(ASN1decoding_t dec, MultiplexEntrySendRelease *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntry(ASN1decoding_t dec, RequestMultiplexEntry *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryAck(ASN1decoding_t dec, RequestMultiplexEntryAck *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryRejectionDescriptions(ASN1decoding_t dec, RequestMultiplexEntryRejectionDescriptions *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryRelease(ASN1decoding_t dec, RequestMultiplexEntryRelease *val);
static int ASN1CALL ASN1Dec_RequestMode(ASN1decoding_t dec, RequestMode *val);
static int ASN1CALL ASN1Dec_RequestModeAck(ASN1decoding_t dec, RequestModeAck *val);
static int ASN1CALL ASN1Dec_RequestModeReject(ASN1decoding_t dec, RequestModeReject *val);
static int ASN1CALL ASN1Dec_RequestModeRelease(ASN1decoding_t dec, RequestModeRelease *val);
static int ASN1CALL ASN1Dec_V76ModeParameters(ASN1decoding_t dec, V76ModeParameters *val);
static int ASN1CALL ASN1Dec_H261VideoMode(ASN1decoding_t dec, H261VideoMode *val);
static int ASN1CALL ASN1Dec_H262VideoMode(ASN1decoding_t dec, H262VideoMode *val);
static int ASN1CALL ASN1Dec_IS11172VideoMode(ASN1decoding_t dec, IS11172VideoMode *val);
static int ASN1CALL ASN1Dec_IS11172AudioMode(ASN1decoding_t dec, IS11172AudioMode *val);
static int ASN1CALL ASN1Dec_IS13818AudioMode(ASN1decoding_t dec, IS13818AudioMode *val);
static int ASN1CALL ASN1Dec_G7231AnnexCMode(ASN1decoding_t dec, G7231AnnexCMode *val);
static int ASN1CALL ASN1Dec_RoundTripDelayRequest(ASN1decoding_t dec, RoundTripDelayRequest *val);
static int ASN1CALL ASN1Dec_RoundTripDelayResponse(ASN1decoding_t dec, RoundTripDelayResponse *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopRequest(ASN1decoding_t dec, MaintenanceLoopRequest *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopAck(ASN1decoding_t dec, MaintenanceLoopAck *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopReject(ASN1decoding_t dec, MaintenanceLoopReject *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopOffCommand(ASN1decoding_t dec, MaintenanceLoopOffCommand *val);
static int ASN1CALL ASN1Dec_CommunicationModeCommand(ASN1decoding_t dec, CommunicationModeCommand *val);
static int ASN1CALL ASN1Dec_CommunicationModeRequest(ASN1decoding_t dec, CommunicationModeRequest *val);
static int ASN1CALL ASN1Dec_CommunicationModeResponse(ASN1decoding_t dec, CommunicationModeResponse *val);
static int ASN1CALL ASN1Dec_Criteria(ASN1decoding_t dec, Criteria *val);
static int ASN1CALL ASN1Dec_TerminalLabel(ASN1decoding_t dec, TerminalLabel *val);
static int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse(ASN1decoding_t dec, RequestAllTerminalIDsResponse *val);
static int ASN1CALL ASN1Dec_TerminalInformation(ASN1decoding_t dec, TerminalInformation *val);
static int ASN1CALL ASN1Dec_RemoteMCRequest(ASN1decoding_t dec, RemoteMCRequest *val);
static int ASN1CALL ASN1Dec_RemoteMCResponse(ASN1decoding_t dec, RemoteMCResponse *val);
static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet(ASN1decoding_t dec, SendTerminalCapabilitySet *val);
static int ASN1CALL ASN1Dec_FlowControlCommand(ASN1decoding_t dec, FlowControlCommand *val);
static int ASN1CALL ASN1Dec_SubstituteConferenceIDCommand(ASN1decoding_t dec, SubstituteConferenceIDCommand *val);
static int ASN1CALL ASN1Dec_KeyProtectionMethod(ASN1decoding_t dec, KeyProtectionMethod *val);
static int ASN1CALL ASN1Dec_EncryptionUpdateRequest(ASN1decoding_t dec, EncryptionUpdateRequest *val);
static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration(ASN1decoding_t dec, H223MultiplexReconfiguration *val);
static int ASN1CALL ASN1Dec_FunctionNotSupported(ASN1decoding_t dec, FunctionNotSupported *val);
static int ASN1CALL ASN1Dec_TerminalYouAreSeeingInSubPictureNumber(ASN1decoding_t dec, TerminalYouAreSeeingInSubPictureNumber *val);
static int ASN1CALL ASN1Dec_VideoIndicateCompose(ASN1decoding_t dec, VideoIndicateCompose *val);
static int ASN1CALL ASN1Dec_ConferenceIndication(ASN1decoding_t dec, ConferenceIndication *val);
static int ASN1CALL ASN1Dec_JitterIndication(ASN1decoding_t dec, JitterIndication *val);
static int ASN1CALL ASN1Dec_H223SkewIndication(ASN1decoding_t dec, H223SkewIndication *val);
static int ASN1CALL ASN1Dec_H2250MaximumSkewIndication(ASN1decoding_t dec, H2250MaximumSkewIndication *val);
static int ASN1CALL ASN1Dec_VendorIdentification(ASN1decoding_t dec, VendorIdentification *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication(ASN1decoding_t dec, NewATMVCIndication *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(ASN1decoding_t dec, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val);
static int ASN1CALL ASN1Dec_MultiplexElement_type_subElementList(ASN1decoding_t dec, PMultiplexElement_type_subElementList *val);
static int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation(ASN1decoding_t dec, PRequestAllTerminalIDsResponse_terminalInformation *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_terminalCertificateResponse(ASN1decoding_t dec, ConferenceResponse_terminalCertificateResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_chairTokenOwnerResponse(ASN1decoding_t dec, ConferenceResponse_chairTokenOwnerResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_terminalListResponse(ASN1decoding_t dec, ConferenceResponse_terminalListResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_passwordResponse(ASN1decoding_t dec, ConferenceResponse_passwordResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_conferenceIDResponse(ASN1decoding_t dec, ConferenceResponse_conferenceIDResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_terminalIDResponse(ASN1decoding_t dec, ConferenceResponse_terminalIDResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_mCTerminalIDResponse(ASN1decoding_t dec, ConferenceResponse_mCTerminalIDResponse *val);
static int ASN1CALL ASN1Dec_ConferenceRequest_requestTerminalCertificate(ASN1decoding_t dec, ConferenceRequest_requestTerminalCertificate *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject_rejectionDescriptions(ASN1decoding_t dec, RequestMultiplexEntryReject_rejectionDescriptions *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendReject_rejectionDescriptions(ASN1decoding_t dec, MultiplexEntrySendReject_rejectionDescriptions *val);
static int ASN1CALL ASN1Dec_MultiplexEntryDescriptor_elementList(ASN1decoding_t dec, MultiplexEntryDescriptor_elementList *val);
static int ASN1CALL ASN1Dec_EncryptionSync_escrowentry(ASN1decoding_t dec, PEncryptionSync_escrowentry *val);
static int ASN1CALL ASN1Dec_H223AL3MParameters_arqType(ASN1decoding_t dec, H223AL3MParameters_arqType *val);
static int ASN1CALL ASN1Dec_H223AL1MParameters_arqType(ASN1decoding_t dec, H223AL1MParameters_arqType *val);
static int ASN1CALL ASN1Dec_H263VideoModeCombos_h263VideoCoupledModes(ASN1decoding_t dec, H263VideoModeCombos_h263VideoCoupledModes *val);
static int ASN1CALL ASN1Dec_H263Options_customPictureFormat(ASN1decoding_t dec, PH263Options_customPictureFormat *val);
static int ASN1CALL ASN1Dec_H263Options_customPictureClockFrequency(ASN1decoding_t dec, PH263Options_customPictureClockFrequency *val);
static int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability *val);
static int ASN1CALL ASN1Dec_TransportCapability_mediaChannelCapabilities(ASN1decoding_t dec, TransportCapability_mediaChannelCapabilities *val);
static int ASN1CALL ASN1Dec_H222Capability_vcCapability(ASN1decoding_t dec, PH222Capability_vcCapability *val);
static int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityDescriptors(ASN1decoding_t dec, TerminalCapabilitySet_capabilityDescriptors *val);
static int ASN1CALL ASN1Dec_NonStandardParameter(ASN1decoding_t dec, NonStandardParameter *val);
static int ASN1CALL ASN1Dec_H223Capability(ASN1decoding_t dec, H223Capability *val);
static int ASN1CALL ASN1Dec_V76Capability(ASN1decoding_t dec, V76Capability *val);
static int ASN1CALL ASN1Dec_RSVPParameters(ASN1decoding_t dec, RSVPParameters *val);
static int ASN1CALL ASN1Dec_QOSCapability(ASN1decoding_t dec, QOSCapability *val);
static int ASN1CALL ASN1Dec_TransportCapability(ASN1decoding_t dec, TransportCapability *val);
static int ASN1CALL ASN1Dec_RedundancyEncodingMethod(ASN1decoding_t dec, RedundancyEncodingMethod *val);
static int ASN1CALL ASN1Dec_H263Options(ASN1decoding_t dec, H263Options *val);
static int ASN1CALL ASN1Dec_H263VideoModeCombos(ASN1decoding_t dec, H263VideoModeCombos *val);
static int ASN1CALL ASN1Dec_AudioCapability(ASN1decoding_t dec, AudioCapability *val);
static int ASN1CALL ASN1Dec_CompressionType(ASN1decoding_t dec, CompressionType *val);
static int ASN1CALL ASN1Dec_MediaEncryptionAlgorithm(ASN1decoding_t dec, MediaEncryptionAlgorithm *val);
static int ASN1CALL ASN1Dec_AuthenticationCapability(ASN1decoding_t dec, AuthenticationCapability *val);
static int ASN1CALL ASN1Dec_IntegrityCapability(ASN1decoding_t dec, IntegrityCapability *val);
static int ASN1CALL ASN1Dec_H223AL1MParameters(ASN1decoding_t dec, H223AL1MParameters *val);
static int ASN1CALL ASN1Dec_H223AL3MParameters(ASN1decoding_t dec, H223AL3MParameters *val);
static int ASN1CALL ASN1Dec_V76HDLCParameters(ASN1decoding_t dec, V76HDLCParameters *val);
static int ASN1CALL ASN1Dec_UnicastAddress(ASN1decoding_t dec, UnicastAddress *val);
static int ASN1CALL ASN1Dec_MulticastAddress(ASN1decoding_t dec, MulticastAddress *val);
static int ASN1CALL ASN1Dec_EncryptionSync(ASN1decoding_t dec, EncryptionSync *val);
static int ASN1CALL ASN1Dec_RequestChannelClose(ASN1decoding_t dec, RequestChannelClose *val);
static int ASN1CALL ASN1Dec_MultiplexEntryDescriptor(ASN1decoding_t dec, MultiplexEntryDescriptor *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendReject(ASN1decoding_t dec, MultiplexEntrySendReject *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject(ASN1decoding_t dec, RequestMultiplexEntryReject *val);
static int ASN1CALL ASN1Dec_H263VideoMode(ASN1decoding_t dec, H263VideoMode *val);
static int ASN1CALL ASN1Dec_AudioMode(ASN1decoding_t dec, AudioMode *val);
static int ASN1CALL ASN1Dec_EncryptionMode(ASN1decoding_t dec, EncryptionMode *val);
static int ASN1CALL ASN1Dec_ConferenceRequest(ASN1decoding_t dec, ConferenceRequest *val);
static int ASN1CALL ASN1Dec_CertSelectionCriteria(ASN1decoding_t dec, PCertSelectionCriteria *val);
static int ASN1CALL ASN1Dec_ConferenceResponse(ASN1decoding_t dec, ConferenceResponse *val);
static int ASN1CALL ASN1Dec_EndSessionCommand(ASN1decoding_t dec, EndSessionCommand *val);
static int ASN1CALL ASN1Dec_ConferenceCommand(ASN1decoding_t dec, ConferenceCommand *val);
static int ASN1CALL ASN1Dec_UserInputIndication_userInputSupportIndication(ASN1decoding_t dec, UserInputIndication_userInputSupportIndication *val);
static int ASN1CALL ASN1Dec_MiscellaneousIndication_type(ASN1decoding_t dec, MiscellaneousIndication_type *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type(ASN1decoding_t dec, MiscellaneousCommand_type *val);
static int ASN1CALL ASN1Dec_EncryptionCommand_encryptionAlgorithmID(ASN1decoding_t dec, EncryptionCommand_encryptionAlgorithmID *val);
static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard *val);
static int ASN1CALL ASN1Dec_RedundancyEncodingMode_secondaryEncoding(ASN1decoding_t dec, RedundancyEncodingMode_secondaryEncoding *val);
static int ASN1CALL ASN1Dec_H223ModeParameters_adaptationLayerType(ASN1decoding_t dec, H223ModeParameters_adaptationLayerType *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard *val);
static int ASN1CALL ASN1Dec_RTPPayloadType_payloadDescriptor(ASN1decoding_t dec, RTPPayloadType_payloadDescriptor *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard *val);
static int ASN1CALL ASN1Dec_H223LogicalChannelParameters_adaptationLayerType(ASN1decoding_t dec, H223LogicalChannelParameters_adaptationLayerType *val);
static int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData(ASN1decoding_t dec, PConferenceCapability_nonStandardData *val);
static int ASN1CALL ASN1Dec_UserInputCapability_nonStandard(ASN1decoding_t dec, UserInputCapability_nonStandard *val);
static int ASN1CALL ASN1Dec_DataProtocolCapability_v76wCompression(ASN1decoding_t dec, DataProtocolCapability_v76wCompression *val);
static int ASN1CALL ASN1Dec_H263Options_modeCombos(ASN1decoding_t dec, PH263Options_modeCombos *val);
static int ASN1CALL ASN1Dec_TransportCapability_qOSCapabilities(ASN1decoding_t dec, PTransportCapability_qOSCapabilities *val);
static int ASN1CALL ASN1Dec_NonStandardMessage(ASN1decoding_t dec, NonStandardMessage *val);
static int ASN1CALL ASN1Dec_RedundancyEncodingCapability(ASN1decoding_t dec, RedundancyEncodingCapability *val);
static int ASN1CALL ASN1Dec_H263VideoCapability(ASN1decoding_t dec, H263VideoCapability *val);
static int ASN1CALL ASN1Dec_EnhancementOptions(ASN1decoding_t dec, EnhancementOptions *val);
static int ASN1CALL ASN1Dec_DataProtocolCapability(ASN1decoding_t dec, DataProtocolCapability *val);
static int ASN1CALL ASN1Dec_EncryptionAuthenticationAndIntegrity(ASN1decoding_t dec, EncryptionAuthenticationAndIntegrity *val);
static int ASN1CALL ASN1Dec_EncryptionCapability(ASN1decoding_t dec, PEncryptionCapability *val);
static int ASN1CALL ASN1Dec_UserInputCapability(ASN1decoding_t dec, UserInputCapability *val);
static int ASN1CALL ASN1Dec_H223LogicalChannelParameters(ASN1decoding_t dec, H223LogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters(ASN1decoding_t dec, V76LogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_RTPPayloadType(ASN1decoding_t dec, RTPPayloadType *val);
static int ASN1CALL ASN1Dec_H245TransportAddress(ASN1decoding_t dec, H245TransportAddress *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters(ASN1decoding_t dec, H2250LogicalChannelAckParameters *val);
static int ASN1CALL ASN1Dec_H223ModeParameters(ASN1decoding_t dec, H223ModeParameters *val);
static int ASN1CALL ASN1Dec_RedundancyEncodingMode(ASN1decoding_t dec, RedundancyEncodingMode *val);
static int ASN1CALL ASN1Dec_VideoMode(ASN1decoding_t dec, VideoMode *val);
static int ASN1CALL ASN1Dec_EncryptionCommand(ASN1decoding_t dec, EncryptionCommand *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand(ASN1decoding_t dec, MiscellaneousCommand *val);
static int ASN1CALL ASN1Dec_MiscellaneousIndication(ASN1decoding_t dec, MiscellaneousIndication *val);
static int ASN1CALL ASN1Dec_MCLocationIndication(ASN1decoding_t dec, MCLocationIndication *val);
static int ASN1CALL ASN1Dec_UserInputIndication(ASN1decoding_t dec, UserInputIndication *val);
static int ASN1CALL ASN1Dec_DataApplicationCapability_application_nlpid(ASN1decoding_t dec, DataApplicationCapability_application_nlpid *val);
static int ASN1CALL ASN1Dec_DataApplicationCapability_application_t84(ASN1decoding_t dec, DataApplicationCapability_application_t84 *val);
static int ASN1CALL ASN1Dec_DataMode_application_nlpid(ASN1decoding_t dec, DataMode_application_nlpid *val);
static int ASN1CALL ASN1Dec_DataMode_application(ASN1decoding_t dec, DataMode_application *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_forwardMultiplexAckParameters(ASN1decoding_t dec, OpenLogicalChannelAck_forwardMultiplexAckParameters *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_mediaPacketization(ASN1decoding_t dec, H2250LogicalChannelParameters_mediaPacketization *val);
static int ASN1CALL ASN1Dec_NetworkAccessParameters_networkAddress(ASN1decoding_t dec, NetworkAccessParameters_networkAddress *val);
static int ASN1CALL ASN1Dec_DataApplicationCapability_application(ASN1decoding_t dec, DataApplicationCapability_application *val);
static int ASN1CALL ASN1Dec_EnhancementLayerInfo_spatialEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_spatialEnhancement *val);
static int ASN1CALL ASN1Dec_EnhancementLayerInfo_snrEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_snrEnhancement *val);
static int ASN1CALL ASN1Dec_MediaPacketizationCapability_rtpPayloadType(ASN1decoding_t dec, MediaPacketizationCapability_rtpPayloadType *val);
static int ASN1CALL ASN1Dec_H2250Capability_redundancyEncodingCapability(ASN1decoding_t dec, PH2250Capability_redundancyEncodingCapability *val);
static int ASN1CALL ASN1Dec_CommandMessage(ASN1decoding_t dec, CommandMessage *val);
static int ASN1CALL ASN1Dec_H235SecurityCapability(ASN1decoding_t dec, H235SecurityCapability *val);
static int ASN1CALL ASN1Dec_MediaPacketizationCapability(ASN1decoding_t dec, MediaPacketizationCapability *val);
static int ASN1CALL ASN1Dec_VideoCapability(ASN1decoding_t dec, VideoCapability *val);
static int ASN1CALL ASN1Dec_BEnhancementParameters(ASN1decoding_t dec, BEnhancementParameters *val);
static int ASN1CALL ASN1Dec_DataApplicationCapability(ASN1decoding_t dec, DataApplicationCapability *val);
static int ASN1CALL ASN1Dec_NetworkAccessParameters(ASN1decoding_t dec, NetworkAccessParameters *val);
static int ASN1CALL ASN1Dec_H2250ModeParameters(ASN1decoding_t dec, H2250ModeParameters *val);
static int ASN1CALL ASN1Dec_DataMode(ASN1decoding_t dec, DataMode *val);
static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_dataType(ASN1decoding_t dec, CommunicationModeTableEntry_dataType *val);
static int ASN1CALL ASN1Dec_H235Mode_mediaMode(ASN1decoding_t dec, H235Mode_mediaMode *val);
static int ASN1CALL ASN1Dec_H235Media_mediaType(ASN1decoding_t dec, H235Media_mediaType *val);
static int ASN1CALL ASN1Dec_EnhancementLayerInfo_bPictureEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_bPictureEnhancement *val);
static int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData(ASN1decoding_t dec, PMediaDistributionCapability_distributedData *val);
static int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData *val);
static int ASN1CALL ASN1Dec_Capability(ASN1decoding_t dec, Capability *val);
static int ASN1CALL ASN1Dec_H2250Capability(ASN1decoding_t dec, H2250Capability *val);
static int ASN1CALL ASN1Dec_H235Media(ASN1decoding_t dec, H235Media *val);
static int ASN1CALL ASN1Dec_H235Mode(ASN1decoding_t dec, H235Mode *val);
static int ASN1CALL ASN1Dec_ModeElement_type(ASN1decoding_t dec, ModeElement_type *val);
static int ASN1CALL ASN1Dec_CapabilityTableEntry(ASN1decoding_t dec, CapabilityTableEntry *val);
static int ASN1CALL ASN1Dec_MultiplexCapability(ASN1decoding_t dec, MultiplexCapability *val);
static int ASN1CALL ASN1Dec_DataType(ASN1decoding_t dec, DataType *val);
static int ASN1CALL ASN1Dec_RedundancyEncoding(ASN1decoding_t dec, RedundancyEncoding *val);
static int ASN1CALL ASN1Dec_ModeElement(ASN1decoding_t dec, ModeElement *val);
static int ASN1CALL ASN1Dec_CommunicationModeTableEntry(ASN1decoding_t dec, CommunicationModeTableEntry *val);
static int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable *val);
static int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySet(ASN1decoding_t dec, TerminalCapabilitySet *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters(ASN1decoding_t dec, H2250LogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_ModeDescription(ASN1decoding_t dec, ModeDescription *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Dec_RequestMode_requestedModes(ASN1decoding_t dec, PRequestMode_requestedModes *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannelAck_reverseLogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannel_reverseLogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannel_forwardLogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel(ASN1decoding_t dec, OpenLogicalChannel *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelAck(ASN1decoding_t dec, OpenLogicalChannelAck *val);
static int ASN1CALL ASN1Dec_RequestMessage(ASN1decoding_t dec, RequestMessage *val);
static int ASN1CALL ASN1Dec_ResponseMessage(ASN1decoding_t dec, ResponseMessage *val);
static int ASN1CALL ASN1Dec_FastConnectOLC(ASN1decoding_t dec, FastConnectOLC *val);
static int ASN1CALL ASN1Dec_FunctionNotUnderstood(ASN1decoding_t dec, FunctionNotUnderstood *val);
static int ASN1CALL ASN1Dec_IndicationMessage(ASN1decoding_t dec, IndicationMessage *val);
static int ASN1CALL ASN1Dec_MultimediaSystemControlMessage(ASN1decoding_t dec, MultimediaSystemControlMessage *val);
static void ASN1CALL ASN1Free_CustomPictureFormat_mPI_customPCF(CustomPictureFormat_mPI_customPCF *val);
static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation_extendedPAR(CustomPictureFormat_pixelAspectInformation_extendedPAR *val);
static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val);
static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route(PUnicastAddress_iPSourceRouteAddress_route *val);
static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val);
static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val);
static void ASN1CALL ASN1Free_UserInputIndication_signal(UserInputIndication_signal *val);
static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest(SendTerminalCapabilitySet_specificRequest *val);
static void ASN1CALL ASN1Free_ConferenceResponse_extensionAddressResponse(ConferenceResponse_extensionAddressResponse *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryRelease_entryNumbers(RequestMultiplexEntryRelease_entryNumbers *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryReject_entryNumbers(RequestMultiplexEntryReject_entryNumbers *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryAck_entryNumbers(RequestMultiplexEntryAck_entryNumbers *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntry_entryNumbers(RequestMultiplexEntry_entryNumbers *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendRelease_multiplexTableEntryNumber(MultiplexEntrySendRelease_multiplexTableEntryNumber *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendAck_multiplexTableEntryNumber(MultiplexEntrySendAck_multiplexTableEntryNumber *val);
static void ASN1CALL ASN1Free_MultiplexElement_type(MultiplexElement_type *val);
static void ASN1CALL ASN1Free_MulticastAddress_iP6Address(MulticastAddress_iP6Address *val);
static void ASN1CALL ASN1Free_MulticastAddress_iPAddress(MulticastAddress_iPAddress *val);
static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress(UnicastAddress_iPSourceRouteAddress *val);
static void ASN1CALL ASN1Free_UnicastAddress_iP6Address(UnicastAddress_iP6Address *val);
static void ASN1CALL ASN1Free_UnicastAddress_iPXAddress(UnicastAddress_iPXAddress *val);
static void ASN1CALL ASN1Free_UnicastAddress_iPAddress(UnicastAddress_iPAddress *val);
static void ASN1CALL ASN1Free_Q2931Address_address(Q2931Address_address *val);
static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation(CustomPictureFormat_pixelAspectInformation *val);
static void ASN1CALL ASN1Free_CustomPictureFormat_mPI(CustomPictureFormat_mPI *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyFrameMapping_frameSequence(RTPH263VideoRedundancyFrameMapping_frameSequence *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_containedThreads(RTPH263VideoRedundancyEncoding_containedThreads *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping(RTPH263VideoRedundancyEncoding_frameToThreadMapping *val);
static void ASN1CALL ASN1Free_RedundancyEncodingCapability_secondaryEncoding(PRedundancyEncodingCapability_secondaryEncoding *val);
static void ASN1CALL ASN1Free_NonStandardIdentifier(NonStandardIdentifier *val);
static void ASN1CALL ASN1Free_CapabilityDescriptor(CapabilityDescriptor *val);
static void ASN1CALL ASN1Free_AlternativeCapabilitySet(AlternativeCapabilitySet *val);
static void ASN1CALL ASN1Free_H222Capability(H222Capability *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding(RTPH263VideoRedundancyEncoding *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyFrameMapping(RTPH263VideoRedundancyFrameMapping *val);
static void ASN1CALL ASN1Free_MultipointCapability(MultipointCapability *val);
static void ASN1CALL ASN1Free_MediaDistributionCapability(MediaDistributionCapability *val);
static void ASN1CALL ASN1Free_EnhancementLayerInfo(EnhancementLayerInfo *val);
static void ASN1CALL ASN1Free_CustomPictureFormat(CustomPictureFormat *val);
static void ASN1CALL ASN1Free_ConferenceCapability(ConferenceCapability *val);
static void ASN1CALL ASN1Free_Q2931Address(Q2931Address *val);
static void ASN1CALL ASN1Free_H222LogicalChannelParameters(H222LogicalChannelParameters *val);
static void ASN1CALL ASN1Free_EscrowData(EscrowData *val);
static void ASN1CALL ASN1Free_MultiplexEntrySend(MultiplexEntrySend *val);
static void ASN1CALL ASN1Free_MultiplexElement(MultiplexElement *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendAck(MultiplexEntrySendAck *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendRelease(MultiplexEntrySendRelease *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntry(RequestMultiplexEntry *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryAck(RequestMultiplexEntryAck *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryRelease(RequestMultiplexEntryRelease *val);
static void ASN1CALL ASN1Free_RequestMode(RequestMode *val);
static void ASN1CALL ASN1Free_CommunicationModeCommand(CommunicationModeCommand *val);
static void ASN1CALL ASN1Free_CommunicationModeResponse(CommunicationModeResponse *val);
static void ASN1CALL ASN1Free_Criteria(Criteria *val);
static void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse(RequestAllTerminalIDsResponse *val);
static void ASN1CALL ASN1Free_TerminalInformation(TerminalInformation *val);
static void ASN1CALL ASN1Free_SendTerminalCapabilitySet(SendTerminalCapabilitySet *val);
static void ASN1CALL ASN1Free_SubstituteConferenceIDCommand(SubstituteConferenceIDCommand *val);
static void ASN1CALL ASN1Free_FunctionNotSupported(FunctionNotSupported *val);
static void ASN1CALL ASN1Free_VendorIdentification(VendorIdentification *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val);
static void ASN1CALL ASN1Free_MultiplexElement_type_subElementList(PMultiplexElement_type_subElementList *val);
static void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse_terminalInformation(PRequestAllTerminalIDsResponse_terminalInformation *val);
static void ASN1CALL ASN1Free_ConferenceResponse_terminalCertificateResponse(ConferenceResponse_terminalCertificateResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_chairTokenOwnerResponse(ConferenceResponse_chairTokenOwnerResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_terminalListResponse(ConferenceResponse_terminalListResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_passwordResponse(ConferenceResponse_passwordResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_conferenceIDResponse(ConferenceResponse_conferenceIDResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_terminalIDResponse(ConferenceResponse_terminalIDResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_mCTerminalIDResponse(ConferenceResponse_mCTerminalIDResponse *val);
static void ASN1CALL ASN1Free_ConferenceRequest_requestTerminalCertificate(ConferenceRequest_requestTerminalCertificate *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryReject_rejectionDescriptions(RequestMultiplexEntryReject_rejectionDescriptions *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendReject_rejectionDescriptions(MultiplexEntrySendReject_rejectionDescriptions *val);
static void ASN1CALL ASN1Free_MultiplexEntryDescriptor_elementList(MultiplexEntryDescriptor_elementList *val);
static void ASN1CALL ASN1Free_EncryptionSync_escrowentry(PEncryptionSync_escrowentry *val);
static void ASN1CALL ASN1Free_H263VideoModeCombos_h263VideoCoupledModes(H263VideoModeCombos_h263VideoCoupledModes *val);
static void ASN1CALL ASN1Free_H263Options_customPictureFormat(PH263Options_customPictureFormat *val);
static void ASN1CALL ASN1Free_H263Options_customPictureClockFrequency(PH263Options_customPictureClockFrequency *val);
static void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability(PMultipointCapability_mediaDistributionCapability *val);
static void ASN1CALL ASN1Free_TransportCapability_mediaChannelCapabilities(TransportCapability_mediaChannelCapabilities *val);
static void ASN1CALL ASN1Free_H222Capability_vcCapability(PH222Capability_vcCapability *val);
static void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities(PCapabilityDescriptor_simultaneousCapabilities *val);
static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityDescriptors(TerminalCapabilitySet_capabilityDescriptors *val);
static void ASN1CALL ASN1Free_NonStandardParameter(NonStandardParameter *val);
static void ASN1CALL ASN1Free_QOSCapability(QOSCapability *val);
static void ASN1CALL ASN1Free_TransportCapability(TransportCapability *val);
static void ASN1CALL ASN1Free_RedundancyEncodingMethod(RedundancyEncodingMethod *val);
static void ASN1CALL ASN1Free_H263Options(H263Options *val);
static void ASN1CALL ASN1Free_H263VideoModeCombos(H263VideoModeCombos *val);
static void ASN1CALL ASN1Free_AudioCapability(AudioCapability *val);
static void ASN1CALL ASN1Free_MediaEncryptionAlgorithm(MediaEncryptionAlgorithm *val);
static void ASN1CALL ASN1Free_AuthenticationCapability(AuthenticationCapability *val);
static void ASN1CALL ASN1Free_IntegrityCapability(IntegrityCapability *val);
static void ASN1CALL ASN1Free_UnicastAddress(UnicastAddress *val);
static void ASN1CALL ASN1Free_MulticastAddress(MulticastAddress *val);
static void ASN1CALL ASN1Free_EncryptionSync(EncryptionSync *val);
static void ASN1CALL ASN1Free_RequestChannelClose(RequestChannelClose *val);
static void ASN1CALL ASN1Free_MultiplexEntryDescriptor(MultiplexEntryDescriptor *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendReject(MultiplexEntrySendReject *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryReject(RequestMultiplexEntryReject *val);
static void ASN1CALL ASN1Free_H263VideoMode(H263VideoMode *val);
static void ASN1CALL ASN1Free_AudioMode(AudioMode *val);
static void ASN1CALL ASN1Free_EncryptionMode(EncryptionMode *val);
static void ASN1CALL ASN1Free_ConferenceRequest(ConferenceRequest *val);
static void ASN1CALL ASN1Free_CertSelectionCriteria(PCertSelectionCriteria *val);
static void ASN1CALL ASN1Free_ConferenceResponse(ConferenceResponse *val);
static void ASN1CALL ASN1Free_EndSessionCommand(EndSessionCommand *val);
static void ASN1CALL ASN1Free_ConferenceCommand(ConferenceCommand *val);
static void ASN1CALL ASN1Free_UserInputIndication_userInputSupportIndication(UserInputIndication_userInputSupportIndication *val);
static void ASN1CALL ASN1Free_MiscellaneousIndication_type(MiscellaneousIndication_type *val);
static void ASN1CALL ASN1Free_MiscellaneousCommand_type(MiscellaneousCommand_type *val);
static void ASN1CALL ASN1Free_EncryptionCommand_encryptionAlgorithmID(EncryptionCommand_encryptionAlgorithmID *val);
static void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard(PCommunicationModeTableEntry_nonStandard *val);
static void ASN1CALL ASN1Free_RedundancyEncodingMode_secondaryEncoding(RedundancyEncodingMode_secondaryEncoding *val);
static void ASN1CALL ASN1Free_H223ModeParameters_adaptationLayerType(H223ModeParameters_adaptationLayerType *val);
static void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors(PMultiplexEntrySend_multiplexEntryDescriptors *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard(PH2250LogicalChannelAckParameters_nonStandard *val);
static void ASN1CALL ASN1Free_RTPPayloadType_payloadDescriptor(RTPPayloadType_payloadDescriptor *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard(PH2250LogicalChannelParameters_nonStandard *val);
static void ASN1CALL ASN1Free_H223LogicalChannelParameters_adaptationLayerType(H223LogicalChannelParameters_adaptationLayerType *val);
static void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData(PConferenceCapability_nonStandardData *val);
static void ASN1CALL ASN1Free_UserInputCapability_nonStandard(UserInputCapability_nonStandard *val);
static void ASN1CALL ASN1Free_H263Options_modeCombos(PH263Options_modeCombos *val);
static void ASN1CALL ASN1Free_TransportCapability_qOSCapabilities(PTransportCapability_qOSCapabilities *val);
static void ASN1CALL ASN1Free_NonStandardMessage(NonStandardMessage *val);
static void ASN1CALL ASN1Free_RedundancyEncodingCapability(RedundancyEncodingCapability *val);
static void ASN1CALL ASN1Free_H263VideoCapability(H263VideoCapability *val);
static void ASN1CALL ASN1Free_EnhancementOptions(EnhancementOptions *val);
static void ASN1CALL ASN1Free_DataProtocolCapability(DataProtocolCapability *val);
static void ASN1CALL ASN1Free_EncryptionAuthenticationAndIntegrity(EncryptionAuthenticationAndIntegrity *val);
static void ASN1CALL ASN1Free_EncryptionCapability(PEncryptionCapability *val);
static void ASN1CALL ASN1Free_UserInputCapability(UserInputCapability *val);
static void ASN1CALL ASN1Free_H223LogicalChannelParameters(H223LogicalChannelParameters *val);
static void ASN1CALL ASN1Free_RTPPayloadType(RTPPayloadType *val);
static void ASN1CALL ASN1Free_H245TransportAddress(H245TransportAddress *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters(H2250LogicalChannelAckParameters *val);
static void ASN1CALL ASN1Free_H223ModeParameters(H223ModeParameters *val);
static void ASN1CALL ASN1Free_RedundancyEncodingMode(RedundancyEncodingMode *val);
static void ASN1CALL ASN1Free_VideoMode(VideoMode *val);
static void ASN1CALL ASN1Free_EncryptionCommand(EncryptionCommand *val);
static void ASN1CALL ASN1Free_MiscellaneousCommand(MiscellaneousCommand *val);
static void ASN1CALL ASN1Free_MiscellaneousIndication(MiscellaneousIndication *val);
static void ASN1CALL ASN1Free_MCLocationIndication(MCLocationIndication *val);
static void ASN1CALL ASN1Free_UserInputIndication(UserInputIndication *val);
static void ASN1CALL ASN1Free_DataApplicationCapability_application_nlpid(DataApplicationCapability_application_nlpid *val);
static void ASN1CALL ASN1Free_DataApplicationCapability_application_t84(DataApplicationCapability_application_t84 *val);
static void ASN1CALL ASN1Free_DataMode_application_nlpid(DataMode_application_nlpid *val);
static void ASN1CALL ASN1Free_DataMode_application(DataMode_application *val);
static void ASN1CALL ASN1Free_OpenLogicalChannelAck_forwardMultiplexAckParameters(OpenLogicalChannelAck_forwardMultiplexAckParameters *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_mediaPacketization(H2250LogicalChannelParameters_mediaPacketization *val);
static void ASN1CALL ASN1Free_NetworkAccessParameters_networkAddress(NetworkAccessParameters_networkAddress *val);
static void ASN1CALL ASN1Free_DataApplicationCapability_application(DataApplicationCapability_application *val);
static void ASN1CALL ASN1Free_EnhancementLayerInfo_spatialEnhancement(PEnhancementLayerInfo_spatialEnhancement *val);
static void ASN1CALL ASN1Free_EnhancementLayerInfo_snrEnhancement(PEnhancementLayerInfo_snrEnhancement *val);
static void ASN1CALL ASN1Free_MediaPacketizationCapability_rtpPayloadType(MediaPacketizationCapability_rtpPayloadType *val);
static void ASN1CALL ASN1Free_H2250Capability_redundancyEncodingCapability(PH2250Capability_redundancyEncodingCapability *val);
static void ASN1CALL ASN1Free_CommandMessage(CommandMessage *val);
static void ASN1CALL ASN1Free_H235SecurityCapability(H235SecurityCapability *val);
static void ASN1CALL ASN1Free_MediaPacketizationCapability(MediaPacketizationCapability *val);
static void ASN1CALL ASN1Free_VideoCapability(VideoCapability *val);
static void ASN1CALL ASN1Free_BEnhancementParameters(BEnhancementParameters *val);
static void ASN1CALL ASN1Free_DataApplicationCapability(DataApplicationCapability *val);
static void ASN1CALL ASN1Free_NetworkAccessParameters(NetworkAccessParameters *val);
static void ASN1CALL ASN1Free_H2250ModeParameters(H2250ModeParameters *val);
static void ASN1CALL ASN1Free_DataMode(DataMode *val);
static void ASN1CALL ASN1Free_CommunicationModeTableEntry_dataType(CommunicationModeTableEntry_dataType *val);
static void ASN1CALL ASN1Free_H235Mode_mediaMode(H235Mode_mediaMode *val);
static void ASN1CALL ASN1Free_H235Media_mediaType(H235Media_mediaType *val);
static void ASN1CALL ASN1Free_EnhancementLayerInfo_bPictureEnhancement(PEnhancementLayerInfo_bPictureEnhancement *val);
static void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData(PMediaDistributionCapability_distributedData *val);
static void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData(PMediaDistributionCapability_centralizedData *val);
static void ASN1CALL ASN1Free_Capability(Capability *val);
static void ASN1CALL ASN1Free_H2250Capability(H2250Capability *val);
static void ASN1CALL ASN1Free_H235Media(H235Media *val);
static void ASN1CALL ASN1Free_H235Mode(H235Mode *val);
static void ASN1CALL ASN1Free_ModeElement_type(ModeElement_type *val);
static void ASN1CALL ASN1Free_CapabilityTableEntry(CapabilityTableEntry *val);
static void ASN1CALL ASN1Free_MultiplexCapability(MultiplexCapability *val);
static void ASN1CALL ASN1Free_DataType(DataType *val);
static void ASN1CALL ASN1Free_RedundancyEncoding(RedundancyEncoding *val);
static void ASN1CALL ASN1Free_ModeElement(ModeElement *val);
static void ASN1CALL ASN1Free_CommunicationModeTableEntry(CommunicationModeTableEntry *val);
static void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable(PCommunicationModeResponse_communicationModeTable *val);
static void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable(PCommunicationModeCommand_communicationModeTable *val);
static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable(PTerminalCapabilitySet_capabilityTable *val);
static void ASN1CALL ASN1Free_TerminalCapabilitySet(TerminalCapabilitySet *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelParameters(H2250LogicalChannelParameters *val);
static void ASN1CALL ASN1Free_ModeDescription(ModeDescription *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val);
static void ASN1CALL ASN1Free_RequestMode_requestedModes(PRequestMode_requestedModes *val);
static void ASN1CALL ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters(OpenLogicalChannelAck_reverseLogicalChannelParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters(OpenLogicalChannel_reverseLogicalChannelParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters(OpenLogicalChannel_forwardLogicalChannelParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel(OpenLogicalChannel *val);
static void ASN1CALL ASN1Free_OpenLogicalChannelAck(OpenLogicalChannelAck *val);
static void ASN1CALL ASN1Free_RequestMessage(RequestMessage *val);
static void ASN1CALL ASN1Free_ResponseMessage(ResponseMessage *val);
static void ASN1CALL ASN1Free_FastConnectOLC(FastConnectOLC *val);
static void ASN1CALL ASN1Free_FunctionNotUnderstood(FunctionNotUnderstood *val);
static void ASN1CALL ASN1Free_IndicationMessage(IndicationMessage *val);
static void ASN1CALL ASN1Free_MultimediaSystemControlMessage(MultimediaSystemControlMessage *val);

typedef ASN1PerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[2] = {
    (ASN1EncFun_t) ASN1Enc_FastConnectOLC,
    (ASN1EncFun_t) ASN1Enc_MultimediaSystemControlMessage,
};
typedef ASN1PerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[2] = {
    (ASN1DecFun_t) ASN1Dec_FastConnectOLC,
    (ASN1DecFun_t) ASN1Dec_MultimediaSystemControlMessage,
};
static const ASN1FreeFun_t freefntab[2] = {
    (ASN1FreeFun_t) ASN1Free_FastConnectOLC,
    (ASN1FreeFun_t) ASN1Free_MultimediaSystemControlMessage,
};
static const ULONG sizetab[2] = {
    SIZE_H245ASN_Module_PDU_0,
    SIZE_H245ASN_Module_PDU_1,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL H245ASN_Module_Startup(void)
{
    H245ASN_Module = ASN1_CreateModule(0x10000, ASN1_PER_RULE_ALIGNED, ASN1FLAGS_NONE, 2, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x35343268);
}

void ASN1CALL H245ASN_Module_Cleanup(void)
{
    ASN1_CloseModule(H245ASN_Module);
    H245ASN_Module = NULL;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1_errorCorrection(ASN1encoding_t enc, NewATMVCIndication_aal_aal1_errorCorrection *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1_errorCorrection(ASN1decoding_t dec, NewATMVCIndication_aal_aal1_errorCorrection *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1_clockRecovery(ASN1encoding_t enc, NewATMVCIndication_aal_aal1_clockRecovery *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1_clockRecovery(ASN1decoding_t dec, NewATMVCIndication_aal_aal1_clockRecovery *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(ASN1encoding_t enc, MiscellaneousCommand_type_progressiveRefinementStart_repeatCount *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(ASN1decoding_t dec, MiscellaneousCommand_type_progressiveRefinementStart_repeatCount *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode_eRM_recovery(ASN1encoding_t enc, V76LogicalChannelParameters_mode_eRM_recovery *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode_eRM_recovery(ASN1decoding_t dec, V76LogicalChannelParameters_mode_eRM_recovery *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_extendedPAR_Set *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->width - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->height - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_extendedPAR_Set *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->width))
	return 0;
    (val)->width += 1;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->height))
	return 0;
    (val)->height += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI_customPCF_Set(ASN1encoding_t enc, CustomPictureFormat_mPI_customPCF_Set *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->clockConversionCode - 1000))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->clockDivisor - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->customMPI - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI_customPCF_Set(ASN1decoding_t dec, CustomPictureFormat_mPI_customPCF_Set *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 1, &(val)->clockConversionCode))
	return 0;
    (val)->clockConversionCode += 1000;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->clockDivisor))
	return 0;
    (val)->clockDivisor += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->customMPI))
	return 0;
    (val)->customMPI += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_availableBitRates_type_rangeOfBitRates(ASN1encoding_t enc, VCCapability_availableBitRates_type_rangeOfBitRates *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->lowerBitRate - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->higherBitRate - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_availableBitRates_type_rangeOfBitRates(ASN1decoding_t dec, VCCapability_availableBitRates_type_rangeOfBitRates *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->lowerBitRate))
	return 0;
    (val)->lowerBitRate += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->higherBitRate))
	return 0;
    (val)->higherBitRate += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(ASN1encoding_t enc, TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.highestEntryNumberProcessed - 1))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(ASN1decoding_t dec, TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.highestEntryNumberProcessed))
	    return 0;
	(val)->u.highestEntryNumberProcessed += 1;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_availableBitRates_type(ASN1encoding_t enc, VCCapability_availableBitRates_type *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.singleBitRate - 1))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_VCCapability_availableBitRates_type_rangeOfBitRates(enc, &(val)->u.rangeOfBitRates))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_availableBitRates_type(ASN1decoding_t dec, VCCapability_availableBitRates_type *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.singleBitRate))
	    return 0;
	(val)->u.singleBitRate += 1;
	break;
    case 2:
	if (!ASN1Dec_VCCapability_availableBitRates_type_rangeOfBitRates(dec, &(val)->u.rangeOfBitRates))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223Capability_h223MultiplexTableCapability_enhanced(ASN1encoding_t enc, H223Capability_h223MultiplexTableCapability_enhanced *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->maximumNestingDepth - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->maximumElementListSize - 2))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->maximumSubElementListSize - 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223Capability_h223MultiplexTableCapability_enhanced(ASN1decoding_t dec, H223Capability_h223MultiplexTableCapability_enhanced *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->maximumNestingDepth))
	return 0;
    (val)->maximumNestingDepth += 1;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maximumElementListSize))
	return 0;
    (val)->maximumElementListSize += 2;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maximumSubElementListSize))
	return 0;
    (val)->maximumSubElementListSize += 2;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI_customPCF(ASN1encoding_t enc, CustomPictureFormat_mPI_customPCF *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_CustomPictureFormat_mPI_customPCF_Set(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI_customPCF(ASN1decoding_t dec, CustomPictureFormat_mPI_customPCF *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_CustomPictureFormat_mPI_customPCF_Set(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat_mPI_customPCF(CustomPictureFormat_mPI_customPCF *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_extendedPAR *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_extendedPAR *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation_extendedPAR(CustomPictureFormat_pixelAspectInformation_extendedPAR *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H223LogicalChannelParameters_adaptationLayerType_al3(ASN1encoding_t enc, H223LogicalChannelParameters_adaptationLayerType_al3 *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncBitVal(enc, 2, (val)->controlFieldOctets))
	return 0;
    l = ASN1uint32_uoctets((val)->sendBufferSize);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->sendBufferSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223LogicalChannelParameters_adaptationLayerType_al3(ASN1decoding_t dec, H223LogicalChannelParameters_adaptationLayerType_al3 *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecU16Val(dec, 2, &(val)->controlFieldOctets))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sendBufferSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode_eRM(ASN1encoding_t enc, V76LogicalChannelParameters_mode_eRM *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->windowSize - 1))
	return 0;
    if (!ASN1Enc_V76LogicalChannelParameters_mode_eRM_recovery(enc, &(val)->recovery))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode_eRM(ASN1decoding_t dec, V76LogicalChannelParameters_mode_eRM *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->windowSize))
	return 0;
    (val)->windowSize += 1;
    if (!ASN1Dec_V76LogicalChannelParameters_mode_eRM_recovery(dec, &(val)->recovery))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnicastAddress_iPSourceRouteAddress_route_ElmFn);
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnicastAddress_iPSourceRouteAddress_route_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route(PUnicastAddress_iPSourceRouteAddress_route *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnicastAddress_iPSourceRouteAddress_route_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route_ElmFn(PUnicastAddress_iPSourceRouteAddress_route val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_routing(ASN1encoding_t enc, UnicastAddress_iPSourceRouteAddress_routing *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_routing(ASN1decoding_t dec, UnicastAddress_iPSourceRouteAddress_routing *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223ModeParameters_adaptationLayerType_al3(ASN1encoding_t enc, H223ModeParameters_adaptationLayerType_al3 *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncBitVal(enc, 2, (val)->controlFieldOctets))
	return 0;
    l = ASN1uint32_uoctets((val)->sendBufferSize);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->sendBufferSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223ModeParameters_adaptationLayerType_al3(ASN1decoding_t dec, H223ModeParameters_adaptationLayerType_al3 *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecU16Val(dec, 2, &(val)->controlFieldOctets))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sendBufferSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(ASN1encoding_t enc, SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(ASN1decoding_t dec, SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn, 1, 65535, 16);
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn, sizeof(**val), 1, 65535, 16);
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart(ASN1encoding_t enc, MiscellaneousCommand_type_progressiveRefinementStart *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(enc, &(val)->repeatCount))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart(ASN1decoding_t dec, MiscellaneousCommand_type_progressiveRefinementStart *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(dec, &(val)->repeatCount))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_videoFastUpdateMB(ASN1encoding_t enc, MiscellaneousCommand_type_videoFastUpdateMB *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->firstGOB))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->firstMB - 1))
	    return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->numberOfMBs - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_videoFastUpdateMB(ASN1decoding_t dec, MiscellaneousCommand_type_videoFastUpdateMB *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->firstGOB))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->firstMB))
	    return 0;
	(val)->firstMB += 1;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->numberOfMBs))
	return 0;
    (val)->numberOfMBs += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_videoFastUpdateGOB(ASN1encoding_t enc, MiscellaneousCommand_type_videoFastUpdateGOB *val)
{
    if (!ASN1PEREncBitVal(enc, 5, (val)->firstGOB))
	return 0;
    if (!ASN1PEREncBitVal(enc, 5, (val)->numberOfGOBs - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_videoFastUpdateGOB(ASN1decoding_t dec, MiscellaneousCommand_type_videoFastUpdateGOB *val)
{
    if (!ASN1PERDecU16Val(dec, 5, &(val)->firstGOB))
	return 0;
    if (!ASN1PERDecU16Val(dec, 5, &(val)->numberOfGOBs))
	return 0;
    (val)->numberOfGOBs += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousIndication_type_videoNotDecodedMBs(ASN1encoding_t enc, MiscellaneousIndication_type_videoNotDecodedMBs *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->firstMB - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->numberOfMBs - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->temporalReference))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousIndication_type_videoNotDecodedMBs(ASN1decoding_t dec, MiscellaneousIndication_type_videoNotDecodedMBs *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->firstMB))
	return 0;
    (val)->firstMB += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->numberOfMBs))
	return 0;
    (val)->numberOfMBs += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->temporalReference))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal5(ASN1encoding_t enc, NewATMVCIndication_aal_aal5 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardMaximumSDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->backwardMaximumSDUSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal5(ASN1decoding_t dec, NewATMVCIndication_aal_aal5 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardMaximumSDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->backwardMaximumSDUSize))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1(ASN1encoding_t enc, NewATMVCIndication_aal_aal1 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_NewATMVCIndication_aal_aal1_clockRecovery(enc, &(val)->clockRecovery))
	return 0;
    if (!ASN1Enc_NewATMVCIndication_aal_aal1_errorCorrection(enc, &(val)->errorCorrection))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->structuredDataTransfer))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->partiallyFilledCells))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1(ASN1decoding_t dec, NewATMVCIndication_aal_aal1 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_NewATMVCIndication_aal_aal1_clockRecovery(dec, &(val)->clockRecovery))
	return 0;
    if (!ASN1Dec_NewATMVCIndication_aal_aal1_errorCorrection(dec, &(val)->errorCorrection))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->structuredDataTransfer))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->partiallyFilledCells))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_reverseParameters_multiplex(ASN1encoding_t enc, NewATMVCIndication_reverseParameters_multiplex *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_reverseParameters_multiplex(ASN1decoding_t dec, NewATMVCIndication_reverseParameters_multiplex *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_UserInputIndication_signal_rtp(ASN1encoding_t enc, UserInputIndication_signal_rtp *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->timestamp);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->timestamp))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->expirationTime);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->expirationTime))
	    return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication_signal_rtp(ASN1decoding_t dec, UserInputIndication_signal_rtp *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->timestamp))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->expirationTime))
	    return 0;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber))
	return 0;
    (val)->logicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UserInputIndication_signalUpdate_rtp(ASN1encoding_t enc, UserInputIndication_signalUpdate_rtp *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication_signalUpdate_rtp(ASN1decoding_t dec, UserInputIndication_signalUpdate_rtp *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber))
	return 0;
    (val)->logicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UserInputIndication_signalUpdate(ASN1encoding_t enc, UserInputIndication_signalUpdate *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->duration - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_UserInputIndication_signalUpdate_rtp(enc, &(val)->rtp))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication_signalUpdate(ASN1decoding_t dec, UserInputIndication_signalUpdate *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->duration))
	return 0;
    (val)->duration += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_UserInputIndication_signalUpdate_rtp(dec, &(val)->rtp))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UserInputIndication_signal(ASN1encoding_t enc, UserInputIndication_signal *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    t = lstrlenA((val)->signalType);
    if (!ASN1PEREncCharString(enc, t, (val)->signalType, 8))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->duration - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_UserInputIndication_signal_rtp(enc, &(val)->rtp))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication_signal(ASN1decoding_t dec, UserInputIndication_signal *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecZeroCharStringNoAlloc(dec, 1, (val)->signalType, 8))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->duration))
	    return 0;
	(val)->duration += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_UserInputIndication_signal_rtp(dec, &(val)->rtp))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserInputIndication_signal(UserInputIndication_signal *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_reverseParameters(ASN1encoding_t enc, NewATMVCIndication_reverseParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->bitRateLockedToPCRClock))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->bitRateLockedToNetworkClock))
	return 0;
    if (!ASN1Enc_NewATMVCIndication_reverseParameters_multiplex(enc, &(val)->multiplex))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_reverseParameters(ASN1decoding_t dec, NewATMVCIndication_reverseParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->bitRateLockedToPCRClock))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->bitRateLockedToNetworkClock))
	return 0;
    if (!ASN1Dec_NewATMVCIndication_reverseParameters_multiplex(dec, &(val)->multiplex))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_multiplex(ASN1encoding_t enc, NewATMVCIndication_multiplex *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_multiplex(ASN1decoding_t dec, NewATMVCIndication_multiplex *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal(ASN1encoding_t enc, NewATMVCIndication_aal *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NewATMVCIndication_aal_aal1(enc, &(val)->u.aal1))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_NewATMVCIndication_aal_aal5(enc, &(val)->u.aal5))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal(ASN1decoding_t dec, NewATMVCIndication_aal *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NewATMVCIndication_aal_aal1(dec, &(val)->u.aal1))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_NewATMVCIndication_aal_aal5(dec, &(val)->u.aal5))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_JitterIndication_scope(ASN1encoding_t enc, JitterIndication_scope *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelNumber - 1))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.resourceID))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_JitterIndication_scope(ASN1decoding_t dec, JitterIndication_scope *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelNumber))
	    return 0;
	(val)->u.logicalChannelNumber += 1;
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.resourceID))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_FunctionNotSupported_cause(ASN1encoding_t enc, FunctionNotSupported_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FunctionNotSupported_cause(ASN1decoding_t dec, FunctionNotSupported_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration_h223AnnexADoubleFlag(ASN1encoding_t enc, H223MultiplexReconfiguration_h223AnnexADoubleFlag *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration_h223AnnexADoubleFlag(ASN1decoding_t dec, H223MultiplexReconfiguration_h223AnnexADoubleFlag *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration_h223ModeChange(ASN1encoding_t enc, H223MultiplexReconfiguration_h223ModeChange *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration_h223ModeChange(ASN1decoding_t dec, H223MultiplexReconfiguration_h223ModeChange *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_EndSessionCommand_isdnOptions(ASN1encoding_t enc, EndSessionCommand_isdnOptions *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EndSessionCommand_isdnOptions(ASN1decoding_t dec, EndSessionCommand_isdnOptions *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_EndSessionCommand_gstnOptions(ASN1encoding_t enc, EndSessionCommand_gstnOptions *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EndSessionCommand_gstnOptions(ASN1decoding_t dec, EndSessionCommand_gstnOptions *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_FlowControlCommand_restriction(ASN1encoding_t enc, FlowControlCommand_restriction *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	l = ASN1uint32_uoctets((val)->u.maximumBitRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->u.maximumBitRate))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FlowControlCommand_restriction(ASN1decoding_t dec, FlowControlCommand_restriction *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->u.maximumBitRate))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_FlowControlCommand_scope(ASN1encoding_t enc, FlowControlCommand_scope *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelNumber - 1))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.resourceID))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FlowControlCommand_scope(ASN1decoding_t dec, FlowControlCommand_scope *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelNumber))
	    return 0;
	(val)->u.logicalChannelNumber += 1;
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.resourceID))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest(ASN1encoding_t enc, SendTerminalCapabilitySet_specificRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multiplexCapability))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(enc, &(val)->capabilityTableEntryNumbers))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(enc, &(val)->capabilityDescriptorNumbers))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest(ASN1decoding_t dec, SendTerminalCapabilitySet_specificRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multiplexCapability))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(dec, &(val)->capabilityTableEntryNumbers))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(dec, &(val)->capabilityDescriptorNumbers))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest(SendTerminalCapabilitySet_specificRequest *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(&(val)->capabilityTableEntryNumbers);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(&(val)->capabilityDescriptorNumbers);
	}
    }
}

static int ASN1CALL ASN1Enc_RemoteMCResponse_reject(ASN1encoding_t enc, RemoteMCResponse_reject *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteMCResponse_reject(ASN1decoding_t dec, RemoteMCResponse_reject *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceResponse_sendThisSourceResponse(ASN1encoding_t enc, ConferenceResponse_sendThisSourceResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_sendThisSourceResponse(ASN1decoding_t dec, ConferenceResponse_sendThisSourceResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceResponse_makeTerminalBroadcasterResponse(ASN1encoding_t enc, ConferenceResponse_makeTerminalBroadcasterResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_makeTerminalBroadcasterResponse(ASN1decoding_t dec, ConferenceResponse_makeTerminalBroadcasterResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceResponse_broadcastMyLogicalChannelResponse(ASN1encoding_t enc, ConferenceResponse_broadcastMyLogicalChannelResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_broadcastMyLogicalChannelResponse(ASN1decoding_t dec, ConferenceResponse_broadcastMyLogicalChannelResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceResponse_extensionAddressResponse(ASN1encoding_t enc, ConferenceResponse_extensionAddressResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->extensionAddress, 1, 128, 7))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_extensionAddressResponse(ASN1decoding_t dec, ConferenceResponse_extensionAddressResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->extensionAddress, 1, 128, 7))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_extensionAddressResponse(ConferenceResponse_extensionAddressResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_makeMeChairResponse(ASN1encoding_t enc, ConferenceResponse_makeMeChairResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_makeMeChairResponse(ASN1decoding_t dec, ConferenceResponse_makeMeChairResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopReject_cause(ASN1encoding_t enc, MaintenanceLoopReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopReject_cause(ASN1decoding_t dec, MaintenanceLoopReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopReject_type(ASN1encoding_t enc, MaintenanceLoopReject_type *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.mediaLoop - 1))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelLoop - 1))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopReject_type(ASN1decoding_t dec, MaintenanceLoopReject_type *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.mediaLoop))
	    return 0;
	(val)->u.mediaLoop += 1;
	break;
    case 3:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelLoop))
	    return 0;
	(val)->u.logicalChannelLoop += 1;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopAck_type(ASN1encoding_t enc, MaintenanceLoopAck_type *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.mediaLoop - 1))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelLoop - 1))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopAck_type(ASN1decoding_t dec, MaintenanceLoopAck_type *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.mediaLoop))
	    return 0;
	(val)->u.mediaLoop += 1;
	break;
    case 3:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelLoop))
	    return 0;
	(val)->u.logicalChannelLoop += 1;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopRequest_type(ASN1encoding_t enc, MaintenanceLoopRequest_type *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.mediaLoop - 1))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelLoop - 1))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopRequest_type(ASN1decoding_t dec, MaintenanceLoopRequest_type *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.mediaLoop))
	    return 0;
	(val)->u.mediaLoop += 1;
	break;
    case 3:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelLoop))
	    return 0;
	(val)->u.logicalChannelLoop += 1;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_G7231AnnexCMode_g723AnnexCAudioMode(ASN1encoding_t enc, G7231AnnexCMode_g723AnnexCAudioMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->highRateMode0 - 27))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->highRateMode1 - 27))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->lowRateMode0 - 23))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->lowRateMode1 - 23))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->sidMode0 - 6))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->sidMode1 - 6))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_G7231AnnexCMode_g723AnnexCAudioMode(ASN1decoding_t dec, G7231AnnexCMode_g723AnnexCAudioMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->highRateMode0))
	return 0;
    (val)->highRateMode0 += 27;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->highRateMode1))
	return 0;
    (val)->highRateMode1 += 27;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->lowRateMode0))
	return 0;
    (val)->lowRateMode0 += 23;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->lowRateMode1))
	return 0;
    (val)->lowRateMode1 += 23;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->sidMode0))
	return 0;
    (val)->sidMode0 += 6;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->sidMode1))
	return 0;
    (val)->sidMode1 += 6;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioMode_multichannelType(ASN1encoding_t enc, IS13818AudioMode_multichannelType *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioMode_multichannelType(ASN1decoding_t dec, IS13818AudioMode_multichannelType *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioMode_audioSampling(ASN1encoding_t enc, IS13818AudioMode_audioSampling *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioMode_audioSampling(ASN1decoding_t dec, IS13818AudioMode_audioSampling *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioMode_audioLayer(ASN1encoding_t enc, IS13818AudioMode_audioLayer *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioMode_audioLayer(ASN1decoding_t dec, IS13818AudioMode_audioLayer *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioMode_multichannelType(ASN1encoding_t enc, IS11172AudioMode_multichannelType *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioMode_multichannelType(ASN1decoding_t dec, IS11172AudioMode_multichannelType *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioMode_audioSampling(ASN1encoding_t enc, IS11172AudioMode_audioSampling *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioMode_audioSampling(ASN1decoding_t dec, IS11172AudioMode_audioSampling *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioMode_audioLayer(ASN1encoding_t enc, IS11172AudioMode_audioLayer *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioMode_audioLayer(ASN1decoding_t dec, IS11172AudioMode_audioLayer *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_AudioMode_g7231(ASN1encoding_t enc, AudioMode_g7231 *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AudioMode_g7231(ASN1decoding_t dec, AudioMode_g7231 *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H263VideoMode_resolution(ASN1encoding_t enc, H263VideoMode_resolution *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoMode_resolution(ASN1decoding_t dec, H263VideoMode_resolution *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H262VideoMode_profileAndLevel(ASN1encoding_t enc, H262VideoMode_profileAndLevel *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H262VideoMode_profileAndLevel(ASN1decoding_t dec, H262VideoMode_profileAndLevel *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H261VideoMode_resolution(ASN1encoding_t enc, H261VideoMode_resolution *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H261VideoMode_resolution(ASN1decoding_t dec, H261VideoMode_resolution *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestModeReject_cause(ASN1encoding_t enc, RequestModeReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeReject_cause(ASN1decoding_t dec, RequestModeReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestModeAck_response(ASN1encoding_t enc, RequestModeAck_response *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeAck_response(ASN1decoding_t dec, RequestModeAck_response *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryRelease_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryRelease_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryRelease_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryRelease_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryRelease_entryNumbers(RequestMultiplexEntryRelease_entryNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryRejectionDescriptions_cause(ASN1encoding_t enc, RequestMultiplexEntryRejectionDescriptions_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryRejectionDescriptions_cause(ASN1decoding_t dec, RequestMultiplexEntryRejectionDescriptions_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryReject_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryReject_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryReject_entryNumbers(RequestMultiplexEntryReject_entryNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryAck_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryAck_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryAck_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryAck_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryAck_entryNumbers(RequestMultiplexEntryAck_entryNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntry_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntry_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntry_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntry_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntry_entryNumbers(RequestMultiplexEntry_entryNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendRelease_multiplexTableEntryNumber(ASN1encoding_t enc, MultiplexEntrySendRelease_multiplexTableEntryNumber *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendRelease_multiplexTableEntryNumber(ASN1decoding_t dec, MultiplexEntrySendRelease_multiplexTableEntryNumber *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendRelease_multiplexTableEntryNumber(MultiplexEntrySendRelease_multiplexTableEntryNumber *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntryRejectionDescriptions_cause(ASN1encoding_t enc, MultiplexEntryRejectionDescriptions_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntryRejectionDescriptions_cause(ASN1decoding_t dec, MultiplexEntryRejectionDescriptions_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendAck_multiplexTableEntryNumber(ASN1encoding_t enc, MultiplexEntrySendAck_multiplexTableEntryNumber *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendAck_multiplexTableEntryNumber(ASN1decoding_t dec, MultiplexEntrySendAck_multiplexTableEntryNumber *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendAck_multiplexTableEntryNumber(MultiplexEntrySendAck_multiplexTableEntryNumber *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexElement_repeatCount(ASN1encoding_t enc, MultiplexElement_repeatCount *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.finite - 1))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexElement_repeatCount(ASN1decoding_t dec, MultiplexElement_repeatCount *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.finite))
	    return 0;
	(val)->u.finite += 1;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MultiplexElement_type(ASN1encoding_t enc, MultiplexElement_type *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MultiplexElement_type_subElementList(enc, &(val)->u.subElementList))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexElement_type(ASN1decoding_t dec, MultiplexElement_type *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MultiplexElement_type_subElementList(dec, &(val)->u.subElementList))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexElement_type(MultiplexElement_type *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_MultiplexElement_type_subElementList(&(val)->u.subElementList);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RequestChannelCloseReject_cause(ASN1encoding_t enc, RequestChannelCloseReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelCloseReject_cause(ASN1decoding_t dec, RequestChannelCloseReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestChannelClose_reason(ASN1encoding_t enc, RequestChannelClose_reason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelClose_reason(ASN1decoding_t dec, RequestChannelClose_reason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CloseLogicalChannel_reason(ASN1encoding_t enc, CloseLogicalChannel_reason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CloseLogicalChannel_reason(ASN1decoding_t dec, CloseLogicalChannel_reason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CloseLogicalChannel_source(ASN1encoding_t enc, CloseLogicalChannel_source *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CloseLogicalChannel_source(ASN1decoding_t dec, CloseLogicalChannel_source *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelReject_cause(ASN1encoding_t enc, OpenLogicalChannelReject_cause *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 6))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelReject_cause(ASN1decoding_t dec, OpenLogicalChannelReject_cause *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 6))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MulticastAddress_iP6Address(ASN1encoding_t enc, MulticastAddress_iP6Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 16))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MulticastAddress_iP6Address(ASN1decoding_t dec, MulticastAddress_iP6Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 16))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MulticastAddress_iP6Address(MulticastAddress_iP6Address *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MulticastAddress_iPAddress(ASN1encoding_t enc, MulticastAddress_iPAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MulticastAddress_iPAddress(ASN1decoding_t dec, MulticastAddress_iPAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MulticastAddress_iPAddress(MulticastAddress_iPAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress(ASN1encoding_t enc, UnicastAddress_iPSourceRouteAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_UnicastAddress_iPSourceRouteAddress_routing(enc, &(val)->routing))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
	return 0;
    if (!ASN1Enc_UnicastAddress_iPSourceRouteAddress_route(enc, &(val)->route))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress(ASN1decoding_t dec, UnicastAddress_iPSourceRouteAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_UnicastAddress_iPSourceRouteAddress_routing(dec, &(val)->routing))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
	return 0;
    if (!ASN1Dec_UnicastAddress_iPSourceRouteAddress_route(dec, &(val)->route))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress(UnicastAddress_iPSourceRouteAddress *val)
{
    if (val) {
	ASN1Free_UnicastAddress_iPSourceRouteAddress_route(&(val)->route);
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iP6Address(ASN1encoding_t enc, UnicastAddress_iP6Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 16))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iP6Address(ASN1decoding_t dec, UnicastAddress_iP6Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 16))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iP6Address(UnicastAddress_iP6Address *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPXAddress(ASN1encoding_t enc, UnicastAddress_iPXAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->tsapIdentifier, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPXAddress(ASN1decoding_t dec, UnicastAddress_iPXAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->tsapIdentifier, 2))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iPXAddress(UnicastAddress_iPXAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPAddress(ASN1encoding_t enc, UnicastAddress_iPAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPAddress(ASN1decoding_t dec, UnicastAddress_iPAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iPAddress(UnicastAddress_iPAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode(ASN1encoding_t enc, V76LogicalChannelParameters_mode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_V76LogicalChannelParameters_mode_eRM(enc, &(val)->u.eRM))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode(ASN1decoding_t dec, V76LogicalChannelParameters_mode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_V76LogicalChannelParameters_mode_eRM(dec, &(val)->u.eRM))
	    return 0;
	break;
    case 2:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_suspendResume(ASN1encoding_t enc, V76LogicalChannelParameters_suspendResume *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_suspendResume(ASN1decoding_t dec, V76LogicalChannelParameters_suspendResume *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AnnexCArqParameters_numberOfRetransmissions(ASN1encoding_t enc, H223AnnexCArqParameters_numberOfRetransmissions *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncBitVal(enc, 5, (val)->u.finite))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexCArqParameters_numberOfRetransmissions(ASN1decoding_t dec, H223AnnexCArqParameters_numberOfRetransmissions *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU16Val(dec, 5, &(val)->u.finite))
	    return 0;
	break;
    case 2:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL3MParameters_crcLength(ASN1encoding_t enc, H223AL3MParameters_crcLength *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL3MParameters_crcLength(ASN1decoding_t dec, H223AL3MParameters_crcLength *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL3MParameters_headerFormat(ASN1encoding_t enc, H223AL3MParameters_headerFormat *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL3MParameters_headerFormat(ASN1decoding_t dec, H223AL3MParameters_headerFormat *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL2MParameters_headerFEC(ASN1encoding_t enc, H223AL2MParameters_headerFEC *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL2MParameters_headerFEC(ASN1decoding_t dec, H223AL2MParameters_headerFEC *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL1MParameters_crcLength(ASN1encoding_t enc, H223AL1MParameters_crcLength *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL1MParameters_crcLength(ASN1decoding_t dec, H223AL1MParameters_crcLength *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL1MParameters_headerFEC(ASN1encoding_t enc, H223AL1MParameters_headerFEC *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL1MParameters_headerFEC(ASN1decoding_t dec, H223AL1MParameters_headerFEC *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL1MParameters_transferMode(ASN1encoding_t enc, H223AL1MParameters_transferMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL1MParameters_transferMode(ASN1decoding_t dec, H223AL1MParameters_transferMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static ASN1stringtableentry_t Q2931Address_address_internationalNumber_StringTableEntries[] = {
    { 32, 32, 0 }, { 48, 57, 1 }, 
};

static ASN1stringtable_t Q2931Address_address_internationalNumber_StringTable = {
    2, Q2931Address_address_internationalNumber_StringTableEntries
};

static int ASN1CALL ASN1Enc_Q2931Address_address(ASN1encoding_t enc, Q2931Address_address *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	t = lstrlenA((val)->u.internationalNumber);
	if (!ASN1PEREncBitVal(enc, 4, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.internationalNumber, 4, &Q2931Address_address_internationalNumber_StringTable))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->u.nsapAddress, 1, 20, 5))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Q2931Address_address(ASN1decoding_t dec, Q2931Address_address *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU32Val(dec, 4, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.internationalNumber, 4, &Q2931Address_address_internationalNumber_StringTable))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->u.nsapAddress, 1, 20, 5))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Q2931Address_address(Q2931Address_address *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    break;
	case 2:
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_NetworkAccessParameters_t120SetupProcedure(ASN1encoding_t enc, NetworkAccessParameters_t120SetupProcedure *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkAccessParameters_t120SetupProcedure(ASN1decoding_t dec, NetworkAccessParameters_t120SetupProcedure *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NetworkAccessParameters_distribution(ASN1encoding_t enc, NetworkAccessParameters_distribution *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkAccessParameters_distribution(ASN1decoding_t dec, NetworkAccessParameters_distribution *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_T84Profile_t84Restricted(ASN1encoding_t enc, T84Profile_t84Restricted *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->qcif))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->cif))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->ccir601Seq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->ccir601Prog))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->hdtvSeq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->hdtvProg))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->g3FacsMH200x100))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->g3FacsMH200x200))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->g4FacsMMR200x100))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->g4FacsMMR200x200))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->jbig200x200Seq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->jbig200x200Prog))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->jbig300x300Seq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->jbig300x300Prog))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoLow))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoMedSeq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoMedProg))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoHighSeq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoHighProg))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_T84Profile_t84Restricted(ASN1decoding_t dec, T84Profile_t84Restricted *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->qcif))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->cif))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->ccir601Seq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->ccir601Prog))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->hdtvSeq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->hdtvProg))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->g3FacsMH200x100))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->g3FacsMH200x200))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->g4FacsMMR200x100))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->g4FacsMMR200x200))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->jbig200x200Seq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->jbig200x200Prog))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->jbig300x300Seq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->jbig300x300Prog))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoLow))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoMedSeq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoMedProg))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoHighSeq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoHighProg))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_G7231AnnexCCapability_g723AnnexCAudioMode(ASN1encoding_t enc, G7231AnnexCCapability_g723AnnexCAudioMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->highRateMode0 - 27))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->highRateMode1 - 27))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->lowRateMode0 - 23))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->lowRateMode1 - 23))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->sidMode0 - 6))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->sidMode1 - 6))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_G7231AnnexCCapability_g723AnnexCAudioMode(ASN1decoding_t dec, G7231AnnexCCapability_g723AnnexCAudioMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->highRateMode0))
	return 0;
    (val)->highRateMode0 += 27;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->highRateMode1))
	return 0;
    (val)->highRateMode1 += 27;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->lowRateMode0))
	return 0;
    (val)->lowRateMode0 += 23;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->lowRateMode1))
	return 0;
    (val)->lowRateMode1 += 23;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->sidMode0))
	return 0;
    (val)->sidMode0 += 6;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->sidMode1))
	return 0;
    (val)->sidMode1 += 6;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_AudioCapability_g7231(ASN1encoding_t enc, AudioCapability_g7231 *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->maxAl_sduAudioFrames - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->silenceSuppression))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AudioCapability_g7231(ASN1decoding_t dec, AudioCapability_g7231 *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maxAl_sduAudioFrames))
	return 0;
    (val)->maxAl_sduAudioFrames += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->silenceSuppression))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncBoolean(enc, (val)->u.anyPixelAspectRatio))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(enc, &(val)->u.pixelAspectCode))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR(enc, &(val)->u.extendedPAR))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecBoolean(dec, &(val)->u.anyPixelAspectRatio))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(dec, &(val)->u.pixelAspectCode))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR(dec, &(val)->u.extendedPAR))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation(CustomPictureFormat_pixelAspectInformation *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(&(val)->u.pixelAspectCode);
	    break;
	case 3:
	    ASN1Free_CustomPictureFormat_pixelAspectInformation_extendedPAR(&(val)->u.extendedPAR);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI(ASN1encoding_t enc, CustomPictureFormat_mPI *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->standardMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CustomPictureFormat_mPI_customPCF(enc, &(val)->customPCF))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI(ASN1decoding_t dec, CustomPictureFormat_mPI *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->standardMPI))
	    return 0;
	(val)->standardMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_CustomPictureFormat_mPI_customPCF(dec, &(val)->customPCF))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat_mPI(CustomPictureFormat_mPI *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CustomPictureFormat_mPI_customPCF(&(val)->customPCF);
	}
    }
}

static int ASN1CALL ASN1Enc_RefPictureSelection_videoBackChannelSend(ASN1encoding_t enc, RefPictureSelection_videoBackChannelSend *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RefPictureSelection_videoBackChannelSend(ASN1decoding_t dec, RefPictureSelection_videoBackChannelSend *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RefPictureSelection_additionalPictureMemory(ASN1encoding_t enc, RefPictureSelection_additionalPictureMemory *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->sqcifAdditionalPictureMemory - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->qcifAdditionalPictureMemory - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->cifAdditionalPictureMemory - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->cif4AdditionalPictureMemory - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->cif16AdditionalPictureMemory - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->bigCpfAdditionalPictureMemory - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RefPictureSelection_additionalPictureMemory(ASN1decoding_t dec, RefPictureSelection_additionalPictureMemory *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->sqcifAdditionalPictureMemory))
	    return 0;
	(val)->sqcifAdditionalPictureMemory += 1;
    }
    if ((val)->o[0] & 0x40) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->qcifAdditionalPictureMemory))
	    return 0;
	(val)->qcifAdditionalPictureMemory += 1;
    }
    if ((val)->o[0] & 0x20) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->cifAdditionalPictureMemory))
	    return 0;
	(val)->cifAdditionalPictureMemory += 1;
    }
    if ((val)->o[0] & 0x10) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->cif4AdditionalPictureMemory))
	    return 0;
	(val)->cif4AdditionalPictureMemory += 1;
    }
    if ((val)->o[0] & 0x8) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->cif16AdditionalPictureMemory))
	    return 0;
	(val)->cif16AdditionalPictureMemory += 1;
    }
    if ((val)->o[0] & 0x4) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->bigCpfAdditionalPictureMemory))
	    return 0;
	(val)->bigCpfAdditionalPictureMemory += 1;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyFrameMapping_frameSequence(ASN1encoding_t enc, RTPH263VideoRedundancyFrameMapping_frameSequence *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyFrameMapping_frameSequence(ASN1decoding_t dec, RTPH263VideoRedundancyFrameMapping_frameSequence *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyFrameMapping_frameSequence(RTPH263VideoRedundancyFrameMapping_frameSequence *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_containedThreads(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding_containedThreads *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_containedThreads(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding_containedThreads *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_containedThreads(RTPH263VideoRedundancyEncoding_containedThreads *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding_frameToThreadMapping *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(enc, &(val)->u.custom))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding_frameToThreadMapping *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(dec, &(val)->u.custom))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping(RTPH263VideoRedundancyEncoding_frameToThreadMapping *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(&(val)->u.custom);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncodingCapability_secondaryEncoding(ASN1encoding_t enc, PRedundancyEncodingCapability_secondaryEncoding *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RedundancyEncodingCapability_secondaryEncoding_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_RedundancyEncodingCapability_secondaryEncoding_ElmFn(ASN1encoding_t enc, PRedundancyEncodingCapability_secondaryEncoding val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncodingCapability_secondaryEncoding(ASN1decoding_t dec, PRedundancyEncodingCapability_secondaryEncoding *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RedundancyEncodingCapability_secondaryEncoding_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_RedundancyEncodingCapability_secondaryEncoding_ElmFn(ASN1decoding_t dec, PRedundancyEncodingCapability_secondaryEncoding val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncodingCapability_secondaryEncoding(PRedundancyEncodingCapability_secondaryEncoding *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RedundancyEncodingCapability_secondaryEncoding_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RedundancyEncodingCapability_secondaryEncoding_ElmFn(PRedundancyEncodingCapability_secondaryEncoding val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H2250Capability_mcCapability(ASN1encoding_t enc, H2250Capability_mcCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->centralizedConferenceMC))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->decentralizedConferenceMC))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250Capability_mcCapability(ASN1decoding_t dec, H2250Capability_mcCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->centralizedConferenceMC))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->decentralizedConferenceMC))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223Capability_mobileOperationTransmitCapability(ASN1encoding_t enc, H223Capability_mobileOperationTransmitCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->modeChangeCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->h223AnnexA))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->h223AnnexADoubleFlag))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->h223AnnexB))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->h223AnnexBwithHeader))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223Capability_mobileOperationTransmitCapability(ASN1decoding_t dec, H223Capability_mobileOperationTransmitCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->modeChangeCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->h223AnnexA))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->h223AnnexADoubleFlag))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->h223AnnexB))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->h223AnnexBwithHeader))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223Capability_h223MultiplexTableCapability(ASN1encoding_t enc, H223Capability_h223MultiplexTableCapability *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_H223Capability_h223MultiplexTableCapability_enhanced(enc, &(val)->u.enhanced))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223Capability_h223MultiplexTableCapability(ASN1decoding_t dec, H223Capability_h223MultiplexTableCapability *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_H223Capability_h223MultiplexTableCapability_enhanced(dec, &(val)->u.enhanced))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_availableBitRates(ASN1encoding_t enc, VCCapability_availableBitRates *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_VCCapability_availableBitRates_type(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_availableBitRates(ASN1decoding_t dec, VCCapability_availableBitRates *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_VCCapability_availableBitRates_type(dec, &(val)->type))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_aal5(ASN1encoding_t enc, VCCapability_aal5 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardMaximumSDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->backwardMaximumSDUSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_aal5(ASN1decoding_t dec, VCCapability_aal5 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardMaximumSDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->backwardMaximumSDUSize))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_aal1(ASN1encoding_t enc, VCCapability_aal1 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->nullClockRecovery))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->srtsClockRecovery))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->adaptiveClockRecovery))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->nullErrorCorrection))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->longInterleaver))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->shortInterleaver))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->errorCorrectionOnly))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->structuredDataTransfer))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->partiallyFilledCells))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_aal1(ASN1decoding_t dec, VCCapability_aal1 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->nullClockRecovery))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->srtsClockRecovery))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->adaptiveClockRecovery))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->nullErrorCorrection))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->longInterleaver))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->shortInterleaver))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->errorCorrectionOnly))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->structuredDataTransfer))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->partiallyFilledCells))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_Capability_h233EncryptionReceiveCapability(ASN1encoding_t enc, Capability_h233EncryptionReceiveCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->h233IVResponseTime))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Capability_h233EncryptionReceiveCapability(ASN1decoding_t dec, Capability_h233EncryptionReceiveCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->h233IVResponseTime))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject_cause(ASN1encoding_t enc, TerminalCapabilitySetReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Enc_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(enc, &(val)->u.tableEntryCapacityExceeded))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject_cause(ASN1decoding_t dec, TerminalCapabilitySetReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Dec_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(dec, &(val)->u.tableEntryCapacityExceeded))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationReject_cause(ASN1encoding_t enc, MasterSlaveDeterminationReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationReject_cause(ASN1decoding_t dec, MasterSlaveDeterminationReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationAck_decision(ASN1encoding_t enc, MasterSlaveDeterminationAck_decision *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationAck_decision(ASN1decoding_t dec, MasterSlaveDeterminationAck_decision *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NonStandardIdentifier_h221NonStandard(ASN1encoding_t enc, NonStandardIdentifier_h221NonStandard *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35CountryCode))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35Extension))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->manufacturerCode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardIdentifier_h221NonStandard(ASN1decoding_t dec, NonStandardIdentifier_h221NonStandard *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35CountryCode))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35Extension))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->manufacturerCode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NonStandardIdentifier(ASN1encoding_t enc, NonStandardIdentifier *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_NonStandardIdentifier_h221NonStandard(enc, &(val)->u.h221NonStandard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardIdentifier(ASN1decoding_t dec, NonStandardIdentifier *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_NonStandardIdentifier_h221NonStandard(dec, &(val)->u.h221NonStandard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardIdentifier(NonStandardIdentifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1objectidentifier_free(&(val)->u.object);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MasterSlaveDetermination(ASN1encoding_t enc, MasterSlaveDetermination *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->terminalType))
	return 0;
    l = ASN1uint32_uoctets((val)->statusDeterminationNumber);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->statusDeterminationNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDetermination(ASN1decoding_t dec, MasterSlaveDetermination *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->terminalType))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->statusDeterminationNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationAck(ASN1encoding_t enc, MasterSlaveDeterminationAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MasterSlaveDeterminationAck_decision(enc, &(val)->decision))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationAck(ASN1decoding_t dec, MasterSlaveDeterminationAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MasterSlaveDeterminationAck_decision(dec, &(val)->decision))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationReject(ASN1encoding_t enc, MasterSlaveDeterminationReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MasterSlaveDeterminationReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationReject(ASN1decoding_t dec, MasterSlaveDeterminationReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MasterSlaveDeterminationReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationRelease(ASN1encoding_t enc, MasterSlaveDeterminationRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationRelease(ASN1decoding_t dec, MasterSlaveDeterminationRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CapabilityDescriptor(ASN1encoding_t enc, CapabilityDescriptor *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->capabilityDescriptorNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CapabilityDescriptor_simultaneousCapabilities(enc, &(val)->simultaneousCapabilities))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CapabilityDescriptor(ASN1decoding_t dec, CapabilityDescriptor *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->capabilityDescriptorNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CapabilityDescriptor_simultaneousCapabilities(dec, &(val)->simultaneousCapabilities))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CapabilityDescriptor(CapabilityDescriptor *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CapabilityDescriptor_simultaneousCapabilities(&(val)->simultaneousCapabilities);
	}
    }
}

static int ASN1CALL ASN1Enc_AlternativeCapabilitySet(ASN1encoding_t enc, AlternativeCapabilitySet *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncUnsignedShort(enc, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AlternativeCapabilitySet(ASN1decoding_t dec, AlternativeCapabilitySet *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecUnsignedShort(dec, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AlternativeCapabilitySet(AlternativeCapabilitySet *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetAck(ASN1encoding_t enc, TerminalCapabilitySetAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetAck(ASN1decoding_t dec, TerminalCapabilitySetAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject(ASN1encoding_t enc, TerminalCapabilitySetReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_TerminalCapabilitySetReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject(ASN1decoding_t dec, TerminalCapabilitySetReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_TerminalCapabilitySetReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetRelease(ASN1encoding_t enc, TerminalCapabilitySetRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetRelease(ASN1decoding_t dec, TerminalCapabilitySetRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H222Capability(ASN1encoding_t enc, H222Capability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->numberOfVCs - 1))
	return 0;
    if (!ASN1Enc_H222Capability_vcCapability(enc, &(val)->vcCapability))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H222Capability(ASN1decoding_t dec, H222Capability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->numberOfVCs))
	return 0;
    (val)->numberOfVCs += 1;
    if (!ASN1Dec_H222Capability_vcCapability(dec, &(val)->vcCapability))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H222Capability(H222Capability *val)
{
    if (val) {
	ASN1Free_H222Capability_vcCapability(&(val)->vcCapability);
    }
}

static int ASN1CALL ASN1Enc_VCCapability(ASN1encoding_t enc, VCCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_VCCapability_aal1(enc, &(val)->aal1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_VCCapability_aal5(enc, &(val)->aal5))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->transportStream))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->programStream))
	return 0;
    if (!ASN1Enc_VCCapability_availableBitRates(enc, &(val)->availableBitRates))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability(ASN1decoding_t dec, VCCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_VCCapability_aal1(dec, &(val)->aal1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_VCCapability_aal5(dec, &(val)->aal5))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->transportStream))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->programStream))
	return 0;
    if (!ASN1Dec_VCCapability_availableBitRates(dec, &(val)->availableBitRates))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AnnexCCapability(ASN1encoding_t enc, H223AnnexCCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL1M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL2M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL3M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL1M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL2M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL3M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL1M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL2M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL3M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alpduInterleaving))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAL1MPDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAL2MSDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAL3MSDUSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexCCapability(ASN1decoding_t dec, H223AnnexCCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL1M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL2M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL3M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL1M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL2M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL3M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL1M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL2M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL3M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alpduInterleaving))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAL1MPDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAL2MSDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAL3MSDUSize))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V75Capability(ASN1encoding_t enc, V75Capability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioHeader))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V75Capability(ASN1decoding_t dec, V75Capability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioHeader))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_QOSMode(ASN1encoding_t enc, QOSMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_QOSMode(ASN1decoding_t dec, QOSMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ATMParameters(ASN1encoding_t enc, ATMParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maxNTUSize))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atmUBR))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atmrtVBR))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atmnrtVBR))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atmABR))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atmCBR))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ATMParameters(ASN1decoding_t dec, ATMParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maxNTUSize))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atmUBR))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atmrtVBR))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atmnrtVBR))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atmABR))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atmCBR))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MediaTransportType(ASN1encoding_t enc, MediaTransportType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MediaTransportType(ASN1decoding_t dec, MediaTransportType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MediaChannelCapability(ASN1encoding_t enc, MediaChannelCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_MediaTransportType(enc, &(val)->mediaTransport))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MediaChannelCapability(ASN1decoding_t dec, MediaChannelCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_MediaTransportType(dec, &(val)->mediaTransport))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->numberOfThreads - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->framesBetweenSyncPoints - 1))
	return 0;
    if (!ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping(enc, &(val)->frameToThreadMapping))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_RTPH263VideoRedundancyEncoding_containedThreads(enc, &(val)->containedThreads))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->numberOfThreads))
	return 0;
    (val)->numberOfThreads += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->framesBetweenSyncPoints))
	return 0;
    (val)->framesBetweenSyncPoints += 1;
    if (!ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping(dec, &(val)->frameToThreadMapping))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_RTPH263VideoRedundancyEncoding_containedThreads(dec, &(val)->containedThreads))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding(RTPH263VideoRedundancyEncoding *val)
{
    if (val) {
	ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping(&(val)->frameToThreadMapping);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_RTPH263VideoRedundancyEncoding_containedThreads(&(val)->containedThreads);
	}
    }
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyFrameMapping(ASN1encoding_t enc, RTPH263VideoRedundancyFrameMapping *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->threadNumber))
	return 0;
    if (!ASN1Enc_RTPH263VideoRedundancyFrameMapping_frameSequence(enc, &(val)->frameSequence))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyFrameMapping(ASN1decoding_t dec, RTPH263VideoRedundancyFrameMapping *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->threadNumber))
	return 0;
    if (!ASN1Dec_RTPH263VideoRedundancyFrameMapping_frameSequence(dec, &(val)->frameSequence))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyFrameMapping(RTPH263VideoRedundancyFrameMapping *val)
{
    if (val) {
	ASN1Free_RTPH263VideoRedundancyFrameMapping_frameSequence(&(val)->frameSequence);
    }
}

static int ASN1CALL ASN1Enc_MultipointCapability(ASN1encoding_t enc, MultipointCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multicastCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multiUniCastConference))
	return 0;
    if (!ASN1Enc_MultipointCapability_mediaDistributionCapability(enc, &(val)->mediaDistributionCapability))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultipointCapability(ASN1decoding_t dec, MultipointCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multicastCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multiUniCastConference))
	return 0;
    if (!ASN1Dec_MultipointCapability_mediaDistributionCapability(dec, &(val)->mediaDistributionCapability))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultipointCapability(MultipointCapability *val)
{
    if (val) {
	ASN1Free_MultipointCapability_mediaDistributionCapability(&(val)->mediaDistributionCapability);
    }
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability(ASN1encoding_t enc, MediaDistributionCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->centralizedControl))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->distributedControl))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->centralizedAudio))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->distributedAudio))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->centralizedVideo))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->distributedVideo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_MediaDistributionCapability_centralizedData(enc, &(val)->centralizedData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_MediaDistributionCapability_distributedData(enc, &(val)->distributedData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability(ASN1decoding_t dec, MediaDistributionCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->centralizedControl))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->distributedControl))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->centralizedAudio))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->distributedAudio))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->centralizedVideo))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->distributedVideo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_MediaDistributionCapability_centralizedData(dec, &(val)->centralizedData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_MediaDistributionCapability_distributedData(dec, &(val)->distributedData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MediaDistributionCapability(MediaDistributionCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MediaDistributionCapability_centralizedData(&(val)->centralizedData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_MediaDistributionCapability_distributedData(&(val)->distributedData);
	}
    }
}

static int ASN1CALL ASN1Enc_H261VideoCapability(ASN1encoding_t enc, H261VideoCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 2, (val)->qcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 2, (val)->cifMPI - 1))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->temporalSpatialTradeOffCapability))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maxBitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->stillImageTransmission))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H261VideoCapability(ASN1decoding_t dec, H261VideoCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 2, &(val)->qcifMPI))
	    return 0;
	(val)->qcifMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 2, &(val)->cifMPI))
	    return 0;
	(val)->cifMPI += 1;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->temporalSpatialTradeOffCapability))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maxBitRate))
	return 0;
    (val)->maxBitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->stillImageTransmission))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H262VideoCapability(ASN1encoding_t enc, H262VideoCapability *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_SPatML))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_MPatLL))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_MPatML))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_MPatH_14))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_MPatHL))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_SNRatLL))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_SNRatML))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_SpatialatH_14))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_HPatML))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_HPatH_14))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_HPatHL))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->videoBitRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->vbvBufferSize);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->framesPerSecond))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->luminanceSampleRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->luminanceSampleRate))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H262VideoCapability(ASN1decoding_t dec, H262VideoCapability *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_SPatML))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_MPatLL))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_MPatML))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_MPatH_14))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_MPatHL))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_SNRatLL))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_SNRatML))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_SpatialatH_14))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_HPatML))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_HPatH_14))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_HPatHL))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->framesPerSecond))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->luminanceSampleRate))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo(ASN1encoding_t enc, EnhancementLayerInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->baseBitRateConstrained))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_EnhancementLayerInfo_snrEnhancement(enc, &(val)->snrEnhancement))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_EnhancementLayerInfo_spatialEnhancement(enc, &(val)->spatialEnhancement))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_EnhancementLayerInfo_bPictureEnhancement(enc, &(val)->bPictureEnhancement))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo(ASN1decoding_t dec, EnhancementLayerInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->baseBitRateConstrained))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_EnhancementLayerInfo_snrEnhancement(dec, &(val)->snrEnhancement))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_EnhancementLayerInfo_spatialEnhancement(dec, &(val)->spatialEnhancement))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_EnhancementLayerInfo_bPictureEnhancement(dec, &(val)->bPictureEnhancement))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo(EnhancementLayerInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_EnhancementLayerInfo_snrEnhancement(&(val)->snrEnhancement);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_EnhancementLayerInfo_spatialEnhancement(&(val)->spatialEnhancement);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_EnhancementLayerInfo_bPictureEnhancement(&(val)->bPictureEnhancement);
	}
    }
}

static int ASN1CALL ASN1Enc_TransparencyParameters(ASN1encoding_t enc, TransparencyParameters *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->presentationOrder - 1))
	return 0;
    l = ASN1uint32_uoctets((val)->offset_x + 262144);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->offset_x + 262144))
	return 0;
    l = ASN1uint32_uoctets((val)->offset_y + 262144);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->offset_y + 262144))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->scale_x - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->scale_y - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransparencyParameters(ASN1decoding_t dec, TransparencyParameters *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->presentationOrder))
	return 0;
    (val)->presentationOrder += 1;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->offset_x))
	return 0;
    (val)->offset_x += 0 - 262144;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->offset_y))
	return 0;
    (val)->offset_y += 0 - 262144;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->scale_x))
	return 0;
    (val)->scale_x += 1;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->scale_y))
	return 0;
    (val)->scale_y += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RefPictureSelection(ASN1encoding_t enc, RefPictureSelection *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_RefPictureSelection_additionalPictureMemory(enc, &(val)->additionalPictureMemory))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->videoMux))
	return 0;
    if (!ASN1Enc_RefPictureSelection_videoBackChannelSend(enc, &(val)->videoBackChannelSend))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RefPictureSelection(ASN1decoding_t dec, RefPictureSelection *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_RefPictureSelection_additionalPictureMemory(dec, &(val)->additionalPictureMemory))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->videoMux))
	return 0;
    if (!ASN1Dec_RefPictureSelection_videoBackChannelSend(dec, &(val)->videoBackChannelSend))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureClockFrequency(ASN1encoding_t enc, CustomPictureClockFrequency *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->clockConversionCode - 1000))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->clockDivisor - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->sqcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncUnsignedShor