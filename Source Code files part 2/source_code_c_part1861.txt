es Whitmer [chuckwh]                                        ;
;                                                                          ;
; Copyright (c) 1991-1999 Microsoft Corporation                            ;
;--------------------------------------------------------------------------;

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc
	include gdii386.inc
        .list

        .code

QUAD    struc
        lo      dd      0
        hi      dd      0
QUAD    ends

	extrn	cmp_table_1:dword
	extrn	cmp_table_2:dword
	extrn	cmp_table_3:dword
	extrn	cmp_table_4:dword

;------------------------------Public-Routine------------------------------;
; LONG    fxYIntersect (pptlAB,pptlCD)                                     ;
; POINTL *pptlAB;       // First line segment.                             ;
; POINTL *pptlCD;       // Second line segment.                            ;
;                                                                          ;
; Computes the y coordinate of the intersection of the two line segments.  ;
; The returned value is the ceiling of the exact geometric intersection.   ;
;                                                                          ;
; The intersection is computed by:                                         ;
;                                                                          ;
;           (Cx - Ax)(Cy - Dy) + (Cy - Ay)(Dx - Cx)                        ;
;   lamda = ---------------------------------------                        ;
;           (Bx - Ax)(Cy - Dy) + (By - Ay)(Dx - Cx)                        ;
;                                                                          ;
; If (lamda < 0) or (lamda > 1) then there is no intersection, and we      ;
; return 0x80000000.                                                       ;
;                                                                          ;
;   Y = Ay + lamda * (By - Ay)                                             ;
;                                                                          ;
; We assume on entry to this routine that all coordinates are limited to   ;
; 31 bits of significance.  Because of this we know that quantities like   ;
; (Cx - Ax) will fit in 32 bits.  Also, products like (Cx - Ax)(Cy - Dy)   ;
; will fit in 63 bits, and sums as in the numerator of lamda will fit in   ;
; 64 bits.                                                                 ;
;                                                                          ;
; Note that if you call this routine with POINTFX's instead of POINTL's    ;
; you'll get answers that are correct down to 1/16th pel.  If you only     ;
; want the integer part, just shift the answer right by 4 bits.            ;
;                                                                          ;
; History:                                                                 ;
;  Wed 25-Sep-1991 16:52:20 -by- Wendy Wu [wendywu]                        ;
; 1) Changed to return the ceiling of the geometric intersection rather    ;
;    than the floor.                                                       ;
; 2) When the given two line segments are actually the same line, we used  ;
;    to return 0x80000000, now return the y at which they last "intersect".;
; 3) If Y is bigger or smaller than both Cy and Dy, return 0x80000000.     ;
;                                                                          ;
;  Fri 26-Apr-1991 10:52:28 -by- Charles Whitmer [chuckwh]                 ;
; Wrote it.                                                                ;
;--------------------------------------------------------------------------;

SEGAB   struc
        AB_xA   dd      0
        AB_yA   dd      0
        AB_xB   dd      0
        AB_yB   dd      0
SEGAB   ends

SEGCD   struc
        CD_xC   dd      0
        CD_yC   dd      0
        CD_xD   dd      0
        CD_yD   dd      0
SEGCD   ends

cProc   fxYIntersect,8,<          \
        uses    ebx esi edi,      \
        pptlAB: ptr SEGAB,        \
        pptlCD: ptr SEGCD         >

local   xA:     dword
local   yA:     dword
local   yByA:   dword
local   qDenom: qword

; Load AB into registers.

        mov     esi,pptlAB
        mov     ebx,[esi].AB_yA
        mov     edx,[esi].AB_yB
        mov     eax,[esi].AB_xA
        mov     ecx,[esi].AB_xB

; Reorder AB so that By >= Ay.  This will guarantee that (By - Ay)*lamda is a
; positive number so that it's easier to compute the ceiling.  (This lets us
; complete the division earlier than a normal extended precision one.)

        cmp     edx,ebx
        jg      @F
        xchg    eax,ecx
        xchg    ebx,edx
@@:

; Save A locally.

        mov     xA,eax
        mov     yA,ebx

; Compute qDenom = (Bx - Ax)(Cy - Dy) + (By - Ay)(Dx - Cx).

        sub     edx,ebx                 ; EDX = (By - Ay)
        mov     esi,pptlCD
        sub     ecx,eax                 ; ECX = (Bx - Ax)
        mov     eax,[esi].CD_xD
        mov     yByA,edx
        sub     eax,[esi].CD_xC         ; EAX = (Dx - Cx)
        imul    edx                     ; EDX:EAX = (By - Ay)(Dx - Cx)
        xchg    ecx,edx                 ; EDX = (Bx - Ax)
        mov     ebx,eax                 ; ECX:EBX = (By - Ay)(Dx - Cx)
        mov     eax,[esi].CD_yC
        sub     eax,[esi].CD_yD         ; EAX = (Cy - Dy)
        imul    edx                     ; EDX:EAX = (Bx - Ax)(Cy - Dy)
        add     ebx,eax
        jz      qDenom_maybe_zero
        adc     ecx,edx                 ; ECX:EBX = qDenom

qDenom_not_zero:
        mov     qDenom.lo,ebx
        mov     qDenom.hi,ecx

; Compute qNum = (Cx - Ax)(Cy - Dy) + (Cy - Ay)(Dx - Cx).

        mov     edx,[esi].CD_yC
        sub     edx,yA                  ; EDX = (Cy - Ay)
        mov     eax,[esi].CD_xD
        sub     eax,[esi].CD_xC         ; EAX = (Dx - Cx)
        imul    edx                     ; EDX:EAX = (Cy - Ay)(Dx - Cx)
        mov     ecx,edx
        mov     ebx,eax                 ; ECX:EBX = (Cy - Ay)(Dx - Cx)
        mov     edx,[esi].CD_xC
        sub     edx,xA                  ; EDX = (Cx - Ax)
        mov     eax,[esi].CD_yC
        sub     eax,[esi].CD_yD         ; EAX = (Cy - Dy)
        imul    edx                     ; EDX:EAX = (Cx - Ax)(Cy - Dy)
        add     eax,ebx
        adc     edx,ecx                 ; EDX:EAX = qNum

; Force the denominator to be positive.

        mov     ebx,qDenom.lo
        mov     ecx,qDenom.hi           ; ECX:EBX = qDenom
        or      ecx,ecx
        jns     @F
        neg     ebx                     ; Negate qDenom.
        adc     ecx,0
        neg     ecx
        neg     eax                     ; Negate qNum.
        adc     edx,0
        neg     edx
        js      no_intersection         ; (qNum < 0) => (lamda < 0)
@@:

; See if (lamda > 1).

        cmp     edx,ecx
        ja      no_intersection         ; (uqNum > uqDenom) => (lamda > 1)
        jb      no_problem
        cmp     eax,ebx
        jbe     no_problem
no_intersection:
        mov     eax,80000000h
        cRet    fxYIntersect

no_problem:

; See if we can do a short form calculation.
; (99% of all cases get handled here.)

        or      ecx,ecx
        jnz     long_form
        mul     yByA                    ; EDX:EAX = (By - Ay) uqNum
        div     ebx                     ; EAX = (By - Ay) uqNum / uqDenom

; Get the ceiling of the intersection by incrementing the quotient
; by 1 if the remainder is bigger than zero.

        cmp     ecx,edx                 ; CF = 1 if (edx > 0)
        adc     eax,0
        add     eax,yA                  ; EAX = CEILING((By - Ay) uqNum /
                                        ;               uqDenom) + Ay
; Compare the intersection y with Cy and Dy.
; Return 0x80000000 if the intersection y is not between Cy and Dy.

cmp_with_cy_dy:
        cmp     eax,[esi].CD_yC
        jg      @F
        jz      done
        cmp     eax,[esi].CD_yD
        jl      no_intersection
        cRet    fxYIntersect
@@:
        cmp     eax,[esi].CD_yD
        jg      no_intersection
done:
        cRet    fxYIntersect
long_form:

; Do the extended precision calculation.

; Count the bits needed to normalize the denominator.

        mov     esi,ecx
        mov     edi,ebx                 ; ESI:EDI = uqDenom.
        xor     ecx,ecx
        cmp     esi,10000h              ; This binary search scheme is a lot
        adc     ecx,ecx                 ; faster than BSR.
        cmp     esi,cmp_table_1[4*ecx]
        adc     ecx,ecx
        cmp     esi,cmp_table_2[4*ecx]
        adc     ecx,ecx
        cmp     esi,cmp_table_3[4*ecx]
        adc     ecx,ecx
        cmp     esi,cmp_table_4[4*ecx]
        adc     ecx,ecx                 ; CL = number of bits to shift left!

; Normalize the denominator and numerator.

        shld    esi,edi,cl
        shl     edi,cl
        shld    edx,eax,cl              ; EDX:EAX = uqNum.
        shl     eax,cl

; Compute uqNum * (By - Ay), a 95 bit result.

        mov     ebx,edx
        mul     yByA
        xchg    eax,ebx
        mov     ecx,edx
        mul     yByA
        add     eax,ecx
        adc     edx,0                   ; EDX:EAX:EBX = (By - Ay) * uqNum

; Divide by the 64 bit uqDenom, we're only interested in the integer part!
; (We would have to worry about overflow in the general case, but we know the
; answer cannot be 0FFFFFFFFh in this case, since (By - Ay) is bounded below
; that.)

        div     esi
        mov     ecx,edx                 ; ECX:EBX = remainder, so far.

; We want to increment the quotient if the remainder is positive.  In this
; case, we want the carry flag set to avoid jumps.  In order to do this,
; instead of calculating the remainder, we calculate the minus remainder.

        mov     esi,eax                 ; Hold quotient temporarily.
        mul     edi
        sub     eax,ebx
        sbb     edx,ecx                 ; EDX:EAX = -remainder

; We don't have enough bits here, since the remainder is unsigned.  We
; therefore use the carry bit instead of a sign bit.  If the carry
; is set, we have a positive remainder.  We'll increment the quotient
; in this case.

; (We have bounded (By - Ay) to be less than 2^31, so we also know that
; the quotient is less than 2^31.  This guarantees that we only have to
; adjust for the quotient once.)

        adc     esi,0
        mov     eax,esi

; Add Ay to the result then compare it with Cy and Dy.

        add     eax,yA
        mov     esi,pptlCD
        jmp     cmp_with_cy_dy

qDenom_maybe_zero:
        adc     ecx,edx                 ; ECX:EBX = qDenom
        jnz     qDenom_not_zero

; These two lines are parallel since qDenom is zero, we have to find out if
; they are actually the same line.
; !!! We may want to change the interface for ulPtOnWhichSide so we call
; !!! it in a more efficient way.  However, this is not a critical path
; !!! so lets wait until performance tuning time. [wendywu]

        mov     esi,pptlAB
        mov     edi,pptlCD

        cCall   ulPtOnWhichSide,<edi,esi>       ; See if C is on SEGAB

        cmp     eax,POINT_ON_LINE
        jnz     no_intersection

; They are indeed the same line, return the last point they meet.
; MIN(MAX(AB_yA, AB_yB), MAX(CD_yC, CD_yD))

        mov     eax,[esi].AB_yA
        cmp     eax,[esi].AB_yB
        jg      @F
        mov     eax,[esi].AB_yB         ; EAX = MAX((AB_yA, AB_yB)
@@:
        mov     ebx,[edi].CD_yC
        cmp     ebx,[edi].CD_yD
        jg      @F
        mov     ebx,[edi].CD_yD         ; EBX = MAX(CD_yC, CD_yD)
@@:
        cmp     eax,ebx
        jl      @F
        mov     eax,ebx
@@:
        cRet    fxYIntersect

endProc fxYIntersect

;------------------------------Public-Routine------------------------------;
; ULONG  ulPtOnWhichSide(pptl,pptlAB)                                      ;
; POINTL *pptl;         // Point in question.                              ;
; POINTL *pptlAB;       // Line segment.                                   ;
;                                                                          ;
; Compute on which side of the line a given point lies.  This is           ;
; determined by the sign of the z component of the cross product of        ;
; the two vectors (pptlB - pptlA) x (pptl - pptlA). i.e. the sign of       ;
;                                                                          ;
; (Bx - Ax) * (y - Ay) - (By - Ay) * (x - Ax)                              ;
;                                                                          ;
; We make sure By >= Ay so the first vector is in the 1st or 2nd quadrant. ;
; If the above product is                                                  ;
;     1) positive -> the given point is on the left side of the line       ;
;     2) negative -> the given point is on the right side of the line      ;
;     3) zero -> the given point is on the given line                      ;
;                                                                          ;
; History:                                                                 ;
;  Wed 25-Sep-1991 16:52:20 -by- Wendy Wu [wendywu]                        ;
; Wrote it.                                                                ;
;--------------------------------------------------------------------------;

cProc   ulPtOnWhichSide,8,<       \
        uses    ebx esi,          \
        pptl:   ptr POINTL,       \
        pptlAB: ptr SEGAB         >

local   yByA:   dword
local   xBxA:   dword

; Load AB into registers.

        mov     esi,pptlAB
        mov     ebx,[esi].AB_yA
        mov     edx,[esi].AB_yB
        mov     ecx,[esi].AB_xA
        mov     eax,[esi].AB_xB

; Reorder AB so that By >= Ay.

        cmp     edx,ebx
        jg      @F
        xchg    eax,ecx
        xchg    ebx,edx
@@:
        sub     eax,ecx                 ; Compute (Bx - Ax)
        mov     xBxA,eax

        sub     edx,ebx                 ; Compute (By - Ay)
        mov     yByA,edx

        mov     esi,pptl
	mov	eax,[esi].ptl_y 	; Compute (y - Ay)
        sub     eax,ebx
        imul    xBxA

        mov     ebx,eax

	mov	eax,[esi].ptl_x 	; Compute (x - Ax)
        sub     eax,ecx

        mov     ecx,edx                 ; ECX:EBX = (Bx - Ax) * (y - Ay)

        imul    yByA                    ; EDX:EAX = (By - Ay) * (x - Ax)

        sub     ebx,eax
        sbb     ecx,edx                 ; ECX:EBX = (Bx - Ax) * (y - Ay) -
        jns     @F                      ;           (By - Ay) * (x - Ax)

        mov     eax,POINT_ON_RIGHT_SIDE ; on the right if negative
        cRet    ulPtOnWhichSide

@@:
        jnz     @F                      ; on the line if zero
        or      ebx,ebx
        jnz     @F
        mov     eax,POINT_ON_LINE
        cRet    ulPtOnWhichSide

@@:
        mov     eax,POINT_ON_LEFT_SIDE  ; on the left if positive
        cRet    ulPtOnWhichSide

endProc ulPtOnWhichSide

;------------------------------Public-Routine------------------------------;
; ULONG  yGetLtoR/yGetRtoL
;
; Compute the ceiling of the y coordinate in integer of a line given the
; x coordinate in FIX.  yB must be bigger than yA.
; plnfx points to a line which must satisfy ptfxLo.y < ptfxHi.y.
; Lines that start from left and end at right, i.e. ptfxLo.x <= ptfxHi.x,
; should use yGetLtoR.
; Lines that start from right and end at left, i.e. ptfxLo.x > ptfxHi.x,
; should use yGetRtoL.
;
; History:
;  02-Dec-1992 -by- Wendy Wu [wendywu]
; Wrote it.
;--------------------------------------------------------------------------;

cProc   yGetLtoR,8,<        \
        uses    ebx,        \
        plnfx:  ptr SEGAB,  \
        x:      dword       >

; Calculate DN = yB - yA

        mov     ebx,plnfx
        mov     eax,[ebx].AB_yB
        sub     eax,[ebx].AB_yA         ; EAX = yB - yA

; Calculate x - xA

        mov     edx,x
        mov     ecx,[ebx].AB_xA
        sub     edx,ecx                 ; EDX = x - xA

        mul     edx                     ; EDX:EAX = (yB - yA) * (x - xA)

; Calculate DM = xB - xA

        sub     ecx,[ebx].AB_xB
        neg     ecx                     ; ECX = xB - xA

; FXTOLONGCEILING(DN * (x - xA) / DM + yA)

        div     ecx

        xor     ecx,ecx                 ; increment by 1 if remainder not 0
        cmp     ecx,edx
        adc     eax,[ebx].AB_yA
        add     eax,15
        sar     eax,4
        cRet    yGetLtoR

endProc yGetLtoR



cProc   yGetRtoL,8,<        \
        uses    ebx,        \
        plnfx:  ptr SEGAB,  \
        x:      dword       >

; Calculate DN = yB - yA

        mov     ebx,plnfx
        mov     eax,[ebx].AB_yB
        sub     eax,[ebx].AB_yA         ; EAX = yB - yA

; Calculate xA - x

        mov     ecx,[ebx].AB_xA
        mov     edx,ecx
        sub     edx,x                   ; EDX = xA - x

        mul     edx                     ; EDX:EAX = (yB - yA) * (xA - x)

; Calculate DM = xA - xB

        sub     ecx,[ebx].AB_xB         ; ECX = xA - xB

; FXTOLONGCEILING(DN * (xA - x) / DM + yA)

        div     ecx

        xor     ecx,ecx                 ; increment by 1 if remainder not 0
        cmp     ecx,edx
        adc     eax,[ebx].AB_yA
        add     eax,15
        sar     eax,4
        cRet    yGetRtoL

endProc yGetRtoL

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\wow6432\makefile.inc ===
!if "$(TARGET_DIRECTORY)" == "i386"
PRIVATEINCS= $(PROJECT_ROOT)\$(SRCBASE)\ntgdi\math\wow6432\$(TARGET_H_DIRECTORY)\efloat.hxx
!else
PRIVATEINCS= $(PROJECT_ROOT)\$(SRCBASE)\ntgdi\math\daytona\$(TARGET_H_DIRECTORY)\efloat.hxx
!endif

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\ia64\tiler.cxx ===
/*******************************Module*Header*****************************\
* 
*  Copyright (c) 1992-1999  Microsoft Corporation
*  Copyright (c) 1992  Digital Equipment Corporation
* 
*  Module Name:
* 
*     tiler.cxx
* 
*  Abstract:
* 
*     This module implements code to copy a pattern to a target surface.
* 
*  Author:
* 
*    David N. Cutler (davec) 4-May-1992
* 
*  Rewritten in C by:
* 
*    Eric Rehm (rehm@zso.dec.com) 15-July-1992
* 
*  Environment:
* 
*     User mode only.
* 
*  Revision History:
* 
\*************************************************************************/

#include "precomp.hxx"

VOID CopyPattern( PULONG pulTrg, LONG culFill, LONG hiPat, LONG loPat);
VOID MergePattern( PULONG pulTrg, LONG culFill, LONG hiPat, LONG loPat);



/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchAndCopy (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an aligned pattern.
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchAndCopy
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    PULONG  pulPat;                 // base pattern address
    PULONG  pulPatCur;              // current pattern address
    PULONG  pulPatEnd;              // ending pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (PULONG) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;           // get low part of 8-byte pattern

      if (xPat == 0)
      {
        hiPat = *(pulPatCur + 1);   // get hi part of 8-byte pattern
      }
      else
      {
        hiPat = *pulPat;            // get hi part of 8-byte pattern
      }

      CopyPattern( pulTrg, culFill, hiPat, loPat); // do a 4 or 8-byte copy
    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      pulPatEnd = (PULONG) ((PUCHAR) pulPat + cxPat);
                                    // ending pattern address

      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = *pulPatCur;       // set target to 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        pulPatCur += 1;             // advance the pattern pixel offset

        if (pulPatCur == pulPatEnd) // Check if at end of pattern
        {
          pulPatCur = pulPat;       // get starting pattern address
        }
      }
    }
} // end vFetchAndCopy



/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchShiftAndCopy (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an unaligned pattern
*     using rop (P).
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchShiftAndCopy
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    ULONG   UNALIGNED *pulPat;                      // base pattern address
    ULONG   UNALIGNED *pulPatCur;           // current pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;           // get low part of 8-byte pattern

      xPat +=4;                     // get hi part of 8-byte pattern
      if (xPat >= cxPat)
      {
          xPat -= cxPat;
      }
      hiPat = *((ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat));

      CopyPattern( pulTrg, culFill, hiPat, loPat); // do a 4 or 8-byte copy
    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = *pulPatCur;
                                    // set target to 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        xPat += 4;
        if (xPat >= cxPat)
        {
          xPat -= cxPat;
        }
        pulPatCur = (ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat);

      }
    }
} // end vFetchShiftAndCopy



/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchNotAndCopy (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an aligned pattern
*     using rop (Pn).
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchNotAndCopy
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    PULONG  pulPat;                 // base pattern address
    PULONG  pulPatCur;              // current pattern address
    PULONG  pulPatEnd;              // ending pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (PULONG) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;           // get low part of 8-byte pattern
      if (xPat == 0)
      {
        hiPat = *(pulPatCur + 1);   // get hi part of 8-byte pattern
      }
      else
      {
        hiPat = *pulPat;            // get hi part of 8-byte pattern
      }
      loPat = ~loPat;               // complement pattern
      hiPat = ~hiPat;
      CopyPattern( pulTrg, culFill, hiPat, loPat); // do a 4 or 8-byte copy
    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      pulPatEnd = (PULONG) ((PUCHAR) pulPat + cxPat);
                                    // ending pattern address

      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = ~(*pulPatCur);
                      // set target to complement of 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        pulPatCur += 1;             // advance the pattern pixel offset

        if (pulPatCur == pulPatEnd) // Check if at end of pattern
        {
          pulPatCur = pulPat;       // get starting pattern address
        }
      }
    }
} // end vFetchNotAndCopy



/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchShiftNotAndCopy (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an unaligned pattern
*     using rop (Pn).
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchShiftNotAndCopy
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    ULONG   UNALIGNED *pulPat;      // base pattern address
    ULONG   UNALIGNED *pulPatCur;   // current pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;
                                    // get low part of 8-byte pattern
      xPat +=4;                     // get hi part of 8-byte pattern
      if (xPat >= cxPat)
      {
          xPat -= cxPat;
      }
      hiPat = *((ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat));

      loPat = ~loPat;               // complement pattern
      hiPat = ~hiPat;
      CopyPattern( pulTrg, culFill, hiPat, loPat); // do a 4 or 8-byte copy
    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = ~(*pulPatCur);
                        // set target to complemented 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        xPat += 4;
        if (xPat >= cxPat)
        {
          xPat -= cxPat;
        }
        pulPatCur = (ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat);

      }
    }
} // end vFetchShiftNotAndCopy


/****************************Private*Routine******************************\
*
*  VOID CopyPattern( PULONG pulTrg, LONG culFill, LONG hiPat, LONG loPat)
*
*  Routine Description:
*
*     This routine contains common code for copying an 8-byte pattern to
*     a target surface.
*
*  Arguments:
*
*     culFill - Supplies the size of the fill in bytes.
*     loPat, hiPat - Supplies the 8-byte pattern to copy.
*     pulTrg - Supplies the starting target surface address.
*
*  Return Value:
*
*     None.
*
*
\*************************************************************************/

VOID CopyPattern
(
        PULONG pulTrg,                  // Starting target surface address (t0)
        LONG   culFill,                 // size of fill in longwords (a1)
        LONG   hiPat,                   // hi part of pattern  (v1)
        LONG   loPat                    // lo part of pattern  (v0)
)
{
    PULONG pulTrgEnd;               // ending target surface address
    ULONG temp;                     // temp for swap

    pulTrgEnd = pulTrg + culFill;
                                    // ending target surface address(t4)

//
// If the fill size is not an even multiple of 8 bytes, then move one
// longword and swap the pattern value.
//

    if ((culFill & 0x01) != 0)
    {
      *pulTrg = loPat;              // store low 4 bytes of pattern
      pulTrg += 1;                  // advance target ptr one longword
      culFill -= 1;
      if (culFill == 0)             // if no more to move then we're done
      {
        return;
      }
      else                          // otherwise, swap 8-byte pattern value
      {
        temp = loPat;
        loPat = hiPat;
        hiPat = temp;
      }
    }

//
// Move 8-byte pattern value to target 8 bytes at a time.
//

    pulTrgEnd -= 2;                 // ending segement address
    if ((culFill & 0x02) != 0)      // check if even multiple of 8 bytes
    {
      while (pulTrg <= pulTrgEnd)   // if not, move 8 bytes at a time
      {
        *pulTrg = loPat;            // store 8-byte pattern value
        *(pulTrg + 1) = hiPat;
        pulTrg += 2;                // advance target address
      }
      return;
    }
    else                            //  move 16 bytes at a time
    {
      pulTrgEnd -= 2;               // ending segement address
      while (pulTrg <= pulTrgEnd)
      {
        *pulTrg = loPat;            // store 8-byte pattern value
        *(pulTrg + 1) = hiPat;
        *(pulTrg + 2) = loPat;      // store 8-byte pattern value
        *(pulTrg + 3) = hiPat;
        pulTrg += 4;                // advance target address
      }
    }
}



/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchAndMerge (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an aligned pattern
*     using ropt (DPx).
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchAndMerge
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    PULONG  pulPat;                 // base pattern address
    PULONG  pulPatCur;              // current pattern address
    PULONG  pulPatEnd;              // ending pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (PULONG) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;           // get low part of 8-byte pattern

      if (xPat == 0)
      {
        hiPat = *(pulPatCur + 1);   // get hi part of 8-byte pattern
      }
      else
      {
        hiPat = *pulPat;            // get hi part of 8-byte pattern
      }

      MergePattern( pulTrg, culFill, hiPat, loPat); //do a 4 or 8-byte copy

    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      pulPatEnd = (PULONG) ((PUCHAR) pulPat + cxPat);
                                    // ending pattern address

      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = (*pulPatCur) ^ (*pulTrg);
                            // XOR 4-byte target with 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        pulPatCur += 1;             // advance the pattern pixel offset

        if (pulPatCur == pulPatEnd) // Check if at end of pattern
        {
          pulPatCur = pulPat;       // get starting pattern address
        }
      }
    }
} // end vFetchAndMerge



/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchShiftAndMerge (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an unaligned pattern
*     using rop (P).
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchShiftAndMerge
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    ULONG   UNALIGNED *pulPat;                      // base pattern address
    ULONG   UNALIGNED *pulPatCur;           // current pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;
                                    // get low part of 8-byte pattern
      xPat +=4;                     // get hi part of 8-byte pattern
      if (xPat >= cxPat)
      {
          xPat -= cxPat;
      }
      hiPat = *((ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat));

      MergePattern( pulTrg, culFill, hiPat, loPat); //do a 4 or 8-byte copy
    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = (*pulPatCur) ^ (*pulTrg);
                            // XOR 4-byte target with 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        xPat += 4;
        if (xPat >= cxPat)
        {
          xPat -= cxPat;
        }
        pulPatCur = (ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat);
      }
    }
} // end vFetchShiftAndMerge


/****************************Private*Routine******************************\
*
*  VOID MergePattern( PULONG pulTrg, LONG culFill, LONG hiPat, LONG loPat)
*
*  Routine Description:
*
*     This routine contains common code for merging an 8-byte pattern with
*     a target surface.
*
*  Arguments:
*
*     culFill - Supplies the size of the fill in bytes.
*     loPat, hiPat - Supplies the 8-byte pattern to merge.
*     pulTrg - Supplies the starting target surface address.
*
*  Return Value:
*
*     None.
*
*
\*************************************************************************/

VOID MergePattern
(
        PULONG pulTrg,                  // Starting target surface address (t0)
        LONG   culFill,                 // size of fill in longwords (a1)
        LONG   hiPat,                   // hi part of pattern  (v1)
        LONG   loPat                    // lo part of pattern  (v0)
)
{
    PULONG pulTrgEnd;               // ending target surface address
    ULONG temp;                     // temp for swap

    pulTrgEnd = pulTrg + culFill;
                                    // ending target surface address(t4)

//
// If the fill size is not an even multiple of 8 bytes, then move one
// longword and swap the pattern value.
//

    if ((culFill & 0x01) != 0)
    {
      *pulTrg = loPat ^ (*pulTrg);  // XOR low 4 bytes of pattern w/ target
      pulTrg += 1;                  // advance target ptr one longword
      culFill -= 1;
      if (culFill == 0)             // if no more to move then we're done
      {
        return;
      }
      else                          // otherwise, swap 8-byte pattern value
      {
        temp = loPat;
        loPat = hiPat;
        hiPat = temp;
      }
    }

//
// Move 8-byte pattern value to target 8 bytes at a time.
//

    pulTrgEnd -= 2;                 // ending segement address
    while (pulTrg <= pulTrgEnd)     // if not, move 8 bytes at a time
    {
      *pulTrg = loPat ^ (*pulTrg);  // XOR 4-byte pattern value
      pulTrg++;                     // advance target address
      *pulTrg = hiPat ^ (*pulTrg);  // XOR 4-byte pattern value
      pulTrg++;                     // advance target address
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htalias.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htalias.c


Abstract:

    This module contains all low levels halftone rendering functions.


Author:

    22-Jan-1991 Tue 12:49:03 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:


--*/

#define DBGP_VARNAME        dbgpHTAlias



#include "htp.h"
#include "htmapclr.h"
#include "limits.h"
#include "htpat.h"
#include "htalias.h"
#include "htstret.h"
#include "htrender.h"
#include "htgetbmp.h"
#include "htsetbmp.h"


#define DBGP_BUILD              0x00000001
#define DBGP_BUILD2             0x00000002
#define DBGP_BUILD3             0x00000004
#define DBGP_EXPMATRIX          0x00000008
#define DBGP_EXP                0x00000010
#define DBGP_AAHEADER           0x00000020
#define DBGP_OUTAA              0x00000040
#define DBGP_FUNC               0x00000080
#define DBGP_AAHT               0x00000100
#define DBGP_AAHT_MEM           0x00000200
#define DBGP_AAHT_TIME          0x00000400
#define DBGP_AAHTPAT            0x00000800
#define DBGP_FIXUPDIB           0x00001000
#define DBGP_INPUT              0x00002000
#define DBGP_VGA256XLATE        0x00004000
#define DBGP_EXPAND             0x00008000
#define DBGP_GETFIXUP           0x00010000
#define DBGP_PSD                0x00020000
#define DBGP_MASK               0x00040000
#define DBGP_PALETTE            0x00080000
#define DBGP_PAL_CHKSUM         0x00100000
#define DBGP_LUT_MAP            0x00200000


DEF_DBGPVAR(BIT_IF(DBGP_BUILD,          0)  |
            BIT_IF(DBGP_BUILD2,         0)  |
            BIT_IF(DBGP_BUILD3,         0)  |
            BIT_IF(DBGP_EXPMATRIX,      0)  |
            BIT_IF(DBGP_EXP,            0)  |
            BIT_IF(DBGP_AAHEADER,       0)  |
            BIT_IF(DBGP_OUTAA,          0)  |
            BIT_IF(DBGP_FUNC,           0)  |
            BIT_IF(DBGP_AAHT,           0)  |
            BIT_IF(DBGP_AAHT_MEM,       0)  |
            BIT_IF(DBGP_AAHT_TIME,      0)  |
            BIT_IF(DBGP_AAHTPAT,        0)  |
            BIT_IF(DBGP_FIXUPDIB,       0)  |
            BIT_IF(DBGP_INPUT,          0)  |
            BIT_IF(DBGP_VGA256XLATE,    0)  |
            BIT_IF(DBGP_EXPAND,         0)  |
            BIT_IF(DBGP_GETFIXUP,       0)  |
            BIT_IF(DBGP_PSD,            0)  |
            BIT_IF(DBGP_MASK,           0)  |
            BIT_IF(DBGP_PALETTE,        0)  |
            BIT_IF(DBGP_PAL_CHKSUM,     0)  |
            BIT_IF(DBGP_LUT_MAP,        0))


extern CONST RGBORDER   SrcOrderTable[];
extern DWORD            dwABPreMul[256];

#define SIZE_AAINFO     _ALIGN_MEM(sizeof(AAINFO))


//
// Following computation is based on
//
// NTSC_R_INT      = 299000
// NTSC_G_INT      = 587000
// NTSC_B_INT      = 114000
// GRAY_MAX_IDX    = 0xFFFF
//
// NTSC_R_GRAY_MAX = (((NTSC_R_INT * GRAY_MAX_IDX) + 500000) / 1000000)
// NTSC_B_GRAY_MAX = (((NTSC_B_INT * GRAY_MAX_IDX) + 500000) / 1000000)
// NTSC_G_GRAY_MAX = (GRAY_MAX_IDX - NTSC_R_GRAY_MAX - NTSC_B_GRAY_MAX)
//

#define NTSC_R_GRAY_MAX     (DWORD)0x4c8b
#define NTSC_B_GRAY_MAX     (DWORD)0x1d2f
#define NTSC_G_GRAY_MAX     (DWORD)(0xFFFF - NTSC_R_GRAY_MAX - NTSC_B_GRAY_MAX)



VOID
HTENTRY
SetGrayColorTable(
    PLONG       pIdxBGR,
    PAASURFINFO pAASI
    )

/*++

Routine Description:




Arguments:

    pIdxBGR - Pointer to how to translate from RGB to gray scale, typically
              this pointer is computed with NTSC gray standard plus any
              device transform or color adjustment, but if this pointer is
              NULL then we are reading from the device (1bpp, 8bpp) so we
              will only do NTSC standard mapping.


Return Value:




Author:

    19-Feb-1999 Fri 13:14:01 created  -by-  Daniel Chou (danielc)


Revision History:

    08-Aug-2000 Tue 18:34:22 updated  -by-  Daniel Chou (danielc)
        Fixing bug for alpha blending, in gray scale mode, the destination
        can only be 1bpp or 8bpp mask mono, so when we read back from the
        destination to do alpha blending, it will double color mapping pixels.
        In gray scale mode, the input function will map the source RGB value
        to gray value with the current device transform, color adjustment and
        so on, so if we read back from destination then this transform is not
        desired.


--*/

{
    PRGB4B      prgb4b;
    LONG        cSrcTable;


    ASSERT(NTSC_R_INT == 299000);
    ASSERT(NTSC_G_INT == 587000);
    ASSERT(NTSC_B_INT == 114000);
    ASSERT(GRAY_MAX_IDX == 0xFFFF);


    if (cSrcTable = (LONG)pAASI->cClrTable) {

        prgb4b = pAASI->pClrTable;

        if (pIdxBGR) {

            //
            // This is a reading from the source
            //

            ASSERT(pAASI->Flags & AASIF_GRAY);
            ASSERT(pAASI->pIdxBGR == pIdxBGR);

            while (cSrcTable--) {

                prgb4b++->a = IDXBGR_2_GRAY_BYTE(pIdxBGR,
                                                 prgb4b->b,
                                                 prgb4b->g,
                                                 prgb4b->r);
            }

        } else {

            //
            // We are reading from the destination so only do NTSC standard,
            // since the destination surface alreay halftoned.
            //

            while (cSrcTable--) {

                prgb4b++->a = (BYTE)((((DWORD)prgb4b->r * NTSC_R_GRAY_MAX) +
                                      ((DWORD)prgb4b->g * NTSC_G_GRAY_MAX) +
                                      ((DWORD)prgb4b->b * NTSC_B_GRAY_MAX) +
                                      (0x7FFF)) / 0xFFFF);
            }
        }

    } else if (pIdxBGR != pAASI->pIdxBGR) {

        //
        // This is the source surface info, we will see if this is the
        // gray color table
        //

        ASSERT(pAASI->Flags & AASIF_GRAY);
        ASSERT(pIdxBGR);
        ASSERT(pAASI->pIdxBGR);

        DBGP_IF(DBGP_INPUT,
                DBGP("Copy pIdxBGR [BGR] order from 012 to %ld%ld%ld"
                        ARGDW(pAASI->AABFData.MaskRGB[2])
                        ARGDW(pAASI->AABFData.MaskRGB[1])
                        ARGDW(pAASI->AABFData.MaskRGB[0])));

        CopyMemory(&pAASI->pIdxBGR[pAASI->AABFData.MaskRGB[2] * 256],
                   &pIdxBGR[0 * 256], sizeof(LONG) * 256);
        CopyMemory(&pAASI->pIdxBGR[pAASI->AABFData.MaskRGB[1] * 256],
                   &pIdxBGR[1 * 256], sizeof(LONG) * 256);
        CopyMemory(&pAASI->pIdxBGR[pAASI->AABFData.MaskRGB[0] * 256],
                   &pIdxBGR[2 * 256], sizeof(LONG) * 256);
    }
}



VOID
HTENTRY
ComputeInputColorInfo(
    LPBYTE      pSrcTable,
    UINT        cPerTable,
    UINT        PrimaryOrder,
    PBFINFO     pBFInfo,
    PAASURFINFO pAASI
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    19-Feb-1999 Fri 13:14:01 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PRGB4B      prgb4b;
    PAABFDATA   pAABFData;
    LONG        cSrcTable;
    LONG        Count;
    LONG        LS;
    LONG        RS;
    BYTE        Mask;


    pAABFData = &pAASI->AABFData;

    if ((pSrcTable) &&
        (Count = cSrcTable = (LONG)pAASI->cClrTable)) {

        UINT    iR;
        UINT    iG;
        UINT    iB;

        prgb4b = pAASI->pClrTable;
        iR     = SrcOrderTable[PrimaryOrder].Order[0];
        iG     = SrcOrderTable[PrimaryOrder].Order[1];
        iB     = SrcOrderTable[PrimaryOrder].Order[2];

        switch (pAABFData->Format) {

        case BMF_1BPP:

            pAASI->InputFunc = (AAINPUTFUNC)Input1BPPToAA24;
            break;

        case BMF_4BPP_VGA16:
        case BMF_4BPP:

            pAASI->InputFunc = (AAINPUTFUNC)Input4BPPToAA24;
            break;

        case BMF_8BPP_VGA256:
        case BMF_8BPP:

            pAASI->InputFunc = (AAINPUTFUNC)Input8BPPToAA24;
            break;

        default:

            DBGP("ComputeInputColorInfo() Invalid Bitmap Format=%ld"
                        ARGDW(pAABFData->Format));

            break;
        }

        while (Count--) {

            prgb4b->r = *(pSrcTable + iR);
            prgb4b->g = *(pSrcTable + iG);
            prgb4b->b = *(pSrcTable + iB);

            DBGP_IF(DBGP_PALETTE,
                    DBGP("Source Pal [%3ld] = %3ld:%3ld:%3ld"
                        ARGDW((LONG)cSrcTable - Count - 1) ARGDW(prgb4b->r)
                        ARGDW(prgb4b->g) ARGDW(prgb4b->b)));

            ++prgb4b;
            pSrcTable += cPerTable;
        }

    } else {

        pAASI->InputFunc = InputAABFDATAToAA24;

        if (pBFInfo->Flags & BFIF_RGB_888) {

            pAABFData->Flags      |= AABF_MASK_IS_ORDER;
            pAABFData->MaskRGB[0]  = (BYTE)pBFInfo->RGBOrder.Order[0];
            pAABFData->MaskRGB[1]  = (BYTE)pBFInfo->RGBOrder.Order[1];
            pAABFData->MaskRGB[2]  = (BYTE)pBFInfo->RGBOrder.Order[2];

        } else {

            //
            // This is bitfield, figure out how to do it, we want to lshift to
            // to edge then right shift to 8bpp then mask off the unwanted bit
            //
            //

            cSrcTable = 3;

            while (cSrcTable--) {

                LS    = 0;
                RS    = (LONG)pBFInfo->BitStart[cSrcTable];
                Count = (LONG)pBFInfo->BitCount[cSrcTable];

                if (Count >= 8) {

                    RS   += (Count - 8);
                    Mask  = 0xFF;

                } else {

                    LS    = 8 - Count;
                    Mask  = (0xFF << LS);

                    if ((RS -= LS) < 0) {

                        LS = -RS;
                        RS = 0;

                    } else {

                        LS = 0;
                    }
                }

                pAABFData->MaskRGB[cSrcTable]   = (BYTE)Mask;
                pAABFData->LShiftRGB[cSrcTable] = (BYTE)LS;
                pAABFData->RShiftRGB[cSrcTable] = (BYTE)RS;

                DBGP_IF(DBGP_FUNC | DBGP_PALETTE,
                        DBGP("BFData[%ld]: Bits=%08lx, LS=%2ld, RS=%2ld, Mask=%02lx -->%02lx"
                            ARGDW(cSrcTable)
                            ARGDW(pBFInfo->BitsRGB[cSrcTable])
                            ARGDW(LS) ARGDW(RS) ARGDW(Mask)
                            ARGDW(((pBFInfo->BitsRGB[cSrcTable] >> RS) << LS) & Mask)));
            }
        }

        switch (pBFInfo->BitmapFormat) {

        case BMF_16BPP:
        case BMF_16BPP_555:
        case BMF_16BPP_565:

            pAABFData->cbSrcInc = 2;
            break;

        case BMF_24BPP:

            ASSERT(pAABFData->Flags & AABF_MASK_IS_ORDER);

            if (pBFInfo->RGBOrder.Index == PRIMARY_ORDER_BGR) {

                ASSERT((pAABFData->MaskRGB[0] == 2) &&
                       (pAABFData->MaskRGB[1] == 1) &&
                       (pAABFData->MaskRGB[2] == 0));

                pAABFData->Flags |= AABF_SRC_IS_BGR8;
            }

            pAABFData->cbSrcInc = 3;

            break;

        case BMF_32BPP:

            if (pAASI->Flags & AASIF_AB_PREMUL_SRC) {

                ASSERT(pAABFData->Flags & AABF_MASK_IS_ORDER);
                ASSERT(dwABPreMul[0] == 0);

                switch (pBFInfo->RGBOrder.Index) {

                case PRIMARY_ORDER_BGR:

                    ASSERT((pAABFData->MaskRGB[0] == 2) &&
                           (pAABFData->MaskRGB[1] == 1) &&
                           (pAABFData->MaskRGB[2] == 0));

                    pAABFData->Flags |= AABF_SRC_IS_BGR_ALPHA;
                    break;

                case PRIMARY_ORDER_RGB:

                    ASSERT((pAABFData->MaskRGB[0] == 0) &&
                           (pAABFData->MaskRGB[1] == 1) &&
                           (pAABFData->MaskRGB[2] == 2));

                    pAABFData->Flags |= AABF_SRC_IS_RGB_ALPHA;
                    break;

                default:

                    break;
                }

                if (dwABPreMul[0] == 0) {

                    pAASI->InputFunc = InputPreMul32BPPToAA24;
                }
            }

            pAABFData->cbSrcInc = 4;
            break;

        default:

            DBGP("ERROR: Invalid BFInfo Format=%ld" ARGDW(pBFInfo->BitmapFormat));
            break;
        }

        DBGP_IF(DBGP_FUNC,
                DBGP("Flags=%02lx. cbSrcInc=%ld, Mask=%02lx:%02lx:%02lx, LS=%2ld:%2ld:%2ld, RS=%2ld:%2ld:%2ld"
                        ARGDW(pAABFData->Flags)
                        ARGDW(pAABFData->cbSrcInc)
                        ARGDW(pAABFData->MaskRGB[0])
                        ARGDW(pAABFData->MaskRGB[1])
                        ARGDW(pAABFData->MaskRGB[2])
                        ARGDW(pAABFData->LShiftRGB[0])
                        ARGDW(pAABFData->LShiftRGB[1])
                        ARGDW(pAABFData->LShiftRGB[2])
                        ARGDW(pAABFData->RShiftRGB[0])
                        ARGDW(pAABFData->RShiftRGB[1])
                        ARGDW(pAABFData->RShiftRGB[2])));
    }

    DBGP_IF(DBGP_FUNC,
            DBGP("+++++ InputFunc = %hs(SrcFmt=%ld), cClrTable=%ld\n"
                ARGPTR(GetAAInputFuncName(pAASI->InputFunc))
                ARGDW(pBFInfo->BitmapFormat) ARGDW(pAASI->cClrTable)));
}



PAAINFO
HTENTRY
BuildTileAAInfo(
    PDEVICECOLORINFO    pDCI,
    DWORD               AAHFlags,
    PLONG               piSrcBeg,
    PLONG               piSrcEnd,
    LONG                SrcSize,
    LONG                IdxDst,
    LONG                IdxDstEnd,
    PLONG               piDstBeg,
    PLONG               piDstEnd,
    LONG                cbExtra
    )

/*++

Routine Description:




Arguments:

    piSrcBeg    - Passed in as begining source index, When return this is the
                  real source begining index.  This always well ordered

    piSrcEnd    - Passed in as ending source index, When return this is the
                  real source ending index.  This always well ordered

    SrcSize     - The real size of source in pixel

    IdxDst      - Starting index of destination pixel

    IdxDstEnd   - Ending index of destination pixel, the iDxdst and IdxDstEnd
                  must be well ordered.

    piDstBeg    - Clipped destination start index when passed in, at return
                  it adjusted to the real destination starting index.

    piDstEnd    - Clipped destination end index when passed in, at return
                  it adjusted to the real destination ending index.

    cbExtra     - Extra byte count to be allocated

    NOTE: 1) piDstBeg/piDstEnd When passed in this must be well ordered, and
             when it returned this is well ordered.


Return Value:

    At enter of this function, the *piSrcEnd, *piDstEnd is exclusive but when
    return from this function the *piSrcEnd and *piDstEnd is inclusive

    *piSrcBeg, *piSrcEnd, *piDstBeg, *piDstEnd are updated if return value
    is not NULL

Author:

    22-Mar-1998 Sun 18:36:28 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    PEXPDATA    pED;
    LONG        cMatrix;
    LONG        cM;
    LONG        cIn;
    LONG        cOut;
    LONG        IdxSrc;
    LONG        iSrcBeg;
    LONG        iSrcEnd;
    LONG        iDstBeg;
    LONG        iDstEnd;
    LONG        jSrcBeg;
    LONG        jSrcEnd;
    LONG        jDstBeg;
    LONG        jDstEnd;
    LONG        cLoop;
    LONG        cAAData;



    iSrcBeg = *piSrcBeg;
    iSrcEnd = *piSrcEnd;

    //
    // The source always clipped to the visiable surface area
    //

    if (iSrcBeg < 0) {

        iSrcBeg = 0;
    }

    if (iSrcEnd > SrcSize) {

        iSrcEnd = SrcSize;
    }

    cIn  = iSrcEnd - (IdxSrc = iSrcBeg);
    cOut = IdxDstEnd - IdxDst;

    if (cIn <= 0) {

        return(NULL);
    }

    ASSERT(cOut > 0);

    iDstBeg = *piDstBeg;
    iDstEnd = *piDstEnd;
    jSrcBeg = -1;

    ASSERT(iDstBeg < iDstEnd);

    DBGP_IF(DBGP_BUILD,
            DBGP("\nTile(%ld-%ld): iSrc=%ld-%ld, cSrc=%ld, iDst=%ld-%ld, Idx=%ld:%ld"
                ARGDW(cIn) ARGDW(cOut) ARGDW(iSrcBeg) ARGDW(iSrcEnd)
                ARGDW(SrcSize) ARGDW(iDstBeg)
                ARGDW(iDstEnd) ARGDW(IdxSrc) ARGDW(IdxDst)));

    ALIGN_MEM(cbExtra, cbExtra);

    if (pAAInfo = (PAAINFO)HTAllocMem((LPVOID)pDCI,
                                      HTMEM_BLTAA,
                                      LPTR,
                                      SIZE_AAINFO + cbExtra)) {

        SETDBGVAR(pAAInfo->cbAlloc, SIZE_AAINFO + cbExtra);

        pAAInfo->pbExtra = (LPBYTE)pAAInfo + SIZE_AAINFO;
        cLoop            = cOut;

        while (cLoop--) {

            if ((IdxSrc >= iSrcBeg) && (IdxSrc < iSrcEnd)  &&
                (IdxDst >= iDstBeg) && (IdxDst < iDstEnd)) {

                if (jSrcBeg == -1) {

                    jSrcBeg = IdxSrc;
                    jDstBeg = IdxDst;
                }

                jSrcEnd = IdxSrc;
                jDstEnd = IdxDst;

            } else if (jSrcBeg != -1) {

                break;
            }

            if (++IdxSrc >= iSrcEnd) {

                IdxSrc = iSrcBeg;
            }

            ++IdxDst;
        }

        if (jSrcBeg == -1) {

            HTFreeMem(pAAInfo);
            return(NULL);
        }

        pAAInfo->iSrcBeg    = jSrcBeg - iSrcBeg;
        jSrcBeg             = iSrcBeg;
        jSrcEnd             = iSrcEnd - 1;
        pAAInfo->Mask.iBeg  =
        *piSrcBeg           = jSrcBeg;
        *piSrcEnd           = jSrcEnd;
        *piDstBeg           = jDstBeg;
        *piDstEnd           = jDstEnd;
        pAAInfo->Mask.iSize =
        pAAInfo->cIn        = jSrcEnd - jSrcBeg + 1;
        pAAInfo->cOut       = jDstEnd - jDstBeg + 1;
        pAAInfo->cAAData    =
        pAAInfo->cAALoad    = (DWORD)pAAInfo->cOut;
        pAAInfo->Mask.cIn   = cIn;
        pAAInfo->Mask.cOut  = cOut;

        DBGP_IF(DBGP_BUILD,
                DBGP("TILE(%ld->%ld): iSrc=%ld:%ld (%ld), iDst=%ld:%ld, cAAData=%ld, cbExtra=%ld, Flags=%04lx"
                    ARGDW(pAAInfo->cIn) ARGDW(pAAInfo->cOut)
                    ARGDW(*piSrcBeg) ARGDW(*piSrcEnd)
                    ARGDW(pAAInfo->iSrcBeg) ARGDW(*piDstBeg)
                    ARGDW(*piDstEnd) ARGDW(pAAInfo->cAAData)
                    ARGDW(cbExtra) ARGDW(pAAInfo->Flags)));
    }

    return(pAAInfo);
}




PAAINFO
HTENTRY
BuildBltAAInfo(
    PDEVICECOLORINFO    pDCI,
    DWORD               AAHFlags,
    PLONG               piSrcBeg,
    PLONG               piSrcEnd,
    LONG                SrcSize,
    LONG                IdxDst,
    LONG                IdxDstEnd,
    PLONG               piDstBeg,
    PLONG               piDstEnd,
    LONG                cbExtra
    )

/*++

Routine Description:




Arguments:

    piSrcBeg    - Passed in as begining source index, When return this is the
                  real source begining index.  This always well ordered

    piSrcEnd    - Passed in as ending source index, When return this is the
                  real source ending index.  This always well ordered

    SrcSize     - The real size of source in pixel

    IdxDst      - Starting index of destination pixel

    IdxDstEnd   - Ending index of destination pixel, the iDxdst and IdxDstEnd
                  must be well ordered.

    piDstBeg    - Clipped destination start index when passed in, at return
                  it adjusted to the real destination starting index.

    piDstEnd    - Clipped destination end index when passed in, at return
                  it adjusted to the real destination ending index.

    cbExtra     - Extra byte count to be allocated

    NOTE: 1) piDstBeg/piDstEnd When passed in this must be well ordered, and
             when it returned this is well ordered.


Return Value:

    At enter of this function, the *piSrcEnd, *piDstEnd is exclusive but when
    return from this function the *piSrcEnd and *piDstEnd is inclusive

    *piSrcBeg, *piSrcEnd, *piDstBeg, *piDstEnd are updated if return value
    is not NULL

Author:

    22-Mar-1998 Sun 18:36:28 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    PEXPDATA    pED;
    LONG        cMatrix;
    LONG        cM;
    LONG        cIn;
    LONG        cOut;
    LONG        IdxSrc;
    LONG        iSrcBeg;
    LONG        iSrcEnd;
    LONG        iDstBeg;
    LONG        iDstEnd;
    LONG        jSrcBeg;
    LONG        jSrcEnd;
    LONG        jDstBeg;
    LONG        jDstEnd;
    LONG        cLoop;
    LONG        cAAData;



    cIn  = (LONG)((iSrcEnd = *piSrcEnd) - (iSrcBeg = IdxSrc = *piSrcBeg));
    cOut = IdxDstEnd - IdxDst;

    ASSERT(cOut > 0);

    if (iSrcBeg < 0) {

        iSrcBeg = 0;
    }

    if (iSrcEnd > SrcSize) {

        iSrcEnd = SrcSize;
    }

    iDstBeg = *piDstBeg;
    iDstEnd = *piDstEnd;
    jSrcBeg = -1;

    ASSERT(iDstBeg < iDstEnd);
    ASSERT(cIn == cOut);

    DBGP_IF(DBGP_BUILD,
            DBGP("\nBlt(%ld-%ld): iSrc=%ld-%ld, cSrc=%ld, iDst=%ld-%ld, Idx=%ld:%ld"
                ARGDW(cIn) ARGDW(cOut) ARGDW(iSrcBeg) ARGDW(iSrcEnd)
                ARGDW(SrcSize) ARGDW(iDstBeg)
                ARGDW(iDstEnd) ARGDW(IdxSrc) ARGDW(IdxDst)));

    ALIGN_MEM(cbExtra, cbExtra);

    if (pAAInfo = (PAAINFO)HTAllocMem((LPVOID)pDCI,
                                      HTMEM_BLTAA,
                                      LPTR,
                                      SIZE_AAINFO + cbExtra)) {

        SETDBGVAR(pAAInfo->cbAlloc, SIZE_AAINFO + cbExtra);

        pAAInfo->pbExtra = (LPBYTE)pAAInfo + SIZE_AAINFO;
        cLoop            = cOut;

        while (cLoop--) {

            if ((IdxSrc >= iSrcBeg) && (IdxSrc < iSrcEnd)  &&
                (IdxDst >= iDstBeg) && (IdxDst < iDstEnd)) {

                if (jSrcBeg == -1) {

                    jSrcBeg = IdxSrc;
                    jDstBeg = IdxDst;
                }

                jSrcEnd = IdxSrc;
                jDstEnd = IdxDst;

            } else if (jSrcBeg != -1) {

                break;
            }

            ++IdxSrc;
            ++IdxDst;
        }

        if (jSrcBeg == -1) {

            HTFreeMem(pAAInfo);
            return(NULL);
        }

        pAAInfo->Mask.iBeg  =
        *piSrcBeg           = jSrcBeg;
        *piSrcEnd           = jSrcEnd;
        *piDstBeg           = jDstBeg;
        *piDstEnd           = jDstEnd;
        pAAInfo->Mask.iSize =
        pAAInfo->cIn        = jSrcEnd - jSrcBeg + 1;
        pAAInfo->cOut       = jDstEnd - jDstBeg + 1;
        pAAInfo->cAAData    =
        pAAInfo->cAALoad    = (DWORD)pAAInfo->cOut;
        pAAInfo->Mask.cIn   = cIn;
        pAAInfo->Mask.cOut  = cOut;

        DBGP_IF(DBGP_BUILD,
                DBGP("BLT(%ld->%ld): iSrc=%ld:%ld, iDst=%ld:%ld, cAAData=%ld, cbExtra=%ld, Flags=%4lx"
                    ARGDW(pAAInfo->cIn) ARGDW(pAAInfo->cOut)
                    ARGDW(*piSrcBeg) ARGDW(*piSrcEnd) ARGDW(*piDstBeg)
                    ARGDW(*piDstEnd) ARGDW(pAAInfo->cAAData)
                    ARGDW(cbExtra) ARGDW(pAAInfo->Flags)));
    }

    return(pAAInfo);
}



#define _MATRIX_POW     (FD6)1414214

#if DBG
    FD6 MATRIX_POWER =      _MATRIX_POW;
#else
    #define MATRIX_POWER    _MATRIX_POW
#endif




BOOL
HTENTRY
BuildRepData(
    PSRCBLTINFO         pSBInfo,
    LONG                IdxSrc,
    LONG                IdxDst
    )

/*++

Routine Description:




Arguments:

    piSrcBeg    - Passed in as begining source index, When return this is the
                  real source begining index.  This always well ordered

    piSrcEnd    - Passed in as ending source index, When return this is the
                  real source ending index.  This always well ordered

    SrcSize     - The real size of source in pixel

    IdxDst      - Starting index of destination pixel

    IdxDstEnd   - Ending index of destination pixel, the iDxdst and IdxDstEnd
                  must be well ordered. (exclusive)

    piDstBeg    - Clipped destination start index when passed in, at return
                  it adjusted to the real destination starting index.

    piDstEnd    - Clipped destination end index when passed in, at return
                  it adjusted to the real destination ending index.

    cbExtra     - Extra byte count to be allocated

    NOTE: 1) piDstBeg/piDstEnd When passed in this must be well ordered, and
             when it returned this is well ordered.


Return Value:

    At enter of this function, the *piSrcEnd, *piDstEnd is exclusive but when
    return from this function the *piSrcEnd and *piDstEnd is inclusive

    *piSrcBeg, *piSrcEnd, *piDstBeg, *piDstEnd are updated if return value
    is not NULL

Author:

    22-Mar-1998 Sun 18:36:28 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    SRCBLTINFO  SBInfo;
    PLONG       pSrcInc;
    PLONG       pDstInc;
    LONG        MinRep;
    LONG        MaxRep;
    LONG        cRem;
    LONG        iRep;
    LONG        cRep;
    LONG        cTot;
    LONG        cIn;
    LONG        cOut;
    LONG        jSrcBeg;
    LONG        jSrcEnd;
    LONG        jDstBeg;
    LONG        jDstEnd;
    UINT        cPrevSrc;
    UINT        cNextSrc;


    SBInfo  = *pSBInfo;
    pRep    = SBInfo.pRep;
    pRepEnd = SBInfo.pRepEnd;
    jSrcBeg = -1;

    if (SBInfo.cIn < SBInfo.cOut) {

        //
        // Expanding
        //

        cIn     = SBInfo.cIn;
        cOut    = SBInfo.cOut;
        pSrcInc = &IdxSrc;
        pDstInc = &IdxDst;

    } else if (SBInfo.cIn > SBInfo.cOut) {

        //
        // Shrinking
        //

        cIn     = SBInfo.cOut;
        cOut    = SBInfo.cIn;
        pSrcInc = &IdxDst;
        pDstInc = &IdxSrc;

    } else {

        ASSERT(SBInfo.cIn != SBInfo.cOut);
        return(FALSE);
    }

    MinRep = cOut / cIn;
    MaxRep = MinRep + 1;

    DBGP_IF(DBGP_BUILD,
            DBGP("\nEXPREP(%ld-%ld): iSrc=%ld-%ld, iDst=%ld-%ld, Idx=%ld:%ld"
                ARGDW(SBInfo.cIn) ARGDW(SBInfo.cOut)
                ARGDW(SBInfo.iSrcBeg) ARGDW(SBInfo.iSrcEnd)
                ARGDW(SBInfo.iDstBeg)
                ARGDW(SBInfo.iDstEnd) ARGDW(IdxSrc) ARGDW(IdxDst)));

    SBInfo.cFirstSkip =
    SBInfo.cLastSkip  = 0;
    iRep              =
    cRep              =
    cTot              = 0;

    //
    // Multiply In/Out by 2, so we do not have run down/up problem, the
    // cRem will be initialized with extra 0.5 for rounding.
    //

    cRem   = (cOut <<= 1) + cIn;
    cIn  <<= 1;

    while (IdxDst < SBInfo.iDstEnd) {

        if ((cRem -= cIn) < 0) {

            ++*pSrcInc;

            if (jSrcBeg != -1) {

                ASSERT(pRep < pRepEnd);
                ASSERT(cRep > 0);
                ASSERT(cRep <= MaxRep);

                pRep++->c  = (WORD)cRep;
                cTot      += cRep;

                DBGP_IF(DBGP_BUILD2,
                        DBGP("    Src=%4ld [%4ld-%4ld], Dst=%4ld [%4ld-%4ld], Rep %4ld=%3ld [%4ld -> %4ld, Rem=%4ld, cTot=%4ld]"
                            ARGDW(IdxSrc) ARGDW(SBInfo.iSrcBeg) ARGDW(SBInfo.iSrcEnd)
                            ARGDW(IdxDst) ARGDW(SBInfo.iDstBeg) ARGDW(SBInfo.iDstEnd)
                            ARGDW(pRep - SBInfo.pRep) ARGDW(cRep)
                            ARGDW(cIn) ARGDW(cOut) ARGDW(cRem) ARGDW(cTot)));
            }

            DBGP_IF(DBGP_BUILD3,
                    DBGP("IdxSrc=%4ld, IdxDst=%4ld, Rep=%3ld / %3ld, Rem=%5ld, cIn=%5ld"
                    ARGDW(IdxSrc) ARGDW(IdxDst)
                    ARGDW(cRep) ARGDW(1) ARGDW(cRem) ARGDW(cIn)));

            cRem += cOut;
            iRep  =
            cRep  = 0;

        } else {

            DBGP_IF(DBGP_BUILD3,
                    DBGP("IdxSrc=%4ld, IdxDst=%4ld, Rep=%3ld / %3ld, Rem=%5ld, cIn=%5ld"
                    ARGDW(IdxSrc) ARGDW(IdxDst)
                    ARGDW(cRep) ARGDW(iRep + 1) ARGDW(cRem) ARGDW(cIn)));

        }

        ++iRep;

        if ((IdxSrc >= SBInfo.iSrcBeg) && (IdxSrc < SBInfo.iSrcEnd)  &&
            (IdxDst >= SBInfo.iDstBeg) && (IdxDst < SBInfo.iDstEnd)) {

            ++cRep;

            if (jSrcBeg == -1) {

                //
                // Any iRep will be the first pixel on the destination that
                // corresponding to the current source, so minus 1 is the
                // total count to be skip for this group of destination
                //

                jSrcBeg           = IdxSrc;
                jDstBeg           = IdxDst;
                SBInfo.cFirstSkip = (BYTE)(iRep - 1);

                DBGP_IF(DBGP_BUILD3,
                        DBGP("               @@@ Set cFirstSkip=%ld at IdxDst=%ld @@@"
                            ARGDW(SBInfo.cFirstSkip) ARGDW(IdxDst)));
            }

            jSrcEnd = IdxSrc;
            jDstEnd = IdxDst;

        } else if (jSrcBeg != -1) {

            break;
        }

        ++*pDstInc;
    }

    if (jSrcBeg == -1) {

        DBGP_IF(DBGP_BUILD3,
                DBGP(" Nothing in the source is on the destination"));

        return(FALSE);
    }


    if (cRep) {

        ASSERT(pRep < pRepEnd);

        pRep++->c  = (WORD)cRep;
        cTot      += cRep;

        DBGP_IF(DBGP_BUILD2,
                DBGP("    ****** Total pRep=%ld,  Last cRep=%ld, cTot=%ld"
                        ARGDW(pRep - SBInfo.pRep)
                        ARGDW(cRep) ARGDW(cTot)));
    }

    while ((cRem -= cIn) >= 0) {

        ++SBInfo.cLastSkip;

        DBGP_IF(DBGP_BUILD3,
                DBGP("               @@@ Set cLastSkip=%4ld, cRem=%5ld @@@"
                        ARGDW(SBInfo.cLastSkip) ARGDW(cRem)));

    }

    if (SBInfo.cIn < SBInfo.cOut) {

        //
        // Expanding, checking for maximum 2 sourcs pixels on each side
        //

        cPrevSrc =
        cNextSrc = 2;

    } else {

        //
        // Shrinking, checking only cFirstSkip and cLastSkip
        //

        cPrevSrc = (UINT)SBInfo.cFirstSkip;
        cNextSrc = (UINT)SBInfo.cLastSkip;
    }

    //
    // Check src begin
    //

    IdxSrc = jSrcBeg;

    while ((cPrevSrc) && (IdxSrc > SBInfo.iSrcBeg)) {

        --IdxSrc;
        --cPrevSrc;
    }

    SBInfo.cPrevSrc = (BYTE)(jSrcBeg - IdxSrc);
    IdxSrc          = jSrcEnd;

    while ((cNextSrc) && (IdxSrc < (SBInfo.iSrcEnd - 1))) {

        ++IdxSrc;
        --cNextSrc;
    }

    SBInfo.cNextSrc = (BYTE)(IdxSrc - jSrcEnd);

    DBGP_IF(DBGP_BUILD3,
            DBGP("cFirstSkip=%ld (%ld), cLastSkip=%ld (%ld), cPrevSrc=%ld, cNextSrc=%ld"
            ARGDW(SBInfo.cFirstSkip) ARGDW(SBInfo.pRep->c)
            ARGDW(SBInfo.cLastSkip)  ARGDW((pRep - 1)->c)
            ARGDW(SBInfo.cPrevSrc) ARGDW(SBInfo.cNextSrc)));

    //  Bug 27036: ensure SBInfo.iSrcEnd is always exclusive

    SBInfo.iBeg       =
    SBInfo.iSrcBeg    = jSrcBeg;
    SBInfo.iSrcEnd    = jSrcEnd + 1;
    SBInfo.iDstBeg    = jDstBeg;
    SBInfo.iDstEnd    = jDstEnd + 1;
    SBInfo.iSize      = jSrcEnd - jSrcBeg + 1;
    SBInfo.pRepEnd    = pRep;
    SBInfo.cRep       = 1;

    DBGP_IF((DBGP_BUILD | DBGP_BUILD2 | DBGP_BUILD3),
            DBGP("EXPREP(%ld->%ld): iSrc=%ld-%ld, iDst=%ld-%ld, iRepSize=%ld"
                ARGDW(SBInfo.cIn) ARGDW(SBInfo.cOut)
                ARGDW(SBInfo.iSrcBeg) ARGDW(SBInfo.iSrcEnd)
                ARGDW(SBInfo.iDstBeg) ARGDW(SBInfo.iDstEnd)
                ARGDW(SBInfo.pRepEnd - SBInfo.pRep)));

    *pSBInfo = SBInfo;

    return(TRUE);
}




PAAINFO
HTENTRY
BuildExpandAAInfo(
    PDEVICECOLORINFO    pDCI,
    DWORD               AAHFlags,
    PLONG               piSrcBeg,
    PLONG               piSrcEnd,
    LONG                SrcSize,
    LONG                IdxDst,
    LONG                IdxDstEnd,
    PLONG               piDstBeg,
    PLONG               piDstEnd,
    LONG                cbExtra
    )

/*++

Routine Description:




Arguments:

    piSrcBeg    - Passed in as begining source index, When return this is the
                  real source begining index.  This always well ordered

    piSrcEnd    - Passed in as ending source index, When return this is the
                  real source ending index.  This always well ordered

    SrcSize     - The real size of source in pixel

    IdxDst      - Starting index of destination pixel

    IdxDstEnd   - Ending index of destination pixel, the iDxdst and IdxDstEnd
                  must be well ordered. (exclusive)

    piDstBeg    - Clipped destination start index when passed in, at return
                  it adjusted to the real destination starting index.

    piDstEnd    - Clipped destination end index when passed in, at return
                  it adjusted to the real destination ending index.

    cbExtra     - Extra byte count to be allocated

    NOTE: 1) piDstBeg/piDstEnd When passed in this must be well ordered, and
             when it returned this is well ordered.


Return Value:

    At enter of this function, the *piSrcEnd, *piDstEnd is exclusive but when
    return from this function the *piSrcEnd and *piDstEnd is inclusive

    *piSrcBeg, *piSrcEnd, *piDstBeg, *piDstEnd are updated if return value
    is not NULL

Author:

    22-Mar-1998 Sun 18:36:28 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    PEXPDATA    pED;
    LONG        cMatrix;
    LONG        cM;
    LONG        cIn;
    LONG        cOut;
    LONG        IdxSrc;
    LONG        iSrcBeg;
    LONG        iSrcEnd;
    LONG        iDstBeg;
    LONG        iDstEnd;
    LONG        jSrcBeg;
    LONG        jSrcEnd;
    LONG        jDstBeg;
    LONG        jDstEnd;
    LONGLONG    cTot;
    LONG        MulAdd;
    LONG        Mul;
    DWORD       cAALoad;
    LONG        cbRep;
    LONG        cRem;
    DWORD       cbED;


    cIn  = (LONG)((iSrcEnd = *piSrcEnd) - (iSrcBeg = IdxSrc = *piSrcBeg));
    cOut = IdxDstEnd - IdxDst;

    ASSERT(cOut > 0);

    if (iSrcBeg < 0) {

        iSrcBeg = 0;
    }

    if (iSrcEnd > SrcSize) {

        iSrcEnd = SrcSize;
    }

    iDstBeg = *piDstBeg;
    iDstEnd = *piDstEnd;
    jSrcBeg = -1;
    cAALoad = 0;

    ASSERT(iDstBeg < iDstEnd);
    ASSERT(cIn < cOut);

    DBGP_IF(DBGP_BUILD,
            DBGP("\nEXP(%ld-%ld): iSrc=%ld-%ld, cSrc=%ld, iDst=%ld-%ld, Idx=%ld:%ld"
                ARGDW(cIn) ARGDW(cOut) ARGDW(iSrcBeg) ARGDW(iSrcEnd)
                ARGDW(SrcSize) ARGDW(iDstBeg)
                ARGDW(iDstEnd) ARGDW(IdxSrc) ARGDW(IdxDst)));

    if (AAHFlags & (AAHF_HAS_MASK       |
                    AAHF_ALPHA_BLEND    |
                    AAHF_FAST_EXP_AA    |
                    AAHF_BBPF_AA_OFF)) {

        ALIGN_MEM(cbRep, (iSrcEnd - iSrcBeg + 3) * sizeof(REPDATA));

    } else {

        cbRep = 0;
    }

    if (AAHFlags & (AAHF_BBPF_AA_OFF | AAHF_FAST_EXP_AA)) {

        cMatrix =
        cbED    =
        cM      = 0;

    } else {

        cMatrix = (LONG)((((cOut + (cIn - 1)) / cIn) << 1) - 1);
        cM      = sizeof(DWORD) * cMatrix;

        ALIGN_MEM(cbED, (iDstEnd - iDstBeg) * sizeof(EXPDATA));
    }

    DBGP_IF(DBGP_BUILD,
            DBGP("BuildEXP(%ld, %ld), cMatrix=%ld, cb=%ld+%ld+%ld=%ld"
                ARGDW(cIn) ARGDW(cOut) ARGDW(cMatrix)
                ARGDW(cbRep) ARGDW(cbED) ARGDW(cM)
                ARGDW(cbRep + cbED + cM)));

    ALIGN_MEM(cbExtra, cbExtra);

    if (pAAInfo = (PAAINFO)HTAllocMem((LPVOID)pDCI,
                                      HTMEM_EXPAA,
                                      LPTR,
                                      cbRep + cbED +
                                            cbExtra + cM + SIZE_AAINFO)) {

        LPBYTE      pbExtra;

        SETDBGVAR(pAAInfo->cbAlloc, cbRep + cbED + cbExtra + cM + SIZE_AAINFO);

        pbExtra = (LPBYTE)pAAInfo + SIZE_AAINFO;

        if (cbExtra) {

            pAAInfo->pbExtra  = (LPBYTE)pbExtra;
            pbExtra          += cbExtra;
        }

        if (cbRep) {

            pAAInfo->Src.cIn      = cIn;
            pAAInfo->Src.cOut     = cOut;
            pAAInfo->Src.iSrcBeg  = iSrcBeg;
            pAAInfo->Src.iSrcEnd  = iSrcEnd;
            pAAInfo->Src.iDstBeg  = iDstBeg;
            pAAInfo->Src.iDstEnd  = iDstEnd;
            pAAInfo->Src.pRep     = (PREPDATA)pbExtra;
            pAAInfo->Src.pRepEnd  = pAAInfo->Src.pRep + (iSrcEnd - iSrcBeg);
            pbExtra              += cbRep;

            if (!BuildRepData(&(pAAInfo->Src), IdxSrc, IdxDst)) {

                HTFreeMem(pAAInfo);
                return(NULL);
            }

            pAAInfo->AB   =
            pAAInfo->Mask = pAAInfo->Src;

            if (AAHFlags & AAHF_FAST_EXP_AA) {

                pAAInfo->Src.iSrcBeg -= pAAInfo->Src.cPrevSrc;
                pAAInfo->Src.iSrcEnd += pAAInfo->Src.cNextSrc;
            }
        }

        if (cbED) {

            PEXPDATA    pED;
            PEXPDATA    pEDEnd;
            LPDWORD     pM;
            LPDWORD     pM1;
            LPDWORD     pM2;
            LONG        cRem2;
            LONG        MincM;
            LONGLONG    ExpMul[4];
            EXPDATA     ed;
            WORD        EDFlags;
            LONGLONG    cNum;
            LONG        cLoop;
            LONG        cMul0;
            LONG        cMul1;
            LONG        cMaskRem;
            LONG        iMaskBeg;
            LONG        iMaskEnd;

            pED              = (PEXPDATA)pbExtra;
            pAAInfo->pAAData = (LPVOID)pED;
            pM               = (LPDWORD)((LPBYTE)pED + cbED);
            pM1              = pM;
            pM2              = pM1 + cMatrix - 1;
            cTot             = 0;

            DBGP_IF(DBGP_BUILD,
                    DBGP("Allocate cbExtra=%ld, pbExtra=%p:%p"
                        ARGDW(cbExtra) ARGPTR(pAAInfo->pbExtra)
                        ARGPTR((LPBYTE)pAAInfo->pbExtra + cbExtra)));

            pM2   = (pM1 += (cMatrix >> 1));
            cTot  = (LONGLONG)(*pM1 = FD6_1);

            if (AAHFlags & AAHF_BBPF_AA_OFF) {

                pAAInfo->Flags |= AAIF_EXP_NO_SHARPEN;

            } else {

                MulAdd = cOut;

                while (((MulAdd -= cIn) > 0) && (--pM1 >= pM)) {

                    Mul = (LONG)DivFD6(MulAdd, cOut);

                    if (Mul != 500000) {

                        Mul = (LONG)RaisePower((FD6)Mul,
                                               MATRIX_POWER,
                                               (WORD)((Mul <= 500000) ?
                                                                0 : RPF_RADICAL));
                    }

                    DBGP_IF(DBGP_EXPMATRIX,
                            DBGP("(%4ld, %4ld) = %s ^ %s = %s"
                                    ARGDW(MulAdd) ARGDW(cOut)
                                    ARGFD6((DivFD6(MulAdd, cOut)), 1, 6)
                                    ARGFD6(MATRIX_POWER, 1, 6) ARGFD6(Mul, 1, 6)));

                    *pM1      =
                    *(++pM2)  = Mul;
                    cTot     += (Mul << 1);
                }
            }

    #if DBG
        {
            FD6 PMPrev = FD6_0;
            FD6 PMCur;


            pM1   = pM;
            cLoop = (LONG)cMatrix;

            while (cLoop--) {

                PMCur = DivFD6(*pM1, (FD6)cTot);

                DBGP_IF(DBGP_EXPMATRIX, DBGP("%3ld: %7ld [%s], Dif=%s, cTot=%ld"
                                ARGDW((pM1 - pM) + 1) ARGDW(*pM1)
                                ARGFD6(PMCur, 1, 6) ARGFD6((PMCur - PMPrev), 1, 6)
                                ARGDW(cTot)));

                PMPrev = PMCur;
                ++pM1;
            }
        }
    #endif
            cTot  *= (LONGLONG)cIn;
            cRem   = cOut + (cIn * (LONG)(cMatrix >> 1));
            cLoop  = cOut;
            cMul0  =
            cMul1  = 0;

            while (cLoop--) {

                cRem2 = cRem;

                if ((cRem -= cIn) <= 0) {

                    cRem += cOut;
                }

                pM1     = pM;
                cM      = cMatrix;
                MincM   = (cMatrix >> 1) - cLoop;
                EDFlags = 0;

                ZeroMemory(ExpMul, sizeof(ExpMul));

                while (cM--) {

                    LONG    cMul;


                    Mul = *pM1++;

                    if ((cRem2 < cIn) && (cM >= MincM)) {

                        if (cMul = cRem2) {

                            ExpMul[3] += (LONGLONG)cRem2 * (LONGLONG)Mul;
                        }

                        cRem2 -= cIn;

                        ASSERTMSG("BuildEXP: Shift more than 3 times", !ExpMul[0]);

                        CopyMemory(&ExpMul[0], &ExpMul[1], sizeof(ExpMul[0]) * 3);

                        ExpMul[3]  = (LONGLONG)-cRem2 * (LONGLONG)Mul;
                        cRem2     += cOut;

                        if (!cM) {

                            if ((++IdxSrc >= iSrcBeg) && (IdxSrc < iSrcEnd)) {

                                EDFlags |= EDF_LOAD_PIXEL;

                                ++cAALoad;
                                ++IdxSrc;

                                if ((IdxSrc <  iSrcBeg) ||
                                    (IdxSrc >= iSrcEnd)) {

                                    EDFlags |= EDF_NO_NEWSRC;
                                }

                                --IdxSrc;
                            }
                        }

                    } else {

                        ExpMul[3] += (LONGLONG)(cMul = cIn) * (LONGLONG)Mul;
                        cRem2     -= cIn;
                    }

                    DBGP_IF(DBGP_BUILD3,
                            DBGP("%5ld-%7ld:%7ld:%7ld:%7ld, %4ld+, cRem2=%4ld, cM=%5ld:%5ld, cMul=%5ldx%5ld%hs%hs"
                                ARGDW(cOut - cLoop - 1) ARGDW(ExpMul[0])
                                ARGDW(ExpMul[1]) ARGDW(ExpMul[2]) ARGDW(ExpMul[3])
                                ARGDW(cMul * Mul) ARGDW(cRem2) ARGDW(cM)
                                ARGDW(MincM) ARGDW(cMul) ARGDW(Mul)
                                ARGPTR((EDFlags & EDF_LOAD_PIXEL) ? ", Load Pixel" : "")
                                ARGPTR((EDFlags & EDF_NO_NEWSRC) ? ", NO New Src" : "")));
                }

                if ((IdxSrc >= iSrcBeg) && (IdxSrc < iSrcEnd)  &&
                    (IdxDst >= iDstBeg) && (IdxDst < iDstEnd)) {

                    GET_FIRST_EDMUL(ed.Mul[3], ExpMul[3], cNum, cTot);
                    GET_NEXT_EDMUL( ed.Mul[2], ExpMul[2], cNum, cTot);

                    if (ExpMul[1]) {

                        ++cMul1;

                        GET_NEXT_EDMUL(ed.Mul[1], ExpMul[1], cNum, cTot);

                        if (ExpMul[0]) {

                            ++cMul0;

                            GET_NEXT_EDMUL(ed.Mul[0], ExpMul[0], cNum, cTot);

                        } else {

                            ed.Mul[0] = 0;
                        }

                    } else {

                        ed.Mul[1] =
                        ed.Mul[0] = 0;
                    }

                    ASSERTMSG("ed.Mul[0] > DI_MAX_NUM", ed.Mul[0] <= DI_MAX_NUM);
                    ASSERTMSG("ed.Mul[1] > DI_MAX_NUM", ed.Mul[1] <= DI_MAX_NUM);
                    ASSERTMSG("ed.Mul[2] > DI_MAX_NUM", ed.Mul[2] <= DI_MAX_NUM);
                    ASSERTMSG("ed.Mul[3] > DI_MAX_NUM", ed.Mul[3] <= DI_MAX_NUM);

                    DBGP_IF(DBGP_BUILD2,
                            DBGP("--%5ld=%7ld:%7ld:%7ld:%7ld, IdxSrc=%5ld --%hs%hs--"
                            ARGDW(IdxDst) ARGDW(ed.Mul[0])
                            ARGDW(ed.Mul[1]) ARGDW(ed.Mul[2])
                            ARGDW(ed.Mul[3]) ARGDW(IdxSrc)
                            ARGPTR((EDFlags & EDF_LOAD_PIXEL) ? ", Load Pixel" : "")
                            ARGPTR((EDFlags & EDF_NO_NEWSRC) ? ", NO New Src" : "")));

                    ed.Mul[0] |= EDFlags;
                    *pED++     = ed;

                    if (jSrcBeg == -1) {

                        iMaskBeg = (cOut - cLoop - 1);
                        jSrcBeg  = IdxSrc;
                        jDstBeg  = IdxDst;
                    }

                    jSrcEnd = IdxSrc;
                    jDstEnd = IdxDst;

                } else if (jSrcBeg != -1) {

                    break;
                }

                ++IdxDst;
            }

            if (jSrcBeg == -1) {

                HTFreeMem(pAAInfo);
                return(NULL);
            }

            //
            // 10-Jun-1998 Wed 08:41:16 updated  -by-  Daniel Chou (danielc)
            //  Fixed for the problem that we need to read extra source for the
            //  last loaded pixel because before expand we will sharpen the pixel
            //  by its 4 neighbors, this will make sure Last+1 pixel/scan line
            //  got read it for sharpen purpose
            //
            // BEGIN FIX
            //

            ++jSrcEnd;

            if ((jSrcEnd < iSrcBeg) || (jSrcEnd >= iSrcEnd)) {

                --jSrcEnd;
            }

            //
            // END FIX
            //

            IdxSrc           =
            *piSrcBeg        = jSrcBeg;
            *piSrcEnd        = jSrcEnd;
            *piDstBeg        = jDstBeg;
            *piDstEnd        = jDstEnd;
            pEDEnd           = pED;
            pED              = (PEXPDATA)(pAAInfo->pAAData);
            pAAInfo->cAAData = (DWORD)(pEDEnd - pED);
            pAAInfo->cAALoad = cAALoad;
            pAAInfo->cMaxMul = (DWORD)((cMul1) ? ((cMul0) ? 4 : 3) : 2);
            ed               = *pED;
            cLoop            = 4;

            if (ed.Mul[0] & EDF_LOAD_PIXEL) {

                --IdxSrc;
                --cLoop;

            } else {

                ++IdxSrc;

                if ((IdxSrc < iSrcBeg) || (IdxSrc >= iSrcEnd)) {

                    pAAInfo->Flags |= AAIF_EXP_NO_LAST_RIGHT;
                }

                --IdxSrc;
            }

            cMul0 = 0;

            while ((cMul0 < cLoop) &&
                   (!(ed.Mul[cMul0] & ~(EDF_LOAD_PIXEL | EDF_NO_NEWSRC)))) {

                ++cMul0;
            }

            DBGP_IF(DBGP_BUILD,
                DBGP("cMul0=%ld, cLoop=%ld, IdxSrc=%ld, iSrcBeg=%ld, iSrcEnd=%ld"
                    ARGDW(cMul0) ARGDW(cLoop) ARGDW(IdxSrc)
                    ARGDW(iSrcBeg) ARGDW(iSrcEnd)));

            while (cLoop-- > cMul0) {

                if ((IdxSrc >= iSrcBeg) && (IdxSrc < iSrcEnd)) {

                    *piSrcBeg          = IdxSrc;
                    pAAInfo->cPreLoad += 0x01;

                } else {

                    pAAInfo->cPreLoad += 0x10;
                }

                --IdxSrc;
            }

            if (pAAInfo->cPreLoad) {

                if ((IdxSrc >= iSrcBeg) && (IdxSrc < iSrcEnd)) {

                    *piSrcBeg       = IdxSrc;
                    pAAInfo->Flags |= AAIF_EXP_HAS_1ST_LEFT;
                }
            }

            if (!(pAAInfo->cPreLoad)) {

                DBGP("*** cPreLOAD=0, BuildExpandAAInfo [%04lx:%04lx:%04lx:%04lx], cPreload=0x%02lx, Flags=0x%04lx"
                    ARGDW(ed.Mul[0]) ARGDW(ed.Mul[1]) ARGDW(ed.Mul[2]) ARGDW(ed.Mul[3])
                    ARGDW(pAAInfo->cPreLoad) ARGDW(pAAInfo->Flags));
            }

        } else {

            //  Bug 27036: ensure jSrcEnd is less than iSrcEnd
            *piSrcBeg = pAAInfo->Src.iSrcBeg;
            *piSrcEnd = pAAInfo->Src.iSrcEnd - 1;
            *piDstBeg = pAAInfo->Src.iDstBeg;
            *piDstEnd = pAAInfo->Src.iDstEnd - 1;
        }

        pAAInfo->cIn  = *piSrcEnd - *piSrcBeg + 1;
        pAAInfo->cOut = *piDstEnd - *piDstBeg + 1;

        DBGP_IF((DBGP_BUILD | DBGP_BUILD2 | DBGP_BUILD3),
                DBGP("EXP(%ld->%ld): iSrc=%ld-%ld, iDst=%ld-%ld, cAAData=%ld, cPreLoad=0x%02lx, Flags=0x%04lx"
                    ARGDW(pAAInfo->cIn) ARGDW(pAAInfo->cOut)
                    ARGDW(*piSrcBeg) ARGDW(*piSrcEnd) ARGDW(*piDstBeg)
                    ARGDW(*piDstEnd) ARGDW(pAAInfo->cAAData)
                    ARGDW(pAAInfo->cPreLoad) ARGDW(pAAInfo->Flags)));
    }

    return(pAAInfo);
}



PAAINFO
HTENTRY
BuildShrinkAAInfo(
    PDEVICECOLORINFO    pDCI,
    DWORD               AAHFlags,
    PLONG               piSrcBeg,
    PLONG               piSrcEnd,
    LONG                SrcSize,
    LONG                IdxDst,
    LONG                IdxDstEnd,
    PLONG               piDstBeg,
    PLONG               piDstEnd,
    LONG                cbExtra
    )

/*++

Routine Description:




Arguments:

    piSrcBeg    - Passed in as begining source index, When return this is the
                  real source begining index.  This always well ordered

    piSrcEnd    - Passed in as ending source index, When return this is the
                  real source ending index.  This always well ordered

    SrcSize     - The real size of source in pixel

    IdxDst      - Starting index of destination pixel

    IdxDstEnd   - Ending index of destination pixel, the iDxdst and IdxDstEnd
                  must be well ordered.

    piDstBeg    - Clipped destination start index when passed in, at return
                  it adjusted to the real destination starting index.

    piDstEnd    - Clipped destination end index when passed in, at return
                  it adjusted to the real destination ending index.

    cbExtra     - Extra byte count to be allocated

    NOTE: 1) piDstBeg/piDstEnd When passed in this must be well ordered, and
             when it returned this is well ordered.

Return Value:

    PSHRINKINFO, if NULL then memory allocation failed


Author:

    20-Mar-1998 Fri 12:29:17 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    PLONG       pMap;
    PLONG       pMapEnd;
    PSHRINKDATA pSD;
    PSHRINKDATA pSDEnd;
    LONG        cIn;
    LONG        cOut;
    LONG        IdxSrc;
    LONG        IdxDstOrg;
    LONG        iSrcBeg;
    LONG        iSrcEnd;
    LONG        iDstBeg;
    LONG        iDstEnd;
    LONG        jSrcBeg;
    LONG        jSrcEnd;
    LONG        jDstBeg;
    LONG        jDstEnd;
    LONG        cLoop;
    LONG        cbRep;
    LONG        Mul;
    LONG        NextMul;
    LONG        CurMul;
    LONG        cCur;
    LONG        MinPixel;
    DWORD       cAAData;
    DWORD       cAADone;
    LONGLONG    cNum;



    cIn  = (LONG)((iSrcEnd = *piSrcEnd) - (iSrcBeg = IdxSrc = *piSrcBeg));
    cOut = IdxDstEnd - (IdxDstOrg = IdxDst);

    ASSERT(cOut > 0);

    if (iSrcBeg < 0) {

        iSrcBeg = 0;
    }

    if (iSrcEnd > SrcSize) {

        iSrcEnd = SrcSize;
    }

    //
    // For shrinking we will enlarge the destination by 1 on both side to
    // obtained the source pixel that for sharpening purpose
    //

    iDstBeg = *piDstBeg - 1;
    iDstEnd = *piDstEnd;
    jSrcBeg = -1;
    cAADone = 0;

    ASSERT(iDstBeg < iDstEnd);
    ASSERT(cIn > cOut);

    DBGP_IF(DBGP_BUILD,
            DBGP("\nSRK(%ld-%ld): iSrc=%ld-%ld, cSrc=%ld, iDst=%ld-%ld (%ld-%ld), Idx=%ld:%ld"
                ARGDW(cIn) ARGDW(cOut) ARGDW(iSrcBeg) ARGDW(iSrcEnd)
                ARGDW(SrcSize) ARGDW(iDstBeg) ARGDW(iDstEnd)
                ARGDW(*piDstBeg) ARGDW(*piDstEnd)
                ARGDW(IdxSrc) ARGDW(IdxDst)));

    //
    // Firstable figure out how may SHRINKDATA needed
    //
    cAAData = (DWORD)((((iDstEnd - iDstBeg + 1) * cIn) + (cOut-1)) / cOut) + 4;

    if ((LONG)cAAData > cIn) {

        (LONG)cAAData = cIn;
    }


    DBGP_IF(DBGP_BUILD,
            DBGP("BuildShrink(%ld-%ld): cSD estimated=%ld (%ld), iDst=%ld-%ld=%ld"
                ARGDW(cIn) ARGDW(cOut) ARGDW(cAAData) ARGDW(cIn)
                ARGDW(iDstBeg) ARGDW(iDstEnd) ARGDW(iDstEnd - iDstBeg)));

    ALIGN_MEM(CurMul, 256 * 2 * sizeof(LONG));
    ALIGN_MEM(cCur, (cAAData + 1) * sizeof(SHRINKDATA));

    CurMul   += cCur;
    MinPixel  = (LONG)(((LONGLONG)cOut * (LONGLONG)DI_MAX_NUM) / (LONGLONG)cIn);

    if (AAHFlags & (AAHF_HAS_MASK       |
                    AAHF_ALPHA_BLEND    |
                    AAHF_FAST_EXP_AA    |
                    AAHF_BBPF_AA_OFF)) {

        ALIGN_MEM(cbRep, (iDstEnd - iDstBeg + 4) * sizeof(REPDATA));

        if (AAHFlags & AAHF_BBPF_AA_OFF) {

            CurMul = 0;
        }

    } else {

        cbRep = 0;
    }

    ALIGN_MEM(cbExtra, cbExtra);

    if (pAAInfo = (PAAINFO)HTAllocMem((LPVOID)pDCI,
                                      HTMEM_SRKAA,
                                      LPTR,
                                      SIZE_AAINFO + CurMul +
                                                    cbRep + cbExtra)) {

        LPBYTE  pbExtra;


        SETDBGVAR(pAAInfo->cbAlloc, SIZE_AAINFO + CurMul + cbRep + cbExtra);

        pbExtra = (LPBYTE)pAAInfo + SIZE_AAINFO;

        if (cbExtra) {

            pAAInfo->pbExtra  = (LPBYTE)pbExtra;
            pbExtra          += cbExtra;
        }

        if (cbRep) {

            pAAInfo->Src.cIn       = cIn;
            pAAInfo->Src.cOut      = cOut;
            pAAInfo->Src.iSrcBeg   = iSrcBeg;
            pAAInfo->Src.iSrcEnd   = iSrcEnd;
            pAAInfo->Src.iDstBeg   = iDstBeg + 1;
            pAAInfo->Src.iDstEnd   = iDstEnd;
            pAAInfo->Src.pRep      = (PREPDATA)pbExtra;
            pAAInfo->Src.pRepEnd   = pAAInfo->Src.pRep + (iDstEnd-iDstBeg+1);
            pbExtra               += cbRep;

            if (!BuildRepData(&(pAAInfo->Src), IdxSrc, IdxDst)) {

                HTFreeMem(pAAInfo);
                return(NULL);
            }

            pAAInfo->AB   =
            pAAInfo->Mask = pAAInfo->Src;
        }

        if (CurMul) {

            pAAInfo->cPreLoad  = 1;
            pMap               =
            pAAInfo->pMapMul   = (PLONG)pbExtra;
            pMapEnd            = pMap + 256;
            pSD                = (PSHRINKDATA)(pMap + (256 * 2));
            pSDEnd             = pSD + cAAData;
            pAAInfo->pAAData   = (LPVOID)pSD;
            Mul                = -MinPixel;
            CurMul             = MinPixel + 1;
            NextMul            = -CurMul;


            ASSERT_MEM_ALIGN(pAAInfo->pMapMul, sizeof(LONG));

            //
            // Build InMax 256 multiplication table
            //

            do {

                pMap[  0]  = (Mul += MinPixel);
                pMap[256]  = (NextMul += CurMul);

            } while (++pMap < pMapEnd);

            //
            // Build the SHRINKINFO table
            //


            CurMul  = 0;
            cCur    =
            cLoop   = cIn;
            cNum    = (LONGLONG)0;
            cAAData = 0;
            --pSD;

            while (cLoop--) {

                WORD    SDFlags;

                if ((cCur -= cOut) <= 0) {

                    Mul      = cCur + cOut;
                    NextMul  = -cCur;
                    cCur    += cIn;
                    SDFlags  = SDF_DONE;

                    ++IdxDst;

                } else {

                    Mul     = cOut;
                    SDFlags = 0;
                }

                if ((IdxDst >= (iDstBeg - 1)) && (IdxDst <= iDstEnd)) {

                    cNum += ((LONGLONG)Mul * (LONGLONG)DI_MAX_NUM);

                    if ((Mul = (LONG)(cNum / cIn)) > MinPixel) {

                        SDFlags |= SDF_LARGE_MUL;
                    }

                    CurMul += Mul;
                    cNum   %= cIn;

                    if (SDFlags & SDF_DONE) {

                        cNum    = (LONGLONG)NextMul * (LONGLONG)DI_MAX_NUM;
                        NextMul = (LONG)(cNum / cIn);

                        if ((Mul + NextMul) > MinPixel) {

                            SDFlags |= SDF_LARGE_MUL;

                        } else {

                            SDFlags &= ~SDF_LARGE_MUL;
                        }

                        cNum   %= cIn;
                        CurMul  = NextMul;
                        NextMul = 0;
                    }
                }

                if ((IdxDst >= iDstBeg) && (IdxDst <= iDstEnd)) {

                    if ((IdxSrc >= iSrcBeg) && (IdxSrc < iSrcEnd)) {

                        //
                        // Save it first
                        //

                        cAADone += (SDFlags & SDF_DONE) ? 1 : 0;

                        if (++pSD >= pSDEnd) {

                            DBGP("Error(1): cAAData Overrun of %ld, Fixed it"
                                                ARGDW(++cAAData));
                            ASSERT(pSD < pSDEnd);

                            --pSD;
                        }

                        pSD->Mul  = (WORD)Mul | SDFlags;

                        ASSERTMSG("sd.Mul > DI_MAX_NUM", Mul <= DI_MAX_NUM);

                        if (jSrcBeg == -1) {

                            jSrcBeg =
                            jSrcEnd = IdxSrc;
                            jDstBeg =
                            jDstEnd = IdxDst;

                            if (SDFlags & SDF_DONE) {

                                //
                                // If we just finished a pixel then we need to see
                                // if it is a source index or a detination index
                                // cause the output become valid
                                //

                                if (IdxDst == iDstBeg) {

                                    //
                                    // The destination just become valid now,
                                    // PreMul is the start of current detination
                                    // until next done pixel
                                    //

                                    DBGP_IF(DBGP_BUILD,
                                            DBGP("@@ FIRST DEST: PreMul=CurMul=%ld, No PSD, IncSrc"
                                                ARGDW(CurMul)));

                                    pAAInfo->PreMul    = (WORD)CurMul;
                                    pAAInfo->PreSrcInc = 1;
                                    --cAADone;
                                    --pSD;

                                } else {

                                    //
                                    // The source just become valid now, need to
                                    // PreMul all prev sources for this detination
                                    // and save this pSD for done pixel
                                    //

                                    DBGP_IF(DBGP_BUILD,
                                            DBGP("@@ FIRST SRC: PreMul=%ld - Mul (%ld)=%ld"
                                                ARGDW(DI_MAX_NUM) ARGDW(Mul)
                                                ARGDW(DI_MAX_NUM - Mul)));

                                    pAAInfo->PreMul = (WORD)(DI_MAX_NUM - Mul);

                                    --jDstBeg;
                                    --jDstEnd;

                                    ASSERTMSG("!!! Error: jDstBeg is WRONG",
                                                (jDstBeg >= iDstBeg) &&
                                                (jDstBeg <= iDstEnd));
                                }

                            } else {

                                //
                                // We are in the middle of compositions, so the
                                // source just become valid, notice that PreMul
                                // could be zero
                                //

                                DBGP_IF(DBGP_BUILD,
                                        DBGP("@@ FIRST MIDDLE: PreMul=CurMul (%ld) - Mul (%ld)=%ld"
                                            ARGDW(CurMul) ARGDW(Mul)
                                            ARGDW(CurMul - Mul)));

                                pAAInfo->PreMul = (WORD)(CurMul - Mul);
                            }

                        } else {

                            jSrcEnd = IdxSrc;
                            jDstEnd = IdxDst;
                        }

                    } else if (jSrcBeg != -1) {

                        //
                        // Source got cut off early, so wrap it up now
                        //

                        DBGP_IF(DBGP_BUILD,
                                DBGP("@@ END SRC: Mul=%ld, CurMul=%ld"
                                    ARGDW(Mul) ARGDW(CurMul)));

                        if (++pSD >= pSDEnd) {

                            DBGP("Error(2): cAAData Overrun of %ld, Fixed it"
                                        ARGDW(++cAAData));
                            ASSERT(pSD < pSDEnd);

                            --pSD;
                        }

                        if (!(SDFlags & SDF_DONE)) {

                            Mul += (DI_MAX_NUM - CurMul);
                        }

                        pSD->Mul  = (WORD)Mul | (SDFlags |= SDF_DONE);
                        cLoop     = 0;
                        ++cAADone;

                        ASSERTMSG("sd.Mul > DI_MAX_NUM", Mul <= DI_MAX_NUM);
                    }

                } else if (jSrcBeg != -1) {

                    //
                    // we just pass the iDstEnd so this one MUST have SDF_DONE
                    // bit set and we need to save this one, if this one is not
                    // SDF_DONE then something is wrong
                    //

                    ASSERTMSG("End Dest but not SDF_DONE", SDFlags & SDF_DONE);

                    DBGP_IF(DBGP_BUILD,
                            DBGP("@@ PASS IdxDst: Mul=%ld, CurMul=%ld"
                                    ARGDW(Mul) ARGDW(CurMul)));

                    if (++pSD >= pSDEnd) {

                        DBGP("Error(3): cAAData Overrun of %ld, Fixed it"
                                    ARGDW(++cAAData));
                        ASSERT(pSD < pSDEnd);

                        --pSD;
                    }

                    jSrcEnd  = IdxSrc;
                    Mul      = DI_MAX_NUM - CurMul;
                    pSD->Mul = (WORD)Mul | (SDFlags = SDF_DONE);
                    cLoop    = 0;
                    ++cAADone;

                    ASSERTMSG("sd.Mul > DI_MAX_NUM", Mul <= DI_MAX_NUM);
                }
#if DBG
                if ((pSD >= (PSHRINKDATA)(pAAInfo->pAAData)) ||
                    (pAAInfo->PreSrcInc)) {

                    BOOL    HasSD;

                    HasSD = (BOOL)(pSD >= (PSHRINKDATA)(pAAInfo->pAAData));

                    if (SDFlags & SDF_DONE) {

                        DBGP_IF(DBGP_BUILD2,
                                DBGP("%hscLoop=%5ld (%5ld/%5ld), iSrc=%5ld, Mul=%5ld [%5ld], Flags=0x%04lx%hs, Done Pixel"
                                    ARGPTR((HasSD) ? "" : "  >>")
                                    ARGDW(cIn - cLoop - 1) ARGDW(IdxDst)
                                    ARGDW(IdxDst - iDstBeg)
                                    ARGDW(IdxSrc)
                                    ARGDW((Mul) ? Mul :
                                                ((SDFlags & SDF_LARGE_MUL) ?
                                                        MinPixel + 1 : MinPixel))
                                    ARGDW(CurMul)
                                    ARGDW(SDFlags)
                                    ARGPTR((SDFlags & SDF_LARGE_MUL) ? ", Large Mul" : "")));

                    } else {

                        DBGP_IF(DBGP_BUILD2,
                                DBGP("%hscLoop=%5ld                iSrc=%5ld, Mul=%5ld [%5ld], Flags=0x%04lx%hs"
                                ARGPTR((HasSD) ? "" : "  >>")
                                ARGDW(cIn - cLoop - 1)
                                ARGDW(IdxSrc)
                                ARGDW((Mul) ? Mul : ((SDFlags & SDF_LARGE_MUL) ?
                                                MinPixel + 1 : MinPixel))
                                ARGDW(CurMul)
                                ARGDW(SDFlags)
                                ARGPTR((SDFlags & SDF_LARGE_MUL) ? ", Large Mul" : "")));
                    }
                }
#endif

                ++IdxSrc;
            }

            //
            // For the last one ZERO
            //

            ++pSD;

            if ((jSrcBeg == -1) || (pSD == (PSHRINKDATA)(pAAInfo->pAAData))) {

                HTFreeMem(pAAInfo);
                return(NULL);
            }

            ++iDstBeg;

            DBGP_IF(DBGP_BUILD,
                    DBGP("*** Final jDstBeg/End=%ld:%ld, REAL=(%ld:%ld)"
                    ARGDW(jDstBeg) ARGDW(jDstEnd) ARGDW(iDstBeg) ARGDW(iDstEnd)));

            //  Bug 27036: ensure jSrcEnd is less than iSrcEnd
            if (jSrcEnd >= iSrcEnd)
            {
                jSrcEnd = iSrcEnd - 1;
            }

            if (jDstBeg < iDstBeg) {

                ++(pAAInfo->cPreLoad);

                jDstBeg = iDstBeg;
            }

            if (jDstEnd >= iDstEnd) {

                jDstEnd = iDstEnd - 1;
            }

            if ((pAAInfo->PreSrcInc) && (pAAInfo->PreMul == 0)) {

                pAAInfo->PreSrcInc = 0;
                ++jSrcBeg;
            }
#if 0
            //
            // 04-Aug-2000 Fri 15:31:03 updated  -by-  Daniel Chou (danielc)
            //  This assert does not applyed here when anti-aliasing will use
            //  surounding 3 pixels (L/T/R/B) if source available (when clipped
            //  source) but the Rep does not use suround pixels.
            //

            if (cbRep) {

                ASSERT(jSrcBeg == pAAInfo->Mask.iBeg);

                if (jSrcEnd != (pAAInfo->Mask.iBeg + pAAInfo->Mask.iSize - 1)) {

                    DBGP("jSrcEnd=%ld, Mask: iBeg=%ld, iSize=%ld"
                            ARGDW(jSrcEnd) ARGDW(pAAInfo->Mask.iBeg)
                            ARGDW(pAAInfo->Mask.iSize));

                    ASSERT(jSrcEnd == pAAInfo->Mask.iBeg + pAAInfo->Mask.iSize - 1);
                }
            }
#endif
            pAAInfo->cAAData = (DWORD)(pSD - (PSHRINKDATA)(pAAInfo->pAAData));
            pAAInfo->cAADone = cAADone;
            pSD->Mul         = 0;

        } else {

            ASSERT(cbRep);

            //  Bug 27036: ensure jSrcEnd is less than iSrcEnd
            jSrcBeg = pAAInfo->Src.iSrcBeg;
            jSrcEnd = pAAInfo->Src.iSrcEnd - 1;
            jDstBeg = pAAInfo->Src.iDstBeg;
            jDstEnd = pAAInfo->Src.iDstEnd - 1;
        }

        *piSrcBeg     = jSrcBeg;
        *piSrcEnd     = jSrcEnd;
        *piDstBeg     = jDstBeg;
        *piDstEnd     = jDstEnd;
        pAAInfo->cIn  = jSrcEnd - jSrcBeg + 1;
        pAAInfo->cOut = jDstEnd - jDstBeg + 1;

        DBGP_IF(DBGP_BUILD,
                DBGP("SRK(%ld->%ld): iSrc=%ld-%ld, iDst=%ld-%ld, cAAData=%ld, cAADone=%ld, PreMul=%4ld, PresrcInc=%ld, cPreLoad=%ld"
                    ARGDW(pAAInfo->cIn) ARGDW(pAAInfo->cOut)
                    ARGDW(jSrcBeg) ARGDW(jSrcEnd) ARGDW(jDstBeg) ARGDW(jDstEnd)
                    ARGDW(pAAInfo->cAAData) ARGDW(cAADone) ARGDW(pAAInfo->PreMul)
                    ARGDW(pAAInfo->PreSrcInc) ARGDW(pAAInfo->cPreLoad)));
    }

    return(pAAInfo);
}



#if DBG
BOOL    ExpExp = TRUE;
BOOL    SrkSrk = TRUE;
#endif


LONG
HTENTRY
ComputeAABBP(
    PBITBLTPARAMS   pBBP,
    PHTSURFACEINFO  pDstSI,
    PAABBP          pAABBP,
    BOOL            GrayFunc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    01-Apr-1998 Wed 20:32:36 created  -by-  Daniel Chou (danielc)


Revision History:

    05-Aug-1998 Wed 19:38:56 updated  -by-  Daniel Chou (danielc)
        Fix banding problem

    10-Aug-1998 Mon 16:05:32 updated  -by-  Daniel Chou (danielc)
        Fix rectangle banding with flip (X or Y) computation, the computation
        is done first by flip the Destination rectangles (Orginal and final)
        first by compute from right to left for flipping X, and bottom to
        top for flipping Y, after computation for stretch, we flip all the
        rectangles back


--*/

{
    BITBLTPARAMS    BBP;
    RECTL           rclSurf;
    RECTL           rclPhyDst;
    LONG            cxIn;
    LONG            cyIn;
    LONG            cxOut;
    LONG            cyOut;
    LONG            Tmp;
    DWORD           AAHFlags;


    BBP      = *pBBP;
    AAHFlags = pAABBP->AAHFlags;

    DBGP_IF(DBGP_AAHEADER,
            DBGP(" Input: rclSrc=(%6ld, %6ld)-(%6ld, %6ld)=%6ld x %6ld"
                ARGDW(pBBP->rclSrc.left) ARGDW(pBBP->rclSrc.top)
                ARGDW(pBBP->rclSrc.right) ARGDW(pBBP->rclSrc.bottom)
                ARGDW(pBBP->rclSrc.right - pBBP->rclSrc.left)
                ARGDW(pBBP->rclSrc.bottom - pBBP->rclSrc.top)));

    DBGP_IF(DBGP_AAHEADER,
            DBGP(" Input: rclDst=(%6ld, %6ld)-(%6ld, %6ld)=%6ld x %6ld"
            ARGDW(pBBP->rclDest.left) ARGDW(pBBP->rclDest.top)
            ARGDW(pBBP->rclDest.right) ARGDW(pBBP->rclDest.bottom)
            ARGDW(pBBP->rclDest.right - pBBP->rclDest.left)
            ARGDW(pBBP->rclDest.bottom - pBBP->rclDest.top)));

    if (BBP.Flags & BBPF_HAS_DEST_CLIPRECT) {

        DBGP_IF(DBGP_AAHEADER,
                DBGP(" Input: rclClip=(%6ld, %6ld)-(%6ld, %6ld)=%6ld x %6ld"
                    ARGDW(pBBP->rclClip.left) ARGDW(pBBP->rclClip.top)
                    ARGDW(pBBP->rclClip.right) ARGDW(pBBP->rclClip.bottom)
                    ARGDW(pBBP->rclClip.right - pBBP->rclClip.left)
                    ARGDW(pBBP->rclClip.bottom - pBBP->rclClip.top)));
    }

    if (BBP.Flags & BBPF_HAS_BANDRECT) {

        DBGP_IF(DBGP_AAHEADER,
                DBGP(" Input: rclBand=(%6ld, %6ld)-(%6ld, %6ld)=%6ld x %6ld"
                ARGDW(pBBP->rclBand.left) ARGDW(pBBP->rclBand.top)
                ARGDW(pBBP->rclBand.right) ARGDW(pBBP->rclBand.bottom)
                ARGDW(pBBP->rclBand.right - pBBP->rclBand.left)
                ARGDW(pBBP->rclBand.bottom - pBBP->rclBand.top)));
    }

    DBGP_IF(DBGP_AAHEADER,
            DBGP("Input: ptlBrushOrg=(%6ld, %6ld)"
            ARGDW(pBBP->ptlBrushOrg.x) ARGDW(pBBP->ptlBrushOrg.y)));

    DBGP_IF(DBGP_AAHEADER,
            DBGP("Input: ptlSrcMask=(%6ld, %6ld)"
                ARGDW(pBBP->ptlSrcMask.x) ARGDW(pBBP->ptlSrcMask.y)));

    if (BBP.rclDest.right < BBP.rclDest.left) {

        XCHG(BBP.rclDest.left, BBP.rclDest.right, Tmp);
        AAHFlags |= AAHF_FLIP_X;
    }

    if (BBP.rclDest.bottom < BBP.rclDest.top) {

        XCHG(BBP.rclDest.top, BBP.rclDest.bottom, Tmp);
        AAHFlags |= AAHF_FLIP_Y;
    }

    //
    // The source RECT is always well ordered
    //

    if (BBP.rclSrc.right < BBP.rclSrc.left) {

        XCHG(BBP.rclSrc.left, BBP.rclSrc.right, Tmp);
        AAHFlags ^= AAHF_FLIP_X;
    }

    if (BBP.rclSrc.bottom < BBP.rclSrc.top) {

        XCHG(BBP.rclSrc.top, BBP.rclSrc.bottom, Tmp);
        AAHFlags ^= AAHF_FLIP_Y;
    }

    if ((BBP.rclSrc.left >= BBP.rclSrc.right)   ||
        (BBP.rclSrc.top >= BBP.rclSrc.bottom)) {

        DBGP_IF(DBGP_AAHEADER,
                DBGP("EMPTY rclSrc: (%ld, %ld)-(%ld, %ld)=%ldx%ld"
                    ARGDW(BBP.rclSrc.left) ARGDW(BBP.rclSrc.top)
                    ARGDW(BBP.rclSrc.right) ARGDW(BBP.rclSrc.bottom)
                    ARGDW(BBP.rclSrc.right - BBP.rclSrc.left)
                    ARGDW(BBP.rclSrc.bottom - BBP.rclSrc.top)));

        return(0);
    }

    if ((BBP.rclDest.left >= BBP.rclDest.right)  ||
        (BBP.rclDest.top >= BBP.rclDest.bottom)) {

        DBGP_IF(DBGP_AAHEADER,
                DBGP("EMPTY rclDest: (%ld, %ld)-(%ld, %ld)=%ldx%ld"
                    ARGDW(BBP.rclDest.left) ARGDW(BBP.rclDest.top)
                    ARGDW(BBP.rclDest.right) ARGDW(BBP.rclDest.bottom)
                    ARGDW(BBP.rclDest.right - BBP.rclDest.left)
                    ARGDW(BBP.rclDest.bottom - BBP.rclDest.top)));

        return(0);
    }

    //
    // set the cxIn, cyIn for no sign
    //

    cxIn                = BBP.rclSrc.right - BBP.rclSrc.left;
    cyIn                = BBP.rclSrc.bottom - BBP.rclSrc.top;
    cxOut               = BBP.rclDest.right - BBP.rclDest.left;
    cyOut               = BBP.rclDest.bottom - BBP.rclDest.top;
    pAABBP->ptlBrushOrg = BBP.ptlBrushOrg;

    if (((((cxOut * 1000) + 500) / cxIn) > 667) &&
        ((((cyOut * 1000) + 500) / cyIn) > 667)) {

        AAHFlags |= AAHF_DO_FIXUPDIB;
    }

    if ((cxOut * cyOut) < (cxIn * cyIn)) {

        AAHFlags |= AAHF_SHRINKING;
        AAHFlags |= AAHF_DO_DST_CLR_MAPPING;

    } else {

        AAHFlags |= AAHF_DO_SRC_CLR_MAPPING;
    }

    if (cyIn == cyOut) {

        pAABBP->AAMaskCYFunc  = BltMask_CY;
        pAABBP->GetAVCYFunc   = BltAV_CY;
        pAABBP->AABuildCYFunc = BuildBltAAInfo;
        pAABBP->CYFuncMode    = AACYMODE_BLT;

    } else if (cyIn < cyOut) {

        pAABBP->AAMaskCYFunc  = ExpandMask_CY;
        pAABBP->GetAVCYFunc   = ExpandAV_CY;
        pAABBP->AABuildCYFunc = BuildExpandAAInfo;

        if (cxOut > cxIn) {

            if ((!(AAHFlags & AAHF_BBPF_AA_OFF))    &&
                ((cyIn * FAST_MAX_CY) >= cyOut)     &&
                ((cxIn * FAST_MAX_CX) >= cxOut)) {

                AAHFlags |= AAHF_FAST_EXP_AA;
            }

            pAABBP->CYFuncMode = AACYMODE_EXPAND_EXPCX;

        } else {

            pAABBP->CYFuncMode = AACYMODE_EXPAND;
        }

#if DBG
        if (!ExpExp) {

            pAABBP->CYFuncMode = AACYMODE_EXPAND;
        }
#endif

    } else {

        pAABBP->AAMaskCYFunc  = ShrinkMask_CY;
        pAABBP->GetAVCYFunc   = ShrinkAV_CY;
        pAABBP->AABuildCYFunc = BuildShrinkAAInfo;
        pAABBP->CYFuncMode    = ((cxOut < cxIn) && (!GrayFunc)) ?
                                    AACYMODE_SHRINK_SRKCX : AACYMODE_SHRINK;
#if DBG
        if (!SrkSrk) {

             pAABBP->CYFuncMode = AACYMODE_SHRINK;
        }
#endif
    }

    DBGP_IF(DBGP_FUNC, DBGP("\n+++++ AACYFuncMode = %ld"
            ARGDW(pAABBP->CYFuncMode)));

    if (cxIn == cxOut) {

        pAABBP->CXFuncMode    = AACXMODE_BLT;
        pAABBP->AAMaskCXFunc  = BltMask_CX;
        pAABBP->GetAVCXFunc   = BltAV_CX;
        pAABBP->AABuildCXFunc = BuildBltAAInfo;
        pAABBP->AACXFunc      = (GrayFunc) ? (AACXFUNC)GrayCopyDIB_CX :
                                             (AACXFUNC)CopyDIB_CX;

        DBGP_IF(DBGP_FUNC, DBGP("+++++ AACXFunc = CopyDIB_CX()"));

    } else if (cxIn < cxOut) {

        pAABBP->CXFuncMode    = AACXMODE_EXPAND;
        pAABBP->AAMaskCXFunc  = ExpandMask_CX;
        pAABBP->GetAVCXFunc   = ExpandAV_CX;
        pAABBP->AABuildCXFunc = BuildExpandAAInfo;
        pAABBP->AACXFunc      = (GrayFunc) ? (AACXFUNC)GrayExpandDIB_CX :
                                             (AACXFUNC)ExpandDIB_CX;

        DBGP_IF(DBGP_FUNC, DBGP("+++++ AACXFunc = ExpandDIB_CX()"));

    } else {

        pAABBP->CXFuncMode     = AACXMODE_SHRINK;
        pAABBP->AAMaskCXFunc   = ShrinkMask_CX;
        AAHFlags              |= AAHF_OR_AV;
        pAABBP->GetAVCXFunc    = ShrinkAV_CX;
        pAABBP->AABuildCXFunc  = BuildShrinkAAInfo;
        pAABBP->AACXFunc       = (GrayFunc) ? (AACXFUNC)GrayShrinkDIB_CX :
                                              (AACXFUNC)ShrinkDIB_CX;

        DBGP_IF(DBGP_FUNC, DBGP("+++++ AACXFunc = ShrinkDIB_CX()"));
    }

    if (BBP.Flags & BBPF_TILE_SRC) {

        pAABBP->CYFuncMode    = AACYMODE_TILE;
        pAABBP->AAMaskCXFunc  = BltMask_CX;
        pAABBP->AAMaskCYFunc  = BltMask_CY;
        pAABBP->GetAVCXFunc   = NULL;
        pAABBP->GetAVCYFunc   = TileAV_CY;
        pAABBP->AABuildCYFunc =
        pAABBP->AABuildCXFunc = BuildTileAAInfo;
        pAABBP->AACXFunc      = NULL;

        DBGP_IF(DBGP_FUNC, DBGP("+++ TILE: TileBlt_CY(), AACXFunc = NULL"));
    }

    pAABBP->AAHFlags  = AAHFlags;
    pAABBP->rclSrc    = BBP.rclSrc;
    pAABBP->ptlMask.x = BBP.ptlSrcMask.x - BBP.rclSrc.left;
    pAABBP->ptlMask.y = BBP.ptlSrcMask.y - BBP.rclSrc.top;
    rclSurf           = BBP.rclDest;

    if (BBP.Flags & BBPF_HAS_DEST_CLIPRECT) {

        if (!IntersectRECTL(&rclSurf, &BBP.rclClip)) {

            DBGP_IF(DBGP_AAHEADER,
                    DBGP("rclClip=(%ld, %ld)-(%ld, %ld)=%ldx%ld < SURF=(%ld, %ld)-(%ld, %ld)=%ldx%ld"
                        ARGDW(BBP.rclClip.left) ARGDW(BBP.rclClip.top)
                        ARGDW(BBP.rclClip.right) ARGDW(BBP.rclClip.bottom)
                        ARGDW(BBP.rclClip.right - BBP.rclClip.left)
                        ARGDW(BBP.rclClip.bottom - BBP.rclClip.top)
                        ARGDW(rclSurf.left) ARGDW(rclSurf.top)
                        ARGDW(rclSurf.right) ARGDW(rclSurf.bottom)
                        ARGDW(rclSurf.right - rclSurf.left)
                        ARGDW(rclSurf.bottom - rclSurf.top)));

            return(0);
        }
    }

    if (BBP.Flags & BBPF_HAS_BANDRECT) {

        ASSERT(BBP.rclBand.left >= 0);
        ASSERT(BBP.rclBand.top  >= 0);
        ASSERT(BBP.rclBand.right  > BBP.rclBand.left);
        ASSERT(BBP.rclBand.bottom > BBP.rclBand.top);

        if (!IntersectRECTL(&rclSurf, &BBP.rclBand)) {

            DBGP_IF(DBGP_AAHEADER,
                    DBGP("rclBand=(%ld, %ld)-(%ld, %ld)=%ldx%ld < SURF=(%ld, %ld)-(%ld, %ld)=%ldx%ld"
                        ARGDW(BBP.rclBand.left) ARGDW(BBP.rclBand.top)
                        ARGDW(BBP.rclBand.right) ARGDW(BBP.rclBand.bottom)
                        ARGDW(BBP.rclBand.right - BBP.rclBand.left)
                        ARGDW(BBP.rclBand.bottom - BBP.rclBand.top)
                        ARGDW(rclSurf.left) ARGDW(rclSurf.top)
                        ARGDW(rclSurf.right) ARGDW(rclSurf.bottom)
                        ARGDW(rclSurf.right - rclSurf.left)
                        ARGDW(rclSurf.bottom - rclSurf.top)));

            return(0);
        }

        //
        // 05-Aug-1998 Wed 19:38:56 updated  -by-  Daniel Chou (danielc)
        //  Fixed the banding problem when mirrored or upside down stretch
        //  The fixes is simple by offset all the Dest rects for the left/top
        //  of the band, and reset the cx/cy destination size according to the
        //  band size and then offset the brush origin according the the band's
        //  left/top position, after these all other codes should run the same
        //  excpet we do not need to check BBPF_HAS_BANDRECT at later time.
        //

        BBP.rclDest.left      -= BBP.rclBand.left;
        BBP.rclDest.right     -= BBP.rclBand.left;
        BBP.rclDest.top       -= BBP.rclBand.top;
        BBP.rclDest.bottom    -= BBP.rclBand.top;
        rclSurf.left          -= BBP.rclBand.left;
        rclSurf.right         -= BBP.rclBand.left;
        rclSurf.top           -= BBP.rclBand.top;
        rclSurf.bottom        -= BBP.rclBand.top;
        pAABBP->ptlBrushOrg.x -= BBP.rclBand.left;
        pAABBP->ptlBrushOrg.y -= BBP.rclBand.top;

        ASSERT((BBP.rclBand.right - BBP.rclBand.left) <= pDstSI->Width);
        ASSERT((BBP.rclBand.bottom - BBP.rclBand.top) <= pDstSI->Height);

        DBGP_IF(DBGP_AAHEADER,
                DBGP("BAND Output: Dest: %ld x %ld --> BAND: %ld x %ld"
                ARGDW(pDstSI->Width) ARGDW(pDstSI->Height)
                ARGDW(BBP.rclBand.right - BBP.rclBand.left)
                ARGDW(BBP.rclBand.bottom - BBP.rclBand.top)));
    }

    rclPhyDst.left   =
    rclPhyDst.top    = 0;
    rclPhyDst.right  = pDstSI->Width;
    rclPhyDst.bottom = pDstSI->Height;

    if (!IntersectRECTL(&rclSurf, &rclPhyDst)) {

        DBGP_IF(DBGP_AAHEADER,
                DBGP("PhyDest=(%ld, %ld)-(%ld, %ld)=%ldx%ld < SURF=(%ld, %ld)-(%ld, %ld)=%ldx%ld"
                    ARGDW(rclPhyDst.left) ARGDW(rclPhyDst.top)
                    ARGDW(rclPhyDst.right) ARGDW(rclPhyDst.bottom)
                    ARGDW(rclPhyDst.right - rclPhyDst.left)
                    ARGDW(rclPhyDst.bottom - rclPhyDst.top)
                    ARGDW(rclSurf.left) ARGDW(rclSurf.top)
                    ARGDW(rclSurf.right) ARGDW(rclSurf.bottom)
                    ARGDW(rclSurf.right - rclSurf.left)
                    ARGDW(rclSurf.bottom - rclSurf.top)));

        return(0);
    }

    //
    // 10-Aug-1998 Mon 16:09:13 updated  -by-  Daniel Chou (danielc)
    //  flipping X computation:  When we flip in X direction, we will first
    //  compute the destination original rectangle and final destination
    //  rectangle by compute its offset from right hand side so later at
    //  stretch computation is easier, after finished stretch computation
    //  (BuildExpand or BuildShrink) we will flip the rectangle back by
    //  substract it from ptlFlip.x.
    //

    if (AAHFlags & AAHF_FLIP_X) {

        DBGP_IF(DBGP_AAHEADER,
                DBGP("*** FLIP X: rclDstOrg=(%6ld - %6ld)=%6ld"
                ARGDW(BBP.rclDest.left) ARGDW(BBP.rclDest.right)
                ARGDW(BBP.rclDest.right - BBP.rclDest.left)));

        DBGP_IF(DBGP_AAHEADER,
                DBGP("*** FLIP X: rclDst=(%6ld -  %6ld)=%6ld, ptlFlip.x=%ld"
                ARGDW(rclSurf.left) ARGDW(rclSurf.right)
                ARGDW(rclSurf.right - rclSurf.left)
                ARGDW(BBP.rclDest.right)));

        Tmp                = rclSurf.right - rclSurf.left;
        rclSurf.left       = BBP.rclDest.right - rclSurf.right;
        rclSurf.right      = rclSurf.left + Tmp;
        pAABBP->ptlFlip.x  = BBP.rclDest.right;
        BBP.rclDest.right -= BBP.rclDest.left;
        BBP.rclDest.left   = 0;
    }

    //
    // 10-Aug-1998 Mon 16:09:13 updated  -by-  Daniel Chou (danielc)
    //  flipping Y computation:  When we flip in Y direction, we will first
    //  compute the destination original rectangle and final destination
    //  rectangle by compute its offset from bottom hand side so later at
    //  stretch computation is easier, after finished stretch computation
    //  (BuildExpand or BuildShrink) we will flip the rectangle back by
    //  substract it from ptlFlip.y.
    //

    if (AAHFlags & AAHF_FLIP_Y) {

        DBGP_IF(DBGP_AAHEADER,
                DBGP("*** FLIP Y: rclDstOrg=(%6ld - %6ld)=%6ld"
                ARGDW(BBP.rclDest.top) ARGDW(BBP.rclDest.bottom)
                ARGDW(BBP.rclDest.bottom - BBP.rclDest.top)));

        DBGP_IF(DBGP_AAHEADER,
                DBGP("*** FLIP Y: rclDst=(%6ld - %6ld)=%6ld, ptlFlip.y=%ld"
                ARGDW(rclSurf.top) ARGDW(rclSurf.bottom)
                ARGDW(rclSurf.bottom - rclSurf.top)
                ARGDW(BBP.rclDest.bottom)));

        Tmp                 = rclSurf.bottom - rclSurf.top;
        rclSurf.top         = BBP.rclDest.bottom - rclSurf.bottom;
        rclSurf.bottom      = rclSurf.top + Tmp;
        pAABBP->ptlFlip.y   = BBP.rclDest.bottom;
        BBP.rclDest.bottom -= BBP.rclDest.top;
        BBP.rclDest.top     = 0;
    }

    pAABBP->rclDstOrg = BBP.rclDest;
    pAABBP->rclDst    = rclSurf;

    DBGP_IF(DBGP_AAHEADER,
            DBGP("Output: rclSrc=(%6ld, %6ld)-(%6ld, %6ld)=%6ld x %6ld"
                ARGDW(pAABBP->rclSrc.left) ARGDW(pAABBP->rclSrc.top)
                ARGDW(pAABBP->rclSrc.right) ARGDW(pAABBP->rclSrc.bottom)
                ARGDW(pAABBP->rclSrc.right - pAABBP->rclSrc.left)
                ARGDW(pAABBP->rclSrc.bottom - pAABBP->rclSrc.top)));

    DBGP_IF(DBGP_AAHEADER,
            DBGP("Output: rclDstOrg=(%6ld, %6ld)-(%6ld, %6ld)=%6ld x %6ld"
            ARGDW(pAABBP->rclDstOrg.left) ARGDW(pAABBP->rclDstOrg.top)
            ARGDW(pAABBP->rclDstOrg.right) ARGDW(pAABBP->rclDstOrg.bottom)
            ARGDW(pAABBP->rclDstOrg.right - pAABBP->rclDstOrg.left)
            ARGDW(pAABBP->rclDstOrg.bottom - pAABBP->rclDstOrg.top)));

    DBGP_IF(DBGP_AAHEADER,
            DBGP("Output:    rclDst=(%6ld, %6ld)-(%6ld, %6ld)=%6ld x %6ld"
            ARGDW(pAABBP->rclDst.left) ARGDW(pAABBP->rclDst.top)
            ARGDW(pAABBP->rclDst.right) ARGDW(pAABBP->rclDst.bottom)
            ARGDW(pAABBP->rclDst.right - pAABBP->rclDst.left)
            ARGDW(pAABBP->rclDst.bottom - pAABBP->rclDst.top)));

    DBGP_IF(DBGP_AAHEADER,
            DBGP("Output:    ptlBrushOrg=(%6ld, %6ld)"
            ARGDW(pAABBP->ptlBrushOrg.x) ARGDW(pAABBP->ptlBrushOrg.y)));

    DBGP_IF(DBGP_AAHEADER,
            DBGP("Output:    ptlSrcMask=(%6ld, %6ld)"
            ARGDW(pAABBP->ptlMask.x) ARGDW(pAABBP->ptlMask.y)));

    return(1);

}


#if DBG
extern INT cCXMask;


LPSTR
GetAACXFuncName(
    AACXFUNC    AACXFunc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    06-Jan-1999 Wed 19:11:27 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    if (AACXFunc == (AACXFUNC)RepDIB_CX) {

        return("RepDIB_CX");

    } else if (AACXFunc == (AACXFUNC)SkipDIB_CX) {

        return("SkipDIB_CX");

    } else if (AACXFunc == (AACXFUNC)CopyDIB_CX) {

        return("CopyDIB_CX");

    } else if (AACXFunc == (AACXFUNC)ShrinkDIB_CX) {

        return("ShrinkDIB_CX");

    } else if (AACXFunc == (AACXFUNC)ExpandDIB_CX) {

        return("ExpandDIB_CX");

    } else if (AACXFunc == (AACXFUNC)GrayRepDIB_CX) {

        return("GrayRepDIB_CX");

    } else if (AACXFunc == (AACXFUNC)GraySkipDIB_CX) {

        return("GraySkipDIB_CX");

    } else if (AACXFunc == (AACXFUNC)GrayCopyDIB_CXGray) {

        return("GrayCopyDIB_CXGray");

    } else if (AACXFunc == (AACXFUNC)GrayCopyDIB_CX) {

        return("GrayCopyDIB_CX");

    } else if (AACXFunc == (AACXFUNC)GrayExpandDIB_CX) {

        return("GrayExpandDIB_CX");

    } else if (AACXFunc == (AACXFUNC)GrayShrinkDIB_CX) {

        return("GrayShrinkDIB_CX");

    } else {

        DBGP("ERROR: Unknown AACXFUNC=%p, Function" ARGPTR(AACXFunc));

        return("Unknown AACXFUNC");
    }

}



LPSTR
GetAACYFuncName(
    AACYFUNC    AACYFunc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    06-Jan-1999 Wed 19:11:27 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{

    if (AACYFunc == (AACYFUNC)TileDIB_CY) {

        return("TileDIB_CY");

    } else if (AACYFunc == (AACYFUNC)RepDIB_CY) {

        return("RepDIB_CY");

    } else if (AACYFunc == (AACYFUNC)FastExpAA_CY) {

        return("FastExpAA_CY");

    } else if (AACYFunc == (AACYFUNC)SkipDIB_CY) {

        return("SkipDIB_CY");

    } else if (AACYFunc == (AACYFUNC)BltDIB_CY) {

        return("BltDIB_CY");

    } else if (AACYFunc == (AACYFUNC)ShrinkDIB_CY) {

        return("ShrinkDIB_CY");

    } else if (AACYFunc == (AACYFUNC)ShrinkDIB_CY_SrkCX) {

        return("ShrinkDIB_CY_SrkCX");

    } else if (AACYFunc == (AACYFUNC)ExpandDIB_CY_ExpCX) {

        return("ExpandDIB_CY_ExpCX");

    } else if (AACYFunc == (AACYFUNC)ExpandDIB_CY) {

        return("ExpandDIB_CY");

    } else if (AACYFunc == (AACYFUNC)GrayExpandDIB_CY_ExpCX) {

        return("GrayExpandDIB_CY_ExpCX");

    } else if (AACYFunc == (AACYFUNC)GrayExpandDIB_CY) {

        return("GrayExpandDIB_CY");

    } else if (AACYFunc == (AACYFUNC)GrayShrinkDIB_CY) {

        return("GrayShrinkDIB_CY");

    } else {

        DBGP("ERROR: Unknown AACYFUNC=%p, Function" ARGPTR(AACYFunc));

        return("Unknown AACYFUNC");
    }
}


#endif



LONG
HTENTRY
SetupAAHeader(
    PHALFTONERENDER     pHR,
    PDEVICECOLORINFO    pDCI,
    PAAHEADER           pAAHdr,
    AACYFUNC            *pAACYFunc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    03-Apr-1998 Fri 04:27:16 created  -by-  Daniel Chou (danielc)


Revision History:

    07-Aug-1998 Fri 19:28:21 updated  -by-  Daniel Chou (danielc)
        Fix the mirror/upside-down banding problems, the problem is when we
        flip the destination original size rectangle we did not flip the
        the real destination rectangle, this cause the the offset getting too
        big and its pointer offset passed the end of the bitmap, it also
        has problem that when we did not flip the destination rectangle
        the wrong portion of the bitmap will be in the band.

--*/

{
    PAAINFO         pAAInfoCX;
    PAAINFO         pAAInfoCY;
    PBITBLTPARAMS   pBBP;
    PHTSURFACEINFO  pSrcSI;
    PHTSURFACEINFO  pDstSI;
    PHTSURFACEINFO  pMaskSI;
    LPBYTE          pbExtra;
    AACYFUNC        AACYFunc;
    AABBP           aabbp;
    LONG            iFree;
    LONG            cbFreeBuf;
    LONG            Top;
    LONG            Bottom;
    LONG            cyNext;
    LONG            cxSize;
    LONG            cbMaskSrc;
    LONG            cIn;
    LONG            cOut;
    LONG            cbCYExtra;
    LONG            cbCXExtra;
    LONG            cbInBuf;
    LONG            cbFUDI;
    LONG            cbVGA256Xlate;
    LONG            cbOutBuf;
    LONG            cbAlphaBuf;
    LONG            cbIdxBGR;
    LONG            Result;
    LONG            cbSrcPel;
    DWORD           PrimAdjFlags;
    UINT            DstSurfFmt;


    pBBP         = pHR->pBitbltParams;
    pSrcSI       = pHR->pSrcSI;
    pDstSI       = pHR->pDestSI;
    pMaskSI      = pHR->pSrcMaskSI;
    DstSurfFmt   = (UINT)pDstSI->SurfaceFormat;
    PrimAdjFlags = (DWORD)pHR->pDevClrAdj->PrimAdj.Flags;
    cbSrcPel     = (pHR->pDevClrAdj->DMI.Flags & DMIF_GRAY) ? sizeof(BYTE) :
                                                              sizeof(BGR8);
    DBGP_IF(DBGP_AAHEADER,
            DBGP("\nSrcSI=%ld x %ld [Format=%ld], DestSI=%ld x %ld [Format=%ld]"
                ARGDW(pSrcSI->Width) ARGDW(pSrcSI->Height)
                ARGDW(pSrcSI->SurfaceFormat)
                ARGDW(pDstSI->Width) ARGDW(pDstSI->Height)
                ARGDW(pDstSI->SurfaceFormat)));

    aabbp.AAHFlags = (PrimAdjFlags & DCA_BBPF_AA_OFF) ? AAHF_BBPF_AA_OFF : 0;

    if (pBBP->Flags & BBPF_TILE_SRC) {

        aabbp.AAHFlags |= AAHF_TILE_SRC;
        aabbp.AAHFlags |= AAHF_BBPF_AA_OFF;
    }

    if (ComputeAABBP(pBBP, pDstSI, &aabbp, cbSrcPel == sizeof(BYTE)) <= 0) {

        return(0);
    }

    cbCXExtra = sizeof(RGBLUTAA);

    if (PrimAdjFlags & DCA_ALPHA_BLEND) {

        aabbp.AAHFlags |= AAHF_ALPHA_BLEND;

        if (PrimAdjFlags & DCA_CONST_ALPHA) {

            aabbp.AAHFlags |= AAHF_CONST_ALPHA;

            cbCXExtra += (AB_BGR_CA_SIZE + AB_CONST_SIZE);

        } else {

            if (PrimAdjFlags & DCA_AB_PREMUL_SRC) {

                //
                // Set the flag so we will try to compute premul's orginal src
                //

                pAAHdr->SrcSurfInfo.Flags |= AASIF_AB_PREMUL_SRC;
            }

            if (PrimAdjFlags & DCA_AB_DEST) {

                aabbp.AAHFlags |= AAHF_AB_DEST;
            }

            cbCXExtra += AB_BGR_SIZE;
        }
    }

    if (PrimAdjFlags & DCA_NO_MAPPING_TABLE) {

        aabbp.AAHFlags &= ~AAHF_DO_CLR_MAPPING;
    }

    ALIGN_MEM(cbCXExtra, cbCXExtra);

    DBGP_IF(DBGP_LUT_MAP,
            DBGP("CXExtra=%ld (RGBLUTAA) + 0 (Mapping=%hs) = %ld"
                    ARGDW(sizeof(RGBLUTAA))
                    ARGPTR((aabbp.AAHFlags & AAHF_DO_SRC_CLR_MAPPING) ?
                            "SRC" : "DST")
                    ARGDW(sizeof(RGBLUTAA) + 0)));

    //
    // This flag is set when reading the source bitmap, so the pointer will
    // advanced to next scanline, this flag will not set for the destiantion
    // since when blending and we reading from destination, we do not want to
    // advanced the destination pointer because it will be done during output
    //

    ComputeInputColorInfo((LPBYTE)pSrcSI->pColorTriad->pColorTable,
                          (UINT)pSrcSI->pColorTriad->BytesPerEntry,
                          (UINT)pSrcSI->pColorTriad->PrimaryOrder,
                          &(pHR->BFInfo),
                          &(pAAHdr->SrcSurfInfo));

    pAAHdr->SrcSurfInfo.Flags |= AASIF_INC_PB |
                                 ((cbSrcPel == sizeof(BYTE)) ? AASIF_GRAY : 0);


    if (PrimAdjFlags & DCA_USE_ADDITIVE_PRIMS) {

        aabbp.AAHFlags |= AAHF_ADDITIVE;
    }

    if (pBBP->Flags & BBPF_TILE_SRC) {

        aabbp.AAHFlags &= ~AAHF_DO_FIXUPDIB;
    }

    if (aabbp.AAHFlags & AAHF_BBPF_AA_OFF) {

        aabbp.AAHFlags &= ~AAHF_DO_FIXUPDIB;
    }

    if (aabbp.AAHFlags & AAHF_DO_FIXUPDIB) {

        CheckBMPNeedFixup(pDCI, pAAHdr, pSrcSI, &aabbp);

        if (aabbp.AAHFlags & AAHF_SHRINKING) {

            if (PrimAdjFlags & DCA_BBPF_AA_OFF) {

                aabbp.AAHFlags |= AAHF_BBPF_AA_OFF;

            } else {

                aabbp.AAHFlags &= ~AAHF_BBPF_AA_OFF;
            }
        }

    }

    if (aabbp.AAHFlags & AAHF_BBPF_AA_OFF) {

        aabbp.AAHFlags &= ~AAHF_FAST_EXP_AA;
    }

    if (pMaskSI) {

        aabbp.AAHFlags |= AAHF_HAS_MASK;
    }

    if (!(pAAInfoCX = aabbp.AABuildCXFunc(pDCI,
                                          aabbp.AAHFlags,
                                          &aabbp.rclSrc.left,
                                          &aabbp.rclSrc.right,
                                          pSrcSI->Width,
                                          aabbp.rclDstOrg.left,
                                          aabbp.rclDstOrg.right,
                                          &aabbp.rclDst.left,
                                          &aabbp.rclDst.right,
                                          cbCXExtra))) {

        //
        // Remove cbCXExtra (use pDCI's rgbLUT and BGRMapTable, AlphaBlendBGR)
        //

        if (!(pAAInfoCX = aabbp.AABuildCXFunc(pDCI,
                                              aabbp.AAHFlags,
                                              &aabbp.rclSrc.left,
                                              &aabbp.rclSrc.right,
                                              pSrcSI->Width,
                                              aabbp.rclDstOrg.left,
                                              aabbp.rclDstOrg.right,
                                              &aabbp.rclDst.left,
                                              &aabbp.rclDst.right,
                                              cbCXExtra = 0))) {

            return(HTERR_INSUFFICIENT_MEMORY);
        }
    }

    //  Bug 27036:  reject empty rectangles
    if(!pAAInfoCX->cIn  ||  !pAAInfoCX->cOut)
    {
#if 0
        LONG crash = 1 ;   // empty src or dest rectangle!
        crash /= (pAAInfoCX->cIn * pAAInfoCX->cOut);            //  delete when debugging is complete.
        if(crash)
            return 0 ;
#endif
        HTFreeMem(pAAInfoCX);
        return 0 ;
    }

    if (cbCXExtra) {

        pAAHdr->prgbLUT  = (PRGBLUTAA)(pbExtra = pAAInfoCX->pbExtra);
        pbExtra         += sizeof(RGBLUTAA);

        ASSERT_MEM_ALIGN(pAAHdr->prgbLUT, sizeof(LONG));

        if (aabbp.AAHFlags & AAHF_ALPHA_BLEND) {

            pAAHdr->pAlphaBlendBGR = (LPBYTE)pbExtra;

            if (PrimAdjFlags & DCA_CONST_ALPHA) {

                pbExtra += (AB_BGR_CA_SIZE + AB_CONST_SIZE);

            } else {

                pbExtra += AB_BGR_SIZE;
            }
        }

    } else {

        ASSERT_MEM_ALIGN(&pDCI->rgbLUT, sizeof(LONG));

        aabbp.AAHFlags  |= AAHF_USE_DCI_DATA;
        pAAHdr->prgbLUT  = &pDCI->rgbLUT;

        if (aabbp.AAHFlags & AAHF_ALPHA_BLEND) {

            pAAHdr->pAlphaBlendBGR = pDCI->pAlphaBlendBGR;

            if (PrimAdjFlags & DCA_CONST_ALPHA) {

                pAAHdr->pAlphaBlendBGR += AB_BGR_SIZE;
            }
        }
    }

    pAAHdr->pIdxBGR = pAAHdr->prgbLUT->IdxBGR;

    if (aabbp.AAHFlags & AAHF_FLIP_X) {

        DBGP_IF(DBGP_AAHEADER,
            DBGP("X Dst=(%ld - %ld)=%ld change it to (%ld - %ld), ptlFlip.x=%ld"
                ARGDW(aabbp.rclDst.left) ARGDW(aabbp.rclDst.right)
                ARGDW(aabbp.rclDst.right - aabbp.rclDst.left)
                ARGDW(aabbp.ptlFlip.x - aabbp.rclDst.left - 1)
                ARGDW(aabbp.ptlFlip.x - aabbp.rclDst.right - 1)
                ARGDW(aabbp.ptlFlip.x)));

        aabbp.rclDst.left  = aabbp.ptlFlip.x - aabbp.rclDst.left - 1;
        aabbp.rclDst.right = aabbp.ptlFlip.x - aabbp.rclDst.right - 1;
    }

    //
    // cbCYExtra is for the input scan line, add one because we want to
    // run it in DWORD mode so we need at least an extra byte at end
    // of input buffer
    //

    cIn       = pAAInfoCX->cIn;
    cOut      = pAAInfoCX->cOut;
    cbInBuf   = cIn + 6;          // left extra=3, right extra=3
    cbFreeBuf =
    cbCYExtra = 0;
    AACYFunc  = NULL;

    if (aabbp.AAHFlags & AAHF_BBPF_AA_OFF) {

        switch (aabbp.CYFuncMode) {

        case AACYMODE_SHRINK:
        case AACYMODE_SHRINK_SRKCX:

            AACYFunc = (AACYFUNC)SkipDIB_CY;
            break;

        case AACYMODE_EXPAND:
        case AACYMODE_EXPAND_EXPCX:

            cbCYExtra = (aabbp.AAHFlags & AAHF_ALPHA_BLEND) ?
                                    (sizeof(BGR8) * (cOut + 6)) : 0;

            AACYFunc = (AACYFUNC)RepDIB_CY;
            break;

        case AACYMODE_BLT:

            AACYFunc = (AACYFUNC)BltDIB_CY;
            break;
        }

        if (AACYFunc) {

            switch (aabbp.CXFuncMode) {

            case AACXMODE_BLT:

                aabbp.AACXFunc = (cbSrcPel == sizeof(BYTE)) ?
                                        (AACXFUNC)GrayCopyDIB_CXGray :
                                        (AACXFUNC)CopyDIB_CX;
                break;

            case AACXMODE_SHRINK:

                aabbp.AACXFunc = (cbSrcPel == sizeof(BYTE)) ?
                                        (AACXFUNC)GraySkipDIB_CX :
                                        (AACXFUNC)SkipDIB_CX;
                break;

            case AACXMODE_EXPAND:

                aabbp.AACXFunc = (cbSrcPel == sizeof(BYTE)) ?
                                        (AACXFUNC)GrayRepDIB_CX :
                                        (AACXFUNC)RepDIB_CX;
                break;
            }

            aabbp.CYFuncMode = AACYMODE_NONE;
        }
    }

    switch (aabbp.CYFuncMode) {

    case AACYMODE_TILE:

        AACYFunc  = TileDIB_CY;
        cbCYExtra = (cbSrcPel == sizeof(BYTE)) ? (cIn * sizeof(WORD)) : 0;
        break;

    case AACYMODE_BLT:

        AACYFunc = (AACYFUNC)BltDIB_CY;
        break;

    case AACYMODE_SHRINK:

        //
        // We need to make sure Off555Buf does not changed
        //

        cbFreeBuf = (sizeof(LONG) * 256 * 2);

        if (cbSrcPel == sizeof(BYTE)) {

            AACYFunc  = GrayShrinkDIB_CY;
            cbCYExtra = (sizeof(LONG) * cOut * 3) + cbFreeBuf +
                        ((cOut + 6) * cbSrcPel);

        } else {

            AACYFunc  = ShrinkDIB_CY;
            cbCYExtra = (sizeof(RGBL) * cIn * 3) + cbFreeBuf +
                        (cbInBuf * cbSrcPel);
        }

        break;

    case AACYMODE_SHRINK_SRKCX:

        AACYFunc  = ShrinkDIB_CY_SrkCX;
        cbFreeBuf = (sizeof(LONG) * 256 * 2);
        cbCYExtra = (sizeof(RGBL) * (pAAInfoCX->cAADone + 2) * 3) + cbFreeBuf;
        break;

    case AACYMODE_EXPAND:

        AACYFunc  = (cbSrcPel == sizeof(BYTE)) ? GrayExpandDIB_CY :
                                                 ExpandDIB_CY;
        cbCYExtra = (cbFreeBuf = (sizeof(LONG) * 256 * 4)) +
                    ((cOut + 6) * cbSrcPel * 6);
        break;

    case AACYMODE_EXPAND_EXPCX:

        //
        // This function use IputBufBeg to sharpening the input scanline so we
        // need 4 extra BGR8 for running the expand pre-read
        //

        if (aabbp.AAHFlags & AAHF_FAST_EXP_AA) {

            DBGP_IF(DBGP_AAHEADER, DBGP("Use FastExpAA_CY functions"));

            cbCYExtra = (cbInBuf * 5 * cbSrcPel);
            AACYFunc  = (AACYFUNC)FastExpAA_CY;

        } else {

            AACYFunc  = (cbSrcPel == sizeof(BYTE)) ? GrayExpandDIB_CY_ExpCX :
                                                     ExpandDIB_CY_ExpCX;
            cbCYExtra = (cbFreeBuf = (sizeof(LONG) * 256 * 4)) +
                        (cbInBuf * cbSrcPel * 3) + ((cOut + 6) * cbSrcPel * 4);
        }

        break;
    }

    cbAlphaBuf                = (aabbp.AAHFlags & AAHF_ALPHA_BLEND) ? cOut : 0;
    pAAHdr->DstSurfInfo.Flags = (cbSrcPel == sizeof(BYTE)) ? AASIF_GRAY : 0;
    pAAHdr->DstSurfInfo.cbCX  = cbAlphaBuf * cbSrcPel;

    ALIGN_MEM(cbAlphaBuf, (cbAlphaBuf + 2 + 6) * cbSrcPel);
    ALIGN_MEM(cbCYExtra, cbCYExtra);

    //
    // cbInBuf is for the input scan line of EXPAND/SHRINK mode, add one
    // because we want to run it in DWORD mode so we need at least an extra
    // byte at end of input buffer
    //
    // 26-Jun-1998 Fri 16:03:26 updated  -by-  Daniel Chou (danielc)
    //  The cbOutBuf is used only when we flipping in X direction, this is
    //  needed since the input/output buffer may collide into each other
    //

    ALIGN_MEM(cbInBuf,  (cbInBuf + 2) * cbSrcPel);
    ALIGN_MEM(cbOutBuf, (cOut + (FAST_MAX_CX * 2)) * sizeof(BGRF));

    cbMaskSrc = (aabbp.AAHFlags & AAHF_HAS_MASK) ?
                        (ComputeBytesPerScanLine(BMF_1BPP, 4, cIn) + 4) : 0;
    cbMaskSrc = _ALIGN_MEM(cbMaskSrc);

    if (cbInBuf < cbAlphaBuf) {

        cbInBuf = cbAlphaBuf;
    }

    if ((aabbp.AAHFlags & (AAHF_ALPHA_BLEND | AAHF_CONST_ALPHA)) ==
                                                            AAHF_ALPHA_BLEND) {

        ALIGN_MEM(cbAlphaBuf, cOut);

    } else {

        cbAlphaBuf = 0;
    }

    DBGP_IF(DBGP_FIXUPDIB,
            DBGP("** Allocate cIn=%ld, cOut=%ld, cbInBuf=%ld, cbOutBuf=%ld, cbMaskSrc=%ld"
                ARGDW(cIn) ARGDW(cOut) ARGDW(cbInBuf) ARGDW(cbOutBuf)
                ARGDW(cbMaskSrc)));


    if ((DstSurfFmt == BMF_8BPP_VGA256) && (pHR->pXlate8BPP)) {

        ALIGN_MEM(cbVGA256Xlate, SIZE_XLATE_666);

        DBGP_IF((DBGP_AAHTPAT | DBGP_AAHT_MEM),
                DBGP("Allocate %ld bytes of Xlate8BPP" ARGDW(cbVGA256Xlate)));

    } else {

        cbVGA256Xlate = 0;
    }

    if (aabbp.AAHFlags & AAHF_DO_FIXUPDIB) {

        ALIGN_MEM(cbFUDI, (cIn + 4) * cbSrcPel);

    } else {

        cbFUDI = 0;
    }

    if ((pAAHdr->SrcSurfInfo.Flags & AASIF_GRAY)                    &&
        (pHR->BFInfo.Flags & BFIF_RGB_888)                          &&
        (pAAHdr->SrcSurfInfo.AABFData.Flags & AABF_MASK_IS_ORDER)   &&
        (pHR->BFInfo.RGBOrder.Index != PRIMARY_ORDER_BGR)) {

        //
        // This is for mapping >= 16bpp source's IdxBGR to gray, when mapping
        // to gray we will make IdxBGR to a correct source order so that it
        // will optimized the source input function speed
        //
        // The AABF_MASK_IS_ORDER indicate the source is 8-bits each of Red,
        // green and blue and it is only occuply lower 24-bits of either
        // a 24-bits or a 32-bits data
        //

        ALIGN_MEM(cbIdxBGR, sizeof(LONG) * 256 * 3);

        DBGP_IF(DBGP_AAHEADER,
                DBGP("Allocate gray non 24bits BGR [%ld] IDXBGR of %ld bytes"
                        ARGDW(pHR->BFInfo.RGBOrder.Index) ARGDW(cbIdxBGR)));

    } else {

        cbIdxBGR = 0;
    }

    if (pAAInfoCY = aabbp.AABuildCYFunc(pDCI,
                                        aabbp.AAHFlags,
                                        &aabbp.rclSrc.top,
                                        &aabbp.rclSrc.bottom,
                                        pSrcSI->Height,
                                        aabbp.rclDstOrg.top,
                                        aabbp.rclDstOrg.bottom,
                                        &aabbp.rclDst.top,
                                        &aabbp.rclDst.bottom,
                                        cbInBuf + cbOutBuf + cbMaskSrc +
                                            (cbFUDI * 6) + cbAlphaBuf +
                                            cbIdxBGR +
                                            cbVGA256Xlate + cbCYExtra))
    {
        //  Bug 27036:  reject empty rectangles
        if(!pAAInfoCY->cIn  ||  !pAAInfoCY->cOut)
        {
#if 0
            LONG crash = 1 ;   // empty src or dest rectangle!
            crash /= (pAAInfoCY->cIn * pAAInfoCY->cOut);            //  delete when debugging is complete.
            if(crash)
                return 0 ;
#endif
            HTFreeMem(pAAInfoCX);
            HTFreeMem(pAAInfoCY);
            return 0 ;
        }


        pbExtra                   = pAAInfoCY->pbExtra + cbCYExtra;
        pAAHdr->Flags             = aabbp.AAHFlags;
        pAAHdr->SrcSurfInfo.cbCX  = cbSrcPel * cIn;
        pAAHdr->pInputBeg         = (PBGR8)pbExtra;
        pbExtra                  += cbInBuf;

        if (cbAlphaBuf) {

            //
            // 04-Aug-2000 Fri 10:31:45 updated  -by-  Daniel Chou (danielc)
            //  Since cbAlphaBuf is Memoey Aliged Adjusted, we want the
            //  pSrcAVEnd to be at exactly count of cOut not cbAlphaBuf
            //

            pAAHdr->pSrcAV     =
            pAAHdr->pSrcAVBeg  = (LPBYTE)pbExtra;
            pAAHdr->pSrcAVEnd  = (LPBYTE)pbExtra + cOut;
            pbExtra           += cbAlphaBuf;
            pAAHdr->SrcAVInc   = sizeof(BYTE);
        }

        if (cbFUDI) {

            pAAHdr->pbFixupDIB = (LPBYTE)pbExtra;
            pAAHdr->FUDI.cbbgr = (DWORD)cbFUDI;

            for (Top = 0; Top < 6; Top++) {

                pAAHdr->FUDI.prgbD[Top]  = (PBGR8)pbExtra;
                pbExtra                 += cbFUDI;
            }
        }

        if (cbVGA256Xlate) {

            pAAHdr->pXlate8BPP  = pbExtra;
            pbExtra            += cbVGA256Xlate;
        }

        if (cbMaskSrc) {

            pAAHdr->pMaskSrc  = pbExtra;
            pbExtra          += cbMaskSrc;
        }

        if (cbIdxBGR) {

            //
            // The pIdxBGR is a local version that will be later re-arranged
            // from pAAHdr->pIdxBGR to correct source byte order in
            // SetGrayColorTable() function
            //

            pAAHdr->SrcSurfInfo.pIdxBGR  = (PLONG)pbExtra;
            pbExtra                     += cbIdxBGR;

        } else {

            pAAHdr->SrcSurfInfo.pIdxBGR = pAAHdr->pIdxBGR;
        }

        DBGP_IF(DBGP_AAHEADER,
                DBGP("cbInBuf=%ld, %p-%p" ARGDW(cbInBuf)
                        ARGPTR(pAAHdr->pInputBeg)
                        ARGPTR((LPBYTE)pAAHdr->pInputBeg + cbInBuf)));

        //
        // FAST_MAX_CX are added to both end of AABuf, this is needed when
        // we want to process the output fast, since we may need to extended
        // the computation to the neighbor pixels
        //

        pAAHdr->pOutputBeg  =
        pAAHdr->pRealOutBeg =
        pAAHdr->pAABufBeg   = (PBGRF)pbExtra + FAST_MAX_CX;
        pAAHdr->pRealOutEnd =
        pAAHdr->pOutputEnd  = pAAHdr->pAABufBeg + cOut;
        pAAHdr->pAABufEnd   = pAAHdr->pOutputEnd;

        //
        // Set the BGRF's Flags to 0xFF first, the 0xFF indicate that this
        // pixel need to be output (masked).
        //

        FillMemory((LPBYTE)pAAHdr->pOutputBeg,
                   (LPBYTE)pAAHdr->pOutputEnd - (LPBYTE)pAAHdr->pOutputBeg,
                   PBGRF_MASK_FLAG);

        //
        // We mirror the image by composed the source the the AABuf in
        // reverse way.  Reading the source from left to right but when
        // composed the source buffer (AABuf) we put it from right to left
        //

        if (aabbp.rclDst.left > aabbp.rclDst.right) {

            XCHG(aabbp.rclDst.left, aabbp.rclDst.right, Result);

            pAAHdr->pAABufBeg   = pAAHdr->pOutputEnd - 1;
            pAAHdr->pAABufEnd   = pAAHdr->pOutputBeg - 1;
            pAAHdr->AABufInc    = -(LONG)sizeof(BGRF);
            pAAHdr->pSrcAVBeg   = pAAHdr->pSrcAVEnd - 1;
            pAAHdr->pSrcAVEnd   = pAAHdr->pSrcAV - 1;
            pAAHdr->SrcAVInc    = -pAAHdr->SrcAVInc;

        } else {

            pAAHdr->AABufInc  = (LONG)sizeof(BGRF);
        }

        pAAHdr->ptlBrushOrg.x = aabbp.rclDst.left - aabbp.ptlBrushOrg.x;

        DBGP_IF(DBGP_AAHEADER,
                DBGP("pInput=%p-%p (%ld), pAABuf=%p-%p (%ld), pOutput=%p-%p, DstLeft=%ld"
                    ARGPTR(pAAHdr->pInputBeg)
                    ARGPTR((LPBYTE)pAAHdr->pInputBeg +
                           pAAHdr->SrcSurfInfo.cbCX)
                    ARGL(pAAHdr->SrcSurfInfo.cbCX)
                    ARGPTR(pAAHdr->pAABufBeg) ARGPTR(pAAHdr->pAABufEnd)
                    ARGDW(pAAHdr->AABufInc)
                    ARGPTR(pAAHdr->pOutputBeg) ARGPTR(pAAHdr->pOutputEnd)
                    ARGDW(aabbp.rclDst.left)));


        if (aabbp.AAHFlags & AAHF_FLIP_Y) {

            DBGP_IF(DBGP_AAHEADER,
                    DBGP("Y Dst=(%ld - %ld)=%ld change it to (%ld - %ld), ptlFlip.y=%ld"
                        ARGDW(aabbp.rclDst.top) ARGDW(aabbp.rclDst.bottom)
                        ARGDW(aabbp.rclDst.bottom - aabbp.rclDst.top)
                        ARGDW(aabbp.ptlFlip.y - aabbp.rclDst.top - 1)
                        ARGDW(aabbp.ptlFlip.y - aabbp.rclDst.bottom - 1)
                        ARGDW(aabbp.ptlFlip.y)));

            aabbp.rclDst.top    = aabbp.ptlFlip.y - aabbp.rclDst.top - 1;
            aabbp.rclDst.bottom = aabbp.ptlFlip.y - aabbp.rclDst.bottom - 1;
        }

        pAAHdr->ptlBrushOrg.y = aabbp.rclDst.top - aabbp.ptlBrushOrg.y;

        DBGP_IF(DBGP_AAHEADER,
                DBGP("BrushOrg=(%ld, %ld) ---> (%ld, %ld)"
                    ARGDW(pBBP->ptlBrushOrg.x) ARGDW(pBBP->ptlBrushOrg.y)
                    ARGDW(pAAHdr->ptlBrushOrg.x) ARGDW(pAAHdr->ptlBrushOrg.y)));

        pAAHdr->pAAInfoCX         = pAAInfoCX;
        pAAHdr->pAAInfoCY         = pAAInfoCY;
        pAAHdr->AACXFunc          = aabbp.AACXFunc;
        pAAHdr->SrcSurfInfo.cx    = pAAInfoCX->cIn;
        pAAHdr->SrcSurfInfo.cyOrg =
        pAAHdr->SrcSurfInfo.cy    = pAAInfoCY->cIn;

        if (aabbp.AAHFlags & AAHF_HAS_MASK) {

            POINTL  MaskEnd;

            cyNext           =
            cxSize           = GET_PHTSI_CXSIZE(pMaskSI);
            aabbp.ptlMask.x += pAAInfoCX->Mask.iBeg;
            aabbp.ptlMask.y += pAAInfoCY->Mask.iBeg;
            MaskEnd.x        = aabbp.ptlMask.x + pAAInfoCX->Mask.iSize;
            MaskEnd.y        = aabbp.ptlMask.y + pAAInfoCY->Mask.iSize;

            if ((aabbp.ptlMask.x < 0)           ||
                (aabbp.ptlMask.y < 0)           ||
                (MaskEnd.x > pMaskSI->Width)    ||
                (MaskEnd.y > pMaskSI->Height)) {

                HTFreeMem(pAAInfoCX);
                HTFreeMem(pAAInfoCY);

                return(HTERR_SRC_MASK_BITS_TOO_SMALL);
            }

            pAAHdr->cyMaskNext = cyNext;
            pAAHdr->cyMaskIn   = pAAInfoCY->Mask.iSize;
            iFree              = ComputeByteOffset(BMF_1BPP,
                                                   MaskEnd.x,
                                                   &(pAAHdr->MaskBitOff));
            cbFreeBuf          = ComputeByteOffset(BMF_1BPP,
                                                   aabbp.ptlMask.x,
                                                   &(pAAHdr->MaskBitOff));
            pAAHdr->cbMaskSrc  = iFree - cbFreeBuf + 1;
            pAAHdr->pMaskIn    = pMaskSI->pPlane +
                                 (aabbp.ptlMask.y * cxSize) + cbFreeBuf;

            DBGP_IF(DBGP_MASK | DBGP_AAHEADER,
                    DBGP("CX: iMaskBeg=%ld, iMaskSize=%ld, cMaskIn=%ld, cMaskOut=%ld"
                        ARGDW(pAAInfoCX->Mask.iBeg) ARGDW(pAAInfoCX->Mask.iSize)
                        ARGDW(pAAInfoCX->Mask.cIn) ARGDW(pAAInfoCX->Mask.cOut)));

            DBGP_IF(DBGP_MASK | DBGP_AAHEADER,
                    DBGP("CY: iMaskBeg=%ld, iMaskSize=%ld, cMaskIn=%ld, cMaskOut=%ld"
                        ARGDW(pAAInfoCY->Mask.iBeg) ARGDW(pAAInfoCY->Mask.iSize)
                        ARGDW(pAAInfoCY->Mask.cIn) ARGDW(pAAInfoCY->Mask.cOut)));

            DBGP_IF(DBGP_MASK | DBGP_AAHEADER,
                    DBGP("aabbp.ptlMask x=%ld - %ld, cb=%ld, MaskBitOff=%02lx [%ld]"
                        ARGDW(aabbp.ptlMask.x) ARGDW(MaskEnd.x)
                        ARGDW(pAAHdr->cbMaskSrc) ARGDW(pAAHdr->MaskBitOff)
                        ARGDW(cbFreeBuf)));

            //
            // 0x01 in the source means use modified pixel, for the
            // reason of or in the mask, we will use 0=0xFF, 1=0x00
            // in the mask
            //


            if (pBBP->Flags & BBPF_INVERT_SRC_MASK) {

                aabbp.AAHFlags |= AAHF_INVERT_MASK;
            }

            pAAHdr->AAMaskCXFunc = aabbp.AAMaskCXFunc;
            pAAHdr->AAMaskCYFunc = aabbp.AAMaskCYFunc;

            SETDBGVAR(cCXMask, 0);

            DBGP_IF(DBGP_AAHEADER,
                    DBGP("--- SrcMask=(%5ld, %5ld)->(%5ld, %5ld) ---"
                        ARGDW(pBBP->ptlSrcMask.x) ARGDW(pBBP->ptlSrcMask.y)
                        ARGDW(aabbp.ptlMask.x) ARGDW(aabbp.ptlMask.y)));
        }

        cyNext =
        cxSize = GET_PHTSI_CXSIZE(pSrcSI);

        pAAHdr->cyABNext           =
        pAAHdr->SrcSurfInfo.cyNext = cyNext;
        pAAHdr->SrcSurfInfo.pbOrg  =
        pAAHdr->SrcSurfInfo.pb     =
                    pSrcSI->pPlane + (aabbp.rclSrc.top * cxSize) +
                    ComputeByteOffset((UINT)pSrcSI->SurfaceFormat,
                                      aabbp.rclSrc.left,
                                      &(pAAHdr->SrcSurfInfo.BitOffset));

        pAAHdr->GetAVCXFunc = aabbp.GetAVCXFunc;
        pAAHdr->GetAVCYFunc = aabbp.GetAVCYFunc;

        DBGP_IF(DBGP_AAHEADER,
                DBGP("**  pIn: (%p-%p), Beg=(%4ld, %4ld)=%p [%5ld], XOff=%4ld:%ld, cbCYExtra=%p-%p (%ld)"
                ARGPTR(pSrcSI->pPlane)
                ARGPTR(pSrcSI->pPlane + (cxSize * pSrcSI->Height))
                ARGDW(aabbp.rclSrc.left) ARGDW(aabbp.rclSrc.top)
                ARGPTR(pAAHdr->SrcSurfInfo.pb)
                ARGDW(pAAHdr->SrcSurfInfo.cyNext)
                ARGDW(ComputeByteOffset((UINT)pSrcSI->SurfaceFormat,
                                        aabbp.rclSrc.left,
                                        &(pAAHdr->SrcSurfInfo.BitOffset)))
                ARGDW(pAAHdr->SrcSurfInfo.BitOffset)
                ARGPTR(pAAInfoCY->pbExtra)
                ARGPTR(pAAInfoCY->pbExtra + cbCYExtra)
                ARGDW(cbCYExtra)));

        //
        // We do up-side-down output by writing to the destination scan lines
        // in reverse order.
        //

        cxSize = GET_PHTSI_CXSIZE(pDstSI);
        cyNext = (aabbp.rclDst.top > aabbp.rclDst.bottom) ? -cxSize :
                                                             cxSize;
        pAAHdr->DstSurfInfo.cyNext = cyNext;
        pAAHdr->DstSurfInfo.pbOrg  =
        pAAHdr->DstSurfInfo.pb     =
                    pDstSI->pPlane + (aabbp.rclDst.top * cxSize) +
                    ComputeByteOffset((UINT)DstSurfFmt,
                                      aabbp.rclDst.left,
                                      &(pAAHdr->DstSurfInfo.BitOffset));
        pAAHdr->pOutLast          = pAAHdr->DstSurfInfo.pb +
                                    (pAAHdr->DstSurfInfo.cyNext *
                                     pAAInfoCY->cOut);
        pAAHdr->DstSurfInfo.cx    = cOut;
        pAAHdr->DstSurfInfo.cyOrg =
        pAAHdr->DstSurfInfo.cy    = pAAInfoCY->cOut;
        pAAHdr->Flags             = aabbp.AAHFlags;     // Re-Save
        *pAACYFunc                = AACYFunc;

#if DBG
        pAAHdr->pOutBeg = pDstSI->pPlane +
                          (aabbp.rclDst.top * cxSize) +
                          ComputeByteOffset((UINT)DstSurfFmt,
                                            aabbp.rclDst.left,
                                            (LPBYTE)&iFree);
        pAAHdr->pOutEnd = pDstSI->pPlane +
                          (aabbp.rclDst.bottom * cxSize) +
                          ComputeByteOffset((UINT)DstSurfFmt,
                                            aabbp.rclDst.right,
                                            (LPBYTE)&iFree);

        if (pAAHdr->pOutBeg > pAAHdr->pOutEnd) {

            pAAHdr->pOutEnd = pDstSI->pPlane +
                              (aabbp.rclDst.top * cxSize) +
                              ComputeByteOffset((UINT)DstSurfFmt,
                                                aabbp.rclDst.right,
                                                (LPBYTE)&iFree);
            pAAHdr->pOutBeg = pDstSI->pPlane +
                              (aabbp.rclDst.bottom * cxSize) +
                              ComputeByteOffset((UINT)DstSurfFmt,
                                                aabbp.rclDst.left,
                                                (LPBYTE)&iFree);

        }
#endif

        //
        // Check it out if we need to fixup the input source bitmap
        //

        if (aabbp.AAHFlags & AAHF_TILE_SRC) {

            //
            // Increase the source cy and adjust pIn now
            //

            pAAHdr->SrcSurfInfo.Flags |= AASIF_TILE_SRC;

            DBGP_IF(DBGP_AAHEADER,
                    DBGP("Advance pIn by iSrcBeg=%ld x %ld=%ld"
                            ARGDW(pAAInfoCY->iSrcBeg)
                            ARGDW(pAAHdr->SrcSurfInfo.cyNext)
                            ARGDW(pAAInfoCY->iSrcBeg *
                                  pAAHdr->SrcSurfInfo.cyNext)));

            pAAHdr->SrcSurfInfo.pb += pAAInfoCY->iSrcBeg *
                                      pAAHdr->SrcSurfInfo.cyNext;
            pAAHdr->SrcSurfInfo.cy -= pAAInfoCY->iSrcBeg;
        }

        pAAHdr->pbgrfAB  = (PBGRF)pAAHdr->SrcSurfInfo.pb;
        pAAHdr->cybgrfAB = pAAHdr->SrcSurfInfo.cy;

        DBGP_IF(DBGP_AAHEADER,
                DBGP("** pOut: (%p-%p), Beg=(%4ld, %4ld)=%p-%p (%p-%p) [%5ld], XOff=%4ld:%ld, cbCYExtra=%5ld"
                ARGPTR(pDstSI->pPlane)
                ARGPTR(pDstSI->pPlane + (cxSize * pDstSI->Height))
                ARGDW(aabbp.rclDst.left) ARGDW(aabbp.rclDst.top)
                ARGPTR(pAAHdr->DstSurfInfo.pb) ARGPTR(pAAHdr->pOutLast)
                ARGPTR(pAAHdr->pOutBeg) ARGPTR(pAAHdr->pOutEnd)
                ARGDW(pAAHdr->DstSurfInfo.cyNext)
                ARGDW(ComputeByteOffset((UINT)DstSurfFmt,
                                        aabbp.rclDst.left,
                                        &(pAAHdr->DstSurfInfo.BitOffset)))
                ARGDW(pAAHdr->DstSurfInfo.BitOffset)
                ARGDW(cbCYExtra)));

        DBGP_IF(DBGP_AAHEADER,
                DBGP("--- BrushOrg=(%5ld, %5ld)->(%5ld, %5ld) ---"
                ARGDW(pBBP->ptlBrushOrg.x) ARGDW(pBBP->ptlBrushOrg.y)
                ARGDW(pAAHdr->ptlBrushOrg.x) ARGDW(pAAHdr->ptlBrushOrg.y)));

        DBGP_IF(DBGP_AAHEADER,
                DBGP("pAAHdr=%p - %p, (%ld bytes)"
                    ARGPTR(pAAHdr) ARGPTR((LPBYTE)pAAHdr + pAAHdr->cbAlloc)
                    ARGDW(pAAHdr->cbAlloc)));

        DBGP_IF(DBGP_AAHEADER,
                DBGP("pAAInfoCX=%p-%p (%ld), pAAInfoCY=%p-%p (%ld)"
                    ARGPTR(pAAInfoCX)
                    ARGPTR((LPBYTE)pAAInfoCX + pAAInfoCX->cbAlloc)
                    ARGDW(pAAInfoCX->cbAlloc)
                    ARGPTR(pAAInfoCY)
                    ARGPTR((LPBYTE)pAAInfoCY + pAAInfoCY->cbAlloc)
                    ARGDW(pAAInfoCY->cbAlloc)));

        DBGP_IF(DBGP_FUNC,
                DBGP("AACYFunc=%hs, AACXFunc=%hs"
                        ARGPTR(GetAACYFuncName(*pAACYFunc))
                        ARGPTR(GetAACXFuncName(aabbp.AACXFunc))));

        return(1);
    }

    HTFreeMem(pAAInfoCX);

    return(HTERR_INSUFFICIENT_MEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htalias.h ===
/*++

Copyright (c) 1990-1993  Microsoft Corporation


Module Name:

    htalias.h


Abstract:

    This module contains defines and structure for anti-aliasing


Author:

    09-Apr-1998 Thu 20:25:29 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#ifndef _HTALIAS_
#define _HTALIAS_


#define XCHG(a,b,t) { (t)=(a); (a)=(b); (b)=(t); }


#define DI_R_SHIFT      13
#define DI_MAX_NUM      (0x0001 << DI_R_SHIFT)
#define DI_NUM_MASK     (DI_MAX_NUM - 1)

#define DI_MUL_SHIFT    (DI_R_SHIFT >> 1)
#define MUL_TABLE_SIZE  (DI_MUL_SHIFT * 256 * sizeof(LONG))

#define AABF_MASK_IS_ORDER      0x01
#define AABF_SRC_IS_BGR8        0x02
#define AABF_SRC_IS_BGR_ALPHA   0x04
#define AABF_SRC_IS_RGB_ALPHA   0x08

typedef struct _AABFDATA {
    BYTE    Flags;
    BYTE    Format;
    BYTE    MaskRGB[3];
    BYTE    LShiftRGB[3];
    BYTE    RShiftRGB[3];
    BYTE    cbSrcInc;
    } AABFDATA, *PAABFDATA;


#define GET_FIRST_EDMUL(em, m, n, t)                                        \
{                                                                           \
    (n)  = ((LONGLONG)(m) * (LONGLONG)DI_MAX_NUM);                          \
    (em) = (WORD)((n) / (LONGLONG)(t));                                     \
}

#define GET_NEXT_EDMUL(em, m, n, t)                                         \
{                                                                           \
    (n)  = ((LONGLONG)(m) * (LONGLONG)DI_MAX_NUM) + ((n) % (LONGLONG)(t));  \
    (em) = (WORD)((n) / (LONGLONG)(t));                                     \
}


#define SDF_LARGE_MUL           (0x0001 << (DI_R_SHIFT + 2))
#define SDF_DONE                (0x0001 << (DI_R_SHIFT + 1))
#define SDF_MUL_MASK            (0xFFFF >> (15 - DI_R_SHIFT))

#define GET_SDF_LARGE_MASK(m)   (BYTE)((SHORT)(m) >> 15)
#define GET_SDF_LARGE_INC(m)    (UINT)((m) >> 15)
#define GET_SDF_LARGE_OFF(m)    (((UINT)(m) >> ((DI_R_SHIFT+2)-10)) & 0x400)

typedef struct _SHRINKDATA {
    WORD    Mul;
    } SHRINKDATA, *PSHRINKDATA;


#define EDF_LOAD_PIXEL          0x8000
#define EDF_NO_NEWSRC           0x4000

typedef struct _EXPDATA {
    WORD    Mul[4];
    } EXPDATA, *PEXPDATA;


#define AAIF_EXP_HAS_1ST_LEFT       0x0001
#define AAIF_EXP_NO_LAST_RIGHT      0x0002
#define AAIF_EXP_NO_SHARPEN         0x0004

typedef struct _REPDATA {
    WORD    c;
    } REPDATA, *PREPDATA;


typedef struct _SRCBLTINFO {
    LONG        cIn;
    LONG        cOut;
    LONG        iBeg;
    LONG        iSize;
    LONG        iSrcBeg;
    LONG        iSrcEnd;
    LONG        iDstBeg;
    LONG        iDstEnd;
    BYTE        cPrevSrc;
    BYTE        cNextSrc;
    BYTE        cFirstSkip;
    BYTE        cLastSkip;
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    DWORD       cRep;
    } SRCBLTINFO, *PSRCBLTINFO;

typedef struct _AAINFO {
    LONG        cIn;            // Input pixels Count
    LONG        cOut;           // Output Pixel Count
    WORD        Flags;          // AAIF_xxxx
    WORD        PreSrcInc;      // For shrinking
    WORD        cPreLoad;       // Preload
    WORD        PreMul;         // pre mul for shrinking
    DWORD       cAAData;
    union {
        DWORD   cAALoad;        // for expand, blt
        DWORD   cAADone;        // for shrinking
        } DUMMYUNIONNAME2;
    union {
        PLONG   pMapMul;        // use by SHRINK
        DWORD   cMaxMul;        // use by EXPAND
        LONG    iSrcBeg;        // use by TILE (Offset for the first one)
        } DUMMYUNIONNAME3;
    LPBYTE      pbExtra;        // extra buffer allocated
    LPVOID      pAAData;        // either PEXPDATA or PSHRINKDATA
    SRCBLTINFO  Src;
    SRCBLTINFO  Mask;
    SRCBLTINFO  AB;
#if DBG
    DWORD       cbAlloc;        // allocating size
#endif
    } AAINFO, *PAAINFO;

typedef VOID (HTENTRY *AACXFUNC)(PAAINFO    pAAInfo,
                                 PBGR8      pIn,
                                 PBGR8      pOut,
                                 LPBYTE     pOutEnd,
                                 LONG       OutInc);

typedef LONG (HTENTRY *AACYFUNC)(struct _AAHEADER   *pAAHdr);


typedef PBGR8 (HTENTRY *AAINPUTFUNC)(struct _AASURFINFO *pAASI,
                                     PBGR8              pInBuf);


#define XLATE_666_IDX_OR            0x01
#define XLATE_RGB_IDX_OR            0x02
#define XLATE_IDX_MASK              (XLATE_RGB_IDX_OR | XLATE_666_IDX_OR)
#define XLATE_IDX_MAX               3


typedef struct _BM8BPPDATA {
    BYTE    pXlateIdx;
    BYTE    bXor;
    BYTE    bBlack;
    BYTE    bWhite;
    } BM8BPPDATA, *PBM8BPPDATA;

typedef union _BM8BPPINFO {
    DWORD       dw;
    BYTE        b4[4];
    BM8BPPDATA  Data;
    } BM8BPPINFO, *PBM8BPPINFO;

typedef struct _AABGRINFO {
    BYTE    Order;
    BYTE    iR;
    BYTE    iG;
    BYTE    iB;
    } AABGRINFO;

typedef struct AABITMASKINFO {
    BYTE    cFirst;
    BYTE    XorMask;
    BYTE    LSFirst;
    BYTE    cLast;
    } AABITMASKINFO;

typedef struct _AAOUTPUTINFO {
    union {
        AABITMASKINFO       bm;
        AABGRINFO           bgri;
        BM8BPPINFO          bm8i;
        LPBYTE              pXlate8BPP;
        PCMY8BPPMASK        pCMY8BPPMask;
        BYTE                b4[4];
        WORD                w2[2];
        DWORD               dw;
        } DUMMYUNIONNAME;
    } AAOUTPUTINFO, *PAAOUTPUTINFO;



typedef VOID (HTENTRY *AAOUTPUTFUNC)(struct _AAHEADER    *pAAHdr,
                                     PBGRF               pInBeg,
                                     PBGRF               pInEnd,
                                     LPBYTE              pDst,
                                     PLONG               pIdxBGR,
                                     LPBYTE              pbPat,
                                     LPBYTE              pbPatEnd,
                                     LONG                cbWrapBGR,
                                     AAOUTPUTINFO        AAOutputInfo);


typedef VOID (HTENTRY *AAMASKFUNC)(struct _AAHEADER *pAAHdr);

#define FAST_MAX_CX             5
#define FAST_MAX_CY             5



#define AAHF_FLIP_X             0x00000001
#define AAHF_FLIP_Y             0x00000002
#define AAHF_ADDITIVE           0x00000004
#define AAHF_DO_SRC_CLR_MAPPING 0x00000008
#define AAHF_DO_DST_CLR_MAPPING 0x00000010
#define AAHF_GET_LAST_SCAN      0x00000020
#define AAHF_DO_FIXUPDIB        0x00000040
#define AAHF_HAS_MASK           0x00000080
#define AAHF_INVERT_MASK        0x00000100
#define AAHF_BBPF_AA_OFF        0x00000200
#define AAHF_TILE_SRC           0x00000400
#define AAHF_ALPHA_BLEND        0x00000800
#define AAHF_CONST_ALPHA        0x00001000
#define AAHF_OR_AV              0x00002000
#define AAHF_FAST_EXP_AA        0x00004000
#define AAHF_SHRINKING          0x00080000
#define AAHF_AB_DEST            0x00100000
#define AAHF_USE_DCI_DATA       0x80000000

#define AAHF_DO_CLR_MAPPING     (AAHF_DO_SRC_CLR_MAPPING |                  \
                                 AAHF_DO_DST_CLR_MAPPING)


#define PBGRF_MASK_FLAG         0xFF
#define PBGRF_END_FLAG          0xED
#define PBGRF_HAS_MASK(p)       ((p)->f)


typedef struct _FIXUPDIBINFO {
    PBGR8   prgbD[6];
    DWORD   cbbgr;
    LONG    cyIn;
#if DBG
    LONG    cCorner;
    LONG    cChecker;
#endif
    } FIXUPDIBINFO;


#define AASIF_TILE_SRC          0x01
#define AASIF_INC_PB            0x02
#define AASIF_GRAY              0x04
#define AASIF_AB_PREMUL_SRC     0x08

typedef struct _AASURFINFO {
    BYTE        Flags;
    BYTE        BitOffset;
    WORD        cClrTable;
    PLONG       pIdxBGR;
    AAINPUTFUNC InputFunc;
    LPBYTE      pbOrg;
    LONG        cyOrg;
    LPBYTE      pb;
    LONG        cx;
    LONG        cy;
    LONG        cbCX;
    LONG        cyNext;
    AABFDATA    AABFData;
    PRGB4B      pClrTable;
    } AASURFINFO, *PAASURFINFO;



typedef struct _AAHEADER {
    DWORD           Flags;
    BYTE            MaskBitOff;
    BYTE            bReserved[3];
    AASURFINFO      SrcSurfInfo;
    AASURFINFO      DstSurfInfo;
    AAMASKFUNC      AAMaskCXFunc;
    AAMASKFUNC      AAMaskCYFunc;
    LONG            cbMaskSrc;
    LPBYTE          pMaskSrc;
    LPBYTE          pMaskIn;
    LONG            cyMaskNext;
    LONG            cyMaskIn;
    AAMASKFUNC      GetAVCXFunc;
    AAMASKFUNC      GetAVCYFunc;
    PBGRF           pbgrfAB;
    LONG            cybgrfAB;
    LONG            cyABNext;
    LPBYTE          pbFixupDIB;
    AAOUTPUTFUNC    AAOutputFunc;
    AAOUTPUTINFO    AAOutputInfo;
    AACXFUNC        AACXFunc;
    AACYFUNC        AACYFunc;
    PAAINFO         pAAInfoCX;
    PAAINFO         pAAInfoCY;
    LPBYTE          pOutLast;
    POINTL          ptlBrushOrg;
    LPBYTE          pAlphaBlendBGR;
    LPBYTE          pSrcAV;
    LPBYTE          pSrcAVBeg;
    LPBYTE          pSrcAVEnd;
    LONG            SrcAVInc;
    PRGBLUTAA       prgbLUT;
    PLONG           pIdxBGR;
    PBGR8           pBGRMapTable;
    LPBYTE          pXlate8BPP;
    AAPATINFO       AAPI;
    FIXUPDIBINFO    FUDI;
    PBGR8           pInputBeg;      // For input the source
    PBGRF           pRealOutBeg;    // original output buffer begin
    PBGRF           pRealOutEnd;    // original output buffer end
    PBGRF           pOutputBeg;     // for output to the destination the
    PBGRF           pOutputEnd;     // pOutputEnd  (will be modified)
    PBGRF           pAABufBeg;      // for temporary anti-aliasing storage
    PBGRF           pAABufEnd;      // This is exclusive
    LONG            AABufInc;       // Buffer increment (may be negative)
#if DBG
    DWORD           cbAlloc;
    LPBYTE          pOutBeg;
    LPBYTE          pOutEnd;
#endif
    } AAHEADER, *PAAHEADER;


typedef PAAINFO (HTENTRY *AABUILDFUNC)(PDEVICECOLORINFO pDCI,
                                       DWORD            AAHFlags,
                                       PLONG            piSrcBeg,
                                       PLONG            piSrcEnd,
                                       LONG             SrcSize,
                                       LONG             cOut,
                                       LONG             IdxDst,
                                       PLONG            piDstBeg,
                                       PLONG            piDstEnd,
                                       LONG             cbExtra);


#define AACYMODE_TILE           0
#define AACYMODE_BLT            1
#define AACYMODE_SHRINK         2
#define AACYMODE_SHRINK_SRKCX   3
#define AACYMODE_EXPAND         4
#define AACYMODE_EXPAND_EXPCX   5
#define AACYMODE_NONE           0xFF

#define AACXMODE_BLT            0
#define AACXMODE_SHRINK         1
#define AACXMODE_EXPAND         2

typedef struct _AABBP {
    DWORD           AAHFlags;
    BYTE            CYFuncMode;
    BYTE            CXFuncMode;
    WORD            wReserved;
    AACXFUNC        AACXFunc;
    AABUILDFUNC     AABuildCXFunc;
    AABUILDFUNC     AABuildCYFunc;
    AAMASKFUNC      AAMaskCXFunc;
    AAMASKFUNC      AAMaskCYFunc;
    AAMASKFUNC      GetAVCXFunc;
    AAMASKFUNC      GetAVCYFunc;
    RECTL           rclSrc;         // original source, not well ordered
    RECTL           rclDst;         // Final destination, well ordered
    RECTL           rclDstOrg;      // Original Destination, well ordered
    POINTL          ptlFlip;        // flipping's substraction
    LONG            cxDst;
    LONG            cyDst;
    POINTL          ptlBrushOrg;
    POINTL          ptlMask;        // Final source mask offset
    } AABBP, *PAABBP;




//
// Function prototype
//

VOID
HTENTRY
SetGrayColorTable(
    PLONG       pIdxBGR,
    PAASURFINFO pAASI
    );

VOID
HTENTRY
GetColorTable(
    PHTSURFACEINFO  pSrcSI,
    PAAHEADER       pAAHdr,
    PBFINFO         pBFInfo
    );

VOID
HTENTRY
ComputeInputColorInfo(
    LPBYTE      pSrcTable,
    UINT        cPerTable,
    UINT        PrimaryOrder,
    PBFINFO     pBFInfo,
    PAASURFINFO pAASI
    );

LONG
HTENTRY
SetupAAHeader(
    PHALFTONERENDER     pHR,
    PDEVICECOLORINFO    pDCI,
    PAAHEADER           pAAHdr,
    AACYFUNC            *pAACYFunc
    );



#endif      // _HTALIAS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htdebug.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htdebug.c


Abstract:

    This module contains the debug functions


Author:
    23-Apr-1992 Thu 20:01:55 updated  -by-  Daniel Chou (danielc)
        changed 'CHAR' type to 'BYTE' type, this will make sure if compiled
        under MIPS the default 'unsigned char' will not affect the signed
        operation on the single 8 bits


    28-Mar-1992 Sat 20:53:29 updated  -by-  Daniel Chou (danielc)
        Modify sprintf for by not using va_start

    20-Feb-1991 Wed 23:06:09 created  -by-  Daniel Chou (danielc)



[Environment:]

    Printer Driver.


[Notes:]


Revision History:



--*/




#if DBG

#include <htp.h>
#include <string.h>
#include <time.h>

#include "htdebug.h"
#include "stdio.h"


UINT        DbgTimerIdx = TIMER_LAST;
DBGTIMER    DbgTimer[TIMER_MAX_IDX + 1];




LPBYTE
HTENTRY
HT_LOADDS
FD6ToString(
    LONG    Num,
    SHORT   IntDigits,
    WORD    FracDigits
    )
{
#define DBG_ONE_FD6_STR_SIZE    13
#define DBG_FD6_STR_MAX         20
#define DBG_FD6_STR_SIZE        (DBG_ONE_FD6_STR_SIZE * DBG_FD6_STR_MAX)
#define DBG_FD6_LAST_STR_IDX    (DBG_ONE_FD6_STR_SIZE * (DBG_FD6_STR_MAX-1))

    static  WORD Rounding[]        = { 50000, 5000, 500, 50, 5 };
    static  WORD DbgFD6StringIndex = 0;
    static  BYTE DbgFD6Strings[DBG_FD6_STR_SIZE + 2];


    LPBYTE  pFD6Str;
    LPBYTE  pb;
    DWORD   Number;
    INT     Loop;
    BOOL    Sign;
#ifdef UMODE
    DWORD   dw = GET_TICK;
#endif

    //
    // Check before using it
    //

    if ((DbgFD6StringIndex += DBG_ONE_FD6_STR_SIZE) > DBG_FD6_LAST_STR_IDX) {

        DbgFD6StringIndex = 0;          // Reset
    }

    pFD6Str = &DbgFD6Strings[DbgFD6StringIndex];


    if (Sign = (BOOL)(Num < 0)) {

        Number = (DWORD)-Num;

    } else {

        Number = (DWORD)Num;
    }

    if (FracDigits) {

        if (FracDigits < 6) {

            Num += (LONG)Rounding[FracDigits];

        } else {

            FracDigits = 6;
        }
    }

    sprintf(pFD6Str, "%5u.%06ld", (UINT)(Number / 1000000L), Number % 1000000L);

    if (!FracDigits) {

        pb         = pFD6Str + 11;
        Loop       = (INT)5;
        FracDigits = 6;

        while ((Loop--) && (*pb-- == (BYTE)'0')) {

            --FracDigits;
        }
    }

    *(pFD6Str + 6 + FracDigits) = (BYTE)0;
    pFD6Str += 4;

    if (IntDigits > 5) {

        IntDigits = 5;
    }

    while (*pFD6Str != (BYTE)' ') {

        --IntDigits;
        --pFD6Str;
    }

    if (Sign) {

        --IntDigits;
        *pFD6Str = '-';

    } else {

        ++pFD6Str;
    }

#ifdef UMODE
    dw                          = GET_TICK - dw;
    DbgTimer[DbgTimerIdx].Last += dw;
    DbgTimer[TIMER_TOT].Last   += dw;
#endif

    return((LPBYTE)((IntDigits > 0) ? pFD6Str - IntDigits : pFD6Str));

#undef DBG_ONE_FD6_STR_SIZE
#undef DBG_FD6_STR_MAX
#undef DBG_FD6_STR_SIZE
#undef DBG_FD6_LAST_STR_IDX
}


VOID
cdecl
HTENTRY
HT_LOADDS
DbgPrintf(
    LPSTR   pStr,
    ...
    )
{
    va_list     vaList;
    BYTE        Buf[256];
#ifdef UMODE
    DWORD   dw = GET_TICK;
#endif

    va_start(vaList, pStr);
    vsprintf(Buf, pStr, vaList);
    va_end(vaList);

#ifdef DBG_INSERT_CR_TO_LF

    {
    LPBYTE      pBufCurrent;
    LPBYTE      pBufNext;


    pBufCurrent = (LPBYTE)Buf;

    while (pBufCurrent) {

        if (pBufNext = (LPBYTE)strchr(pBufCurrent, 0x0a)) {

            *pBufNext++ = 0x00;
            DEBUGOUTPUTFUNC(pBufCurrent);
            DEBUGOUTPUTFUNC("\r\n");

        } else {

            DEBUGOUTPUTFUNC(pBufCurrent);
        }

        pBufCurrent = pBufNext;
    }

    DEBUGOUTPUTFUNC("\r\n");
    }

#else  // DBG_INSERT_CR_TO_LF

    DEBUGOUTPUTFUNC(Buf);

#endif // DBG_INSERT_CR_TO_LF


#ifdef UMODE
    dw                          = GET_TICK - dw;
    DbgTimer[DbgTimerIdx].Last += dw;
    DbgTimer[TIMER_TOT].Last   += dw;
#endif

}



VOID
HTENTRY
HT_LOADDS
_MyAssert(
    LPSTR   pMsg,
    LPSTR   pFalseExp,
    LPSTR   pFilename,
    WORD    LineNo
    )
{
#ifdef UMODE
    DWORD   dw = GET_TICK;
#endif

    DbgPrintf("\n*   Assertion Failed: %s", pMsg);
    DbgPrintf("*   False Expression: %s", pFalseExp);
    DbgPrintf("*    Failed Filename: %s", pFilename);
    DbgPrintf("* Failed Line Number: %u\n\n", LineNo);

    DBGSTOP();

#ifdef UMODE
    dw                          = GET_TICK - dw;
    DbgTimer[DbgTimerIdx].Last += dw;
    DbgTimer[TIMER_TOT].Last   += dw;
#endif

}



LPSTR
HTENTRY
HT_LOADDS
DbgTimeString(
    UINT    Idx
    )
{
#define DBG_ONE_TIME_STR_SIZE   12
#define DBG_TIME_STR_MAX        (TIMER_MAX_IDX + 1)
#define DBG_TIME_STR_SIZE       (DBG_ONE_TIME_STR_SIZE * DBG_TIME_STR_MAX)
#define DBG_TIME_LAST_STR_IDX   (DBG_ONE_TIME_STR_SIZE * (DBG_TIME_STR_MAX-1))

    static  WORD DbgTimeStringIndex = 0;
    static  BYTE DbgTimeStrings[DBG_TIME_STR_SIZE + 2];
    LPSTR   pTimeStr;
    DWORD   Time;
    UINT    Second;

    if ((DbgTimeStringIndex += DBG_ONE_TIME_STR_SIZE) > DBG_TIME_LAST_STR_IDX) {

        DbgTimeStringIndex = 0;          // Reset
    }

    pTimeStr = &DbgTimeStrings[DbgTimeStringIndex];

    if ((Time = DbgTimer[Idx].Tot) >= 1000L) {

        Second = (UINT)(Time / 1000L);
        Time  %= 1000L;

    } else {

        Second = 0;
    }

    sprintf(pTimeStr, "%2u.%03u", Second, Time);
    return(pTimeStr);


#undef DBG_ONE_TIME_STR_SIZE
#undef DBG_TIME_STR_MAX
#undef DBG_TIME_STR_SIZE
#undef DBG_TIME_LAST_STR_IDX
}

#if defined(_OS2_) || defined(_OS_20_)


VOID
HTENTRY
DebugBreak(
    VOID
    )
{
    _asm
    {
        int 3h
    }
}

#endif  // _OS2_

#ifndef UMODE

void  DrvDbgPrint(
    char * pch,
    ...)
{
    va_list ap;
    va_start(ap, pch);

    EngDebugPrint("",pch,ap);

    va_end(ap);
}

#endif

#endif  // DBG != 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htapi.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htapi.h


Abstract:

    This module contains all the public defines, constants, structures and
    functions declarations for htapi.c

Author:

    15-Jan-1991 Wed 21:13:21 updated  -by-  Daniel Chou (danielc)
        add in test pattern support

    15-Jan-1991 Tue 21:13:21 created  -by-  Daniel Chou (danielc)
        wrote it



[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:


--*/

#ifndef _HTAPI_
#define _HTAPI_

//
// The following are default printer and monitor C.I.E. color space Red,
// Green, Blue, Alignment White's coordinate and its white/black luminance.
//

#define VALID_YC                0xFFFE
#define VALID_YB_DENSITY        0xFFFE
#define MIN_RGB_GAMMA             100
#define MAX_RGB_GAMMA           65500

#define INTENSITY_R             (FD6)212674
#define INTENSITY_G             (FD6)715151
#define INTENSITY_B             (FD6) 72175

#define HT_BRUSH_COLORFULNESS   5

#define HT_K_REF_CLIP           (FD6)0
#define HT_W_REF_CLIP           (FD6)0
#define HT_K_REF_BASE           HT_K_REF_CLIP
#define HT_W_REF_BASE           (FD6_1 - HT_W_REF_CLIP)
#define HT_KW_REF_RANGE         (FD6_1 - (HT_K_REF_CLIP + HT_W_REF_CLIP))
#define HT_K_REF_ADD            (HT_K_REF_CLIP + (FD6)0)
#define HT_W_REF_SUB            (HT_W_REF_CLIP + (FD6)0)

#define DEFAULT_SCR_HTPAT_SIZE  HTPAT_SIZE_SUPERCELL_M


#if 0

CIEINFO CIEInfoSRGBScreen = {

        { 6400, 3300,       0 },    // xr, yr, Yr CIE_NORNAL_MONITOR
        { 3000, 6000,       0 },    // xg, yg, Yg
        { 1500,  600,       0 },    // xb, yb, Yb
        {    0,    0,VALID_YC },    // xc, yc, Yc
        {    0,    0,       0 },    // xm, ym, Ym
        {    0,    0,       0 },    // xy, yy, Yy
        { 3127, 3290,UDECI4_1 }     // xw, yw, Yw
    };

CIEINFO CIEInfoSRGBPrinter = {

        { 6400, 3300,       0 },    // xr, yr, Yr CIE_NORNAL_MONITOR
        { 3000, 6000,       0 },    // xg, yg, Yg
        { 1500,  600,       0 },    // xb, yb, Yb
        {    0,    0,VALID_YC },    // xc, yc, Yc
        {    0,    0,       0 },    // xm, ym, Ym
        {    0,    0,       0 },    // xy, yy, Yy
        { 3457, 3585,UDECI4_1 }     // xw, yw, Yw
    };


CIEINFO CIEInfoNormalMonitor = {

        { 6280, 3475,       0 },    // xr, yr, Yr CIE_NORNAL_MONITOR
        { 2750, 5980,       0 },    // xg, yg, Yg
        { 1480,  625,       0 },    // xb, yb, Yb
        {    0,    0,VALID_YC },    // xc, yc, Yc
        {    0,    0,       0 },    // xm, ym, Ym
        {    0,    0,       0 },    // xy, yy, Yy
        { 3127, 3290,UDECI4_1 }     // xw, yw, Yw
    };


CIEINFO CIEInfoNTSC = {

        { 6700, 3300,       0 },    // xr, yr, Yr CIE_NTSC
        { 2100, 7100,       0 },    // xg, yg, Yg
        { 1250,  800,       0 },    // xb, yb, Yb
        { 1750, 3950,VALID_YC },    // xc, yc, Yc
        { 2550, 2050,       0 },    // xm, ym, Ym
        { 4250, 5200,       0 },    // xy, yy, Yy
        { 3127, 3290,UDECI4_1 }     // xw, yw, Yw
    };


CIEINFO CIEInfoNormalPrinter = {

        { 6380, 3350,       0 },        // xr, yr, Yr
        { 2345, 6075,       0 },        // xg, yg, Yg
        { 1410,  932,       0 },        // xb, yb, Yb
        { 2000, 2450,VALID_YC },        // xc, yc, Yc
        { 5210, 2100,       0 },        // xm, ym, Ym
        { 4750, 5100,       0 },        // xy, yy, Yy
        { 3127, 3290,UDECI4_1 }         // xw, yw, Yw
    };

CIEINFO CIEInfoColorFilm = {

        { 6810, 3050,       0 },        // xr, yr, Yr
        { 2260, 6550,       0 },        // xg, yg, Yg
        { 1810,  500,       0 },        // xb, yb, Yb
        { 2000, 2450,VALID_YC },        // xc, yc, Yc
        { 5210, 2100,       0 },        // xm, ym, Ym
        { 4750, 5100,       0 },        // xy, yy, Yy
        { 3470, 2985,UDECI4_1 }         // xw, yw, Yw
    };

#endif


#ifdef INCLUDE_DEF_CIEINFO


CONST CIEINFO HT_CIE_SRGB = {

        { 6400, 3300,       0 },    // xr, yr, Yr CIE_NORNAL_MONITOR
        { 3000, 6000,       0 },    // xg, yg, Yg
        { 1500,  600,       0 },    // xb, yb, Yb
        {    0,    0,VALID_YC },    // xc, yc, Yc
        {    0,    0,       0 },    // xm, ym, Ym
        {    0,    0,       0 },    // xy, yy, Yy
        { 3127, 3290,UDECI4_1 }     // xw, yw, Yw
    };

CONST SOLIDDYESINFO   DefaultSolidDyesInfo = {

       2720,   1730,    // M/C, Y/C
       1720,   1068,    // C/M, Y/M
        320,    210,    // C/Y, M/Y
    };

#if 0

CONST SOLIDDYESINFO   DefaultSolidDyesInfo = {

        712,    121,    // M/C, Y/C
         86,    468,    // C/M, Y/M
         21,     35     // C/Y, M/Y
    };

#endif

CONST HTCOLORADJUSTMENT   DefaultCA = {

            sizeof(COLORADJUSTMENT),
            0,
            ILLUMINANT_DEFAULT,
            HT_DEF_RGB_GAMMA,
            HT_DEF_RGB_GAMMA,
            HT_DEF_RGB_GAMMA,
                0,
            10000,
            0,
            0,
            0,
            0
    };


#define MAX_RES_PERCENT         15000
#define MIN_RES_PERCENT         333
#define TOT_RES_PERCENT         (MAX_RES_PERCENT - MIN_RES_PERCENT + 1)



#endif

#ifndef _HTUI_CIEINFO_ONLY_


typedef struct _HTTESTDATA {
    WORD    cx;
    WORD    cy;
    FD6     cyRatio;
    LPBYTE  pBitmap;
    } HTTESTDATA, FAR *PHTTESTDATA;

typedef struct _HTTESTINFO {
    COLORTRIAD  ColorTriad;
    PHTTESTDATA pTestData;
    BYTE        SurfaceFormat;
    BYTE        TotalData;
    BYTE        cx;
    BYTE        cy;
    } HTTESTINFO, FAR *PHTTESTINFO;


#define DEFAULT_DENSITY_WHITE       (DECI4)9127
#define DEFAULT_DENSITY_BLACK       (DECI4)478

#define HTAPI_IDX_INIT                          0
#define HTAPI_IDX_CREATE_DHI                    1
#define HTAPI_IDX_DESTROY_DHI                   2
#define HTAPI_IDX_CHB                           3
#define HTAPI_IDX_CCT                           4
#define HTAPI_IDX_CREATE_SMP                    5
#define HTAPI_IDX_HALFTONE_BMP                  6


#if DBG

LONG
HTENTRY
HT_LOADDS
SetHalftoneError(
    DWORD   HT_FuncIndex,
    LONG    ErrorID
    );



#define SET_ERR(a,b)    SetHalftoneError((a),(b))
#define HTAPI_RET(a,b)  return((LONG)(((b)<0) ? SET_ERR((a),(b)) : (b)))

#else

#define SET_ERR(a,b)
#define HTAPI_RET(a,b)  return(b)

#endif

#define HTINITINFO_INITIAL_CHECKSUM     0x1234f012
#define HTSMP_INITIAL_CHECKSUM          0xa819203f

#define MAX_CDCI_COUNT      16
#define MAX_CSMP_COUNT      10


//
// Following are the function prototype
//

BOOL
HTENTRY
CleanUpDHI(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo
    );

PCDCIDATA
HTENTRY
FindCachedDCI(
    PDEVICECOLORINFO    pDCI
    );

BOOL
HTENTRY
AddCachedDCI(
    PDEVICECOLORINFO    pDCI
    );

BOOL
HTENTRY
GetCachedDCI(
    PDEVICECOLORINFO    pDCI
    );

PCSMPBMP
HTENTRY
FindCachedSMP(
    PDEVICECOLORINFO    pDCI,
    UINT                PatternIndex
    );

LONG
HTENTRY
GetCachedSMP(
    PDEVICECOLORINFO    pDCI,
    PSTDMONOPATTERN     pSMP
    );

DWORD
HTENTRY
ComputeHTINITINFOChecksum(
    PDEVICECOLORINFO    pDCI,
    PHTINITINFO         pHTInitInfo
    );


#endif // _HTUI_API_
#endif // _HTAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htgetbmp.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htgetbmp.c


Abstract:

    This module provided a set of functions which read the 1/4/8/16/24/32
    bits per pel bitmap and composed it


Author:
    08-Jan-1999 Fri 18:14:42 updated  -by-  Daniel Chou (danielc)
        Re-write

    23-Apr-1992 Thu 21:14:55 updated  -by-  Daniel Chou (danielc)
        1. Delete InFuncInfo.StretchSize, and using Prim1/Prim2 to determined
           when we will stop the source stretch,

        2. Change 'ColorInfoIncrement' from 'CHAR' to 'SHORT', this will make
           sure the default MIPS's 'unsigned char' will not affect our
           signed operation.

    28-Mar-1992 Sat 20:54:58 updated  -by-  Daniel Chou (danielc)
        Update it for VGA intensity (16 colors mode), this make all the
        codes update to 4 primaries internal.

    05-Apr-1991 Fri 15:55:08 created  -by-  Daniel Chou (danielc)


[Environment:]

    Printer Driver.


[Notes:]


Revision History:



--*/

#define DBGP_VARNAME        dbgpHTGetBmp

#include "htp.h"
#include "htmapclr.h"
#include "htpat.h"
#include "htalias.h"
#include "htrender.h"
#include "htstret.h"
#include "htgetbmp.h"


#define DBGP_INPUT              0x00000001
#define DBGP_GETFIXUP           0x00000002
#define DBGP_CHK_FUDI           0x00000004
#define DBGP_FUDI               0x00000008
#define DBGP_EXP_MASK           0x00000010


DEF_DBGPVAR(BIT_IF(DBGP_INPUT,          0)  |
            BIT_IF(DBGP_GETFIXUP,       0)  |
            BIT_IF(DBGP_CHK_FUDI,       0)  |
            BIT_IF(DBGP_FUDI,           0)  |
            BIT_IF(DBGP_EXP_MASK,       0))


#if DBG
    INT cCXMask = 0;

    #define DBG_CXMASK      0
#else
    #define DBG_CXMASK      0
#endif

#define GET_AV(p)       (BYTE)(p)->f
#define OR_AV(AV1, AV2) (BYTE)(((UINT)(AV1) + (UINT)(AV2) + 1) >> 1)

extern  DWORD           dwABPreMul[256];

#define GET_PREMUL_SRC(x, m)                                           \
                        (BYTE)((((DWORD)(x) * (DWORD)(m)) + 0x800000) >> 24)



VOID
HTENTRY
BltAV_CX(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    LPBYTE      pSrcAV;
    LPBYTE      pSrcAVEnd;
    INT         SrcAVInc;
    PBGRF       pbgrfAB;


    pSrcAV      = pAAHdr->pSrcAVBeg;
    pSrcAVEnd   = pAAHdr->pSrcAVEnd;
    SrcAVInc    = (INT)pAAHdr->SrcAVInc;
    pbgrfAB     = pAAHdr->pbgrfAB;

    if (pAAHdr->Flags & AAHF_OR_AV) {

        do {

            *pSrcAV = OR_AV(*pSrcAV, GET_AV(pbgrfAB));

            ++pbgrfAB;

        } while (((LPBYTE)pSrcAV += SrcAVInc) != (LPBYTE)pSrcAVEnd);

    } else {

        do {

            *pSrcAV = GET_AV(pbgrfAB);

            ++pbgrfAB;

        } while (((LPBYTE)pSrcAV += SrcAVInc) != (LPBYTE)pSrcAVEnd);
    }
}



VOID
HTENTRY
BltAV_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    pAAHdr->GetAVCXFunc(pAAHdr);

    (LPBYTE)pAAHdr->pbgrfAB += pAAHdr->cyABNext;
}





VOID
HTENTRY
TileAV_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    LPBYTE      pSrcAV;
    LPBYTE      pSrcAVEnd;
    INT         SrcAVInc;
    PBGRF       pbgrfAB;
    PBGRF       pbgrfABBeg;
    PBGRF       pbgrfABEnd;


    pSrcAV      = pAAHdr->pSrcAVBeg;
    pSrcAVEnd   = pAAHdr->pSrcAVEnd;
    SrcAVInc    = (INT)pAAHdr->SrcAVInc;
    pbgrfAB     =
    pbgrfABBeg  = pAAHdr->pbgrfAB;
    pbgrfABEnd  = pbgrfAB + pAAHdr->SrcSurfInfo.cx;
    pbgrfAB    +=  pAAHdr->pAAInfoCX->iSrcBeg;

    do {

        *pSrcAV = GET_AV(pbgrfAB);

        if (++pbgrfAB >= pbgrfABEnd) {

            pbgrfAB = pbgrfABBeg;
        }

    } while (((LPBYTE)pSrcAV += SrcAVInc) != (LPBYTE)pSrcAVEnd);

    if (--pAAHdr->cybgrfAB <= 0) {

        pAAHdr->pbgrfAB  = (PBGRF)pAAHdr->SrcSurfInfo.pbOrg;
        pAAHdr->cybgrfAB = pAAHdr->SrcSurfInfo.cyOrg;
    }
}




VOID
HTENTRY
ExpandAV_CX(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:54:25 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    LPBYTE      pSrcAV;
    LPBYTE      pSrcAVEnd;
    PBGRF       pbgrfAB;
    INT         SrcAVInc;
    BOOL        OrAV;
    DWORD       cRep;
    BYTE        AV;


    pSrcAV    = pAAHdr->pSrcAVBeg;
    pSrcAVEnd = pAAHdr->pSrcAVEnd;
    SrcAVInc  = (INT)pAAHdr->SrcAVInc;
    pbgrfAB   = pAAHdr->pbgrfAB;
    pAAInfo   = pAAHdr->pAAInfoCX;
    pRep      = pAAInfo->AB.pRep;
    pRepEnd   = pAAInfo->AB.pRepEnd;
    cRep      = 1;

    //
    // The AB set to 0xff so if the source AB is not available at begining
    // then it will be no AB
    //

    AV   = 0xFF;
    OrAV = (BOOL)(pAAHdr->Flags & AAHF_OR_AV);

    do {

        if (--cRep == 0) {

            ASSERT(pRep < pRepEnd);

            cRep = (DWORD)pRep++->c;
            AV   = GET_AV(pbgrfAB);

            if (OrAV) {

                AV = OR_AV(AV, *pSrcAV);
            }

            ++pbgrfAB;
        }

        *pSrcAV = (BYTE)AV;

    } while (((LPBYTE)pSrcAV += SrcAVInc) != (LPBYTE)pSrcAVEnd);
}



VOID
HTENTRY
ExpandAV_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;


    pAAInfo = pAAHdr->pAAInfoCY;

    if (--pAAInfo->AB.cRep == 0) {

        ASSERT(pAAInfo->AB.pRep < pAAInfo->AB.pRepEnd);

        pAAInfo->AB.cRep = (DWORD)pAAInfo->AB.pRep++->c;

        BltAV_CY(pAAHdr);
    }
}




VOID
HTENTRY
ShrinkAV_CX(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    LPBYTE      pSrcAV;
    LPBYTE      pSrcAVEnd;
    PBGRF       pbgrfAB;
    INT         SrcAVInc;
    DWORD       cRep;
    BOOL        OrAV;
    BYTE        AV;


    pSrcAV    = pAAHdr->pSrcAVBeg;
    pSrcAVEnd = pAAHdr->pSrcAVEnd;
    SrcAVInc  = (INT)pAAHdr->SrcAVInc;
    pbgrfAB   = pAAHdr->pbgrfAB;
    pAAInfo   = pAAHdr->pAAInfoCX;
    pRep      = pAAInfo->AB.pRep;
    pRepEnd   = pAAInfo->AB.pRepEnd;
    OrAV      = (BOOL)(pAAHdr->Flags & AAHF_OR_AV);

    do {

        AV = 0xFF;

        ASSERT(pRep < pRepEnd);

        if (pRep < pRepEnd) {

            AV = GET_AV(pbgrfAB);

            if (OrAV) {

                AV = OR_AV(*pSrcAV, AV);
            }

            ++pbgrfAB;
            cRep = (DWORD)pRep++->c;

            while (--cRep) {

                AV = OR_AV(AV, GET_AV(pbgrfAB));
                ++pbgrfAB;
            }
        }

        *pSrcAV = AV;

    } while (((LPBYTE)pSrcAV += SrcAVInc) != (LPBYTE)pSrcAVEnd);
}



VOID
HTENTRY
ShrinkAV_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfoCY;
    DWORD       AAHFlags;
    DWORD       cRep;

    //
    // We will get the scan first then subsequence scans will be or in
    //


    pAAInfoCY      = pAAHdr->pAAInfoCY;
    AAHFlags       = pAAHdr->Flags;
    pAAHdr->Flags &= ~AAHF_OR_AV;

    ASSERT(pAAInfoCY->AB.pRep < pAAInfoCY->AB.pRepEnd);

    cRep = (DWORD)pAAInfoCY->AB.pRep++->c;

    while (cRep--) {

        pAAHdr->GetAVCXFunc(pAAHdr);

        pAAHdr->Flags            = AAHFlags;
        (LPBYTE)pAAHdr->pbgrfAB += pAAHdr->cyABNext;
    }
}



VOID
HTENTRY
BltMask_CX(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    PBGRF       pDst;
    PBGRF       pDstEnd;
    LPBYTE      pb;
    INT         DstInc;
    DW2W4B      dw4b;
    BYTE        Mask;

    pAAInfo     = pAAHdr->pAAInfoCX;
    pDst        = pAAHdr->pAABufBeg;
    pDstEnd     = pAAHdr->pAABufEnd;
    DstInc      = pAAHdr->AABufInc;
    pb          = pAAHdr->pMaskSrc;
    dw4b.dw     = 0x01;
    dw4b.b[2]   = *pb++;
    dw4b.dw   <<= pAAHdr->MaskBitOff;

    do {

        if (dw4b.b[1]) {

            dw4b.dw   = 0x01;
            dw4b.b[2] = *pb++;
        }

        pDst->f   = (BYTE)((dw4b.b[2] & 0x80) ? PBGRF_MASK_FLAG : 0);
        dw4b.dw <<= 1;

    } while (((LPBYTE)pDst += DstInc) != (LPBYTE)pDstEnd);
}



VOID
HTENTRY
BltMask_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    GET_MASK_SCAN(pAAHdr);
    pAAHdr->AAMaskCXFunc(pAAHdr);
}



VOID
HTENTRY
ExpandMask_CX(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:54:25 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    PBGRF       pDst;
    PBGRF       pDstEnd;
    LPBYTE      pb;
    DWORD       cRep;
    INT         DstInc;
    DW2W4B      dw4b;
    BYTE        Mask;


    pAAInfo     = pAAHdr->pAAInfoCX;
    pRep        = pAAInfo->Mask.pRep;
    pRepEnd     = pAAInfo->Mask.pRepEnd;
    pDst        = pAAHdr->pAABufBeg;
    pDstEnd     = pAAHdr->pAABufEnd;
    DstInc      = pAAHdr->AABufInc;
    pb          = pAAHdr->pMaskSrc;
    dw4b.dw     = 0x01;
    dw4b.b[2]   = *pb++;
    dw4b.dw   <<= pAAHdr->MaskBitOff;

    //
    // The Mask set to 0xff so if the source mask is not available at begining
    // then it will be no mask
    //

    Mask = PBGRF_MASK_FLAG;
    cRep = 1;

    do {

        if (--cRep == 0) {

            ASSERT(pRep < pRepEnd);

            cRep = (DWORD)pRep++->c;

            //
            // Load new byte data if we already used up current byte
            //

            if (dw4b.b[1]) {

                dw4b.dw   = 0x01;
                dw4b.b[2] = *pb++;
            }

            Mask       = (BYTE)((dw4b.b[2] & 0x80) ? PBGRF_MASK_FLAG : 0);
            dw4b.dw  <<= 1;
        }

        pDst->f = Mask;

    } while (((LPBYTE)pDst += DstInc) != (LPBYTE)pDstEnd);

    SETDBGVAR(cCXMask, -1);
}



VOID
HTENTRY
ExpandMask_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;


    pAAInfo = pAAHdr->pAAInfoCY;

    if (--pAAInfo->Mask.cRep == 0) {

        ASSERT(pAAInfo->Mask.pRep < pAAInfo->Mask.pRepEnd);

        pAAInfo->Mask.cRep = (DWORD)pAAInfo->Mask.pRep++->c;

        DBGP_IF(DBGP_EXP_MASK,
                DBGP("LOAD: cy=%4ld, cMaskRem=%4ld, cMaskIn=%4ld, cMaskOut=%4ld"
                    ARGDW(pAAHdr->cyMaskIn) ARGDW(pAAInfo->Mask.cRep)
                    ARGDW(pAAInfo->Mask.cIn) ARGDW(pAAInfo->Mask.cOut)));

        BltMask_CY(pAAHdr);

    } else {

        DBGP_IF(DBGP_EXP_MASK,
                DBGP("      cy=%4ld, cMaskRem=%4ld, cMaskIn=%4ld, cMaskOut=%4ld"
                        ARGDW(pAAHdr->cyMaskIn) ARGDW(pAAInfo->Mask.cRep)
                        ARGDW(pAAInfo->Mask.cIn) ARGDW(pAAInfo->Mask.cOut)));
    }
}




VOID
HTENTRY
ShrinkMask_CX(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    PBGRF       pDst;
    PBGRF       pDstEnd;
    LPBYTE      pb;
    DWORD       cRep;
    DW2W4B      dw4b;
    INT         DstInc;
    BYTE        Mask;



    pAAInfo     = pAAHdr->pAAInfoCX;
    pRep        = pAAInfo->Mask.pRep;
    pRepEnd     = pAAInfo->Mask.pRepEnd;
    pDst        = pAAHdr->pAABufBeg;
    pDstEnd     = pAAHdr->pAABufEnd;
    DstInc      = pAAHdr->AABufInc;
    pb          = pAAHdr->pMaskSrc;
    dw4b.dw     = 0x01;
    dw4b.b[2]   = *pb++;
    dw4b.dw   <<= pAAHdr->MaskBitOff;

    //
    // --iMaskSize, because we want it to go negative when we reach 0, and
    // use bit 24-31 for mask
    //

    do {

        ASSERT(pRep < pRepEnd);

        cRep = (DWORD)pRep++->c;
        Mask = 0;

        while (cRep--) {

            //
            // Load new byte data if we already used up current byte
            //

            if (dw4b.b[1]) {

                dw4b.dw   = 0x01;
                dw4b.b[2] = *pb++;
            }

            //
            // Or in the bit 0x80, we will mask it later
            //

            Mask     |= dw4b.b[2];
            dw4b.dw <<= 1;
        }

        pDst->f = (BYTE)((Mask & 0x80) ? PBGRF_MASK_FLAG : 0);

    } while (((LPBYTE)pDst += DstInc) != (LPBYTE)pDstEnd);
}



VOID
HTENTRY
ShrinkMask_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO pAAInfo;
    DWORD   cRep;

    //
    // We will get the scan first then subsequence scans will be or in
    //

    GET_MASK_SCAN(pAAHdr);

    pAAInfo = pAAHdr->pAAInfoCY;

    ASSERT(pAAInfo->Mask.pRep < pAAInfo->Mask.pRepEnd);

    cRep = (DWORD)pAAInfo->Mask.pRep++->c;

    while (--cRep) {

        OR_MASK_SCAN(pAAHdr);
    }

    pAAHdr->AAMaskCXFunc(pAAHdr);
}





PBGR8
HTENTRY
Input1BPPToAA24(
    PAASURFINFO pAASI,
    PBGR8       pInBuf
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    15-Apr-1998 Wed 16:25:04 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPBYTE  pIn;
    PBGR8   pRet;
    UINT    cIn;
    UINT    Idx;
    UINT    i;
    W2B     Bit;
    UINT    InData;


    pIn     = pAASI->pb;
    cIn     = (UINT)pAASI->cx;
    pRet    = pInBuf;

    if (pAASI->Flags & AASIF_GRAY) {

        LPBYTE  pbIB = (LPBYTE)pInBuf;
        BYTE    Gray[2];

        Gray[0] = pAASI->pClrTable[0].a;
        Gray[1] = pAASI->pClrTable[1].a;

        if (Idx = pAASI->BitOffset) {

            Bit.w = (WORD)*pIn++ << Idx;

            if ((Idx = 8 - Idx) > cIn) {

                Idx = cIn;
            }

            cIn -= Idx;

            while (Idx--) {

                Bit.w   <<= 1;
                *pbIB++   = Gray[i = (Bit.b[1] & 0x01)];
            }
        }

        Idx = cIn >> 3;

        while (Idx--) {

            InData       = (UINT)*pIn++;
            *(pbIB + 0)  = Gray[(InData >> 7) & 0x01];
            *(pbIB + 1)  = Gray[(InData >> 6) & 0x01];
            *(pbIB + 2)  = Gray[(InData >> 5) & 0x01];
            *(pbIB + 3)  = Gray[(InData >> 4) & 0x01];
            *(pbIB + 4)  = Gray[(InData >> 3) & 0x01];
            *(pbIB + 5)  = Gray[(InData >> 2) & 0x01];
            *(pbIB + 6)  = Gray[(InData >> 1) & 0x01];
            *(pbIB + 7)  = Gray[(InData     ) & 0x01];
            pbIB        += 8;
        }

        if (cIn &= 0x07) {

            Bit.w = (WORD)*pIn;

            while (cIn--) {

                Bit.w   <<= 1;
                *pbIB++   = Gray[i = (Bit.b[1] & 0x01)];
            }
        }

    } else {

        BGR8    rgb[2];

        rgb[0] = *(PBGR8)pAASI->pClrTable;
        rgb[1] = *(PBGR8)(pAASI->pClrTable + 1);

        if (Idx = pAASI->BitOffset) {

            Bit.w = (WORD)*pIn++ << Idx;

            if ((Idx = 8 - Idx) > cIn) {

                Idx = cIn;
            }

            cIn -= Idx;

            while (Idx--) {

                Bit.w     <<= 1;
                *pInBuf++   = rgb[i = (Bit.b[1] & 0x01)];
            }
        }

        Idx = cIn >> 3;

        while (Idx--) {

            InData         = (UINT)*pIn++;
            *(pInBuf + 0)  = rgb[(InData >> 7) & 0x01];
            *(pInBuf + 1)  = rgb[(InData >> 6) & 0x01];
            *(pInBuf + 2)  = rgb[(InData >> 5) & 0x01];
            *(pInBuf + 3)  = rgb[(InData >> 4) & 0x01];
            *(pInBuf + 4)  = rgb[(InData >> 3) & 0x01];
            *(pInBuf + 5)  = rgb[(InData >> 2) & 0x01];
            *(pInBuf + 6)  = rgb[(InData >> 1) & 0x01];
            *(pInBuf + 7)  = rgb[(InData     ) & 0x01];
            pInBuf       += 8;
        }

        if (cIn &= 0x07) {

            Bit.w = (WORD)*pIn;

            while (cIn--) {

                Bit.w     <<= 1;
                *pInBuf++   = rgb[i = (Bit.b[1] & 0x01)];
            }
        }
    }

    DBGP_IF(DBGP_INPUT,
            DBGP("cyIn=%5ld, pIn=%p-%p, cbIn=%5ld, Buf=%p-%p"
                ARGDW(pAASI->cy) ARGPTR(pAASI->pb)
                ARGPTR(pIn) ARGDW(pAASI->cbCX)
                ARGPTR(pRet) ARGPTR((LPBYTE)pRet + pAASI->cbCX)));

    SET_NEXT_PIN(pAASI);

    return(pRet);
}



PBGR8
HTENTRY
Input4BPPToAA24(
    PAASURFINFO pAASI,
    PBGR8       pInBuf
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    15-Apr-1998 Wed 16:25:04 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPBYTE  pIn;
    PBGR8   pRet;
    PRGB4B  pColorTable;
    UINT    InData;
    UINT    InData2;
    UINT    cIn;
    UINT    Idx;


    pIn         = pAASI->pb;
    cIn         = (UINT)pAASI->cx;
    pRet        = pInBuf;
    pColorTable = pAASI->pClrTable;

    if (pAASI->Flags & AASIF_GRAY) {

        LPBYTE  pbIB = (LPBYTE)pInBuf;

        if (pAASI->BitOffset) {

            --cIn;
            InData  = (UINT)(*pIn++ & 0x0F);
            *pbIB++ = pColorTable[InData].a;
        }

        Idx = cIn >> 1;

        while (Idx--) {

            InData       = (UINT)*pIn++;
            *(pbIB + 0)  = pColorTable[InData >>   4].a;
            *(pbIB + 1)  = pColorTable[InData & 0x0F].a;
            pbIB        += 2;
        }

        if (cIn & 0x01) {

            InData  = (UINT)(*pIn >> 4);
            *pbIB++ = pColorTable[InData].a;
        }

    } else {

        if (pAASI->BitOffset) {

            --cIn;
            InData     = (UINT)(*pIn++ & 0x0F);
            *pInBuf++  = *(PBGR8)(pColorTable + InData);
        }

        Idx = cIn >> 1;

        while (Idx--) {

            InData         = (UINT)*pIn++;
            *(pInBuf + 0)  = *(PBGR8)(pColorTable + (InData >> 4));
            *(pInBuf + 1)  = *(PBGR8)(pColorTable + (InData & 0x0F));
            pInBuf        += 2;
        }

        if (cIn & 0x01) {

            InData    = (UINT)(*pIn >> 4);
            *pInBuf++ = *(PBGR8)(pColorTable + InData);
        }
    }

    DBGP_IF(DBGP_INPUT,
            DBGP("cyIn=%5ld, pIn=%p-%p, cbIn=%5ld, Buf=%p-%p"
                ARGDW(pAASI->cy) ARGPTR(pAASI->pb)
                ARGPTR(pIn) ARGDW(pAASI->cbCX)
                ARGPTR(pRet) ARGPTR((LPBYTE)pRet + pAASI->cbCX)));

    SET_NEXT_PIN(pAASI);

    return(pRet);
}



PBGR8
HTENTRY
Input8BPPToAA24(
    PAASURFINFO pAASI,
    PBGR8       pInBuf
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    15-Apr-1998 Wed 16:25:04 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#define pbIB    ((LPBYTE)pInBuf)

    LPBYTE  pIn;
    LPBYTE  pInBufEnd;
    PBGR8   pRet;
    PRGB4B  pColorTable;


    pIn         = pAASI->pb;
    pRet        = pInBuf;
    pColorTable = pAASI->pClrTable;
    pInBufEnd   = (LPBYTE)pInBuf + pAASI->cbCX;

    if (pAASI->Flags & AASIF_GRAY) {

        ASSERT(pAASI->cbCX == pAASI->cx);

        do {

            *pbIB = pColorTable[*pIn++].a;

        } while (++pbIB < pInBufEnd);

    } else {

        ASSERT(pAASI->cbCX == (LONG)(pAASI->cx * sizeof(BGR8)));

        do {

            *pInBuf = *(PBGR8)(pColorTable + *pIn++);

        } while (++pInBuf < (PBGR8)pInBufEnd);
    }

    DBGP_IF(DBGP_INPUT,
            DBGP("cyIn=%5ld, pIn=%p-%p, cbIn=%5ld, Buf=%p-%p"
                ARGDW(pAASI->cy) ARGPTR(pAASI->pb)
                ARGPTR(pIn) ARGDW(pAASI->cbCX)
                ARGPTR(pRet) ARGPTR((LPBYTE)pRet + pAASI->cbCX)));

    SET_NEXT_PIN(pAASI);

    return(pRet);

#undef pbIB
}



PBGR8
HTENTRY
InputPreMul32BPPToAA24(
    PAASURFINFO pAASI,
    PBGR8       pInBuf
    )

/*++

Routine Description:

    This function will read input from a 32-bit (red, green, blue, alpha
    8 bits for each channel) type of source and reverse mapped the input
    alpha channel pre-multiply RGB byte data to its orginal value.

    This function only used if alpha blending is requested and its is a per
    pixel alpha blending with 32-bit source

Arguments:




Return Value:

    pointer to the pInBuf


Author:

    16-Aug-2000 Wed 11:07:15 updated  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#define pbIB        ((LPBYTE)pInBuf)
#define mR          (AABFData.MaskRGB[0])
#define mG          (AABFData.MaskRGB[1])
#define mB          (AABFData.MaskRGB[2])

    LPBYTE      pbIn;
    PBGR8       pRet;
    LPBYTE      pInBufEnd;
    AABFDATA    AABFData;
    DWORD       Mul;
    BYTE        bgr[3];


    pbIn      = (LPBYTE)pAASI->pb;
    pRet      = pInBuf;
    AABFData  = pAASI->AABFData;
    pInBufEnd = pbIB + pAASI->cbCX;

    ASSERT(AABFData.Flags & AABF_MASK_IS_ORDER);
    ASSERT(dwABPreMul[0] == 0);

    //
    // If the pbIn[0], pbIn[1], pbIn[2] is greater than is alpha value in
    // pbIn[3] then it will be some wrong xlate, but at here we trust that
    // caller doing the right math for its RGB values
    //

    if (pAASI->Flags & AASIF_GRAY) {

        PLONG   pIdxBGR;
        BGR8    bgr8;


        pIdxBGR = pAASI->pIdxBGR;

        ASSERT((LONG)pAASI->cbCX == (LONG)pAASI->cx);
        ASSERT(pIdxBGR);

        //
        // When we need to translate from a 32-bits RGB source to gray, the
        // pIdxBGR mapping table must already re-arranged to have
        //
        //  pIdxBGR[  0 - 255] for 1st byte source RGB order
        //  pIdxBGR[256 - 511] for 2nd byte source RGB order
        //  pIdxBGR[512 - 768] for 3rd byte source RGB order
        //

        do {

            Mul    = (DWORD)dwABPreMul[pbIn[3]];
            *pbIB  = IDXBGR_2_GRAY_BYTE(pIdxBGR,
                                        GET_PREMUL_SRC(pbIn[0], Mul),
                                        GET_PREMUL_SRC(pbIn[1], Mul),
                                        GET_PREMUL_SRC(pbIn[2], Mul));
            pbIn  += 4;

        } while (++pbIB < pInBufEnd);

    } else {

        ASSERT(pAASI->cbCX == (LONG)(pAASI->cx * sizeof(BGR8)));

        if (AABFData.Flags & AABF_SRC_IS_BGR_ALPHA) {

            do {

                Mul        = (DWORD)dwABPreMul[pbIn[3]];
                pInBuf->b  = GET_PREMUL_SRC(pbIn[0], Mul);
                pInBuf->g  = GET_PREMUL_SRC(pbIn[1], Mul);
                pInBuf->r  = GET_PREMUL_SRC(pbIn[2], Mul);
                pbIn      += 4;

            } while (++pInBuf < (PBGR8)pInBufEnd);

        } else if (AABFData.Flags & AABF_SRC_IS_RGB_ALPHA) {

            do {

                Mul        = (DWORD)dwABPreMul[pbIn[3]];
                pInBuf->r  = GET_PREMUL_SRC(pbIn[0], Mul);
                pInBuf->g  = GET_PREMUL_SRC(pbIn[1], Mul);
                pInBuf->b  = GET_PREMUL_SRC(pbIn[2], Mul);
                pbIn      += 4;

            } while (++pInBuf < (PBGR8)pInBufEnd);

        } else {

            do {

                Mul        = (DWORD)dwABPreMul[pbIn[3]];
                bgr[0]     = pbIn[mB];
                bgr[1]     = pbIn[mG];
                bgr[2]     = pbIn[mR];
                pInBuf->b  = GET_PREMUL_SRC(bgr[0], Mul);
                pInBuf->g  = GET_PREMUL_SRC(bgr[1], Mul);
                pInBuf->r  = GET_PREMUL_SRC(bgr[2], Mul);
                pbIn      += 4;

            } while (++pInBuf < (PBGR8)pInBufEnd);
        }
    }

    SET_NEXT_PIN(pAASI);

    return(pRet);

#undef  mR
#undef  mG
#undef  mB
#undef  pbIB
}



PBGR8
HTENTRY
InputAABFDATAToAA24(
    PAASURFINFO pAASI,
    PBGR8       pInBuf
    )

/*++

Routine Description:

    This function read input from a 16/24/32 bits per pixel source, these
    source can be bit mask type of source (16/32 bits)


Arguments:




Return Value:




Author:

    12-Mar-1999 Fri 12:53:16 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#define pbIB        ((LPBYTE)pInBuf)
#define pwIn        ((LPWORD)pbIn)
#define pdwIn       ((LPDWORD)pbIn)
#define mR          (AABFData.MaskRGB[0])
#define mG          (AABFData.MaskRGB[1])
#define mB          (AABFData.MaskRGB[2])
#define lR          (AABFData.LShiftRGB[0])
#define lG          (AABFData.LShiftRGB[1])
#define lB          (AABFData.LShiftRGB[2])
#define rR          (AABFData.RShiftRGB[0])
#define rG          (AABFData.RShiftRGB[1])
#define rB          (AABFData.RShiftRGB[2])

#define GET_AABFDATA_BGR8(pbgr8, dwIn)                                      \
{                                                                           \
    (pbgr8)->r  = (BYTE)(((dwIn >> rR) << lR) & mR);                        \
    (pbgr8)->g  = (BYTE)(((dwIn >> rG) << lG) & mG);                        \
    (pbgr8)->b  = (BYTE)(((dwIn >> rB) << lB) & mB);                        \
}


    LPBYTE      pbIn;
    PBGR8       pRet;
    LPBYTE      pInBufEnd;
    AABFDATA    AABFData;
    DWORD       dwIn;
    UINT        cbSrcInc;


    pbIn      = (LPBYTE)pAASI->pb;
    pRet      = pInBuf;
    AABFData  = pAASI->AABFData;
    cbSrcInc  = (UINT)AABFData.cbSrcInc;
    pInBufEnd = (LPBYTE)pInBuf + pAASI->cbCX;

    if (pAASI->Flags & AASIF_GRAY) {

        PLONG   pIdxBGR;
        BGR8    bgr8;


        ASSERT((LONG)pAASI->cbCX == (LONG)pAASI->cx);

        pIdxBGR   = pAASI->pIdxBGR;
        pInBufEnd = pbIB + pAASI->cx;

        if (AABFData.Flags & AABF_MASK_IS_ORDER) {

            //
            // When we have AASIF_GRAY, the pIdxBGR must already re-arranged
            // to have
            //
            //  pIdxBGR[  0 - 255] for 1st byte source RGB order
            //  pIdxBGR[256 - 511] for 2nd byte source RGB order
            //  pIdxBGR[512 - 768] for 3rd byte source RGB order
            //

            do {

                *pbIB  = IDXBGR_2_GRAY_BYTE(pIdxBGR, pbIn[0], pbIn[1], pbIn[2]);
                pbIn  += cbSrcInc;

            } while (++pbIB < pInBufEnd);

        } else if (cbSrcInc == 4) {

            do {

                dwIn = (DWORD)*pdwIn++;

                GET_AABFDATA_BGR8(&bgr8, dwIn);

                *pbIB = IDXBGR_2_GRAY_BYTE(pIdxBGR, bgr8.b, bgr8.g, bgr8.r);

            } while (++pbIB < pInBufEnd);

        } else {

            ASSERT(cbSrcInc == 2);

            do {

                dwIn = (DWORD)*pwIn++;

                GET_AABFDATA_BGR8(&bgr8, dwIn);

                *pbIB = IDXBGR_2_GRAY_BYTE(pIdxBGR, bgr8.b, bgr8.g, bgr8.r);

            } while (++pbIB < pInBufEnd);
        }

    } else {

        ASSERT(pAASI->cbCX == (LONG)(pAASI->cx * sizeof(BGR8)));

        if (AABFData.Flags & AABF_MASK_IS_ORDER) {

            if (AABFData.Flags & AABF_SRC_IS_BGR8) {

                CopyMemory(pInBuf, pbIn, pAASI->cbCX);

            } else {

                do {

                    pInBuf->r  = pbIn[mR];
                    pInBuf->g  = pbIn[mG];
                    pInBuf->b  = pbIn[mB];
                    pbIn      += cbSrcInc;

                } while (++pInBuf < (PBGR8)pInBufEnd);
            }

        } else if (cbSrcInc == 4) {

            do {

                dwIn = (DWORD)*pdwIn++;

                GET_AABFDATA_BGR8(pInBuf, dwIn);

            } while (++pInBuf < (PBGR8)pInBufEnd);

        } else {

            ASSERT(cbSrcInc == 2);

            do {

                dwIn = (DWORD)*pwIn++;

                GET_AABFDATA_BGR8(pInBuf, dwIn);

            } while (++pInBuf < (PBGR8)pInBufEnd);
        }
    }

    SET_NEXT_PIN(pAASI);

    return(pRet);

#undef  mR
#undef  mG
#undef  mB
#undef  lR
#undef  lG
#undef  lB
#undef  rR
#undef  rG
#undef  rB
#undef  pwIn
#undef  pdwIn
#undef  pbIB
}




#if DBG


LPSTR
GetAAInputFuncName(
    AAINPUTFUNC AAInputFunc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    06-Jan-1999 Wed 19:11:27 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    if (AAInputFunc == (AAINPUTFUNC)Input1BPPToAA24) {

        return("Input1BPPToAA24");

    } else if (AAInputFunc == (AAINPUTFUNC)Input4BPPToAA24) {

        return("Input4BPPToAA24");

    } else if (AAInputFunc == (AAINPUTFUNC)Input8BPPToAA24) {

        return("Input8BPPToAA24");

    } else if (AAInputFunc == (AAINPUTFUNC)InputPreMul32BPPToAA24) {

        return("InputPreMul32BPPToAA24");

    } else if (AAInputFunc == (AAINPUTFUNC)InputAABFDATAToAA24) {

        return("InputAABFDATAToAA24");

    } else {

        return("ERROR: Unknown Function");
    }
}


#endif




PBGR8
HTENTRY
FixupGrayScan(
    PAAHEADER   pAAHdr,
    PBGR8       pInBuf
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    13-Apr-1999 Tue 11:48:14 created  -by-  Daniel Chou (danielc)


Revision History:

    06-May-1999 Thu 13:07:49 updated  -by-  Daniel Chou (danielc)
        The pInBuf can be NULL now

--*/

{
    FIXUPDIBINFO    FUDI;
    LPBYTE          pS0;
    LPBYTE          pS1;
    LPBYTE          pS2;
    LPBYTE          pS3;
    LPBYTE          pD1;
    LPBYTE          pD2;
    UINT            cIn;
    UINT            cbIn;
    BYTE            Mask;


    cbIn =
    cIn  = (UINT)pAAHdr->SrcSurfInfo.cx;
    FUDI = pAAHdr->FUDI;

    if (pAAHdr->Flags & AAHF_GET_LAST_SCAN) {

        pS0             = (LPBYTE)FUDI.prgbD[4];
        pAAHdr->Flags &= ~AAHF_GET_LAST_SCAN;

        DBGP_IF(DBGP_GETFIXUP,
            DBGP("*** GetFixupScan: Re-Copy cyIn=%ld LAST SCANLINE ***"
                        ARGDW(FUDI.cyIn)));

        ++FUDI.cyIn;

    } else if (FUDI.cyIn <= 1) {

        pS0 = (LPBYTE)FUDI.prgbD[5];

        DBGP_IF(DBGP_GETFIXUP,
                DBGP("*** GetFixupScan: cyIn=%ld, FINAL SCANLINE, cChecker=%ld, cCorner=%ld, Tot=%ld"
                        ARGDW(FUDI.cyIn)
                        ARGDW(pAAHdr->FUDI.cChecker)
                        ARGDW(pAAHdr->FUDI.cCorner)
                        ARGDW(pAAHdr->FUDI.cCorner + pAAHdr->FUDI.cChecker)));

    } else {

        DWORD   g0;
        DWORD   g1;
        LONG    c0;
        LONG    c1;
        LONG    c2;
        LONG    c3;
        LONG    c0L;
        LONG    c0T;
        LONG    c1R;
        LONG    c1T;
        LONG    c2L;
        LONG    c2B;
        LONG    c3R;
        LONG    c3B;

        //
        // Scroll up the scan lines
        //

        pD2 = (LPBYTE)FUDI.prgbD[0];
        CopyMemory(&FUDI.prgbD[0], &FUDI.prgbD[1], sizeof(FUDI.prgbD[0]) * 5);
        FUDI.prgbD[5] = (PBGR8)pD2;

        pS0 = (LPBYTE)FUDI.prgbD[0];
        pS1 = (LPBYTE)FUDI.prgbD[1];
        pS2 = (LPBYTE)FUDI.prgbD[2];
        pS3 = (LPBYTE)FUDI.prgbD[3];
        pD1 = (LPBYTE)FUDI.prgbD[4];

        CopyMemory(pD2, pS2, FUDI.cbbgr);

        //
        // Save the next source scan line
        //

        if (pAAHdr->SrcSurfInfo.cy > 0) {

            pAAHdr->SrcSurfInfo.InputFunc(&(pAAHdr->SrcSurfInfo),
                                          (PBGR8)(pS3 + 1));

            *(pS3 + 0)       = *(pS3 + 2);
            *(pS3 + cIn + 1) = *(pS3 + cIn - 1);

        } else {

            //
            // No more scan lines, so copy the prev -2
            //

            CopyMemory(pS3, pS1, FUDI.cbbgr);
        }

        c0  = (LONG)*(pS1 + 0);
        c2  = (LONG)*(pS2 + 0);
        c1  = (LONG)*(pS1 + 1);
        c3  = (LONG)*(pS2 + 1);
        c1R = (LONG)*(pS1 + 2);
        c3R = (LONG)*(pS2 + 2);
        g1  = c1;

        while (--cIn) {

            c0L = c0;
            c2L = c2;
            c0  = c1;
            c2  = c3;
            c1  = c1R;
            c3  = c3R;
            c1R = (LONG)*(pS1 + 3);
            c3R = (LONG)*(pS2 + 3);
            g0  = g1;
            g1  = c1;

            if ((c0 != c1) && (!((c0 ^ c3) | (c1 ^ c2)))) {

                c0T = (LONG)*(pS0 + 1);
                c1T = (LONG)*(pS0 + 2);
                c2B = (LONG)*(pS3 + 1);
                c3B = (LONG)*(pS3 + 2);

                if ((!((c0L ^ c1) | (c2L ^ c3) | (c1R ^ c0) | (c3R ^ c2))) ||
                    (!((c0T ^ c2) | (c1T ^ c3) | (c2B ^ c0) | (c3B ^ c1)))) {

                    *(pD1 + 1) =
                    *(pD1 + 2) =
                    *(pD2 + 1) =
                    *(pD2 + 2) = (BYTE)(((LONG)*(pS1 + 1) +
                                         (LONG)*(pS1 + 2) + 1) >> 1);

                    SETDBGVAR(FUDI.cChecker, FUDI.cChecker + 1);

                } else {

                    if (g0 >= g1) {

                        SET_CORNER_GRAY(pD1 + 1, c1, c1R, c2, c2B);
                        SET_CORNER_GRAY(pD2 + 2, c1, c1T, c2, c2L);

                    } else {

                        SET_CORNER_GRAY(pD1 + 2, c0, c0L, c3, c3B);
                        SET_CORNER_GRAY(pD2 + 1, c0, c0T, c3, c3R);
                    }

                    SETDBGVAR(FUDI.cCorner, FUDI.cCorner + 1);
                }
            }

            ++pS0;
            ++pS1;
            ++pS2;
            ++pS3;
            ++pD1;
            ++pD2;
        }

        pS0 = (LPBYTE)FUDI.prgbD[4];

        DBGP_IF(DBGP_GETFIXUP,
                DBGP("*** GetFixupScan: cyIn=%ld" ARGDW(FUDI.cyIn - 1)));
    }

    if (pInBuf) {

        CopyMemory(pInBuf, pS0 + 1, cbIn);
    }

    --FUDI.cyIn;
    pAAHdr->FUDI = FUDI;

    return(pInBuf);
}



PBGR8
HTENTRY
FixupColorScan(
    PAAHEADER   pAAHdr,
    PBGR8       pInBuf
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    13-Apr-1999 Tue 11:48:20 created  -by-  Daniel Chou (danielc)


Revision History:

    06-May-1999 Thu 13:07:49 updated  -by-  Daniel Chou (danielc)
        The pInBuf can be NULL now

--*/

{
    FIXUPDIBINFO    FUDI;
    PBGR8           pS0;
    PBGR8           pS1;
    PBGR8           pS2;
    PBGR8           pS3;
    PBGR8           pD1;
    PBGR8           pD2;
    UINT            cIn;
    UINT            cbIn;
    BYTE            Mask;


    cIn  = (UINT)pAAHdr->SrcSurfInfo.cx;
    cbIn = (UINT)pAAHdr->SrcSurfInfo.cbCX;
    FUDI = pAAHdr->FUDI;

    if (pAAHdr->Flags & AAHF_GET_LAST_SCAN) {

        pS0             = FUDI.prgbD[4];
        pAAHdr->Flags &= ~AAHF_GET_LAST_SCAN;

        DBGP_IF(DBGP_GETFIXUP,
            DBGP("*** GetFixupScan: Re-Copy cyIn=%ld LAST SCANLINE ***"
                        ARGDW(FUDI.cyIn)));

        ++FUDI.cyIn;

    } else if (FUDI.cyIn <= 1) {

        pS0 = FUDI.prgbD[5];

        DBGP_IF(DBGP_GETFIXUP,
                DBGP("*** GetFixupScan: cyIn=%ld, FINAL SCANLINE, cChecker=%ld, cCorner=%ld, Tot=%ld"
                        ARGDW(FUDI.cyIn)
                        ARGDW(pAAHdr->FUDI.cChecker)
                        ARGDW(pAAHdr->FUDI.cCorner)
                        ARGDW(pAAHdr->FUDI.cCorner + pAAHdr->FUDI.cChecker)));

    } else {

        DWORD   g0;
        DWORD   g1;
        LONG    c0;
        LONG    c1;
        LONG    c2;
        LONG    c3;
        LONG    c0L;
        LONG    c0T;
        LONG    c1R;
        LONG    c1T;
        LONG    c2L;
        LONG    c2B;
        LONG    c3R;
        LONG    c3B;

        //
        // Scroll up the scan lines
        //

        pD2 = FUDI.prgbD[0];
        CopyMemory(&FUDI.prgbD[0], &FUDI.prgbD[1], sizeof(FUDI.prgbD[0]) * 5);
        FUDI.prgbD[5] = pD2;

        pS0 = FUDI.prgbD[0];
        pS1 = FUDI.prgbD[1];
        pS2 = FUDI.prgbD[2];
        pS3 = FUDI.prgbD[3];
        pD1 = FUDI.prgbD[4];

        CopyMemory(pD2, pS2, FUDI.cbbgr);

        //
        // Save the next source scan line
        //

        if (pAAHdr->SrcSurfInfo.cy > 0) {

            pAAHdr->SrcSurfInfo.InputFunc(&(pAAHdr->SrcSurfInfo), pS3 + 1);

            *(pS3 + 0)       = *(pS3 + 2);
            *(pS3 + cIn + 1) = *(pS3 + cIn - 1);

        } else {

            //
            // No more scan lines, so copy the prev -2
            //

            CopyMemory(pS3, pS1, FUDI.cbbgr);
        }

        c0  = GET_LBGR(pS1 + 0);
        c2  = GET_LBGR(pS2 + 0);
        c1  = GET_LBGR(pS1 + 1);
        c3  = GET_LBGR(pS2 + 1);
        c1R = GET_LBGR(pS1 + 2);
        c3R = GET_LBGR(pS2 + 2);
        g1  = GET_GRAY_RGB(pS1 + 1);

        while (--cIn) {

            c0L = c0;
            c2L = c2;
            c0  = c1;
            c2  = c3;
            c1  = c1R;
            c3  = c3R;
            c1R = GET_LBGR(pS1 + 3);
            c3R = GET_LBGR(pS2 + 3);
            g0  = g1;
            g1  = GET_GRAY_RGB(pS1 + 2);

            if ((c0 != c1) && (!((c0 ^ c3) | (c1 ^ c2)))) {

                c0T = GET_LBGR(pS0 + 1);
                c1T = GET_LBGR(pS0 + 2);
                c2B = GET_LBGR(pS3 + 1);
                c3B = GET_LBGR(pS3 + 2);

                if ((!((c0L ^ c1) | (c2L ^ c3) | (c1R ^ c0) | (c3R ^ c2))) ||
                    (!((c0T ^ c2) | (c1T ^ c3) | (c2B ^ c0) | (c3B ^ c1)))) {

                    (pD1 + 1)->r =
                    (pD1 + 2)->r =
                    (pD2 + 1)->r =
                    (pD2 + 2)->r = (BYTE)(((LONG)(pS1 + 1)->r +
                                           (LONG)(pS1 + 2)->r + 1) >> 1);
                    (pD1 + 1)->g =
                    (pD1 + 2)->g =
                    (pD2 + 1)->g =
                    (pD2 + 2)->g = (BYTE)(((LONG)(pS1 + 1)->g +
                                           (LONG)(pS1 + 2)->g + 1) >> 1);
                    (pD1 + 1)->b =
                    (pD1 + 2)->b =
                    (pD2 + 1)->b =
                    (pD2 + 2)->b = (BYTE)(((LONG)(pS1 + 1)->b +
                                           (LONG)(pS1 + 2)->b + 1) >> 1);

                    SETDBGVAR(FUDI.cChecker, FUDI.cChecker + 1);

                } else {

                    if (g0 >= g1) {

                        SET_CORNER_BGR(pD1 + 1, c1, c1R, c2, c2B);
                        SET_CORNER_BGR(pD2 + 2, c1, c1T, c2, c2L);

                    } else {

                        SET_CORNER_BGR(pD1 + 2, c0, c0L, c3, c3B);
                        SET_CORNER_BGR(pD2 + 1, c0, c0T, c3, c3R);
                    }

                    SETDBGVAR(FUDI.cCorner, FUDI.cCorner + 1);
                }
            }

            ++pS0;
            ++pS1;
            ++pS2;
            ++pS3;
            ++pD1;
            ++pD2;
        }

        pS0 = FUDI.prgbD[4];

        DBGP_IF(DBGP_GETFIXUP,
                DBGP("*** GetFixupScan: cyIn=%ld" ARGDW(FUDI.cyIn - 1)));
    }

    if (pInBuf) {

        CopyMemory(pInBuf, pS0 + 1, cbIn);
    }

    --FUDI.cyIn;
    pAAHdr->FUDI = FUDI;

    return(pInBuf);
}




PBGR8
HTENTRY
GetFixupScan(
    PAAHEADER   pAAHdr,
    PBGR8       pInBuf
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    17-Oct-1998 Sat 15:25:57 created  -by-  Daniel Chou (danielc)


Revision History:

    06-May-1999 Thu 13:07:49 updated  -by-  Daniel Chou (danielc)
        The pInBuf can be NULL now


--*/

{
    DWORD   AAHFlags;


    DBG_TIMER_BEG(TIMER_INPUT);

    if (!((AAHFlags = pAAHdr->Flags) & AAHF_DO_FIXUPDIB)) {

        if (AAHFlags & AAHF_GET_LAST_SCAN) {

            if (++pAAHdr->SrcSurfInfo.cy > pAAHdr->SrcSurfInfo.cyOrg) {

                DBGP("Error: GET_LAST_SCAN on first scan line %ld (%ld)"
                        ARGDW(pAAHdr->SrcSurfInfo.cy)
                        ARGDW(pAAHdr->SrcSurfInfo.cyOrg));

                pAAHdr->SrcSurfInfo.cy = pAAHdr->SrcSurfInfo.cyOrg;
            }

            pAAHdr->SrcSurfInfo.pb     = pAAHdr->SrcSurfInfo.pbOrg +
                                         ((pAAHdr->SrcSurfInfo.cyOrg -
                                           pAAHdr->SrcSurfInfo.cy) *
                                          pAAHdr->SrcSurfInfo.cyNext);
            pAAHdr->SrcSurfInfo.Flags |= AASIF_INC_PB;
            pAAHdr->Flags             &= ~AAHF_GET_LAST_SCAN;
        }

        if (pInBuf) {

            pAAHdr->SrcSurfInfo.InputFunc(&(pAAHdr->SrcSurfInfo), pInBuf);

        } else {

            SET_NEXT_PIN((&(pAAHdr->SrcSurfInfo)));
        }

    } else if (pAAHdr->SrcSurfInfo.Flags & AASIF_GRAY) {

        FixupGrayScan(pAAHdr, pInBuf);

    } else {

        FixupColorScan(pAAHdr, pInBuf);
    }

    if ((pAAHdr->Flags & AAHF_DO_SRC_CLR_MAPPING) && (pInBuf)) {

        MappingBGR(pInBuf,
                   pAAHdr->SrcSurfInfo.cx,
                   (PBGR8)pAAHdr->pBGRMapTable,
                   (LPBYTE)pAAHdr->AAPI.pbPat555);

        if ((pAAHdr->AAPI.pbPat555 += pAAHdr->AAPI.cyNext555) ==
                                                pAAHdr->AAPI.pbWrap555) {

            pAAHdr->AAPI.pbPat555 = pAAHdr->AAPI.pbBeg555;
        }
    }

    DBG_TIMER_END(TIMER_INPUT);

    return(pInBuf);
}



BOOL
HTENTRY
CheckBMPNeedFixup(
    PDEVICECOLORINFO    pDCI,
    PAAHEADER           pAAHdr,
    PHTSURFACEINFO      pSrcSI,
    PAABBP              pAABBP
    )

/*++

Routine Description:

    This function check the bitmap to see if we need to do a fixup, if yes
    then it allocated memory accordingly


Arguments:




Return Value:




Author:

    07-Dec-1998 Mon 18:25:45 created  -by-  Daniel Chou (danielc)


Revision History:

    15-Aug-2000 Tue 19:05:25 updated  -by-  Daniel Chou (danielc)
        At pre-read checking, we HAVE TO turn off the the gray conversion
        and Alpha Blending pre-multiply conversion.


--*/

{
    LPBYTE      pbAlloc = NULL;
    LPBYTE      pInEnd;
    LPDWORD     pdwBegPal;
    LPDWORD     pdwEndPal;
    LPDWORD     pdw;
    AASURFINFO  SrcSurfInfo;
    RECTL       rclSrc;
    UINT        SrcFmt;
    LONG        cIn;
    LONG        cbIn;
    LONG        cPalChk;
    LONG        cPalTot;
    LONG        cyIn;
    LONG        cySkip;
    LONG        cy;
    DW2W4B      dw4b;
    DWORD       AAHFlags;
    BOOL        NewPal;

    DEFDBGVAR(LONG,  iY)


    SrcFmt = (UINT)pSrcSI->SurfaceFormat;

    if (!((AAHFlags = pAABBP->AAHFlags) & AAHF_DO_FIXUPDIB)) {

        DBGP_IF(DBGP_FUDI | DBGP_CHK_FUDI,
                DBGP("CheckBMPNeedFixup(%ld)=No" ARGDW(SrcFmt)));

        return(FALSE);
    }

    switch (SrcFmt) {

    case BMF_1BPP:
    case BMF_4BPP:
    case BMF_4BPP_VGA16:

        pAABBP->AAHFlags |= (AAHF_DO_FIXUPDIB | AAHF_BBPF_AA_OFF);

        DBGP_IF(DBGP_FUDI | DBGP_CHK_FUDI,
                DBGP("CheckBMPNeedFixup(%ld)=1BPP/4BPPNo, Check DIB and AA=OFF" ARGDW(SrcFmt)));

        return(TRUE);
        break;

    case BMF_8BPP:
    case BMF_8BPP_VGA256:
    case BMF_16BPP:
    case BMF_16BPP_555:
    case BMF_16BPP_565:
    case BMF_24BPP:
    case BMF_32BPP:

        rclSrc.left   =
        rclSrc.top    = 0;
        rclSrc.right  = pSrcSI->Width;
        rclSrc.bottom = pSrcSI->Height;

        if (!IntersectRECTL(&rclSrc, &pAABBP->rclSrc)) {

            return(FALSE);
        }

        //
        // 15-Aug-2000 Tue 19:05:25 updated  -by-  Daniel Chou (danielc)
        //  At pre-read checking, we HAVE TO turn off the the gray conversion
        //  and Alpha Blending pre-multiply conversion.
        //

        SrcSurfInfo        = pAAHdr->SrcSurfInfo;
        SrcSurfInfo.Flags &= ~(AASIF_GRAY | AASIF_AB_PREMUL_SRC);
        SrcSurfInfo.cyNext =
        cIn                = GET_PHTSI_CXSIZE(pSrcSI);
        cyIn               =
        SrcSurfInfo.cy     = rclSrc.bottom - rclSrc.top;
        SrcSurfInfo.pb     = pSrcSI->pPlane +
                             (rclSrc.top * cIn) +
                             ComputeByteOffset(SrcFmt,
                                               rclSrc.left,
                                               &(SrcSurfInfo.BitOffset));
        SrcSurfInfo.cx     =
        cIn                = rclSrc.right - rclSrc.left;
        SrcSurfInfo.cbCX   = cIn * sizeof(BGR8);
        cySkip             = 1;

        ALIGN_MEM(cbIn, (cIn + 2) * sizeof(BGR8));

        if ((cPalTot = cyIn * cIn) <= MIN_FIXUP_SIZE) {

            DBGP_IF(DBGP_FUDI,
                    DBGP("cyIn=%ld x cIn==%ld = %ld (<= MIN_FIXUP_SIZE=%ld, Turn off AA"
                        ARGDW(cyIn) ARGDW(cIn) ARGDW(cPalTot)
                        ARGDW(MIN_FIXUP_SIZE)));

            AAHFlags |= AAHF_BBPF_AA_OFF;
            break;

        } else if (cPalTot <= MIN_PAL_SIZE) {

            DBGP_IF(DBGP_FUDI,
                    DBGP("cPalTot=%ld <= MIN_PAL_SIZE=%ld, cPalChk: %ld -> %ld"
                        ARGDW(cPalTot) ARGDW(MIN_PAL_SIZE)
                        ARGDW(cPalTot) ARGDW(GET_PAL_CHK_COUNT(cPalTot))));

            cPalChk = GET_PAL_CHK_COUNT(cPalTot);

        } else {

            SrcSurfInfo.cy      = (cyIn + STD_PAL_CY_SKIP - 1) / STD_PAL_CY_SKIP;
            SrcSurfInfo.cyNext *= (cySkip = STD_PAL_CY_SKIP);
            cPalChk             = MAX_FIXUPDIB_PAL;

            DBGP_IF(DBGP_FUDI,
                    DBGP("REGULAR BITMAP, cySkip=%ld, cy=%ld -> %ld, cPalChk=%ld (MAX_FIXUPDIB_PAL)"
                        ARGDW(cySkip) ARGDW(cyIn) ARGDW(SrcSurfInfo.cy)
                        ARGDW(cPalChk) ARGDW(MAX_FIXUPDIB_PAL)));
        }

        if (!(pbAlloc = (LPBYTE)HTAllocMem((LPVOID)pDCI,
                                           HTMEM_FIXUPDIB,
                                           LPTR,
                                           cbIn + ((cPalChk + 1) *
                                                        sizeof(DWORD))))) {

            DBGP("Error: Cannot Allocate FixupDIB memory=%ld bytes, Turn of FIXUP"
                    ARGDW(cbIn + ((cPalChk + 1) * sizeof(DWORD))));

            pAABBP->AAHFlags = (AAHFlags & ~AAHF_DO_FIXUPDIB);

            return(FALSE);
        }

        pdwEndPal =
        pdwBegPal = (LPDWORD)(pbAlloc + cbIn);
        pInEnd    = (LPBYTE)pbAlloc + (cIn * sizeof(BGR8));
        cPalTot   = 0;

        SETDBGVAR(iY, 0);

        DBGP_IF(DBGP_FUDI,
                DBGP("SrcInputFunc=%p, cySkip=%ld, pIn=%p, Fmt=%ld (%ld x %ld), cPalChk=%ld"
                        ARGPTR(SrcSurfInfo.InputFunc) ARGDW(cySkip)
                        ARGPTR(SrcSurfInfo.pb) ARGDW(SrcFmt)
                        ARGDW(cIn) ARGDW(cyIn) ARGDW(cPalChk)));

        cbIn    = (cyIn * cIn);
        dw4b.dw = 0;

        do {

            PBGR8   pbgr;

            //
            // Try to read some lines and determine if this is a non primary
            // color bitmap, we only fixed up the bitmap if any of RGB is
            // 0x00, 0x40, 0x80, 0xc0, 0xFF
            //

            NewPal = FALSE;
            pbgr   = SrcSurfInfo.InputFunc(&SrcSurfInfo, (PBGR8)pbAlloc);

            do {


                //
                // The first entry is the sentinal, so it always stop there
                //

                dw4b.b[0] = pbgr->g;

                if ((dw4b.b[1] = pbgr->r) ==
                    (dw4b.b[2] = pbgr->b)) {

                    //
                    // This is a gray scale data, make it collapse by 4,
                    // the 0, 1, 2, 3 = 0, 4, 5, 6, 7 = 4,...., 252, 253,
                    // 254, 255 = 252
                    //

                    dw4b.dw &= 0xFCFCFCFC;
                }

                *pdwBegPal  = dw4b.dw;
                pdw         = pdwEndPal;

                while (*pdw != dw4b.dw) {

                    --pdw;
                }

                if (pdw == pdwBegPal) {

                    //
                    // We have new palette entry
                    //

                    if (++cPalTot > cPalChk) {

                        break;
                    }

                    *(++pdwEndPal) = dw4b.dw;
                    NewPal         = TRUE;
                }

            } while (++pbgr < (PBGR8)pInEnd);

            DBGP_IF(DBGP_FUDI,
                    DBGP("IsBmpNeedFixup(%4ld/%4ld) [%4ld/%4ld]: cPalTot=%4ld, cPalChk=%4ld"
                            ARGDW(iY) ARGDW(SrcSurfInfo.cy)
                            ARGDW((iY * cySkip) + 1)
                            ARGDW(cyIn) ARGDW(cPalTot) ARGDW(cPalChk)));

            SETDBGVAR(iY, iY + 1);

            if ((cPalChk != MAX_FIXUPDIB_PAL) && (!NewPal)) {

                DBGP_IF(DBGP_FUDI,
                        DBGP("Same Scanline Pal (%4ld / %4ld),  cPalChk=%ld (%ld)"
                            ARGDW(iY) ARGDW(SrcSurfInfo.cy)
                            ARGDW(cPalChk) ARGDW(MAX_FIXUPDIB_PAL)));

                //
                // Scan line is same, so reduced the cPalChk for SMALL BMP
                //

                if ((cbIn -= cIn) <= MIN_FIXUP_SIZE) {

                    DBGP_IF(DBGP_FUDI | DBGP_CHK_FUDI,
                            DBGP("cx*cy=%ld <= MIN_FIXUP_SIZE=%ld, Turn off AA"
                                ARGDW(cbIn) ARGDW(MIN_FIXUP_SIZE)));

                    AAHFlags |= AAHF_BBPF_AA_OFF;
                    break;
                }

                cPalChk = GET_PAL_CHK_COUNT2(cbIn);
            }

        } while ((cPalTot <= cPalChk) && (SrcSurfInfo.cy));

        DBGP_IF(DBGP_CHK_FUDI,
                DBGP("IsBmpNeedFixup(): cPalChk=%ld, cy=%ld, cPalTot=%ld"
                        ARGDW(cPalChk) ARGDW((iY * cySkip) + 1)
                        ARGDW(cPalTot)));

        if (cPalTot < MAX_FIXUPDIB_PAL) {

            DBGP_IF(DBGP_FUDI | DBGP_CHK_FUDI,
                    DBGP("cPalTot=%ld < MAX_FIXUPDIB_PAL (%ld) Turn off AA"
                        ARGDW(cPalTot) ARGDW(MAX_FIXUPDIB_PAL)));

            AAHFlags |= AAHF_BBPF_AA_OFF;
        }

        if (cPalChk == MAX_FIXUPDIB_PAL) {

            //
            // We are checking regular size bitmap, turn OFF FIXUPDIB if
            // cPalTot > cPalChk
            //

            if (cPalTot > cPalChk) {

                AAHFlags &= ~AAHF_DO_FIXUPDIB;
            }

            DBGP_IF(DBGP_FUDI | DBGP_CHK_FUDI,
                    DBGP("Checking REGULAR BITMAP: cPalTot=%ld, cPalChk=%ld, DO_FIXUP=%hs"
                        ARGDW(cPalTot) ARGDW(cPalChk)
                        ARGPTR((AAHFlags & AAHF_DO_FIXUPDIB) ? "Yes" : "No")));

        } else {

            //
            // We are checking bitmap size <= MIN_PAL_SIZE (smaller size)
            // the FIXUPDIB will be turn ON if (cPalTot <= MAX_FIXUPDIB_PAL) ||
            // (cPalTot > cPalChk)
            //

            if ((cPalTot > MAX_FIXUPDIB_PAL) ||
                (cPalTot <= cPalChk)) {

                AAHFlags &= ~AAHF_DO_FIXUPDIB;
            }

            DBGP_IF(DBGP_FUDI | DBGP_CHK_FUDI,
                    DBGP("Checking SMALL BITMAP: Min=%ld, cPalTot=%ld, cPalChk=%ld, DO_FIXUP=%hs"
                        ARGDW(MAX_FIXUPDIB_PAL) ARGDW(cPalTot) ARGDW(cPalChk)
                        ARGPTR((AAHFlags & AAHF_DO_FIXUPDIB) ? "Yes" : "No")));
        }
    }

    if (pbAlloc) {

        HTFreeMem(pbAlloc);
    }

    pAABBP->AAHFlags = AAHFlags;

    DBGP_IF(DBGP_FUDI | DBGP_CHK_FUDI,
            DBGP("CheckBMPNeedFixup(%ld): DoFixup=%hs, AA=%hs"
                ARGDW(SrcFmt)
                ARGPTR((AAHFlags & AAHF_DO_FIXUPDIB) ? "Yes" : "No")
                ARGPTR((AAHFlags & AAHF_BBPF_AA_OFF) ? "Off" : "On")));

    return((BOOL)(AAHFlags & AAHF_DO_FIXUPDIB));
}




VOID
HTENTRY
InitializeFUDI(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    16-Dec-1998 Wed 17:30:34 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PBGR8   pbgr;
    LPBYTE  pb;
    UINT    cIn;
    UINT    i;


    pAAHdr->FUDI.cyIn = (pAAHdr->Flags & AAHF_TILE_SRC) ?
                                        pAAHdr->DstSurfInfo.cy :
                                        pAAHdr->SrcSurfInfo.cy;
    cIn               = pAAHdr->SrcSurfInfo.cx;

    if (pAAHdr->SrcSurfInfo.Flags & AASIF_GRAY) {

        for (i = 2; i <= 3; i++) {

            pb = (LPBYTE)pAAHdr->FUDI.prgbD[i];

            pAAHdr->SrcSurfInfo.InputFunc(&(pAAHdr->SrcSurfInfo),
                                          (PBGR8)(pb + 1));

            *(pb + 0)       = *(pb + 2);
            *(pb + cIn + 1) = *(pb + cIn - 1);
        }

    } else {

        for (i = 2; i <= 3; i++) {

            pbgr = pAAHdr->FUDI.prgbD[i];

            pAAHdr->SrcSurfInfo.InputFunc(&(pAAHdr->SrcSurfInfo), pbgr + 1);

            *(pbgr + 0)       = *(pbgr + 2);
            *(pbgr + cIn + 1) = *(pbgr + cIn - 1);
        }
    }

    //
    // Save this one in case we need to copy first scan line
    //

    CopyMemory(pAAHdr->FUDI.prgbD[5],
               pAAHdr->FUDI.prgbD[2],
               pAAHdr->FUDI.cbbgr);
    CopyMemory(pAAHdr->FUDI.prgbD[1],
               pAAHdr->FUDI.prgbD[3],
               pAAHdr->FUDI.cbbgr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htgetbmp.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htgetbmp.h


Abstract:

    This module contains all local definitions for the htgetbmp.c


Author:
    28-Mar-1992 Sat 20:54:58 updated  -by-  Daniel Chou (danielc)
        Update it for VGA intensity (16 colors mode), this make all the
        codes update to 4 primaries internal.


    05-Apr-1991 Fri 15:54:23 created  -by-  Daniel Chou (danielc)


[Environment:]

    Printer Driver.


[Notes:]


Revision History:



--*/


#ifndef _HTGETBMP_
#define _HTGETBMP_


#define GET_GRAY_RGB(p)     (((DWORD)((PBGR3)(p))->r << 2) +                \
                             ((DWORD)((PBGR3)(p))->g << 3) +                \
                             ((DWORD)((PBGR3)(p))->b     ))




#define SET_NEXT_PIN(pAASI)                                                 \
{                                                                           \
    if (pAASI->Flags & AASIF_INC_PB) {                                      \
                                                                            \
        if ((pAASI->cy == 0)  || (--pAASI->cy == 0)) {  /*  Bug 27036  */     \
                                                                            \
            if (pAASI->Flags & AASIF_TILE_SRC) {                            \
                                                                            \
                pAASI->pb = pAASI->pbOrg;                                   \
                pAASI->cy = pAASI->cyOrg;                                   \
                                                                            \
            } else {                                                        \
                                                                            \
                pAASI->Flags &= ~AASIF_INC_PB;                              \
            }                                                               \
                                                                            \
        } else {                                                            \
                                                                            \
            pAASI->pb += pAASI->cyNext;                                     \
        }                                                                   \
    }                                                                       \
}


#define GET_LBGR(p)     (LONG)(((DWORD)*(DWORD UNALIGNED *)(p)) & 0xFFFFFF)

#define SET_CORNER_BGR(p, c0, c1, c2, c3)                                   \
{                                                                           \
    LONG    cS = GET_LBGR(p);                                               \
                                                                            \
    (p)->b = (BYTE)((((cS & 0x0000FF) << 3) +                               \
                     ((cS & 0x0000FF) << 2) +                               \
                            0x000008 +                                      \
                      (c0 & 0x0000FF) +                                     \
                      (c1 & 0x0000FF) +                                     \
                      (c2 & 0x0000FF) +                                     \
                      (c3 & 0x0000FF)) >> 4);                               \
    (p)->g = (BYTE)((((cS & 0x00FF00) << 3) +                               \
                     ((cS & 0x00FF00) << 2) +                               \
                            0x000800 +                                      \
                      (c0 & 0x00FF00) +                                     \
                      (c1 & 0x00FF00) +                                     \
                      (c2 & 0x00FF00) +                                     \
                      (c3 & 0x00FF00)) >> (4 + 8));                         \
    (p)->r = (BYTE)((((cS & 0xFF0000) << 3) +                               \
                     ((cS & 0xFF0000) << 2) +                               \
                            0x080000 +                                      \
                      (c0 & 0xFF0000) +                                     \
                      (c1 & 0xFF0000) +                                     \
                      (c2 & 0xFF0000) +                                     \
                      (c3 & 0xFF0000)) >> (4 + 16));                        \
}

#define SET_CORNER_GRAY(p, c0, c1, c2, c3)                                  \
{                                                                           \
    LONG    cS = (LONG)*(p);                                                \
                                                                            \
    *(p) = (BYTE)((((cS) << 3) + ((cS) << 2) + 8 +                          \
                   (c0) + (c1) + (c2) + (c3)) >> 4);                        \
}


#define STD_PAL_CY_SKIP         6
#define MAX_FIXUPDIB_PAL        20
#define MIN_FIXUP_SIZE          (48 * 48)
#define MIN_PAL_SIZE            (128 * 128)
#define GET_PAL_CHK_COUNT(x)    ((x) >> 3)
#define GET_PAL_CHK_COUNT2(x)   ((x) >> 4)



#define ZERO_MASK_SCAN(pAAHdr)  ZeroMemory(pAAHdr->pMaskSrc, pAAHdr->cbMaskSrc)

#define GET_MASK_SCAN(pAAHdr)                                               \
{                                                                           \
    LPBYTE  pbSrc = (LPBYTE)pAAHdr->pMaskIn;                                \
    LPBYTE  pbDst = (LPBYTE)pAAHdr->pMaskSrc;                               \
    UINT    cb    = (UINT)pAAHdr->cbMaskSrc;                                \
    UINT    cdw;                                                            \
                                                                            \
    if (pAAHdr->Flags & AAHF_INVERT_MASK) {                                 \
                                                                            \
        cdw  = cb >> 2;                                                     \
        cb  &= 0x03;                                                        \
                                                                            \
        while (cdw--) {                                                     \
                                                                            \
            *((LPDWORD)pbDst)++ = ~*((LPDWORD)pbSrc)++;                     \
        }                                                                   \
                                                                            \
        while (cb--) {                                                      \
                                                                            \
            *pbDst++ = ~*pbSrc++;                                           \
        }                                                                   \
                                                                            \
    } else {                                                                \
                                                                            \
        CopyMemory(pbDst, pbSrc, cb);                                       \
    }                                                                       \
                                                                            \
    if (--pAAHdr->cyMaskIn > 0) {                                           \
                                                                            \
        pAAHdr->pMaskIn += pAAHdr->cyMaskNext;                              \
    }                                                                       \
}


#define OR_MASK_SCAN(pAAHdr)                                                \
{                                                                           \
    LPBYTE  pbSrc = (LPBYTE)pAAHdr->pMaskIn;                                \
    LPBYTE  pbDst = (LPBYTE)pAAHdr->pMaskSrc;                               \
    UINT    cb    = (UINT)pAAHdr->cbMaskSrc;                                \
    UINT    cdw;                                                            \
                                                                            \
    cdw  = cb >> 2;                                                         \
    cb  &= 0x03;                                                            \
                                                                            \
    if (pAAHdr->Flags & AAHF_INVERT_MASK) {                                 \
                                                                            \
        while (cdw--) {                                                     \
                                                                            \
            *((LPDWORD)pbDst)++ |= ~*((LPDWORD)pbSrc)++;                    \
        }                                                                   \
                                                                            \
        while (cb--) {                                                      \
                                                                            \
            *pbDst++ |= ~*pbSrc++;                                          \
        }                                                                   \
                                                                            \
    } else {                                                                \
                                                                            \
        while (cdw--) {                                                     \
                                                                            \
            *((LPDWORD)pbDst)++ |= *((LPDWORD)pbSrc)++;                     \
        }                                                                   \
                                                                            \
        while (cb--) {                                                      \
                                                                            \
            *pbDst++ |= *pbSrc++;                                           \
        }                                                                   \
    }                                                                       \
                                                                            \
    if (--pAAHdr->cyMaskIn > 0) {                                           \
                                                                            \
        pAAHdr->pMaskIn += pAAHdr->cyMaskNext;                              \
    }                                                                       \
}




//
// Function prototypes
//

VOID
HTENTRY
BltAV_CX(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
ExpandAV_CX(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
ShrinkAV_CX(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
BltAV_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
TileAV_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
ExpandAV_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
ShrinkAV_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
BltMask_CX(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
ExpandMask_CX(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
ShrinkMask_CX(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
BltMask_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
ExpandMask_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
ShrinkMask_CY(
    PAAHEADER   pAAHdr
    );

PBGR8
HTENTRY
Input1BPPToAA24(
    PAASURFINFO pAASI,
    PBGR8       pInBuf
    );

PBGR8
HTENTRY
Input4BPPToAA24(
    PAASURFINFO pAASI,
    PBGR8       pInBuf
    );

PBGR8
HTENTRY
Input8BPPToAA24(
    PAASURFINFO pAASI,
    PBGR8       pInBuf
    );

PBGR8
HTENTRY
InputPreMul32BPPToAA24(
    PAASURFINFO pAASI,
    PBGR8       pInBuf
    );

PBGR8
HTENTRY
InputAABFDATAToAA24(
    PAASURFINFO pAASI,
    PBGR8       pInBuf
    );

PBGR8
HTENTRY
GetFixupScan(
    PAAHEADER   pAAHdr,
    PBGR8       pInBuf
    );

BOOL
CheckBMPNeedFixup(
    PDEVICECOLORINFO    pDCI,
    PAAHEADER           pAAHdr,
    PHTSURFACEINFO      pSrcSI,
    PAABBP              pAABBP
    );

VOID
HTENTRY
InitializeFUDI(
    PAAHEADER   pAAHdr
    );

#if DBG

LPSTR
GetAAInputFuncName(
    AAINPUTFUNC AAInputFunc
    );

#endif


#endif  // _HTGETBMP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htdebug.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htdebug.h


Abstract:

    This module contains all the debug definitions


Author:
    23-Apr-1992 Thu 20:01:55 updated  -by-  Daniel Chou (danielc)
        changed DBG_TIMEx structure fields' 'CHAR' type to 'BYTE' type, this
        will make sure if compiled under MIPS the default 'unsigned char' will
        not affect the signed operation on the single 8 bits

    28-Mar-1992 Sat 20:54:09 updated  -by-  Daniel Chou (danielc)
        change DEF_DBGPVAR() marco so MIPS build does not complaint


    20-Feb-1991 Wed 23:06:36 created  -by-  Daniel Chou (danielc)


[Environment:]

    Printer Driver.


[Notes:]


Revision History:



--*/


#ifndef _HTDEBUG_
#define _HTDEBUG_


#if DBG

#define TIMER_TOT               0
#define TIMER_SETUP             1
#define TIMER_INPUT             2
#define TIMER_OUTPUT            3
#define TIMER_MASK              4
#define TIMER_LAST              5

#define TIMER_MAX_IDX   TIMER_LAST

typedef struct _DBGTIMER {
    DWORD   Last;
    DWORD   Tot;
    } DBGTIMER, *PDBGTIMER;

LPBYTE
HTENTRY
HT_LOADDS
FD6ToString(
    LONG    Num,
    SHORT   IntDigits,
    WORD    FracDigits
    );

VOID
cdecl
HTENTRY
HT_LOADDS
DbgPrintf(
    LPSTR   pStr,
    ...
    );

VOID
HTENTRY
HT_LOADDS
_MyAssert(
    LPSTR   pMsg,
    LPSTR   pFalseExp,
    LPSTR   pFilename,
    WORD    LineNo
    );

LPSTR
HTENTRY
HT_LOADDS
DbgTimeString(
    UINT    Idx
    );


#if defined(_OS2_) || defined(_OS_20_) || defined(_DOS_)

#ifdef _DOS_                    // if Dos Win3

VOID
FAR PASCAL
DebugBreak(
    VOID
    );

#define DEBUGOUTPUTFUNC(x)  OutputDebugString(x)

#else   // if OS2

VOID
HTENTRY
DebugBreak(
    VOID
    );

VOID
FAR PASCAL
DebugOutput(
    LPSTR   pStr
    );

#define DEBUGOUTPUTFUNC(x)  DebugOutput(x)

#endif

#define DBG_INSERT_CR_TO_LF


#else   // OS2/DOS


#undef ASSERTMSG
#undef ASSERT

#ifdef UMODE
    #define DEBUGOUTPUTFUNC(x)  OutputDebugString(x)
#else
    void  DrvDbgPrint(
        char * pch,
        ...);

    #define DEBUGOUTPUTFUNC(x)  DrvDbgPrint(x)
#endif

#define DBG_INSERT_CR_TO_LF

#endif  // OS2/DOS

#define ASSERTMSG(msg, exp)     \
                    if (!(exp)) { _MyAssert(msg, #exp, __FILE__, __LINE__); }

#define ASSERT(exp)             ASSERTMSG("-ERROR-",(exp))

#ifdef UMODE
    #define DBGSTOP()               DebugBreak()
#else
    #define DBGSTOP()               EngDebugBreak()
#endif

#define ARG(x)                  ,(x)
#define ARGB(x)                 ,(BYTE)(x)
#define ARGC(x)                 ,(CHAR)(x)
#define ARGW(x)                 ,(WORD)(x)
#define ARGS(x)                 ,(SHORT)(x)
#define ARGU(x)                 ,(UINT)(x)
#define ARGI(x)                 ,(INT)(x)
#define ARGDW(x)                ,(DWORD)(x)
#define ARGL(x)                 ,(LONG)(x)
#define ARGPTR(x)               ,(LPVOID)(x)
#define ARGFD6(x, i, f)         ,FD6ToString((FD6)(x),(SHORT)(i),(WORD)(f))
#define ARGFD6s(x)              ARGFD6(x,0,0)
#define ARGFD6l(x)              ARGFD6(x,5,6)
#define ARGTIME(i)             ,DbgTimeString(i)

#define DBGP(y)                 DbgPrintf(y)
#define DBGMSG(y)               DbgPrintf(y); DbgPrintf("\n");

#define DEFDBGVAR(type, val)    type val;
#define SETDBGVAR(name, val)    name=val

extern UINT     DbgTimerIdx;
extern DBGTIMER DbgTimer[TIMER_MAX_IDX + 1];


#ifdef UMODE
    #define GET_TICK            (DWORD)GetTickCount()
#else
    #define GET_TICK            (DWORD)0
#endif


#define DBG_TIMER_BEG(i)        DbgTimer[DbgTimerIdx=i].Last=GET_TICK
#define DBG_TIMER_END(i)        DbgTimer[i].Tot+=GET_TICK-DbgTimer[i].Last; \
                                DbgTimerIdx = TIMER_LAST
#define DBG_TIMER_RESET         ZeroMemory(DbgTimer, sizeof(DbgTimer));     \
                                DbgTimerIdx=TIMER_LAST;                     \
                                DbgTimer[TIMER_TOT].Last=GET_TICK

//
// The following macros used for the DBGP_IF()
//

#ifdef DBGP_VARNAME

#define DEF_DBGPVAR(x)   DWORD DBGP_VARNAME = (x);
#define DBGP_IF(v,y)     if ((v) && ((v) & DBGP_VARNAME)) { y; }

#else

#define DEF_DBGPVAR(x)
#define DBGP_IF(v,y)

#endif


#ifdef NODBGMSG

#undef  DBGP
#undef  DBGMSG

#define DBGMSG(x)
#define DBGP(y)

#endif  // NODBGMSG


#else   // DBG != 0

#define ARG(x)
#define ARGB(x)
#define ARGC(x)
#define ARGW(x)
#define ARGS(x)
#define ARGU(x)
#define ARGI(x)
#define ARGDW(x)
#define ARGL(x)
#define ARGFD6(x, i, f)
#define ARGFD6s(x)
#define ARGFD6l(x)
#define ARGTIME(i)

#define DBGSTOP()
#define DBGMSG(x)
#define DBGP(y)

#define DEFDBGVAR(type, val)
#define SETDBGVAR(name, val)

#define DBG_TIMER_BEG(i)
#define DBG_TIMER_END(i)
#define DBG_TIMER_RESET

#define DEF_DBGPVAR(x)
#define DBGP_IF(v,y)


#define ASSERT(exp)
#define ASSERTMSG(msg,exp)


#endif  // DBG != 0


#endif // _HTDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htapi.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htapi.c


Abstract:

    This module contains all the halftone entry points which communicate
    with caller to the halftone dll.


Author:

    05-Feb-1991 Tue 10:52:03 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:


--*/

#define DBGP_VARNAME        dbgpHTAPI

#define _HTAPI_ENTRY_

#include "htp.h"
#include "htmapclr.h"
#include "htpat.h"
#include "htrender.h"
#include "htmath.h"
#include "htalias.h"
#include "htsetbmp.h"
#include "stdio.h"

#define INCLUDE_DEF_CIEINFO
#include "htapi.h"


#define DBGP_SHOWPAT        0x00000001
#define DBGP_TIMER          0x00000002
#define DBGP_CACHED_DCI     0x00000004
#define DBGP_CACHED_SMP     0x00000008
#define DBGP_DISABLE_HT     0x00000010
#define DBGP_DYECORRECTION  0x00000020
#define DBGP_DHI_MEM        0x00000040
#define DBGP_COMPUTE_L2I    0x00000080
#define DBGP_HTMUTEX        0x00000100
#define DBGP_GAMMA_PAL      0x00000200
#define DBGP_CHB            0x00000400
#define DBGP_DEVPELSDPI     0x00000800
#define DBGP_SRCBMP         0x00001000
#define DBGP_TILE           0x00002000
#define DBGP_HTAPI          0x00004000
#define DBGP_MEMLINK        0x00008000
#define DBGP_SHOW_CSMBMP    0x00010000



DEF_DBGPVAR(BIT_IF(DBGP_SHOWPAT,        0)  |
            BIT_IF(DBGP_TIMER,          0)  |
            BIT_IF(DBGP_CACHED_DCI,     0)  |
            BIT_IF(DBGP_CACHED_SMP,     0)  |
            BIT_IF(DBGP_DISABLE_HT,     0)  |
            BIT_IF(DBGP_DYECORRECTION,  0)  |
            BIT_IF(DBGP_DHI_MEM,        0)  |
            BIT_IF(DBGP_COMPUTE_L2I,    0)  |
            BIT_IF(DBGP_HTMUTEX,        0)  |
            BIT_IF(DBGP_GAMMA_PAL,      0)  |
            BIT_IF(DBGP_CHB,            0)  |
            BIT_IF(DBGP_DEVPELSDPI,     0)  |
            BIT_IF(DBGP_SRCBMP,         0)  |
            BIT_IF(DBGP_TILE,           0)  |
            BIT_IF(DBGP_HTAPI,          0)  |
            BIT_IF(DBGP_MEMLINK,        0)  |
            BIT_IF(DBGP_SHOW_CSMBMP,    0))


HTGLOBAL    HTGlobal = { (HMODULE)NULL,
                         (HTMUTEX)NULL,
                         (HTMUTEX)NULL,
                         (HTMUTEX)NULL,
                         (PCDCIDATA)NULL,
                         (PCSMPDATA)NULL,
                         (PBGRMAPCACHE)NULL,
                         (LONG)0,
                         (LONG)0,
                         (LONG)0,
                         (WORD)0,
                         (WORD)0
                       };

#define DO_DYES_CORRECTION      0

#define CMY_8BPP(b, i, m, t)                                                \
{                                                                           \
    if ((i) < (m)) {                                                        \
                                                                            \
        (t) = FD6_1 - DivFD6((FD6)(i),(FD6)(m));                            \
        (b) = (BYTE)SCALE_FD6((t), 255);                                    \
                                                                            \
    } else {                                                                \
                                                                            \
        (b) = 0;                                                            \
    }                                                                       \
}


#define RGB_8BPP(rgb)       (BYTE)SCALE_FD6((rgb), 255)
#define GET_DEN_LO(x)       DivFD6((FD6)((((x)     ) & 0xFF) + 1), (FD6)256)
#define GET_DEN_HI(x)       DivFD6((FD6)((((x) >> 8) & 0xFF) + 1), (FD6)256)


#if DBG


LONG
HTENTRY
HT_LOADDS
SetHalftoneError(
    DWORD   HT_FuncIndex,
    LONG    ErrorID
    )
{
    const static  LPSTR   HTApiFuncName[] = {

                        "HalftoneInitProc",
                        "HT_CreateDeviceHalftoneInfo",
                        "HT_DestroyDeviceHalftoneInfo",
                        "HT_CreateHalftoneBrush",
                        "HT_ConvertColorTable",
                        "HT_CreateStandardMonoPattern",
                        "HT_HalftoneBitmap",
                    };


    const static  LPSTR   HTErrorStr[] = {

                        "WRONG_VERSION_HTINITINFO",
                        "INSUFFICIENT_MEMORY",
                        "CANNOT_DEALLOCATE_MEMORY",
                        "COLORTABLE_TOO_BIG",
                        "QUERY_SRC_BITMAP_FAILED",
                        "QUERY_DEST_BITMAP_FAILED",
                        "QUERY_SRC_MASK_FAILED",
                        "SET_DEST_BITMAP_FAILED",
                        "INVALID_SRC_FORMAT",
                        "INVALID_SRC_MASK_FORMAT",
                        "INVALID_DEST_FORMAT",
                        "INVALID_DHI_POINTER",
                        "SRC_MASK_BITS_TOO_SMALL",
                        "INVALID_HTPATTERN_INDEX",
                        "INVALID_HALFTONE_PATTERN",
                        "HTPATTERN_SIZE_TOO_BIG",
                        "NO_SRC_COLORTRIAD",
                        "INVALID_COLOR_TABLE",
                        "INVALID_COLOR_TYPE",
                        "INVALID_COLOR_TABLE_SIZE",
                        "INVALID_PRIMARY_SIZE",
                        "INVALID_PRIMARY_VALUE_MAX",
                        "INVALID_PRIMARY_ORDER",
                        "INVALID_COLOR_ENTRY_SIZE",
                        "INVALID_FILL_SRC_FORMAT",
                        "INVALID_FILL_MODE_INDEX",
                        "INVALID_STDMONOPAT_INDEX",
                        "INVALID_DEVICE_RESOLUTION",
                        "INVALID_TONEMAP_VALUE",
                        "NO_TONEMAP_DATA",
                        "TONEMAP_VALUE_IS_SINGULAR",
                        "INVALID_BANDRECT",
                        "STRETCH_RATIO_TOO_BIG",
                        "CHB_INV_COLORTABLE_SIZE",
                        "HALFTONE_INTERRUPTTED",
                        "HTERR_NO_SRC_HTSURFACEINFO",
                        "HTERR_NO_DEST_HTSURFACEINFO",
                        "HTERR_8BPP_PATSIZE_TOO_BIG",
                        "HTERR_16BPP_555_PATSIZE_TOO_BIG"
                    };

    const static LPSTR    HTPErrorStr[] = {

                        "STRETCH_FACTOR_TOO_BIG",
                        "XSTRETCH_FACTOR_TOO_BIG",
                        "STRETCH_NEG_OVERHANG",
                        "COLORSPACE_NOT_MATCH",
                        "INVALID_SRCRGB_SIZE",
                        "INVALID_DEVRGB_SIZE"
                    };


    LPSTR   pFuncName;
    LONG    ErrorIdx;
    BOOL    MapErrorOk = FALSE;

    if (ErrorID < 0) {

        if (HT_FuncIndex < (sizeof(HTApiFuncName) / sizeof(LPSTR))) {

            pFuncName = HTApiFuncName[HT_FuncIndex];

        } else {

            pFuncName = "Invalid HT API Function Name";
        }

        ErrorIdx = -ErrorID;

        if (ErrorIdx <= (sizeof(HTErrorStr) / sizeof(LPSTR))) {

            DBGP("%s failed: HTERR_%s (%ld)"
                            ARG(pFuncName)
                            ARG(HTErrorStr[ErrorIdx - 1])
                            ARGL(ErrorID));
            DBGP("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");

            MapErrorOk = TRUE;

        } else if (ErrorIdx >= -(LONG)HTERR_INTERNAL_ERRORS_START) {

            ErrorIdx += (LONG)HTERR_INTERNAL_ERRORS_START;

            if (ErrorIdx < (sizeof(HTPErrorStr) / sizeof(LPSTR))) {

                DBGP("%s Internal Error: %s (%ld)"
                            ARG(pFuncName)
                            ARG(HTPErrorStr[ErrorIdx])
                            ARGL(ErrorID));
                DBGP("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");

                MapErrorOk = TRUE;
            }

        }

        if (!MapErrorOk) {

            DBGP("%s failed: ??Invalid Error ID (%ld)"
                                        ARG(pFuncName) ARGL(ErrorID));
            DBGP("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
        }
    }

    return(ErrorID);
}

#endif




BOOL
PASCAL
HT_LOADDS
EnableHalftone(
    VOID
    )

/*++

Routine Description:

    This function initialize all internal halftone global data to have
    halftone DLL/LIB ready to be used

    This function MUST called from ALL API entries which does not required
    a PDEVICEHALFTONEINFO data pointer

Arguments:

    None


Return Value:

    None

Author:

    02-Mar-1993 Tue 19:38:43 created  -by-  Daniel Chou (danielc)

    15-Dec-1995 Fri 16:48:46 updated  -by-  Daniel Chou (danielc)
        All initialization is done at here

Revision History:


--*/

{

    FD6     L;
    UINT    i;


    if (!(HTGlobal.HTMutexBGRMC = CREATE_HTMUTEX())) {

        DBGMSG("InitHTInternalData: CREATE_HTMUTEX(HTMutexBGRMC) failed!");
        return(FALSE);
    }

    HTGlobal.pBGRMC      = NULL;
    HTGlobal.cBGRMC      =
    HTGlobal.cIdleBGRMC  =
    HTGlobal.cAllocBGRMC = 0;

    if (!(HTGlobal.HTMutexCDCI = CREATE_HTMUTEX())) {

        DBGMSG("InitHTInternalData: CREATE_HTMUTEX(HTMutexCDCI) failed!");
        return(FALSE);
    }

    HTGlobal.CDCICount = 0;

    if (!(HTGlobal.HTMutexCSMP = CREATE_HTMUTEX())) {

        DBGMSG("InitHTInternalData: CREATE_HTMUTEX(HTMutexCSMP) failed!");

        return(FALSE);
    }

    HTGlobal.CSMPCount = 0;

    return(TRUE);
}




VOID
PASCAL
HT_LOADDS
DisableHalftone(
    VOID
    )

/*++

Routine Description:

    This function free CDCI/CSMP cached data

Arguments:

    none.

Return Value:

    BOOL

    This function must called when gdisrv.dll is unloaded, sinnce halftone
    is a linked as a library not a individual DLL.

Author:

    20-Feb-1991 Wed 18:42:11 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    HLOCAL          hData;
    PCDCIDATA       pCDCIData;
    PCSMPDATA       pCSMPData;
    PCSMPBMP        pCSMPBmp;
    LONG            i;
    extern LPWORD   ppwHTPat[HTPAT_SIZE_MAX_INDEX];

    DBGP_IF(DBGP_DISABLE_HT,
            DBGP("FreeHTGlobal: UsedCount: CDCI=%u, CSMP=%u"
                 ARGU(HTGlobal.CDCICount)
                 ARGU(HTGlobal.CSMPCount)));

    //
    // Do the BGRMapCache first
    //

    ACQUIRE_HTMUTEX(HTGlobal.HTMutexBGRMC);

    if (HTGlobal.pBGRMC) {

        for (i = 0; i < HTGlobal.cBGRMC; i++) {

            hData = (HLOCAL)HTGlobal.pBGRMC[i].pMap;

            DBGP_IF(DBGP_DISABLE_HT,
                    DBGP("FreeHTGlobal: HTFreeMem(pBGRMC[%ld].pMap=%p"
                        ARGDW(i) ARGPTR(hData)));

            hData     = HTFreeMem(hData);

            ASSERTMSG("FreeHTGlobal: HTFreeMem(BGRMap) Failed", !hData);
        }

        hData = (HLOCAL)HTGlobal.pBGRMC;

        DBGP_IF(DBGP_DISABLE_HT,
                DBGP("FreeHTGlobal: HTFreeMem(pBGRMC=%p" ARGPTR(hData)));

        hData = HTFreeMem(hData);

        ASSERTMSG("FreeHTGlobal: HTFreeMem(pBGRMC) Failed", !hData);
    }

    HTGlobal.cBGRMC      =
    HTGlobal.cIdleBGRMC  =
    HTGlobal.cAllocBGRMC = 0;
    HTGlobal.pBGRMC      = NULL;

    RELEASE_HTMUTEX(HTGlobal.HTMutexBGRMC);
    DELETE_HTMUTEX(HTGlobal.HTMutexBGRMC);

    //
    // Do the CDCI Data first
    //

    ACQUIRE_HTMUTEX(HTGlobal.HTMutexCDCI);

    pCDCIData = HTGlobal.pCDCIDataHead;

    while (hData = (HLOCAL)pCDCIData) {

        DBGP_IF(DBGP_DISABLE_HT,
                DBGP("FreeHTGlobal: HTFreeMem(pCDCIDATA=%p"
                    ARGPTR(pCDCIData)));

        pCDCIData = pCDCIData->pNextCDCIData;
        hData     = HTFreeMem(hData);

        ASSERTMSG("FreeHTGlobal: HTFreeMem(CDCI) Failed", !hData);
    }

    HTGlobal.pCDCIDataHead = NULL;
    HTGlobal.CDCICount     = 0;

    RELEASE_HTMUTEX(HTGlobal.HTMutexCDCI);
    DELETE_HTMUTEX(HTGlobal.HTMutexCDCI);

    HTGlobal.HTMutexCDCI = (HTMUTEX)0;

    //
    //  Do the bitmap pattern now
    //

    ACQUIRE_HTMUTEX(HTGlobal.HTMutexCSMP);

    pCSMPData = HTGlobal.pCSMPDataHead;

    while (pCSMPData) {

        pCSMPBmp = pCSMPData->pCSMPBmpHead;

        while (hData = (HLOCAL)pCSMPBmp) {

            DBGP_IF(DBGP_DISABLE_HT,
                    DBGP("FreeHTGlobal:    HTFreeMem(pCSMPBmp=%p"
                    ARGPTR(pCSMPBmp)));

            pCSMPBmp = pCSMPBmp->pNextCSMPBmp;
            hData    = HTFreeMem(hData);

            ASSERTMSG("FreeHTGlobal: HTFreeMem(CSMPBMP) Failed", !hData);
        }

        hData     = (HLOCAL)pCSMPData;
        pCSMPData = pCSMPData->pNextCSMPData;
        hData     = HTFreeMem(hData);

        DBGP_IF(DBGP_DISABLE_HT,
                DBGP("FreeHTGlobal: HTFreeMem(pCSMPData=%p"
                ARGPTR(pCSMPData)));

        ASSERTMSG("FreeHTGlobal: HTFreeMem(CSMPDATA) Failed", !hData);
    }

    HTGlobal.pCSMPDataHead = NULL;
    HTGlobal.CSMPCount     = 0;

    for (i = 0; i < HTPAT_SIZE_MAX_INDEX; i++) {

        if (hData = (HLOCAL)ppwHTPat[i]) {

            DBGP_IF(DBGP_DISABLE_HT,
                    DBGP("FreeHTPat: HTFreeMem(ppwHTPat[%2ld]=%p"
                                ARGDW(i) ARGPTR(hData)));

            HTFreeMem(hData);
            ppwHTPat[i] = NULL;
        }
    }

    CHK_MEM_LEAK(NULL, HTMEM_BEGIN);

    RELEASE_HTMUTEX(HTGlobal.HTMutexCSMP);
    DELETE_HTMUTEX(HTGlobal.HTMutexCSMP);

    HTGlobal.HTMutexCSMP = (HTMUTEX)NULL;
}




BOOL
HTENTRY
CleanUpDHI(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo
    )

/*++

Routine Description:

    This function clean up (free hMutex/memory) of a DeviceHalftoneInfo

Arguments:

    pDeviceHalftoneInfo - the pDeviceHalftoneInfo must be valid

Return Value:

    BOOL


Author:

    20-Feb-1991 Wed 18:42:11 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    PDEVICECOLORINFO    pDCI;
    HTMUTEX             HTMutex;
    HLOCAL              hData;
    UINT                Loop;
    BOOL                Ok = TRUE;



    pDCI = PDHI_TO_PDCI(pDeviceHalftoneInfo);

    ACQUIRE_HTMUTEX(pDCI->HTMutex);

    HTMutex = pDCI->HTMutex;

    //
    // Free all memory assoicated with this device
    //

    if ((pDCI->HTCell.pThresholds)  &&
        (!(pDCI->HTCell.Flags & HTCF_STATIC_PTHRESHOLDS))) {

        DBGP_IF(DBGP_DHI_MEM,
                DBGP("CleanUpDHI: HTFreeMem(pDCI->HTCell.pThresholds=%p)"
                ARGPTR(pDCI->HTCell.pThresholds)));

        if (HTFreeMem(pDCI->HTCell.pThresholds)) {

            ASSERTMSG("CleanUpDHI: FreeMemory(pDCI->HTCell.pThresholds)", FALSE);
            Ok = FALSE;
        }
    }

    if (hData = (HLOCAL)pDCI->pAlphaBlendBGR) {

        DBGP_IF(DBGP_DHI_MEM,
                DBGP("CleanUpDHI: HTFreeMem(pDCI->pAlphaBlendBGR=%p)"
                ARGPTR(hData)));

        if (HTFreeMem(hData)) {

            ASSERTMSG("CleanUpDHI: FreeMemory(pDCI->pAlphaBlendBGR)", FALSE);
            Ok = FALSE;
        }
    }

    Loop = CRTX_TOTAL_COUNT;

    while (Loop--) {

        if (hData = (HLOCAL)pDCI->CRTX[Loop].pFD6XYZ) {

            DBGP_IF(DBGP_DHI_MEM,
                    DBGP("CleanUpDHI: HTFreeMem(pDCI->CRTX[%u].pFD6XYZ=%p)"
                    ARGU(Loop) ARGPTR(hData)));

            if (HTFreeMem(hData)) {

                ASSERTMSG("CleanUpDHI: FreeMemory(pDCI->CRTX[])", FALSE);
                Ok = FALSE;
            }
        }
    }

    DBGP_IF(DBGP_DHI_MEM,
            DBGP("CleanUpDHI: HTFreeMem(pDHI=%p)"
            ARGPTR(pDeviceHalftoneInfo)));

    if (HTFreeMem(pDeviceHalftoneInfo)) {

        ASSERTMSG("CleanUpDHI: FreeMemory(pDeviceHalftoneInfo)", FALSE);
        Ok = FALSE;
    }

    RELEASE_HTMUTEX(HTMutex);
    DELETE_HTMUTEX(HTMutex);

    return(Ok);
}


BOOL
APIENTRY
HT_LOADDS
HalftoneInitProc(
    HMODULE hModule,
    DWORD   Reason,
    LPVOID  Reserved
    )
/*++

Routine Description:

    This function is DLL main entry point, at here we will save the module
    handle, in the future we will need to do other initialization stuff.

Arguments:

    hModule     - Handle to this moudle when get loaded.

    Reason      - may be DLL_PROCESS_ATTACH

    Reserved    - reserved

Return Value:

    Always return 1L


Author:

    20-Feb-1991 Wed 18:42:11 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    UNREFERENCED_PARAMETER(Reserved);


    switch(Reason) {

    case DLL_PROCESS_ATTACH:

        DBGP_IF((DBGP_CACHED_DCI | DBGP_CACHED_SMP),
                DBGP("\n****** DLL_PROCESS_ATTACH ******\n"));

        HTGlobal.hModule = hModule;
        EnableHalftone();

        break;


    case DLL_PROCESS_DETACH:

        DBGP_IF((DBGP_CACHED_DCI | DBGP_CACHED_SMP),
                DBGP("\n****** DLL_PROCESS_DETACH ******\n"));

        DisableHalftone();
        break;
    }

    return(TRUE);
}


#if DO_CACHE_DCI


PCDCIDATA
HTENTRY
FindCachedDCI(
    PDEVICECOLORINFO    pDCI
    )

/*++

Routine Description:

    This function will try to find the cached DEVICECOLORINFO and put the
    cached data to the pDCI

Arguments:

    pDCI    - Pointer to current device color info


Return Value:

    INT,  Index number to the PCDCI.Header[] array, if return value is < 0 then
    the CachedDCI data is not found.

Author:

    01-May-1992 Fri 13:10:14 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PCDCIDATA       pCurCDCIData;
    DEFDBGVAR(UINT, SearchIndex = 0)


    ACQUIRE_HTMUTEX(HTGlobal.HTMutexCDCI);

    if (pCurCDCIData = HTGlobal.pCDCIDataHead) {

        PCDCIDATA   pPrevCDCIData = NULL;
        DWORD       Checksum = pDCI->HTInitInfoChecksum;


        DBGP_IF(DBGP_CACHED_DCI,
                DBGP("FindCDCI: Looking for Checksum (0x%08lx), Count=%u"
                    ARGDW(Checksum) ARGU(HTGlobal.CDCICount)));

        ASSERT(HTGlobal.CDCICount);

        while (pCurCDCIData) {

            if (pCurCDCIData->Checksum == Checksum) {

                DBGP_IF(DBGP_CACHED_DCI,
                        DBGP("FindCDCI: Found %08lx [CheckSum=%08lx] after %u links, pPrev=%p"
                            ARG(pCurCDCIData)
                            ARGDW(Checksum)
                            ARGU(SearchIndex)
                            ARGPTR(pPrevCDCIData)));

                if (pPrevCDCIData) {

                    //
                    // The most recent reference's DCI always as first entry,
                    // (ie. Link Head), the last is the longest unreferenced
                    // so that if we need to delete a DCI, we delete the
                    // last one.
                    //

                    DBGP_IF(DBGP_CACHED_DCI,
                            DBGP("FindCDCI: Move pCur to pHead"));

                    pPrevCDCIData->pNextCDCIData = pCurCDCIData->pNextCDCIData;
                    pCurCDCIData->pNextCDCIData  = HTGlobal.pCDCIDataHead;
                    HTGlobal.pCDCIDataHead       = pCurCDCIData;
                }

                return(pCurCDCIData);
            }

            SETDBGVAR(SearchIndex, SearchIndex + 1);

            pPrevCDCIData = pCurCDCIData;
            pCurCDCIData  = pCurCDCIData->pNextCDCIData;
        }

        DBGP_IF(DBGP_CACHED_DCI, DBGP("FindCDCI: ??? NOT FOUND ???"));

    } else {

        DBGP_IF(DBGP_CACHED_DCI, DBGP("FindCDCI: ++No CDCIDATA cahced yet++"));
    }

    RELEASE_HTMUTEX(HTGlobal.HTMutexCDCI);

    return(NULL);
}




BOOL
HTENTRY
AddCachedDCI(
    PDEVICECOLORINFO    pDCI
    )

/*++

Routine Description:

    This function add the DEVICECOLORINFO information to the DCI cache

Arguments:

    pDCI        - Pointer to current device color info

    Lock        - TRUE if need to keep the hMutex locked, (only if add is
                  sucessfully)

Return Value:

    INT,  Index number to the PCDCI.Header[] array where the new data is added,
    if return value is < 0 then the pDCI'CachedDCI data did not add to the
    cached array.

    NOTE: If AddCachedDCI() return value >= 0 and Lock=TRUE then caller must
          release the PCDCI.hMutex after done with the data, if return value
          is < 0 then no unlock is necessary.


Author:

    01-May-1992 Fri 13:24:58 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PCDCIDATA   pCurCDCIData;
    PCDCIDATA   pPrevCDCIData;
    DWORD       AllocSize;
    DWORD       SizeCell;


    ACQUIRE_HTMUTEX(HTGlobal.HTMutexCDCI);

    //
    // We only cached CDCIDATA to certain extend, if we over that limit then
    // delete the last entry in the link list before adding anything
    //

    if (HTGlobal.CDCICount >= MAX_CDCI_COUNT) {

        ASSERT(HTGlobal.pCDCIDataHead);

        pCurCDCIData  = HTGlobal.pCDCIDataHead;
        pPrevCDCIData = NULL;

        while (pCurCDCIData->pNextCDCIData) {

            pPrevCDCIData = pCurCDCIData;
            pCurCDCIData  = pCurCDCIData->pNextCDCIData;
        }

        ASSERT(pPrevCDCIData);

        DBGP_IF(DBGP_CACHED_DCI,
                DBGP("AddCDCI: CDCICount >= %u, Free pLast=%p"
                ARGU(MAX_CDCI_COUNT)
                ARGPTR(pCurCDCIData)));

        if (HTFreeMem(pCurCDCIData)) {

            ASSERTMSG("AddCDCI: HTFreeMem(pLastCDCIData) Failed", FALSE);
        }

        pPrevCDCIData->pNextCDCIData = NULL;
        --HTGlobal.CDCICount;
    }

    if (pDCI->HTCell.Flags & HTCF_STATIC_PTHRESHOLDS) {

        SizeCell = 0;

    } else {

        SizeCell  = (DWORD)pDCI->HTCell.Size;
    }

    AllocSize = (DWORD)SizeCell + (DWORD)sizeof(CDCIDATA);

    DBGP_IF(DBGP_CACHED_DCI,
            DBGP("  AddCDCI: HTAllocMem(CDCIDATA(%ld) + Cell(%ld)) = %ld bytes"
                    ARGDW(sizeof(CDCIDATA))
                    ARGDW(SizeCell) ARGDW(AllocSize)));

    if (pCurCDCIData = (PCDCIDATA)HTAllocMem(NULL,
                                             HTMEM_CurCDCIData,
                                             NONZEROLPTR,
                                             AllocSize)) {

        //
        // put this data at link list head
        //

        pCurCDCIData->Checksum      = pDCI->HTInitInfoChecksum;
        pCurCDCIData->pNextCDCIData = HTGlobal.pCDCIDataHead;
        pCurCDCIData->ClrXFormBlock = pDCI->ClrXFormBlock;
        pCurCDCIData->DCIFlags      = pDCI->Flags;
        pCurCDCIData->DevResXDPI    = pDCI->DeviceResXDPI;
        pCurCDCIData->DevResYDPI    = pDCI->DeviceResYDPI;
        pCurCDCIData->DevPelRatio   = pDCI->DevPelRatio;
        pCurCDCIData->HTCell        = pDCI->HTCell;

        if (SizeCell) {

            CopyMemory((LPBYTE)(pCurCDCIData + 1),
                       (LPBYTE)pDCI->HTCell.pThresholds,
                       SizeCell);

            pCurCDCIData->HTCell.pThresholds = NULL;
        }

        HTGlobal.pCDCIDataHead = pCurCDCIData;
        ++HTGlobal.CDCICount;


        DBGP_IF(DBGP_CACHED_DCI,
                DBGP("  AddCDCI: CDCIHeader, UsedCount=%u, pHead=%p, [%08lx]"
                            ARGU(HTGlobal.CDCICount)
                            ARGPTR(pCurCDCIData)
                            ARGDW(pCurCDCIData->Checksum)));

    } else {

        ASSERTMSG("AddCDCI: HTAllocMem(pCDCIData) Failed", FALSE);
    }

    RELEASE_HTMUTEX(HTGlobal.HTMutexCDCI);

    return((pCurCDCIData) ? TRUE : FALSE);
}




BOOL
HTENTRY
GetCachedDCI(
    PDEVICECOLORINFO    pDCI
    )

/*++

Routine Description:

    This function will try to find the cached DEVICECOLORINFO and put the
    cached data to the pDCI

Arguments:

    pDCI        - Pointer to current device color info


Return Value:

    BOOLEAN

Author:

    01-May-1992 Fri 13:10:14 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PCDCIDATA   pCDCIData;
    BOOL        GetOk = FALSE;


    if (pCDCIData = FindCachedDCI(pDCI)) {

        pDCI->ClrXFormBlock = pCDCIData->ClrXFormBlock;
        pDCI->Flags         = pCDCIData->DCIFlags;
        pDCI->DeviceResXDPI = pCDCIData->DevResXDPI;
        pDCI->DeviceResYDPI = pCDCIData->DevResYDPI;
        pDCI->DevPelRatio   = pCDCIData->DevPelRatio;
        pDCI->HTCell        = pCDCIData->HTCell;

        if (pDCI->HTCell.Flags & HTCF_STATIC_PTHRESHOLDS) {

            GetOk = TRUE;

        } else if (pDCI->HTCell.pThresholds =
                            (LPBYTE)HTAllocMem((LPVOID)pDCI,
                                               HTMEM_GetCacheThreshold,
                                               NONZEROLPTR,
                                               pDCI->HTCell.Size)) {

            CopyMemory((LPBYTE)pDCI->HTCell.pThresholds,
                       (LPBYTE)(pCDCIData + 1),
                       pDCI->HTCell.Size);

            GetOk = TRUE;

        } else {

            DBGMSG("GetCDCI: HTAllocMem(Thresholds) failed");
        }

        RELEASE_HTMUTEX(HTGlobal.HTMutexCDCI);
    }

    return(GetOk);
}

#endif  // DO_CACHE_DCI



#if DBG


VOID
HTENTRY
DbgDumpCSMPBMP(
    VOID
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    25-Mar-1999 Thu 17:49:53 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PCSMPDATA   pCSMPData;
    UINT        c0 = 0;

    pCSMPData = HTGlobal.pCSMPDataHead;

    while (pCSMPData) {

        PCSMPBMP    pCSMPBmp;
        UINT        c1 = 0;

        DBGP_IF(DBGP_SHOW_CSMBMP,
                DBGP("cDatas=%3ld: Checksum=%08lx"
                        ARGDW(++c0) ARGDW(pCSMPData->Checksum)));

        pCSMPBmp = pCSMPData->pCSMPBmpHead;

        while (pCSMPBmp) {

            DBGP_IF(DBGP_SHOW_CSMBMP,
                    DBGP("    %3ld: Idx=%2ld, %4ldx%4ld=%4ld"
                            ARGDW(++c1)
                            ARGDW(pCSMPBmp->PatternIndex)
                            ARGDW(pCSMPBmp->cxPels)
                            ARGDW(pCSMPBmp->cyPels)
                            ARGDW(pCSMPBmp->cxBytes)));



            pCSMPBmp = pCSMPBmp->pNextCSMPBmp;
        }

        pCSMPData = pCSMPData->pNextCSMPData;
    }

    if (c0 != (UINT)HTGlobal.CSMPCount) {

        DBGP("c0 (%ld) != CSMPCount (%ld)"
                ARGDW(c0) ARGDW(HTGlobal.CSMPCount));
    }
}


#endif


PCSMPBMP
HTENTRY
FindCachedSMP(
    PDEVICECOLORINFO    pDCI,
    UINT                PatternIndex
    )

/*++

Routine Description:

    This function will try to find the cached DEVICECOLORINFO and put the
    cached data to the pDCI

Arguments:

    pDCI    - Pointer to current device color info


Return Value:

    INT,  Index number to the PCDCI.Header[] array, if return value is < 0 then
    the CachedDCI data is not found.

Author:

    01-May-1992 Fri 13:10:14 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PCSMPDATA       pPrevCSMPData;
    PCSMPDATA       pCurCSMPData;
    PCSMPBMP        pCurCSMPBmp;
    DWORD           Checksum = pDCI->HTSMPChecksum;
    DEFDBGVAR(UINT, SearchIndex = 0)


    ACQUIRE_HTMUTEX(HTGlobal.HTMutexCSMP);

    DBGP_IF(DBGP_SHOW_CSMBMP, DbgDumpCSMPBMP(); );

    if (pCurCSMPData = HTGlobal.pCSMPDataHead) {

        pPrevCSMPData = NULL;

        DBGP_IF(DBGP_CACHED_DCI,
                DBGP(">>FindCSMP: Looking for Checksum (0x%08lx), Count=%u"
                    ARGDW(Checksum) ARGU(HTGlobal.CSMPCount)));

        ASSERT(HTGlobal.CSMPCount);

        while (pCurCSMPData) {

            if (pCurCSMPData->Checksum == Checksum) {

                DBGP_IF(DBGP_CACHED_SMP,
                        DBGP(">>FindCSMP: Found after %u links, pPrev=%p"
                            ARGU(SearchIndex)
                            ARGPTR(pPrevCSMPData)));

                if (pPrevCSMPData) {

                    //
                    // The most recent reference's CSMPDATA always as first
                    // entry,(ie. Link Head), the last is the longest
                    // unreferenced so that if we need to delete a CSMPDATA,
                    // we delete the last one.
                    //

                    DBGP_IF(DBGP_CACHED_SMP,
                            DBGP(">>FindCSMP: Move pCur to pHead"));

                    pPrevCSMPData->pNextCSMPData = pCurCSMPData->pNextCSMPData;
                    pCurCSMPData->pNextCSMPData  = HTGlobal.pCSMPDataHead;
                    HTGlobal.pCSMPDataHead       = pCurCSMPData;
                }

                //
                // See we cached any pattern for this group
                //

                pCurCSMPBmp = pCurCSMPData->pCSMPBmpHead;

                SETDBGVAR(SearchIndex, 0);

                while (pCurCSMPBmp) {

                    if ((UINT)pCurCSMPBmp->PatternIndex == PatternIndex) {

                        DBGP_IF(DBGP_CACHED_SMP,
                                DBGP(">>FindCSMP: Found Pat(%u) after %u links"
                                ARGU(PatternIndex)
                                ARGU(SearchIndex++)));

                        return(pCurCSMPBmp);
                    }

                    pCurCSMPBmp = pCurCSMPBmp->pNextCSMPBmp;
                }

                //
                // Found in this group but no bitmap for PatternIndex is
                // cached yet!
                //

                break;
            }

            SETDBGVAR(SearchIndex, SearchIndex + 1);

            pPrevCSMPData = pCurCSMPData;
            pCurCSMPData  = pCurCSMPData->pNextCSMPData;
        }

        DBGP_IF(DBGP_CACHED_SMP, DBGP(">>FindCSMP: ??? NOT FOUND ???"));

    } else {

        DBGP_IF(DBGP_CACHED_DCI, DBGP(">>FindCSMP: ++No CSMPDATA cahced yet++"));
    }

    if (!pCurCSMPData) {

        //
        // Since we did not even found the CSMPDATA checksum group, we want to
        // add it in there, but We only cached CSMPDATA to certain extend, if
        // we over that limit then delete the last entry in the link list
        // before adding anything
        //

        if (HTGlobal.CSMPCount >= MAX_CSMP_COUNT) {

            HLOCAL  hData;


            ASSERT(HTGlobal.pCSMPDataHead);

            pPrevCSMPData = NULL;
            pCurCSMPData  = HTGlobal.pCSMPDataHead;

            while (pCurCSMPData->pNextCSMPData) {

                pPrevCSMPData = pCurCSMPData;
                pCurCSMPData  = pCurCSMPData->pNextCSMPData;
            }

            ASSERT(pPrevCSMPData);

            //
            // Free all the allocated cached standard mono pattern bitmap for
            // this group
            //

            pCurCSMPBmp = pCurCSMPData->pCSMPBmpHead;

            DBGP_IF(DBGP_CACHED_SMP,
                DBGP(">>FindCSMP: CSMPCount >= %u, Free pLast=%p"
                     ARGU(MAX_CSMP_COUNT) ARGPTR(pCurCSMPData)));

            while (hData = (HLOCAL)pCurCSMPBmp) {

                pCurCSMPBmp = pCurCSMPBmp->pNextCSMPBmp;

                DBGP_IF(DBGP_CACHED_SMP,
                        DBGP(">>FindCSMP: Free pLastCSMPBmp=%p" ARGPTR(hData)));

                if (HTFreeMem(hData)) {

                    ASSERTMSG(">>FindCSMP: HTFreeMem(pCurCSMBmp) Failed", FALSE);
                }
            }

            //
            // Now free the header for the CSMPDATA
            //

            if (HTFreeMem(pCurCSMPData)) {

                ASSERTMSG(">>FindCSMP: HTFreeMem(pLastCSMPData) Failed", FALSE);
            }

            pPrevCSMPData->pNextCSMPData = NULL;
            --HTGlobal.CSMPCount;
        }

        if (pCurCSMPData = (PCSMPDATA)HTAllocMem((LPVOID)NULL,
                                                 HTMEM_CurCSMPData,
                                                 NONZEROLPTR,
                                                 sizeof(CSMPDATA))) {

            //
            // Make this one as the link list head
            //

            pCurCSMPData->Checksum      = Checksum;
            pCurCSMPData->pNextCSMPData = HTGlobal.pCSMPDataHead;
            pCurCSMPData->pCSMPBmpHead  = NULL;

            HTGlobal.pCSMPDataHead      = pCurCSMPData;
            ++HTGlobal.CSMPCount;

            DBGP_IF(DBGP_CACHED_SMP,
                DBGP("  >>FindCSMP: Add CSMPDATA, UsedCount=%u, pHead=%p"
                            ARGU(HTGlobal.CSMPCount) ARGPTR(pCurCSMPData)));

        } else {

            DBGMSG("  >>FindCSMP: HTAllocMem(CSMPDATA) Failed");
        }
    }

    //
    // Do allocate new pattern only if we have header
    //

    if (pCurCSMPData) {

        STDMONOPATTERN  SMP;
        DWORD           Size;


        SMP.Flags              = SMP_TOPDOWN;
        SMP.ScanLineAlignBytes = (BYTE)sizeof(BYTE);
        SMP.PatternIndex       = (BYTE)PatternIndex;
        SMP.LineWidth          = DEFAULT_SMP_LINE_WIDTH;
        SMP.LinesPerInch       = DEFAULT_SMP_LINES_PER_INCH;
        SMP.pPattern           = NULL;

        //
        // Find out the size for the pattern bitmap (BYTE Aligned)
        //

        Size = (DWORD)CreateStandardMonoPattern(pDCI, &SMP) +
               (DWORD)sizeof(CSMPBMP);

        DBGP_IF(DBGP_CACHED_SMP,
                DBGP(">>FindCSMP: Add PatternIndex=%u, sz=%ld, DPI(X=%u, Y=%u, P=%u)"
                        ARGU(PatternIndex)
                        ARGU(Size)
                        ARGU(pDCI->DeviceResXDPI)
                        ARGU(pDCI->DeviceResYDPI)
                        ARGU(pDCI->DevPelRatio)));

        if (pCurCSMPBmp = (PCSMPBMP)HTAllocMem(NULL,
                                               HTMEM_CurCSMPBmp,
                                               NONZEROLPTR,
                                               Size)) {

            SMP.pPattern = (LPBYTE)pCurCSMPBmp + sizeof(CSMPBMP);

            CreateStandardMonoPattern(pDCI, &SMP);

            //
            // Make this pattern index as link list head
            //

            pCurCSMPBmp->pNextCSMPBmp  = pCurCSMPData->pCSMPBmpHead;
            pCurCSMPBmp->PatternIndex  = (WORD)PatternIndex;
            pCurCSMPBmp->cxPels        = (WORD)SMP.cxPels;
            pCurCSMPBmp->cyPels        = (WORD)SMP.cyPels;
            pCurCSMPBmp->cxBytes       = (WORD)SMP.BytesPerScanLine;

            pCurCSMPData->pCSMPBmpHead = pCurCSMPBmp;

            return(pCurCSMPBmp);

        } else {

            ASSERTMSG("  >>FindCSMP: HTAllocMem(CSMPBMP) Failed", FALSE);
        }
    }

    RELEASE_HTMUTEX(HTGlobal.HTMutexCSMP);

    return(NULL);
}



LONG
HTENTRY
GetCachedSMP(
    PDEVICECOLORINFO    pDCI,
    PSTDMONOPATTERN     pSMP
    )

/*++

Routine Description:

    This function will try to find the cached DEVICECOLORINFO and put the
    cached data to the pDCI

Arguments:

    pDCI    - Pointer to current device color info


    pSMP    - Pointer to the STDMONOPATTERN data structure, if PatIndex is
              < CACHED_SMP_COUNT or, its not default size then it will be
              computed on the fly.



Return Value:

    The size of the SMP pattern.

Author:

    01-May-1992 Fri 13:10:14 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LONG        SizeRet = 0;
    UINT        PatIndex;


    if (!(pSMP->LineWidth)) {

        pSMP->LineWidth = DEFAULT_SMP_LINE_WIDTH;
    }

    if (!(pSMP->LinesPerInch)) {

        pSMP->LinesPerInch = DEFAULT_SMP_LINES_PER_INCH;
    }

    if (((PatIndex = (UINT)pSMP->PatternIndex) < HT_SMP_PERCENT_SCREEN_START) &&
        (pSMP->LineWidth    == DEFAULT_SMP_LINE_WIDTH)                        &&
        (pSMP->LinesPerInch == DEFAULT_SMP_LINES_PER_INCH)) {

        PCSMPBMP    pCSMPBmp;

        if (pCSMPBmp = FindCachedSMP(pDCI, PatIndex)) {

            CSMPBMP     CSMPBmp;
            LPBYTE      pPatRet;
            LPBYTE      pPat;
            WORD        cxBytesRet;


            CSMPBmp      = *pCSMPBmp;
            pPat         = (LPBYTE)pCSMPBmp + sizeof(CSMPBMP);
            pSMP->cxPels = CSMPBmp.cxPels;
            pSMP->cyPels = CSMPBmp.cyPels;

            cxBytesRet             =
            pSMP->BytesPerScanLine = (WORD)
                        ComputeBytesPerScanLine((UINT)BMF_1BPP,
                                                (UINT)pSMP->ScanLineAlignBytes,
                                                (DWORD)CSMPBmp.cxPels);
            SizeRet                = (LONG)cxBytesRet * (LONG)CSMPBmp.cyPels;

            if (pPatRet = pSMP->pPattern) {

                INT     cxBytes;
                INT     PatInc;
                WORD    Flags;


                PatInc  =
                cxBytes = (INT)CSMPBmp.cxBytes;
                Flags   = pSMP->Flags;

                DBGP_IF(DBGP_CACHED_DCI,
                        DBGP(">>  GetCSMP: *COPY* [%2u:%ux%u] @%u(%ld) -> @%u(%u) [%s] [%c=K]"
                            ARGU(PatIndex)
                            ARGU(CSMPBmp.cxPels)
                            ARGU(CSMPBmp.cyPels)
                            ARGU(cxBytes)
                            ARGU((LONG)cxBytes * (LONG)CSMPBmp.cyPels)
                            ARGU(cxBytesRet)
                            ARGU(SizeRet)
                            ARG((Flags & SMP_TOPDOWN) ? "TOP DOWN" : "BOTTOM UP ")
                            ARG((Flags & SMP_0_IS_BLACK) ? '0' : '1')));

                //
                // Start copying the cached pattern
                //

                if (!(Flags & SMP_TOPDOWN)) {

                    pPat   += (LONG)cxBytes * (LONG)(CSMPBmp.cyPels - 1);
                    PatInc  = -PatInc;
                }

                while (CSMPBmp.cyPels--) {

                    CopyMemory(pPatRet, pPat, cxBytes);

                    pPatRet += cxBytesRet;
                    pPat    += PatInc;
                }

                if (Flags & SMP_0_IS_BLACK) {

                    LONG    Count = SizeRet;


                    pPatRet = pSMP->pPattern;

                    while (Count--) {

                        *pPatRet++ ^= 0xff;
                    }
                }
            }

            RELEASE_HTMUTEX(HTGlobal.HTMutexCSMP);
        }

    } else {

        DBGP_IF(DBGP_CACHED_SMP,
                DBGP(">>  GetCSMP: NO CACHED FOR LineWidth=%u, LinesPerInch=%u"
                    ARGU(pSMP->LineWidth) ARGU(pSMP->LinesPerInch)));
    }

    if (!SizeRet) {

        SizeRet = CreateStandardMonoPattern(pDCI, pSMP);
    }

    return(SizeRet);

}


#if DO_CACHE_DCI


DWORD
HTENTRY
ComputeHTINITINFOChecksum(
    PDEVICECOLORINFO    pDCI,
    PHTINITINFO         pHTInitInfo
    )

/*++

Routine Description:

    This function compute 32-bit checksum for the HTINITINFO data structure
    passed

Arguments:

    pDCI            - Pointer to the DCI

    pHTInitInfo    - Pointer to the HTINITINFO5 data structure

Return Value:

    32-bit checksum

Author:

    29-Apr-1992 Wed 18:44:42 created  -by-  Daniel Chou (danielc)

    11-Feb-1997 Tue 12:54:50 updated  -by-  Daniel Chou (danielc)
        Changed using HTINITINFO5

Revision History:


--*/

{
    DWORD   Checksum;
    WORD    wBuf[12];


    Checksum = ComputeHTCell((WORD)pHTInitInfo->HTPatternIndex,
                             pHTInitInfo->pHalftonePattern,
                             NULL);

    DBGP_IF(DBGP_CACHED_DCI,
            DBGP("       HTPATTERN Checksum= %08lx" ARGDW(Checksum)));

    wBuf[0] = (WORD)'HT';
    wBuf[1] = (WORD)pHTInitInfo->Flags;
    wBuf[2] = (WORD)(pDCI->HTInitInfoChecksum >> 16);
    wBuf[3] = (WORD)pHTInitInfo->DeviceResXDPI;
    wBuf[4] = (WORD)pHTInitInfo->DeviceResYDPI;
    wBuf[5] = (WORD)pHTInitInfo->DevicePelsDPI;
    wBuf[6] = (WORD)(pDCI->HTInitInfoChecksum & 0xffff);
    wBuf[7] = (WORD)pHTInitInfo->DevicePowerGamma;
    wBuf[8] = (WORD)0x1234;

    if (pHTInitInfo->Version > HTINITINFO_VERSION2) {

        wBuf[9]  = (WORD)pHTInitInfo->DeviceRGamma;
        wBuf[10]  = (WORD)pHTInitInfo->DeviceGGamma;
        wBuf[11] = (WORD)pHTInitInfo->DeviceBGamma;

    } else {

        wBuf[9]  = 0x1234;
        wBuf[10] = 0xfedc;
        wBuf[11] = 0xabcd;
    }

    Checksum = ComputeChecksum((LPBYTE)&(wBuf[0]), Checksum, sizeof(wBuf));

    DBGP_IF(DBGP_CACHED_DCI,
            DBGP("    HTINITINFO Checksum= %08lx [%08lx]"
                        ARGDW(Checksum) ARGDW(pDCI->HTInitInfoChecksum)));

    if (pHTInitInfo->pInputRGBInfo) {

        Checksum = ComputeChecksum((LPBYTE)pHTInitInfo->pInputRGBInfo,
                                   Checksum,
                                   sizeof(CIEINFO));
        DBGP_IF(DBGP_CACHED_DCI,
                DBGP("           RGBINFO Checksum= %08lx" ARGDW(Checksum)));
    }

    if (pHTInitInfo->pDeviceCIEInfo) {

        Checksum = ComputeChecksum((LPBYTE)pHTInitInfo->pDeviceCIEInfo,
                                   Checksum,
                                   sizeof(CIEINFO));
        DBGP_IF(DBGP_CACHED_DCI,
                DBGP("             CIEINFO Checksum= %08lx" ARGDW(Checksum)));
    }

    if (pHTInitInfo->pDeviceSolidDyesInfo) {

        Checksum = ComputeChecksum((LPBYTE)pHTInitInfo->pDeviceSolidDyesInfo,
                                   Checksum,
                                   sizeof(SOLIDDYESINFO));
        DBGP_IF(DBGP_CACHED_DCI,
                DBGP("               SOLIDDYE Checksum= %08lx" ARGDW(Checksum)));
    }

    DBGP_IF(DBGP_CACHED_DCI,
            DBGP("----------------- FINAL Checksum= %08lx" ARGDW(Checksum)));

    return(pDCI->HTInitInfoChecksum = Checksum);
}


#endif



HTCALLBACKFUNCTION
DefaultHTCallBack(
    PHTCALLBACKPARAMS   pHTCallBackParams
    )

/*++

Routine Description:

    This stuff function is provided when caller do not specified the halftone
    callback function.

Arguments:

    pHTCallBackParams   - Pointer to the PHTCALLBACKPARAMS

Return Value:

    always return false for the caller.

Author:

    18-Mar-1992 Wed 12:28:13 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    UNREFERENCED_PARAMETER(pHTCallBackParams);

    return(FALSE);
}


#define FLIP_COORD(m, a)        (a) = ((m) << 1) - (a)




VOID
HTENTRY
GetCIEPrims(
    PCIEINFO    pCIEInfo,
    PCIEPRIMS   pCIEPrims,
    PCIEINFO    pDefCIEInfo,
    BOOL        FlipWhite
    )

/*++

Routine Description:

    This function take CIEINFO data structure and converted it to the CIEPRIMS
    internal data type

Arguments:

    pCIEInfo    - Pointer to the CIEINFO data structure for conversion,
                  if this pointer is NULL then DefCIEPrimsIndex is used
                  to index into DefaultCIEPrims[].

    pCIEPrims   - Pointer to the CIEPRIMS data structure

    pDefCIEInfo - Pointer to the CIEINFO for the default

Return Value:

    BOOL    If it is standard CIE Info

Author:

    20-Apr-1993 Tue 01:14:23 created  -by-  Daniel Chou (danielc)


Revision History:

    06-Oct-2000 Fri 18:01:40 updated  -by-  Daniel Chou (danielc)
        fix bug: Move FlipWhite to the outer loop so it will compute even in
        default CIEINFO situation

--*/

{
    CIEINFO CIEInfo;
    BOOL    UseDefCIEInfo = TRUE;
    LONG    Diff;


    if (pCIEInfo) {

        CIEInfo = *pCIEInfo;

        if ((CIEInfo.Red.x < CIE_x_MIN)                 ||
            (CIEInfo.Red.x > CIE_x_MAX)                 ||
            (CIEInfo.Red.y < CIE_y_MIN)                 ||
            (CIEInfo.Red.y > CIE_y_MAX)                 ||
            (CIEInfo.Green.x < CIE_x_MIN)               ||
            (CIEInfo.Green.x > CIE_x_MAX)               ||
            (CIEInfo.Green.y < CIE_y_MIN)               ||
            (CIEInfo.Green.y > CIE_y_MAX)               ||
            (CIEInfo.Blue.x < CIE_x_MIN)                ||
            (CIEInfo.Blue.x > CIE_x_MAX)                ||
            (CIEInfo.Blue.y < CIE_y_MIN)                ||
            (CIEInfo.Blue.y > CIE_y_MAX)                ||
            (CIEInfo.AlignmentWhite.x < CIE_x_MIN)      ||
            (CIEInfo.AlignmentWhite.x > CIE_x_MAX)      ||
            (CIEInfo.AlignmentWhite.y < CIE_y_MIN)      ||
            (CIEInfo.AlignmentWhite.y > CIE_y_MAX)      ||
            (CIEInfo.AlignmentWhite.Y < (UDECI4)2500)   ||
            (CIEInfo.AlignmentWhite.Y > (UDECI4)60000)) {

            NULL;

        } else {

            UseDefCIEInfo = FALSE;

        }
    }

    if (UseDefCIEInfo) {

        CIEInfo = *pDefCIEInfo;
    }

    if (FlipWhite) {

        FLIP_COORD(pDefCIEInfo->AlignmentWhite.x,
                   CIEInfo.AlignmentWhite.x);

        FLIP_COORD(pDefCIEInfo->AlignmentWhite.y,
                   CIEInfo.AlignmentWhite.y);
    }

    pCIEPrims->r.x = UDECI4ToFD6(CIEInfo.Red.x);
    pCIEPrims->r.y = UDECI4ToFD6(CIEInfo.Red.y);
    pCIEPrims->g.x = UDECI4ToFD6(CIEInfo.Green.x);
    pCIEPrims->g.y = UDECI4ToFD6(CIEInfo.Green.y);
    pCIEPrims->b.x = UDECI4ToFD6(CIEInfo.Blue.x);
    pCIEPrims->b.y = UDECI4ToFD6(CIEInfo.Blue.y);
    pCIEPrims->w.x = UDECI4ToFD6(CIEInfo.AlignmentWhite.x);
    pCIEPrims->w.y = UDECI4ToFD6(CIEInfo.AlignmentWhite.y);
    pCIEPrims->Yw  = UDECI4ToFD6(CIEInfo.AlignmentWhite.Y);
}



LONG
APIENTRY
HT_LOADDS
HT_CreateDeviceHalftoneInfo(
    PHTINITINFO             pHTInitInfo,
    PPDEVICEHALFTONEINFO    ppDeviceHalftoneInfo
    )

/*++

Routine Description:

    This function initialize a device to the halftone dll, it calculate all
    the necessary parameters for the device and return a pointer points to
    the DEVICEHALFTONEINFO data structure back to the caller.

    NOTE: return pointer will not be particulary anchor to a single physucal
          device, but rather to a group of physical devices, that is if the
          caller has simillar devices which share the same characteristics
          then it may use the same pointer to halftone the bitmap.

Arguments:

    pHTInitInfo             - Pointer to the HTINITINFO data structure which
                              describe the device characteristics and other
                              initialzation requests.

    ppDeviceHalftoneInfo    - Pointer to the DEVICEHALFTONEINFO pointer, if
                              content of this pointer is not NULL then halftone
                              dll assume the caller has previously cached
                              DEVICEHALFTONEINFO data pointed by it, if it
                              is NULL then halftone dll compute all the
                              DEVICEHALFTONEINFO datas for newly created
                              halftone info. for the device. (see following
                              'Return Value' for more detail)

Return Value:

    The return value will be greater than 0L if the function sucessfully, and
    it will be an error code (less than or equal to 0) if function failed.

    Return value greater than 0

        1. The pointer location points by the ppDeviceHalftoneInfo will be
           updated to stored the pointer which points to the DEVICEHALFTONEINFO
           data structure for later any HT_xxxx() api calls.

        2. The Return value is the total bytes the caller can saved and used
           as cached DeviceHalftoneInfo for next time calling this function,
           the saved area is started from *(ppDeviceHalftoneInfo) and has
           size in bytes as return value.

        NOTE: if caller passed a pointer pointed by ppDeviceHalftoneInfo and
              the return value is greater than zero then it signal that it
              passed DEVICEHALFTONEINFO pointer is not correct of data has
              been changed from HTINITINFO data structure, the caller can
              continue to save the newly created DEVICEHALFTONEINFO cached
              data.

              In any cases the caller's passed pointer stored in the
              ppDeviceHalftoneInfo is overwritten by newly created
              DEVICEHALFTONEINFO data structure pointer.


    Return value equal to 0

        1. The caller passed pointer *(ppDeviceHalftoneInfo) is sucessfully
           used as new device halftone info

        2. The pointer location points by the ppDeviceHalftoneInfo will be
           updated to stored the new pointer which points to the
           DEVICEHALFTONEINFO data structure for later any HT_xxxx() api calls.


        NOTE: The caller's passed pointer stored in the ppDeviceHalftoneInfo
              is overwritten by newly created DEVICEHALFTONEINFO data structure
              pointer.

    Return value less than or equal to zero

        The function failed, the storage points by the ppDeviceHalftoneInfo is
        undefined.

        This function may return following error codes.

        HTERR_INSUFFICIENT_MEMORY       - Not enough memory for halftone
                                          process.

        HTERR_HTPATTERN_SIZE_TOO_BIG    - Caller defined halftone pattern's
                                          width or height is excessed limit.

        HTERR_INVALID_HALFTONEPATTERN   - One or more HALFTONEPATTERN data
                                          structure field specified invalid
                                          values.


    Note: The first field in the DEVICEHALFTONEINFO (DeviceOwnData) is a 32-bit
          area which will be set to 0L upon sucessful returned, the caller can
          put any data in this field.

Author:

    05-Feb-1991 Tue 10:54:32 created  -by-  Daniel Chou (danielc)


Revision History:

    05-Jun-1991 Wed 10:22:07 updated  -by-  Daniel Chou (danielc)

        Fixed the typing errors for halftone pattern default

--*/

{
    PHT_DHI             pHT_DHI;
    PDEVICECOLORINFO    pDCI;
    HTINITINFO          HTInitInfo;
    BOOL                UseCurNTDefault;
    FD6                 DevPelRatio;
    WORD                ExtraDCIF;
    DWORD               dwBuf[6];

#define _RegDataIdx     ((DWORD)(dwBuf[0]))
#define _MaxMulDiv      ((FD6)(dwBuf[0]))
#define _cC             ((DWORD)(dwBuf[1]))
#define _cM             ((DWORD)(dwBuf[2]))
#define _cY             ((DWORD)(dwBuf[3]))
#define _MaxCMY         ((DWORD)(dwBuf[4]))
#define _Idx            ((DWORD)(dwBuf[5]))


    DBGP_IF(DBGP_CACHED_DCI,
            DBGP("\n********* HT_CreateDeviceHalftoneInfo *************\n"));

    ZeroMemory(&HTInitInfo, sizeof(HTINITINFO));

    //
    // Now check if we have valid data
    //

    if (pHTInitInfo->Version == (DWORD)HTINITINFO_VERSION2) {

        HTInitInfo.Version = sizeof(HTINITINFO) - HTINITINFO_V3_CB_EXTRA;

    } else if (pHTInitInfo->Version == (DWORD)HTINITINFO_VERSION) {

        HTInitInfo.Version = sizeof(HTINITINFO);

    } else {

        HTAPI_RET(HTAPI_IDX_CREATE_DHI, HTERR_WRONG_VERSION_HTINITINFO);
    }

    CopyMemory(&HTInitInfo, pHTInitInfo, HTInitInfo.Version);

    DBGP_IF(DBGP_CACHED_DCI,
            DBGP("*** Allocate HT_DHI(%ld) ***" ARGDW(sizeof(HT_DHI))));

    if (!(pHT_DHI = (PHT_DHI)HTAllocMem(NULL,
                                        HTMEM_HT_DHI,
                                        LPTR,
                                        sizeof(HT_DHI)))) {

        HTAPI_RET(HTAPI_IDX_CREATE_DHI, HTERR_INSUFFICIENT_MEMORY);
    }

    pDCI                = &(pHT_DHI->DCI);
    pDCI->HalftoneDLLID = HALFTONE_DLL_ID;

    if (!(pDCI->HTMutex = CREATE_HTMUTEX())) {

        DBGMSG("InitHTInternalData: CREATE_HTMUTEX(pDCI->HTMutex) failed!");

        HTFreeMem(pHT_DHI);
        HTAPI_RET(HTAPI_IDX_CREATE_DHI, (HTERR_INTERNAL_ERRORS_START - 1000));
    }

    if (!(pDCI->HTCallBackFunction = HTInitInfo.HTCallBackFunction)) {

        pDCI->HTCallBackFunction = DefaultHTCallBack;
    }

    HTInitInfo.Flags &= HIF_BIT_MASK;

    // ****************************************************************
    // * We want to check to see if this is a old data, if yes then   *
    // * update the caller to default                                 *
    // ****************************************************************
    //

    pDCI->HTInitInfoChecksum = HTINITINFO_INITIAL_CHECKSUM;

    if ((!HTInitInfo.pDeviceCIEInfo) ||
        (HTInitInfo.pDeviceCIEInfo->Cyan.Y != (UDECI4)VALID_YC)) {

        //
        // Let's munge around the printer info, to see if its an old def,
        // if yes, then we now make this all into NT4.00 default
        //

        DBGP_IF(DBGP_CACHED_DCI,
                DBGP("HT: *WARNING* Update Old Default COLORINFO to NT5.00 DEFAULT"));

        HTInitInfo.pDeviceCIEInfo = NULL;
        UseCurNTDefault           = TRUE;
        dwBuf[0]                  = (DWORD)'NTHT';
        dwBuf[1]                  = (DWORD)'2000';
        dwBuf[2]                  = (DWORD)'Dan.';
        dwBuf[3]                  = (DWORD)'Chou';
        pDCI->HTInitInfoChecksum  = ComputeChecksum((LPBYTE)&dwBuf[0],
                                                    pDCI->HTInitInfoChecksum,
                                                    sizeof(dwBuf[0]) * 4);

    } else {

        UseCurNTDefault = FALSE;
    }

    DevPelRatio = (FD6)HTInitInfo.DevicePelsDPI;

    DBGP_IF(DBGP_DEVPELSDPI,
            DBGP("Passed DevicePelsDPI=%08lx" ARGDW(DevPelRatio)));

    if ((HTInitInfo.DeviceRGamma == (UDECI4)0xFFFF) &&
        (HTInitInfo.DeviceGGamma == (UDECI4)0xFFFF) &&
        (HTInitInfo.DeviceBGamma == (UDECI4)0xFFFF)) {

        ExtraDCIF = DCIF_FORCE_ICM;

    } else {

        ExtraDCIF = 0;
    }

    if ((HTInitInfo.DeviceRGamma < (UDECI4)MIN_RGB_GAMMA)   ||
        (HTInitInfo.DeviceRGamma > (UDECI4)MAX_RGB_GAMMA)   ||
        (HTInitInfo.DeviceGGamma < (UDECI4)MIN_RGB_GAMMA)   ||
        (HTInitInfo.DeviceGGamma > (UDECI4)MAX_RGB_GAMMA)   ||
        (HTInitInfo.DeviceBGamma < (UDECI4)MIN_RGB_GAMMA)   ||
        (HTInitInfo.DeviceBGamma > (UDECI4)MAX_RGB_GAMMA)) {

        HTInitInfo.DeviceRGamma =
        HTInitInfo.DeviceGGamma =
        HTInitInfo.DeviceBGamma = UDECI4_1;
    }

    //
    // Compute HTInitInfoChecksum, and check if we have any cached data
    //

#if DO_CACHE_DCI
    ComputeHTINITINFOChecksum(pDCI, &HTInitInfo);

    if (!GetCachedDCI(pDCI)) {
#else
    if (TRUE) {
#endif
        LONG    Result;

        //
        // Now start to checking the init information
        //

        pDCI->Flags = (WORD)((HTInitInfo.Flags & HIF_SQUARE_DEVICE_PEL) ?
                                                    DCIF_SQUARE_DEVICE_PEL : 0);

        if ((!(pDCI->DeviceResXDPI = HTInitInfo.DeviceResXDPI)) ||
            (!(pDCI->DeviceResYDPI = HTInitInfo.DeviceResYDPI))) {

            pDCI->DeviceResXDPI =
            pDCI->DeviceResYDPI = 300;
            DevPelRatio         = 0;
        }

        if (DevPelRatio & 0x8000) {

            //
            // This is a percentage ie. 1000 = 100.0%, 960=96.0%,
            // on the DeviceResXDPI, Maximum number accepted is 300.0%
            // The larger the percetage the larger the dot size and smaller
            // the percentage the smaller the dot size, if specified as 1000
            // which is 100.0% then it has same size as its X resolution
            // The range is 33.3% to 1500%
            //

            DevPelRatio &= 0x7FFF;

            if ((DevPelRatio > MAX_RES_PERCENT) ||
                (DevPelRatio < MIN_RES_PERCENT)) {

                DBGP_IF(DBGP_DEVPELSDPI,
                        DBGP("HT: *WARNING* Invalid DevicePelsDPI=%ld (PERCENT) set to DEFAULT=1.0"
                             ARGDW(DevPelRatio)));

                DevPelRatio = FD6_1;

            } else {

                DBGP_IF(DBGP_DEVPELSDPI,
                        DBGP("*** Percentage INPUT DevicePelsDPI=%ld *** "
                                        ARGDW(DevPelRatio)));

                DevPelRatio *= 1000;

                DBGP_IF(DBGP_DEVPELSDPI,
                        DBGP("*** Percentage OUTPUT DevPelRatio=%s *** "
                                    ARGFD6(DevPelRatio, 1, 6)));
            }

        } else {

            if ((DevPelRatio > (pDCI->DeviceResXDPI * 3)) ||
                (DevPelRatio > (pDCI->DeviceResYDPI * 3))) {

                DBGP_IF(DBGP_DEVPELSDPI,
                        DBGP("HT: *WARNING* Invalid DevicePelsDPI=%ld (RES) set to DEFAULT=0"
                                        ARGDW(DevPelRatio)));

                DevPelRatio = 0;
            }

            if (DevPelRatio) {

                dwBuf[0]    = (((DWORD)pDCI->DeviceResXDPI *
                                (DWORD)pDCI->DeviceResXDPI) +
                               ((DWORD)pDCI->DeviceResYDPI *
                                (DWORD)pDCI->DeviceResYDPI));
                dwBuf[1]    = ((DWORD)DevPelRatio * (DWORD)DevPelRatio * 2);
                DevPelRatio = SquareRoot(DivFD6(dwBuf[0], dwBuf[1]));

            } else {

                DevPelRatio = FD6_1;
            }
        }

        //
        // If the DevicePelsDPI is out of range then we will make it 0 (same as
        // device resolution), so it can continue to work
        //

        if (HTInitInfo.Flags & HIF_ADDITIVE_PRIMS) {

            pDCI->ClrXFormBlock.ColorSpace  = CIELUV_1976;
            pDCI->Flags                    |= DCIF_ADDITIVE_PRIMS;

        } else {

            pDCI->ClrXFormBlock.ColorSpace  = CIELAB_1976;
#if DO_DYES_CORRECTION
            pDCI->Flags                    |= DCIF_NEED_DYES_CORRECTION;
#endif
            if (HTInitInfo.Flags & HIF_DO_DEVCLR_XFORM) {

                pDCI->Flags |= DCIF_DO_DEVCLR_XFORM;
            }

            if (HTInitInfo.Flags & HIF_HAS_BLACK_DYE) {

                pDCI->Flags |= DCIF_HAS_BLACK_DYE;
            }
        }

        //
        // Save the DevPelRatio back to PDCI
        //

        DBGP_IF(DBGP_DEVPELSDPI,
                DBGP("*** XDPI=%ld, YDPI=%ld, DevPelRatio=%s *** "
                        ARGDW(pDCI->DeviceResXDPI) ARGDW(pDCI->DeviceResYDPI)
                        ARGFD6(DevPelRatio, 1, 6)));

        pDCI->DevPelRatio               = (FD6)DevPelRatio;
        pDCI->ClrXFormBlock.DevGamma[0] = UDECI4ToFD6(HTInitInfo.DeviceRGamma);
        pDCI->ClrXFormBlock.DevGamma[1] = UDECI4ToFD6(HTInitInfo.DeviceGGamma);
        pDCI->ClrXFormBlock.DevGamma[2] = UDECI4ToFD6(HTInitInfo.DeviceBGamma);

        if ((UseCurNTDefault)                                   ||
            (HTInitInfo.HTPatternIndex > HTPAT_SIZE_MAX_INDEX)  ||
            ((HTInitInfo.HTPatternIndex == HTPAT_SIZE_USER) &&
             (HTInitInfo.pHalftonePattern == NULL))) {

            if ((HTInitInfo.HTPatternIndex != HTPAT_SIZE_8x8) &&
                (HTInitInfo.HTPatternIndex != HTPAT_SIZE_8x8_M)) {

                HTInitInfo.HTPatternIndex = HTPAT_SIZE_DEFAULT;
            }
        }

        if ((HTInitInfo.Flags & HIF_ADDITIVE_PRIMS)     &&
            (HTInitInfo.HTPatternIndex <= HTPAT_SIZE_4x4_M)) {

            HTInitInfo.HTPatternIndex = DEFAULT_SCR_HTPAT_SIZE;
        }

        switch (HTInitInfo.Flags & (HIF_INK_HIGH_ABSORPTION |
                                    HIF_INK_ABSORPTION_INDICES)) {

        case HIF_HIGHEST_INK_ABSORPTION:

            _RegDataIdx = 0;
            break;

        case HIF_HIGHER_INK_ABSORPTION:

            _RegDataIdx = 1;
            break;

        case HIF_HIGH_INK_ABSORPTION:

            _RegDataIdx = 2;
            break;

        case HIF_LOW_INK_ABSORPTION:

            _RegDataIdx = 4;
            break;

        case HIF_LOWER_INK_ABSORPTION:

            _RegDataIdx = 5;
            break;

        case HIF_LOWEST_INK_ABSORPTION:

            _RegDataIdx = 6;
            break;

        case HIF_NORMAL_INK_ABSORPTION:
        default:

            _RegDataIdx = 3;
            break;
        }

        pDCI->ClrXFormBlock.RegDataIdx = (BYTE)_RegDataIdx;

        GetCIEPrims(HTInitInfo.pDeviceCIEInfo,
                    &(pDCI->ClrXFormBlock.DevCIEPrims),
                    (PCIEINFO)&HT_CIE_SRGB,
                    TRUE);

        GetCIEPrims(HTInitInfo.pInputRGBInfo,
                    &(pDCI->ClrXFormBlock.rgbCIEPrims),
                    (PCIEINFO)&HT_CIE_SRGB,
                    FALSE);

        //
        // Compute the solid dyes mixes information and its hue shifting
        // correction factors.
        //

        if (pDCI->Flags & DCIF_NEED_DYES_CORRECTION) {

            SOLIDDYESINFO   SDI;
            MATRIX3x3       FD6SDI;
            BOOL            HasDevSDI;

            //
            // We have make sure the solid dyes info passed from the caller can be
            // inversed, if not we will use our default
            //

            if (HasDevSDI = (HTInitInfo.pDeviceSolidDyesInfo) ? TRUE : FALSE) {

                SDI = *(HTInitInfo.pDeviceSolidDyesInfo);

                if ((SDI.MagentaInCyanDye   > (UDECI4)9000) ||
                    (SDI.YellowInCyanDye    > (UDECI4)9000) ||
                    (SDI.CyanInMagentaDye   > (UDECI4)9000) ||
                    (SDI.YellowInMagentaDye > (UDECI4)9000) ||
                    (SDI.CyanInYellowDye    > (UDECI4)9000) ||
                    (SDI.MagentaInYellowDye > (UDECI4)9000)) {

                    HasDevSDI = FALSE;

                } else if ((SDI.MagentaInCyanDye   == UDECI4_0) &&
                           (SDI.YellowInCyanDye    == UDECI4_0) &&
                           (SDI.CyanInMagentaDye   == UDECI4_0) &&
                           (SDI.YellowInMagentaDye == UDECI4_0) &&
                           (SDI.CyanInYellowDye    == UDECI4_0) &&
                           (SDI.MagentaInYellowDye == UDECI4_0)) {

                    //
                    // Do not need any correction if it all zeros
                    //

                    pDCI->Flags &= (WORD)(~DCIF_NEED_DYES_CORRECTION);
                }

            } else {

                pDCI->Flags &= (WORD)(~DCIF_NEED_DYES_CORRECTION);
            }

            if (pDCI->Flags & DCIF_NEED_DYES_CORRECTION) {

                #define PDCI_CMYDYEMASKS    pDCI->ClrXFormBlock.CMYDyeMasks


                MULDIVPAIR  MDPairs[4];
                FD6         Y;


                if ((UseCurNTDefault) || (!HasDevSDI)) {

                    SDI = DefaultSolidDyesInfo;
                }

                FD6SDI.m[0][1] = UDECI4ToFD6(SDI.CyanInMagentaDye);
                FD6SDI.m[0][2] = UDECI4ToFD6(SDI.CyanInYellowDye);

                FD6SDI.m[1][0] = UDECI4ToFD6(SDI.MagentaInCyanDye);
                FD6SDI.m[1][2] = UDECI4ToFD6(SDI.MagentaInYellowDye);

                FD6SDI.m[2][0] = UDECI4ToFD6(SDI.YellowInCyanDye);
                FD6SDI.m[2][1] = UDECI4ToFD6(SDI.YellowInMagentaDye);

                FD6SDI.m[0][0] =
                FD6SDI.m[1][1] =
                FD6SDI.m[2][2] = FD6_1;

                ComputeInverseMatrix3x3(&FD6SDI, &(PDCI_CMYDYEMASKS));

                if (!(pDCI->Flags & DCIF_HAS_BLACK_DYE)) {

                    MAKE_MULDIV_INFO(MDPairs, 3, MULDIV_NO_DIVISOR);
                    MAKE_MULDIV_PAIR(MDPairs, 1, CIE_Xr(PDCI_CMYDYEMASKS), FD6_1);
                    MAKE_MULDIV_PAIR(MDPairs, 2, CIE_Xg(PDCI_CMYDYEMASKS), FD6_1);
                    MAKE_MULDIV_PAIR(MDPairs, 3, CIE_Xb(PDCI_CMYDYEMASKS), FD6_1);

                    Y = FD6_1 - MulFD6(FD6_1 - MulDivFD6Pairs(MDPairs),
                                       pDCI->PrimAdj.DevCSXForm.Yrgb.R);

                    MAKE_MULDIV_PAIR(MDPairs, 1, CIE_Yr(PDCI_CMYDYEMASKS), FD6_1);
                    MAKE_MULDIV_PAIR(MDPairs, 2, CIE_Yg(PDCI_CMYDYEMASKS), FD6_1);
                    MAKE_MULDIV_PAIR(MDPairs, 3, CIE_Yb(PDCI_CMYDYEMASKS), FD6_1);

                    Y -= MulFD6(FD6_1 - MulDivFD6Pairs(MDPairs),
                                pDCI->PrimAdj.DevCSXForm.Yrgb.G);

                    MAKE_MULDIV_PAIR(MDPairs, 1, CIE_Zr(PDCI_CMYDYEMASKS), FD6_1);
                    MAKE_MULDIV_PAIR(MDPairs, 2, CIE_Zg(PDCI_CMYDYEMASKS), FD6_1);
                    MAKE_MULDIV_PAIR(MDPairs, 3, CIE_Zb(PDCI_CMYDYEMASKS), FD6_1);

                    Y -= MulFD6(FD6_1 - MulDivFD6Pairs(MDPairs),
                                pDCI->PrimAdj.DevCSXForm.Yrgb.B);

                    DBGP_IF(DBGP_DYECORRECTION,
                            DBGP("DYE: Maximum Y=%s, Make Luminance from %s to %s, Turn ON DCIF_HAS_BLACK_DYE"
                                ARGFD6(Y, 1, 6)
                                ARGFD6(pDCI->ClrXFormBlock.DevCIEPrims.Yw, 1, 6)
                                ARGFD6(MulFD6(Y,
                                              pDCI->ClrXFormBlock.DevCIEPrims.Yw),
                                       1, 6)));

                    pDCI->Flags                        |= DCIF_HAS_BLACK_DYE;
                    pDCI->ClrXFormBlock.DevCIEPrims.Yw  =
                                MulFD6(pDCI->ClrXFormBlock.DevCIEPrims.Yw, Y);
                }

                DBGP_IF(DBGP_DYECORRECTION,

                    FD6         C;
                    FD6         M;
                    FD6         Y;
                    FD6         C1;
                    FD6         M1;
                    FD6         Y1;
                    static BYTE DyeName[] = "WCMBYGRK";
                    WORD        Loop = 0;

                    DBGP("====== DyeCorrection 3x3 Matrix =======");
                    DBGP("[Cc Cm Cy] [%s %s %s] [%s %s %s]"
                                        ARGFD6(FD6SDI.m[0][0], 2, 6)
                                        ARGFD6(FD6SDI.m[0][1], 2, 6)
                                        ARGFD6(FD6SDI.m[0][2], 2, 6)
                                        ARGFD6(PDCI_CMYDYEMASKS.m[0][0], 2, 6)
                                        ARGFD6(PDCI_CMYDYEMASKS.m[0][1], 2, 6)
                                        ARGFD6(PDCI_CMYDYEMASKS.m[0][2], 2, 6));
                    DBGP("[Mc Mm My]=[%s %s %s]=[%s %s %s]"
                                        ARGFD6(FD6SDI.m[1][0], 2, 6)
                                        ARGFD6(FD6SDI.m[1][1], 2, 6)
                                        ARGFD6(FD6SDI.m[1][2], 2, 6)
                                        ARGFD6(PDCI_CMYDYEMASKS.m[1][0], 2, 6)
                                        ARGFD6(PDCI_CMYDYEMASKS.m[1][1], 2, 6)
                                        ARGFD6(PDCI_CMYDYEMASKS.m[1][2], 2, 6));
                    DBGP("[Yc Ym Yy] [%s %s %s] [%s %s %s]"
                                        ARGFD6(FD6SDI.m[2][0], 2, 6)
                                        ARGFD6(FD6SDI.m[2][1], 2, 6)
                                        ARGFD6(FD6SDI.m[2][2], 2, 6)
                                        ARGFD6(PDCI_CMYDYEMASKS.m[2][0], 2, 6)
                                        ARGFD6(PDCI_CMYDYEMASKS.m[2][1], 2, 6)
                                        ARGFD6(PDCI_CMYDYEMASKS.m[2][2], 2, 6));
                    DBGP("================================================");

                    MAKE_MULDIV_INFO(MDPairs, 3, MULDIV_NO_DIVISOR);

                    for (Loop = 0; Loop <= 7; Loop++) {

                        C = (FD6)((Loop & 0x01) ? FD6_1 : FD6_0);
                        M = (FD6)((Loop & 0x02) ? FD6_1 : FD6_0);
                        Y = (FD6)((Loop & 0x04) ? FD6_1 : FD6_0);


                        MAKE_MULDIV_PAIR(MDPairs,1,CIE_Xr(PDCI_CMYDYEMASKS),C);
                        MAKE_MULDIV_PAIR(MDPairs,2,CIE_Xg(PDCI_CMYDYEMASKS),M);
                        MAKE_MULDIV_PAIR(MDPairs,3,CIE_Xb(PDCI_CMYDYEMASKS),Y);
                        C1 = MulDivFD6Pairs(MDPairs);

                        MAKE_MULDIV_PAIR(MDPairs,1,CIE_Yr(PDCI_CMYDYEMASKS),C);
                        MAKE_MULDIV_PAIR(MDPairs,2,CIE_Yg(PDCI_CMYDYEMASKS),M);
                        MAKE_MULDIV_PAIR(MDPairs,3,CIE_Yb(PDCI_CMYDYEMASKS),Y);
                        M1 = MulDivFD6Pairs(MDPairs);

                        MAKE_MULDIV_PAIR(MDPairs,1,CIE_Zr(PDCI_CMYDYEMASKS),C);
                        MAKE_MULDIV_PAIR(MDPairs,2,CIE_Zg(PDCI_CMYDYEMASKS),M);
                        MAKE_MULDIV_PAIR(MDPairs,3,CIE_Zb(PDCI_CMYDYEMASKS),Y);
                        Y1 = MulDivFD6Pairs(MDPairs);

                        DBGP("%u:[%c] = [%s %s %s]"
                            ARGU(Loop) ARGB(DyeName[Loop])
                            ARGFD6(C1, 2, 6) ARGFD6(M1, 2, 6) ARGFD6(Y1, 2, 6));
                    }
                );
            }
        }

        //
        // Re-compute
        //
        // Geneate internal HTCELL data structure based on the halftone
        // pattern data passed.
        //

        if ((Result = ComputeHTCell((WORD)HTInitInfo.HTPatternIndex,
                                    HTInitInfo.pHalftonePattern,
                                    pDCI)) < 0) {

            CleanUpDHI((PDEVICEHALFTONEINFO)pHT_DHI);
            HTAPI_RET(HTAPI_IDX_CREATE_DHI, Result);
        }

        //
        // Compute simulated rotate pattern for 3 planes
        //

#if DO_CACHE_DCI
        AddCachedDCI(pDCI);
#endif
    }

    pDCI->CRTX[CRTX_LEVEL_255].PrimMax  = CRTX_PRIMMAX_255;
    pDCI->CRTX[CRTX_LEVEL_255].SizeCRTX = (WORD)CRTX_SIZE_255;
    pDCI->CRTX[CRTX_LEVEL_RGB].PrimMax  = CRTX_PRIMMAX_RGB;
    pDCI->CRTX[CRTX_LEVEL_RGB].SizeCRTX = (WORD)CRTX_SIZE_RGB;

    //
    // Setting the public field so the caller can looked at
    //

    pHT_DHI->DHI.DeviceOwnData     = 0;
    pHT_DHI->DHI.cxPattern         = (WORD)pDCI->HTCell.cxReal;
    pHT_DHI->DHI.cyPattern         = (WORD)pDCI->HTCell.Height;

    if ((HTInitInfo.DefHTColorAdjustment.caIlluminantIndex >
                                            ILLUMINANT_MAX_INDEX)       ||
        (HTInitInfo.DefHTColorAdjustment.caSize !=
                                            sizeof(COLORADJUSTMENT))    ||
        ((HTInitInfo.DefHTColorAdjustment.caRedGamma   == 10000)  &&
         (HTInitInfo.DefHTColorAdjustment.caGreenGamma == 10000)  &&
         (HTInitInfo.DefHTColorAdjustment.caBlueGamma  == 10000))) {

        pHT_DHI->DHI.HTColorAdjustment = DefaultCA;

        DBGP_IF(DBGP_CACHED_DCI,
                DBGP("*** USE DEFAULT COLORADJUSTMENT in DCI *** "));

    } else {

        pHT_DHI->DHI.HTColorAdjustment = HTInitInfo.DefHTColorAdjustment;
    }

    if ((HTInitInfo.Flags & (HIF_ADDITIVE_PRIMS | HIF_PRINT_DRAFT_MODE)) ==
                                                  HIF_PRINT_DRAFT_MODE) {

        pDCI->Flags |= DCIF_PRINT_DRAFT_MODE;
    }

    //
    // Compute what 8bpp mode we will be in
    //

    if (HTInitInfo.Flags & HIF_USE_8BPP_BITMASK) {

        pDCI->Flags |= DCIF_USE_8BPP_BITMASK |
                       ((HTInitInfo.Flags & HIF_INVERT_8BPP_BITMASK_IDX) ?
                            DCIF_INVERT_8BPP_BITMASK_IDX : 0);
        _cC          = (DWORD)((HTInitInfo.CMYBitMask8BPP >> 5) & 0x7);
        _cM          = (DWORD)((HTInitInfo.CMYBitMask8BPP >> 2) & 0x7);
        _cY          = (DWORD)((HTInitInfo.CMYBitMask8BPP     ) & 0x3);

        if (HTInitInfo.CMYBitMask8BPP == 1) {

            //
            // This is 4:4:4: format (0-4 of 5 levels)
            //

            _cC =
            _cM =
            _cY = 4;
            HTInitInfo.CMYBitMask8BPP = (BYTE)((5 * 5 * 5) - 1);

        } else if (HTInitInfo.CMYBitMask8BPP == 2) {

            //
            // This is 5:5:5: format (0-5 of 6 levels)
            //

            _cC =
            _cM =
            _cY = 5;
            HTInitInfo.CMYBitMask8BPP = (BYTE)((6 * 6 * 6) - 1);

        } else if ((_cC < 1) || (_cM < 1) || (_cY < 1)) {

            _cC                        =
            _cM                        =
            _cY                        = 0xFF;
            HTInitInfo.CMYBitMask8BPP  = 0xFF;
            pDCI->Flags               |= DCIF_MONO_8BPP_BITMASK;
        }

        pDCI->CMY8BPPMask.GenerateXlate =
                        (pDCI->Flags & DCIF_INVERT_8BPP_BITMASK_IDX) ? 1 : 0;

        if ((_cC == _cM) && (_cC == _cY)) {

            pDCI->Flags                 |= DCIF_CMY8BPPMASK_SAME_LEVEL;
            pDCI->CMY8BPPMask.SameLevel  = (BYTE)_cC;

        } else {

            pDCI->CMY8BPPMask.SameLevel  = 0;
        }

        if ((_MaxCMY = _cC) < _cM) {

            _MaxCMY = _cM;
        }

        if (_MaxCMY < _cY) {

            _MaxCMY = _cY;
        }

        //
        // Set to 0xFFFF to indicate this is a default setting to start with
        // then modified depends on the parameters passed
        //

        pDCI->CMY8BPPMask.KCheck = 0xFFFF;

        if ((_MaxCMY <= 6)                  &&
            (pHTInitInfo->pDeviceCIEInfo)   &&
            (pHTInitInfo->pDeviceCIEInfo->Blue.Y == VALID_YB_DENSITY)) {

            PCIEINFO    pCIE = pHTInitInfo->pDeviceCIEInfo;

            //
            // 27-Sep-2000 Wed 15:05:38 updated  -by-  Daniel Chou (danielc)
            //  if Blue.Y == 0xfffe then it specified that it has CMY densities
            //  in the CIEINFO, Cyan.x=C1,C2, Cyan.y=C3,C4, Red.Y=C5,C6
            //  Magenta.x=M1,M2, Magenta.y=M3,M4, Magenta.Y=M5,M6
            //  Yellow.x=Y1,Y2, Yellow.y=Y3,Y4, Yellow.Y=Y5,Y6, each density is
            //  one byte and its computation is (C1+1)/256 to get the perentage
            //  of the density.  The Last level is to specified maximum dye
            //  output for that color. for example if Cyan has 2 levels
            //  and C1=0x7F and C2=0xF0 then first level of ink is
            //  (0x7f+1) / 0x100=50% and last level of ink is 0xF0 which
            //  speicified maximum ink will be used, at here =
            //  (0xF0 + 1) / 0x100 = 94.14% which maximum cyan ink will be at
            //  94.14% not 100%
            //

            pDCI->Flags               |= DCIF_HAS_DENSITY;
            pDCI->CMY8BPPMask.DenC[0]  = GET_DEN_HI(pCIE->Cyan.x);
            pDCI->CMY8BPPMask.DenC[1]  = GET_DEN_LO(pCIE->Cyan.x);
            pDCI->CMY8BPPMask.DenC[2]  = GET_DEN_HI(pCIE->Cyan.y);
            pDCI->CMY8BPPMask.DenC[3]  = GET_DEN_LO(pCIE->Cyan.y);
            pDCI->CMY8BPPMask.DenC[4]  = GET_DEN_HI(pCIE->Red.Y);
            pDCI->CMY8BPPMask.DenC[5]  = GET_DEN_LO(pCIE->Red.Y);
            pDCI->CMY8BPPMask.DenM[0]  = GET_DEN_HI(pCIE->Magenta.x);
            pDCI->CMY8BPPMask.DenM[1]  = GET_DEN_LO(pCIE->Magenta.x);
            pDCI->CMY8BPPMask.DenM[2]  = GET_DEN_HI(pCIE->Magenta.y);
            pDCI->CMY8BPPMask.DenM[3]  = GET_DEN_LO(pCIE->Magenta.y);
            pDCI->CMY8BPPMask.DenM[4]  = GET_DEN_HI(pCIE->Magenta.Y);
            pDCI->CMY8BPPMask.DenM[5]  = GET_DEN_LO(pCIE->Magenta.Y);
            pDCI->CMY8BPPMask.DenY[0]  = GET_DEN_HI(pCIE->Yellow.x);
            pDCI->CMY8BPPMask.DenY[1]  = GET_DEN_LO(pCIE->Yellow.x);
            pDCI->CMY8BPPMask.DenY[2]  = GET_DEN_HI(pCIE->Yellow.y);
            pDCI->CMY8BPPMask.DenY[3]  = GET_DEN_LO(pCIE->Yellow.y);
            pDCI->CMY8BPPMask.DenY[4]  = GET_DEN_HI(pCIE->Yellow.Y);
            pDCI->CMY8BPPMask.DenY[5]  = GET_DEN_LO(pCIE->Yellow.Y);

            //
            // The Green.Y is a UDECI4 number that specified the black ink
            // replacement base ratio, the range and meaning as follow
            //
            //           0: Default black ink replacement computation
            //  1  -  9999: Specified black ink replacement base ratio
            //    >= 10000: turn off black ink replacement computation
            //

            if (pCIE->Green.Y >= UDECI4_1) {

                pDCI->CMY8BPPMask.KCheck = FD6_0;

            } else if (pCIE->Green.Y != UDECI4_0) {

                pDCI->CMY8BPPMask.KCheck = UDECI4ToFD6(pCIE->Green.Y);
            }

            _MaxMulDiv                 = DivFD6(FD6_1, pDCI->DevPelRatio);
            pDCI->CMY8BPPMask.MaxMulC  = MulFD6(pDCI->CMY8BPPMask.DenC[_cC - 1],
                                                _MaxMulDiv);
            pDCI->CMY8BPPMask.MaxMulM  = MulFD6(pDCI->CMY8BPPMask.DenM[_cM - 1],
                                                _MaxMulDiv);
            pDCI->CMY8BPPMask.MaxMulY  = MulFD6(pDCI->CMY8BPPMask.DenY[_cY - 1],
                                                _MaxMulDiv);

            for (_Idx = COUNT_ARRAY(pDCI->CMY8BPPMask.DenC);
                 _Idx > 0;
                 _Idx--) {

                if (_Idx >= _cC) {

                    pDCI->CMY8BPPMask.DenC[_Idx - 1]  = FD6_1;
                }

                if (_Idx >= _cM) {

                    pDCI->CMY8BPPMask.DenM[_Idx - 1]  = FD6_1;
                }

                if (_Idx >= _cY) {

                    pDCI->CMY8BPPMask.DenY[_Idx - 1]  = FD6_1;
                }
            }

            DBGP_IF(DBGP_CACHED_DCI,
                    DBGP("   Cyan %ld/%s Density: %s, %s, %s, %s, %s, %s"
                            ARGDW(_cC)
                            ARGFD6(pDCI->CMY8BPPMask.MaxMulC, 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenC[0], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenC[1], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenC[2], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenC[3], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenC[4], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenC[5], 1, 6)));

            DBGP_IF(DBGP_CACHED_DCI,
                    DBGP("Magenta %ld/%s Density: %s, %s, %s, %s, %s, %s"
                            ARGDW(_cM)
                            ARGFD6(pDCI->CMY8BPPMask.MaxMulM, 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenM[0], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenM[1], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenM[2], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenM[3], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenM[4], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenM[5], 1, 6)));

            DBGP_IF(DBGP_CACHED_DCI,
                    DBGP(" Yellow %ld/%s Density: %s, %s, %s, %s, %s, %s"
                            ARGDW(_cY)
                            ARGFD6(pDCI->CMY8BPPMask.MaxMulY, 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenY[0], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenY[1], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenY[2], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenY[3], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenY[4], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenY[5], 1, 6)));

        } else {

            _MaxMulDiv                = FD6xL(pDCI->DevPelRatio, _MaxCMY);
            pDCI->CMY8BPPMask.MaxMulC = DivFD6(FD6xL(FD6_1, _cC), _MaxMulDiv);
            pDCI->CMY8BPPMask.MaxMulM = DivFD6(FD6xL(FD6_1, _cM), _MaxMulDiv);
            pDCI->CMY8BPPMask.MaxMulY = DivFD6(FD6xL(FD6_1, _cY), _MaxMulDiv);
        }

        if ((_MaxMulDiv = pDCI->CMY8BPPMask.MaxMulC) <
                                                pDCI->CMY8BPPMask.MaxMulM) {

            _MaxMulDiv =  pDCI->CMY8BPPMask.MaxMulM;
        }

        if (_MaxMulDiv < pDCI->CMY8BPPMask.MaxMulY) {

            _MaxMulDiv =  pDCI->CMY8BPPMask.MaxMulY;
        }

        if (pDCI->CMY8BPPMask.KCheck == 0xFFFF) {

            //
            // Default setting, turn off K Replacement only if
            // DevPelsRatio/Density = 100% and CMY inks are in same level
            //

            pDCI->CMY8BPPMask.KCheck =
                        ((_MaxMulDiv == FD6_1) &&
                         (pDCI->Flags & DCIF_CMY8BPPMASK_SAME_LEVEL)) ?
                                                        FD6_0 : K_REP_START;
        }

        if (pDCI->CMY8BPPMask.KCheck == FD6_0) {

            //
            // If K replacement was turn off, but the ratio is not 100% or
            // have different ink levels then wee need to turn it on at
            // 1.0 (FD6_1) so that a 8bpp black replacement function is
            // used, only in k replacement function it compute how to
            // reduced non 100% device pel ratio (KPower)
            //

            if ((_MaxMulDiv != FD6_1) ||
                (!(pDCI->Flags & DCIF_CMY8BPPMASK_SAME_LEVEL))) {

                pDCI->CMY8BPPMask.KCheck = FD6_1;
            }
        }

        DBGP_IF(DBGP_CACHED_DCI,
            DBGP("KCheck= %s ^ %s = %s"
                ARGFD6(pDCI->CMY8BPPMask.KCheck, 1, 6) ARGFD6(_MaxMulDiv, 1, 6)
                ARGFD6(Power(pDCI->CMY8BPPMask.KCheck, _MaxMulDiv), 1, 6)));

        pDCI->CMY8BPPMask.KCheck  = Power(pDCI->CMY8BPPMask.KCheck, _MaxMulDiv);
        pDCI->CMY8BPPMask.PatSubC =
                        (WORD)MulFD6(pDCI->CMY8BPPMask.MaxMulC, 0xFFF) + 1;
        pDCI->CMY8BPPMask.PatSubM =
                        (WORD)MulFD6(pDCI->CMY8BPPMask.MaxMulM, 0xFFF) + 1;
        pDCI->CMY8BPPMask.PatSubY =
                        (WORD)MulFD6(pDCI->CMY8BPPMask.MaxMulY, 0xFFF) + 1;

        DBGP_IF(DBGP_CACHED_DCI,
                DBGP("*** USE_8BPP_BITMASK: CMY=%ld:%ld:%ld, Same=%ld], Mask=%02lx, Max=%ld ***"
                    ARGDW(_cC) ARGDW(_cM) ARGDW(_cY)
                    ARGDW(pDCI->CMY8BPPMask.SameLevel)
                    ARGDW(HTInitInfo.CMYBitMask8BPP) ARGDW(_MaxCMY)));

        DBGP_IF(DBGP_CACHED_DCI,
                DBGP("*** MaxMulCMY=%s:%s:%s [KCheck=%s], SubCMY=%4ld:%4ld:%4ld ***"
                    ARGFD6(pDCI->CMY8BPPMask.MaxMulC, 1, 6)
                    ARGFD6(pDCI->CMY8BPPMask.MaxMulM, 1, 6)
                    ARGFD6(pDCI->CMY8BPPMask.MaxMulY, 1, 6)
                    ARGFD6(pDCI->CMY8BPPMask.KCheck, 1, 6)
                    ARGDW(pDCI->CMY8BPPMask.PatSubC)
                    ARGDW(pDCI->CMY8BPPMask.PatSubM)
                    ARGDW(pDCI->CMY8BPPMask.PatSubY)));

    } else {

        _cC                       =
        _cM                       =
        _cY                       =
        _MaxCMY                   = 1;
        HTInitInfo.CMYBitMask8BPP = 0xFF;
    }

    pDCI->CMY8BPPMask.cC   = (BYTE)_cC;
    pDCI->CMY8BPPMask.cM   = (BYTE)_cM;
    pDCI->CMY8BPPMask.cY   = (BYTE)_cY;
    pDCI->CMY8BPPMask.Max  = (BYTE)_MaxCMY;
    pDCI->CMY8BPPMask.Mask = (BYTE)HTInitInfo.CMYBitMask8BPP;

    //
    // Now compute the HTSMP checksum for the pattern
    //

    dwBuf[0] = (DWORD)pDCI->DeviceResXDPI;
    dwBuf[1] = (DWORD)pDCI->DeviceResYDPI;
    dwBuf[2] = (DWORD)pDCI->DevPelRatio;
    dwBuf[3] = (DWORD)(dwBuf[0] + dwBuf[1]);

    pDCI->HTSMPChecksum = ComputeChecksum((LPBYTE)&dwBuf[0],
                                          HTSMP_INITIAL_CHECKSUM,
                                          sizeof(dwBuf[0]) * 4);

    ASSERTMSG("pDCI->ClrXFormBlock.RegDataIdx > 6",
                        (pDCI->ClrXFormBlock.RegDataIdx < 7));

    if (pDCI->ClrXFormBlock.RegDataIdx > 6) {

        pDCI->ClrXFormBlock.RegDataIdx = 3;
    }

    DBGP_IF(DBGP_CACHED_DCI,
            DBGP("SMP Checksum = %08lx, RegDataIdx=%u"
                ARGDW(pDCI->HTSMPChecksum)
                ARGU(pDCI->ClrXFormBlock.RegDataIdx)));

    DBGP_IF(DBGP_CACHED_DCI,
            DBGP("*** Final DevResDPI=%ld x %ld DevPelRatio=%ld, cx/cyPat=%ld x %ld=%ld *** "
                        ARGDW(pDCI->DeviceResXDPI)
                        ARGDW(pDCI->DeviceResYDPI)
                        ARGDW(pDCI->DevPelRatio)
                        ARGDW(pHT_DHI->DHI.cxPattern)
                        ARGDW(pHT_DHI->DHI.cyPattern)
                        ARGDW(pDCI->HTCell.Size)));

    //
    // Set the ILLUMINANT index to an invalid value for next one will get
    // computed
    //

    pDCI->Flags                |= ExtraDCIF;
    pDCI->ca.caSize             = ADJ_FORCE_DEVXFORM;
    pDCI->ca.caIlluminantIndex  = 0xffff;
    *ppDeviceHalftoneInfo       = (PDEVICEHALFTONEINFO)pHT_DHI;

    return(HALFTONE_DLL_ID);


#undef _RegDataIdx
#undef _MaxMulDiv
#undef _cC
#undef _cM
#undef _cY
#undef _MaxCMY
#undef _Idx
}




BOOL
APIENTRY
HT_LOADDS
HT_DestroyDeviceHalftoneInfo(
    PDEVICEHALFTONEINFO     pDeviceHalftoneInfo
    )

/*++

Routine Description:

    This function destroy the handle which returned from halftone initialize
    function HT_CreateDeviceHalftoneInfo()

Arguments:

    pDeviceHalftoneInfo - Pointer to the DEVICEHALFTONEINFO data structure
                          which returned from the HT_CreateDeviceHalftoneInfo.

Return Value:

    TRUE    - if function sucessed.
    FALSE   - if function failed.

Author:

    05-Feb-1991 Tue 14:18:20 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    if ((!pDeviceHalftoneInfo) ||
        (PHT_DHI_DCI_OF(HalftoneDLLID) != HALFTONE_DLL_ID)) {

        SET_ERR(HTAPI_IDX_DESTROY_DHI, HTERR_INVALID_DHI_POINTER);
        return(FALSE);
    }

    return(CleanUpDHI(pDeviceHalftoneInfo));
}




LONG
APIENTRY
HT_LOADDS
HT_CreateHalftoneBrush(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo,
    PHTCOLORADJUSTMENT  pHTColorAdjustment,
    PCOLORTRIAD         pColorTriad,
    CHBINFO             CHBInfo,
    LPVOID              pOutputBuffer
    )

/*++

Routine Description:

    This function create halftone mask for the requested solid color.

Arguments:

    pDeviceHalftoneInfo - Pointer to the DEVICEHALFTONEINFO data structure
                          which returned from the HT_CreateDeviceHalftoneInfo.

    pHTColorAdjustment  - Pointer to the HTCOLORADJUSTMENT data structure to
                          specified the input/output color adjustment/transform,
                          if this pointer is NULL then a default color
                          adjustments is applied.

    pColorTriad         - Pointer to the COLORTRIAD data structure to describe
                          the brush colors.

    CHBInfo             - CHBINFO data structure, specified following:

                            Flags: CHBF_BW_ONLY
                                   CHBF_USE_ADDITIVE_PRIMS
                                   CHBF_NEGATIVE_PATTERN


                            DestSurfaceFormat:  BMF_1BPP
                                                BMF_4BPP
                                                BMF_4BPP_VGA16
                                                BMF_8BPP_VGA256

                            ScanLineAlignBytes: 0 - 255

                            DestPrimaryOrder:   One of PRIMARY_ORDER_xxx



    pOutputBuffer       - Pointer to the buffer area to received indices/mask.
                          in bytes needed to stored the halftone pattern.


Return Value:

    if the return value is negative or zero then an error was encountered,
    possible error codes are

        HTERR_INVALID_DHI_POINTER           - Invalid pDevideHalftoneInfo is
                                              passed.

        HTERR_INVALID_DEST_FORMAT           - the Format of the destination
                                              surface is not one of the defined
                                              HSC_FORMAT_xxxx

        HTERR_CHB_INV_COLORTABLE_SIZE       - Color table size is not 1

    otherwise

        If pSurface is NULL, it return the bytes count which need to stored
        the pattern, otherwise it return the size in byte copied to the output
        buffer.

Author:

    05-Feb-1991 Tue 14:28:23 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{

    PDEVICECOLORINFO    pDCI;
    PDEVCLRADJ          pDevClrAdj;
    CTSTD_UNION         CTSTDUnion;
    WORD                ForceFlags;
    LONG                cbBufScan;
    LONG                cbBufSize;


    if ((!pColorTriad)                          ||
        (pColorTriad->ColorTableEntries != 1)   ||
        (!(pColorTriad->pColorTable))) {

        HTAPI_RET(HTAPI_IDX_CHB, HTERR_CHB_INV_COLORTABLE_SIZE);
    }

    ForceFlags             = ADJ_FORCE_BRUSH;
    CTSTDUnion.b.cbPrim    = 0;
    CTSTDUnion.b.SrcOrder  = pColorTriad->PrimaryOrder;
    CTSTDUnion.b.BMFDest   = CHBInfo.DestSurfaceFormat;
    CTSTDUnion.b.DestOrder = CHBInfo.DestPrimaryOrder;

    if ((CHBInfo.Flags & CHBF_BW_ONLY) ||
        (CHBInfo.DestSurfaceFormat == BMF_1BPP)) {

        ForceFlags |= ADJ_FORCE_MONO;
    }

    if (CHBInfo.Flags & CHBF_NEGATIVE_BRUSH) {

        ForceFlags |= ADJ_FORCE_NEGATIVE;
    }

    if (CHBInfo.Flags & CHBF_USE_ADDITIVE_PRIMS) {

        ForceFlags |= ADJ_FORCE_ADDITIVE_PRIMS;
    }

    if (CHBInfo.Flags & CHBF_ICM_ON) {

        ForceFlags |= ADJ_FORCE_ICM;
    }

    SETDBGVAR(pDevClrAdj, NULL);

    if (!(pDCI = pDCIAdjClr(pDeviceHalftoneInfo,
                            pHTColorAdjustment,
                            (pOutputBuffer) ? &pDevClrAdj : NULL,
                            0,
                            ForceFlags,
                            CTSTDUnion.b,
                            &cbBufSize))) {

        HTAPI_RET(HTAPI_IDX_CHB, cbBufSize);
    }

    cbBufScan = (LONG)ComputeBytesPerScanLine(
                                        (UINT)CHBInfo.DestSurfaceFormat,
                                        (UINT)CHBInfo.DestScanLineAlignBytes,
                                        (DWORD)pDCI->HTCell.cxReal);
    cbBufSize = cbBufScan * (LONG)pDCI->HTCell.Height;

    if (pOutputBuffer) {

        if (CHBInfo.Flags & CHBF_BOTTOMUP_BRUSH) {

            (LPBYTE)pOutputBuffer += (cbBufSize - cbBufScan);
            cbBufScan              = -cbBufScan;
        }

        //-------------------------------------------------------------------
        // CreateHalftoneBrushPat will release the semaphore for us
        //-------------------------------------------------------------------

        if ((cbBufScan = CreateHalftoneBrushPat(pDCI,
                                                pColorTriad,
                                                pDevClrAdj,
                                                pOutputBuffer,
                                                cbBufScan)) <= 0) {

            cbBufSize = cbBufScan;
        }

        if (HTFreeMem(pDevClrAdj)) {

            ASSERTMSG("HTFreeMem(pDevClrAdj) Failed", FALSE);
        }

    } else {

        RELEASE_HTMUTEX(pDCI->HTMutex);

        ASSERT(pDevClrAdj == NULL);
    }

    DBGP_IF(DBGP_HTAPI,
            DBGP("HT_CreateHalftoneBrush(%hs %ld/%6ld): RGB=0x%08lx (%ld), Dst(Fmt=%ld, Order=%ld)"
                    ARGPTR((pOutputBuffer) ? "BUF" : "NUL")
                    ARGDW(pDCI->cbMemTot) ARGDW(pDCI->cbMemMax)
                    ARGDW(*((LPDWORD)pColorTriad->pColorTable))
                    ARGDW(pColorTriad->PrimaryOrder)
                    ARGDW(CHBInfo.DestSurfaceFormat)
                    ARGDW(CHBInfo.DestPrimaryOrder)));

    HTAPI_RET(HTAPI_IDX_CHB, cbBufSize);
}




LONG
APIENTRY
HT_LOADDS
HT_ComputeRGBGammaTable(
    WORD    GammaTableEntries,
    WORD    GammaTableType,
    UDECI4  RedGamma,
    UDECI4  GreenGamma,
    UDECI4  BlueGamma,
    LPBYTE  pGammaTable
    )

/*++

Routine Description:

    This function compute device gamma correction table based on the lightness

                                                       (1/RedGamma)
    Gamma[N] = INT((LIGHTNESS(N / GammaTableEntries-1))             x 255)

                                      3
    LIGHTNESS(x) = ((x + 0.16) / 1.16)      if x >= 0.007996
                   (x / 9.033)              if x <  0.007996


    1. INT() is a integer function which round up to next integer number if
       resulting fraction is 0.5 or higher, the final result always limit
       to have range between 0 and 255.

    2. N is a integer step number and range from 0 to (GammaTableEntries-1)
       in one (1) increment.


Arguments:

    GammaTableEntries       - Total gamma table entries for each of red, green
                              and blue gamma table, halftone dll normalized
                              the gamma table with step value computed as
                              1/GammaTableEntries.

                              This value must range from 3 to 255 else a 0
                              is returned and no table is updated.

    GammaTableType          - red, green and blue gamma table organizations

                                0 - The gamma table is Red, Green, Blue 3 bytes
                                    for each gamma step entries and total of
                                    GammaTableEntries entries.

                                1 - The gamma table is Red Gamma tables follow
                                    by green gamma table then follow by blue
                                    gamma table, each table has total of
                                    GammaTableEntries bytes.

                                Other value default to 0.

    RedGamma                - Red gamma number in UDECI4 format

    GreenGamma              - Green gamma number in UDECI4 format

    BlueGamma               - Blue gamma number in UDECI4 format

    pGammaTable             - pointer to the gamma table byte array.
                              each output gamma number is range from 0 to 255.


Return Value:

    Return value is the total table entries updated.

Author:

    15-Sep-1992 Tue 17:49:20 updated  -by-  Daniel Chou (danielc)
        Fixed bug# 6257

    17-Jul-1992 Fri 19:04:31 created    -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPBYTE      pRGamma;
    LPBYTE      pGGamma;
    LPBYTE      pBGamma;
    FD6         L_StepInc;
    FD6         IValue;
    FD6         Lightness;
    LONG        Result;
    UINT        NextEntry;
    FD6         RGBGamma[3];


    //
    // Initialize All internal data first
    //

    if (((Result = GammaTableEntries) > 256) ||
        (Result < 2)) {

        return(0);
    }

    Lightness   = FD6_0;
    L_StepInc   = DivFD6((FD6)1, (FD6)(GammaTableEntries - 1));
    RGBGamma[0] = UDECI4ToFD6(RedGamma);
    RGBGamma[1] = UDECI4ToFD6(GreenGamma);
    RGBGamma[2] = UDECI4ToFD6(BlueGamma);

    pRGamma    = pGammaTable;

    if (GammaTableType == 1) {

        pGGamma   = pRGamma + GammaTableEntries;
        pBGamma   = pGGamma + GammaTableEntries;
        NextEntry = 1;

    } else {

        pGGamma   = pRGamma + 1;
        pBGamma   = pGGamma + 1;
        NextEntry = 3;
    }

    while (--GammaTableEntries) {

        IValue      = Lightness;    // CIE_L2I(Lightness);
        *pRGamma    = RGB_8BPP(Radical(IValue, RGBGamma[0]));
        *pGGamma    = RGB_8BPP(Radical(IValue, RGBGamma[1]));
        *pBGamma    = RGB_8BPP(Radical(IValue, RGBGamma[2]));
        pRGamma    += NextEntry;
        pGGamma    += NextEntry;
        pBGamma    += NextEntry;
        Lightness  += L_StepInc;
    }

    *pRGamma =
    *pGGamma =
    *pBGamma = 255;

    return(Result);
}



LONG
APIENTRY
HT_LOADDS
HT_Get8BPPFormatPalette(
    LPPALETTEENTRY  pPaletteEntry,
    UDECI4          RedGamma,
    UDECI4          GreenGamma,
    UDECI4          BlueGamma
    )

/*++

Routine Description:

    This functions retrieve a halftone's VGA256 color table definitions

Arguments:

    pPaletteEntry   - Pointer to PALETTEENTRY data structure array,

    RedGamma        - The monitor's red gamma value in UDECI4 format

    GreenGamma      - The monitor's green gamma value in UDECI4 format

    BlueGamma       - The monitor's blue gamma value in UDECI4 format


Return Value:

    if pPaletteEntry is NULL then it return the PALETTEENTRY count needed for
    VGA256 halftone process, if it is not NULL then it return the total
    paletteEntry updated.

    If the pPaletteEntry is not NULL then halftone.dll assume it has enough
    space for the size returned when this pointer is NULL.

Author:

    14-Apr-1992 Tue 13:03:21 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    FD6     RGBGamma[3];
    FD6     IValue;
    FD6     Yr;
    FD6     Yg;
    FD6     Yb;
    UINT    RIndex;
    UINT    GIndex;
    UINT    BIndex;
    UINT    TableSize;

    DEFDBGVAR(UINT, PaletteIdx = 0)


    DBGP_IF(DBGP_HTAPI,
            DBGP("HT_Get8BPPFormatPalette(%p): Gamma=%05ld:%05ld:%05ld"
                    ARGPTR(pPaletteEntry)
                    ARGDW(RedGamma) ARGDW(GreenGamma) ARGDW(BlueGamma)));

    //
    // Initialize All internal data first
    //

    if (pPaletteEntry) {

        RGBGamma[0] = UDECI4ToFD6(RedGamma);
        RGBGamma[1] = UDECI4ToFD6(GreenGamma);
        RGBGamma[2] = UDECI4ToFD6(BlueGamma);

        DBGP_IF(DBGP_GAMMA_PAL,
                DBGP("***** HT_Get8BPPFormatPalette: %s:%s:%s *****"
                     ARGFD6(RGBGamma[0], 1, 4)
                     ARGFD6(RGBGamma[1], 1, 4)
                     ARGFD6(RGBGamma[2], 1, 4)));

        //
        // Our VGA256 format is BGR type of Primary order.
        //

        RIndex    =
        GIndex    =
        BIndex    = 0;

        TableSize = VGA256_CUBE_SIZE;

        while (TableSize--) {

            Yr                     = DivFD6(RIndex, VGA256_R_IDX_MAX);
            Yg                     = DivFD6(GIndex, VGA256_G_IDX_MAX);
            Yb                     = DivFD6(BIndex, VGA256_B_IDX_MAX);
            pPaletteEntry->peRed   = RGB_8BPP(Yr);
            pPaletteEntry->peGreen = RGB_8BPP(Yg);
            pPaletteEntry->peBlue  = RGB_8BPP(Yb);
            pPaletteEntry->peFlags = 0;


            DBGP_IF(DBGP_GAMMA_PAL,
                    DBGP("%3u - %3u:%3u:%3u"
                     ARGU(PaletteIdx++)
                     ARGU(pPaletteEntry->peRed  )
                     ARGU(pPaletteEntry->peGreen)
                     ARGU(pPaletteEntry->peBlue )));

            ++pPaletteEntry;

            if ((++RIndex) > VGA256_R_IDX_MAX) {

                RIndex = 0;

                if ((++GIndex) > VGA256_G_IDX_MAX) {

                    GIndex = 0;
                    ++BIndex;
                }
            }
        }

        //
        // 03-Feb-1999 Wed 00:49:08 updated  -by-  Daniel Chou (danielc)
        //
        // Since all these monochrome/gray scale is not stick in the system
        // palette, The halftone codes with new supercell will not use these
        // entries anymore, so do not return it.
        //
#if 0
        RIndex = 0;

        while (RIndex <= VGA256_M_IDX_MAX) {

            IValue                  = DivFD6(RIndex++, VGA256_M_IDX_MAX);
            pPaletteEntry->peRed    = RGB_8BPP(IValue);
            pPaletteEntry->peGreen  = RGB_8BPP(IValue);
            pPaletteEntry->peBlue   = RGB_8BPP(IValue);
            pPaletteEntry->peFlags  = 0;

            DBGP_IF(DBGP_GAMMA_PAL,
                    DBGP("%3u - %3u:%3u:%3u [%s]"
                     ARGU(PaletteIdx++)
                     ARGU(pPaletteEntry->peRed  )
                     ARGU(pPaletteEntry->peGreen)
                     ARGU(pPaletteEntry->peBlue )
                     ARGFD6(IValue, 1, 6)));

            ++pPaletteEntry;
        }
#endif
    }

    return((LONG)VGA256_CUBE_SIZE);

    // return((LONG)VGA256_PALETTE_COUNT);

}





LONG
APIENTRY
HT_LOADDS
HT_Get8BPPMaskPalette(
    LPPALETTEENTRY  pPaletteEntry,
    BOOL            Use8BPPMaskPal,
    BYTE            CMYMask,
    UDECI4          RedGamma,
    UDECI4          GreenGamma,
    UDECI4          BlueGamma
    )

/*++

Routine Description:

    This functions retrieve a halftone's VGA256 color table definitions

Arguments:

    pPaletteEntry   - Pointer to PALETTEENTRY data structure array,

    Use8BPPMaskPal  - TRUE if using byte Mask palette, false to use NT4.0
                      standard MS 8bpp palette

    CMYMask         - Specified level mask in C3:M3:Y2

    RedGamma        - The monitor's red gamma value in UDECI4 format

    GreenGamma      - The monitor's green gamma value in UDECI4 format

    BlueGamma       - The monitor's blue gamma value in UDECI4 format


Return Value:

    if pPaletteEntry is NULL then it return the PALETTEENTRY count needed for
    VGA256 halftone process, if it is not NULL then it return the total
    paletteEntry updated.

    If the pPaletteEntry is not NULL then halftone.dll assume it has enough
    space for the size returned when this pointer is NULL.

Author:

    14-Apr-1992 Tue 13:03:21 created  -by-  Daniel Chou (danielc)


Revision History:

    03-Aug-2000 Thu 19:58:18 updated  -by-  Daniel Chou (danielc)
        Overloading the pPaletteEntry to returned a inverted indices palette
        based on Whistler bug# 22915.  Because the Windows GDI ROP assume
        index 0 always black, last index alwasy white without checking the
        halftone palette and cause many rop got inverted result.

    08-Sep-2000 Fri 14:24:28 updated  -by-  Daniel Chou (danielc)
     For new CMY_INVERTED mode, we want to make sure we pack all
     possible ink entries in the middle of 256 indices and pack
     black/white at end.  If the total ink color compositions are
     an odd number then we duplicate the middle one.  This will

//
// ***************************************************************************
// * SPECIAL NOTE for Windows NT version later than Windows 2000 Release     *
// ***************************************************************************
// Current version of Window NT (Post Windows 2000) will Overloading the
// pPaletteEntry in HT_Get8BPPMaskPalette(DoUseCMYMask) API to returned a
// inverted indices palette based on additive palette entries composition.
// Because Windows GDI ROP assume index 0 always black and last index always
// white without checking the palette entries. (Indices based ROPs rather color
// based)  This cause many ROPS got wrong result which has inverted output.
//
// To correct this GDI ROPs behavior, the POST windows 2000 version of GDI
// Halftone will supports a special CMY_INVERTED format. All new drivers should
// use this CMY_INVERTED method for future compabilities
//
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @   Following Steps are required for ALL POST Windows 2000 Drivers when    @
// @   using Window GDI Halftone 8bpp CMY332 Mask mode                        @
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
// 1. Must set HT_FLAG_INVERT_8BPP_BITMASK_IDX flags
//
// 2. Must set pPaleteEntry[0] when calling HT_Get8BPPMaskPalette() with
//
//     pPaletteEntry[0].peRed   = 'R';
//     pPaletteEntry[0].peGreen = 'G';
//     pPaletteEntry[0].peBlue  = 'B';
//     pPaletteEntry[0].peFlags = '0';
//
//     The caller can use following supplied macro to set this for future
//     compabilities
//
//         HT_SET_BITMASKPAL2RGB(pPaletteEntry)
//
//     where pPaletteEntry is the pointer to the PALETTEENTRY that passed to
//     the HT_GET8BPPMaskPalette() fucntion call
//
// 3. Must Check the return Palette from HT_Get8BPPMaskPalette() using
//    following Macro
//
//         HT_IS_BITMASKPALRGB(pPaletteEntry)
//
//    where pPaletteEntry is the pointer to the PALETTEENTRY that passed to the
//    HT_GET8BPPMaskPalette() fucntion call,
//
//    If this macro return FALSE then the current version of GDI HALFTONE does
//    NOT support the CMY_INVERTED 8bpp bitmaask mode and it only supports CMY
//    mode.
//
//    If this macro return TRUE then the GDI HALFTONE DOES support the
//    CMY_INVERTED 8bpp bitmaask mode and the caller must using a translation
//    table to obtain final halftone surface bitmap 8bpp indices ink levels.
//
// 4. Behavior changes for GDI halftone that supports 8bpp CMY_INVERTED bitmask
//    mode, following is a list of changes of CMYMask mode passed to
//    the HT_Get8BPPMaskPalette()
//
//    CMYMask      CMY Mode Indices          CMY_INVERTED Mode Indices
//    =======  =========================   =============================
//         0         0: WHITE                    0: BLACK
//               1-254: Light->Dark Gray     1-254: Dark->Light Gray
//                 255: BLACK                  255: WHITE
//    -------------------------------------------------------------------
//         1         0: WHITE                 0-65: BLACK
//               1-123: 5^3 CMY color       66-188: 5^3 RGB color
//             124-255: BLACK              189-255: WHITE
//                                         127-128: Duplicate for XOR ROP
//                                                  (CMY Levels 2:2:2)
//    -------------------------------------------------------------------
//         2         0: WHITE                 0-20: BLACK
//               1-214: 6^3 CMY color       21-234: 6^3 RGB color
//             215-255: BLACK              235-255: WHITE
//    -------------------------------------------------------------------
//     3-255*        0: WHITE                    0: BLACK
//               1-254: CMY Color BitMask    1-254: Centered CxMxY BitMask*
//                 255: BLACK                  255: WHITE
//    ===================================================================
//
//     * For CMYMask mode 3-255, the valid combination must NOT have any
//       of Cyan, Magenta or Yellow ink level equal to 0.
//
//     * The reason for CMY_INVERTED mode that pading BLACK and WHITE entires
//       at both end and have all other color in the middle is to make sure
//       all 256 color palette entries are even distributed so that GDI ROPs
//       (raster operation) will work more correctly. This is because GDI ROPs
//       are based on the indices not color
//
//     * The CMY_INVERTED Mode has all non-black, non white indices centered
//       and even distributed within the total 256 palette indices.  For
//       example; if a CMY=333 levels then it has total 3x3x3=27 indices,
//       these 27 indices will be centered by packing 114 black indices at
//       begining and packing 114 white indices at end to ensure that ROP
//       will be correct rendered.
//
//       See following sample function of for how to generate these ink levels
//       and Windows 2000 CMY332 Index translation table
//
//
// 5. For CMYMask index mode 0 to 255, the caller can use following sample
//    function to genrate INKLEVELS translation table
//
//    The follwing structure and tables are examples of how to translate 8bpp
//    bitmask halftone bitmap indices to ink levels
//
//        typedef struct _INKLEVELS {
//             BYTE    Cyan;        // Cyan level from 0 to max
//             BYTE    Magenta;     // Magenta level from 0 to max
//             BYTE    Yellow;      // Yellow level from 0 to max
//             BYTE    CMY332Idx;   // Original windows 2000 CMY332 Index
//             } INKLEVELS, *PINKLEVELS;
//
//     To Compute a 8bpp translate table of INKLEVELS, following sample
//     function show how to genrate a INKLEVELS translate table for a valid
//     CMYMask range from 0 to 255.  It can be use to generate either Windows
//     2000 CMY Mode or new Post Windows 2000's CMY_INVERTED mode translation
//     table.  It also generate a windows 2000 CMY Mode CMY332Idx so caller
//     can map CMY_INVERTED new indices to old index for current existing
//     indices processing function.
//
//     Example Function that generate translate table for CMYMask 0 to 255,
//     the pInkLevels must pointed to a valid memory location of 256 INKLEVELS
//     entries, if return value is TRUE then it can be used to trnaslate 8bpp
//     indices to ink levels or mapp to the older CMY332 style indices.
//
//     
//     BOOL
//     GenerateInkLevels(
//         PINKLEVELS  pInkLevels,     // Pointer to 256 INKLEVELS table
//         BYTE        CMYMask,        // CMYMask mode
//         BOOL        CMYInverted     // TRUE for CMY_INVERTED mode
//         )
//     {
//         PINKLEVELS  pILDup;
//         PINKLEVELS  pILEnd;
//         INKLEVELS   InkLevels;
//         INT         Count;
//         INT         IdxInc;
//         INT         cC;
//         INT         cM;
//         INT         cY;
//         INT         xC;
//         INT         xM;
//         INT         xY;
//         INT         iC;
//         INT         iM;
//         INT         iY;
//         INT         mC;
//         INT         mM;
//
//
//         switch (CMYMask) {
//
//         case 0:
//
//             cC =
//             cM =
//             xC =
//             xM = 0;
//             cY =
//             xY = 255;
//             break;
//
//         case 1:
//         case 2:
//
//             cC =
//             cM =
//             cY =
//             xC =
//             xM =
//             xY = 3 + (INT)CMYMask;
//             break;
//
//         default:
//
//             cC = (INT)((CMYMask >> 5) & 0x07);
//             cM = (INT)((CMYMask >> 2) & 0x07);
//             cY = (INT)( CMYMask       & 0x03);
//             xC = 7;
//             xM = 7;
//             xY = 3;
//             break;
//         }
//
//         Count = (cC + 1) * (cM + 1) * (cY + 1);
//
//         if ((Count < 1) || (Count > 256)) {
//
//             return(FALSE);
//         }
//
//         InkLevels.Cyan      =
//         InkLevels.Magenta   =
//         InkLevels.Yellow    =
//         InkLevels.CMY332Idx = 0;
//         mC                  = (xM + 1) * (xY + 1);
//         mM                  = xY + 1;
//         pILDup              = NULL;
//
//         if (CMYInverted) {
//
//             //
//             // Move the pInkLevels to the first entry which center around
//             // 256 table entries, if we skip any then all entries skipped
//             // will be white (CMY levels all zeros).  Because this is
//             // CMY_INVERTED so entries start from back of the table and
//             // moving backward to the begining of the table
//             //
//
//             pILEnd      = pInkLevels - 1;
//             IdxInc      = ((256 - Count - (Count & 0x01)) / 2);
//             pInkLevels += 255;
//
//             while (IdxInc--) {
//
//                 *pInkLevels-- = InkLevels;
//             }
//
//             if (Count & 0x01) {
//
//                 //
//                 // If we have odd number of entries then we need to
//                 // duplicate the center one for correct XOR ROP to
//                 // operated correctly. The pILDup will always be index
//                 // 127, the duplication are indices 127, 128
//                 //
//
//                 pILDup = pInkLevels - (Count / 2) - 1;
//             }
//
//             //
//             // We running from end of table to the begining, because
//             // when in CMYInverted mode, the index 0 is black and index
//             // 255 is white.  Since we only generate 'Count' of index
//             // and place them at center, we will change xC, xM, xY max.
//             // index to same as cC, cM and cY.
//             //
//
//             IdxInc = -1;
//             xC     = cC;
//             xM     = cM;
//             xY     = cY;
//
//         } else {
//
//             IdxInc = 1;
//             pILEnd = pInkLevels + 256;
//         }
//
//         //
//         // At following, the composition of ink levels, index always
//         // from 0 CMY Ink levels (WHITE) to maximum ink levels (BLACK),
//         // the different with CMY_INVERTED mode is we compose it from
//         // index 255 to index 0 rather than from index 0 to 255
//         //
//
//         if (CMYMask) {
//
//             INT Idx332C;
//             INT Idx332M;
//
//             for (iC = 0, Idx332C = -mC; iC <= xC; iC++) {
//
//                 if (iC <= cC) {
//
//                     InkLevels.Cyan  = (BYTE)iC;
//                     Idx332C        += mC;
//                 }
//
//                 for (iM = 0, Idx332M = -mM; iM <= xM; iM++) {
//
//                     if (iM <= cM) {
//
//                         InkLevels.Magenta  = (BYTE)iM;
//                         Idx332M           += mM;
//                     }
//
//                     for (iY = 0; iY <= xY; iY++) {
//
//                         if (iY <= cY) {
//
//                             InkLevels.Yellow = (BYTE)iY;
//                         }
//
//                         InkLevels.CMY332Idx = (BYTE)(Idx332C + Idx332M) +
//                                               InkLevels.Yellow;
//                         *pInkLevels         = InkLevels;
//
//                         if ((pInkLevels += IdxInc) == pILDup) {
//
//                             *pInkLevels  = InkLevels;
//                             pInkLevels  += IdxInc;
//                         }
//                     }
//                 }
//             }
//
//             //
//             // Now if we need to pack black at other end of the
//             // translation table then do it here, Notice that InkLevels
//             // are at cC, cM and cY here and the CMY332Idx is at BLACK
//             //
//
//             while (pInkLevels != pILEnd) {
//
//                 *pInkLevels  = InkLevels;
//                 pInkLevels  += IdxInc;
//             }
//
//         } else {
//
//             //
//             // Gray Scale case
//             //
//
//             for (iC = 0; iC < 256; iC++, pInkLevels += IdxInc) {
//
//                 pInkLevels->Cyan      =
//                 pInkLevels->Magenta   =
//                 pInkLevels->Yellow    =
//                 pInkLevels->CMY332Idx = (BYTE)iC;
//             }
//         }
//
//         return(TRUE);
//     }
//
//
// 6. For CMYMask Mode 0 (Gray scale), the gray scale table just inverted
//    between CMY and CMY_INVERTED mode.
//
//     CMY mode:          0 to 255 gray scale from WHITE to BLACK increment,
//     CMY_INVERTED Mode: 0 to 255 gray scale from BLACK to WHITE increment.
//
//
// 7. For CMYMask Mode 1 and 2, the caller should use a translation table for
//    translate indices to CMY ink levels.
//
// 8. For CMYMode mode 3 to 255,
//
//    if in CMY Mode (Windows 2000) is specified then The final CMY ink levels
//    indices byte has following meanings
//
//         Bit     7 6 5 4 3 2 1 0
//                 |   | |   | | |
//                 +---+ +---+ +=+
//                   |     |    |
//                   |     |    +-- Yellow 0-3 (Max. 4 levels)
//                   |     |
//                   |     +-- Magenta 0-7 (Max. 8 levels)
//                   |
//                   +-- Cyan 0-7 (Max. 8 levels)
//
//
//     If a CMY_INVERTED mode is specified then caller must use a translation
//     table to convert a index to the ink levels, to generate this table,
//     please see above #5 description.
//
//

--*/

{
    LPPALETTEENTRY  pPalOrg;
    FD6             RGBGamma[3];
    FD6             Tmp;
    FD6             Y;
    INT             PalInc;
    UINT            PalStart;
    UINT            PalIdx;
    UINT            cC;
    UINT            cM;
    UINT            cY;
    UINT            iC;
    UINT            iM;
    UINT            iY;
    UINT            MaxPal;
    UINT            IdxPalDup;
    BYTE            bR;
    BYTE            bG;
    BYTE            bB;


    DBGP_IF(DBGP_HTAPI,
            DBGP("HT_Get8BPPMaskPalette(%p): UseMask=%ld, CMYMask=%02lx, Gamma=%05ld:%05ld:%05ld"
                    ARGPTR(pPaletteEntry)
                    ARGDW((Use8BPPMaskPal) ? 1 : 0)
                    ARGDW(CMYMask)
                    ARGDW(RedGamma) ARGDW(GreenGamma) ARGDW(BlueGamma)));

    if (!Use8BPPMaskPal) {

        return(HT_Get8BPPFormatPalette(pPaletteEntry,
                                       RedGamma,
                                       GreenGamma,
                                       BlueGamma));
    }

    //
    // Checking the CMYMask first to make sure caller passed valid CMYMask
    //

    switch (CMYMask) {

    case 1:

        cC       =
        cM       =
        cY       = 4;
        MaxPal   = 125;
        break;

    case 2:

        cC     =
        cM     =
        cY     = 5;
        MaxPal = 216;
        break;

    default:

        MaxPal = 0;
        cC     = (UINT)((CMYMask >> 5) & 0x07);
        cM     = (UINT)((CMYMask >> 2) & 0x07);
        cY     = (UINT)((CMYMask >> 0) & 0x03);

        //
        // If this is not zero, but one of the cC, cM, cY is zero then return
        // zero to indicate error
        //

        if ((CMYMask != 0) && ((!cC) || (!cM) || (!cY))) {

            ASSERTMSG("One of Ink Levels is ZERO", (cC) && (cM) && (cY));

            return(0);
        }

        break;
    }

    //
    // Initialize All internal data first
    //

    if (pPalOrg = pPaletteEntry) {

        PalStart  = 0;
        PalInc    = 1;
        IdxPalDup = 0x200;

        //
        // Since we will always compose the palette using CMY method, the only
        // thing we need to do for the RGB mode is write the palette from index
        // 255 to 0, the backward writing provied that caller can just invert
        // its 8bpp indices to get the CMY ink levels definition
        //

        if (*((LPDWORD)pPaletteEntry) == HTBITMASKPALRGB_DW) {

            //
            // RGB Mode, go to end of the palette end move backward, the reason
            // for the 5:5:5 and 6:6:6 that pas white and black at both end is
            // to make sure the ROP work more correctly for the GDI.
            //

            pPaletteEntry += 255;
            PalInc         = -1;

            //
            // 08-Sep-2000 Fri 14:22:02 updated  -by-  Daniel Chou (danielc)
            //  For new CMY_INVERTED mode, we want to make sure we pack all
            //  possible ink entries in the middle of 256 indices and pack
            //  black/white at end.  If the total ink color compositions are
            //  an odd number then we duplicate the middle one.  This will
            //  ensure that the ROP will work correctly on color entries
            //

            if (CMYMask) {

                MaxPal    = (cC + 1) * (cM + 1) * (cY + 1);
                PalStart  = (256 - MaxPal) >> 1;

                if (MaxPal & 0x01) {

                    IdxPalDup = (MaxPal >> 1) + PalStart;
                }
            }
        }

        //
        // Clear all palette entries to zero first
        //

        ZeroMemory(pPalOrg, sizeof(PALETTEENTRY) * 256);

        RGBGamma[0] = UDECI4ToFD6(RedGamma);
        RGBGamma[1] = UDECI4ToFD6(GreenGamma);
        RGBGamma[2] = UDECI4ToFD6(BlueGamma);
        PalIdx      = 0;

        DBGP_IF(DBGP_GAMMA_PAL,
                DBGP("***** HT_Get8BPPMaskPalette: %s:%s:%s, CMY=%u:%u:%u=%3ld (%s, %ld,%ld) *****"
                     ARGFD6(RGBGamma[0], 1, 4)
                     ARGFD6(RGBGamma[1], 1, 4)
                     ARGFD6(RGBGamma[2], 1, 4)
                     ARGDW(cC) ARGDW(cM) ARGDW(cY) ARGDW(MaxPal)
                     ARGPTR((PalInc==-1) ? "RGB" : "CMY")
                     ARGDW(PalStart) ARGDW(IdxPalDup)));

        if (MaxPal) {

            //
            // For the begining filler, we will fill with WHITE, because
            // we are composing use CMY, when CMY is 0 it means white
            //

            for (;
                 PalIdx < PalStart;
                 PalIdx++, pPaletteEntry += PalInc) {

                pPaletteEntry->peRed   =
                pPaletteEntry->peGreen =
                pPaletteEntry->peBlue  = 0xFF;
            }

            for (iC = 0; iC <= cC; iC++) {

                CMY_8BPP(bR, iC, cC, Tmp);

                for (iM = 0; iM <= cM; iM++) {

                    CMY_8BPP(bG, iM, cM, Tmp)

                    for (iY = 0;
                         iY <= cY;
                         iY++, PalIdx++, pPaletteEntry += PalInc) {

                        CMY_8BPP(bB, iY, cY, Tmp);

                        pPaletteEntry->peRed   = bR;
                        pPaletteEntry->peGreen = bG;
                        pPaletteEntry->peBlue  = bB;

                        DBGP_IF(DBGP_GAMMA_PAL,
                                DBGP("[%3ld] %3u - %3u:%3u:%3u"
                                 ARGU(pPaletteEntry - pPalOrg)
                                 ARGU(PalIdx)
                                 ARGU(pPaletteEntry->peRed  )
                                 ARGU(pPaletteEntry->peGreen)
                                 ARGU(pPaletteEntry->peBlue )));

                        if (PalIdx == IdxPalDup) {

                            ++PalIdx;
                            pPaletteEntry          += PalInc;
                            pPaletteEntry->peRed    = bR;
                            pPaletteEntry->peGreen  = bG;
                            pPaletteEntry->peBlue   = bB;

                            DBGP_IF(DBGP_GAMMA_PAL,
                                    DBGP("[%3ld] %3u - %3u:%3u:%3u --- DUP"
                                     ARGU(pPaletteEntry - pPalOrg)
                                     ARGU(PalIdx)
                                     ARGU(pPaletteEntry->peRed  )
                                     ARGU(pPaletteEntry->peGreen)
                                     ARGU(pPaletteEntry->peBlue )));
                        }
                    }
                }
            }

            //
            // For ending fillers (Current PalIdx to 255), we will fill with
            // BLACK, because we are composing use CMY, when CMY is at MAX it
            // means BLACK, Since we clear all pPalOrg to ZERO at begining of
            // this function, so we are done and do not need to do anything.
            //

        } else if ((cC < 1) || (cM < 1) || (cY < 1)) {

            for (Y = 255;
                 PalIdx <= 255;
                 PalIdx++, Y--, pPaletteEntry += PalInc) {

                pPaletteEntry->peRed   =
                pPaletteEntry->peGreen =
                pPaletteEntry->peBlue  = (BYTE)Y;

                DBGP_IF(DBGP_GAMMA_PAL,
                        DBGP("[%3ld] %3u - %3u:%3u:%3u"
                         ARGU(pPaletteEntry - pPalOrg)
                         ARGU(PalIdx)
                         ARGU(pPaletteEntry->peRed  )
                         ARGU(pPaletteEntry->peGreen)
                         ARGU(pPaletteEntry->peBlue )));
            }

        } else {

            for (iC = 0; iC <= 7; iC++) {

                CMY_8BPP(bR, iC, cC, Tmp);

                for (iM = 0; iM <= 7; iM++) {

                    CMY_8BPP(bG, iM, cM, Tmp)

                    for (iY = 0;
                         iY <= 3;
                         iY++, PalIdx++, pPaletteEntry += PalInc) {

                        CMY_8BPP(bB, iY, cY, Tmp);

                        pPaletteEntry->peRed   = bR;
                        pPaletteEntry->peGreen = bG;
                        pPaletteEntry->peBlue  = bB;

                        DBGP_IF(DBGP_GAMMA_PAL,
                                DBGP("[%3ld] %3u - %3u:%3u:%3u"
                                 ARGU(pPaletteEntry - pPalOrg)
                                 ARGU(PalIdx)
                                 ARGU(pPaletteEntry->peRed  )
                                 ARGU(pPaletteEntry->peGreen)
                                 ARGU(pPaletteEntry->peBlue )));
                    }
                }
            }
        }
    }

    //
    // Always return full 256 palette entry for halftone
    //

    return((LONG)256);
}




LONG
APIENTRY
HT_LOADDS
HT_CreateStandardMonoPattern(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo,
    PSTDMONOPATTERN     pStdMonoPattern
    )

/*++

Routine Description:

    This function create standard predefined monochrome pattern for the device.

Arguments:

    pDeviceHalftoneInfo - Pointer to the DEVICEHALFTONEINFO data structure
                          which returned from the HT_CreateDeviceHalftoneInfo.

    pStdMonoPattern     - Pointer to the STDMONOPATTERN data structure, the
                          pPattern in this data structure is optional.

Return Value:

    if the return value is negative or zero then an error was encountered,
    possible error codes are

        HTERR_INVALID_DHI_POINTER           - Invalid pDevideHalftoneInfo is
                                              passed.

        HTERR_INVALID_STDMONOPAT_INDEX      - The PatternIndex field in
                                              STDMONOPATTERN data structure is
                                              invalid.
    otherwise

        If pPattern field in STDMONOPATTERN data structure Surface is NULL, it
        return the bytes count which need to stored the pattern, otherwise it
        return the size in byte copied to the pattern buffer.

Author:

    05-Feb-1991 Tue 14:28:23 created  -by-  Daniel Chou (danielc)


Revision History:

    05-Jun-1991 Wed 10:22:41 updated  -by-  Daniel Chou (danielc)

        Fixed the bugs when the pStdMonoPattern is NULL, it was used without
        checking it.


--*/

{

    PDEVICECOLORINFO    pDCI;
    CHBINFO             CHBInfo;
    CTSTD_UNION         CTSTDUnion;
    LONG                Result;
    WORD                PatCX;
    WORD                PatCY;
    BYTE                PatIndex;


    if ((PatIndex = pStdMonoPattern->PatternIndex) > HT_SMP_MAX_INDEX) {

        HTAPI_RET(HTAPI_IDX_CREATE_SMP, HTERR_INVALID_STDMONOPAT_INDEX);
    }

    CTSTDUnion.b.cbPrim    =
    CTSTDUnion.b.SrcOrder  =
    CTSTDUnion.b.BMFDest   =
    CTSTDUnion.b.DestOrder = 0;

    if (!(pDCI = pDCIAdjClr(pDeviceHalftoneInfo,
                            NULL,
                            NULL,
                            0,
                            0,
                            CTSTDUnion.b,
                            &Result))) {

        HTAPI_RET(HTAPI_IDX_CREATE_SMP, Result);
    }

    if (PatIndex >= HT_SMP_PERCENT_SCREEN_START) {

        CHBInfo.DestScanLineAlignBytes = pStdMonoPattern->ScanLineAlignBytes;
        PatCX = pStdMonoPattern->cxPels = pDCI->HTCell.cxReal;
        PatCY = pStdMonoPattern->cyPels = pDCI->HTCell.Height;

        pStdMonoPattern->BytesPerScanLine = (WORD)
                ComputeBytesPerScanLine((UINT)BMF_1BPP,
                                        (UINT)CHBInfo.DestScanLineAlignBytes,
                                        (DWORD)PatCX);
        CHBInfo.Flags = CHBF_BW_ONLY;

        if (pStdMonoPattern->pPattern) {

            BYTE        rgb[3];
            COLORTRIAD  ColorTriad;

            rgb[0] =
            rgb[1] =
            rgb[0] = (BYTE)(HT_SMP_MAX_INDEX - PatIndex);

            ColorTriad.Type              = (BYTE)COLOR_TYPE_RGB;
            ColorTriad.BytesPerPrimary   = (BYTE)sizeof(BYTE);
            ColorTriad.BytesPerEntry     = (BYTE)(sizeof(BYTE) * 3);
            ColorTriad.PrimaryOrder      = PRIMARY_ORDER_RGB;
            ColorTriad.PrimaryValueMax   = (FD6)100;
            ColorTriad.ColorTableEntries = 1;
            ColorTriad.pColorTable       = (LPVOID)rgb;

            if (pStdMonoPattern->Flags & SMP_0_IS_BLACK) {

                CHBInfo.Flags |= CHBF_USE_ADDITIVE_PRIMS;
            }

            if (!(pStdMonoPattern->Flags & SMP_TOPDOWN)) {

                CHBInfo.Flags |= CHBF_BOTTOMUP_BRUSH;
            }

            CHBInfo.DestSurfaceFormat = BMF_1BPP;
            CHBInfo.DestPrimaryOrder  = PRIMARY_ORDER_123;

            Result = HT_CreateHalftoneBrush(pDeviceHalftoneInfo,
                                            NULL,
                                            &ColorTriad,
                                            CHBInfo,
                                            (LPVOID)pStdMonoPattern->pPattern);

        } else {

            Result = (LONG)pStdMonoPattern->BytesPerScanLine *
                     (LONG)PatCY;
        }

    } else {

        Result = GetCachedSMP(pDCI, pStdMonoPattern);
    }

    RELEASE_HTMUTEX(pDCI->HTMutex);

DBGP_IF(DBGP_SHOWPAT,

    LPBYTE  pCurPat;
    LPBYTE  pPatScan;
    BYTE    Buf1[80];
    BYTE    Buf2[80];
    BYTE    Buf3[80];
    BYTE    Digit1;
    BYTE    Digit2;
    WORD    Index;
    WORD    XInc;
    WORD    YInc;
    BYTE    Mask;
    BOOL    Swap;


    DBGP_IF(DBGP_HTAPI,
            DBGP("HT_CreateStandardMonoPattern(%d) = %ld"
                            ARGI(PatIndex - HT_SMP_PERCENT_SCREEN_START)
                            ARGDW(Result)));

    if ((Result > 0) && (pPatScan = pStdMonoPattern->pPattern)) {

        Swap = (BOOL)(pStdMonoPattern->Flags & SMP_0_IS_BLACK);

        FillMemory(Buf1, 80, ' ');
        FillMemory(Buf2, 80, ' ');
        Digit1 = 0;
        Digit2 = 0;
        Index = 4;
        XInc = pStdMonoPattern->cxPels;

        while ((XInc--) && (Index < 79)) {

            if (!Digit2) {

                Buf1[Index] = (BYTE)(Digit1 + '0');

                if (++Digit1 == 10) {

                    Digit1 = 0;
                }
            }

            Buf2[Index] = (BYTE)(Digit2 + '0');

            if (++Digit2 == 10) {

                Digit2 = 0;
            }

            ++Index;
        }

        Buf1[Index] = Buf2[Index] = 0;

        DBGP("%s" ARG(Buf1));
        DBGP("%s\r\n" ARG(Buf2));

        for (YInc = 0; YInc < pStdMonoPattern->cyPels; YInc++) {

            Index = (WORD)sprintf(Buf3, "%3u ", YInc);

            pCurPat = pPatScan;

            for (XInc = 0, Mask = 0x80;
                 XInc < pStdMonoPattern->cxPels;
                 XInc++) {

                if (Swap) {

                    Buf3[Index] = (BYTE)((*pCurPat & Mask) ? '' : '');

                } else {

                    Buf3[Index] = (BYTE)((*pCurPat & Mask) ? '' : '');
                }

                if (!(Mask >>= 1)) {

                    Mask = 0x80;
                    ++pCurPat;
                }

                if (++Index > 75) {

                    Index = 75;
                }
            }

            sprintf(&Buf3[Index], " %-3u", YInc);
            DBGP("%s" ARG(Buf3));

            pPatScan += pStdMonoPattern->BytesPerScanLine;
        }

        DBGP("\r\n%s" ARG(Buf2));
        DBGP("%s" ARG(Buf1));
    }
)

    HTAPI_RET(HTAPI_IDX_CREATE_SMP, Result);
}




LONG
HTENTRY
CheckABInfo(
    PBITBLTPARAMS   pBBP,
    UINT            SrcSurfFormat,
    UINT            DstSurfFormat,
    LPWORD          pForceFlags,
    PLONG           pcOutMax
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    04-Mar-1999 Thu 18:41:06 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PABINFO pABInfo;
    LONG    cOutMax;
    WORD    ForceFlags;


    if (!(pABInfo = pBBP->pABInfo)) {

        return(HTERR_INVALID_ABINFO);
    }

    switch (DstSurfFormat) {

    case BMF_1BPP:

        cOutMax = 2;
        break;

    case BMF_4BPP:
    case BMF_4BPP_VGA16:

        cOutMax = 16;
        break;

    case BMF_8BPP:
    case BMF_8BPP_VGA256:

        cOutMax = 256;
        break;

    default:

        cOutMax = 0;
        break;
    }

    if (cOutMax) {

        if ((pABInfo->pDstPal == NULL) ||
            (pABInfo->cDstPal > cOutMax)) {

            return(HTERR_INVALID_ABINFO);
        }
    }

    *pForceFlags |= ADJ_FORCE_ALPHA_BLEND;


    if (pABInfo->Flags & ABIF_USE_CONST_ALPHA_VALUE) {

        switch (pABInfo->ConstAlphaValue) {

        case 0:

            //
            // We do not need to do anything
            //

            return(0);

        case 0xFF:

            *pForceFlags &= ~ADJ_FORCE_ALPHA_BLEND;
            cOutMax       = 0;
            break;

        default:

            *pForceFlags |= ADJ_FORCE_CONST_ALPHA;
            break;
        }

    } else if (SrcSurfFormat != BMF_32BPP) {

         return(HTERR_INVALID_SRC_FORMAT);

    } else {

        if (pABInfo->Flags & ABIF_SRC_ALPHA_IS_PREMUL) {

            *pForceFlags |= ADJ_FORCE_AB_PREMUL_SRC;
        }

        if (pABInfo->Flags & ABIF_BLEND_DEST_ALPHA) {

            if (DstSurfFormat != BMF_32BPP) {

                return(HTERR_INVALID_DEST_FORMAT);
            }

            *pForceFlags |= ADJ_FORCE_AB_DEST;
        }
    }

    *pcOutMax = cOutMax;

    return(1);
}




LONG
APIENTRY
HT_LOADDS
HT_HalftoneBitmap(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo,
    PHTCOLORADJUSTMENT  pHTColorAdjustment,
    PHTSURFACEINFO      pSourceHTSurfaceInfo,
    PHTSURFACEINFO      pSourceMaskHTSurfaceInfo,
    PHTSURFACEINFO      pDestinationHTSurfaceInfo,
    PBITBLTPARAMS       pBitbltParams
    )

/*++

Routine Description:

    This function halftone the source bitmap and output to the destination
    surface depends on the surface type and bitblt parameters

    The source surface type must one of the following:

        1-bit per pel. (BMF_1BPP)
        4-bit per pel. (BMF_4BPP)
        8-bit per pel. (BMF_8BPP)
       16-bit per pel. (BMF_16BPP)
       24-bit per pel. (BMF_24BPP)
       32-bit per pel. (BMF_32BPP)

    The destination surface type must one of the following:

        1-bit per pel.                  (BMF_1BPP)
        4-bit per pel.                  (BMF_4BPP)
        3 plane and 1 bit per pel.      (BMF_1BPP_3PLANES)

Arguments:

    pDeviceHalftoneInfo         - pointer to the DEVICEHALFTONEINFO data
                                  structure

    pHTColorAdjustment          - Pointer to the HTCOLORADJUSTMENT data
                                  structure to specified the input/output color
                                  adjustment/transform, if this pointer is NULL
                                  then a default color adjustments is applied.

    pSourceHTSurfaceInfo        - pointer to the source surface infomation.

    pSourceMaskHTSurfaceInfo    - pointer to the source mask surface infomation,
                                  if this pointer is NULL then there is no
                                  source mask for the halftoning.

    pDestinationHTSurfaceInfo   - pointer to the destination surface infomation.

    pBitbltParams               - pointer to the BITBLTPARAMS data structure to
                                  specified the source, destination, source
                                  mask and clipping rectangle information, the
                                  content of this data structure will not be
                                  modified by this function.


Return Value:

    if the return value is less than zero then an error has occurred,
    the error code is one of the following #define which start with HTERR_.

    HTERR_INSUFFICIENT_MEMORY           - not enough memory to do the halftone
                                          process.

    HTERR_COLORTABLE_TOO_BIG            - can not create the color table to map
                                          the colors to the dyes' densities.

    HTERR_QUERY_SRC_BITMAP_FAILED       - callback function return FALSE when
                                          query the source bitmap pointer.

    HTERR_QUERY_DEST_BITMAP_FAILED      - callback function return FALSE when
                                          query the destination bitmap pointers.

    HTERR_INVALID_SRC_FORMAT            - Invalid source surface format.

    HTERR_INVALID_DEST_FORMAT           - Invalid destination surface type,
                                          this function only recongnized 1/4/
                                          bits per pel source surfaces or 1 bit
                                          per pel 3 planes.

    HTERR_INVALID_DHI_POINTER           - Invalid pDevideHalftoneInfo is passed.

    HTERR_SRC_MASK_BITS_TOO_SMALL       - If the source mask bitmap is too
                                          small to cover the visible region of
                                          the source bitmap.

    HTERR_INVALID_MAX_QUERYLINES        - One or more of Source/Destination
                                          SourceMasks' maximum query scan line
                                          is < 0

    HTERR_INTERNAL_ERRORS_START         - any other negative numbers indicate
                                          a halftone internal failue.

   else                                - the total destination scan lines
                                          halftoned.


Author:

    05-Feb-1991 Tue 15:23:07 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PDEVICECOLORINFO    pDCI;
    PHALFTONERENDER     pHR;
    PAAHEADER           pAAHdr;
    PDEVCLRADJ          pDevClrAdj;
    PRGB4B              pClrTable;
    PABINFO             pABInfo;
    LONG                Result;
    WORD                ForceFlags;
    WORD                BBPFlags;
    CTSTD_UNION         CTSTDUnion;
    LONG                cInPal;
    LONG                cInMax;
    LONG                cOutMax;
    BYTE                SrcSurfFormat;
    BYTE                DstSurfFormat;
    CONST static BYTE   MaxPal_0148_LS[4] = { 0, 1, 4, 8 };


    DBG_TIMER_RESET;

    SrcSurfFormat = pSourceHTSurfaceInfo->SurfaceFormat;
    DstSurfFormat = pDestinationHTSurfaceInfo->SurfaceFormat;
    BBPFlags      = pBitbltParams->Flags;
    ForceFlags    = 0;

    cInPal  =
    cInMax  =
    cOutMax = 0;

    switch (SrcSurfFormat) {

    case BMF_1BPP:
    case BMF_4BPP:
    case BMF_8BPP:

        cInMax = (UINT)0x01 << MaxPal_0148_LS[SrcSurfFormat];

        if (pSourceHTSurfaceInfo->pColorTriad) {

            cInPal = (LONG)pSourceHTSurfaceInfo->pColorTriad->ColorTableEntries;
        }

        if (!cInPal) {

            HTAPI_RET(HTAPI_IDX_HALFTONE_BMP, HTERR_INVALID_COLOR_TABLE);
        }

    default:

        break;
    }

    if ((BBPFlags & BBPF_DO_ALPHA_BLEND)    &&
        ((Result = CheckABInfo(pBitbltParams,
                               SrcSurfFormat,
                               DstSurfFormat,
                               &ForceFlags,
                               &cOutMax)) <= 0)) {

        HTAPI_RET(HTAPI_IDX_HALFTONE_BMP, Result);
    }

    DBGP_IF(DBGP_SRCBMP,
            DBGP("SrcFmt=%ld, cInPal=%ld (%ld), DstFmt=%ld, cOutMax=%ld"
                ARGDW(SrcSurfFormat) ARGDW(cInMax) ARGDW(cInPal)
                ARGDW(DstSurfFormat) ARGDW(cOutMax)));

    CTSTDUnion.b.cbPrim    = 0;
    CTSTDUnion.b.SrcOrder  = PRIMARY_ORDER_BGR;
    CTSTDUnion.b.BMFDest   = (BYTE)DstSurfFormat;
    CTSTDUnion.b.DestOrder = (BYTE)pBitbltParams->DestPrimaryOrder;

    if (BBPFlags & BBPF_USE_ADDITIVE_PRIMS) {

        ForceFlags |= ADJ_FORCE_ADDITIVE_PRIMS;
    }

    if (BBPFlags & BBPF_NEGATIVE_DEST) {

        ForceFlags |= ADJ_FORCE_NEGATIVE;
    }

    if ((BBPFlags & BBPF_BW_ONLY) ||
        (CTSTDUnion.b.BMFDest == BMF_1BPP)) {

        ForceFlags |= ADJ_FORCE_MONO;
    }

    if (BBPFlags & BBPF_ICM_ON) {

        ForceFlags |= ADJ_FORCE_ICM;
    }

    //
    // Find out if we will call anti-aliasing codes
    //

    ASSERTMSG("Source X is not well ordered",
                    pBitbltParams->rclSrc.right >= pBitbltParams->rclSrc.left);
    ASSERTMSG("Source Y is not well ordered",
                    pBitbltParams->rclSrc.bottom >= pBitbltParams->rclSrc.top);

    if (BBPFlags & BBPF_NO_ANTIALIASING) {

        ForceFlags |= ADJ_FORCE_NO_EXP_AA;
    }

    //
    // Now Compute the Device Color Adjusment data
    //

    if (!(pDCI = pDCIAdjClr(pDeviceHalftoneInfo,
                            pHTColorAdjustment,
                            &pDevClrAdj,
                            sizeof(HALFTONERENDER) + sizeof(AAHEADER) +
                                        ((cInMax + cOutMax) * sizeof(RGB4B)),
                            ForceFlags,
                            CTSTDUnion.b,
                            &Result))) {

        HTAPI_RET(HTAPI_IDX_HALFTONE_BMP, Result);
    }

    pHR = (PHALFTONERENDER)(pDevClrAdj + 1);

    //
    // We will mask out the more flags, since this flag is currently used
    // internally.
    //

    pHR->pDeviceColorInfo = pDCI;
    pHR->pDevClrAdj       = pDevClrAdj;
    pHR->pBitbltParams    = pBitbltParams;
    pHR->pSrcSI           = pSourceHTSurfaceInfo;
    pHR->pSrcMaskSI       = pSourceMaskHTSurfaceInfo;
    pHR->pDestSI          = pDestinationHTSurfaceInfo;
    pAAHdr                = (PAAHEADER)(pHR->pAAHdr = (LPVOID)(pHR + 1));
    pClrTable             = (PRGB4B)(pAAHdr + 1);

    if (cInMax) {

        pAAHdr->SrcSurfInfo.cClrTable  = (WORD)cInPal;
        pAAHdr->SrcSurfInfo.pClrTable  = (PRGB4B)pClrTable;
        pClrTable                     += cInMax;
    }

    if (ForceFlags & ADJ_FORCE_ALPHA_BLEND) {

        if ((!(pDCI->pAlphaBlendBGR))   &&
            (!(pDCI->pAlphaBlendBGR = (LPBYTE)HTAllocMem(pDCI,
                                                         HTMEM_AlphaBlendBGR,
                                                         LPTR,
                                                         AB_DCI_SIZE)))) {

            RELEASE_HTMUTEX(pDCI->HTMutex);

            HTAPI_RET(HTAPI_IDX_HALFTONE_BMP, HTERR_INSUFFICIENT_MEMORY);
        }

        if (ForceFlags & ADJ_FORCE_CONST_ALPHA) {

            pDCI->PrevConstAlpha = pDCI->CurConstAlpha;
            pDCI->CurConstAlpha  = pBitbltParams->pABInfo->ConstAlphaValue;
        }

        if (cOutMax) {

            pAAHdr->DstSurfInfo.pClrTable = (PRGB4B)pClrTable;
            pAAHdr->DstSurfInfo.cClrTable =
                                        (WORD)pBitbltParams->pABInfo->cDstPal;
        }
    }

    pAAHdr->SrcSurfInfo.AABFData.Format = (BYTE)SrcSurfFormat;
    pAAHdr->DstSurfInfo.AABFData.Format = (BYTE)DstSurfFormat;

    if (BBPFlags & BBPF_TILE_SRC) {

        //
        // Remove SrcMask if TILE_SRC is used
        //

        pHR->pSrcMaskSI = NULL;
    }

    //-----------------------------------------------------------------------
    // The semaphore pDCI->HTMutex will be released by AAHalftoneBitmap
    //-----------------------------------------------------------------------

    Result = AAHalftoneBitmap(pHR);

    if (HTFreeMem(pDevClrAdj)) {

        ASSERTMSG("HTFreeMem(pDevClrAdj) Failed", FALSE);
    }

    DBGP_IF(DBGP_HTAPI,
            DBGP("HT_HalftoneBitmap(%ld/%6ld): Src[%ld]=(%4ld,%4ld)-(%4ld,%4ld), Dst[%ld]=(%4ld,%4ld)-(%4ld,%4ld) [0x%04lx]"
                    ARGDW(pDCI->cbMemTot) ARGDW(pDCI->cbMemMax)
                    ARGDW(SrcSurfFormat)
                    ARGDW(pBitbltParams->rclSrc.left)
                    ARGDW(pBitbltParams->rclSrc.top)
                    ARGDW(pBitbltParams->rclSrc.right)
                    ARGDW(pBitbltParams->rclSrc.bottom)
                    ARGDW(DstSurfFormat)
                    ARGDW(pBitbltParams->rclDest.left)
                    ARGDW(pBitbltParams->rclDest.top)
                    ARGDW(pBitbltParams->rclDest.right)
                    ARGDW(pBitbltParams->rclDest.bottom)
                    ARGDW(BBPFlags)));

    DBGP_IF(DBGP_MEMLINK,

           DumpMemLink(NULL, 0);
           DumpMemLink((LPVOID)pDCI, 0);
    )

    DBGP_IF(DBGP_TIMER,

        UINT    i;

        DBG_TIMER_END(TIMER_TOT);

        DbgTimer[TIMER_LAST].Tot = DbgTimer[TIMER_TOT].Tot;

        for (i = 1; i < TIMER_LAST; i++) {

            DbgTimer[TIMER_LAST].Tot -= DbgTimer[i].Tot;
        }

        DBGP("HTBlt(%s): Setup=%s, AA=%s, In=%s, Out=%s, Mask=%s, Fmt=%ld->%ld [%02lx]"
            ARGTIME(TIMER_TOT)
            ARGTIME(TIMER_SETUP)
            ARGTIME(TIMER_LAST)
            ARGTIME(TIMER_INPUT)
            ARGTIME(TIMER_OUTPUT)
            ARGTIME(TIMER_MASK)
            ARGDW(pSourceHTSurfaceInfo->SurfaceFormat)
            ARGDW(pDevClrAdj->DMI.CTSTDInfo.BMFDest)
            ARGDW(pDevClrAdj->DMI.Flags));
    )

    HTAPI_RET(HTAPI_IDX_HALFTONE_BMP, Result);
}




LONG
APIENTRY
HT_LOADDS
HT_GammaCorrectPalette(
    LPPALETTEENTRY  pPaletteEntry,
    LONG            cPalette,
    UDECI4          RedGamma,
    UDECI4          GreenGamma,
    UDECI4          BlueGamma
    )

/*++

Routine Description:

    This functions retrieve a halftone's VGA256 color table definitions

Arguments:

    pPaletteEntry   - Pointer to PALETTEENTRY data structure array,

    cPalette        - Total palette passed by the pPaletteEntry

    RedGamma        - The monitor's red gamma value in UDECI4 format

    GreenGamma      - The monitor's green gamma value in UDECI4 format

    BlueGamma       - The monitor's blue gamma value in UDECI4 format


Return Value:

    if pPaletteEntry is NULL then it return the PALETTEENTRY count needed for
    VGA256 halftone process, if it is not NULL then it return the total
    paletteEntry updated.

    If the pPaletteEntry is not NULL then halftone.dll assume it has enough
    space for the size returned when this pointer is NULL.

Author:

    14-Apr-1992 Tue 13:03:21 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    FD6     RGBGamma[3];
    LONG    cPal;
    FD6     Yr;
    FD6     Yg;
    FD6     Yb;
    BYTE    r;
    BYTE    g;
    BYTE    b;

    //
    // Initialize All internal data first
    //

    if ((cPal = cPalette) && (pPaletteEntry)) {

        RGBGamma[0] = UDECI4ToFD6(RedGamma);
        RGBGamma[1] = UDECI4ToFD6(GreenGamma);
        RGBGamma[2] = UDECI4ToFD6(BlueGamma);

        DBGP_IF(DBGP_GAMMA_PAL,
                DBGP("***** HT_GammaCorrectPalette: %s:%s:%s *****"
                     ARGFD6(RGBGamma[0], 1, 4)
                     ARGFD6(RGBGamma[1], 1, 4)
                     ARGFD6(RGBGamma[2], 1, 4)));

        while (cPalette--) {

            Yr  = (FD6)DivFD6(r = pPaletteEntry->peRed,   255);
            Yg  = (FD6)DivFD6(g = pPaletteEntry->peGreen, 255);
            Yb  = (FD6)DivFD6(b = pPaletteEntry->peBlue,  255);

            pPaletteEntry->peRed   = RGB_8BPP(Yr);
            pPaletteEntry->peGreen = RGB_8BPP(Yg);
            pPaletteEntry->peBlue  = RGB_8BPP(Yb);
            pPaletteEntry->peFlags = 0;

            DBGP_IF(DBGP_GAMMA_PAL,
                    DBGP("%3u - %3u:%3u:%3u --> %3u:%3u:%3u"
                         ARGU(cPalette)
                         ARGU(r) ARGU(g) ARGU(b)
                         ARGU(pPaletteEntry->peRed  )
                         ARGU(pPaletteEntry->peGreen)
                         ARGU(pPaletteEntry->peBlue )));

            ++pPaletteEntry;
        }
    }

    return((LONG)cPal);
}





LONG
APIENTRY
HT_LOADDS
HT_ConvertColorTable(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo,
    PHTCOLORADJUSTMENT  pHTColorAdjustment,
    PCOLORTRIAD         pColorTriad,
    DWORD               Flags
    )


/*++

Routine Description:

    This function modified input color table entries base on the
    pHTColorAdjustment data structure specification.

Arguments:

    pDeviceHalftoneInfo - Pointer to the DEVICEHALFTONEINFO data structure
                          which returned from the HT_CreateDeviceHalftoneInfo.

    pHTColorAdjustment  - Pointer to the HTCOLORADJUSTMENT data structure to
                          specified the input/output color adjustment/transform,
                          if this pointer is NULL then a default color
                          adjustments is applied.

    pColorTriad         - Specified the source color table format and location.

    Flags               - One of the following may be specified

                            CCTF_BW_ONLY

                                Create grayscale of the color table.

                            CCTF_NEGATIVE

                                Create negative version of the original color
                                table.

Return Value:

    if the return value is negative or zero then an error was encountered,
    possible error codes are

        HTERR_INVALID_COLOR_TABLE   - The ColorTableEntries field is = 0 or
                                      CCTInfo.SizePerColorTableEntry is not
                                      between 3 to 255, or if the
                                      CCTInfo.FirstColorIndex in CCTInfo is
                                      not in the range of 0 to
                                      (SizePerColorTableEntry - 3).

        HTERR_INVALID_DHI_POINTER   - Invalid pDevideHalftoneInfo is passed.

    otherwise

        Total entries of the converted color table is returned.


Author:

    14-Aug-1991 Wed 12:43:29 updated  -by-  Daniel Chou (danielc)


Revision History:

    16-Feb-1993 Tue 00:10:56 updated  -by-  Daniel Chou (danielc)
        Fixes bug #10448 which create all black densitities brushes, this
        was caused by not initialized ColorTriad.PrimaryOrder.


--*/

{

    PDEVICECOLORINFO    pDCI;
    PDEVCLRADJ          pDevClrAdj;
    CTSTD_UNION         CTSTDUnion;
    WORD                ForceFlags;
    LONG                Result;

    return(HTERR_COLORTABLE_TOO_BIG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htmapclr.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htmapclr.c


Abstract:

    This module contains low levels functions which map the input color to
    the dyes' densities.


Author:

    29-Jan-1991 Tue 10:28:20 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]

    1. In the near future we will also allowed the XYZ/LAB to be specified in
       the color table


Revision History:


--*/

#define DBGP_VARNAME        dbgpHTMapClr

#include "htp.h"
#include "htmapclr.h"
#include "htrender.h"
#include "htmath.h"
#include "htapi.h"
#include "htpat.h"
#include "htalias.h"


#define DBGP_SHOWXFORM_RGB      0x00000001
#define DBGP_SHOWXFORM_ALL      0x00000002
#define DBGP_CIEMATRIX          0x00000004
#define DBGP_CSXFORM            0x00000008
#define DBGP_CCT                0x00000010
#define DBGP_DYE_CORRECT        0x00000020
#define DBGP_HCA                0x00000040
#define DBGP_PRIMARY_ORDER      0x00000080
#define DBGP_CACHED_GAMMA       0x00000100
#define DBGP_RGBLUTAA           0x00000200
#define DBGP_SCALE_RGB          0x00000400
#define DBGP_MONO_PRIM          0x00000800
#define DBGP_PRIMADJFLAGS       0x00001000
#define DBGP_CELLGAMMA          0x00002000
#define DBGP_CONST_ALPHA        0x00004000
#define DBGP_BGRMAPTABLE        0x00008000


DEF_DBGPVAR(BIT_IF(DBGP_SHOWXFORM_RGB,  0)  |
            BIT_IF(DBGP_SHOWXFORM_ALL,  0)  |
            BIT_IF(DBGP_CIEMATRIX,      0)  |
            BIT_IF(DBGP_CSXFORM,        0)  |
            BIT_IF(DBGP_CCT,            0)  |
            BIT_IF(DBGP_DYE_CORRECT,    0)  |
            BIT_IF(DBGP_HCA,            0)  |
            BIT_IF(DBGP_PRIMARY_ORDER,  0)  |
            BIT_IF(DBGP_CACHED_GAMMA,   0)  |
            BIT_IF(DBGP_RGBLUTAA,       0)  |
            BIT_IF(DBGP_SCALE_RGB,      0)  |
            BIT_IF(DBGP_MONO_PRIM,      0)  |
            BIT_IF(DBGP_PRIMADJFLAGS,   0)  |
            BIT_IF(DBGP_CELLGAMMA,      0)  |
            BIT_IF(DBGP_CONST_ALPHA,    0)  |
            BIT_IF(DBGP_BGRMAPTABLE,    0))


extern  HTCOLORADJUSTMENT   DefaultCA;
extern  CONST LPBYTE        p8BPPXlate[];
extern  HTGLOBAL            HTGlobal;


#define FD6_p25             (FD6_5 / 2)
#define FD6_p75             (FD6_p25 * 3)
#define JND_ADJ(j,x)        RaisePower((j), (FD6)(x), RPF_INTEXP)

#define FD6_p1125           (FD6)112500
#define FD6_p225            (FD6)225000
#define FD6_p325            (FD6)325000
#define FD6_p55             (FD6)550000
#define FD6_p775            (FD6)775000



const FD6     SinNumber[] = {

                 0,  17452,  34899,  52336,  69756,   // 0
             87156, 104528, 121869, 139173, 156434,   // 5.0
            173648, 190809, 207912, 224951, 241922,   // 10
            258819, 275637, 292372, 309017, 325568,   // 15.0
            342020, 358368, 374607, 390731, 406737,   // 20
            422618, 438371, 453990, 469472, 484810,   // 25.0
            500000, 515038, 529919, 544639, 559193,   // 30
            573576, 587785, 601815, 615661, 629320,   // 35.0
            642788, 656059, 669131, 681998, 694658,   // 40
            707107, 719340, 731354, 743145, 754710,   // 45.0
            766044, 777146, 788011, 798636, 809017,   // 50
            819152, 829038, 838671, 848048, 857167,   // 55.0
            866025, 874620, 882948, 891007, 898794,   // 60
            906308, 913545, 920505, 927184, 933580,   // 65.0
            939693, 945519, 951057, 956305, 961262,   // 70
            965926, 970296, 974370, 978148, 981627,   // 75.0
            984808, 987688, 990268, 992546, 994522,   // 80
            996195, 997564, 998630, 999391, 999848,   // 85.0
            1000000
        };


#define CLAMP_0(x)              if ((x) < FD6_0) { (x) = FD6_0; }
#define CLAMP_1(x)              if ((x) > FD6_1) { (x) = FD6_1; }
#define CLAMP_01(x)             CLAMP_0(x) else CLAMP_1(x)
#define CLAMP_PRIMS_0(a,b,c)    CLAMP_0(a); CLAMP_0(b); CLAMP_0(c)
#define CLAMP_PRIMS_1(a,b,c)    CLAMP_1(a); CLAMP_1(b); CLAMP_1(c)
#define CLAMP_PRIMS_01(a,b,c)   CLAMP_01(a); CLAMP_01(b); CLAMP_01(c)


FD6 LogFilterMax = 0;

#if 0
#define LOG_FILTER_RATIO            4
#else
#define LOG_FILTER_RATIO            7
#endif

#define LOG_FILTER_POWER            (FD6)1200000
#define PRIM_LOG_RATIO(p)           Log(FD6xL((p), LOG_FILTER_RATIO) + FD6_1)

#define PRIM_CONTRAST(p,adj)        (p)=MulFD6((p), (adj).Contrast)
#define PRIM_BRIGHTNESS(p,adj)      (p)+=((adj).Brightness)
#define PRIM_COLORFULNESS(a,b,adj)  (a)=MulFD6((a),(adj).Color);            \
                                    (b)=MulFD6((b),(adj).Color)
#define PRIM_TINT(a,b,t,adj)        (t)=(a);                                \
                                    (a)=MulFD6((a),(adj).TintCosAngle) -    \
                                        MulFD6((b),(adj).TintSinAngle);     \
                                    (b)=MulFD6((t),(adj).TintSinAngle) +    \
                                        MulFD6((b),(adj).TintCosAngle)
#if 0
#define PRIM_LOG_FILTER(p)                                                  \
(p)=FD6_1-Power(FD6_1-DivFD6(PRIM_LOG_RATIO(p),LogFilterMax),LOG_FILTER_POWER)
#else
#define PRIM_LOG_FILTER(p)          (p)=DivFD6(PRIM_LOG_RATIO(p),LogFilterMax)
#endif

#define PRIM_BW_ADJ(p,adj)                                                  \
{                                                                           \
    if ((p) <= (adj).MinL) {                                                \
                                                                            \
        (p) = MulFD6(p, (adj).MinLMul);                                     \
                                                                            \
    } else if ((p) >= (adj).MaxL) {                                         \
                                                                            \
        (p) = HT_W_REF_BASE + MulFD6((p)-(adj).MaxL, (adj).MaxLMul);        \
                                                                            \
    } else {                                                                \
                                                                            \
        (p) = HT_K_REF_BASE + MulFD6((p)-(adj).MinL, (adj).RangeLMul);      \
    }                                                                       \
}


#define COMP_CA(pca1,pca2)          CompareMemory((LPBYTE)(pca1),           \
                                                  (LPBYTE)(pca2),           \
                                                  sizeof(HTCOLORADJUSTMENT))
#define ADJ_CA(a,min,max)           if (a < min) { a = min; } else  \
                                    if (a > max) { a = max; }

#define GET_CHECKSUM(c, f)      (c)=ComputeChecksum((LPBYTE)&(f),(c),sizeof(f))
#define PRIM_GAMMA_ADJ(p,g)     (p)=Power((p),(g))


#define NO_NEGATIVE_RGB_SCALE       0

#if NO_NEGATIVE_RGB_SCALE
#define SCALE_PRIM_RGB(pPrim,py)    ScaleRGB((pPrim))
#else
#define SCALE_PRIM_RGB(pPrim,py)    ScaleRGB((pPrim), (py))
#endif


#define SET_CACHED_CMI_CA(ca)                                           \
{                                                                       \
    (ca).caFlags         &= ~(CLRADJF_LOG_FILTER |                      \
                              CLRADJF_NEGATIVE);                        \
    (ca).caRedGamma       =                                             \
    (ca).caGreenGamma     =                                             \
    (ca).caBlueGamma      = 0;                                          \
    (ca).caReferenceBlack = 0x1234;                                     \
    (ca).caReferenceWhite = 0x5678;                                     \
    (ca).caContrast       = (SHORT)0xABCD;                              \
    (ca).caBrightness     = (SHORT)0xFFFF;                              \
}


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// The following macros used in Color space transform functions, these macros
// are used to compute CIELAB X/Xw, Y/Yw, Z/Zw when its values is less
// than 0.008856
//
//               1/3
//  fX = (X/RefXw)   - (16/116)     (X/RefXw) >  0.008856
//  fX = 7.787 x (X/RefXw)          (X/RefXw) <= 0.008856
//
//               1/3
//  fY = (Y/RefYw)   - (16/116)     (Y/RefYw) >  0.008856
//  fY = 7.787 x (Y/RefYw)          (Y/RefYw) <= 0.008856
//
//               1/3
//  fZ = (Z/RefZw)   - (16/116)     (Z/RefZw) >  0.008856
//  fZ = 7.787 x (Z/RefZw)          (Z/RefZw) <= 0.008856
//
//
//                       1/3
//  Thresholds at 0.008856   - (16/116) = 0.068962
//                7.787 x 0.008856      = 0.068962
//
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


#define NORM_XYZ(xyz, w)    (FD6)(((w)==FD6_1) ? (xyz) : DivFD6((xyz), (w)))

#define fXYZFromXYZ(f,n,w)  (f) = ((((f)=NORM_XYZ((n),(w))) >= FD6_p008856) ? \
                                    (CubeRoot((f))) :                         \
                                    (MulFD6((f), FD6_7p787) + FD6_16Div116))

#define XYZFromfXYZ(n,f,w)  (n)=((f)>(FD6)206893) ?                          \
                                (Cube((f))) :                                \
                                (DivFD6((f) - FD6_16Div116, FD6_7p787));                   \
                            if ((w)!=FD6_1) { (n)=MulFD6((n),(w)); }


//
// Following #defines are used in  ComputeColorSpaceXForm, XFormRGB_XYZ_UCS()
// and XFormUCS_XYZ_RGB() functions for easy referenced.
//

#define CSX_AUw(XForm)      XForm.AUw
#define CSX_BVw(XForm)      XForm.BVw
#define CSX_RefXw(XForm)    XForm.WhiteXYZ.X
#define CSX_RefYw(XForm)    FD6_1
#define CSX_RefZw(XForm)    XForm.WhiteXYZ.Z

#define iAw                 CSX_AUw(pDevClrAdj->PrimAdj.rgbCSXForm)
#define iBw                 CSX_BVw(pDevClrAdj->PrimAdj.rgbCSXForm)
#define iUw                 CSX_AUw(pDevClrAdj->PrimAdj.rgbCSXForm)
#define iVw                 CSX_BVw(pDevClrAdj->PrimAdj.rgbCSXForm)
#define iRefXw              CSX_RefXw(pDevClrAdj->PrimAdj.rgbCSXForm)
#define iRefYw              CSX_RefYw(pDevClrAdj->PrimAdj.rgbCSXForm)
#define iRefZw              CSX_RefZw(pDevClrAdj->PrimAdj.rgbCSXForm)

#define oAw                 CSX_AUw(pDevClrAdj->PrimAdj.DevCSXForm)
#define oBw                 CSX_BVw(pDevClrAdj->PrimAdj.DevCSXForm)
#define oUw                 CSX_AUw(pDevClrAdj->PrimAdj.DevCSXForm)
#define oVw                 CSX_BVw(pDevClrAdj->PrimAdj.DevCSXForm)
#define oRefXw              CSX_RefXw(pDevClrAdj->PrimAdj.DevCSXForm)
#define oRefYw              CSX_RefYw(pDevClrAdj->PrimAdj.DevCSXForm)
#define oRefZw              CSX_RefZw(pDevClrAdj->PrimAdj.DevCSXForm)



CONST CIExy2 StdIlluminant[ILLUMINANT_MAX_INDEX] = {

        { (UDECI4)4476, (UDECI4)4074 },     //  A   Tungsten
        { (UDECI4)3489, (UDECI4)3520 },     //  B   Noon Sun
        { (UDECI4)3101, (UDECI4)3162 },     //  C   NTSC
        { (UDECI4)3457, (UDECI4)3585 },     // D50  Plain Paper
        { (UDECI4)3324, (UDECI4)3474 },     // D55  White Bond Paper
        { (UDECI4)3127, (UDECI4)3290 },     // D65  Standard Sun
        { (UDECI4)2990, (UDECI4)3149 },     // D75  Northern Sun
        { (UDECI4)3721, (UDECI4)3751 }      //  F2  Cool White
    };

CONST REGDATA RegData[] = {

    { 9,251,35000,950000,100840336,68627450,31372549,100745314,40309045 },
    { 8,249,45000,930000, 69716775,66386554,33613445,101097041,42542759 },
    { 7,247,55000,910000, 49910873,65141612,34858387,101555706,44600305 },
    { 6,245,65000,890000, 36199095,64349376,35650623,102121877,46557500 },
    { 5,243,75000,870000, 26143790,63800904,36199095,102799050,48461978 },
    { 4,241,85000,850000, 18454440,63398692,36601307,103595587,50361904 },
    { 3,239,95000,830000, 12383900,63091118,36908881,104537807,52367907 }
};

//
//
// REG_L_MIN    = 0.075
// REG_L_MAX    = 0.8500
// REG_D255MIN  = 7
// REG_D255MAX  = 248 (255 - 7)
//
//                  iP        7
// REG_DMIN_MUL = ------- * -----
//                 0.075     255
//
//              = iP * 0.366013
//              = (iP * 36.601307) / 100
//
//
//                 248       iP - 0.8500      7
// REG_DMAX_MUL = ----- + ( ------------- * ----- )
//                 255          0.1500       255
//
//              = 0.972549 + (0.183007 * iP) - 0.155556
//              = 0.816993 + (0.183007 * iP)
//                ~~~~~~~~    ~~~~~~~~
//              = (81.699346  + (18.300654 * iP)) / 100;
//
//
//
//                 7        X - RegLogSub       241
// REG_DEN_MUL = ----- + ((--------------- ) * ----- )
//                255       RegLogRange         255
//
//                 7        X - RegLogSub       241
//             = ----- + ((--------------- ) * ----- )
//                255       RegLogRange         255
//
//                 7        X - -2.080771       241
//             = ----- + ((--------------- ) * ----- )
//                255          1.900361         255
//
//                 7        X + 2.080771       241
//             = ----- + ((-------------- ) * ----- )
//                255          1.900361        255
//
//                 7        X + 2.080771       241
//             = ----- + ((-------------- ) * ----- )
//                255          1.900361        255
//
//             = 0.027451 + (( X + 2.080771) * 0.49736)
//             = 0.027451 + ( 0.49736X + 1.034820)
//             = 0.027451 + 0.49736X + 1.034820
//             = 0.497326X + 1.062271
//             = (49.732555 X + 106.227145) / 100
//
//
//  X           = Log(CIE_L2I(iP)),
//  RegLogMin   = Log(CIE_L2I(REG_L_MIN)) = Log(CIE_L2I(0.075)) = -2.080771
//  RegLogMax   = Log(CIE_L2I(REG_L_MAX)) = Log(CIE_L2I(0.85))  = -0.180410
//  RegLogSub   = -2.080771
//  RegLogRange = -0.180410 - -2.080771 = 1.900361
//

//
// Standard Illuminant Coordinates and its tristimulus values
//
// Illuminant      x          y          X         Y         Z
//------------ ---------- ---------- --------- --------- ---------
//    EQU       0.333333   0.333333   100.000   100.000   100.000
//     A        0.447573   0.407440   109.850   100.000    35.585
//     B        0.348904   0.352001    99.120   100.000    84.970
//     C        0.310061   0.316150    98.074   100.000   118.232
//    D50       0.345669   0.358496    96.422   100.000    82.521
//    D55       0.332424   0.347426    95.682   100.000    92.149
//    D65       0.312727   0.329023    95.047   100.000   108.883
//    D75       0.299021   0.314852    94.972   100.000   122.638
//     F2       0.372069   0.375119    99.187   100.000    67.395
//     F7       0.312852   0.329165    95.044   100.000   108.755
//    F11       0.380521   0.376881   100.966   100.000    64.370
//-----------------------------------------------------------------
//

//
// This is the Source RGB order in Halftone's order, ORDER_ABC, where A is
// lowest memory location and C is the highest memory location
//

const RGBORDER   SrcOrderTable[PRIMARY_ORDER_MAX + 1] = {

                { PRIMARY_ORDER_RGB, { 0, 1, 2 } },
                { PRIMARY_ORDER_RBG, { 0, 2, 1 } },
                { PRIMARY_ORDER_GRB, { 1, 0, 2 } },
                { PRIMARY_ORDER_GBR, { 2, 0, 1 } },
                { PRIMARY_ORDER_BGR, { 2, 1, 0 } },
                { PRIMARY_ORDER_BRG, { 1, 2, 0 } }
            };

//
// This is the destination RGB order in Halftone's order, ORDER_ABC, where C is
// lowest memory location and A is the highest memory location
//

const RGBORDER   DstOrderTable[PRIMARY_ORDER_MAX + 1] = {

                { PRIMARY_ORDER_RGB, { 2, 1, 0 } },
                { PRIMARY_ORDER_RBG, { 2, 0, 1 } },
                { PRIMARY_ORDER_GRB, { 1, 2, 0 } },
                { PRIMARY_ORDER_GBR, { 0, 2, 1 } },
                { PRIMARY_ORDER_BGR, { 0, 1, 2 } },
                { PRIMARY_ORDER_BRG, { 1, 0, 2 } }
            };


#define SRC_BF_HT_RGB       0
#define SRC_TABLE_BYTE      1
#define SRC_TABLE_WORD      2
#define SRC_TABLE_DWORD     3


#if DBG


const LPBYTE  pCBFLUTName[] = { "CBFLI_16_MONO",
                                "CBFLI_24_MONO",
                                "CBFLI_32_MONO",
                                "CBFLI_16_COLOR",
                                "CBFLI_24_COLOR",
                                "CBFLI_32_COLOR" };

const LPBYTE  pSrcPrimTypeName[] = { "SRC_BF_HT_RGB",
                                     "SRC_TABLE_BYTE",
                                     "SRC_TABLE_WORD",
                                     "SRC_TABLE_DWORD" };

const LPBYTE  pDbgCSName[]  = { "LUV", "LAB" };
const LPBYTE  pDbgCMIName[] = { "TABLE:MONO",  "TABLE:COLOR",
                                "HT555:MONO",  "HT555:COLOR" };
#endif

DWORD   dwABPreMul[256] = { 0xFFFFFFFF };


VOID
GenCMYMaskXlate(
    LPBYTE      pbXlate,
    BOOL        CMYInverted,
    LONG        cC,
    LONG        cM,
    LONG        cY
    )

/*++

Routine Description:

    This function generate xlate table for 332 format which CMYMask Mode 3-255


Arguments:




Return Value:




Author:

    08-Sep-2000 Fri 17:57:02 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LONG    iC;
    LONG    iM;
    LONG    iY;
    LONG    IdxDup;
    LONG    Clr;
    LONG    MaxC;
    LONG    MaxM;
    LONG    MaxIdx;
    LONG    IdxC;
    LONG    IdxM;
    LONG    IdxY;


    MaxC   = (cM + 1) * (cY + 1);
    MaxM   = (cY + 1);
    MaxIdx = (cC + 1) * (cM + 1) * (cY + 1);

    if ((MaxIdx >= 1) && (MaxIdx <= 256) && (CMYInverted)) {

        if (MaxIdx & 0x01) {

            IdxDup = MaxIdx / 2;
            ++MaxIdx;

        } else {

            IdxDup = 0x200;
        }

        MaxIdx += ((256 - MaxIdx) / 2) - 1;

        for (iC = 0, IdxC = -MaxC; iC <= 7; iC++) {

            if (iC <= cC) {

                IdxC += MaxC;
            }

            for (iM = 0, IdxM = -MaxM; iM <= 7; iM++) {

                if (iM <= cM) {

                    IdxM += MaxM;
                }

                for (iY = 0, IdxY = -1; iY <= 3; iY++) {

                    if (iY <= cY) {

                        ++IdxY;
                    }

                    if ((Clr = IdxC + IdxM + IdxY) > IdxDup) {

                        ++Clr;
                    }

                    *pbXlate++ = (BYTE)(MaxIdx - Clr);
                }
            }
        }

    } else {

        for (iC = 0; iC < 256; iC++) {

            *pbXlate++ = (BYTE)iC;
        }
    }
}



VOID
HTENTRY
TintAngle(
    LONG    TintAdjust,
    LONG    AngleStep,
    PFD6    pSin,
    PFD6    pCos
    )

/*++

Routine Description:

    This function return a sin/cos number for the tint adjust, these returned
    numbers are used to rotate the color space.

Arguments:

    TintAdjust  - Range from -100 to 100

    AngleStep   - Range from 1 to 10

    pSin        - Pointer to a FD6 number to store the SIN result

    pCos        - Pointer to a FD6 number to store the COS result

Return Value:

    no return value, but the result is stored in pSin/pCos

Author:

    13-Mar-1992 Fri 15:58:30 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LONG    Major;
    LONG    Minor;
    BOOL    PosSin;
    BOOL    PosCos = TRUE;
    FD6     Sin;
    FD6     Cos;


    if (PosSin = (BOOL)(TintAdjust <= 0)) {

        if (!(TintAdjust = (LONG)-TintAdjust)) {

            *pSin = *pCos = (FD6)0;
            return;
        }
    }

    if (TintAdjust > 100) {

        TintAdjust = 100;
    }

    if ((AngleStep < 1) || (AngleStep > 10)) {

        AngleStep = 10;
    }

    if ((TintAdjust *= AngleStep) >= 900) {

        TintAdjust = 1800L - TintAdjust;
        PosCos     = FALSE;
    }

    //
    // Compute the Sin portion
    //

    Major = TintAdjust / 10L;
    Minor = TintAdjust % 10L;

    Sin = SinNumber[Major];

    if (Minor) {

        Sin += (FD6)((((LONG)(SinNumber[Major+1] - Sin) * Minor) + 5L) / 10L);
    }

    *pSin = (PosSin) ? Sin : -Sin;

    //
    // Compute the cosine portion
    //

    if (Minor) {

        Minor = 10 - Minor;
        ++Major;
    }

    Major = 90 - Major;

    Cos = SinNumber[Major];

    if (Minor) {

        Cos += (FD6)((((LONG)(SinNumber[Major+1] - Cos) * Minor) + 5L) / 10L);
    }

    *pCos = (PosCos) ? Cos : -Cos;
}




#define DO_DEST_GAMMA   1
#define DO_SS_GAMMA     0



BOOL
HTENTRY
AdjustSrcDevGamma(
    PDEVICECOLORINFO    pDCI,
    PPRIMADJ            pPrimAdj,
    PHTCOLORADJUSTMENT  pca,
    BYTE                DestSurfFormat,
    WORD                AdjForceFlags
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    29-Jan-1997 Wed 12:34:13 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    FD6         SrcGamma[3];
    FD6         DevGamma[3];
    FD6         PelGamma;
    DWORD       Flags;
    BOOL        Changed;



    Changed          = FALSE;
    Flags            = 0;
    SrcGamma[0]      = DivFD6((FD6)pca->caRedGamma,    (FD6)HT_DEF_RGB_GAMMA);
    SrcGamma[1]      = DivFD6((FD6)pca->caGreenGamma,  (FD6)HT_DEF_RGB_GAMMA);
    SrcGamma[2]      = DivFD6((FD6)pca->caBlueGamma,   (FD6)HT_DEF_RGB_GAMMA);
    PelGamma         = FD6_1;
    pPrimAdj->Flags &= ~DCA_DO_DEVCLR_XFORM;


    if (AdjForceFlags & ADJ_FORCE_ICM) {

        Flags       |= DCA_HAS_ICM;
        DevGamma[0]  =
        DevGamma[1]  =
        DevGamma[2]  = FD6_1;

        //
        // ??? LATER - We may have to turn off ALL gamma correction here
        //

        DBGP_IF(DBGP_CELLGAMMA, DBGP("--- DCA_HAS_ICM ---"));

    } else {

        FD6 GammaMul = FD6_1;


        if (pDCI->Flags & DCIF_ADDITIVE_PRIMS) {

            //
            // Screen Devices
            //

            switch (DestSurfFormat) {

            case BMF_1BPP:
            case BMF_4BPP:
            case BMF_4BPP_VGA16:

                //
                // Since we only have two levels (on/off) we will simulate the
                // 16bpp's darker output
                //

                DevGamma[0]            =
                DevGamma[1]            =
                DevGamma[2]            = 1325000;
                pca->caReferenceBlack += 550;
                pca->caReferenceWhite -= 300;

                break;

            case BMF_8BPP_VGA256:

                DevGamma[0] =
                DevGamma[1] =
                DevGamma[2] = (FD6)1025000;
                break;

            case BMF_16BPP_555:
            case BMF_16BPP_565:
            case BMF_24BPP:
            case BMF_32BPP:

                DevGamma[0] =
                DevGamma[1] =
                DevGamma[2] = (FD6)1000000;
                break;

                break;

            default:

                return(FALSE);
            }

        } else {

            FD6 CellSubGamma = GET_REG_GAMMA(pDCI->ClrXFormBlock.RegDataIdx);

#if DO_DEST_GAMMA
            CopyMemory(DevGamma, pDCI->ClrXFormBlock.DevGamma, sizeof(DevGamma));
#else
            SrcGamma[0] = MulFD6(SrcGamma[0], pDCI->ClrXFormBlock.DevGamma[0]);
            SrcGamma[1] = MulFD6(SrcGamma[1], pDCI->ClrXFormBlock.DevGamma[1]);
            SrcGamma[2] = MulFD6(SrcGamma[2], pDCI->ClrXFormBlock.DevGamma[2]);
            DevGamma[0] =
            DevGamma[1] =
            DevGamma[2] = FD6_1;
#endif
            //
            // Printer Devices
            //

            pPrimAdj->Flags |= DCA_DO_DEVCLR_XFORM;

            if (pDCI->HTCell.HTPatIdx <= HTPAT_SIZE_16x16_M) {

                GammaMul = FD6_1 +
                           FD6xL(((pDCI->HTCell.HTPatIdx >> 1) + 1), 25000);

                if (DestSurfFormat == BMF_1BPP) {

                    DBGP_IF(DBGP_CELLGAMMA,
                            DBGP("1BPP: HTPatIdx=%ld, GammaMul=%s --> %s"
                                ARGDW(pDCI->HTCell.HTPatIdx)
                                ARGFD6(GammaMul, 1, 6)
                                ARGFD6(MulFD6(GammaMul, 1125000), 1, 6)));

                    GammaMul = MulFD6(GammaMul, 1125000);
                }
            }

            if (pDCI->DevPelRatio > FD6_1) {

                PelGamma = DivFD6(-477121,
                                  Log(DivFD6(333333, pDCI->DevPelRatio)));

            } else if (pDCI->DevPelRatio < FD6_1) {

                PelGamma = DivFD6(Log(pDCI->DevPelRatio / 3), -477121);
            }

            switch (DestSurfFormat) {

            case BMF_1BPP:
            case BMF_4BPP:
            case BMF_4BPP_VGA16:

                break;

            case BMF_8BPP_VGA256:

                if ((pDCI->Flags & (DCIF_USE_8BPP_BITMASK |
                                    DCIF_MONO_8BPP_BITMASK)) ==
                                    DCIF_USE_8BPP_BITMASK) {

                    DBGP_IF(DBGP_CELLGAMMA,
                            DBGP("Mask 8BPP, Reset PelGamma=FD6_1, CellSubGamma=%s --> %s"
                                ARGFD6(CellSubGamma, 1, 6)
                                ARGFD6(DivFD6(CellSubGamma, MASK8BPP_GAMMA_DIV), 1, 6)));

                    CellSubGamma = DivFD6(CellSubGamma, MASK8BPP_GAMMA_DIV);
                    PelGamma     = FD6_1;
                }

                break;

            case BMF_16BPP_555:
            case BMF_16BPP_565:
            case BMF_24BPP:
            case BMF_32BPP:

                if (!(pDCI->Flags & DCIF_DO_DEVCLR_XFORM)) {

                   pPrimAdj->Flags &= ~DCA_DO_DEVCLR_XFORM;
                   CellSubGamma     = FD6_1;

                   break;
                }

                break;

            default:

                return(FALSE);
            }

            DBGP_IF(DBGP_CELLGAMMA,
                    DBGP("Res=%ldx%ld, , PelRatio=%s, PelGamma=%s"
                        ARGDW(pDCI->DeviceResXDPI) ARGDW(pDCI->DeviceResYDPI)
                        ARGFD6(pDCI->DevPelRatio, 1, 6) ARGFD6(PelGamma, 1, 6)));

            DBGP_IF(DBGP_CELLGAMMA,
                    DBGP("HTPatIdx=%ld, CellSubGamma=%s, SUB GammaMul=%s"
                        ARGDW(pDCI->HTCell.HTPatIdx)
                        ARGFD6(CellSubGamma, 1, 6)
                        ARGFD6(GammaMul, 1, 6)));

            GammaMul = MulFD6(GammaMul, CellSubGamma);

#if DO_SS_GAMMA
            if (pDCI->Flags & (DCIF_SUPERCELL | DCIF_SUPERCELL_M)) {

                DBGP_IF(DBGP_CELLGAMMA,
                        DBGP("SM: Gamma: %s:%s:%s --> %s:%s:%s"
                            ARGFD6(SrcGamma[0], 1, 6)
                            ARGFD6(SrcGamma[1], 1, 6)
                            ARGFD6(SrcGamma[2], 1, 6)
                            ARGFD6(MulFD6(SrcGamma[0], SCM_R_GAMMA_MUL), 1, 6)
                            ARGFD6(MulFD6(SrcGamma[1], SCM_G_GAMMA_MUL), 1, 6)
                            ARGFD6(MulFD6(SrcGamma[2], SCM_B_GAMMA_MUL), 1, 6)));

                SrcGamma[0] = MulFD6(SrcGamma[0], SCM_R_GAMMA_MUL);
                SrcGamma[1] = MulFD6(SrcGamma[1], SCM_G_GAMMA_MUL);
                SrcGamma[2] = MulFD6(SrcGamma[2], SCM_B_GAMMA_MUL);
            }
#endif
        }

        SrcGamma[0] = MulFD6(SrcGamma[0], GammaMul);
        SrcGamma[1] = MulFD6(SrcGamma[1], GammaMul);
        SrcGamma[2] = MulFD6(SrcGamma[2], GammaMul);

        DBGP_IF(DBGP_CELLGAMMA,
                DBGP("Gamma: Src=%s:%s:%s, Dev=%s:%s:%s, Pel=%s, Mul=%s"
                    ARGFD6(SrcGamma[0], 1, 6)
                    ARGFD6(SrcGamma[1], 1, 6)
                    ARGFD6(SrcGamma[2], 1, 6)
                    ARGFD6(DevGamma[0], 1, 6)
                    ARGFD6(DevGamma[1], 1, 6)
                    ARGFD6(DevGamma[2], 1, 6)
                    ARGFD6(PelGamma,   1, 6)
                    ARGFD6(GammaMul,   1, 6)));

        DBGP_IF(DBGP_CELLGAMMA,
                DBGP("Source Gamma=%s:%s:%s, PelGamma=%s"
                    ARGFD6(SrcGamma[0], 1, 6) ARGFD6(SrcGamma[1], 1, 6)
                    ARGFD6(SrcGamma[2], 1, 6) ARGFD6(PelGamma, 1, 6)));

        if (PelGamma != FD6_1) {

            DevGamma[0] = MulFD6(DevGamma[0], PelGamma);
            DevGamma[1] = MulFD6(DevGamma[1], PelGamma);
            DevGamma[2] = MulFD6(DevGamma[2], PelGamma);

            DBGP_IF(DBGP_CELLGAMMA,
                    DBGP("DevGamma=%s:%s:%s, PelGamma=%s"
                        ARGFD6(DevGamma[0], 1, 6) ARGFD6(DevGamma[1], 1, 6)
                        ARGFD6(DevGamma[2], 1, 6) ARGFD6(PelGamma, 1, 6)));
        }
    }

    if ((SrcGamma[0] != FD6_1) ||
        (SrcGamma[1] != FD6_1) ||
        (SrcGamma[2] != FD6_1)) {

        Flags |= DCA_HAS_SRC_GAMMA;

        DBGP_IF(DBGP_CELLGAMMA,
                DBGP("--- DCA_HAS_SRC_GAMMA --- %s:%s:%s [%s]"
                    ARGFD6(SrcGamma[0], 1, 6)
                    ARGFD6(SrcGamma[1], 1, 6)
                    ARGFD6(SrcGamma[2], 1, 6)
                    ARGFD6(MulFD6(SrcGamma[0], (FD6)2200000), 1, 6)));
    }

    if ((SrcGamma[0] != pPrimAdj->SrcGamma[0])    ||
        (SrcGamma[1] != pPrimAdj->SrcGamma[1])    ||
        (SrcGamma[2] != pPrimAdj->SrcGamma[2])) {

        CopyMemory(pPrimAdj->SrcGamma, SrcGamma, sizeof(SrcGamma));
        Changed = TRUE;
    }

    if ((DevGamma[0] != FD6_1) ||
        (DevGamma[1] != FD6_1) ||
        (DevGamma[2] != FD6_1)) {

        Flags |= DCA_HAS_DEST_GAMMA;

        DBGP_IF(DBGP_CELLGAMMA,
                DBGP("--- DCA_HAS_DEST_GAMMA --- %s:%s:%s"
                    ARGFD6(DevGamma[0], 1, 6)
                    ARGFD6(DevGamma[1], 1, 6)
                    ARGFD6(DevGamma[2], 1, 6)));
    }

    if ((DevGamma[0] != pPrimAdj->DevGamma[0])    ||
        (DevGamma[1] != pPrimAdj->DevGamma[1])    ||
        (DevGamma[2] != pPrimAdj->DevGamma[2])) {

        CopyMemory(pPrimAdj->DevGamma, DevGamma, sizeof(DevGamma));

        Changed = TRUE;
    }

    if ((pPrimAdj->Flags & (DCA_HAS_ICM         |
                            DCA_HAS_SRC_GAMMA   |
                            DCA_HAS_DEST_GAMMA)) != Flags) {

        Changed = TRUE;
    }

    if (Changed) {

        pPrimAdj->Flags = (pPrimAdj->Flags & ~(DCA_HAS_ICM          |
                                               DCA_HAS_SRC_GAMMA    |
                                               DCA_HAS_DEST_GAMMA)) | Flags;
    }

    return(Changed);
}



PDEVICECOLORINFO
HTENTRY
pDCIAdjClr(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo,
    PHTCOLORADJUSTMENT  pHTColorAdjustment,
    PDEVCLRADJ          *ppDevClrAdj,
    DWORD               cbAlloc,
    WORD                ForceFlags,
    CTSTDINFO           CTSTDInfo,
    PLONG               pError
    )

/*++

Routine Description:

    This function allowed the caller to changed the overall color adjustment
    for all the pictures rendered

Arguments:

    pDeviceHalftoneInfo - Pointer to the DEVICEHALFTONEINFO data structure
                          which returned from the HT_CreateDeviceHalftoneInfo.

    pHTColorAdjustment  - Pointer to the HTCOLORADJUSTMENT data structure, if
                          this pointer is NULL then a default is applied.

    ppDevClrAdj         - Pointer to pointer to the DEVCLRADJ data structure
                          where the computed results will be stored, if this
                          pointer isNULL then no color adjustment is done.

                          if pSrcSI and ppDevClrAdj are not NULL then
                          *ppDevClrAdj->Flags must contains the BBPFlags;

    ForceFlags          - Force flags to make color changed.

Return Value:

    PDEVICECOLORINFO, if return is NULL then a invalid pDeviceHalftoneInfo
    pointer is passed.

Author:

    29-May-1991 Wed 09:11:31 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    PDEVICECOLORINFO    pDCI;


    if ((!pDeviceHalftoneInfo) ||
        (PHT_DHI_DCI_OF(HalftoneDLLID) != HALFTONE_DLL_ID)) {

        *pError = HTERR_INVALID_DHI_POINTER;

        return(NULL);
    }

    pDCI = PDHI_TO_PDCI(pDeviceHalftoneInfo);

    //
    // Lock For this DCI
    //

    ACQUIRE_HTMUTEX(pDCI->HTMutex);

    //
    // Only if caller required color adjustments computations, then we will
    // compute for it.
    //

    if (ppDevClrAdj) {

        PDEVCLRADJ          pDevClrAdj;
        PCIEPRIMS           pDevPrims;
        PRGBLUTAA           prgbLUT;
        HTCOLORADJUSTMENT   ca;
        HTCOLORADJUSTMENT   caCached;
        DEVMAPINFO          DMI;
        DWORD               LUTAAHdr[LUTAA_HDR_COUNT];
        PRIMADJ             PrimAdj;
        DWORD               DCIFlags;


        if ((ForceFlags & ADJ_FORCE_AB_PREMUL_SRC) &&
            (dwABPreMul[0])) {

            DWORD   i;

            //
            // Generate a ABPreMul[] so that we can multiply it and get the
            // original pre-mul source value
            //

            dwABPreMul[0] = 0;

            for (i = 1; i < 256; i++) {

                dwABPreMul[i] = (DWORD)((0xFF000000 + (i - 1))  / i);
            }
        }

        if (!(*ppDevClrAdj = pDevClrAdj =
                        (PDEVCLRADJ)HTAllocMem((LPVOID)pDCI,
                                               HTMEM_DevClrAdj,
                                               LPTR,
                                               cbAlloc + sizeof(DEVCLRADJ)))) {

            *pError = HTERR_INSUFFICIENT_MEMORY;

            //================================================================
            // Release SEMAPHORE NOW, since we are failing the memory request
            //================================================================

            RELEASE_HTMUTEX(pDCI->HTMutex);

            return(NULL);
        }

        //
        // Force the ICM on
        //

        if ((DCIFlags = pDCI->Flags) & DCIF_FORCE_ICM) {

            ForceFlags |= ADJ_FORCE_ICM;
        }

        //
        // Force gray scale
        //

        DMI.CTSTDInfo = CTSTDInfo;

        if ((DMI.CTSTDInfo.BMFDest == BMF_1BPP)    ||
            ((DMI.CTSTDInfo.BMFDest == BMF_8BPP_VGA256) &&
             ((DCIFlags & (DCIF_USE_8BPP_BITMASK | DCIF_MONO_8BPP_BITMASK)) ==
                          (DCIF_USE_8BPP_BITMASK | DCIF_MONO_8BPP_BITMASK)))) {

            ForceFlags |= (ADJ_FORCE_MONO | ADJ_FORCE_IDXBGR_MONO);
        }

        prgbLUT = (ForceFlags & ADJ_FORCE_BRUSH) ? &pDCI->rgbLUTPat :
                                                   &pDCI->rgbLUT;

        if (ForceFlags & ADJ_FORCE_ICM) {

            //
            // These two does not mix
            //

            ForceFlags &= ~ADJ_FORCE_BRUSH;
        }

        //=====================================================================
        // We must make sure only one thread using this info.
        //=====================================================================

        ca = (pHTColorAdjustment) ? *pHTColorAdjustment :
                                    pDeviceHalftoneInfo->HTColorAdjustment;

        if ((ca.caSize != sizeof(HTCOLORADJUSTMENT)) ||
            (ca.caFlags & ~(CLRADJF_FLAGS_MASK))) {

            ca = DefaultCA;
        }

        caCached = pDCI->ca;
        PrimAdj  = pDCI->PrimAdj;


        //
        // Now validate all color adjustments
        //

        ca.caFlags &= CLRADJF_FLAGS_MASK;

        if (ca.caIlluminantIndex > ILLUMINANT_MAX_INDEX) {

            ca.caIlluminantIndex = DefaultCA.caIlluminantIndex;
        }

        ADJ_CA(ca.caRedGamma,   RGB_GAMMA_MIN, RGB_GAMMA_MAX);
        ADJ_CA(ca.caGreenGamma, RGB_GAMMA_MIN, RGB_GAMMA_MAX);
        ADJ_CA(ca.caBlueGamma,  RGB_GAMMA_MIN, RGB_GAMMA_MAX);
        ADJ_CA(ca.caReferenceBlack, 0,                   REFERENCE_BLACK_MAX);
        ADJ_CA(ca.caReferenceWhite, REFERENCE_WHITE_MIN, 10000);
        ADJ_CA(ca.caContrast,     MIN_COLOR_ADJ, MAX_COLOR_ADJ);
        ADJ_CA(ca.caBrightness,   MIN_COLOR_ADJ, MAX_COLOR_ADJ);
        ADJ_CA(ca.caColorfulness, MIN_COLOR_ADJ, MAX_COLOR_ADJ);
        ADJ_CA(ca.caRedGreenTint, MIN_COLOR_ADJ, MAX_COLOR_ADJ);

        if ((ForceFlags & ADJ_FORCE_MONO)   ||
            (ca.caColorfulness == MIN_COLOR_ADJ)) {

            ca.caColorfulness  = MIN_COLOR_ADJ;
            ca.caRedGreenTint  = 0;
        }

        if (ForceFlags & ADJ_FORCE_NEGATIVE) {

            ca.caFlags |= CLRADJF_NEGATIVE;
        }

        ca.caSize = (WORD)(ForceFlags & (ADJ_FORCE_DEVXFORM     |
                                         ADJ_FORCE_BRUSH        |
                                         ADJ_FORCE_MONO         |
                                         ADJ_FORCE_IDXBGR_MONO  |
                                         ADJ_FORCE_ICM));

        if ((AdjustSrcDevGamma(pDCI,
                               &PrimAdj,
                               &ca,
                               DMI.CTSTDInfo.BMFDest,
                               ForceFlags)) ||
            (!COMP_CA(&ca, &caCached))){

            DBGP_IF(DBGP_HCA,
                    DBGP("---- New Color Adjustments --%08lx---" ARGDW(ca.caSize));
                    DBGP("Flags    = %08x" ARGDW(ca.caFlags));
                    DBGP("Illum    = %d" ARGW(ca.caIlluminantIndex));
                    DBGP("R_Power  = %u" ARGI(ca.caRedGamma));
                    DBGP("G_Power  = %u" ARGI(ca.caGreenGamma));
                    DBGP("B_Power  = %u" ARGI(ca.caBlueGamma));
                    DBGP("BlackRef = %u" ARGW(ca.caReferenceBlack));
                    DBGP("WhiteRef = %u" ARGW(ca.caReferenceWhite));
                    DBGP("Contrast = %d" ARGI(ca.caContrast));
                    DBGP("Bright   = %d" ARGI(ca.caBrightness));
                    DBGP("Colorful = %d" ARGI(ca.caColorfulness));
                    DBGP("RG_Tint  = %d" ARGI(ca.caRedGreenTint));
                    DBGP("ForceAdj = %04lx" ARGDW(ForceFlags)));

            PrimAdj.Flags &= (DCA_HAS_ICM           |
                              DCA_DO_DEVCLR_XFORM   |
                              DCA_HAS_SRC_GAMMA     |
                              DCA_HAS_DEST_GAMMA);

            if (ForceFlags & ADJ_FORCE_IDXBGR_MONO) {

                PrimAdj.Flags |= DCA_MONO_ONLY;

                DBGP_IF(DBGP_HCA, DBGP("---DCA_MONO_ONLY---"));

            }

            if (ca.caFlags & CLRADJF_LOG_FILTER) {

                if (!LogFilterMax) {

                    LogFilterMax = PRIM_LOG_RATIO(FD6_1);
                }

                PrimAdj.Flags |= DCA_LOG_FILTER;

                DBGP_IF(DBGP_HCA, DBGP("---DCA_LOG_FILTER---"));
            }

            if (ca.caFlags & CLRADJF_NEGATIVE) {

                PrimAdj.Flags |= DCA_NEGATIVE;

                DBGP_IF(DBGP_HCA, DBGP("---DCA_NEGATIVE---"));
            }

            pDevPrims = (PrimAdj.Flags & DCA_HAS_ICM) ?
                                &(pDCI->ClrXFormBlock.rgbCIEPrims) :
                                &(pDCI->ClrXFormBlock.DevCIEPrims);

            if ((ca.caSize &       (ADJ_FORCE_ICM | ADJ_FORCE_DEVXFORM)) !=
                (caCached.caSize & (ADJ_FORCE_ICM | ADJ_FORCE_DEVXFORM))) {

                //
                // Re-Compute Device RGB xfrom matrix
                //

                DBGP_IF(DBGP_CCT,
                        DBGP("\n***  ComputeColorSpaceForm(%hs_XFORM) ***\n"
                                ARGPTR((PrimAdj.Flags & DCA_HAS_ICM) ?
                                        "ICM" : "DEVICE")));

                ComputeColorSpaceXForm(pDCI,
                                       pDevPrims,
                                       &(PrimAdj.DevCSXForm),
                                       -1);
            }

            if (ca.caIlluminantIndex != caCached.caIlluminantIndex) {

                DBGP_IF(DBGP_CCT,
                        DBGP("***  ComputeColorSpaceForm(RGB_XFORM Illuminant=%u) ***"
                                ARGU(ca.caIlluminantIndex)));

                ComputeColorSpaceXForm(pDCI,
                                       &(pDCI->ClrXFormBlock.rgbCIEPrims),
                                       &(PrimAdj.rgbCSXForm),
                                       (INT)ca.caIlluminantIndex);
            }

            if ((PrimAdj.Flags & DCA_MONO_ONLY) ||
                (CompareMemory((LPBYTE)pDevPrims,
                               (LPBYTE)&(pDCI->ClrXFormBlock.rgbCIEPrims),
                               sizeof(CIEPRIMS)))) {

                PrimAdj.Flags &= ~DCA_HAS_CLRSPACE_ADJ;

            } else {

                PrimAdj.Flags |= DCA_HAS_CLRSPACE_ADJ;
            }

            PrimAdj.MinL = UDECI4ToFD6(ca.caReferenceBlack) + HT_K_REF_ADD;
            PrimAdj.MaxL = UDECI4ToFD6(ca.caReferenceWhite) - HT_W_REF_SUB;

            if ((PrimAdj.MinL != HT_K_REF_BASE) ||
                (PrimAdj.MaxL != HT_W_REF_BASE)) {

                PrimAdj.Flags     |= DCA_HAS_BW_REF_ADJ;
                PrimAdj.MinLMul    = DivFD6(HT_K_REF_CLIP, PrimAdj.MinL);
                PrimAdj.MaxLMul    = DivFD6(HT_W_REF_CLIP,
                                            FD6_1 - PrimAdj.MaxL);
                PrimAdj.RangeLMul  = DivFD6(HT_KW_REF_RANGE,
                                            PrimAdj.MaxL - PrimAdj.MinL);

                DBGP_IF(DBGP_HCA,
                        DBGP("--- DCA_HAS_BW_REF_ADJ %s to %s, xK=%s, xW=%s, xRange=%s ---"
                            ARGFD6(PrimAdj.MinL, 1, 6)
                            ARGFD6(PrimAdj.MaxL, 1, 6)
                            ARGFD6(PrimAdj.MinLMul, 1, 6)
                            ARGFD6(PrimAdj.MaxLMul, 1, 6)
                            ARGFD6(PrimAdj.RangeLMul, 1, 6)));

            } else {

                PrimAdj.Flags     &= ~DCA_HAS_BW_REF_ADJ;
                PrimAdj.MinL       = FD6_0;
                PrimAdj.MaxL       = FD6_1;
                PrimAdj.MinLMul    =
                PrimAdj.MaxLMul    =
                PrimAdj.RangeLMul  = FD6_0;
            }

            if (ca.caContrast) {

                PrimAdj.Contrast  = JND_ADJ((FD6)1015000, ca.caContrast);
                PrimAdj.Flags    |= DCA_HAS_CONTRAST_ADJ;

                DBGP_IF(DBGP_HCA,
                        DBGP("--- DCA_HAS_CONTRAST_ADJ = %s ---"
                            ARGFD6(PrimAdj.Contrast, 1, 6)));
            }

            if (ca.caBrightness) {

                PrimAdj.Brightness  = FD6xL((FD6)3750, ca.caBrightness);
                PrimAdj.Flags      |= DCA_HAS_BRIGHTNESS_ADJ;

                DBGP_IF(DBGP_HCA,
                        DBGP("--- DCA_HAS_BRIGHTNESS_ADJ = %s ---"
                                ARGFD6(PrimAdj.Brightness, 1, 6)));
            }

            //
            // Colorfulness, RedGreenTint, and DYE_CORRECTIONS only valid and
            // necessary if it a color device output
            //

            if (!(PrimAdj.Flags & DCA_MONO_ONLY)) {

                PrimAdj.Color = (FD6)(ca.caColorfulness + MAX_COLOR_ADJ);

                // if (ca.caSize & ADJ_FORCE_BRUSH) {
                //
                //     PrimAdj.Color += HT_BRUSH_COLORFULNESS;
                // }

                if ((PrimAdj.Color *= 10000) != FD6_1) {

                    PrimAdj.Flags |= DCA_HAS_COLOR_ADJ;

                    DBGP_IF(DBGP_HCA,
                            DBGP("--- DCA_HAS_COLOR_ADJ = %s ---"
                                                ARGFD6(PrimAdj.Color, 1, 6)));
                }

                if (ca.caRedGreenTint) {

                    TintAngle((LONG)ca.caRedGreenTint,
                              (LONG)6,
                              (PFD6)&(PrimAdj.TintSinAngle),
                              (PFD6)&(PrimAdj.TintCosAngle));

                    PrimAdj.Flags |= DCA_HAS_TINT_ADJ;

                    DBGP_IF(DBGP_HCA,
                            DBGP("--- DCA_HAS_TINT_ADJ Sin=%s, Cos=%s ---"
                                    ARGFD6(PrimAdj.TintSinAngle, 1, 6)
                                    ARGFD6(PrimAdj.TintCosAngle, 1, 6)));
                }

                if ((DCIFlags & DCIF_NEED_DYES_CORRECTION)  &&
                    ((PrimAdj.Flags & (DCA_HAS_ICM | DCA_DO_DEVCLR_XFORM)) ==
                                                     DCA_DO_DEVCLR_XFORM)) {

                    PrimAdj.Flags |= DCA_NEED_DYES_CORRECTION;

                    DBGP_IF(DBGP_HCA, DBGP("---DCA_NEED_DYES_CORRECTION---"));

                    if (DCIFlags & DCIF_HAS_BLACK_DYE) {

                        PrimAdj.Flags |= DCA_HAS_BLACK_DYE;

                        DBGP_IF(DBGP_HCA, DBGP("---DCA_HAS_BLACK_DYE---"));
                    }
                }
            }

            DBGP_IF(DBGP_CCT,
                    DBGP("** Save PrimAdj back to pDCI, Flags=%08lx **"
                            ARGDW(PrimAdj.Flags)));

            pDCI->ca      = ca;
            pDCI->PrimAdj = PrimAdj;

        } else {

            DBGP_IF(DBGP_CCT, DBGP("* Use cached HTCOLORADJUSTMENT *"));
        }

        //
        // These flags are always computed per call, so turn it off first
        //

        PrimAdj.Flags &= ~(DCA_NO_ANY_ADJ               |
                           DCA_NO_MAPPING_TABLE         |
                           DCA_MASK8BPP                 |
                           DCA_BBPF_AA_OFF              |
                           DCA_USE_ADDITIVE_PRIMS       |
                           DCA_XLATE_555_666            |
                           DCA_XLATE_332                |
                           DCA_REPLACE_BLACK);

        if (!(PrimAdj.Flags & (DCA_NEED_DYES_CORRECTION |
                               DCA_HAS_CLRSPACE_ADJ     |
                               DCA_HAS_SRC_GAMMA        |
                               DCA_HAS_BW_REF_ADJ       |
                               DCA_HAS_CONTRAST_ADJ     |
                               DCA_HAS_BRIGHTNESS_ADJ   |
                               DCA_HAS_COLOR_ADJ        |
                               DCA_HAS_TINT_ADJ         |
                               DCA_LOG_FILTER           |
                               DCA_NEGATIVE             |
                               DCA_DO_DEVCLR_XFORM      |
                               DCA_HAS_DEST_GAMMA))) {

            PrimAdj.Flags |= DCA_NO_ANY_ADJ;

            DBGP_IF(DBGP_HCA, DBGP("---DCA_NO_ANY_ADJ---"));
        }

        if ((PrimAdj.Flags & DCA_MONO_ONLY) ||
            (!(PrimAdj.Flags & (DCA_NEED_DYES_CORRECTION    |
                                DCA_HAS_CLRSPACE_ADJ        |
                                DCA_HAS_COLOR_ADJ           |
                                DCA_HAS_TINT_ADJ)))) {

            PrimAdj.Flags |= DCA_NO_MAPPING_TABLE;

            DBGP_IF(DBGP_HCA, DBGP("---DCA_NO_MAPPING_TABLE---"));
        }

        if ((DCIFlags & DCIF_PRINT_DRAFT_MODE)    ||
            (ForceFlags & ADJ_FORCE_NO_EXP_AA)) {

            PrimAdj.Flags |= DCA_BBPF_AA_OFF;

            DBGP_IF(DBGP_HCA, DBGP("---DCA_BBPF_AA_OFF---"));
        }

        if (ForceFlags & ADJ_FORCE_ALPHA_BLEND) {

            PrimAdj.Flags |= DCA_ALPHA_BLEND;

            DBGP_IF(DBGP_HCA, DBGP("---DCA_ALPHA_BLEND---"));

            if (ForceFlags & ADJ_FORCE_CONST_ALPHA) {

                PrimAdj.Flags |= DCA_CONST_ALPHA;

                DBGP_IF(DBGP_HCA, DBGP("---DCA_CONST_ALPHA---"));

            } else {

                if (ForceFlags & ADJ_FORCE_AB_PREMUL_SRC) {

                    DBGP_IF(DBGP_HCA, DBGP("---DCA_AB_PREMUL_SRC---"));

                    PrimAdj.Flags |= DCA_AB_PREMUL_SRC;
                }

                if (ForceFlags & ADJ_FORCE_AB_DEST) {

                    DBGP_IF(DBGP_HCA, DBGP("---DCA_AB_DEST---"));

                    PrimAdj.Flags |= DCA_AB_DEST;
                }
            }
        }

        //
        // Since we do substractive prims at output time, we need to re-set
        // this flag evertime the pDCIAdjClr called.
        //

        if (ForceFlags & ADJ_FORCE_ADDITIVE_PRIMS) {

            PrimAdj.Flags |= DCA_USE_ADDITIVE_PRIMS;

            DBGP_IF(DBGP_HCA, DBGP("---DCA_USE_ADDITIVE_PRIMS---"));
        }

        //
        // All following is first set in RGB order wehre B is lowest memory
        // location (0) and R is in highest memory location (2), see
        // DstOrderTable[], so the index 0=B, 1=G. 2=R
        //
        // LUTAAHdr[]:  DWORD Masking for the destination in BGR order
        // Mul[]:       Multiply factor when makeing RGBLUTAA table
        // MulAdd:      Addition amount after Mul
        // LSft:        Left shift amount after Mul/MulAdd
        //

        ZeroMemory(LUTAAHdr, sizeof(LUTAAHdr));

        DMI.BlackChk         = FD6_1;
        DMI.Flags            = 0;
        DMI.LSft[0]          =
        DMI.LSft[1]          =
        DMI.LSft[2]          = 4;
        DMI.CTSTDInfo.cbPrim = sizeof(BGR8);

        if (PrimAdj.Flags & DCA_MONO_ONLY) {

            PrimAdj.Flags |= DCA_RGBLUTAA_MONO;
            DMI.Flags     |= DMIF_GRAY;
            DMI.Mul[0]     =
            DMI.Mul[1]     =
            DMI.Mul[2]     = GRAY_MAX_IDX;
            DMI.MulAdd     = 0;

        } else {

            DMI.MulAdd = 0x1000;
            DMI.Mul[0] =
            DMI.Mul[1] =
            DMI.Mul[2] = DMI.MulAdd - 1;
        }

        switch (DMI.CTSTDInfo.BMFDest) {

        case BMF_1BPP:

            //
            //  PRIMARY_ORDER_RGB (Always)
            //
            //      NOT APPLICABLE
            //

            ASSERT(DMI.Flags & DMIF_GRAY);

            DMI.CTSTDInfo.DestOrder  = PRIMARY_ORDER_RGB;

            break;

        case BMF_4BPP_VGA16:

            //
            //  PRIMARY_ORDER_BGR
            //                |||
            //                ||+-- bit 0/4
            //                ||
            //                |+--- bit 1/5
            //                |
            //                +---- bit 2/7
            //
            //

            PrimAdj.Flags           |= DCA_USE_ADDITIVE_PRIMS;
            DMI.CTSTDInfo.DestOrder  = PRIMARY_ORDER_BGR;

            //
            // Fall through for same as BMF_4BPP
            //

        case BMF_4BPP:

            //
            //  PRIMARY_ORDER_abc
            //                |||
            //                ||+-- bit 0/4
            //                ||
            //                |+--- bit 1/5
            //                |
            //                +---- bit 2/7
            //
            //

            LUTAAHdr[0] = 0x100000;
            LUTAAHdr[1] = 0x200000;
            LUTAAHdr[2] = 0x400000;
            LUTAAHdr[3] = 0x010000;
            LUTAAHdr[4] = 0x020000;
            LUTAAHdr[5] = 0x040000;
            DMI.LSft[0] = 4;
            DMI.LSft[1] = 5;
            DMI.LSft[2] = 6;
            DMI.MulAdd  = 0x0;

            break;

        case BMF_8BPP_VGA256:

            //
            //  8BPP_MASK_CLR (COLOR)
            //
            //      PRIMARY_ORDER_CMY (system standard 3:3:2 CMY format)
            //                    |||
            //                    ||+-- bit 0-1 (Max. 2 bits of yellow)
            //                    ||
            //                    |+--- bit 2-4 (Max. 3 bits of magenta)
            //                    |
            //                    +---- bit 5-7 (Max. 3 bits of cyan)
            //
            //
            //  8BPP_MASK_MONO (MONO)
            //
            //      NOT APPLICABLE
            //
            //
            //
            //  VGA_256 System Halftone Standard (BGR Always)
            //
            //      PRIMARY_ORDER_BGR
            //                    | |
            //                    | +-- Lowest Primary Index
            //                    |
            //                    |
            //                    |
            //                    +---- Highest Primary Index
            //
            //

            if (DCIFlags & DCIF_USE_8BPP_BITMASK) {

                BM8BPPINFO  bm8i;


                PrimAdj.Flags |= DCA_MASK8BPP;
                bm8i.dw        = 0;

                if (pDCI->CMY8BPPMask.GenerateXlate) {

                    GenCMYMaskXlate(pDCI->CMY8BPPMask.bXlate,
                                    (BOOL)(DCIFlags &
                                                DCIF_INVERT_8BPP_BITMASK_IDX),
                                    (LONG)pDCI->CMY8BPPMask.cC,
                                    (LONG)pDCI->CMY8BPPMask.cM,
                                    (LONG)pDCI->CMY8BPPMask.cY);

                    pDCI->CMY8BPPMask.GenerateXlate = 0;
                }

                if (DCIFlags & DCIF_INVERT_8BPP_BITMASK_IDX) {

                    bm8i.Data.pXlateIdx |= XLATE_RGB_IDX_OR;
                    bm8i.Data.bXor       = 0xFF;

                } else {

                    bm8i.Data.bXor = 0;
                }

                bm8i.Data.bBlack = pDCI->CMY8BPPMask.Mask ^ bm8i.Data.bXor;
                bm8i.Data.bWhite = bm8i.Data.bXor;

                if (DCIFlags & DCIF_MONO_8BPP_BITMASK) {

                    ASSERT(DMI.Flags & DMIF_GRAY);

                    LUTAAHdr[0]              =
                    LUTAAHdr[1]              =
                    LUTAAHdr[2]              = 0xFF0000;
                    DMI.CTSTDInfo.DestOrder  = PRIMARY_ORDER_RGB;
                    DMI.CTSTDInfo.BMFDest    = BMF_8BPP_MONO;

                    DBGP_IF(DBGP_HCA, DBGP("---DCA_MASK8BPP_MONO---"));

                } else {

                    LPBYTE  pXlate;
                    DWORD   KIdx;


                    DMI.Mul[0]  = ((DWORD)pDCI->CMY8BPPMask.cY << 12) - 1;
                    DMI.Mul[1]  = ((DWORD)pDCI->CMY8BPPMask.cM << 12) - 1;
                    DMI.Mul[2]  = ((DWORD)pDCI->CMY8BPPMask.cC << 12) - 1;
                    LUTAAHdr[0] = (DWORD)pDCI->CMY8BPPMask.PatSubY;
                    LUTAAHdr[1] = (DWORD)pDCI->CMY8BPPMask.PatSubM;
                    LUTAAHdr[2] = (DWORD)pDCI->CMY8BPPMask.PatSubC;
                    DMI.LSft[0] = 4;
                    DMI.LSft[1] = 7;
                    DMI.LSft[2] = 10;

                    switch (pDCI->CMY8BPPMask.SameLevel) {

                    case 4:
                    case 5:

                        if (pDCI->CMY8BPPMask.SameLevel == 4) {

                            DMI.CTSTDInfo.BMFDest = BMF_8BPP_L555;
                            KIdx                  = SIZE_XLATE_555 - 1;

                        } else {

                            DMI.CTSTDInfo.BMFDest  = BMF_8BPP_L666;
                            bm8i.Data.pXlateIdx   |= XLATE_666_IDX_OR;
                            KIdx                   = SIZE_XLATE_666 - 1;
                        }

                        PrimAdj.Flags       |= DCA_XLATE_555_666;
                        bm8i.Data.pXlateIdx &= XLATE_IDX_MASK;
                        pXlate               = p8BPPXlate[bm8i.Data.pXlateIdx];
                        bm8i.Data.bBlack     = pXlate[KIdx];
                        bm8i.Data.bWhite     = pXlate[0];
                        break;

                    default:

                        DMI.LSft[1]           = 6;
                        DMI.LSft[2]           = 9;
                        DMI.CTSTDInfo.BMFDest = BMF_8BPP_B332;

                        if (DCIFlags & DCIF_INVERT_8BPP_BITMASK_IDX) {

                            PrimAdj.Flags    |= DCA_XLATE_332;
                            bm8i.Data.bBlack  = pDCI->CMY8BPPMask.bXlate[255];
                            bm8i.Data.bWhite  = pDCI->CMY8BPPMask.bXlate[0];
                        }

                        break;
                    }


                    if (pDCI->CMY8BPPMask.KCheck) {

                        PrimAdj.Flags  |= DCA_REPLACE_BLACK;
                        DMI.BlackChk    = pDCI->CMY8BPPMask.KCheck;
                        DMI.LSft[0]    -= 4;
                        DMI.LSft[1]    -= 4;
                        DMI.LSft[2]    -= 4;

                        switch (DMI.CTSTDInfo.BMFDest) {

                        case BMF_8BPP_B332:

                            DMI.CTSTDInfo.BMFDest = BMF_8BPP_K_B332;
                            break;

                        case BMF_8BPP_L555:

                            DMI.CTSTDInfo.BMFDest = BMF_8BPP_K_L555;
                            break;

                        case BMF_8BPP_L666:

                            DMI.CTSTDInfo.BMFDest = BMF_8BPP_K_L666;
                            break;
                        }
                    }

                    DMI.CTSTDInfo.DestOrder = PRIMARY_ORDER_CMY;

                    DBGP_IF(DBGP_HCA,
                            DBGP("---%hsFlag=%04lx, KCheck=%s, KPower=%s ---"
                                    ARGPTR((PrimAdj.Flags & DCA_REPLACE_BLACK) ?
                                        "DCA_REPLACE_BLACK, " : " ")
                                    ARGDW(DMI.Flags)
                                    ARGFD6(DMI.BlackChk, 1, 6)
                                    ARGFD6(K_REP_POWER, 1, 6)));
                }

                DBGP_IF(DBGP_HCA,
                    DBGP("---DCA_MASK8BPP (%hs), Idx=%02lx, Xor=%02lx, K=%02lx (%ld), W=(%02lx/%ld) ---"
                            ARGPTR((DCIFlags & DCIF_INVERT_8BPP_BITMASK_IDX) ?
                                    "RGB" : "CMY")
                            ARGDW(bm8i.Data.pXlateIdx)
                            ARGDW(bm8i.Data.bXor)
                            ARGDW(bm8i.Data.bBlack) ARGDW(bm8i.Data.bBlack)
                            ARGDW(bm8i.Data.bWhite) ARGDW(bm8i.Data.bWhite)));

                LUTAAHdr[3] =
                LUTAAHdr[4] =
                LUTAAHdr[5] = bm8i.dw;


            } else {

                //
                //  PRIMARY_ORDER_BGR (Always BGR system halftone palette)
                //                |||
                //                ||+-- bit 0-2  (3 bits)
                //                ||
                //                |+--- bit 3-5  (3 bits)
                //                |
                //                +---- bit 6-8  (3 bits)
                //
                //

                DMI.Mul[0]               =
                DMI.Mul[1]               =
                DMI.Mul[2]               = 0x4FFF;
                LUTAAHdr[0]              = 0x0070000;
                LUTAAHdr[1]              = 0x0380000;
                LUTAAHdr[2]              = 0x1c00000;
                DMI.LSft[0]              = 4;
                DMI.LSft[1]              = 7;
                DMI.LSft[2]              = 10;
                DMI.CTSTDInfo.DestOrder  = PRIMARY_ORDER_BGR;
                PrimAdj.Flags           &= ~DCA_MASK8BPP;
            }

            break;

        case BMF_16BPP_555:

            //
            //  PRIMARY_ORDER_abc
            //                |||
            //                ||+-- bit 0-4   (5 bits)
            //                ||
            //                |+--- bit 5-9   (5 bits)
            //                |
            //                +---- bit 10-14 (5 bits)
            //
            //

            DMI.Mul[0]  =
            DMI.Mul[1]  =
            DMI.Mul[2]  = 0x1EFFF;
            LUTAAHdr[0] = 0x001F0000;
            LUTAAHdr[1] = 0x03e00000;
            LUTAAHdr[2] = 0x7c000000;
            LUTAAHdr[3] =
            LUTAAHdr[4] =
            LUTAAHdr[5] = 0x7FFF7FFF;
            DMI.LSft[0] = 4;
            DMI.LSft[1] = 9;
            DMI.LSft[2] = 14;

            break;

        case BMF_16BPP_565:

            //
            //  PRIMARY_ORDER_RGB (or BGR)
            //                |||
            //                ||+-- bit 0-4   (5 bits)
            //                ||
            //                |+--- bit 5-10  (6 bits)
            //                |
            //                +---- bit 11-15 (5 bits)
            //
            //

            switch (DMI.CTSTDInfo.DestOrder) {

            case PRIMARY_ORDER_RGB:
            case PRIMARY_ORDER_BGR:

                break;

            default:

                DBGP("Invalid 16BPP 565 Order=%ld, Allowed=(%ld,%ld) --> %ld"
                        ARGDW(DMI.CTSTDInfo.DestOrder)
                        ARGDW(PRIMARY_ORDER_RGB) ARGDW(PRIMARY_ORDER_BGR)
                        ARGDW(PRIMARY_ORDER_RGB));

                DMI.CTSTDInfo.DestOrder = PRIMARY_ORDER_RGB;
            }

            DMI.Mul[0]  =
            DMI.Mul[2]  = 0x1EFFF;
            DMI.Mul[1]  = 0x3EFFF;
            LUTAAHdr[0] = 0x001F0000;
            LUTAAHdr[1] = 0x07e00000;
            LUTAAHdr[2] = 0xF8000000;
            LUTAAHdr[3] =
            LUTAAHdr[4] =
            LUTAAHdr[5] = 0xFFFFFFFF;
            DMI.LSft[0] = 4;
            DMI.LSft[1] = 9;
            DMI.LSft[2] = 15;

            break;

        case BMF_24BPP:

            //
            //  PRIMARY_ORDER_BGR (system standard always BGR)
            //                |||
            //                ||+-- bit 0-7   (8 bits)
            //                ||
            //                |+--- bit 8-15  (8 bits)
            //                |
            //                +---- bit 16-23 (8 bits)
            //
            //

            DBGP_IF(DBGP_HCA,
                    DBGP("24BPP DstOrder=%ld" ARGDW(DMI.CTSTDInfo.DestOrder)));

            //
            // Fall through
            //

        case BMF_32BPP:

            //
            //  PRIMARY_ORDER_abc
            //                |||
            //                ||+-- bit 0-7   (8 bits)
            //                ||
            //                |+--- bit 8-15  (8 bits)
            //                |
            //                +---- bit 16-23 (8 bits)
            //
            //

            DMI.Mul[0]  =
            DMI.MulAdd              = 0;
            DMI.LSft[0]             =
            DMI.LSft[1]             =
            DMI.LSft[2]             = 0;
            DMI.Mul[0]              =
            DMI.Mul[1]              =
            DMI.Mul[2]              = 0xFF;
            LUTAAHdr[0]             = 0;
            LUTAAHdr[1]             = 1;
            LUTAAHdr[2]             = 2;
            break;
        }

        //
        // Watch out!!!, the ExtBGR must in BGR order
        //

        DMI.DstOrder               = DstOrderTable[DMI.CTSTDInfo.DestOrder];
        pDevClrAdj->DMI            = DMI;
        pDevClrAdj->ca             = ca;
        prgbLUT->ExtBGR[2]         = LUTAAHdr[DMI.DstOrder.Order[0]];
        prgbLUT->ExtBGR[1]         = LUTAAHdr[DMI.DstOrder.Order[1]];
        prgbLUT->ExtBGR[0]         = LUTAAHdr[DMI.DstOrder.Order[2]];
        prgbLUT->ExtBGR[5]         = LUTAAHdr[DMI.DstOrder.Order[0] + 3];
        prgbLUT->ExtBGR[4]         = LUTAAHdr[DMI.DstOrder.Order[1] + 3];
        prgbLUT->ExtBGR[3]         = LUTAAHdr[DMI.DstOrder.Order[2] + 3];
        pDevClrAdj->PrimAdj        = PrimAdj;
        pDevClrAdj->pClrXFormBlock = &(pDCI->ClrXFormBlock);
        pDevClrAdj->pCRTXLevel255  = &(pDCI->CRTX[CRTX_LEVEL_255]);
        pDevClrAdj->pCRTXLevelRGB  = &(pDCI->CRTX[CRTX_LEVEL_RGB]);

        DBGP_IF(DBGP_HCA,
                DBGP("DestFmt=%3ld, Order=%ld [%ld:%ld:%ld], DMI.Flags=%02lx"
                    ARGDW(DMI.CTSTDInfo.BMFDest) ARGDW(DMI.DstOrder.Index)
                    ARGDW(DMI.DstOrder.Order[0]) ARGDW(DMI.DstOrder.Order[1])
                    ARGDW(DMI.DstOrder.Order[2]) ARGDW(DMI.Flags)));

        DBGP_IF(DBGP_HCA,
                DBGP("ExtBGR=%08lx:%08lx:%08lx:%08lx:%08lx:%08lx, LSft=%ld:%ld:%ld"
                    ARGDW(prgbLUT->ExtBGR[0]) ARGDW(prgbLUT->ExtBGR[1])
                    ARGDW(prgbLUT->ExtBGR[2]) ARGDW(prgbLUT->ExtBGR[3])
                    ARGDW(prgbLUT->ExtBGR[4]) ARGDW(prgbLUT->ExtBGR[5])
                    ARGDW(pDevClrAdj->DMI.LSft[0])
                    ARGDW(pDevClrAdj->DMI.LSft[1])
                    ARGDW(pDevClrAdj->DMI.LSft[2])));

        DBGP_IF(DBGP_HCA,
                DBGP("Mul=%08lx:%08lx:%08lx, MulAdd=%08lx"
                    ARGDW(pDevClrAdj->DMI.Mul[0]) ARGDW(pDevClrAdj->DMI.Mul[1])
                    ARGDW(pDevClrAdj->DMI.Mul[2]) ARGDW(pDevClrAdj->DMI.MulAdd)));

        DBGP_IF(DBGP_PRIMADJFLAGS,
                DBGP("pDCIAdjClr: PrimAdj.Flags=%08lx" ARGDW(PrimAdj.Flags)));
    }

    return(pDCI);
}



VOID
HTENTRY
ComputeColorSpaceXForm(
    PDEVICECOLORINFO    pDCI,
    PCIEPRIMS           pCIEPrims,
    PCOLORSPACEXFORM    pCSXForm,
    INT                 IlluminantIndex
    )

/*++

Routine Description:

    This function take device's R/G/B/W CIE coordinate (x,y) and compute
    3 x 3 transform matrix, it assume the primaries are additively.

    Calcualte the 3x3 CIE matrix and its inversion (matrix) based on the
    C.I.E. CHROMATICITY x, y coordinates or RGB and WHITE alignment.

    this function produces the CIE XYZ matrix and/or its inversion for trnaform
    between RGB primary colors and CIE color spaces, the transforms are
                                                        -1
    [ X ] = [ Xr Xg Xb ] [ R ]      [ R ] = [ Xr Xg Xb ]   [ X ]
    [ Y ] = [ Yr Yg Yb ] [ G ] and  [ G ]   [ Yr Yg Yb ]   [ Y ]
    [ Z ] = [ Zr Zg Zb ] [ B ]      [ B ]   [ Zr Zg Zb ]   [ Z ]

Arguments:

    pDCI            - The current device color info

    pCIEPrims       - Pointer to CIEPRIMS data structure, the CIEPRIMS data
                      must already validated.

    pCSXForm        - Pointer to the location to stored the transfrom

    ColorSpace      - CIELUV or CIELAB

    IlluminantIndex - Standard illuminant index if < 0 then pCIEPrims->w is
                      used

Return Value:

    VOID

Author:

    11-Oct-1991 Fri 14:19:59 created    -by-  Daniel Chou (danielc)


Revision History:

    20-Apr-1993 Tue 03:08:15 updated  -by-  Daniel Chou (danielc)
        re-write so that xform will be correct when device default is used.

    22-Jan-1998 Thu 03:01:02 updated  -by-  Daniel Chou (danielc)
        use IlluminantIndex to indicate if device reverse transform is needed


--*/

{
    MATRIX3x3   Matrix3x3;
    FD6XYZ      WhiteXYZ;
    MULDIVPAIR  MDPairs[5];
    FD6         DiffRGB;
    FD6         RedXYZScale;
    FD6         GreenXYZScale;
    FD6         BlueXYZScale;
    FD6         AUw;
    FD6         BVw;
    FD6         xr;
    FD6         yr;
    FD6         xg;
    FD6         yg;
    FD6         xb;
    FD6         yb;
    FD6         xw;
    FD6         yw;
    FD6         Yw;



    xr = pCIEPrims->r.x;
    yr = pCIEPrims->r.y;
    xg = pCIEPrims->g.x;
    yg = pCIEPrims->g.y;
    xb = pCIEPrims->b.x;
    yb = pCIEPrims->b.y;
    Yw = pCIEPrims->Yw;

    if (IlluminantIndex < 0) {

        xw = pCIEPrims->w.x;
        yw = pCIEPrims->w.y;

    } else {

        if (--IlluminantIndex < 0) {

            IlluminantIndex = ILLUMINANT_D65 - 1;
        }

        pCIEPrims->w.x =
        xw             = UDECI4ToFD6(StdIlluminant[IlluminantIndex].x);
        pCIEPrims->w.y =
        yw             = UDECI4ToFD6(StdIlluminant[IlluminantIndex].y);
    }

    DBGP_IF(DBGP_CIEMATRIX,
            DBGP("** CIEINFO:  [xw, yw, Yw] = [%s, %s, %s], Illuminant=%d"
                ARGFD6l(xw) ARGFD6l(yw) ARGFD6l(Yw) ARGI(IlluminantIndex)));

    DBGP_IF(DBGP_CIEMATRIX,
            DBGP("[xR yR] = [%s %s]" ARGFD6l(xr) ARGFD6l(yr));
            DBGP("[xG yG] = [%s %s]" ARGFD6l(xg) ARGFD6l(yg));
            DBGP("[xB yB] = [%s %s]" ARGFD6l(xb) ARGFD6l(yb));
            DBGP("***********************************************"));

    //
    // Normalized to have C.I.E. Y equal to 1.0
    //

    MAKE_MULDIV_INFO(MDPairs, 3, MULDIV_HAS_DIVISOR);
    MAKE_MULDIV_DVSR(MDPairs, Yw);

    MAKE_MULDIV_PAIR(MDPairs, 1, xr, yg - yb);
    MAKE_MULDIV_PAIR(MDPairs, 2, xg, yb - yr);
    MAKE_MULDIV_PAIR(MDPairs, 3, xb, yr - yg);

    DiffRGB = MulFD6(yw, MulDivFD6Pairs(MDPairs));

    //
    // Compute Scaling factors for each color
    //

    MAKE_MULDIV_INFO(MDPairs, 4, MULDIV_HAS_DIVISOR);
    MAKE_MULDIV_DVSR(MDPairs, DiffRGB);

    MAKE_MULDIV_PAIR(MDPairs, 1,  xw, yg - yb);
    MAKE_MULDIV_PAIR(MDPairs, 2, -yw, xg - xb);
    MAKE_MULDIV_PAIR(MDPairs, 3,  xg, yb     );
    MAKE_MULDIV_PAIR(MDPairs, 4, -xb, yg     );

    RedXYZScale = MulDivFD6Pairs(MDPairs);

    MAKE_MULDIV_PAIR(MDPairs, 1,  xw, yb - yr);
    MAKE_MULDIV_PAIR(MDPairs, 2, -yw, xb - xr);
    MAKE_MULDIV_PAIR(MDPairs, 3, -xr, yb     );
    MAKE_MULDIV_PAIR(MDPairs, 4,  xb, yr     );

    GreenXYZScale = MulDivFD6Pairs(MDPairs);

    MAKE_MULDIV_PAIR(MDPairs, 1,  xw, yr - yg);
    MAKE_MULDIV_PAIR(MDPairs, 2, -yw, xr - xg);
    MAKE_MULDIV_PAIR(MDPairs, 3,  xr, yg     );
    MAKE_MULDIV_PAIR(MDPairs, 4, -xg, yr     );

    BlueXYZScale = MulDivFD6Pairs(MDPairs);

    //
    // Now scale the RGB coordinate by it ratio, notice that C.I.E z value.
    // equal to (1.0 - x - y)
    //
    // Make sure Yr + Yg + Yb = 1.0, this may happened when ruound off
    // durning the computation, we will add the difference (at most it will
    // be 0.000002) to the Yg since this is brightnest color
    //

    CIE_Xr(Matrix3x3) = MulFD6(xr,              RedXYZScale);
    CIE_Xg(Matrix3x3) = MulFD6(xg,              GreenXYZScale);
    CIE_Xb(Matrix3x3) = MulFD6(xb,              BlueXYZScale);

    pCSXForm->Yrgb.R  =
    CIE_Yr(Matrix3x3) = MulFD6(yr,              RedXYZScale);
    pCSXForm->Yrgb.G  =
    CIE_Yg(Matrix3x3) = MulFD6(yg,              GreenXYZScale);
    pCSXForm->Yrgb.B  =
    CIE_Yb(Matrix3x3) = MulFD6(yb,              BlueXYZScale);

    CIE_Zr(Matrix3x3) = MulFD6(FD6_1 - xr - yr, RedXYZScale);
    CIE_Zg(Matrix3x3) = MulFD6(FD6_1 - xg - yg, GreenXYZScale);
    CIE_Zb(Matrix3x3) = MulFD6(FD6_1 - xb - yb, BlueXYZScale);

    WhiteXYZ.X = CIE_Xr(Matrix3x3) + CIE_Xg(Matrix3x3) + CIE_Xb(Matrix3x3);
    WhiteXYZ.Y = CIE_Yr(Matrix3x3) + CIE_Yg(Matrix3x3) + CIE_Yb(Matrix3x3);
    WhiteXYZ.Z = CIE_Zr(Matrix3x3) + CIE_Zg(Matrix3x3) + CIE_Zb(Matrix3x3);

    //
    // If request a 3 x 3 transform matrix then save the result back
    //

    DBGP_IF(DBGP_CIEMATRIX,

        DBGP("== RGB -> XYZ 3x3 Matrix ==== White = (%s, %s) =="
                                   ARGFD6s(xw) ARGFD6s(yw));
        DBGP("[Xr Xg Xb] = [%s %s %s]" ARGFD6l(CIE_Xr(Matrix3x3))
                                   ARGFD6l(CIE_Xg(Matrix3x3))
                                   ARGFD6l(CIE_Xb(Matrix3x3)));
        DBGP("[Yr Yg Yb] = [%s %s %s]" ARGFD6l(CIE_Yr(Matrix3x3))
                                   ARGFD6l(CIE_Yg(Matrix3x3))
                                   ARGFD6l(CIE_Yb(Matrix3x3)));
        DBGP("[Zr Zg Zb] = [%s %s %s]" ARGFD6l(CIE_Zr(Matrix3x3))
                                       ARGFD6l(CIE_Zg(Matrix3x3))
                                       ARGFD6l(CIE_Zb(Matrix3x3)));
        DBGP("===============================================");
    );

    DBGP_IF(DBGP_CIEMATRIX,
           DBGP("RGB->XYZ: [Xw=%s, Yw=%s, Zw=%s]"
                ARGFD6l(WhiteXYZ.X)
                ARGFD6l(WhiteXYZ.Y)
                ARGFD6l(WhiteXYZ.Z)));

    if (IlluminantIndex < 0) {

        pCSXForm->M3x3 = Matrix3x3;

        ComputeInverseMatrix3x3(&(pCSXForm->M3x3), &Matrix3x3);

        DBGP_IF(DBGP_CIEMATRIX,

            DBGP("======== XYZ -> RGB INVERSE 3x3 Matrix ========");
            DBGP("          -1");
            DBGP("[Xr Xg Xb]   = [%s %s %s]" ARGFD6l(CIE_Xr(Matrix3x3))
                                             ARGFD6l(CIE_Xg(Matrix3x3))
                                             ARGFD6l(CIE_Xb(Matrix3x3)));
            DBGP("[Yr Yg Yb]   = [%s %s %s]"
                                             ARGFD6l(CIE_Yr(Matrix3x3))
                                             ARGFD6l(CIE_Yg(Matrix3x3))
                                             ARGFD6l(CIE_Yb(Matrix3x3)));
            DBGP("[Zr Zg Zb]   = [%s %s %s]"
                                             ARGFD6l(CIE_Zr(Matrix3x3))
                                             ARGFD6l(CIE_Zg(Matrix3x3))
                                             ARGFD6l(CIE_Zb(Matrix3x3)));
            DBGP("===============================================");
        );
    }

    if ((pCSXForm->YW = WhiteXYZ.Y) != NORMALIZED_WHITE) {

        if (WhiteXYZ.Y) {

            WhiteXYZ.X = DivFD6(WhiteXYZ.X, WhiteXYZ.Y);
            WhiteXYZ.Z = DivFD6(WhiteXYZ.Z, WhiteXYZ.Y);

        } else {

            WhiteXYZ.X =
            WhiteXYZ.Z = FD6_0;
        }

        WhiteXYZ.Y = NORMALIZED_WHITE;
    }

    switch (pDCI->ClrXFormBlock.ColorSpace) {

    case CIELUV_1976:

        //
        // U' = 4X / (X + 15Y + 3Z)
        // V' = 9Y / (X + 15Y + 3Z)
        //
        // U* = 13 x L x (U' - Uw)
        // V* = 13 x L x (V' - Vw)
        //
        //

        DiffRGB = WhiteXYZ.X + FD6xL(WhiteXYZ.Y, 15) + FD6xL(WhiteXYZ.Z, 3);
        AUw     = DivFD6(FD6xL(WhiteXYZ.X, 4), DiffRGB);
        BVw     = DivFD6(FD6xL(WhiteXYZ.Y, 9), DiffRGB);

        break;

    case CIELAB_1976:
    default:

        //
        // CIELAB 1976 L*A*B*
        //
        //  A* = 500 x (fX - fY)
        //  B* = 200 x (fY - fZ)
        //
        //             1/3
        //  fX = (X/Xw)                     (X/Xw) >  0.008856
        //  fX = 7.787 x (X/Xw) + (16/116)  (X/Xw) <= 0.008856
        //
        //             1/3
        //  fY = (Y/Yw)                     (Y/Yw) >  0.008856
        //  fY = 7.787 Y (Y/Yw) + (16/116)  (Y/Yw) <= 0.008856
        //
        //             1/3
        //  fZ = (Z/Zw)                     (Z/Zw) >  0.008856
        //  fZ = 7.787 Z (Z/Zw) + (16/116)  (Z/Zw) <= 0.008856
        //

        AUw =
        BVw = FD6_0;

        break;

    }

    pCSXForm->M3x3     = Matrix3x3;
    pCSXForm->WhiteXYZ = WhiteXYZ;
    pCSXForm->AUw      = AUw;
    pCSXForm->BVw      = BVw;
    pCSXForm->xW       = xw;
    pCSXForm->yW       = yw;

    DBGP_IF(DBGP_CSXFORM,
        DBGP("------- ComputeColorSpaceXForm: %s ---------"
                            ARG(pDbgCSName[pDCI->ClrXFormBlock.ColorSpace]));
        DBGP("   White XYZ = (%s, %s, %s)" ARGFD6(WhiteXYZ.X, 1, 6)
                                           ARGFD6(WhiteXYZ.Y, 1, 6)
                                           ARGFD6(WhiteXYZ.Z, 1, 6));
        DBGP("     AUw/BVw = %s / %s" ARGFD6(AUw, 1, 6) ARGFD6s(BVw));
        DBGP("   White xyY = (%s, %s, %s)" ARGFD6(pCSXForm->xW, 1, 6)
                                           ARGFD6(pCSXForm->yW, 1, 6)
                                           ARGFD6(pCSXForm->YW, 1, 6));
        DBGP("------------------------------------------------");
    );
}




PCACHERGBTOXYZ
HTENTRY
CacheRGBToXYZ(
    PCACHERGBTOXYZ      pCRTX,
    PFD6XYZ             pFD6XYZ,
    LPDWORD             pNewChecksum,
    PDEVCLRADJ          pDevClrAdj
    )

/*++

Routine Description:

    This function cached the RGB color input to XYZ


Arguments:

    pCRTX       - Pointer to the CACHERGBTOXYZ

    pFD6XYZ     - Pointer to the local cached RGB->XYZ table (will be updated)

    pNewChecksum- Pointer to the new checksum computed

    pDevClrAdj  - Pointer to DEVCLRADJ,

Return Value:

    if a cahced is copied to the pFD6XYZ then NULL will be returned, otherwise
    the cache table is computed on the pFD6XYZ and pCRTX returned


    TRUE if cached XYZ info is generate, false otherwise, only possible failure
    is that memory allocation failed.

Author:

    08-May-1992 Fri 13:21:03 created  -by-  Daniel Chou (danielc)


Revision History:

    09-Mar-1995 Thu 10:50:13 updated  -by-  Daniel Chou (danielc)
        DO NOT TURN OFF DCA_NEGATIVE in this function

--*/

{
    PMATRIX3x3  pRGBToXYZ;
    PPRIMADJ    pPrimAdj;
    FD6         rgbX;
    FD6         rgbY;
    FD6         rgbZ;
    FD6         PrimCur;
    UINT        PrimMax;
    UINT        PrimInc;
    DWORD       Checksum;
    UINT        RGBIndex;

    //
    // Turn off the one we did not need any checksum for
    //

    pPrimAdj   = &(pDevClrAdj->PrimAdj);
    pRGBToXYZ  = &(pPrimAdj->rgbCSXForm.M3x3);
    Checksum   = ComputeChecksum((LPBYTE)pRGBToXYZ, 'CXYZ', sizeof(MATRIX3x3));

    if ((pCRTX->pFD6XYZ) &&
        (pCRTX->Checksum == Checksum)) {

        CopyMemory(pFD6XYZ, pCRTX->pFD6XYZ, pCRTX->SizeCRTX);

        DBGP_IF(DBGP_CACHED_GAMMA,
                DBGP("*** Use %u bytes CACHED RGB->XYZ Table ***"
                    ARGU(pCRTX->SizeCRTX)));

        return(NULL);
    }

    *pNewChecksum = Checksum;

    DBGP_IF(DBGP_CCT, DBGP("** Re-Compute %ld bytes RGB->XYZ xform table **"
                    ARGDW(pCRTX->SizeCRTX)));

    PrimMax = (UINT)pCRTX->PrimMax;

    for (RGBIndex = 0; RGBIndex < 3; RGBIndex++) {

        rgbX = pRGBToXYZ->m[X_INDEX][RGBIndex];
        rgbY = pRGBToXYZ->m[Y_INDEX][RGBIndex];
        rgbZ = pRGBToXYZ->m[Z_INDEX][RGBIndex];

        DBGP_IF(DBGP_CACHED_GAMMA,
                DBGP("CachedRGBToXYZ %u:%u, XYZ=%s:%s:%s"
                         ARGU(RGBIndex) ARGU(PrimMax)
                         ARGFD6(rgbX,  2, 6) ARGFD6(rgbY,  2, 6)
                         ARGFD6(rgbZ,  2, 6)));

        for (PrimInc = 0; PrimInc <= PrimMax; PrimInc++, pFD6XYZ++) {

            PrimCur     = DivFD6((FD6)PrimInc, (FD6)PrimMax);
            pFD6XYZ->X  = MulFD6(rgbX, PrimCur);
            pFD6XYZ->Y  = MulFD6(rgbY, PrimCur);
            pFD6XYZ->Z  = MulFD6(rgbZ, PrimCur);

            DBGP_IF(DBGP_CACHED_GAMMA,
                    DBGP("(%u:%3u): %s, XYZ=%s:%s:%s"
                    ARGU(RGBIndex) ARGU(PrimInc)
                    ARGFD6(PrimCur, 1, 6)
                    ARGFD6(pFD6XYZ->X, 1, 6)
                    ARGFD6(pFD6XYZ->Y, 1, 6)
                    ARGFD6(pFD6XYZ->Z, 1, 6)));
        }
    }

    return(pCRTX);
}


#define RD_MIN_POWER    (FD6)1500000
#define RD_MAX_POWER    (FD6)2000000

#define GET_RD_MIN_PRIM(p, RD)                                              \
{                                                                           \
  (p) = FD6_1 - DivFD6(p, RD.LMin);                                         \
  (p) = MulFD6(FD6_1 - Power(p, RD_MIN_POWER), RD.LMin);                    \
}

#define GET_RD_MAX_PRIM(p, RD)                                              \
{                                                                           \
  (p) = DivFD6((p) - RD.LMax, FD6_1 - RD.LMax);                             \
  (p) = RD.LMax + MulFD6(Power(p, RD_MAX_POWER), FD6_1 - RD.LMax);          \
}




VOID
HTENTRY
ComputeRGBLUTAA(
    PDEVICECOLORINFO    pDCI,
    PDEVCLRADJ          pDevClrAdj,
    PRGBLUTAA           prgbLUT
    )

/*++

Routine Description:

    This function compute a RGB to Monochrome *L translation table.


Arguments:

    pDCI        - Pointer to the DEVICECOLORINFO

    pDevClrAdj  - Pointer to DEVCLRADJ, the DCA_NEGATIVE and DCA_HAS_SRC_GAMMA
                  flags in pDevClrAdj->PrimAdj.Flags will always be turn off
                  at return.

    prgbLUT     - Pointer to the RGBLUTAA buffer for computation

Return Value:

    VOID

Author:

    05-Mar-1993 Fri 17:37:12 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPDWORD             pdw;
    LPBYTE              pbAB;
    REGDATA             RD;
    PRIMADJ             PrimAdj;
    DEVMAPINFO          DMI;
    HTCOLORADJUSTMENT   ca;
    FD6                 Prim;
    FD6                 PrimOrg;
    FD6                 PrimKDiv;
    FD6                 Mul;
    FD6                 SrcGamma;
    FD6                 DevGamma;
    DWORD               dwPrim;
    DWORD               PrimMask;
    DWORD               aMulAdd[3];
    DWORD               CurCA;
    DWORD               PrevCA;
    FD6                 aPrimMaxMul[3];
    FD6                 PrimMaxMul;
    PFD6                pDenCMY[3];
    PFD6                pDensity;
    UINT                Index;
    UINT                LeftShift;
    UINT                PrimIdx;
    INT                 PrimCur;


    PrimAdj                     = pDevClrAdj->PrimAdj;
    ca                          = pDevClrAdj->ca;
    DMI                         = pDevClrAdj->DMI;
    pDevClrAdj->PrimAdj.Flags  &= ~(DCA_HAS_SRC_GAMMA       |
                                    DCA_HAS_DEST_GAMMA      |
                                    DCA_HAS_BW_REF_ADJ      |
                                    DCA_HAS_CONTRAST_ADJ    |
                                    DCA_HAS_BRIGHTNESS_ADJ  |
                                    DCA_LOG_FILTER          |
                                    DCA_NEGATIVE            |
                                    DCA_DO_DEVCLR_XFORM);

    ca.caColorfulness =
    ca.caRedGreenTint = (PrimAdj.Flags & DCA_MONO_ONLY) ? 0xff : 0x00;

    SET_CACHED_CMI_CA(pDevClrAdj->ca);

    aPrimMaxMul[0] =
    aPrimMaxMul[1] =
    aPrimMaxMul[2] = FD6_1;
    aMulAdd[0]     =
    aMulAdd[1]     =
    aMulAdd[2]     = DMI.MulAdd;
    pDenCMY[0]     =
    pDenCMY[1]     =
    pDenCMY[2]     = NULL;

    if (PrimAdj.Flags & DCA_RGBLUTAA_MONO) {

        ASSERT(PrimAdj.Flags & DCA_NO_MAPPING_TABLE);
        ASSERT(DMI.Mul[1] == GRAY_MAX_IDX);
        ASSERT(PrimAdj.Flags & DCA_MONO_ONLY);
        ASSERT(DMI.MulAdd == 0);
        ASSERT(DMI.Flags & DMIF_GRAY);

        DMI.Mul[0]             = (DWORD)MulFD6(NTSC_R_INT, DMI.Mul[1]);
        DMI.Mul[2]             = (DWORD)MulFD6(NTSC_B_INT, DMI.Mul[1]);
        DMI.Mul[1]            -= (DMI.Mul[0] + DMI.Mul[2]);
        DMI.DstOrder.Order[0]  = 0;
        DMI.DstOrder.Order[1]  = 1;
        DMI.DstOrder.Order[2]  = 2;
        DMI.LSft[0]            =
        DMI.LSft[1]            =
        DMI.LSft[2]            = 0;

    } else {

        ASSERT(!(DMI.Flags & DMIF_GRAY));

        if (PrimAdj.Flags & DCA_MASK8BPP) {

            ASSERT((pDCI->Flags & (DCIF_USE_8BPP_BITMASK |
                                   DCIF_MONO_8BPP_BITMASK)) ==
                                   DCIF_USE_8BPP_BITMASK);

            aPrimMaxMul[0] = pDCI->CMY8BPPMask.MaxMulY;
            aPrimMaxMul[1] = pDCI->CMY8BPPMask.MaxMulM;
            aPrimMaxMul[2] = pDCI->CMY8BPPMask.MaxMulC;

            if (pDCI->Flags & DCIF_HAS_DENSITY) {

                pDenCMY[0] = pDCI->CMY8BPPMask.DenY;
                pDenCMY[1] = pDCI->CMY8BPPMask.DenM;
                pDenCMY[2] = pDCI->CMY8BPPMask.DenC;
            }
        }
    }

    if (!(PrimAdj.Flags & DCA_REPLACE_BLACK)) {

        DMI.BlackChk = FD6_1;
    }

    PrimMask = PrimAdj.Flags & (DCA_REPLACE_BLACK   |
                                DCA_DO_DEVCLR_XFORM |
                                DCA_ALPHA_BLEND     |
                                DCA_CONST_ALPHA     |
                                DCA_NO_MAPPING_TABLE);

    GET_CHECKSUM(PrimMask, PrimAdj.SrcGamma);
    GET_CHECKSUM(PrimMask, PrimAdj.DevGamma);
    GET_CHECKSUM(PrimMask, ca);
    GET_CHECKSUM(PrimMask, DMI);

    CurCA  = (DWORD)pDCI->CurConstAlpha;
    PrevCA = (DWORD)pDCI->PrevConstAlpha;

    if (prgbLUT->Checksum != PrimMask) {

        prgbLUT->Checksum    = PrimMask;
        PrevCA               =
        pDCI->PrevConstAlpha = AB_CONST_MAX + 1;

        DBGP_IF(DBGP_RGBLUTAA,
                DBGP("** Re-Compute %ld bytes of pLUT=%p, SG=%s:%s:%s, DG=%s:%s:%s **"
                        ARGDW(sizeof(RGBLUTAA))
                        ARGPTR(prgbLUT)
                        ARGFD6(PrimAdj.SrcGamma[0], 1, 4)
                        ARGFD6(PrimAdj.SrcGamma[1], 1, 4)
                        ARGFD6(PrimAdj.SrcGamma[2], 1, 4)
                        ARGFD6(PrimAdj.DevGamma[0], 1, 4)
                        ARGFD6(PrimAdj.DevGamma[1], 1, 4)
                        ARGFD6(PrimAdj.DevGamma[2], 1, 4)));

        DBGP_IF(DBGP_RGBLUTAA,
                DBGP("DMI.Mul=%08lx:%08lx:%08lx, %08lx, LSft=%ld:%ld:%ld"
                    ARGDW(DMI.Mul[0]) ARGDW(DMI.Mul[1]) ARGDW(DMI.Mul[2])
                    ARGDW(DMI.Mul[0] + DMI.Mul[1] + DMI.Mul[2])
                    ARGDW(DMI.LSft[0]) ARGDW(DMI.LSft[1]) ARGDW(DMI.LSft[2])));

        if (PrimAdj.Flags & DCA_DO_DEVCLR_XFORM) {

            RD = RegData[pDCI->ClrXFormBlock.RegDataIdx];
        }

        //
        // Compute order BGR
        //

        Index    = 3;
        PrimKDiv = FD6_1 - DMI.BlackChk;
        PrimMask = (DWORD)(DMI.MulAdd - 1);
        pdw      = (LPDWORD)prgbLUT->IdxBGR;

        if ((PrimAdj.Flags & DCA_ALPHA_BLEND) &&
            (!(DMI.Flags & DMIF_GRAY))) {

            pbAB = (LPBYTE)pDCI->pAlphaBlendBGR;

        } else {

            pbAB = NULL;
        }

        while (Index--) {

            SrcGamma   = PrimAdj.SrcGamma[Index];
            DevGamma   = PrimAdj.DevGamma[Index];
            PrimIdx    = DMI.DstOrder.Order[Index];
            PrimMaxMul = aPrimMaxMul[PrimIdx];
            DMI.MulAdd = aMulAdd[PrimIdx];
            LeftShift  = DMI.LSft[PrimIdx];
            Mul        = DMI.Mul[PrimIdx];
            pDensity   = pDenCMY[PrimIdx];
            PrimCur    = -1;

            DBGP_IF(DBGP_RGBLUTAA,
                    DBGP("Index=%ld: Mul=%08lx, LSft=%2ld [%08lx], PrimMaxMul=%s, MulAdd=%04lx"
                        ARGDW(Index) ARGDW(Mul) ARGDW(LeftShift)
                        ARGDW( ((Mul + DMI.MulAdd) & PrimMask) |
                              (((Mul + DMI.MulAdd) & ~PrimMask) << LeftShift))
                        ARGFD6(PrimMaxMul, 1, 6) ARGDW(DMI.MulAdd)));

            while (++PrimCur < BF_GRAY_TABLE_COUNT) {

                PrimOrg =
                Prim    = DivFD6((FD6)PrimCur, (FD6)(BF_GRAY_TABLE_COUNT - 1));

                if (PrimAdj.Flags & DCA_HAS_SRC_GAMMA) {

                    Prim = Power(Prim, SrcGamma);
                }

                if (PrimAdj.Flags & DCA_HAS_BW_REF_ADJ) {

                    PRIM_BW_ADJ(Prim, PrimAdj);
                }

                if (PrimAdj.Flags & DCA_HAS_CONTRAST_ADJ) {

                    PRIM_CONTRAST(Prim, PrimAdj);
                }

                if (PrimAdj.Flags & DCA_HAS_BRIGHTNESS_ADJ) {

                    PRIM_BRIGHTNESS(Prim, PrimAdj);
                }

                if (PrimAdj.Flags & DCA_LOG_FILTER) {

                    PRIM_LOG_FILTER(Prim);
                }

                CLAMP_01(Prim);

                if (PrimAdj.Flags & DCA_NEGATIVE) {

                    Prim = FD6_1 - Prim;
                }

                if (PrimAdj.Flags & DCA_DO_DEVCLR_XFORM) {

                    if (Prim <= RD.LMin) {

                        GET_RD_MIN_PRIM(Prim, RD);
                        Prim = REG_DMIN_ADD + 50 + MulFD6(Prim, RD.DMinMul);

                    } else if (Prim >= RD.LMax) {

                        GET_RD_MAX_PRIM(Prim, RD);
                        Prim = RD.DMaxAdd + 50 + MulFD6(Prim, RD.DMaxMul);

                    } else {

                        Prim = RD.DenAdd + 50 +
                               MulFD6(Log(CIE_L2I(Prim)), RD.DenMul);
                    }

                    Prim /= 100;
                }

                CLAMP_01(Prim);

                if (PrimAdj.Flags & DCA_HAS_DEST_GAMMA) {

                    Prim = Power(Prim, DevGamma);
                }

                if (pbAB) {

                    *pbAB++ = (BYTE)MulFD6(Prim, 0xFF);
                    Prim    = PrimOrg;
                }

                if (!(DMI.Flags & DMIF_GRAY)) {

                    Prim = FD6_1 - Prim;
                }

                if (pDensity) {

                    FD6     p1;
                    FD6     p2;
                    DWORD   Idx;

                    p2  = FD6_0;
                    Idx = ~0;

                    do {

                        p1 = p2;
                        p2 = pDensity[++Idx];

                    } while (Prim > p2);

                    dwPrim = MulFD6(DivFD6(Prim - p1, p2 - p1), MAX_BGR_IDX) +
                             (Idx << 12) + DMI.MulAdd;

                } else {

                    dwPrim = (DWORD)MulFD6(Prim, Mul) + DMI.MulAdd;
                }

                dwPrim = (DWORD)MulFD6(dwPrim & PrimMask, PrimMaxMul) |
                         ((DWORD)(dwPrim & ~PrimMask) << LeftShift);

                if (Prim > DMI.BlackChk) {

                    dwPrim |= (DWORD)MulFD6(Power(DivFD6(Prim - DMI.BlackChk,
                                                         PrimKDiv),
                                                  K_REP_POWER),
                                            MAX_K_IDX) << 21;
                }

                *pdw++ = dwPrim;
            }

            for (PrimCur = 0; PrimCur < BF_GRAY_TABLE_COUNT; PrimCur++) {

                DBGP_IF(DBGP_RGBLUTAA,
                        DBGP("COLOR(%04lx:%4ld) %3u = %08lx"
                             ARGU(Index) ARGU(Mul) ARGU(PrimCur)
                             ARGDW(*(pdw - BF_GRAY_TABLE_COUNT + PrimCur))));
            }

        }

    } else {

        DBGP_IF(DBGP_RGBLUTAA, DBGP("** Used Cached %ld bytes pLUT **"
                                ARGDW(sizeof(RGBLUTAA))));
    }

    if ((PrimAdj.Flags & (DCA_ALPHA_BLEND | DCA_CONST_ALPHA)) ==
                         (DCA_ALPHA_BLEND | DCA_CONST_ALPHA)) {

        if (PrevCA != CurCA) {

            LPWORD  pwBGR;
            LPWORD  pCA;


            DBGP_IF(DBGP_CONST_ALPHA,
                    DBGP("** %hs ConstAlpha=%3ld: Re-compute"
                        ARGPTR((DMI.Flags & DMIF_GRAY) ? "GRAY" : "STD")
                        ARGDW(CurCA)));

            pbAB                  = pDCI->pAlphaBlendBGR;
            pwBGR                 = (LPWORD)(pbAB + AB_BGR_SIZE);
            pCA                   = (LPWORD)((LPBYTE)pwBGR + AB_BGR_CA_SIZE);
            pDCI->CurConstAlpha   =
            pDCI->PrevConstAlpha  = (WORD)CurCA;
            PrevCA                = (DMI.Flags & DMIF_GRAY) ? 0xFFFF : 0xFF00;
            CurCA                 = (((CurCA * PrevCA) + 0x7F) / 0xFF);
            PrevCA               -= CurCA;

            for (Index = 0, dwPrim = 0x7F;
                 Index < 256;
                 Index++, dwPrim += CurCA) {

                pCA[Index] = (WORD)(dwPrim / 255);
            }

            if (DMI.Flags & DMIF_GRAY) {

                CopyMemory(pwBGR, pCA, sizeof(WORD) * 256);

            } else {

                Index = 256 * 3;

                while (Index--) {

                    *pwBGR++ = pCA[*pbAB++];
                }
            }

            for (Index = 0, dwPrim = 0x7F;
                 Index < 256;
                 Index++, dwPrim += PrevCA) {

                pCA[Index] = (WORD)(dwPrim / 255);
            }

        } else {

            DBGP_IF(DBGP_CONST_ALPHA,
                    DBGP("** %hs ConstAlpha=%3ld: Use Cache"
                        ARGPTR((DMI.Flags & DMIF_GRAY) ? "GRAY" : "STD")
                        ARGDW(CurCA)));
        }
    }

    DBGP_IF(DBGP_RGBLUTAA,
            DBGP("ComputeRGBLUTAA: PrimAdj.Flags=%08lx"
            ARGDW(pDevClrAdj->PrimAdj.Flags)));

}



#if NO_NEGATIVE_RGB_SCALE


VOID
HTENTRY
ScaleRGB(
    PFD6    pRGB
    )

/*++

Routine Description:

    This function scale out of range RGB back into range and taking the
    lumminance of the color into consideration.

    if any of RGB is less then 0.0 then it will first clamp that to 0.0 and
    it only scale if any of RGB is greater then 1.0

Arguments:

    pRGB    - Pointer to RGB (FD6) prims to be adjust


Return Value:

    VOID


Author:

    08-Mar-1995 Wed 19:19:33 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PFD6    pRGBTmp;
    FD6     MaxClr;
    INT     Idx;


    DEFDBGVAR(FD6,  RGBOld[3])
    DEFDBGVAR(BOOL, Negative = FALSE)



    Idx     = 3;
    pRGBTmp = pRGB;
    MaxClr  = FD6_1;

    while (Idx--) {

        FD6 CurClr;

        //
        // Firstable Clamp the negative component
        //

        if ((CurClr = *pRGBTmp) < FD6_0) {

            *pRGBTmp = FD6_0;

            SETDBGVAR(Negative, TRUE);

        } else if (CurClr > MaxClr) {

            MaxClr = CurClr;
        }

        ++pRGBTmp;

        SETDBGVAR(RGBOld[Idx], CurClr);
    }

    if (MaxClr > FD6_1) {

        //
        // Now Scale it
        //

        *pRGB++ = DivFD6(*pRGB, MaxClr);
        *pRGB++ = DivFD6(*pRGB, MaxClr);
        *pRGB   = DivFD6(*pRGB, MaxClr);

        DBGP_IF(DBGP_SCALE_RGB,
                DBGP("ScaleRGB: %s:%s:%s -> %s:%s:%s, Max=%s%s"
                ARGFD6(RGBOld[2], 1, 6)
                ARGFD6(RGBOld[1], 1, 6)
                ARGFD6(RGBOld[0], 1, 6)
                ARGFD6(*(pRGB - 2), 1, 6)
                ARGFD6(*(pRGB - 1), 1, 6)
                ARGFD6(*(pRGB    ), 1, 6)
                ARGFD6(MaxClr, 1, 6)
                ARG((Negative) ? "*NEG CLAMP*" : "")));
    } else {

        DBGP_IF(DBGP_SCALE_RGB,
            {

                if (Negative) {

                    DBGP("*NEG CLAMP ONLY* ScaleRGB: %s:%s:%s -> %s:%s:%s"
                         ARGFD6(RGBOld[2], 1, 6)
                         ARGFD6(RGBOld[1], 1, 6)
                         ARGFD6(RGBOld[0], 1, 6)
                         ARGFD6(*(pRGB    ), 1, 6)
                         ARGFD6(*(pRGB + 1), 1, 6)
                         ARGFD6(*(pRGB + 2), 1, 6));
                }
            }
        )
    }
}


#else


VOID
HTENTRY
ScaleRGB(
    PFD6    pRGB,
    PFD6    pYrgb
    )

/*++

Routine Description:

    This function scale out of range RGB back into range and taking the
    lumminance of the color into consideration.

    if any of RGB is less then 0.0 then it will first clamp that to 0.0 and
    it only scale if any of RGB is greater then 1.0

Arguments:

    pRGB    - Pointer to RGB (FD6) prims to be adjust

    pYrgb   - Pinter to the Luminance (FD6) of the RGB, if NULL then it is not
              used in the computation


Return Value:

    VOID


Author:

    08-Mar-1995 Wed 19:19:33 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    FD6     MaxClr = FD6_1;
    FD6     MinClr = FD6_10;
    FD6     RGBNew[3];
    FD6     RGBOld[3];



    if ((RGBOld[0] = pRGB[0]) > (RGBOld[1] = pRGB[1])) {

        MaxClr = RGBOld[0];
        MinClr = RGBOld[1];

    } else {

        MaxClr = RGBOld[1];
        MinClr = RGBOld[0];
    }

    if ((RGBOld[2] = pRGB[2]) > MaxClr) {

        MaxClr = RGBOld[2];
    }

    if (RGBOld[2] < MinClr) {

        MinClr = RGBOld[2];
    }

    if ((MaxClr <= FD6_1) && (MinClr >= FD6_0)) {

        return;
    }

    if (MinClr >= FD6_1) {

        DBGP_IF((DBGP_SCALE_RGB | DBGP_SCALE_RGB),
                DBGP("** RGB %s:%s:%s is too LIGHT make it WHITE"
                        ARGFD6(RGBOld[0], 1, 6)
                        ARGFD6(RGBOld[1], 1, 6)
                        ARGFD6(RGBOld[2], 1, 6)));

        pRGB[0] =
        pRGB[1] =
        pRGB[2] = FD6_1;

        return;
    }

    if (MaxClr <= FD6_0) {

        DBGP_IF((DBGP_SCALE_RGB | DBGP_SCALE_RGB),
                DBGP("** RGB %s:%s:%s is too DARK make it BLACK"
                        ARGFD6(RGBOld[0], 1, 6)
                        ARGFD6(RGBOld[1], 1, 6)
                        ARGFD6(RGBOld[2], 1, 6)));

        pRGB[0] =
        pRGB[1] =
        pRGB[2] = FD6_0;

        return;
    }

    if (MaxClr < FD6_1) {

        MaxClr = FD6_1;
    }

    if (MinClr > FD6_0) {

        MinClr = FD6_0;
    }

    MaxClr    -= MinClr;
    RGBNew[0]  = DivFD6(RGBOld[0] - MinClr, MaxClr);
    RGBNew[1]  = DivFD6(RGBOld[1] - MinClr, MaxClr);
    RGBNew[2]  = DivFD6(RGBOld[2] - MinClr, MaxClr);

    DBGP_IF(DBGP_SCALE_RGB,
            DBGP("ScaleRGB: %s:%s:%s -> %s:%s:%s, (%s/%s, %s)"
            ARGFD6(RGBOld[0], 1, 6)
            ARGFD6(RGBOld[1], 1, 6)
            ARGFD6(RGBOld[2], 1, 6)
            ARGFD6(RGBNew[0], 1, 6)
            ARGFD6(RGBNew[1], 1, 6)
            ARGFD6(RGBNew[2], 1, 6)
            ARGFD6(MinClr, 1, 6)
            ARGFD6(MaxClr + MinClr, 1, 6)
            ARGFD6(MaxClr, 1, 6)));


    if (pYrgb) {

        FD6 OldY;

        if ((OldY = MulFD6(RGBOld[0], pYrgb[0]) +
                    MulFD6(RGBOld[1], pYrgb[1]) +
                    MulFD6(RGBOld[2], pYrgb[2])) <= FD6_0) {

            DBGP_IF(DBGP_SHOWXFORM_RGB,
                    DBGP("OldY <= 0.0 (%s), Ignore and NO Y Scale"
                        ARGFD6(OldY, 2, 6)));

        } else if (OldY >= FD6_1) {

            DBGP_IF(DBGP_SHOWXFORM_RGB,
                    DBGP("OldY >= 1.0 (%s), Ignore and NO Y Scale"
                        ARGFD6(OldY, 2, 6)));

        } else {

            FD6 NewY;
            FD6 CurRatio;
            FD6 MaxRatio;

            NewY = MulFD6(RGBNew[0], pYrgb[0]) +
                   MulFD6(RGBNew[1], pYrgb[1]) +
                   MulFD6(RGBNew[2], pYrgb[2]);

            DBGP_IF(DBGP_SHOWXFORM_RGB,
                    DBGP("RGBOld=%s:%s:%s [Y=%s] --> New=%s:%s:%s [Y=%s]"
                    ARGFD6(pRGB[0], 1, 6)
                    ARGFD6(pRGB[1], 1, 6)
                    ARGFD6(pRGB[2], 1, 6)
                    ARGFD6(OldY, 1, 6)
                    ARGFD6(RGBNew[0], 1, 6)
                    ARGFD6(RGBNew[1], 1, 6)
                    ARGFD6(RGBNew[2], 1, 6)
                    ARGFD6(NewY, 1, 6)));

            if (OldY != NewY) {

                MaxClr = (RGBNew[0] > RGBNew[1]) ? RGBNew[0] : RGBNew[1];

                if (RGBNew[2] > MaxClr) {

                    MaxClr = RGBNew[2];
                }

                MaxRatio = DivFD6(FD6_1, MaxClr);
                CurRatio = DivFD6(OldY, NewY);

                if (CurRatio > MaxRatio) {

                    CurRatio = MaxRatio;
                }

                RGBNew[0] = MulFD6(RGBNew[0], CurRatio);
                RGBNew[1] = MulFD6(RGBNew[1], CurRatio);
                RGBNew[2] = MulFD6(RGBNew[2], CurRatio);

                DBGP_IF(DBGP_SHOWXFORM_RGB,
                        DBGP("CurRatio%s, MaxRatio=%s, MaxClr=%s"
                        ARGFD6(CurRatio, 1, 6)
                        ARGFD6(MaxRatio, 1, 6)
                        ARGFD6(MaxClr, 1, 6)));
            }
        }
    }

    //
    // Save back and return
    //

    pRGB[0] = RGBNew[0];
    pRGB[1] = RGBNew[1];
    pRGB[2] = RGBNew[2];
}

#endif




LONG
HTENTRY
ComputeBGRMappingTable(
    PDEVICECOLORINFO    pDCI,
    PDEVCLRADJ          pDevClrAdj,
    PCOLORTRIAD         pSrcClrTriad,
    PBGR8               pbgr
    )
/*++

Routine Description:

    This functions set up all the DECI4 value in PRIMRGB, PRIMCMY with
    PowerGamma, Brightness, Contrast adjustment and optionally to transform
    to C.I.E. color space and/or do the Colorfulness adjustment.

Arguments:

    pDCI            - Pointer to computed DEVICECOLORINFO

    pDevClrAdj      - Pointer to the pre-computed DEVCLRADJ data structure.

    pSrcClrTriad    - Pointer to the COLORTRIAD strcutrue for computation

    pbgr            - Pointer to the storage for computed BGR table


Return Value:

    Return value LONG

        Count of table generated, if < 0 then it is an error number


Author:

    30-Jan-1991 Wed 13:31:58 created  -by-  Daniel Chou (danielc)


Revision History:

    06-Feb-1992 Thu 21:39:46 updated  -by-  Daniel Chou (danielc)

        Rewrite!

    02-Feb-1994 Wed 17:33:55 updated  -by-  Daniel Chou (danielc)
        Remove unreferenced/unused variable L

    10-May-1994 Tue 11:24:16 updated  -by-  Daniel Chou (danielc)
        Bug# 13329, Memory Leak, Free Up pR_XYZ which I fogot to free it after
        allocated it.

    17-Dec-1998 Thu 16:33:16 updated  -by-  Daniel Chou (danielc)
        Re-organized so it use pbgr now, and it will only generate for color

    15-Feb-1999 Mon 15:40:03 updated  -by-  Daniel Chou (danielc)
        Re-do it only BGR 3 bytes for each entry, and it will generate both
        color or gray scale conversion, all color mapping for coloradjustment
        is done here, this includes internal ICM (when external icm is off)


--*/

{
    PFD6            pPrimA;
    PFD6            pPrimB;
    PFD6            pPrimC;
    LPBYTE          pSrcPrims;
    PCACHERGBTOXYZ  pCRTX;
    PFD6XYZ         pR_XYZ = NULL;
    PFD6XYZ         pG_XYZ;
    PFD6XYZ         pB_XYZ;
    COLORTRIAD      SrcClrTriad;
    PMATRIX3x3      pCMYDyeMasks;
    DWORD           Loop;
    DWORD           CRTXChecksum;
    DWORD           PrimAdjFlags;
    FD6             Prim[3];
    FD6             X;
    FD6             Y;
    FD6             Z;
    FD6             AU;
    FD6             BV;
    FD6             U1;
    FD6             V1;
    FD6             p0;
    FD6             p1;
    FD6             p2;
    FD6             C;
    FD6             W;
    FD6             AutoPrims[3];
    MULDIVPAIR      MDPairs[4];
    MULDIVPAIR      AUMDPairs[3];
    MULDIVPAIR      BVMDPairs[3];
    RGBORDER        RGBOrder;
    INT             TempI;
    INT             TempJ;
    BYTE            DataSet[8];

    DEFDBGVAR(WORD,  ClrNo)
    DEFDBGVAR(BYTE,  dbgR)
    DEFDBGVAR(BYTE,  dbgG)
    DEFDBGVAR(BYTE,  dbgB)

#define _SrcPrimType            DataSet[ 0]
#define _DevBytesPerPrimary     DataSet[ 1]
#define _DevBytesPerEntry       DataSet[ 2]
#define _ColorSpace             DataSet[ 3]
#define _fX                     p0
#define _fY                     p1
#define _fZ                     p2
#define _X15Y3Z                 C
#define _L13                    W

    SETDBGVAR(ClrNo, 0);

    if (pSrcClrTriad) {

        SrcClrTriad  = *pSrcClrTriad;

    } else {

        SrcClrTriad.Type               = COLOR_TYPE_RGB;
        SrcClrTriad.BytesPerPrimary    = 0;
        SrcClrTriad.BytesPerEntry      = 0;
        SrcClrTriad.PrimaryOrder       = PRIMARY_ORDER_RGB;
        SrcClrTriad.PrimaryValueMax    = 0xFF;
        SrcClrTriad.ColorTableEntries  = HT_RGB_CUBE_COUNT;
        SrcClrTriad.pColorTable        = (LPBYTE)&Prim[0];
    }

    if (SrcClrTriad.Type != COLOR_TYPE_RGB) {

        return(HTERR_INVALID_COLOR_TYPE);
    }

    //
    // Two possible cases:
    //
    //  A:  The transform is used for color adjustment only, this is for
    //      HT_AdjustColorTable API call
    //
    //  B:  The halftone is taking places, the final output will be either
    //      Prim1/2 or Prim1/2/3 and each primary must 1 byte long.
    //

    PrimAdjFlags = pDevClrAdj->PrimAdj.Flags;

    ASSERT((PrimAdjFlags & (DCA_HAS_SRC_GAMMA       |
                            DCA_HAS_DEST_GAMMA      |
                            DCA_HAS_BW_REF_ADJ      |
                            DCA_HAS_CONTRAST_ADJ    |
                            DCA_HAS_BRIGHTNESS_ADJ  |
                            DCA_LOG_FILTER          |
                            DCA_NEGATIVE            |
                            DCA_DO_DEVCLR_XFORM)) == 0);

    //
    // We will not do regression (source to destination mapping) for
    //
    //  1. ICM is ON
    //  2. Subtractive with 24bpp
    //  3. Additive surface.
    //

    if (pbgr) {

        _DevBytesPerEntry   = (BYTE)pDevClrAdj->DMI.CTSTDInfo.cbPrim;
        _DevBytesPerPrimary = 1;

        ASSERT(_DevBytesPerEntry == sizeof(BGR8));

    } else {

        return(HTERR_INVALID_COLOR_TYPE);
    }

    if (!(pSrcPrims = (LPBYTE)SrcClrTriad.pColorTable)) {

        return(HTERR_INVALID_COLOR_TABLE);
    }

    //
    // If the total color table entries is less than MIN_CCT_COLORS then
    // we just compute the color directly
    //

    pCRTX = NULL;

    DBGP_IF(DBGP_CCT,
            DBGP("PrimAdjFlags=%08lx" ARGDW(PrimAdjFlags)));

    if (SrcClrTriad.BytesPerPrimary) {

        //
        // Something passed
        //

        RGBOrder = SrcOrderTable[SrcClrTriad.PrimaryOrder];
        pPrimA   = &Prim[RGBOrder.Order[0]];
        pPrimB   = &Prim[RGBOrder.Order[1]];
        pPrimC   = &Prim[RGBOrder.Order[2]];

        DBGP_IF(DBGP_PRIMARY_ORDER,
                DBGP("SOURCE PrimaryOrder: %u [%u] - %u:%u:%u"
                    ARGU(SrcClrTriad.PrimaryOrder)
                    ARGU(RGBOrder.Index)  ARGU(RGBOrder.Order[0])
                    ARGU(RGBOrder.Order[1])  ARGU(RGBOrder.Order[2])));
    }

    //
    // Now compute the cache info
    //

    switch (SrcClrTriad.BytesPerPrimary) {

    case 0:

        SrcClrTriad.BytesPerEntry   = 0;        // stay there!!
        _SrcPrimType                = SRC_BF_HT_RGB;
        SrcClrTriad.PrimaryValueMax = HT_RGB_MAX_COUNT - 1;
        pCRTX                       = pDevClrAdj->pCRTXLevelRGB;

        break;

    case 1:

        _SrcPrimType = SRC_TABLE_BYTE;
        break;

    case 2:

        _SrcPrimType = SRC_TABLE_WORD;
        break;

    case 4:

        _SrcPrimType = SRC_TABLE_DWORD;
        break;

    default:

        return(INTERR_INVALID_SRCRGB_SIZE);
    }

    if (PrimAdjFlags & DCA_NEED_DYES_CORRECTION) {

        pCMYDyeMasks = &(pDevClrAdj->pClrXFormBlock->CMYDyeMasks);
    }

    _ColorSpace = (BYTE)pDevClrAdj->pClrXFormBlock->ColorSpace;

    if (((_ColorSpace == CIELUV_1976) &&
         ((pDevClrAdj->PrimAdj.rgbCSXForm.xW !=
                                pDevClrAdj->PrimAdj.DevCSXForm.xW)    ||
          (pDevClrAdj->PrimAdj.rgbCSXForm.yW !=
                                pDevClrAdj->PrimAdj.DevCSXForm.yW)))  ||
        (PrimAdjFlags & (DCA_HAS_CLRSPACE_ADJ   |
                         DCA_HAS_COLOR_ADJ      |
                         DCA_HAS_TINT_ADJ))) {

        TempI = 1;
        TempJ = (_ColorSpace == CIELUV_1976) ? MULDIV_HAS_DIVISOR :
                                               MULDIV_NO_DIVISOR;
        C     = FD6_1;
        AU    =
        BV    = (PrimAdjFlags & DCA_HAS_COLOR_ADJ) ?
                                pDevClrAdj->PrimAdj.Color : FD6_1;

        if (PrimAdjFlags & DCA_HAS_TINT_ADJ) {

            if (_ColorSpace == CIELAB_1976) {

                AU = FD6xL(AU, 500);
                BV = FD6xL(BV, 200);
            }

            TempI                  = 2;
            TempJ                  = MULDIV_HAS_DIVISOR;
            C                      = pDevClrAdj->PrimAdj.TintSinAngle;
            AUMDPairs[2].Pair1.Mul = MulFD6(BV, -C);
            BVMDPairs[2].Pair1.Mul = MulFD6(AU,  C);
            C                      = pDevClrAdj->PrimAdj.TintCosAngle;

            MAKE_MULDIV_DVSR(AUMDPairs, (FD6)500000000);
            MAKE_MULDIV_DVSR(BVMDPairs, (FD6)200000000);
        }

        AUMDPairs[1].Pair1.Mul = MulFD6(AU, C);
        BVMDPairs[1].Pair1.Mul = MulFD6(BV, C);

        MAKE_MULDIV_INFO(AUMDPairs, TempI, TempJ);
        MAKE_MULDIV_INFO(BVMDPairs, TempI, TempJ);
    }

    DBGP_IF(DBGP_SHOWXFORM_ALL,
            DBGP("iUVw = %s,%s, iRefXYZ = %s, %s, %s"
                ARGFD6(iUw,  1, 6)
                ARGFD6(iVw,  1, 6)
                ARGFD6(iRefXw, 1, 6)
                ARGFD6(iRefYw, 1, 6)
                ARGFD6(iRefZw, 1, 6)));

    DBGP_IF(DBGP_SHOWXFORM_ALL,
            DBGP("oUVw = %s,%s, oRefXYZ = %s, %s, %s"
                ARGFD6(oUw,  1, 6)
                ARGFD6(oVw,  1, 6)
                ARGFD6(oRefXw, 1, 6)
                ARGFD6(oRefYw, 1, 6)
                ARGFD6(oRefZw, 1, 6)));

    if (pCRTX) {

        DBGP_IF(DBGP_CCT,
                DBGP("*** Allocate %u bytes RGB->XYZ xform table ***"
                        ARGU(pCRTX->SizeCRTX)));

        if (pR_XYZ = (PFD6XYZ)HTAllocMem((LPVOID)pDCI,
                                         HTMEM_RGBToXYZ,
                                         NONZEROLPTR,
                                         pCRTX->SizeCRTX)) {

            Loop = (DWORD)(pCRTX->PrimMax + 1);

            //
            // Save current flags back before calling, since CachedRGBToXYZ
            // may change this flags for DCA_xxx
            //

            pCRTX                        = CacheRGBToXYZ(pCRTX,
                                                         pR_XYZ,
                                                         &CRTXChecksum,
                                                         pDevClrAdj);
            pG_XYZ                       = pR_XYZ + Loop;
            pB_XYZ                       = pG_XYZ + Loop;
            SrcClrTriad.PrimaryValueMax  = 0;

            DBGP_IF(DBGP_CCT, DBGP("*** Has RGB->XYZ xform table ***"));

        } else {

            DBGP_IF(DBGP_CCT, DBGP("Allocate RGB->XYZ xform table failed !!"));
        }
    }

    if (SrcClrTriad.PrimaryValueMax == (LONG)FD6_1) {

        SrcClrTriad.PrimaryValueMax = 0;
    }

    //
    // Starting the big Loop, reset AutoCur = AutoMax so it recycle back to
    // 0:0:0
    //

    MAKE_MULDIV_SIZE(MDPairs, 3);
    MAKE_MULDIV_FLAG(MDPairs, MULDIV_NO_DIVISOR);

    AutoPrims[0] =
    AutoPrims[1] =
    AutoPrims[2] = FD6_0;
    Loop         = SrcClrTriad.ColorTableEntries;

    DBGP_IF(DBGP_CCT,
            DBGP("Compute %ld COLOR of %s type [%p]"
                ARGDW(Loop)
                ARG(pSrcPrimTypeName[_SrcPrimType])
                ARGPTR(pSrcPrims)));

    //
    // 0. Get The source prim into the Prim[]
    //

    while (Loop--) {

        switch (_SrcPrimType) {

        case SRC_BF_HT_RGB:

            //
            // This format always in BGR order
            //

            Prim[0] = AutoPrims[0];     // R
            Prim[1] = AutoPrims[1];     // G
            Prim[2] = AutoPrims[2];     // B

            if (++AutoPrims[0] >= (FD6)HT_RGB_MAX_COUNT) {

                AutoPrims[0] = FD6_0;

                if (++AutoPrims[1] >= (FD6)HT_RGB_MAX_COUNT) {

                    AutoPrims[1] = FD6_0;

                    if (++AutoPrims[2] >= (FD6)HT_RGB_MAX_COUNT) {

                        AutoPrims[2] = FD6_0;
                    }
                }
            }

            DBGP_IF(DBGP_SHOWXFORM_ALL, DBGP("HT555: Prim[3]= %2ld:%2ld:%2ld, %s:%s:%s, (%ld / %ld)"
                        ARGDW(Prim[0])
                        ARGDW(Prim[1])
                        ARGDW(Prim[2])
                        ARGFD6(DivFD6(Prim[0], (FD6)(HT_RGB_MAX_COUNT - 1)), 1, 6)
                        ARGFD6(DivFD6(Prim[1], (FD6)(HT_RGB_MAX_COUNT - 1)), 1, 6)
                        ARGFD6(DivFD6(Prim[2], (FD6)(HT_RGB_MAX_COUNT - 1)), 1, 6)
                        ARGDW(HT_RGB_MAX_COUNT)
                        ARGDW(SrcClrTriad.PrimaryValueMax)));

            break;

        case SRC_TABLE_BYTE:

            *pPrimA = (FD6)(*(LPBYTE)(pSrcPrims                     ));
            *pPrimB = (FD6)(*(LPBYTE)(pSrcPrims + (sizeof(BYTE) * 1)));
            *pPrimC = (FD6)(*(LPBYTE)(pSrcPrims + (sizeof(BYTE) * 2)));
            break;

        case SRC_TABLE_WORD:

            *pPrimA = (FD6)(*(LPSHORT)(pSrcPrims                      ));
            *pPrimB = (FD6)(*(LPSHORT)(pSrcPrims + (sizeof(SHORT) * 1)));
            *pPrimC = (FD6)(*(LPSHORT)(pSrcPrims + (sizeof(SHORT) * 2)));
            break;

        case SRC_TABLE_DWORD:

            *pPrimA = (FD6)(*(PFD6)(pSrcPrims                    ));
            *pPrimB = (FD6)(*(PFD6)(pSrcPrims + (sizeof(FD6) * 1)));
            *pPrimC = (FD6)(*(PFD6)(pSrcPrims + (sizeof(FD6) * 2)));
            break;
        }

        SETDBGVAR(dbgR, (BYTE)Prim[0]);
        SETDBGVAR(dbgG, (BYTE)Prim[1]);
        SETDBGVAR(dbgB, (BYTE)Prim[2]);

        pSrcPrims += SrcClrTriad.BytesPerEntry;

        //
        // 1. First convert the Input value to FD6
        //

        if (SrcClrTriad.PrimaryValueMax) {

            Prim[0] = DivFD6(Prim[0], SrcClrTriad.PrimaryValueMax);
            Prim[1] = DivFD6(Prim[1], SrcClrTriad.PrimaryValueMax);
            Prim[2] = DivFD6(Prim[2], SrcClrTriad.PrimaryValueMax);
        }

        //
        // 2: Transform from RGB (gamma correction) -> XYZ -> L*A*B* or L*U*V*
        //    This only done if any of DCA_HAS_COLOR_ADJ or DCA_HAS_TINT_ADJ
        //

        if (PrimAdjFlags & (DCA_HAS_CLRSPACE_ADJ    |
                            DCA_HAS_COLOR_ADJ       |
                            DCA_HAS_TINT_ADJ)) {

            // If we only doing monochrome, then we only need Y/L pair only,
            // else convert it to the XYZ/LAB/LUV
            //

            if (pR_XYZ) {

                X = pR_XYZ[Prim[0]].X +
                    pG_XYZ[Prim[1]].X +
                    pB_XYZ[Prim[2]].X;

                Y = pR_XYZ[Prim[0]].Y +
                    pG_XYZ[Prim[1]].Y +
                    pB_XYZ[Prim[2]].Y;

                Z = pR_XYZ[Prim[0]].Z +
                    pG_XYZ[Prim[1]].Z +
                    pB_XYZ[Prim[2]].Z;

                DBGP_IF(DBGP_SHOWXFORM_ALL,
                        DBGP("Yrgb: %s:%s:%s"
                            ARGFD6(pR_XYZ[Prim[0]].Y, 1, 6)
                            ARGFD6(pG_XYZ[Prim[1]].Y, 1, 6)
                            ARGFD6(pB_XYZ[Prim[2]].Y, 1, 6)));


            } else {

                MAKE_MULDIV_FLAG(MDPairs, MULDIV_NO_DIVISOR);

                MAKE_MULDIV_PAIR(
                            MDPairs, 1,
                            CIE_Xr(pDevClrAdj->PrimAdj.rgbCSXForm.M3x3),
                            Prim[0]);
                MAKE_MULDIV_PAIR(
                            MDPairs, 2,
                            CIE_Xg(pDevClrAdj->PrimAdj.rgbCSXForm.M3x3),
                            Prim[1]);
                MAKE_MULDIV_PAIR(
                            MDPairs, 3,
                            CIE_Xb(pDevClrAdj->PrimAdj.rgbCSXForm.M3x3),
                            Prim[2]);

                X = MulDivFD6Pairs(MDPairs);

                //
                // Compute CIE L from CIE Y tristimulus value
                //
                // L* = (1.16 x f(Y/Yw)) - 0.16
                //
                //                 1/3
                //  f(Y/Yw) = (Y/Yw)                (Y/Yw) >  0.008856
                //  f(Y/Yw) = 9.033 x (Y/Yw)        (Y/Yw) <= 0.008856
                //
                //
                // Our L* is range from 0.0 to 1.0, not 0.0 to 100.0
                //

                MAKE_MULDIV_PAIR(
                            MDPairs, 1,
                            CIE_Yr(pDevClrAdj->PrimAdj.rgbCSXForm.M3x3),
                            Prim[0]);
                MAKE_MULDIV_PAIR(
                            MDPairs, 2,
                            CIE_Yg(pDevClrAdj->PrimAdj.rgbCSXForm.M3x3),
                            Prim[1]);
                MAKE_MULDIV_PAIR(
                            MDPairs, 3,
                            CIE_Yb(pDevClrAdj->PrimAdj.rgbCSXForm.M3x3),
                            Prim[2]);

                Y = MulDivFD6Pairs(MDPairs);

                MAKE_MULDIV_PAIR(
                            MDPairs, 1,
                            CIE_Zr(pDevClrAdj->PrimAdj.rgbCSXForm.M3x3),
                            Prim[0]);
                MAKE_MULDIV_PAIR(
                            MDPairs, 2,
                            CIE_Zg(pDevClrAdj->PrimAdj.rgbCSXForm.M3x3),
                            Prim[1]);
                MAKE_MULDIV_PAIR(
                            MDPairs, 3,
                            CIE_Zb(pDevClrAdj->PrimAdj.rgbCSXForm.M3x3),
                            Prim[2]);

                Z = MulDivFD6Pairs(MDPairs);

            }

            switch (_ColorSpace) {

            case CIELUV_1976:

                //
                // U' = 4X / (X + 15Y + 3Z)
                // V' = 9Y / (X + 15Y + 3Z)
                //
                // U* = 13 x L x (U' - Uw)
                // V* = 13 x L x (V' - Vw)
                //

                _X15Y3Z = X + FD6xL(Y, 15) + FD6xL(Z, 3);
                U1      = DivFD6(FD6xL(X, 4), _X15Y3Z) - iUw;
                V1      = DivFD6(FD6xL(Y, 9), _X15Y3Z) - iVw;
                _L13    = FD6xL(CIE_I2L(Y), 13);
                AU      = MulFD6(_L13, U1);
                BV      = MulFD6(_L13, V1);

                MAKE_MULDIV_DVSR(AUMDPairs, _L13);
                MAKE_MULDIV_DVSR(BVMDPairs, _L13);

                DBGP_IF(DBGP_SHOWXFORM_ALL,
                        DBGP("     << UV1: %s:%s [%s:%s], X15Y3Z=%s"
                        ARGFD6(U1,  2, 6)
                        ARGFD6(V1,  2, 6)
                        ARGFD6(U1 + iUw, 2, 6)
                        ARGFD6(V1 + iVw, 2, 6)
                        ARGFD6(_X15Y3Z,  2, 6)));

                break;

            case CIELAB_1976:
            default:

                //
                // CIELAB 1976 L*A*B*
                //
                //  A* = 500 x (fX - fY)
                //  B* = 200 x (fY - fZ)
                //
                //             1/3
                //  fX = (X/Xw)                     (X/Xw) >  0.008856
                //  fX = 7.787 x (X/Xw) + (16/116)  (X/Xw) <= 0.008856
                //
                //             1/3
                //  fY = (Y/Yw)                     (Y/Yw) >  0.008856
                //  fY = 7.787 Y (Y/Yw) + (16/116)  (Y/Yw) <= 0.008856
                //
                //             1/3
                //  fZ = (Z/Zw)                     (Z/Zw) >  0.008856
                //  fZ = 7.787 Z (Z/Zw) + (16/116)  (Z/Zw) <= 0.008856
                //

                fXYZFromXYZ(_fX, X, iRefXw);
                fXYZFromXYZ(_fY, Y, FD6_1);
                fXYZFromXYZ(_fZ, Z, iRefZw);

                DBGP_IF(DBGP_SHOWXFORM_ALL,
                        DBGP("     >> fXYZ: %s:%s:%s"
                        ARGFD6(_fX,  2, 6)
                        ARGFD6(_fY,  2, 6)
                        ARGFD6(_fZ,  2, 6)));

                AU = _fX - _fY;
                BV = _fY - _fZ;

                //
                // DO NOT Translate it now
                //

                if ((AU >= (FD6)-20) && (AU <= (FD6)20) &&
                    (BV >= (FD6)-20) && (BV <= (FD6)20)) {

                    DBGP_IF(DBGP_MONO_PRIM,
                            DBGP("*** MONO PRIMS: %s:%s:%s --> Y=%s"
                                    ARGFD6(DivFD6(dbgR, 255), 1, 6)
                                    ARGFD6(DivFD6(dbgG, 255), 1, 6)
                                    ARGFD6(DivFD6(dbgB, 255), 1, 6)
                                    ARGFD6(Y, 1, 6)));
                }

                break;
            }

            DBGP_IF(DBGP_SHOWXFORM_ALL,
                    DBGP("     XYZ->%s: %s:%s:%s >> L:%s:%s"
                        ARG(pDbgCSName[_ColorSpace])
                        ARGFD6(X,  2, 6)
                        ARGFD6(Y,  1, 6)
                        ARGFD6(Z,  2, 6)
                        ARGFD6(AU, 4, 6)
                        ARGFD6(BV, 4, 6)));

            //
            // 5: Do any Color Adjustments (in LAB/LUV)
            //

            AUMDPairs[1].Pair2 =
            BVMDPairs[2].Pair2 = AU;
            AUMDPairs[2].Pair2 =
            BVMDPairs[1].Pair2 = BV;

            AU = MulDivFD6Pairs(AUMDPairs);
            BV = MulDivFD6Pairs(BVMDPairs);

            //
            // 6: Transform From LAB/LUV->XYZ->RGB with possible gamma
            //    correction
            //
            // L* = (1.16 x f(Y/Yw)) - 0.16
            //
            //                 1/3
            //  f(Y/Yw) = (Y/Yw)                (Y/Yw) >  0.008856
            //  f(Y/Yw) = 9.033 x (Y/Yw)        (Y/Yw) <= 0.008856
            //

            switch (_ColorSpace) {

            case CIELUV_1976:

                //
                // U' = 4X / (X + 15Y + 3Z)
                // V' = 9Y / (X + 15Y + 3Z)
                //
                // U* = 13 x L x (U' - Uw)
                // V* = 13 x L x (V' - Vw)
                //

                if (((V1 = BV + oVw) < FD6_0) ||
                    ((_X15Y3Z = DivFD6(FD6xL(Y, 9), V1)) < FD6_0)) {

                    _X15Y3Z = (FD6)2147000000;
                }

                if ((U1 = AU + oUw) < FD6_0) {

                    X  =
                    U1 = FD6_0;

                } else {

                    X = FD6DivL(MulFD6(_X15Y3Z, U1), 4);
                }

                Z = FD6DivL(_X15Y3Z - X - FD6xL(Y, 15), 3);

                DBGP_IF(DBGP_SHOWXFORM_ALL,
                        DBGP("     >> UV1: %s:%s [%s:%s], X15Y3Z=%s"
                        ARGFD6(U1 - oUw,  2, 6)
                        ARGFD6(V1 - oVw,  2, 6)
                        ARGFD6(U1, 2, 6)
                        ARGFD6(V1, 2, 6)
                        ARGFD6(_X15Y3Z,  2, 6)));

                break;

            case CIELAB_1976:
            default:

                //
                // CIELAB 1976 L*A*B*
                //
                //  A* = 500 x (fX - fY)
                //  B* = 200 x (fY - fZ)
                //
                //             1/3
                //  fX = (X/Xw)                     (X/Xw) >  0.008856
                //  fX = 7.787 x (X/Xw) + (16/116)  (X/Xw) <= 0.008856
                //
                //             1/3
                //  fY = (Y/Yw)                     (Y/Yw) >  0.008856
                //  fY = 7.787 Y (Y/Yw) + (16/116)  (Y/Yw) <= 0.008856
                //
                //             1/3
                //  fZ = (Z/Zw)                     (Z/Zw) >  0.008856
                //  fZ = 7.787 Z (Z/Zw) + (16/116)  (Z/Zw) <= 0.008856
                //

                // _fX = FD6DivL(AU, 500) + _fY;
                // _fZ = _fY - FD6DivL(BV, 200);

                _fX = AU + _fY;
                _fZ = _fY - BV;

                XYZFromfXYZ(X, _fX, oRefXw);
                XYZFromfXYZ(Z, _fZ, oRefZw);

                DBGP_IF(DBGP_SHOWXFORM_ALL,
                        DBGP("     << fXYZ: %s:%s:%s"
                        ARGFD6(_fX,  2, 6)
                        ARGFD6(_fY,  2, 6)
                        ARGFD6(_fZ,  2, 6)));



                break;
            }

            DBGP_IF(DBGP_SHOWXFORM_ALL,
                DBGP("     %s->XYZ: %s:%s:%s << L:%s:%s"
                ARG(pDbgCSName[_ColorSpace])
                ARGFD6(X,  2, 6)
                ARGFD6(Y,  1, 6)
                ARGFD6(Z,  2, 6)
                ARGFD6(AU, 4, 6)
                ARGFD6(BV, 4, 6)));

            MAKE_MULDIV_FLAG(MDPairs, MULDIV_NO_DIVISOR);

            MAKE_MULDIV_PAIR(MDPairs, 1,
                        CIE_Xr(pDevClrAdj->PrimAdj.DevCSXForm.M3x3), X);
            MAKE_MULDIV_PAIR(MDPairs, 2,
                        CIE_Xg(pDevClrAdj->PrimAdj.DevCSXForm.M3x3), Y);
            MAKE_MULDIV_PAIR(MDPairs, 3,
                        CIE_Xb(pDevClrAdj->PrimAdj.DevCSXForm.M3x3), Z);

            Prim[0] = MulDivFD6Pairs(MDPairs);

            MAKE_MULDIV_PAIR(MDPairs, 1,
                        CIE_Yr(pDevClrAdj->PrimAdj.DevCSXForm.M3x3), X);
            MAKE_MULDIV_PAIR(MDPairs, 2,
                        CIE_Yg(pDevClrAdj->PrimAdj.DevCSXForm.M3x3), Y);
            MAKE_MULDIV_PAIR(MDPairs, 3,
                        CIE_Yb(pDevClrAdj->PrimAdj.DevCSXForm.M3x3), Z);

            Prim[1] = MulDivFD6Pairs(MDPairs);

            MAKE_MULDIV_PAIR(MDPairs, 1,
                        CIE_Zr(pDevClrAdj->PrimAdj.DevCSXForm.M3x3), X);
            MAKE_MULDIV_PAIR(MDPairs, 2,
                        CIE_Zg(pDevClrAdj->PrimAdj.DevCSXForm.M3x3), Y);
            MAKE_MULDIV_PAIR(MDPairs, 3,
                        CIE_Zb(pDevClrAdj->PrimAdj.DevCSXForm.M3x3), Z);

            Prim[2] = MulDivFD6Pairs(MDPairs);

            //
            // Make sure everthing is in the range
            //

            SCALE_PRIM_RGB(Prim, NULL);

            DBGP_IF(DBGP_SHOWXFORM_ALL,
                    DBGP("     XYZ->RGB: %s:%s:%s >> %s:%s:%s"
                        ARGFD6(X,  2, 6) ARGFD6(Y,  1, 6)
                        ARGFD6(Z,  2, 6) ARGFD6(Prim[0], 1, 6)
                        ARGFD6(Prim[1], 1, 6) ARGFD6(Prim[2], 1, 6)));
        }

        //
        // 3: Dye correction if necessary
        //

        if (PrimAdjFlags & DCA_NEED_DYES_CORRECTION) {

            if (PrimAdjFlags & DCA_HAS_BLACK_DYE) {

                MAX_OF_3(W, Prim[0], Prim[1], Prim[2]);

            } else {

                W = FD6_1;
            }

            p0 = W - Prim[0];
            p1 = W - Prim[1];
            p2 = W - Prim[2];

            DBGP_IF(DBGP_DYE_CORRECT,
                    DBGP("    DYE_CORRECT: %s:%s:%s, W=%s --> %s:%s:%s"
                        ARGFD6(Prim[0],  2, 6) ARGFD6(Prim[1],  2, 6)
                        ARGFD6(Prim[2],  2, 6) ARGFD6(W, 1, 6)
                        ARGFD6(p0,  2, 6) ARGFD6(p1,  2, 6)
                        ARGFD6(p2,  2, 6)));

            MAKE_MULDIV_FLAG(MDPairs, MULDIV_NO_DIVISOR);

            MAKE_MULDIV_PAIR(MDPairs, 1, CIE_Xr((*pCMYDyeMasks)), p0);
            MAKE_MULDIV_PAIR(MDPairs, 2, CIE_Xg((*pCMYDyeMasks)), p1);
            MAKE_MULDIV_PAIR(MDPairs, 3, CIE_Xb((*pCMYDyeMasks)), p2);

            Prim[0] = W - MulDivFD6Pairs(MDPairs);

            MAKE_MULDIV_PAIR(MDPairs, 1, CIE_Yr((*pCMYDyeMasks)), p0);
            MAKE_MULDIV_PAIR(MDPairs, 2, CIE_Yg((*pCMYDyeMasks)), p1);
            MAKE_MULDIV_PAIR(MDPairs, 3, CIE_Yb((*pCMYDyeMasks)), p2);

            Prim[1] = W - MulDivFD6Pairs(MDPairs);

            MAKE_MULDIV_PAIR(MDPairs, 1, CIE_Zr((*pCMYDyeMasks)), p0);
            MAKE_MULDIV_PAIR(MDPairs, 2, CIE_Zg((*pCMYDyeMasks)), p1);
            MAKE_MULDIV_PAIR(MDPairs, 3, CIE_Zb((*pCMYDyeMasks)), p2);

            Prim[2] = W - MulDivFD6Pairs(MDPairs);

            DBGP_IF(DBGP_DYE_CORRECT,
                    DBGP("    DYE_CORRECT: %s:%s:%s << %s:%s:%s"
                        ARGFD6(Prim[0],  2, 6) ARGFD6(Prim[1],  2, 6)
                        ARGFD6(Prim[2],  2, 6) ARGFD6(p0,  2, 6)
                        ARGFD6(p1,  2, 6)      ARGFD6(p2,  2, 6)));

            CLAMP_01(Prim[0]);
            CLAMP_01(Prim[1]);
            CLAMP_01(Prim[2]);
        }

        //*******************************************************************
        //
        // 4: Compute Final Device DYE through device color mapping and
        //    Primary/Halftone Cell number computation, The Primaries (ie.
        //    Prim[]) are in ADDITIVE FORMAT
        //
        //*******************************************************************

        //
        // Store in BGRF in this order
        //

        (pbgr  )->r = (BYTE)MulFD6(Prim[0], 0xFF);
        (pbgr  )->g = (BYTE)MulFD6(Prim[1], 0xFF);
        (pbgr++)->b = (BYTE)MulFD6(Prim[2], 0xFF);

        DBGP_IF(DBGP_SHOWXFORM_ALL,
                DBGP("    MAPPING(%3ld:%3ld:%3ld): %s:%s:%s ---> %3ld:%3ld:%3ld"
                    ARGDW(dbgR) ARGDW(dbgG) ARGDW(dbgB)
                    ARGFD6(Prim[0],  2, 6) ARGFD6(Prim[1],  2, 6)
                    ARGFD6(Prim[2],  2, 6) ARGDW((pbgr - 1)->r)
                    ARGDW((pbgr - 1)->g) ARGDW((pbgr - 1)->b)));
    }

    if ((pR_XYZ) && (pCRTX)) {

        if (!pCRTX->pFD6XYZ) {

            DBGP_IF(DBGP_CCT,
                    DBGP("CCT: Allocate %ld bytes RGB->XYZ xform cached table"
                            ARGDW(pCRTX->SizeCRTX)));

            if (!(pCRTX->pFD6XYZ =
                    (PFD6XYZ)HTAllocMem((LPVOID)pDCI,
                                        HTMEM_CacheCRTX,
                                        NONZEROLPTR,
                                        pCRTX->SizeCRTX))) {

                DBGP_IF(DBGP_CCT,
                        DBGP("Allocate %ld bytes of RGB->XYZ cached table failed"
                                ARGDW(pCRTX->SizeCRTX)));
            }
        }

        if (pCRTX->pFD6XYZ) {

            DBGP_IF(DBGP_CCT,
                    DBGP("CCT: *** Save computed RGB->XYZ xform to CACHE ***"));

            pCRTX->Checksum = CRTXChecksum;

            CopyMemory(pCRTX->pFD6XYZ, pR_XYZ, pCRTX->SizeCRTX);
        }
    }

    if (pR_XYZ) {

        DBGP_IF(DBGP_CCT,
                DBGP("ColorTriadSrcToDev: Free Up pR_XYZ local cached table"));

        HTFreeMem(pR_XYZ);
    }

    return((LONG)SrcClrTriad.ColorTableEntries);


#undef _SrcPrimType
#undef _DevBytesPerPrimary
#undef _DevBytesPerEntry
#undef _ColorSpace
#undef _fX
#undef _fY
#undef _fZ
#undef _X15Y3Z
#undef _L13

}


#if DBG


VOID
ShowBGRMC(
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    06-Oct-2000 Fri 17:01:25 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LONG    i;

    ACQUIRE_HTMUTEX(HTGlobal.HTMutexBGRMC);

    i = HTGlobal.cBGRMC;

    DBGP_IF(DBGP_BGRMAPTABLE, DBGP("\n================"));

    while (i-- > 0) {

        DBGP_IF(DBGP_BGRMAPTABLE,
                DBGP("    --- %3ld: pMap=%p, Checksum=%08lx, cRef=%4ld"
                    ARGDW(i)
                    ARGPTR(HTGlobal.pBGRMC[i].pMap)
                    ARGDW(HTGlobal.pBGRMC[i].Checksum)
                    ARGDW(HTGlobal.pBGRMC[i].cRef)));
    }

    DBGP_IF(DBGP_BGRMAPTABLE, DBGP("================\n"));

    RELEASE_HTMUTEX(HTGlobal.HTMutexBGRMC);
}


    #if 1
        #define SHOW_BGRMC()
    #else
        #define SHOW_BGRMC()    ShowBGRMC()
    #endif
#else
    #define SHOW_BGRMC()
#endif



LONG
TrimBGRMapCache(
    VOID
    )

/*++

Routine Description:

    This function trim the BGRMAPCache back to BGRMC_MAX_COUNT if possible

Arguments:

    VOID


Return Value:

    Total count that removed


Author:

    06-Oct-2000 Fri 14:24:14 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PBGRMAPCACHE    pSave;
    PBGRMAPCACHE    pCur;
    LONG            cb;
    LONG            Count;
    LONG            cTot;


    ACQUIRE_HTMUTEX(HTGlobal.HTMutexBGRMC);

    if ((HTGlobal.cBGRMC > BGRMC_MAX_COUNT) && (HTGlobal.cIdleBGRMC)) {

        pSave   =
        pCur    = HTGlobal.pBGRMC;
        cTot    =
        Count   = HTGlobal.cBGRMC;

        while ((cTot--) && (HTGlobal.cBGRMC > BGRMC_MAX_COUNT)) {

            if (pCur->cRef == 0) {

                DBGP_IF(DBGP_BGRMAPTABLE,
                        DBGP("Remove %ld, pMap=%p"
                            ARGDW((DWORD)(pCur - HTGlobal.pBGRMC))
                            ARGPTR(pCur->pMap)));

                HTFreeMem(pCur->pMap);

                --HTGlobal.cBGRMC;
                --HTGlobal.cIdleBGRMC;

            } else {

                if (pSave != pCur) {

                    *pSave = *pCur;
                }

                ++pSave;
            }

            ++pCur;
        }

        DBGP_IF(DBGP_BGRMAPTABLE,
            DBGP("pSave=%p, pCur=%p, (%ld), [%ld / %ld]"
                ARGPTR(pSave) ARGPTR(pCur) ARGDW((DWORD)(pCur - pSave))
                ARGDW((DWORD)(&HTGlobal.pBGRMC[Count] - pCur))
                ARGDW((DWORD)((LPBYTE)&HTGlobal.pBGRMC[Count] - (LPBYTE)pCur))));

        if (Count != HTGlobal.cBGRMC) {

            if ((pCur > pSave)  &&
                ((cb = (LONG)((LPBYTE)&HTGlobal.pBGRMC[Count] -
                              (LPBYTE)pCur)) > 0)) {

                CopyMemory(pSave, pCur, cb);
            }

            Count -= HTGlobal.cBGRMC;

            DBGP_IF(DBGP_BGRMAPTABLE,
                    DBGP("TriBGRMapCache=%ld" ARGDW(Count)));

        } else {

            DBGP_IF(DBGP_BGRMAPTABLE, DBGP("!!!! TriBGRMapCache=0"));
        }
    }

    DBGP_IF(DBGP_BGRMAPTABLE,
            DBGP("  TTrimBGRMapCache: pBGRMC=%p, cBGRMC=%ld, cIdleBGRMC=%ld, cAllocBGRMC=%ld"
                        ARGPTR(HTGlobal.pBGRMC) ARGDW(HTGlobal.cBGRMC)
                        ARGDW(HTGlobal.cIdleBGRMC) ARGDW(HTGlobal.cAllocBGRMC)));

    RELEASE_HTMUTEX(HTGlobal.HTMutexBGRMC);

    ASSERT(HTGlobal.cBGRMC >= 0);
    ASSERT(HTGlobal.cIdleBGRMC <= HTGlobal.cBGRMC);
    ASSERT(HTGlobal.cIdleBGRMC >= 0);

    SHOW_BGRMC();

    return(Count);
}



PBGR8
FindBGRMapCache(
    PBGR8   pDeRefMap,
    DWORD   Checksum
    )

/*++

Routine Description:

    This function found a BGRMapCache with same checksum and move that
    link to the begining.


Arguments:

    pDeRefMap   - Find pMap for deference (NULL if not)

    Checksum    - Find checksum (only if pDeRefMap == NULL


Return Value:

    PBGR8   - The map that found


Author:

    06-Oct-2000 Fri 13:30:14 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LONG    Count;
    PBGR8   pRet = NULL;


    ACQUIRE_HTMUTEX(HTGlobal.HTMutexBGRMC);

    if ((HTGlobal.pBGRMC) && (Count = HTGlobal.cBGRMC)) {

        PBGRMAPCACHE    pCur = &HTGlobal.pBGRMC[Count - 1];

        while ((Count) && (!pRet)) {

            if (pDeRefMap == pCur->pMap) {

                ASSERT(pCur->cRef);

                pRet = pDeRefMap;

                if (pCur->cRef) {

                    if (--pCur->cRef == 0) {

                        ++HTGlobal.cIdleBGRMC;
                    }
                }

            } else if (pCur->Checksum == Checksum) {

                DBGP_IF(DBGP_BGRMAPTABLE,
                    DBGP("find Cached %08lx = %p at Index %ld, cRef=%ld"
                            ARGDW(Checksum) ARGPTR(pCur->pMap)
                            ARGDW((DWORD)(pCur - HTGlobal.pBGRMC))
                            ARGDW(pCur->cRef)));

                pRet = pCur->pMap;

                if (pCur->cRef++ == 0) {

                    --HTGlobal.cIdleBGRMC;
                }

                //
                // Move this reference to the end of the list as most recent
                //

                if (Count < HTGlobal.cBGRMC) {

                    BGRMAPCACHE BGRMC = *pCur;

                    CopyMemory(pCur,
                               pCur + 1,
                               (HTGlobal.cBGRMC - Count) * sizeof(BGRMAPCACHE));

                    HTGlobal.pBGRMC[HTGlobal.cBGRMC - 1] = BGRMC;
                }
            }

            --Count;
            --pCur;
        }
    }

    if ((pDeRefMap) && (!pRet)) {

        DBGP_IF(DBGP_BGRMAPTABLE,
                DBGP("Cannot find the pMap=%p that to be DeReference"
                            ARGPTR(pDeRefMap)));
    }

    DBGP_IF(DBGP_BGRMAPTABLE,
                DBGP("%s_BGRMapCache(%p, %08lx): pBGRMC=%p, cBGRMC=%ld, cIdleBGRMC=%ld, cAllocBGRMC=%ld"
                        ARGPTR((pDeRefMap) ? "DEREF" : " FIND")
                        ARGPTR(pDeRefMap) ARGDW(Checksum)
                        ARGPTR(HTGlobal.pBGRMC) ARGDW(HTGlobal.cBGRMC)
                        ARGDW(HTGlobal.cIdleBGRMC) ARGDW(HTGlobal.cAllocBGRMC)));

    if ((HTGlobal.cBGRMC > BGRMC_MAX_COUNT) && (HTGlobal.cIdleBGRMC)) {

        TrimBGRMapCache();
    }

    RELEASE_HTMUTEX(HTGlobal.HTMutexBGRMC);

    ASSERT(HTGlobal.cBGRMC >= 0);
    ASSERT(HTGlobal.cIdleBGRMC <= HTGlobal.cBGRMC);
    ASSERT(HTGlobal.cIdleBGRMC >= 0);

    SHOW_BGRMC();

    return(pRet);
}




BOOL
AddBGRMapCache(
    PBGR8   pMap,
    DWORD   Checksum
    )

/*++

Routine Description:

    Add pMap with Checksum to the cache table


Arguments:




Return Value:




Author:

    06-Oct-2000 Fri 13:29:52 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PBGRMAPCACHE    pBGRMC;
    LONG            cAlloc;
    BOOL            bRet = TRUE;


    ACQUIRE_HTMUTEX(HTGlobal.HTMutexBGRMC);

    if ((HTGlobal.cBGRMC > BGRMC_MAX_COUNT) && (HTGlobal.cIdleBGRMC)) {

        TrimBGRMapCache();
    }

    ASSERT(HTGlobal.cBGRMC <= HTGlobal.cAllocBGRMC);

    if (HTGlobal.cBGRMC >= (cAlloc = HTGlobal.cAllocBGRMC)) {

        DBGP_IF(DBGP_BGRMAPTABLE,
                    DBGP("AddBGRMapCache() Increase cAllocBGRMC %ld to %ld"
                            ARGDW(HTGlobal.cAllocBGRMC)
                            ARGDW(HTGlobal.cAllocBGRMC + BGRMC_SIZE_INC)));

        cAlloc += BGRMC_SIZE_INC;

        if (pBGRMC = (PBGRMAPCACHE)HTAllocMem((LPVOID)NULL,
                                              HTMEM_BGRMC_CACHE,
                                              LPTR,
                                              cAlloc * sizeof(BGRMAPCACHE))) {

            if (HTGlobal.pBGRMC) {

                CopyMemory(pBGRMC,
                           HTGlobal.pBGRMC,
                           HTGlobal.cBGRMC * sizeof(BGRMAPCACHE));

                HTFreeMem(HTGlobal.pBGRMC);
            }

            HTGlobal.pBGRMC      = pBGRMC;
            HTGlobal.cAllocBGRMC = cAlloc;

        } else {

            DBGP_IF(DBGP_BGRMAPTABLE,
                    DBGP("AddBGRMapCache() Allocation %ld bytes of Memory Failed"
                        ARGDW(HTGlobal.cAllocBGRMC * sizeof(BGRMAPCACHE))));
        }
    }

    if ((HTGlobal.pBGRMC) &&
        (HTGlobal.cBGRMC < HTGlobal.cAllocBGRMC)) {

        pBGRMC           = &HTGlobal.pBGRMC[HTGlobal.cBGRMC++];
        pBGRMC->pMap     = pMap;
        pBGRMC->Checksum = Checksum;
        pBGRMC->cRef     = 1;

        DBGP_IF(DBGP_BGRMAPTABLE,
                    DBGP(" AddBGRMapCache() Added %p (%08lx) to Cache"
                            ARGPTR(pMap) ARGDW(Checksum)));

    } else {

        bRet = FALSE;
    }

    DBGP_IF(DBGP_BGRMAPTABLE,
                DBGP("   AddBGRMapCache: pBGRMC=%p, cBGRMC=%ld, cIdleBGRMC=%ld, cAllocBGRMC=%ld"
                        ARGPTR(HTGlobal.pBGRMC) ARGDW(HTGlobal.cBGRMC)
                        ARGDW(HTGlobal.cIdleBGRMC) ARGDW(HTGlobal.cAllocBGRMC)));

    RELEASE_HTMUTEX(HTGlobal.HTMutexBGRMC);

    ASSERT(HTGlobal.cBGRMC >= 0);
    ASSERT(HTGlobal.cIdleBGRMC <= HTGlobal.cBGRMC);
    ASSERT(HTGlobal.cIdleBGRMC >= 0);

    SHOW_BGRMC();

    return(bRet);
}




LONG
HTENTRY
CreateDyesColorMappingTable(
    PHALFTONERENDER pHR
    )

/*++

Routine Description:

    this function allocate the memory for the dyes color mapping table depends
    on the source surface type information, it then go throug the color table
    and calculate dye densities for each RGB color in the color table.


Arguments:

    pHalftoneRender - Pointer to the HALFTONERENDER data structure.

Return Value:

    a negative return value indicate failue.



    HTERR_INVALID_SRC_FORMAT        - Invalid source surface format, this
                                      function only recongnized 1/4/8/24 bits
                                      per pel source surfaces.

    HTERR_COLORTABLE_TOO_BIG        - can not create the color table to map
                                      the colors to the dyes' densities.

    HTERR_INSUFFICIENT_MEMORY       - not enough memory for the pattern.

    HTERR_INTERNAL_ERRORS_START     - any other negative number indicate
                                      halftone internal failure.

    else                            - size of the color table entries created.


Author:

    29-Jan-1991 Tue 11:13:02 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    PAAHEADER           pAAHdr;
    PDEVICECOLORINFO    pDCI;
    PDEVCLRADJ          pDevClrAdj;
    CTSTD_UNION         CTSTDUnion;
    LONG                Result;


    pDCI                               = pHR->pDeviceColorInfo;
    pDevClrAdj                         = pHR->pDevClrAdj;
    pAAHdr                             = (PAAHEADER)pHR->pAAHdr;
    CTSTDUnion.b                       = pDevClrAdj->DMI.CTSTDInfo;
    CTSTDUnion.b.SrcOrder              =
    pDevClrAdj->DMI.CTSTDInfo.SrcOrder = PRIMARY_ORDER_BGR;

    //
    // Make sure these call are semaphore protected
    //

    ComputeRGBLUTAA(pDCI, pDevClrAdj, &(pDCI->rgbLUT));

    if (!(pDevClrAdj->PrimAdj.Flags & DCA_NO_MAPPING_TABLE)) {

        PBGR8   pBGRMap;
        PBGR8   pNewMap = NULL;
        DWORD   Checksum;


        ASSERT(CTSTDUnion.b.cbPrim == sizeof(BGR8));
        ASSERT(pAAHdr->Flags & AAHF_DO_CLR_MAPPING);


        //
        // Compute checksum for all necessary component that computing it
        //  1. rgbCSXForm (which is sRGB constant in GDI implementation)
        //  2. DevCSXForm
        //  3. ColorAdjustment (illum, colorfulness, tint)
        //

        Checksum = ComputeChecksum((LPBYTE)&pDevClrAdj->PrimAdj.rgbCSXForm,
                                   0x12345678,
                                   sizeof(COLORSPACEXFORM));

        Checksum = ComputeChecksum((LPBYTE)&pDevClrAdj->PrimAdj.DevCSXForm,
                                   Checksum,
                                   sizeof(COLORSPACEXFORM));

        Checksum = ComputeChecksum((LPBYTE)&(pDevClrAdj->ca),
                                   Checksum,
                                   sizeof(pDevClrAdj->ca));

        if (!(pBGRMap = FIND_BGRMAPCACHE(Checksum))) {

            DBGP_IF(DBGP_BGRMAPTABLE,
                    DBGP("*** No CACHE: Alloc %ld bytes of CACHE pBGRMap ***"
                                ARGDW(SIZE_BGR_MAPPING_TABLE)));

            if (!(pBGRMap =
                  pNewMap = (PBGR8)HTAllocMem((LPVOID)NULL,
                                              HTMEM_BGRMC_MAP,
                                              NONZEROLPTR,
                                              SIZE_BGR_MAPPING_TABLE))) {

                DBGP_IF(DBGP_BGRMAPTABLE,
                        DBGP("\n*** FAILED Alloc %ld bytes of pBGRMap ***\n"));

                return((LONG)HTERR_INSUFFICIENT_MEMORY);
            }
        }

        if (pNewMap) {

            DBGP_IF(DBGP_BGRMAPTABLE,
                    DBGP("Cached map Checksum (%08lx) not found, compute Re-Compute RGB555"
                        ARGDW(Checksum)));

            if ((Result = ComputeBGRMappingTable(pDCI,
                                                 pDevClrAdj,
                                                 NULL,
                                                 pNewMap)) ==
                                                        HT_RGB_CUBE_COUNT) {

                if (!(AddBGRMapCache(pNewMap, Checksum))) {

                    DBGP_IF(DBGP_BGRMAPTABLE,
                            DBGP("Adding BGRMapCache failed, Free pNewMap=%p"
                                    ARGPTR(pNewMap)));

                    HTFreeMem(pNewMap);

                    return((LONG)HTERR_INSUFFICIENT_MEMORY);
                }

            } else {

                DBGP_IF(DBGP_BGRMAPTABLE,
                        DBGP("ColorTriadSrcTodev() Failed, Result=%ld"
                            ARGDW(Result)));

                return(INTERR_INVALID_DEVRGB_SIZE);
            }
        }

        pAAHdr->pBGRMapTable = pBGRMap;
    }

    Result = CachedHalftonePattern(pDCI,
                                   pDevClrAdj,
                                   &(pAAHdr->AAPI),
                                   pAAHdr->ptlBrushOrg.x,
                                   pAAHdr->ptlBrushOrg.y,
                                   (BOOL)(pAAHdr->Flags & AAHF_FLIP_Y));

    return(Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htmath.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htmath.c


Abstract:

    This module contains the basic math. functions for the halftone
    process.

Author:

    16-Jan-1991 Wed 10:51:27 created  -by-  Daniel Chou (danielc)

[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:

    02-Feb-1994 Wed 18:08:13 updated  -by-  Daniel Chou (danielc)
        Remove unary unsigned wranings.



--*/

#define DBGP_VARNAME        dbgpHTMath



#define HAS_80x86_EQUIVALENT_CODES

#include "htp.h"
#include "htmath.h"


#define DBGP_MAPPING        0x0001
#define DBGP_CONCAT_M       0x0002

DEF_DBGPVAR(BIT_IF(DBGP_CONCAT_M,   0)  |
            BIT_IF(DBGP_MAPPING,    0))



#if DBG
LPBYTE  pDbgRegMode[] = { "LINEAR", "LOG", "EXP", "POWER" };
#endif


//
// Local definitions only used in this file
//

#define ABSFD6(a)           (FD6)(((a) < 0L) ? -(a) : (a))
#define SWAPFD6(a, b, t)    (t)=(a); (a)=(b); (b)=(t)
#define U16_H_U32(a)        (WORD)((DWORD)(a) >> 16)
#define U16_L_U32(a)        (WORD)((DWORD)(a) & 0xffffL)
#define FD6_LOG_MIN         -FD6_6
#define FD6_LOG_MAX         (FD6)3331930L
#define FD6ToL(n)           (LONG)(n)
#define FD6FromL(n)         (FD6)(n)

#define NEGDW(x)            (DWORD)(-(LONG)(x))
#define MIN_FD6             (FD6)-(LONG)2147483648
#define MAX_FD6             (FD6)(LONG)2147483647



//
// MANTISSATABLE
//
//  This is the look up table for the mantissa portion of the log number, the
//  table range from 1.00 to 10.00 at increment of 0.01 for the look up
//  numbers.  If the requested number has lies between two look up numbers
//  then an interpolation is done using those two look up numbers.
//

#define MANTISSATABLE_SIZE          901


FD6 MantissaTable[MANTISSATABLE_SIZE] = {

    (FD6)0,      (FD6)4321,     //  1.00 - 1.01
    (FD6)8600,   (FD6)12837,    //  1.02 - 1.03
    (FD6)17033,  (FD6)21189,    //  1.04 - 1.05
    (FD6)25306,  (FD6)29384,    //  1.06 - 1.07
    (FD6)33424,  (FD6)37426,    //  1.08 - 1.09
    (FD6)41393,  (FD6)45323,    //  1.10 - 1.11
    (FD6)49218,  (FD6)53078,    //  1.12 - 1.13
    (FD6)56905,  (FD6)60698,    //  1.14 - 1.15
    (FD6)64458,  (FD6)68186,    //  1.16 - 1.17
    (FD6)71882,  (FD6)75547,    //  1.18 - 1.19
    (FD6)79181,  (FD6)82785,    //  1.20 - 1.21
    (FD6)86360,  (FD6)89905,    //  1.22 - 1.23
    (FD6)93422,  (FD6)96910,    //  1.24 - 1.25
    (FD6)100371, (FD6)103804,   //  1.26 - 1.27
    (FD6)107210, (FD6)110590,   //  1.28 - 1.29
    (FD6)113943, (FD6)117271,   //  1.30 - 1.31
    (FD6)120574, (FD6)123852,   //  1.32 - 1.33
    (FD6)127105, (FD6)130334,   //  1.34 - 1.35
    (FD6)133539, (FD6)136721,   //  1.36 - 1.37
    (FD6)139879, (FD6)143015,   //  1.38 - 1.39
    (FD6)146128, (FD6)149219,   //  1.40 - 1.41
    (FD6)152288, (FD6)155336,   //  1.42 - 1.43
    (FD6)158362, (FD6)161368,   //  1.44 - 1.45
    (FD6)164353, (FD6)167317,   //  1.46 - 1.47
    (FD6)170262, (FD6)173186,   //  1.48 - 1.49
    (FD6)176091, (FD6)178977,   //  1.50 - 1.51
    (FD6)181844, (FD6)184691,   //  1.52 - 1.53
    (FD6)187521, (FD6)190332,   //  1.54 - 1.55
    (FD6)193125, (FD6)195900,   //  1.56 - 1.57
    (FD6)198657, (FD6)201397,   //  1.58 - 1.59
    (FD6)204120, (FD6)206826,   //  1.60 - 1.61
    (FD6)209515, (FD6)212188,   //  1.62 - 1.63
    (FD6)214844, (FD6)217484,   //  1.64 - 1.65
    (FD6)220108, (FD6)222716,   //  1.66 - 1.67
    (FD6)225309, (FD6)227887,   //  1.68 - 1.69
    (FD6)230449, (FD6)232996,   //  1.70 - 1.71
    (FD6)235528, (FD6)238046,   //  1.72 - 1.73
    (FD6)240549, (FD6)243038,   //  1.74 - 1.75
    (FD6)245513, (FD6)247973,   //  1.76 - 1.77
    (FD6)250420, (FD6)252853,   //  1.78 - 1.79
    (FD6)255273, (FD6)257679,   //  1.80 - 1.81
    (FD6)260071, (FD6)262451,   //  1.82 - 1.83
    (FD6)264818, (FD6)267172,   //  1.84 - 1.85
    (FD6)269513, (FD6)271842,   //  1.86 - 1.87
    (FD6)274158, (FD6)276462,   //  1.88 - 1.89
    (FD6)278754, (FD6)281033,   //  1.90 - 1.91
    (FD6)283301, (FD6)285557,   //  1.92 - 1.93
    (FD6)287802, (FD6)290035,   //  1.94 - 1.95
    (FD6)292256, (FD6)294466,   //  1.96 - 1.97
    (FD6)296665, (FD6)298853,   //  1.98 - 1.99
    (FD6)301030, (FD6)303196,   //  2.00 - 2.01
    (FD6)305351, (FD6)307496,   //  2.02 - 2.03
    (FD6)309630, (FD6)311754,   //  2.04 - 2.05
    (FD6)313867, (FD6)315970,   //  2.06 - 2.07
    (FD6)318063, (FD6)320146,   //  2.08 - 2.09
    (FD6)322219, (FD6)324282,   //  2.10 - 2.11
    (FD6)326336, (FD6)328380,   //  2.12 - 2.13
    (FD6)330414, (FD6)332438,   //  2.14 - 2.15
    (FD6)334454, (FD6)336460,   //  2.16 - 2.17
    (FD6)338456, (FD6)340444,   //  2.18 - 2.19
    (FD6)342423, (FD6)344392,   //  2.20 - 2.21
    (FD6)346353, (FD6)348305,   //  2.22 - 2.23
    (FD6)350248, (FD6)352183,   //  2.24 - 2.25
    (FD6)354108, (FD6)356026,   //  2.26 - 2.27
    (FD6)357935, (FD6)359835,   //  2.28 - 2.29
    (FD6)361728, (FD6)363612,   //  2.30 - 2.31
    (FD6)365488, (FD6)367356,   //  2.32 - 2.33
    (FD6)369216, (FD6)371068,   //  2.34 - 2.35
    (FD6)372912, (FD6)374748,   //  2.36 - 2.37
    (FD6)376577, (FD6)378398,   //  2.38 - 2.39
    (FD6)380211, (FD6)382017,   //  2.40 - 2.41
    (FD6)383815, (FD6)385606,   //  2.42 - 2.43
    (FD6)387390, (FD6)389166,   //  2.44 - 2.45
    (FD6)390935, (FD6)392697,   //  2.46 - 2.47
    (FD6)394452, (FD6)396199,   //  2.48 - 2.49
    (FD6)397940, (FD6)399674,   //  2.50 - 2.51
    (FD6)401401, (FD6)403121,   //  2.52 - 2.53
    (FD6)404834, (FD6)406540,   //  2.54 - 2.55
    (FD6)408240, (FD6)409933,   //  2.56 - 2.57
    (FD6)411620, (FD6)413300,   //  2.58 - 2.59
    (FD6)414973, (FD6)416641,   //  2.60 - 2.61
    (FD6)418301, (FD6)419956,   //  2.62 - 2.63
    (FD6)421604, (FD6)423246,   //  2.64 - 2.65
    (FD6)424882, (FD6)426511,   //  2.66 - 2.67
    (FD6)428135, (FD6)429752,   //  2.68 - 2.69
    (FD6)431364, (FD6)432969,   //  2.70 - 2.71
    (FD6)434569, (FD6)436163,   //  2.72 - 2.73
    (FD6)437751, (FD6)439333,   //  2.74 - 2.75
    (FD6)440909, (FD6)442480,   //  2.76 - 2.77
    (FD6)444045, (FD6)445604,   //  2.78 - 2.79
    (FD6)447158, (FD6)448706,   //  2.80 - 2.81
    (FD6)450249, (FD6)451786,   //  2.82 - 2.83
    (FD6)453318, (FD6)454845,   //  2.84 - 2.85
    (FD6)456366, (FD6)457882,   //  2.86 - 2.87
    (FD6)459392, (FD6)460898,   //  2.88 - 2.89
    (FD6)462398, (FD6)463893,   //  2.90 - 2.91
    (FD6)465383, (FD6)466868,   //  2.92 - 2.93
    (FD6)468347, (FD6)469822,   //  2.94 - 2.95
    (FD6)471292, (FD6)472756,   //  2.96 - 2.97
    (FD6)474216, (FD6)475671,   //  2.98 - 2.99
    (FD6)477121, (FD6)478566,   //  3.00 - 3.01
    (FD6)480007, (FD6)481443,   //  3.02 - 3.03
    (FD6)482874, (FD6)484300,   //  3.04 - 3.05
    (FD6)485721, (FD6)487138,   //  3.06 - 3.07
    (FD6)488551, (FD6)489958,   //  3.08 - 3.09
    (FD6)491362, (FD6)492760,   //  3.10 - 3.11
    (FD6)494155, (FD6)495544,   //  3.12 - 3.13
    (FD6)496930, (FD6)498311,   //  3.14 - 3.15
    (FD6)499687, (FD6)501059,   //  3.16 - 3.17
    (FD6)502427, (FD6)503791,   //  3.18 - 3.19
    (FD6)505150, (FD6)506505,   //  3.20 - 3.21
    (FD6)507856, (FD6)509203,   //  3.22 - 3.23
    (FD6)510545, (FD6)511883,   //  3.24 - 3.25
    (FD6)513218, (FD6)514548,   //  3.26 - 3.27
    (FD6)515874, (FD6)517196,   //  3.28 - 3.29
    (FD6)518514, (FD6)519828,   //  3.30 - 3.31
    (FD6)521138, (FD6)522444,   //  3.32 - 3.33
    (FD6)523746, (FD6)525045,   //  3.34 - 3.35
    (FD6)526339, (FD6)527630,   //  3.36 - 3.37
    (FD6)528917, (FD6)530200,   //  3.38 - 3.39
    (FD6)531479, (FD6)532754,   //  3.40 - 3.41
    (FD6)534026, (FD6)535294,   //  3.42 - 3.43
    (FD6)536558, (FD6)537819,   //  3.44 - 3.45
    (FD6)539076, (FD6)540329,   //  3.46 - 3.47
    (FD6)541579, (FD6)542825,   //  3.48 - 3.49
    (FD6)544068, (FD6)545307,   //  3.50 - 3.51
    (FD6)546543, (FD6)547775,   //  3.52 - 3.53
    (FD6)549003, (FD6)550228,   //  3.54 - 3.55
    (FD6)551450, (FD6)552668,   //  3.56 - 3.57
    (FD6)553883, (FD6)555094,   //  3.58 - 3.59
    (FD6)556303, (FD6)557507,   //  3.60 - 3.61
    (FD6)558709, (FD6)559907,   //  3.62 - 3.63
    (FD6)561101, (FD6)562293,   //  3.64 - 3.65
    (FD6)563481, (FD6)564666,   //  3.66 - 3.67
    (FD6)565848, (FD6)567026,   //  3.68 - 3.69
    (FD6)568202, (FD6)569374,   //  3.70 - 3.71
    (FD6)570543, (FD6)571709,   //  3.72 - 3.73
    (FD6)572872, (FD6)574031,   //  3.74 - 3.75
    (FD6)575188, (FD6)576341,   //  3.76 - 3.77
    (FD6)577492, (FD6)578639,   //  3.78 - 3.79
    (FD6)579784, (FD6)580925,   //  3.80 - 3.81
    (FD6)582063, (FD6)583199,   //  3.82 - 3.83
    (FD6)584331, (FD6)585461,   //  3.84 - 3.85
    (FD6)586587, (FD6)587711,   //  3.86 - 3.87
    (FD6)588832, (FD6)589950,   //  3.88 - 3.89
    (FD6)591065, (FD6)592177,   //  3.90 - 3.91
    (FD6)593286, (FD6)594393,   //  3.92 - 3.93
    (FD6)595496, (FD6)596597,   //  3.94 - 3.95
    (FD6)597695, (FD6)598791,   //  3.96 - 3.97
    (FD6)599883, (FD6)600973,   //  3.98 - 3.99
    (FD6)602060, (FD6)603144,   //  4.00 - 4.01
    (FD6)604226, (FD6)605305,   //  4.02 - 4.03
    (FD6)606381, (FD6)607455,   //  4.04 - 4.05
    (FD6)608526, (FD6)609594,   //  4.06 - 4.07
    (FD6)610660, (FD6)611723,   //  4.08 - 4.09
    (FD6)612784, (FD6)613842,   //  4.10 - 4.11
    (FD6)614897, (FD6)615950,   //  4.12 - 4.13
    (FD6)617000, (FD6)618048,   //  4.14 - 4.15
    (FD6)619093, (FD6)620136,   //  4.16 - 4.17
    (FD6)621176, (FD6)622214,   //  4.18 - 4.19
    (FD6)623249, (FD6)624282,   //  4.20 - 4.21
    (FD6)625312, (FD6)626340,   //  4.22 - 4.23
    (FD6)627366, (FD6)628389,   //  4.24 - 4.25
    (FD6)629410, (FD6)630428,   //  4.26 - 4.27
    (FD6)631444, (FD6)632457,   //  4.28 - 4.29
    (FD6)633468, (FD6)634477,   //  4.30 - 4.31
    (FD6)635484, (FD6)636488,   //  4.32 - 4.33
    (FD6)637490, (FD6)638489,   //  4.34 - 4.35
    (FD6)639486, (FD6)640481,   //  4.36 - 4.37
    (FD6)641474, (FD6)642465,   //  4.38 - 4.39
    (FD6)643453, (FD6)644439,   //  4.40 - 4.41
    (FD6)645422, (FD6)646404,   //  4.42 - 4.43
    (FD6)647383, (FD6)648360,   //  4.44 - 4.45
    (FD6)649335, (FD6)650308,   //  4.46 - 4.47
    (FD6)651278, (FD6)652246,   //  4.48 - 4.49
    (FD6)653213, (FD6)654177,   //  4.50 - 4.51
    (FD6)655138, (FD6)656098,   //  4.52 - 4.53
    (FD6)657056, (FD6)658011,   //  4.54 - 4.55
    (FD6)658965, (FD6)659916,   //  4.56 - 4.57
    (FD6)660865, (FD6)661813,   //  4.58 - 4.59
    (FD6)662758, (FD6)663701,   //  4.60 - 4.61
    (FD6)664642, (FD6)665581,   //  4.62 - 4.63
    (FD6)666518, (FD6)667453,   //  4.64 - 4.65
    (FD6)668386, (FD6)669317,   //  4.66 - 4.67
    (FD6)670246, (FD6)671173,   //  4.68 - 4.69
    (FD6)672098, (FD6)673021,   //  4.70 - 4.71
    (FD6)673942, (FD6)674861,   //  4.72 - 4.73
    (FD6)675778, (FD6)676694,   //  4.74 - 4.75
    (FD6)677607, (FD6)678518,   //  4.76 - 4.77
    (FD6)679428, (FD6)680336,   //  4.78 - 4.79
    (FD6)681241, (FD6)682145,   //  4.80 - 4.81
    (FD6)683047, (FD6)683947,   //  4.82 - 4.83
    (FD6)684845, (FD6)685742,   //  4.84 - 4.85
    (FD6)686636, (FD6)687529,   //  4.86 - 4.87
    (FD6)688420, (FD6)689309,   //  4.88 - 4.89
    (FD6)690196, (FD6)691081,   //  4.90 - 4.91
    (FD6)691965, (FD6)692847,   //  4.92 - 4.93
    (FD6)693727, (FD6)694605,   //  4.94 - 4.95
    (FD6)695482, (FD6)696356,   //  4.96 - 4.97
    (FD6)697229, (FD6)698101,   //  4.98 - 4.99
    (FD6)698970, (FD6)699838,   //  5.00 - 5.01
    (FD6)700704, (FD6)701568,   //  5.02 - 5.03
    (FD6)702431, (FD6)703291,   //  5.04 - 5.05
    (FD6)704151, (FD6)705008,   //  5.06 - 5.07
    (FD6)705864, (FD6)706718,   //  5.08 - 5.09
    (FD6)707570, (FD6)708421,   //  5.10 - 5.11
    (FD6)709270, (FD6)710117,   //  5.12 - 5.13
    (FD6)710963, (FD6)711807,   //  5.14 - 5.15
    (FD6)712650, (FD6)713491,   //  5.16 - 5.17
    (FD6)714330, (FD6)715167,   //  5.18 - 5.19
    (FD6)716003, (FD6)716838,   //  5.20 - 5.21
    (FD6)717671, (FD6)718502,   //  5.22 - 5.23
    (FD6)719331, (FD6)720159,   //  5.24 - 5.25
    (FD6)720986, (FD6)721811,   //  5.26 - 5.27
    (FD6)722634, (FD6)723456,   //  5.28 - 5.29
    (FD6)724276, (FD6)725095,   //  5.30 - 5.31
    (FD6)725912, (FD6)726727,   //  5.32 - 5.33
    (FD6)727541, (FD6)728354,   //  5.34 - 5.35
    (FD6)729165, (FD6)729974,   //  5.36 - 5.37
    (FD6)730782, (FD6)731589,   //  5.38 - 5.39
    (FD6)732394, (FD6)733197,   //  5.40 - 5.41
    (FD6)733999, (FD6)734800,   //  5.42 - 5.43
    (FD6)735599, (FD6)736397,   //  5.44 - 5.45
    (FD6)737193, (FD6)737987,   //  5.46 - 5.47
    (FD6)738781, (FD6)739572,   //  5.48 - 5.49
    (FD6)740363, (FD6)741152,   //  5.50 - 5.51
    (FD6)741939, (FD6)742725,   //  5.52 - 5.53
    (FD6)743510, (FD6)744293,   //  5.54 - 5.55
    (FD6)745075, (FD6)745855,   //  5.56 - 5.57
    (FD6)746634, (FD6)747412,   //  5.58 - 5.59
    (FD6)748188, (FD6)748963,   //  5.60 - 5.61
    (FD6)749736, (FD6)750508,   //  5.62 - 5.63
    (FD6)751279, (FD6)752048,   //  5.64 - 5.65
    (FD6)752816, (FD6)753583,   //  5.66 - 5.67
    (FD6)754348, (FD6)755112,   //  5.68 - 5.69
    (FD6)755875, (FD6)756636,   //  5.70 - 5.71
    (FD6)757396, (FD6)758155,   //  5.72 - 5.73
    (FD6)758912, (FD6)759668,   //  5.74 - 5.75
    (FD6)760422, (FD6)761176,   //  5.76 - 5.77
    (FD6)761928, (FD6)762679,   //  5.78 - 5.79
    (FD6)763428, (FD6)764176,   //  5.80 - 5.81
    (FD6)764923, (FD6)765669,   //  5.82 - 5.83
    (FD6)766413, (FD6)767156,   //  5.84 - 5.85
    (FD6)767898, (FD6)768638,   //  5.86 - 5.87
    (FD6)769377, (FD6)770115,   //  5.88 - 5.89
    (FD6)770852, (FD6)771587,   //  5.90 - 5.91
    (FD6)772322, (FD6)773055,   //  5.92 - 5.93
    (FD6)773786, (FD6)774517,   //  5.94 - 5.95
    (FD6)775246, (FD6)775974,   //  5.96 - 5.97
    (FD6)776701, (FD6)777427,   //  5.98 - 5.99
    (FD6)778151, (FD6)778874,   //  6.00 - 6.01
    (FD6)779596, (FD6)780317,   //  6.02 - 6.03
    (FD6)781037, (FD6)781755,   //  6.04 - 6.05
    (FD6)782473, (FD6)783189,   //  6.06 - 6.07
    (FD6)783904, (FD6)784617,   //  6.08 - 6.09
    (FD6)785330, (FD6)786041,   //  6.10 - 6.11
    (FD6)786751, (FD6)787460,   //  6.12 - 6.13
    (FD6)788168, (FD6)788875,   //  6.14 - 6.15
    (FD6)789581, (FD6)790285,   //  6.16 - 6.17
    (FD6)790988, (FD6)791691,   //  6.18 - 6.19
    (FD6)792392, (FD6)793092,   //  6.20 - 6.21
    (FD6)793790, (FD6)794488,   //  6.22 - 6.23
    (FD6)795185, (FD6)795880,   //  6.24 - 6.25
    (FD6)796574, (FD6)797268,   //  6.26 - 6.27
    (FD6)797960, (FD6)798651,   //  6.28 - 6.29
    (FD6)799341, (FD6)800029,   //  6.30 - 6.31
    (FD6)800717, (FD6)801404,   //  6.32 - 6.33
    (FD6)802089, (FD6)802774,   //  6.34 - 6.35
    (FD6)803457, (FD6)804139,   //  6.36 - 6.37
    (FD6)804821, (FD6)805501,   //  6.38 - 6.39
    (FD6)806180, (FD6)806858,   //  6.40 - 6.41
    (FD6)807535, (FD6)808211,   //  6.42 - 6.43
    (FD6)808886, (FD6)809560,   //  6.44 - 6.45
    (FD6)810233, (FD6)810904,   //  6.46 - 6.47
    (FD6)811575, (FD6)812245,   //  6.48 - 6.49
    (FD6)812913, (FD6)813581,   //  6.50 - 6.51
    (FD6)814248, (FD6)814913,   //  6.52 - 6.53
    (FD6)815578, (FD6)816241,   //  6.54 - 6.55
    (FD6)816904, (FD6)817565,   //  6.56 - 6.57
    (FD6)818226, (FD6)818885,   //  6.58 - 6.59
    (FD6)819544, (FD6)820201,   //  6.60 - 6.61
    (FD6)820858, (FD6)821514,   //  6.62 - 6.63
    (FD6)822168, (FD6)822822,   //  6.64 - 6.65
    (FD6)823474, (FD6)824126,   //  6.66 - 6.67
    (FD6)824776, (FD6)825426,   //  6.68 - 6.69
    (FD6)826075, (FD6)826723,   //  6.70 - 6.71
    (FD6)827369, (FD6)828015,   //  6.72 - 6.73
    (FD6)828660, (FD6)829304,   //  6.74 - 6.75
    (FD6)829947, (FD6)830589,   //  6.76 - 6.77
    (FD6)831230, (FD6)831870,   //  6.78 - 6.79
    (FD6)832509, (FD6)833147,   //  6.80 - 6.81
    (FD6)833784, (FD6)834421,   //  6.82 - 6.83
    (FD6)835056, (FD6)835691,   //  6.84 - 6.85
    (FD6)836324, (FD6)836957,   //  6.86 - 6.87
    (FD6)837588, (FD6)838219,   //  6.88 - 6.89
    (FD6)838849, (FD6)839478,   //  6.90 - 6.91
    (FD6)840106, (FD6)840733,   //  6.92 - 6.93
    (FD6)841359, (FD6)841985,   //  6.94 - 6.95
    (FD6)842609, (FD6)843233,   //  6.96 - 6.97
    (FD6)843855, (FD6)844477,   //  6.98 - 6.99
    (FD6)845098, (FD6)845718,   //  7.00 - 7.01
    (FD6)846337, (FD6)846955,   //  7.02 - 7.03
    (FD6)847573, (FD6)848189,   //  7.04 - 7.05
    (FD6)848805, (FD6)849419,   //  7.06 - 7.07
    (FD6)850033, (FD6)850646,   //  7.08 - 7.09
    (FD6)851258, (FD6)851870,   //  7.10 - 7.11
    (FD6)852480, (FD6)853090,   //  7.12 - 7.13
    (FD6)853698, (FD6)854306,   //  7.14 - 7.15
    (FD6)854913, (FD6)855519,   //  7.16 - 7.17
    (FD6)856124, (FD6)856729,   //  7.18 - 7.19
    (FD6)857332, (FD6)857935,   //  7.20 - 7.21
    (FD6)858537, (FD6)859138,   //  7.22 - 7.23
    (FD6)859739, (FD6)860338,   //  7.24 - 7.25
    (FD6)860937, (FD6)861534,   //  7.26 - 7.27
    (FD6)862131, (FD6)862728,   //  7.28 - 7.29
    (FD6)863323, (FD6)863917,   //  7.30 - 7.31
    (FD6)864511, (FD6)865104,   //  7.32 - 7.33
    (FD6)865696, (FD6)866287,   //  7.34 - 7.35
    (FD6)866878, (FD6)867467,   //  7.36 - 7.37
    (FD6)868056, (FD6)868644,   //  7.38 - 7.39
    (FD6)869232, (FD6)869818,   //  7.40 - 7.41
    (FD6)870404, (FD6)870989,   //  7.42 - 7.43
    (FD6)871573, (FD6)872156,   //  7.44 - 7.45
    (FD6)872739, (FD6)873321,   //  7.46 - 7.47
    (FD6)873902, (FD6)874482,   //  7.48 - 7.49
    (FD6)875061, (FD6)875640,   //  7.50 - 7.51
    (FD6)876218, (FD6)876795,   //  7.52 - 7.53
    (FD6)877371, (FD6)877947,   //  7.54 - 7.55
    (FD6)878522, (FD6)879096,   //  7.56 - 7.57
    (FD6)879669, (FD6)880242,   //  7.58 - 7.59
    (FD6)880814, (FD6)881385,   //  7.60 - 7.61
    (FD6)881955, (FD6)882525,   //  7.62 - 7.63
    (FD6)883093, (FD6)883661,   //  7.64 - 7.65
    (FD6)884229, (FD6)884795,   //  7.66 - 7.67
    (FD6)885361, (FD6)885926,   //  7.68 - 7.69
    (FD6)886491, (FD6)887054,   //  7.70 - 7.71
    (FD6)887617, (FD6)888179,   //  7.72 - 7.73
    (FD6)888741, (FD6)889302,   //  7.74 - 7.75
    (FD6)889862, (FD6)890421,   //  7.76 - 7.77
    (FD6)890980, (FD6)891537,   //  7.78 - 7.79
    (FD6)892095, (FD6)892651,   //  7.80 - 7.81
    (FD6)893207, (FD6)893762,   //  7.82 - 7.83
    (FD6)894316, (FD6)894870,   //  7.84 - 7.85
    (FD6)895423, (FD6)895975,   //  7.86 - 7.87
    (FD6)896526, (FD6)897077,   //  7.88 - 7.89
    (FD6)897627, (FD6)898176,   //  7.90 - 7.91
    (FD6)898725, (FD6)899273,   //  7.92 - 7.93
    (FD6)899821, (FD6)900367,   //  7.94 - 7.95
    (FD6)900913, (FD6)901458,   //  7.96 - 7.97
    (FD6)902003, (FD6)902547,   //  7.98 - 7.99
    (FD6)903090, (FD6)903633,   //  8.00 - 8.01
    (FD6)904174, (FD6)904716,   //  8.02 - 8.03
    (FD6)905256, (FD6)905796,   //  8.04 - 8.05
    (FD6)906335, (FD6)906874,   //  8.06 - 8.07
    (FD6)907411, (FD6)907949,   //  8.08 - 8.09
    (FD6)908485, (FD6)909021,   //  8.10 - 8.11
    (FD6)909556, (FD6)910091,   //  8.12 - 8.13
    (FD6)910624, (FD6)911158,   //  8.14 - 8.15
    (FD6)911690, (FD6)912222,   //  8.16 - 8.17
    (FD6)912753, (FD6)913284,   //  8.18 - 8.19
    (FD6)913814, (FD6)914343,   //  8.20 - 8.21
    (FD6)914872, (FD6)915400,   //  8.22 - 8.23
    (FD6)915927, (FD6)916454,   //  8.24 - 8.25
    (FD6)916980, (FD6)917506,   //  8.26 - 8.27
    (FD6)918030, (FD6)918555,   //  8.28 - 8.29
    (FD6)919078, (FD6)919601,   //  8.30 - 8.31
    (FD6)920123, (FD6)920645,   //  8.32 - 8.33
    (FD6)921166, (FD6)921686,   //  8.34 - 8.35
    (FD6)922206, (FD6)922725,   //  8.36 - 8.37
    (FD6)923244, (FD6)923762,   //  8.38 - 8.39
    (FD6)924279, (FD6)924796,   //  8.40 - 8.41
    (FD6)925312, (FD6)925828,   //  8.42 - 8.43
    (FD6)926342, (FD6)926857,   //  8.44 - 8.45
    (FD6)927370, (FD6)927883,   //  8.46 - 8.47
    (FD6)928396, (FD6)928908,   //  8.48 - 8.49
    (FD6)929419, (FD6)929930,   //  8.50 - 8.51
    (FD6)930440, (FD6)930949,   //  8.52 - 8.53
    (FD6)931458, (FD6)931966,   //  8.54 - 8.55
    (FD6)932474, (FD6)932981,   //  8.56 - 8.57
    (FD6)933487, (FD6)933993,   //  8.58 - 8.59
    (FD6)934498, (FD6)935003,   //  8.60 - 8.61
    (FD6)935507, (FD6)936011,   //  8.62 - 8.63
    (FD6)936514, (FD6)937016,   //  8.64 - 8.65
    (FD6)937518, (FD6)938019,   //  8.66 - 8.67
    (FD6)938520, (FD6)939020,   //  8.68 - 8.69
    (FD6)939519, (FD6)940018,   //  8.70 - 8.71
    (FD6)940516, (FD6)941014,   //  8.72 - 8.73
    (FD6)941511, (FD6)942008,   //  8.74 - 8.75
    (FD6)942504, (FD6)943000,   //  8.76 - 8.77
    (FD6)943495, (FD6)943989,   //  8.78 - 8.79
    (FD6)944483, (FD6)944976,   //  8.80 - 8.81
    (FD6)945469, (FD6)945961,   //  8.82 - 8.83
    (FD6)946452, (FD6)946943,   //  8.84 - 8.85
    (FD6)947434, (FD6)947924,   //  8.86 - 8.87
    (FD6)948413, (FD6)948902,   //  8.88 - 8.89
    (FD6)949390, (FD6)949878,   //  8.90 - 8.91
    (FD6)950365, (FD6)950851,   //  8.92 - 8.93
    (FD6)951338, (FD6)951823,   //  8.94 - 8.95
    (FD6)952308, (FD6)952792,   //  8.96 - 8.97
    (FD6)953276, (FD6)953760,   //  8.98 - 8.99
    (FD6)954243, (FD6)954725,   //  9.00 - 9.01
    (FD6)955207, (FD6)955688,   //  9.02 - 9.03
    (FD6)956168, (FD6)956649,   //  9.04 - 9.05
    (FD6)957128, (FD6)957607,   //  9.06 - 9.07
    (FD6)958086, (FD6)958564,   //  9.08 - 9.09
    (FD6)959041, (FD6)959518,   //  9.10 - 9.11
    (FD6)959995, (FD6)960471,   //  9.12 - 9.13
    (FD6)960946, (FD6)961421,   //  9.14 - 9.15
    (FD6)961895, (FD6)962369,   //  9.16 - 9.17
    (FD6)962843, (FD6)963316,   //  9.18 - 9.19
    (FD6)963788, (FD6)964260,   //  9.20 - 9.21
    (FD6)964731, (FD6)965202,   //  9.22 - 9.23
    (FD6)965672, (FD6)966142,   //  9.24 - 9.25
    (FD6)966611, (FD6)967080,   //  9.26 - 9.27
    (FD6)967548, (FD6)968016,   //  9.28 - 9.29
    (FD6)968483, (FD6)968950,   //  9.30 - 9.31
    (FD6)969416, (FD6)969882,   //  9.32 - 9.33
    (FD6)970347, (FD6)970812,   //  9.34 - 9.35
    (FD6)971276, (FD6)971740,   //  9.36 - 9.37
    (FD6)972203, (FD6)972666,   //  9.38 - 9.39
    (FD6)973128, (FD6)973590,   //  9.40 - 9.41
    (FD6)974051, (FD6)974512,   //  9.42 - 9.43
    (FD6)974972, (FD6)975432,   //  9.44 - 9.45
    (FD6)975891, (FD6)976350,   //  9.46 - 9.47
    (FD6)976808, (FD6)977266,   //  9.48 - 9.49
    (FD6)977724, (FD6)978181,   //  9.50 - 9.51
    (FD6)978637, (FD6)979093,   //  9.52 - 9.53
    (FD6)979548, (FD6)980003,   //  9.54 - 9.55
    (FD6)980458, (FD6)980912,   //  9.56 - 9.57
    (FD6)981366, (FD6)981819,   //  9.58 - 9.59
    (FD6)982271, (FD6)982723,   //  9.60 - 9.61
    (FD6)983175, (FD6)983626,   //  9.62 - 9.63
    (FD6)984077, (FD6)984527,   //  9.64 - 9.65
    (FD6)984977, (FD6)985426,   //  9.66 - 9.67
    (FD6)985875, (FD6)986324,   //  9.68 - 9.69
    (FD6)986772, (FD6)987219,   //  9.70 - 9.71
    (FD6)987666, (FD6)988113,   //  9.72 - 9.73
    (FD6)988559, (FD6)989005,   //  9.74 - 9.75
    (FD6)989450, (FD6)989895,   //  9.76 - 9.77
    (FD6)990339, (FD6)990783,   //  9.78 - 9.79
    (FD6)991226, (FD6)991669,   //  9.80 - 9.81
    (FD6)992111, (FD6)992554,   //  9.82 - 9.83
    (FD6)992995, (FD6)993436,   //  9.84 - 9.85
    (FD6)993877, (FD6)994317,   //  9.86 - 9.87
    (FD6)994757, (FD6)995196,   //  9.88 - 9.89
    (FD6)995635, (FD6)996074,   //  9.90 - 9.91
    (FD6)996512, (FD6)996949,   //  9.92 - 9.93
    (FD6)997386, (FD6)997823,   //  9.94 - 9.95
    (FD6)998259, (FD6)998695,   //  9.96 - 9.97
    (FD6)999131, (FD6)999565,   //  9.98 - 9.99
    FD6_1                       // 10.00
    };


WORD    MantSearchTable[101] = {

       0,  //  0: 0.000000 - 0.012837,  EndIndex =   3 ( 4)
       2,  //  1: 0.008600 - 0.021189,  EndIndex =   5 ( 4)
       4,  //  2: 0.017033 - 0.033424,  EndIndex =   8 ( 5)
       7,  //  3: 0.029384 - 0.041393,  EndIndex =  10 ( 4)
       9,  //  4: 0.037426 - 0.053078,  EndIndex =  13 ( 5)
      12,  //  5: 0.049218 - 0.060698,  EndIndex =  15 ( 4)
      14,  //  6: 0.056905 - 0.071882,  EndIndex =  18 ( 5)
      17,  //  7: 0.068186 - 0.082785,  EndIndex =  21 ( 5)
      20,  //  8: 0.079181 - 0.093422,  EndIndex =  24 ( 5)
      23,  //  9: 0.089905 - 0.100371,  EndIndex =  26 ( 4)
      25,  // 10: 0.096910 - 0.110590,  EndIndex =  29 ( 5)
      28,  // 11: 0.107210 - 0.120574,  EndIndex =  32 ( 5)
      31,  // 12: 0.117271 - 0.130334,  EndIndex =  35 ( 5)
      34,  // 13: 0.127105 - 0.143015,  EndIndex =  39 ( 6)
      38,  // 14: 0.139879 - 0.152288,  EndIndex =  42 ( 5)
      41,  // 15: 0.149219 - 0.161368,  EndIndex =  45 ( 5)
      44,  // 16: 0.158362 - 0.170262,  EndIndex =  48 ( 5)
      47,  // 17: 0.167317 - 0.181844,  EndIndex =  52 ( 6)
      51,  // 18: 0.178977 - 0.190332,  EndIndex =  55 ( 5)
      54,  // 19: 0.187521 - 0.201397,  EndIndex =  59 ( 6)
      58,  // 20: 0.198657 - 0.212188,  EndIndex =  63 ( 6)
      62,  // 21: 0.209515 - 0.220108,  EndIndex =  66 ( 5)
      65,  // 22: 0.217484 - 0.230449,  EndIndex =  70 ( 6)
      69,  // 23: 0.227887 - 0.240549,  EndIndex =  74 ( 6)
      73,  // 24: 0.238046 - 0.250420,  EndIndex =  78 ( 6)
      77,  // 25: 0.247973 - 0.260071,  EndIndex =  82 ( 6)
      81,  // 26: 0.257679 - 0.271842,  EndIndex =  87 ( 7)
      86,  // 27: 0.269513 - 0.281033,  EndIndex =  91 ( 6)
      90,  // 28: 0.278754 - 0.290035,  EndIndex =  95 ( 6)
      94,  // 29: 0.287802 - 0.301030,  EndIndex = 100 ( 7)
      99,  // 30: 0.298853 - 0.311754,  EndIndex = 105 ( 7)
     104,  // 31: 0.309630 - 0.320146,  EndIndex = 109 ( 6)
     108,  // 32: 0.318063 - 0.330414,  EndIndex = 114 ( 7)
     113,  // 33: 0.328380 - 0.340444,  EndIndex = 119 ( 7)
     118,  // 34: 0.338456 - 0.350248,  EndIndex = 124 ( 7)
     123,  // 35: 0.348305 - 0.361728,  EndIndex = 130 ( 8)
     129,  // 36: 0.359835 - 0.371068,  EndIndex = 135 ( 7)
     134,  // 37: 0.369216 - 0.380211,  EndIndex = 140 ( 7)
     139,  // 38: 0.378398 - 0.390935,  EndIndex = 146 ( 8)
     145,  // 39: 0.389166 - 0.401401,  EndIndex = 152 ( 8)
     151,  // 40: 0.399674 - 0.411620,  EndIndex = 158 ( 8)
     157,  // 41: 0.409933 - 0.421604,  EndIndex = 164 ( 8)
     163,  // 42: 0.419956 - 0.431364,  EndIndex = 170 ( 8)
     169,  // 43: 0.429752 - 0.440909,  EndIndex = 176 ( 8)
     175,  // 44: 0.439333 - 0.450249,  EndIndex = 182 ( 8)
     181,  // 45: 0.448706 - 0.460898,  EndIndex = 189 ( 9)
     188,  // 46: 0.459392 - 0.471292,  EndIndex = 196 ( 9)
     195,  // 47: 0.469822 - 0.480007,  EndIndex = 202 ( 8)
     201,  // 48: 0.478566 - 0.491362,  EndIndex = 210 (10)
     209,  // 49: 0.489958 - 0.501059,  EndIndex = 217 ( 9)
     216,  // 50: 0.499687 - 0.510545,  EndIndex = 224 ( 9)
     223,  // 51: 0.509203 - 0.521138,  EndIndex = 232 (10)
     231,  // 52: 0.519828 - 0.530200,  EndIndex = 239 ( 9)
     238,  // 53: 0.528917 - 0.540329,  EndIndex = 247 (10)
     246,  // 54: 0.539076 - 0.550228,  EndIndex = 255 (10)
     254,  // 55: 0.549003 - 0.561101,  EndIndex = 264 (11)
     263,  // 56: 0.559907 - 0.570543,  EndIndex = 272 (10)
     271,  // 57: 0.569374 - 0.580925,  EndIndex = 281 (11)
     280,  // 58: 0.579784 - 0.591065,  EndIndex = 290 (11)
     289,  // 59: 0.589950 - 0.600973,  EndIndex = 299 (11)
     298,  // 60: 0.599883 - 0.610660,  EndIndex = 308 (11)
     307,  // 61: 0.609594 - 0.620136,  EndIndex = 317 (11)
     316,  // 62: 0.619093 - 0.630428,  EndIndex = 327 (12)
     326,  // 63: 0.629410 - 0.640481,  EndIndex = 337 (12)
     336,  // 64: 0.639486 - 0.650308,  EndIndex = 347 (12)
     346,  // 65: 0.649335 - 0.660865,  EndIndex = 358 (13)
     357,  // 66: 0.659916 - 0.670246,  EndIndex = 368 (12)
     367,  // 67: 0.669317 - 0.680336,  EndIndex = 379 (13)
     378,  // 68: 0.679428 - 0.690196,  EndIndex = 390 (13)
     389,  // 69: 0.689309 - 0.700704,  EndIndex = 402 (14)
     401,  // 70: 0.699838 - 0.710117,  EndIndex = 413 (13)
     412,  // 71: 0.709270 - 0.720159,  EndIndex = 425 (14)
     424,  // 72: 0.719331 - 0.730782,  EndIndex = 438 (15)
     437,  // 73: 0.729974 - 0.740363,  EndIndex = 450 (14)
     449,  // 74: 0.739572 - 0.750508,  EndIndex = 463 (15)
     462,  // 75: 0.749736 - 0.760422,  EndIndex = 476 (15)
     475,  // 76: 0.759668 - 0.770115,  EndIndex = 489 (15)
     488,  // 77: 0.769377 - 0.780317,  EndIndex = 503 (16)
     502,  // 78: 0.779596 - 0.790285,  EndIndex = 517 (16)
     516,  // 79: 0.789581 - 0.800029,  EndIndex = 531 (16)
     530,  // 80: 0.799341 - 0.810233,  EndIndex = 546 (17)
     545,  // 81: 0.809560 - 0.820201,  EndIndex = 561 (17)
     560,  // 82: 0.819544 - 0.830589,  EndIndex = 577 (18)
     576,  // 83: 0.829947 - 0.840106,  EndIndex = 592 (17)
     591,  // 84: 0.839478 - 0.850033,  EndIndex = 608 (18)
     607,  // 85: 0.849419 - 0.860338,  EndIndex = 625 (19)
     624,  // 86: 0.859739 - 0.870404,  EndIndex = 642 (19)
     641,  // 87: 0.869818 - 0.880242,  EndIndex = 659 (19)
     658,  // 88: 0.879669 - 0.890421,  EndIndex = 677 (20)
     676,  // 89: 0.889862 - 0.900367,  EndIndex = 695 (20)
     694,  // 90: 0.899821 - 0.910091,  EndIndex = 713 (20)
     712,  // 91: 0.909556 - 0.920123,  EndIndex = 732 (21)
     731,  // 92: 0.919601 - 0.930440,  EndIndex = 752 (22)
     751,  // 93: 0.929930 - 0.940018,  EndIndex = 771 (21)
     770,  // 94: 0.939519 - 0.950365,  EndIndex = 792 (23)
     791,  // 95: 0.949878 - 0.960471,  EndIndex = 813 (23)
     812,  // 96: 0.959995 - 0.970347,  EndIndex = 834 (23)
     833,  // 97: 0.969882 - 0.980003,  EndIndex = 855 (23)
     854,  // 98: 0.979548 - 0.990339,  EndIndex = 878 (25)
     877,  // 99: 0.989895 - 1.000000,  EndIndex = 900 (24)
     899   // Last MantissaTable[] Index Number - 1
    };

//
// Mantissa Correction Data Bits Usage:
//
//
//       <---High Word---> <----Low Word--->
//  Bit#  3          2          1          0
//       10987654 32109876 54321098 76543210
//       | | | |  | |  |   ||  |  |
//       | | | |  | |  |   ||  |  +-- x.000 Minimum Difference
//       | | | |  | |  |   ||  +----- x.001-x.002 (0-7) Correct 1
//       | | | |  | |  |   |+-------- x.000-x.001 (0-7) Correct 2
//       | | | |  | |  |   +--------- x.009-y.000 (0-1) Correct 10
//       | | | |  | |  +------------- x.009-y.000 (0-7) Correct 3
//       | | | |  | +---------------- x.008-x.009 (0-7) Correct 4
//       | | | |  +------------------ x.007-x.008 (0-3) Correct 5
//       | | | +--------------------- x.006-x.007 (0-3) Correct 6
//       | | +----------------------- x.005-x.006 (0-3) Correct 7
//       | +------------------------- x.004-x.005 (0-3) Correct 8
//       +--------------------------- x.003-x.004 (0-3) Correct 9
//

DWORD MantissaCorrectData[MANTISSATABLE_SIZE] = {

    0x269b49ae, 0x169a49aa, 0x159339a6, 0x9ba34ba1, 0x0692399e,  // 1.00-1.04
    0x165a399a, 0x559a4796, 0x1a93c792, 0x5adb398e, 0x4692398b,  // 1.05-1.09
    0x5a934787, 0x15923784, 0x59d33980, 0x5593297d, 0x1252277a,  // 1.10-1.14
    0x269bb776, 0x56933773, 0x55923770, 0x4653276d, 0x1592276a,  // 1.15-1.19
    0x158b2767, 0x46523764, 0x49922761, 0x1992b75e, 0x2692b75b,  // 1.20-1.24
    0x11522559, 0x45922556, 0x56922753, 0x054a2551, 0x158a354e,  // 1.25-1.29
    0x599a374b, 0x458a2749, 0x014a1547, 0x55522544, 0x05492542,  // 1.30-1.34
    0x1652b53f, 0x058aa53d, 0x044a233b, 0x00491539, 0x55522536,  // 1.35-1.39
    0x154a2534, 0x05492532, 0x01492530, 0x5992272d, 0x1992a72b,  // 1.40-1.44
    0x198ab529, 0x55922527, 0x00411526, 0x56522523, 0x56522721,  // 1.45-1.49
    0x01091520, 0x0449231e, 0x0149231c, 0x4549251a, 0x154a9518,  // 1.50-1.54
    0x4651a516, 0x01091315, 0x04492313, 0x454a1511, 0x158aa50f,  // 1.55-1.59
    0x0141230e, 0x1451150c, 0x464aa50a, 0x04491309, 0x454a1507,  // 1.60-1.64
    0x1952a505, 0x05491504, 0x558a2502, 0x41491501, 0x158a94ff,  // 1.65-1.69
    0x050922fe, 0x555124fc, 0x114914fb, 0x564a24f9, 0x454914f8,  // 1.70-1.74
    0x010912f7, 0x455122f5, 0x110914f4, 0x1951a4f2, 0x154994f1,  // 1.75-1.79
    0x410912f0, 0x558a22ee, 0x454a14ed, 0x114912ec, 0x010812eb,  // 1.80-1.84
    0x1551a2e9, 0x1149a2e8, 0x110912e7, 0x010812e6, 0x000102e5,  // 1.85-1.89
    0x454922e3, 0x114914e2, 0x044912e1, 0x044112e0, 0x004102df,  // 1.90-1.94
    0x1551a2dd, 0x518914dc, 0x454914db, 0x444922da, 0x414912d9,  // 1.95-1.99
    0x110912d8, 0x014112d7, 0x040912d6, 0x010812d5, 0x010812d4,  // 2.00-2.04
    0x004102d3, 0x2551a4d1, 0x2551a4d0, 0x000812d0, 0x000812cf,  // 2.05-2.09
    0x595124cd, 0x010812cd, 0x100902cc, 0x044110cb, 0x010902ca,  // 2.10-2.14
    0x410912c9, 0x444112c8, 0x110912c7, 0x450914c6, 0x1449a2c5,  // 2.15-2.19
    0x515112c4, 0x155194c3, 0x000802c3, 0x004102c2, 0x010892c1,  // 2.20-2.24
    0x044910c0, 0x054194bf, 0x154992be, 0x554922bd, 0x004012bd,  // 2.25-2.29
    0x044102bc, 0x414112bb, 0x114992ba, 0x1549a2b9, 0x000810b9,  // 2.30-2.34
    0x044102b8, 0x114112b7, 0x144994b6, 0x000010b6, 0x004102b5,  // 2.35-2.39
    0x414112b4, 0x454912b3, 0x555114b2, 0x040812b2, 0x444812b1,  // 2.40-2.44
    0x550a12b0, 0x000802b0, 0x410902af, 0x450912ae, 0x458994ad,  // 2.45-2.49
    0x104102ad, 0x114892ac, 0x000000ac, 0x100810ab, 0x444812aa,  // 2.50-2.54
    0x1549a2a9, 0x010102a9, 0x110992a8, 0x515192a7, 0x010110a7,  // 2.55-2.59
    0x144992a6, 0x155192a5, 0x410812a5, 0x144992a4, 0x004010a4,  // 2.60-2.64
    0x044892a3, 0x554912a2, 0x104102a2, 0x450912a1, 0x000802a1,  // 2.65-2.69
    0x110902a0, 0x4549949f, 0x4041029f, 0x4509929e, 0x0101009e,  // 2.70-2.74
    0x4449029d, 0x0000109d, 0x4441029c, 0x5549129b, 0x1041029b,  // 2.75-2.79
    0x5149129a, 0x0101029a, 0x45091299, 0x00010299, 0x11099298,  // 2.80-2.84
    0x00001098, 0x44481297, 0x554a1296, 0x44411296, 0x51519295,  // 2.85-2.89
    0x41090295, 0x51519294, 0x04418294, 0x55491293, 0x41081293,  // 2.90-2.94
    0x00000093, 0x04411092, 0x55491491, 0x11081291, 0x1549a290,  // 2.95-2.99
    0x11081290, 0x00000290, 0x1109828f, 0x0008008f, 0x1109908e,  // 3.00-3.04
    0x0000108e, 0x4509128d, 0x1001028d, 0x4541128c, 0x4041028c,  // 3.05-3.09
    0x5449128b, 0x0408928b, 0x5549128a, 0x0448928a, 0x0008008a,  // 3.10-3.14
    0x45091089, 0x00401089, 0x54491288, 0x41010288, 0x45499287,  // 3.15-3.19
    0x41090287, 0x00001087, 0x14489286, 0x01010086, 0x51491285,  // 3.20-3.24
    0x04089285, 0x00000085, 0x11098284, 0x01001084, 0x15099283,  // 3.25-3.29
    0x11010283, 0x51519282, 0x44481282, 0x00080282, 0x45499281,  // 3.30-3.34
    0x10411081, 0x00000281, 0x14489280, 0x40401080, 0x4549927f,  // 3.35-3.39
    0x1109027f, 0x0008027f, 0x1449927e, 0x0441027e, 0x0000027e,  // 3.40-3.44
    0x5141127d, 0x0108027d, 0x1549947c, 0x4448127c, 0x0401027c,  // 3.45-3.49
    0x1549927b, 0x1108927b, 0x1001007b, 0x5509127a, 0x1108127a,  // 3.50-3.54
    0x0040027a, 0x54491279, 0x41090279, 0x00001079, 0x51499278,  // 3.55-3.59
    0x11081078, 0x04001078, 0x45498277, 0x11081077, 0x00400277,  // 3.60-3.64
    0x15099276, 0x44410276, 0x01001076, 0x55091275, 0x11089275,  // 3.65-3.69
    0x04010075, 0x45499274, 0x11098274, 0x00409074, 0x15499273,  // 3.70-3.74
    0x11419273, 0x04081073, 0x00000273, 0x51481272, 0x04418272,  // 3.75-3.79
    0x00080072, 0x54491271, 0x11089271, 0x01001071, 0x00000071,  // 3.80-3.84
    0x45090270, 0x41010270, 0x00080070, 0x4548926f, 0x1108906f,  // 3.85-3.89
    0x1001006f, 0x4549926e, 0x4448926e, 0x1040106e, 0x0000106e,  // 3.90-3.94
    0x5509126d, 0x1109826d, 0x0401006d, 0x0000006d, 0x1448926c,  // 3.95-3.99
    0x1041026c, 0x0040026c, 0x4549926b, 0x4448126b, 0x1041026b,  // 4.00-4.04
    0x0001006b, 0x5449126a, 0x4448126a, 0x0408026a, 0x0000106a,  // 4.05-4.09
    0x45419269, 0x44411069, 0x10080269, 0x45899268, 0x14499268,  // 4.10-4.14
    0x41410268, 0x04080268, 0x00000068, 0x15099267, 0x44410267,  // 4.15-4.19
    0x04080267, 0x55511266, 0x54491266, 0x11089266, 0x10401066,  // 4.20-4.24
    0x00400066, 0x45498265, 0x11098265, 0x10401065, 0x00000265,  // 4.25-4.29
    0x15499264, 0x14489264, 0x41081064, 0x10010064, 0x15499263,  // 4.30-4.34
    0x45411263, 0x11081263, 0x04080263, 0x00080063, 0x51499062,  // 4.35-4.39
    0x14419062, 0x10401062, 0x04000262, 0x51499261, 0x14489261,  // 4.40-4.44
    0x04418261, 0x01009061, 0x00000061, 0x55091260, 0x44489260,  // 4.45-4.49
    0x04418060, 0x00080060, 0x5149945f, 0x4509925f, 0x4441025f,  // 4.50-4.54
    0x4101025f, 0x0008005f, 0x5549125e, 0x4509925e, 0x0448905e,  // 4.55-4.59
    0x4040105e, 0x0008005e, 0x5149925d, 0x1448925d, 0x4441025d,  // 4.60-4.64
    0x4040105d, 0x0008005d, 0x5149925c, 0x1449825c, 0x0441905c,  // 4.65-4.69
    0x4040105c, 0x0008005c, 0x4549925b, 0x5141125b, 0x1108925b,  // 4.70-4.74
    0x4041005b, 0x0001005b, 0x0000005b, 0x5148925a, 0x4448105a,  // 4.75-4.79
    0x4101025a, 0x0400105a, 0x0000005a, 0x55091259, 0x14489259,  // 4.80-4.84
    0x11081059, 0x10080259, 0x00080059, 0x54499258, 0x14498258,  // 4.85-4.89
    0x11410258, 0x10410258, 0x04001058, 0x00000058, 0x15419257,  // 4.90-4.94
    0x14489257, 0x11081057, 0x04080257, 0x40000257, 0x55099256,  // 4.95-4.99
    0x45419256, 0x11419056, 0x44081056, 0x01009056, 0x00000056,  // 5.00-5.04
    0x00000056, 0x15099055, 0x11418255, 0x04089055, 0x04010055,  // 5.05-5.09
    0x00010055, 0x51499254, 0x51481254, 0x45081254, 0x11010254,  // 5.10-5.14
    0x40400254, 0x10000054, 0x55489253, 0x51490253, 0x44481253,  // 5.15-5.19
    0x04418253, 0x01018053, 0x04000053, 0x45499252, 0x55091252,  // 5.20-5.24
    0x14489252, 0x11089052, 0x41010052, 0x40010052, 0x00000052,  // 5.25-5.29
    0x55099251, 0x45099051, 0x44481051, 0x11010251, 0x40400251,  // 5.30-5.34
    0x01000051, 0x15499250, 0x55091250, 0x14489250, 0x11089050,  // 5.35-5.39
    0x10401050, 0x01000250, 0x00001050, 0x5449924f, 0x5148924f,  // 5.40-5.44
    0x1448904f, 0x1108104f, 0x0408824f, 0x0040004f, 0x0000104f,  // 5.45-5.49
    0x5541924e, 0x1449904e, 0x5109024e, 0x0441824e, 0x4040104e,  // 5.50-5.54
    0x1001004e, 0x0000004e, 0x1549924d, 0x4541924d, 0x1141904d,  // 5.55-5.59
    0x0441824d, 0x1040104d, 0x0040024d, 0x0000024d, 0x5549124c,  // 5.60-5.64
    0x5449124c, 0x1141924c, 0x4441024c, 0x1101024c, 0x4040024c,  // 5.65-5.69
    0x0008004c, 0x0000004c, 0x5509924b, 0x1509904b, 0x1141824b,  // 5.70-5.74
    0x1108104b, 0x4101024b, 0x1001004b, 0x1000004b, 0x5541924a,  // 5.75-5.79
    0x1541924a, 0x1448924a, 0x1441824a, 0x0440904a, 0x4040104a,  // 5.80-5.84
    0x0001804a, 0x0000004a, 0x15499249, 0x55091249, 0x14489249,  // 5.85-5.89
    0x44410249, 0x04418249, 0x01018049, 0x00080049, 0x00000249,  // 5.90-5.94
    0x45499248, 0x55091248, 0x51411248, 0x11098248, 0x41081048,  // 5.95-5.99
    0x04080248, 0x00400248, 0x00000248, 0x00000048, 0x55411247,  // 6.00-6.04
    0x45419247, 0x14419047, 0x11089047, 0x10410047, 0x40400247,  // 6.05-6.09
    0x00080047, 0x00000047, 0x55491246, 0x54491246, 0x11419246,  // 6.10-6.14
    0x11418246, 0x41081046, 0x04080246, 0x00408246, 0x10000046,  // 6.15-6.19
    0x00000046, 0x55490245, 0x15099245, 0x45098245, 0x45081045,  // 6.20-6.24
    0x11081045, 0x04088245, 0x00088045, 0x10000045, 0x00000045,  // 6.25-6.29
    0x55491044, 0x15099244, 0x44498244, 0x44481044, 0x10418244,  // 6.30-6.34
    0x10410044, 0x01001044, 0x10000244, 0x00000044, 0x54499243,  // 6.35-6.39
    0x15419243, 0x14489243, 0x11098243, 0x04418243, 0x04089043,  // 6.40-6.44
    0x01018043, 0x00400043, 0x00001043, 0x00000043, 0x55481242,  // 6.45-6.49
    0x15099242, 0x45098242, 0x44481042, 0x10418242, 0x10401042,  // 6.50-6.54
    0x40400242, 0x00080042, 0x00001042, 0x55491241, 0x51499241,  // 6.55-6.59
    0x51481241, 0x14419241, 0x44418241, 0x44401041, 0x04089041,  // 6.60-6.64
    0x04010041, 0x10001041, 0x00000041, 0x00000041, 0x54499240,  // 6.65-6.69
    0x51498240, 0x51411040, 0x51081240, 0x04418240, 0x04089040,  // 6.70-6.74
    0x01018040, 0x40080040, 0x10000040, 0x00000040, 0x5509923f,  // 6.75-6.79
    0x1548923f, 0x5148123f, 0x1448923f, 0x4448103f, 0x1101823f,  // 6.80-6.84
    0x4101003f, 0x4040103f, 0x0008003f, 0x0000023f, 0x0000003f,  // 6.85-6.89
    0x5149923e, 0x1541923e, 0x5448123e, 0x4508123e, 0x1108923e,  // 6.90-6.94
    0x4108103e, 0x0408823e, 0x0401003e, 0x0100023e, 0x0001003e,  // 6.95-6.99
    0x0000003e, 0x5149923d, 0x5509123d, 0x4541923d, 0x5141103d,  // 7.00-7.04
    0x1141823d, 0x1108103d, 0x1101023d, 0x1008023d, 0x0100103d,  // 7.05-7.09
    0x4000023d, 0x0000003d, 0x0000003d, 0x1549903c, 0x1541923c,  // 7.10-7.14
    0x1448923c, 0x5109023c, 0x4441023c, 0x0441823c, 0x0440103c,  // 7.15-7.19
    0x0408023c, 0x0100103c, 0x0001003c, 0x0008003c, 0x5548923b,  // 7.20-7.24
    0x5509923b, 0x5449103b, 0x5141123b, 0x4448923b, 0x1108903b,  // 7.25-7.29
    0x1108103b, 0x4101023b, 0x4040103b, 0x0401003b, 0x0001003b,  // 7.30-7.34
    0x0001003b, 0x5549123a, 0x5549123a, 0x5509123a, 0x4541923a,  // 7.35-7.39
    0x5141103a, 0x1109823a, 0x1108903a, 0x4408103a, 0x1040103a,  // 7.40-7.44
    0x4040023a, 0x0008803a, 0x4000003a, 0x0000003a, 0x45499239,  // 7.45-7.49
    0x51499239, 0x45489239, 0x14498239, 0x45090239, 0x11089239,  // 7.50-7.54
    0x11089039, 0x44081039, 0x10401039, 0x40401039, 0x00088039,  // 7.55-7.59
    0x10000039, 0x00000039, 0x00000039, 0x55491038, 0x55091238,  // 7.60-7.64
    0x45419238, 0x51411038, 0x45081238, 0x44410238, 0x10418238,  // 7.65-7.69
    0x10401038, 0x04080238, 0x01000238, 0x04000238, 0x04000038,  // 7.70-7.74
    0x00000038, 0x55099237, 0x55099237, 0x54491037, 0x45419237,  // 7.75-7.79
    0x11419037, 0x11418237, 0x11089037, 0x44081037, 0x04089037,  // 7.80-7.84
    0x04018037, 0x40080037, 0x00400037, 0x00010037, 0x00000037,  // 7.85-7.89
    0x55491236, 0x45499236, 0x15419236, 0x51489236, 0x11419036,  // 7.90-7.94
    0x51090236, 0x44410236, 0x04418236, 0x04089036, 0x41010036,  // 7.95-7.99
    0x01009036, 0x00400036, 0x00008236, 0x00000036, 0x00000036,  // 8.00-8.04
    0x54499235, 0x55099235, 0x54491035, 0x51419235, 0x14419035,  // 8.05-8.09
    0x11418235, 0x44481035, 0x11088235, 0x10410035, 0x04088235,  // 8.10-8.14
    0x10080035, 0x04001035, 0x00080035, 0x00010035, 0x00000035,  // 8.15-8.19
    0x51499234, 0x54499234, 0x51498234, 0x54490234, 0x14489234,  // 8.20-8.24
    0x11418234, 0x44418234, 0x44081034, 0x10418234, 0x41010034,  // 8.25-8.29
    0x40401034, 0x04001034, 0x04000234, 0x00400034, 0x00000034,  // 8.30-8.34
    0x00000034, 0x55491233, 0x45499233, 0x45489233, 0x54490233,  // 8.35-8.39
    0x14489233, 0x51090233, 0x14418233, 0x11081033, 0x10418233,  // 8.40-8.44
    0x10410033, 0x04080233, 0x40400233, 0x40080033, 0x01000033,  // 8.45-8.49
    0x40000033, 0x00000033, 0x55489232, 0x54499232, 0x15489232,  // 8.50-8.54
    0x45489232, 0x45099032, 0x51411032, 0x51081232, 0x44410232,  // 8.55-8.59
    0x44410232, 0x41080232, 0x04088232, 0x01018032, 0x10010032,  // 8.60-8.64
    0x10001032, 0x00400032, 0x01000032, 0x00000032, 0x51499231,  // 8.65-8.69
    0x45499231, 0x55091231, 0x15099231, 0x51481231, 0x14489231,  // 8.70-8.74
    0x51090231, 0x14418231, 0x11089031, 0x04418031, 0x04409031,  // 8.75-8.79
    0x41010031, 0x01018031, 0x40400031, 0x00400031, 0x00001031,  // 8.80-8.84
    0x00080031, 0x00000031, 0x55489230, 0x55099230, 0x45498230,  // 8.85-8.89
    0x51489230, 0x45099030, 0x45090230, 0x44489230, 0x51081030,  // 8.90-8.94
    0x44410230, 0x11081030, 0x11010230, 0x04088230, 0x04018030,  // 8.95-8.99
    0x40400030, 0x00088030, 0x10000030, 0x00000030, 0x00001030,  // 9.00-9.04
    0x5541922f, 0x1549922f, 0x5449922f, 0x4549822f, 0x5449022f,  // 9.05-9.09
    0x5141122f, 0x1448922f, 0x1441902f, 0x4448102f, 0x4441022f,  // 9.10-9.14
    0x1108022f, 0x1101022f, 0x0408822f, 0x0401802f, 0x4040002f,  // 9.15-9.19
    0x0008802f, 0x0400002f, 0x0400002f, 0x0000002f, 0x0000002f,  // 9.20-9.24
    0x5541922e, 0x5509922e, 0x4549822e, 0x5148922e, 0x1509902e,  // 9.25-9.29
    0x4509822e, 0x1441902e, 0x1441822e, 0x1108902e, 0x1108902e,  // 9.30-9.34
    0x0441802e, 0x0440902e, 0x4101002e, 0x0101802e, 0x4008002e,  // 9.35-9.39
    0x0008802e, 0x0400002e, 0x0400002e, 0x0000002e, 0x0000002e,  // 9.40-9.44
    0x5449922d, 0x5149922d, 0x5541122d, 0x1509922d, 0x5148922d,  // 9.45-9.49
    0x5141902d, 0x1448902d, 0x1141822d, 0x4441102d, 0x4441022d,  // 9.50-9.54
    0x0441822d, 0x4408102d, 0x1040902d, 0x0408802d, 0x1008002d,  // 9.55-9.59
    0x0100102d, 0x0400022d, 0x0008002d, 0x0001002d, 0x0000002d,  // 9.60-9.64
    0x0000002d, 0x5549122c, 0x1549922c, 0x5449922c, 0x5149822c,  // 9.65-9.69
    0x5449022c, 0x5148122c, 0x1448922c, 0x1141902c, 0x1441822c,  // 9.70-9.74
    0x1108902c, 0x1108902c, 0x0441802c, 0x0440902c, 0x4101002c,  // 9.75-9.79
    0x4040102c, 0x0100102c, 0x0040822c, 0x0100002c, 0x0008002c,  // 9.80-9.84
    0x0008002c, 0x0000002c, 0x0000002c, 0x4549922b, 0x4549922b,  // 9.85-9.89
    0x5509922b, 0x5149902b, 0x5449102b, 0x5148122b, 0x1448922b,  // 9.90-9.94
    0x4509022b, 0x5108122b, 0x4441822b, 0x1108102b, 0x4441022b,  // 9.95-9.99
    0x00000000 };


DWORD   Power10ExpNum[] = {

                    1L,
                   10L,
                  100L,
                 1000L,
                10000L,
               100000L,
              1000000L,
             10000000L,
            100000000L,
           1000000000L
        };





FD6
HTENTRY
Log(
    FD6 Number
    )

/*++

Routine Description:

    This functions calculate the common logarithm for the number passed in,
    this is 10 based logarithm.

Arguments:

    Number - the decimal (FD6) number, this is a special format decimal number
             (FD6) it depends on the #define and may be floating number or
             six (6) lower digits as number to the right of the decimal
             points. that is 3 = 0.000003, 10000 = 0.010000, 1232321 = 1.232321
             and so on.

Return Value:

    Now no error value is returned, but it will clip to the FD6 defined limit
    as following:

    FD6_LOG_MAX - if the Number passed in is >= FD6_MAX (ie. 2147.483647)
                  then it returned FD6_LOG_MAX (ie. 3.331930).

    FD6_LOG_MIN - if the Number passed in is less or equal to 0 then it treated
                  passed Number as 0.000001 so the return value will be
                  FD6_LOG_MIN (ie. -6.0)

    othewise    - the approximate logarithm (based 10) number is returnd as
                  a FD6 number.  The accuracy of the returned logarithm number
                  as minimum/maximum errors as

                    maximum error = +0.000005983
                    minimum error = -0.0000009018

Author:

    16-Jan-1991 Wed 14:03:58 created  -by-  Daniel Chou (danielc)

Revision History:

    26-Sep-1991 Thu 12:10:52 updated  -by-  Daniel Chou (danielc)

        Rewrite for more accuracy up to six significant decimal digitis, and
        also make it durable to run under floating point package.


--*/

{
    FD6     Characteristic;                     // characteristics number
    FD6     Mantissa;
    LONG    Rem;
    INT     Quot;


    //
    // Do in-line binary search to find out how many digits of this
    // number (decimal left shift count), at here the range is from
    // 0.000001 to 999.999999, the goal is to make the number range in
    // 100.000000 to 999.999999 and also get its characteristic number.
    //
    //  100.000000  = 0
    //   10.000000  = 1
    //    1.000000  = 2
    //    0.100000  = 3
    //    0.010000  = 4
    //    0.001000  = 5
    //    0.000100  = 6
    //    0.000010  = 7
    //    0.000001  = 8
    //
    // first, find out what the characteristic is
    //

    if (Number >= FD6_p01) {                            // possible 0,1,2,3,4

        if (Number >= FD6_1) {                          // possible 0,1,2

            if (Number >= FD6_10) {                     // possible 0,1

                if (Number >= FD6_100) {                // possible 0

                    if (Number >= FD6_1000) {

                        if (Number >= (FD6_MAX - FD6_p000005)) {

                            return(FD6_LOG_MAX);
                        }

                        Characteristic = FD6_3;
                        Number = FD6DivL(Number, 10);

                    } else {

                        // 100.000000 - 999.000000

                        Characteristic = FD6_2;         // alreay in range
                    }

                } else {                                // possible 1

                    // 10.000000 - 99.999999

                    Characteristic = FD6_1;
                    Number = FD6xL(Number, 10);
                }

            } else {                                    // possible 2

                // 1.000000 - 9.999999

                Characteristic = FD6_0;
                Number = FD6xL(Number, 100);
            }

        } else if (Number >= FD6_p1) {                  // possible 3

            // 0.100000 - 0.999999

            Characteristic = -FD6_1;
            Number = FD6xL(Number, 1000);

        } else {                                        // possible 4

            // 0.010000 - 0.099999

            Characteristic = -FD6_2;
            Number = FD6xL(Number, 10000);
        }

    } else if (Number >= FD6_p0001) {                   // possible 5,6

        if (Number >= FD6_p001) {                       // possible 5

            // 0.001000 - 0.009999

            Characteristic = -FD6_3;
            Number = FD6xL(Number, 100000);

        } else {                                        // possible 6

            // 0.000100 - 0.000999

            Characteristic = -FD6_4;
            Number = FD6xL(Number, 1000000);
        }

    } else if (Number >= FD6_p00001) {                  // possible 7

        // 0.000010 - 0.000099

        Characteristic = -FD6_5;
        Number = FD6xL(Number, 10000000);

    } else if (Number > FD6_0) {                        // possible 8

        // 0.000001 - 0.000009

        Characteristic = -FD6_6;
        Number = FD6xL(Number, 100000000);

    } else {

        return(FD6_LOG_MIN);                            // invalid numbers
    }

    //
    // The number now range from 100.0000 to 999.999999
    //
    //
    //  ASSERT((Number >= FD6_100) && (Number < FD6_1000));
    //

    //
    // The Number now range from 100.000000 - 999.999999 and we need to
    // find the mantissa for it.  The number will be index
    // and/or interpolate from the table as following:
    //
    // Number  123.1234567
    //         |   |
    //         |   +----> 0.1234567 (if non zero) then interpolate with
    //         |          next table entry.
    //         |
    //         +-------> (123 - 100) will be index into the table
    //
    // For example:
    //
    //  Log (1.234567)     = 0.091515
    //
    //      Characteristic = 0.000000
    //            Mantissa = Table[123-100] = 0.089905
    //            Fraction = (Table[124-100] - 0.089905) * 0.456700
    //                     = 0.003517 * 0.4567 = 0.001606
    //              Return = (Characteristic + Mantissa + Fraction) =
    //                     = 0.000000 + 0.089905 + 0.001606 = 0.091511
    //               Error = 0.091515 - 0.091511 = 0.000004
    //
    //      Max/Min Errors are +0.000006/-0.000001
    //

    Mantissa = MantissaTable[Quot = (INT)(Number / FD6_1) - (INT)100];

    if (Rem = (LONG)(Number % FD6_1)) {

        Mantissa += FractionToMantissa((FD6)Rem,
                                       MantissaCorrectData[Quot]);
    }

    return(Characteristic + Mantissa);

}



FD6
HTENTRY
AntiLog(
    FD6 Number
    )

/*++

Routine Description:

    Calculate the antilogarithm for the logarithm number passed in, that is
    this function return the exponent of Number which base 10.

Arguments:

    Number - the logarithm number, this is a special format decimal number
             (FD6) it depends on the #define and may be floating number or
             six (6) lower digits as number to the right of the decimal
             points. that is 3 = 0.000003, 10000 = 0.010000, 1232321 = 1.232321
             and so on.

Return Value:

    Now no error returned, but it clipped the result to the FD6 limit, return
    values as following:

    0.000001    - if the Number is <= -6.0

    FD6_MAX     - if the Number is >= 3.331930 then it return FD6_MAX
                  (ie. 2147.483647).

    othewise    - approximate the antilogarithm (base 10) of the Number passed
                  in. the accuracy of the function is abount +0.000008 to
                  -0.000001.

Author:

    16-Jan-1991 Wed 15:34:17 created  -by-  Daniel Chou (danielc)

Revision History:

    26-Sep-1991 Thu 12:01:06 updated  -by-  Daniel Chou (danielc)

        Rewrite for more accuracy up to six significant decimal digitis, and
        also make it durable to run under floating point package.


--*/

{
    INT     Characteristic;
    INT     Index;
    INT     IndexH;
    INT     IndexL;
    FD6     CurrentMantissa;

    //
    // The number range is from -5.999999 - 3.331928
    // Separate the Number into Characteristic and Mantissa,
    //

    if (Number < FD6_0) {

        if (Number <= FD6_LOG_MIN) {

            return(FD6_p000001);
        }

        Characteristic  = (INT)((Number - (FD6)999999) / FD6_1);
        Number         -= FD6xL(FD6_1, Characteristic);

    } else if (Number >= FD6_1) {

        if (Number >= FD6_LOG_MAX) {

            return(FD6_MAX);
        }

        Characteristic = (INT)((Number + (FD6)999999) / FD6_1);
        Number         = FD6xL(FD6_1, Characteristic) - Number;

    } else {

        Characteristic = 0;
    }

    if (Number) {

        //
        // Do a modified binary search to find the closed low index, the
        // SearchTable[] is a estimate index for the first 2 mantissa digits.
        //

        Index  = (INT)(Number / FD6_p01);           // divide by 0.01 for index
        IndexL = (INT)MantSearchTable[Index++];     // starting estimate index
        IndexH = (INT)(MantSearchTable[Index] + 1); // ending estimate index

        while ((Index = (IndexL + IndexH) >> 1) != IndexL) {

            if (Number < (CurrentMantissa = MantissaTable[Index])) {

                IndexH = Index;

            } else if (Number > CurrentMantissa) {

                IndexL = Index;

            } else {

                Number = FD6_0;
                break;
            }
        }

        if (Number) {                   // Number = 0, if exactly match

            ASSERT((IndexL == Index) && ((IndexL + 1) == IndexH));

            //
            // Here we try to estimate for lower 4 decimal digit Mantissa
            // the table index is the index Mantissa of 0 - 900 (0.00 - 9.00)
            // the interpolate Mantissa is betwen two table indics Mantissas
            // such between 512 and 513 will be Mantissa between 5.12 and 5.13
            //

            Number = MantissaToFraction(Number - MantissaTable[IndexL],
                                        MantissaCorrectData[IndexL]);
        }

        //
        // The Index range is from 0-900
        //
        // Add in 100 to offset the mantissa table, since the first entry
        // is 1.0000
        //

        Number += INTToFD6(Index + 100);
        Characteristic -= 2;

    } else {                        // Number = 0.0, the result is 1.0

        Number = FD6_1;
    }

    //
    // Now we need to shift the decimal point around, if characteristic is
    // positive then we shift the decimal to the right (multiply), if the
    // Mantissa is negative then we shift the decimal point to the left
    // (divide), if it is a zero, then this is the final logarithm Mantissa.
    //

    if (Characteristic < 0) {

        return(FD6DivL(Number, (LONG)Power10ExpNum[-Characteristic]));

    } else if (Characteristic > 0) {

        return(FD6xL(Number, (LONG)Power10ExpNum[Characteristic]));

    } else {

        return(Number);
    }
}





FD6
HTENTRY
RaisePower(
    FD6     BaseNumber,
    FD6     Exponent,
    WORD    Flags
    )

/*++

Routine Description:

    Calculate the power of the base number (BaseNumber^Power).


Arguments:

    BaseNumber  -   The decimal (FD6) number, this is a special format decimal
                    number FD6) it depends on the #define and may be floating
                    number or six (6) lower digits as number to the right of
                    the decimal points. that is 3 = 0.000003, 10000 = 0.010000,
                    1232321 = 1.232321 and so on.

    Exponent    -   The exponent number is nth number to raise power to, it
                    has same format as BaseNumber.

    Flags       -   One or more of the following flags may be specified

                    RPF_RADICAL

                        1: This is a radical expression, the Exponent is
                              equal to 1.0/Exponent that is,

                        0: This is a regular power expression.


                    RPF_INTEXP

                        1: The Exponent field is treated as long integer number
                           rather a FD6 number.

                        0: The Exponent field is a FD6 number


        Note:   When BaseNumber is a negative number.

                1) Expoonent has fraction = .0 (ie. Integer only)

                    The whole BaseNumber is treated as an whole number.

                              2.0                    3.0
                        (-0.6)    = 0.36   and (-0.6)    = -0.216

                2) Exponent has fraction portion.

                    The negative sign is treated as a symbol.

                            2.1        2.1
                        -0.6    = -(0.6   ) = -0.342072


                The ONLY exception is that if Exponent = 0.0, then it returned

                    1.0 - if BaseNumber != 0.0
                    0.0 - if BaseNumber == 0.0 <-- Error Condition


Return Value:

    Now no error value is returned, but it will clip to the FD6 defined limit
    if condition occured as following and in this sequence:


    1)  0.0     - If BaseNumber = 0.0,

                    No error returned if Exponent <= 0.0, this number should
                    is not a real number.

    2)  1.0     - If Exponent = 0.0.

    othewise    - the approximate number for the nth power is returnd as
                  a FD6 number.  The accuracy of the returned logarithm number
                  as minimum/maximum errors as

                    maximum error = +0.000005983
                    minimum error = -0.0000009018

Author:

    16-Jan-1991 Wed 14:03:58 created  -by-  Daniel Chou (danielc)

Revision History:

    26-Sep-1991 Thu 12:10:52 updated  -by-  Daniel Chou (danielc)

        Delete OneOverExponent (BOOL) parameter

        Rewrite for more accuracy up to six significant decimal digitis, and
        also make it durable to run under floating point package.


--*/

{
    BOOL    NegativeBase;
    FD6     PowerNumber;


    //
    // check if any illegal condition exists, and preprocess any necessary
    // data
    //

    if (Flags & RPF_INTEXP) {

        if (Exponent == 1L) {

            return(BaseNumber);
        }

    } else {

        if (Exponent == FD6_1) {

            return(BaseNumber);
        }

        if (!(Exponent % FD6_1)) {

            Exponent /= FD6_1;
            Flags |= RPF_INTEXP;
        }
    }

    if (NegativeBase = (BOOL)(BaseNumber <= FD6_0)) {

        if (!(BaseNumber = -BaseNumber)) {      // 0^-num, 0^0 are illegal!!
                                                // but return as 0.0 now
            return(FD6_0);
        }
    }

    if (!Exponent) {

        return((NegativeBase) ? -FD6_1 : FD6_1);
    }

    //
    //                  y
    // Calculating the x = N with logarithms by solving following formula:
    //
    //      Log(N) = y * Log(x)
    //      ...
    //
    //      N = AntiLog(y * Log(x))
    //
    //  For example:
    //
    //       y           -1.654321
    //      x  = 0.123456           using the above formula we have
    //      -----------------------
    //
    //      Log(N) = y * Log(x)
    //      N      = AntiLog(y * Log(x))
    //
    //  ==> N = AntiLog(-1.654321 * Log(0.123456))
    //  ==> N = AntiLog(-1.654321 * -0.908488)
    //  ==> N = AntiLog(1.502931)
    //  ==> N = 31.836917                       <=== apporoximate FD6 number
    //
    //
    // If base number is 10.0 then do nothing with the logarithm, since
    // Log(10.0) = 1.0
    //

    BaseNumber = (BaseNumber == FD6_10) ? FD6_1 : Log(BaseNumber);

    if (Flags & RPF_INTEXP) {

        //
        // For EVEN interger exponent, the result always positive
        //

        if (!((DWORD)Exponent & 0x01)) {

            NegativeBase = FALSE;
        }

        PowerNumber = AntiLog((Flags & RPF_RADICAL) ?
                                            FD6DivL(BaseNumber, Exponent) :
                                            FD6xL(BaseNumber, Exponent));

    } else {

        PowerNumber = AntiLog((Flags & RPF_RADICAL) ?
                                            DivFD6(BaseNumber, Exponent) :
                                            MulFD6(BaseNumber, Exponent));
    }

    return((NegativeBase) ? -PowerNumber : PowerNumber);
}




BOOL
HTENTRY
ComputeInverseMatrix3x3(
    PMATRIX3x3  pInMatrix,
    PMATRIX3x3  pOutMatrix
    )

/*++

Routine Description:
                                           -1
    This function calculate inverse (Matrix  ) of the input 3x3 matrix

Arguments:

    pInMatrix       - 3 x 3 matrix to be inversed

    pOutMatrix      - Inverse 3 x 3 matrix of the input 3 x 3 matrix.

Return Value:

    The returned value will be TRUE if sucessfully invert the input matrix and
    returned value will be FALSE if there is singular in the input matrix.

    If the returned value is FALSE then the output matrix is not completed.

Author:

    11-Oct-1991 Fri 14:19:59 created    -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    MATRIX3x3   InMatrix;
    MATRIX3x3   OutMatrix;
    FD6         Temp;
    BOOL        NoSigular = TRUE;
    INT         i;
    INT         j;
    INT         k;


    InMatrix = *pInMatrix;                      // do a local copy

    //
    // Clear all to zero and set diagnal to 1.0
    //

    ZeroMemory(&OutMatrix.m[0][0], sizeof(MATRIX3x3));
    OutMatrix.m[0][0] = OutMatrix.m[1][1] = OutMatrix.m[2][2] = FD6_1;

    //
    // Using gaussian elimination.
    //

    for (i = 0; i < 3; i++) {

        for (j = i + 1, k = i; j < 3; j++) {

            if (ABSFD6(InMatrix.m[j][i]) > ABSFD6(InMatrix.m[k][i])) {

                k = j;
            }
        }

        if (InMatrix.m[k][i]) {

            //
            // Now we need to do pivot, we will switch row 'i' and row 'k' if
            // they are not in order.
            //

            if (k != i) {

                for (j = 0; j < 3; j++) {

                    SWAPFD6( InMatrix.m[i][j],  InMatrix.m[k][j], Temp);
                    SWAPFD6(OutMatrix.m[i][j], OutMatrix.m[k][j], Temp);
                }
            }

            //
            // Normalize the row, make the diagonal (ie. Matrix[i][i]) to 1.0
            // that is
            //

            for (j = 0, Temp = InMatrix.m[i][i]; j < 3; j++) {

                InMatrix.m[i][j]  = DivFD6(InMatrix.m[i][j],  Temp);
                OutMatrix.m[i][j] = DivFD6(OutMatrix.m[i][j], Temp);
            }

            //
            // and, zero the non-diagonal items in this column (ie. column i).
            //

            for (j = 0; j < 3; j++) {

                if ((j != i) && (Temp = InMatrix.m[j][i])) {

                    for (k = 0; k < 3; k++) {

                        InMatrix.m[j][k]  -= MulFD6( InMatrix.m[i][k], Temp);
                        OutMatrix.m[j][k] -= MulFD6(OutMatrix.m[i][k], Temp);
                    }
                }
            }

        } else {

            NoSigular = FALSE;
        }
    }

    *pOutMatrix = OutMatrix;

    return(NoSigular);

}




VOID
HTENTRY
ConcatTwoMatrix3x3(
    PMATRIX3x3  pConcat,
    PMATRIX3x3  pMatrix,
    PMATRIX3x3  pOutMatrix
    )

/*++

Routine Description:

    This function concatenate 'pMatrix' to 'pConcat' and output the result in
    'pOutMatrix',  supposed you have

    pConcat = RGB->YIQ and pMatrix = YIQ->XYZ

    then pOutMatrix = RGB->XYZ


Arguments:

    pConcat     - Source matrix to be concat

    pMatrix     - Matrix to concatenate into pConcat

    pOutMatrix  - Concatenated 3 x 3 matrix.

Return Value:

    There is no return value.

Author:

    11-Oct-1991 Fri 14:19:59 created    -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    MATRIX3x3   Concat = *pConcat;
    MATRIX3x3   Matrix = *pMatrix;
    MATRIX3x3   OutMatrix;
    MULDIVPAIR  MDPairs[4];
    INT         i;
    INT         j;


    MAKE_MULDIV_INFO(MDPairs, 3, MULDIV_NO_DIVISOR);

    for (i = 0; i < 3; i++) {

        for (j = 0; j < 3; j++) {

            MAKE_MULDIV_PAIR(MDPairs, 1, Matrix.m[i][0], Concat.m[0][j]);
            MAKE_MULDIV_PAIR(MDPairs, 2, Matrix.m[i][1], Concat.m[1][j]);
            MAKE_MULDIV_PAIR(MDPairs, 3, Matrix.m[i][2], Concat.m[2][j]);

            OutMatrix.m[i][j] = MulDivFD6Pairs(MDPairs);
        }
    }

    DBGP_IF(DBGP_CONCAT_M,
            DBGP("== Concat two 3x3 matrixes ==");
            DBGP("[%s %s %s]   [%s %s %s]   [%s %s %s]"
                ARGFD6(Matrix.m[0][0],2,3)
                ARGFD6(Matrix.m[0][1],2,3)      ARGFD6(Matrix.m[0][2],2,3)
                ARGFD6(Concat.m[0][0],2,3)
                ARGFD6(Concat.m[0][1],2,3)      ARGFD6(Concat.m[0][2],2,3)
                ARGFD6(OutMatrix.m[0][0],2,3)
                ARGFD6(OutMatrix.m[0][1],2,3)   ARGFD6(OutMatrix.m[0][2],2,3));

            DBGP("[%s %s %s] x [%s %s %s] = [%s %s %s]"
                ARGFD6(Matrix.m[1][0],2,3)
                ARGFD6(Matrix.m[1][1],2,3)      ARGFD6(Matrix.m[1][2],2,3)
                ARGFD6(Concat.m[1][0],2,3)
                ARGFD6(Concat.m[1][1],2,3)      ARGFD6(Concat.m[1][2],2,3)
                ARGFD6(OutMatrix.m[1][0],2,3)
                ARGFD6(OutMatrix.m[1][1],2,3)   ARGFD6(OutMatrix.m[1][2],2,3));

            DBGP("[%s %s %s]   [%s %s %s]   [%s %s %s]"
                ARGFD6(Matrix.m[2][0],2,3)
                ARGFD6(Matrix.m[2][1],2,3)      ARGFD6(Matrix.m[2][2],2,3)
                ARGFD6(Concat.m[2][0],2,3)
                ARGFD6(Concat.m[2][1],2,3)      ARGFD6(Concat.m[2][2],2,3)
                ARGFD6(OutMatrix.m[2][0],2,3)
                ARGFD6(OutMatrix.m[2][1],2,3)   ARGFD6(OutMatrix.m[2][2],2,3));
    );


    *pOutMatrix = OutMatrix;
}


#ifndef HT_OK_GEN_80x86_CODES


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Following functions are compiled only if we cannot using 80x86 assembly  //
// equvalent codes                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


#define U32xU32_U64(uD1, uD2, QH, QL) {                                     \
                                                                            \
    DWORD x0, x1, x2, x3;                                                   \
                                                                            \
    (x0)=(DWORD)((uD1) & 0xFFFF) * (DWORD)((uD2) & 0xFFFF);                 \
    (x1)=(DWORD)((uD1) >>    16) * (DWORD)((uD2) & 0xFFFF);                 \
    (x2)=(DWORD)((uD1) & 0xFFFF) * (DWORD)((uD2) >>    16);                 \
    (QL)=(DWORD)((x0) >> 16) + ((x1) & 0xFFFF) + ((x2) & 0xFFFF);           \
    (x3)=((DWORD)((uD1)>>16) * (DWORD)((uD2)>>16)) + (DWORD)((QL)>>16);     \
    (QL)=(DWORD)((QL) << 16) | ((x0) & 0xFFFF);                             \
    (QH)=(DWORD)((x1) >> 16) + (DWORD)((x2) >> 16) + (x3);                  \
}

#define NEG_U64(QH, QL)                                                     \
        (DWORD)(QH)=(DWORD)~(DWORD)(QH); (DWORD)(QL)=(DWORD)~(DWORD)(QL);   \
	if (!(++((DWORD)(QL)))) { ++((DWORD)(QH)); }

#define U64AddU64(QH, QL, Q0H, Q0L)                                         \
	if (((DWORD)(QL)+=(DWORD)(Q0L))<(DWORD)(Q0L)) { ++((DWORD)(QH)); }  \
        (DWORD)(QH) += (DWORD)(Q0H)

#define U64AddU32(QH, QL, uD)                                               \
	if (((DWORD)(QL)+=(DWORD)(uD))<(DWORD)(uD)) { ++((DWORD)(QH)); }

#define U64DivFD6_1(xH, xL, uD) {                                           \
        DWORD   xT;                                                         \
	if (((DWORD)(xL)+=(DWORD)FD6_p5)<(DWORD)FD6_p5) { ++((DWORD)(xH)); }\
        (DWORD)(uD)=(DWORD)(((xT=(DWORD)((DWORD)(xH) << 12) |               \
                                 (DWORD)((DWORD)(xL) >> 20)) /              \
                             (DWORD)62500) << 16);                          \
        (DWORD)(uD)|=(DWORD)((DWORD)((DWORD)((xT % (DWORD)62500)<<16) |     \
                                     (DWORD)(((DWORD)(xL)>>4) & 0xffffL)) / \
                             (DWORD)62500);  }




FD6
HTENTRY
MulFD6(
    FD6 Multiplicand,
    FD6 Multiplier
    )

/*++

Routine Description:

    This function multiply two FD6 numbers.

Arguments:

    Multiplicand    - The Multiplicand in FD6 format.

    Multiplier      - The Multiplier in FD6 format.


Return Value:

    No error returned, the return value is the products of multiplicand and
    multiplier.


Author:

    10-Oct-1991 Thu 11:14:24 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    DWORD   xH;
    DWORD   xL;
    DWORD   Result;
    BOOL    Sign;


    if (Sign = (BOOL)(Multiplicand <= 0L)) {

        if (!(Multiplicand = -Multiplicand)) {

            return(0L);                     // if one of them is '0' then...
        }
    }

    if (Multiplier <= 0L) {

        if (Multiplier = -Multiplier) {

            Sign = !Sign;

        } else {

            return(FD6_0);              // if one of them is '0' then...
        }
    }

    if (Multiplicand == FD6_1) {

        Result = Multiplier;

    } else if (Multiplier == FD6_1) {

        Result = Multiplicand;

    } else {

        U32xU32_U64(Multiplicand, Multiplier, xH, xL);
        U64DivFD6_1(xH, xL, Result);
    }

    return((Sign) ? -(FD6)Result : (FD6)Result);
}



DWORD
HTENTRY
U64DivU32RoundUp(
    DWORD   Dividend64H,
    DWORD   Dividend64L,
    DWORD   Divisor32
    )

/*++

Routine Description:

    This function divide a unsigned 64-bit number by a 32-bit unsigned number

Arguments:

    Dividend64H - High 32-bit of a 64-bit unsigned dividend number

    Dividend64L - Low 32-bit of a 64-bit unsigned dividend number

    Divisor32   - 32-bit unsigned divisor number. (must not zero);

Return Value:

    No error returned, the return value is the round up quotient of the
    Divndend/Divisor.

    if Dividend is equal to 0 then a 0 is returned,


Author:

    10-Oct-1991 Thu 11:14:24 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    DWORD   xH;
    DWORD   xL;
    DWORD   xT;
    DWORD   xR;
    WORD    Correct;
    WORD    DvsrL;
    WORD    DvsrH;
    WORD    QH;
    WORD    QL;



    ASSERT(Divisor32 != 0L);


    if ((xL = Dividend64L + (Divisor32 >> 1)) < Dividend64L) {

        xH = ++Dividend64H;

    } else {

        xH = Dividend64H;
    }

    DvsrH = U16_H_U32(Divisor32);

    if ((DvsrL = U16_L_U32(Divisor32)) && (DvsrH)) {

        //
        // Both DvsrH/DvsrL are non-zero
        //

        xT = (DWORD)(QH = (WORD)(xH / (DWORD)DvsrH)) * (DWORD)DvsrL;
        xR = ((xH - ((DWORD)QH * (DWORD)DvsrH)) << 16) | (DWORD)U16_H_U32(xL);

        if ((LONG)xT < 0L) {

            //
            // The overrun just too high, let's reduce it so we can manage it
            // (we like it to have overrun less then 0x80000000L
            //

            QH -= (Correct = (WORD)((xT - xR) / Divisor32));
            xT -= (DWORD)Correct * Divisor32;
        }

        if ((LONG)(xR -= xT) < 0L) {

            --QH;

            if ((LONG)(xR += Divisor32) < 0L) {

                --QH;

                if ((LONG)(xR += Divisor32) < 0L) {

                    --QH;

                    if ((LONG)(xR += Divisor32) < 0L) {

                        --QH;

                        if ((LONG)(xR += Divisor32) < 0L) {

                            --QH;

                            if ((LONG)(xR += Divisor32) < 0L) {

                                --QH;

                                if ((LONG)(xR += Divisor32) < 0L) {

                                    DWORD   Rem;

                                    QH -= (WORD)(NEGDW(xR) / Divisor32);

                                    if (Rem = (DWORD)(NEGDW(xR) % Divisor32)) {

                                        --QH;
                                        xR = Divisor32 - Rem;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        if (U16_H_U32(xR) < DvsrH) {

            xT = (DWORD)(QL = (WORD)(xR / (DWORD)DvsrH)) * (DWORD)DvsrL;
            xR = ((xR - ((DWORD)QL * (DWORD)DvsrH)) << 16) | (xL & 0xffffL);

            if (xR < xT) {

                --QL;

                if ((xR += Divisor32) < xT) {

                    --QL;

                    if ((xR += Divisor32) < xT) {

                        --QL;

                        if ((xR += Divisor32) < xT) {

                            --QL;

                            if ((xR += Divisor32) < xT) {

                                QL -= Correct = (WORD)((xT -= xR)/Divisor32);

                                if (xT > (DWORD)Correct * Divisor32) {

                                    --QL;
                                }
                            }
                        }
                    }
                }
            }

        } else {

            xR = ((DWORD)DvsrL << 16) - ((xR << 16) | (xL & 0xffffL));
            QL = (WORD)(xR / Divisor32);

            if (xR > ((DWORD)QL * Divisor32)) {

                ++QL;
            }

            QL = -QL;
        }

    } else if (DvsrL) {

        QH = (WORD)((xH = (xH << 16) | (xL >> 16)) / (DWORD)DvsrL);
        QL = (WORD)((((xH % (DWORD)DvsrL) << 16) | (xL & 0xffffL)) /
                      (DWORD)DvsrL);

    } else {                                // DvsrL = 0

        QH = (WORD)(xH / (DWORD)DvsrH);
        QL = (WORD)((((xH % (DWORD)DvsrH) << 16) | (xL >> 16)) /
                      (DWORD)DvsrH);
    }

    return(((DWORD)QH << 16) | (DWORD)QL);

}




FD6
HTENTRY
DivFD6(
    FD6 Dividend,
    FD6 Divisor
    )

/*++

Routine Description:

    This function divide two FD6 numbers.

Arguments:

    Dividend    - The Dividend in FD6 format.

    Divisor     - The Divosr in FD6 format.

Return Value:

    No error returned, the return value is the round up quotient of the
    Divndend/Divisor.

    if Dividend is equal to 0 then a 0 is returned,
    if Divisor is equal to zero then Dividend is returned.


Author:

    10-Oct-1991 Thu 11:14:24 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    DWORD   x0;
    DWORD   x1;
    DWORD   xH;
    DWORD   xL;
    BOOL    Sign;


    if (Sign = (BOOL)(Divisor <= FD6_0)) {

        if (!(Divisor = -Divisor)) {

            return((Dividend < 0) ? MAX_FD6 : MIN_FD6);
        }
    }

    if (Divisor == FD6_1) {

        return((Sign) ? -Dividend : Dividend);
    }

    if (Dividend <= 0L) {

        if (Dividend = -Dividend) {

            Sign = (BOOL)!Sign;

        } else {

            return(FD6_0);          // nothing to divide, so return 0
        }
    }

    if (Dividend == Divisor) {

        return((Sign) ? -FD6_1 : FD6_1);
    }

    x0 = (DWORD)U16_L_U32(Dividend) * (DWORD)62500;
    x1 = (DWORD)U16_H_U32(Dividend) * (DWORD)62500;

    xH = (DWORD)U16_H_U32(x1);

    if ((xL = x0 + (x1 << 16)) < x0) {

        ++xH;
    }

    xH = (xH << 4) | (DWORD)(U16_H_U32(xL) >> 12);
    xL <<= 4;

    if (Sign) {

        return(-(FD6)U64DivU32RoundUp(xH, xL, Divisor));

    } else {

        return((FD6)U64DivU32RoundUp(xH, xL, Divisor));
    }
}



FD6
HTENTRY
FD6DivL(
    FD6     Dividend,
    LONG    Divisor
    )

/*++

Routine Description:

    This function divide a FD6 number by a LONG integer.

Arguments:

    Dividend    - The Dividend in FD6 format.

    Divisor     - The Divosr in long format.

Return Value:

    No error returned, the return value is the round up quotient of the
    Divndend/Divisor.

    if Dividend is equal to 0 then a 0 is returned,
    if Divisor is equal to zero then Dividend is returned.


Author:

    10-Oct-1991 Thu 11:14:24 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    DWORD   Quot;
    BOOL    Sign;


    if (Sign = (BOOL)(Divisor <= 0L)) {

        if (!(Divisor = -Divisor)) {

            return(Dividend);           // can not divide by 0, return as 1
        }
    }

    if (Dividend <= 0L) {

        if (Dividend = -Dividend) {

            Sign = (BOOL)!Sign;

        } else {

            return(FD6_0);          // nothing to divide, so return 0
        }
    }

    Quot = ((DWORD)Dividend + (DWORD)((DWORD)Divisor >> 1)) / (DWORD)Divisor;

    return((Sign) ? -(FD6)Quot : (FD6)Quot);
}



FD6
HTENTRY
MulDivFD6Pairs(
    PMULDIVPAIR pMulDivPair
    )

/*++

Routine Description:

    This function multiply TotalFD6Pairs of FD6 numbers and optional divide by
    passed divisor.

Arguments:

    pMulDivPair - Pointer to array of MULDIVPAIR data structure, the first
                  structure in the array tell the count of the FD6 pairs,
                  a Divisor present flag and a Divisor, the FD6 pairs start
                  from second element in the array.

Return Value:

    The return value is the 32-bit FD6 number which is round up from 7th
    decimal points, there is no remainder returned.

    NO ERROR returned, if divisor is zero then it assume no divisor is present,
    if Count of FD6 pairs is zero then it return FD6_0

Author:

    27-Aug-1992 Thu 18:13:55 updated  -by-  Daniel Chou (danielc)
        Re-write to remove variable argument conflict, and make it only passed
        a pointer to the MULDIVPAIR structure array

    10-Oct-1991 Thu 11:14:24 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    FD6     Multiplicand;
    FD6     Multiplier;
    FD6     Divisor;
    DWORD   xH;
    DWORD   xL;
    DWORD   xPH;
    DWORD   xPL;
    DWORD   Result;
    BOOL    Sign;
    INT     cFD6Pairs;


    if (!(cFD6Pairs = (INT)pMulDivPair->Pair1.Info.Size)) {

        return(FD6_0);
    }

    Divisor = FD6_0;

    if (pMulDivPair->Pair1.Info.Flag & MULDIV_HAS_DIVISOR) {

        if ((Divisor = pMulDivPair->Pair2) == FD6_1) {

            Divisor = FD6_0;
        }
    }

    xH = xL = (DWORD)0;

    while (cFD6Pairs--) {

        ++pMulDivPair;

        Multiplicand = pMulDivPair->Pair1.Mul;
        Multiplier   = pMulDivPair->Pair2;

        if (Sign = (BOOL)(Multiplicand <= 0L)) {

            if (!(Multiplicand = -Multiplicand)) {

                continue;           // this one will be zero, check next pair
            }
        }

        if (Multiplier <= 0L) {

            if (Multiplier = -Multiplier) {

                Sign = (BOOL)!Sign;

            } else {

                continue;           // this one will be zero, check next pair
            }
        }

        U32xU32_U64(Multiplicand, Multiplier, xPH, xPL);

        if (Sign) {

            NEG_U64(xPH, xPL);
        }

        U64AddU64(xH, xL, xPH, xPL);

    }

    if (Sign = (BOOL)((LONG)xH < 0)) {

        NEG_U64(xH, xL);
    }

    if (Divisor) {

        if (Divisor < FD6_0) {

            Divisor = -Divisor;
            Sign    = !Sign;
        }

        Result = U64DivU32RoundUp(xH, xL, (DWORD)Divisor);

    } else {

        //
        // No Divisor, so just divide it by FD6_1
        //

        U64DivFD6_1(xH, xL, Result);
    }

    return((Sign) ? -(FD6)Result : (FD6)Result);
}



FD6
HTENTRY
FractionToMantissa(
    FD6     Fraction,
    DWORD   CorrectData
    )

/*++

Routine Description:

    This function take decimal fraction and correct the logarithm mantissa
    between x.xxyyyy x.xxzzzz, where fraction is laid between yyyy to zzzz.

Arguments:

    Fraction        - the fraction number after decimal place, because
                      we have mantissa table up to two decimal places, the
                      correction is necessary because logarithm numbers are
                      no linear.  The number is range from 0.000000-0.999999

    CorrectData     - The correction data which from MantissaCorrectData[]

Return Value:

    No error returned, the return value is the Mantissa value for the fraction
    passed in.


Author:

    10-Oct-1991 Thu 11:14:24 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    DWORD   Mantissa;
    DWORD   Rem;
    INT     Loop;
    WORD    Base;
    WORD    Error;
    WORD    NextErr;
    WORD    CorrL;
    WORD    CorrH;


    //
    // Mantissa Correction Data Bits Usage:
    //
    //
    //       <---High Word---> <----Low Word--->
    //  Bit#  3          2          1          0
    //       10987654 32109876 54321098 76543210
    //       | | | |  | |  |   ||  |  |
    //       | | | |  | |  |   ||  |  +-- x.000 Minimum Difference
    //       | | | |  | |  |   ||  +----- x.001-x.002 (0-7) Correct 1
    //       | | | |  | |  |   |+-------- x.000-x.001 (0-7) Correct 2
    //       | | | |  | |  |   +--------- x.009-y.000 (0-1) Correct 10
    //       | | | |  | |  +------------- x.009-y.000 (0-7) Correct 3
    //       | | | |  | +---------------- x.008-x.009 (0-7) Correct 4
    //       | | | |  +------------------ x.007-x.008 (0-3) Correct 5
    //       | | | +--------------------- x.006-x.007 (0-3) Correct 6
    //       | | +----------------------- x.005-x.006 (0-3) Correct 7
    //       | +------------------------- x.004-x.005 (0-3) Correct 8
    //       +--------------------------- x.003-x.004 (0-3) Correct 9
    //

    CorrL = U16_L_U32(CorrectData);
    CorrH = U16_H_U32(CorrectData);
    Rem   = (DWORD)(Fraction % 100000L);
    Loop  = (INT)(Fraction / 100000L);
    Base  = (WORD)(CorrL & 0x1ff);
    Error = 0;

    NextErr = (WORD)(Base + ((CorrL >>= 9) & 0x07));

    if (Loop--) {

        Error   += NextErr;

        //
        // bit 6, 0x40 = correct 10
        //

        NextErr  = (WORD)(Base + ((CorrL >> 3) & 0x07));

        if (Loop--) {

            Error   += NextErr;
            NextErr  = (WORD)(Base + (CorrH & 0x07));

            if (Loop--) {

                Error   += NextErr;
                NextErr  = (WORD)(Base + ((CorrH >>= 3) & 0x07));

                if (CorrL & 0x40) {

                    CorrH |= 0x2000;        // add in correction 10
                }

                CorrH >>= 1;                // pre-shift for next while

                while (Loop--) {

                    Error += NextErr;
                    NextErr = (WORD)(Base + ((CorrH >>= 2) & 0x03));
                }
            }
        }
    }

    Mantissa = (DWORD)Error +
               ((((Rem * (DWORD)NextErr) >> 1) + 25000L) / 50000L);

    return(FD6FromL(Mantissa));
}




FD6
HTENTRY
MantissaToFraction(
    FD6     Mantissa,
    DWORD   CorrectData
    )

/*++

Routine Description:

    This function take mantissa number and convert it to the decimal fraction

Arguments:

    Mantissa        - the mantissa values which will converted to the the
                      fraction number.

    CorrectData     - The correction data which from MantissaCorrectData[]

Return Value:

    No error returned, the return value is the fraction value for the mantissa
    passed in, it range from 0.000000 - 1.000000


Author:

    10-Oct-1991 Thu 11:14:24 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    static  DWORD   ul100000To900000[] = { 100000L, 200000L, 300000L, 400000L,
                                           500000L, 600000L, 700000L, 800000L,
                                           900000L
                                         };
    DWORD   Fraction;
    SHORT   Index;
    SHORT   Base;
    SHORT   Error;
    SHORT   NextErr;
    WORD    CorrL;
    WORD    CorrH;

    //
    // Mantissa Correction Data Bits Usage:
    //
    //
    //       <---High Word---> <----Low Word--->
    //  Bit#  3          2          1          0
    //       10987654 32109876 54321098 76543210
    //       | | | |  | |  |   ||  |  |
    //       | | | |  | |  |   ||  |  +-- x.000 Minimum Difference
    //       | | | |  | |  |   ||  +----- x.001-x.002 (0-7) Correct 1
    //       | | | |  | |  |   |+-------- x.000-x.001 (0-7) Correct 2
    //       | | | |  | |  |   +--------- x.009-y.000 (0-1) Correct 10
    //       | | | |  | |  +------------- x.009-y.000 (0-7) Correct 3
    //       | | | |  | +---------------- x.008-x.009 (0-7) Correct 4
    //       | | | |  +------------------ x.007-x.008 (0-3) Correct 5
    //       | | | +--------------------- x.006-x.007 (0-3) Correct 6
    //       | | +----------------------- x.005-x.006 (0-3) Correct 7
    //       | +------------------------- x.004-x.005 (0-3) Correct 8
    //       +--------------------------- x.003-x.004 (0-3) Correct 9
    //

    Error    = (SHORT)FD6ToL(Mantissa);         // only need 16 bits
    CorrL    = U16_L_U32(CorrectData);
    CorrH    = U16_H_U32(CorrectData);
    Base     = (SHORT)(CorrL & 0x1ff);
    Fraction = 0L;

    Index = 1;                                  // assume 1
    NextErr = (WORD)(Base + ((CorrL >>= 9) & 0x07));

    if ((Error -= NextErr) > 0) {

        ++Index;

        //
        // bit 6, 0x40 = correct 10
        //

        NextErr = (WORD)(Base + ((CorrL >> 3) & 0x07));

        if ((Error -= NextErr) > 0) {

            ++Index;
            NextErr = (WORD)(Base + (CorrH & 0x07));

            if ((Error -= NextErr) > 0) {

                ++Index;
                NextErr = (WORD)(Base + ((CorrH >>= 3) & 0x07));

                if (CorrL & 0x40) {

                    CorrH |= 0x2000;        // add in correction 10
                }

                CorrH >>= 1;                // pre-shift for next while

                while ((Error -= NextErr) > 0) {

                    ++Index;
                    NextErr = (WORD)(Base + ((CorrH >>= 2) & 0x03));
                }
            }
        }
    }

    if (Error) {

        --Index;
        Fraction = (((((DWORD)(Error + NextErr) * 50000L) << 1) +
                    (DWORD)(NextErr >> 1)) / (DWORD)NextErr);
    }

    if (Index--) {

        Fraction += ul100000To900000[Index];
    }

    return(FD6FromL(Fraction));
}




DWORD
HTENTRY
ComputeChecksum(
    LPBYTE  pData,
    DWORD   InitialChecksum,
    DWORD   DataSize
    )

/*++

Routine Description:

    This function compute a 32-bit check sum for the pData passed in

Arguments:

    pData           - Pointer to data which checksum to be computed

    InitChecksum    - Initial checksum value, this value can be a checksum
                      value from last computed result, so it can generate a
                      single checksum from a large linked data.

    DataSize        - pData size in bytes


    The Checksum is forming by two 16-bit checksum octets R,S and n is the
    octet number, the addition is performed in one's complement arithmic.

    S(n)     = S(n-1) + Data(n)
    R(n)     = R(n-1) + S(n)

    Checksum = (DWORD)(R << 16) | (DWORDS;


Return Value:

    return value is a 32-bit checksum


Author:

    27-Apr-1992 Mon 18:36:03 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    W2B     w2b;
    WORD    OctetR;
    WORD    OctetS;


    //
    // We using two 16-bit checksum octets with one's complement arithmic
    //

    //
    // 1. Get initial values for OctetR and OctetS
    //

    OctetR = HIWORD(InitialChecksum);
    OctetS = LOWORD(InitialChecksum);

    //
    // 2. Since we doing 16-bit at a time, we will pack high byte with zero
    //    if data size in bytes is odd number
    //

    if (DataSize & 0x01) {

        OctetR += (OctetS += (WORD)*pData++);
    }

    //
    // 3. Now forming checksum 16-bit at a time
    //

    DataSize >>= 1;

    while (DataSize--) {

        w2b.b[0] = *pData++;
        w2b.b[1] = *pData++;

        OctetR += (OctetS += w2b.w);
    }

    return((DWORD)((DWORD)OctetR << 16) | (DWORD)OctetS);
}



#endif  // HT_OK_GEN_80x86_CODES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htmemory.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htmemory.c


Abstract:

    This module supports the memory allocation functions for the halftone
    process, these functions are provided so that it will compatible with
    window's LocalAlloc/LocalFree memory allocation APIs.


Author:

    18-Jan-1991 Fri 17:02:42 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]

    The memory allocation may be need to change depends on the operating
    system used, currently it is conform to the NT and WIN32, the memory
    address simply treated as flat 32-bit location.

Revision History:


--*/


#define DBGP_VARNAME        dbgpHTMemory


#include "htp.h"
#include "htmapclr.h"



#define DBGP_ALLOC              0x00000001
#define DBGP_SHOWMEMLINK        0x00000002


DEF_DBGPVAR(BIT_IF(DBGP_ALLOC,              0)  |
            BIT_IF(DBGP_SHOWMEMLINK,        0))


#if DBG_MEMORY_TRACKING

#define MEM_TRACK_ID    (DWORD)'HTMT'


typedef struct _MEMLINK {
    DWORD               ID;
    PDEVICECOLORINFO    pDCI;
    LPVOID              pMem;
    DW2W4B              Tag;
    LONG                cb;
    struct _MEMLINK *pNext;
    } MEMLINK, *PMEMLINK;


static DWORD    cbTotAlloc = 0;
static PMEMLINK pMHGlobal = NULL;

LONG        cbMemTot = 0;
LONG        cbMemMax = 0;

#define TAG2DW(t)           ((((t) >> 24) & 0xFF) | (((t) >> 8) & 0xFF00))



VOID
DumpMemLink(
    LPVOID  pInfo,
    DWORD   Tag
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    24-Feb-1999 Wed 20:43:39 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PDEVICECOLORINFO    pDCI = (PDEVICECOLORINFO)pInfo;
    PMEMLINK            pML;
    BOOL                HasShow = FALSE;


    if (pML = (pDCI) ? pDCI->pMemLink : pMHGlobal) {

        DWORD   dwDbg = DBGP_VARNAME;
        UINT    i = 0;
        LONG    cb = 0;


        if ((Tag) && (Tag != 0xFFFFFFFF)) {

            Tag = TAG2DW(Tag);
        }

        do {

            BOOL    ShouldFree;

            ++i;
            DBGP_VARNAME = dwDbg;

            if (Tag == 0xFFFFFFFF) {

                ShouldFree = FALSE;

            } else if (!Tag) {

                ShouldFree = FALSE;
                DBGP_VARNAME |= DBGP_SHOWMEMLINK;

            } else {

                ShouldFree = (BOOL)(TAG2DW(pML->Tag.dw) >= Tag);

                if (ShouldFree) {

                    DBGP_VARNAME |= DBGP_SHOWMEMLINK;

                } else {

                    DBGP_VARNAME &= ~DBGP_SHOWMEMLINK;
                }
            }

            if ((DBGP_VARNAME & DBGP_SHOWMEMLINK) && (!HasShow)) {

                DBGP_IF(DBGP_SHOWMEMLINK,
                        DBGP("------BEGIN-- cbMemTot=%ld, cbMemMax=%ld----------------"
                            ARGDW((pDCI) ? pDCI->cbMemTot : cbMemTot)
                            ARGDW((pDCI) ? pDCI->cbMemMax : cbMemMax)));

                HasShow = TRUE;
            }

            DBGP_IF(DBGP_SHOWMEMLINK,
                    DBGP("%hsMemLink(%3ld): pDCI=%p, Tag=%c%c%c%c, pMem=%p, cb=%7ld [%7ld]"
                        ARGPTR((ShouldFree) ? "\n*Memory Not Free*\n" : "")
                        ARGDW(i) ARGPTR(pML->pDCI)
                        ARGDW(pML->Tag.b[0])
                        ARGDW(pML->Tag.b[1])
                        ARGDW(pML->Tag.b[2])
                        ARGDW(pML->Tag.b[3])
                        ARGPTR(pML->pMem) ARGDW(pML->cb)
                        ARGDW(cb += pML->cb)));

        } while (pML = pML->pNext);

        if (HasShow) {

            DBGP_IF(DBGP_SHOWMEMLINK,
                    DBGP("------END---------------------------------------\n"));
        }

        DBGP_VARNAME = dwDbg;
    }
}



LPVOID
HTAllocMem(
    LPVOID  pInfo,
    DWORD   Tag,
    DWORD   Flags,
    DWORD   cb
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    24-Feb-1999 Wed 20:16:59 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PDEVICECOLORINFO    pDCI = (PDEVICECOLORINFO)pInfo;
    LPBYTE              pb;
    PMEMLINK            pML;
    PMEMLINK            pMH;
    PMEMLINK            *ppMH;
    PLONG               pTot;
    PLONG               pMax;
    DWORD               cbTot;




#ifdef UMODE
    pb = LocalAlloc(Flags, cb + sizeof(MEMLINK));
#else
    pb = EngAllocMem((Flags == LPTR) ? FL_ZERO_MEMORY : 0,
                     cb + sizeof(MEMLINK) ,
                     Tag);

#endif
    if (pDCI) {

        ppMH = &((PMEMLINK)pDCI->pMemLink);
        pTot = &(pDCI->cbMemTot);
        pMax = &(pDCI->cbMemMax);

    } else if (Tag == HTMEM_HT_DHI) {

        pMH  = NULL;
        ppMH = &pMH;

    } else {

        ppMH = &pMHGlobal;
        pTot = &cbMemTot;
        pMax = &cbMemMax;
    }

    if (pb) {

        if (!(pML = *ppMH)) {

            pML   =
            *ppMH = (PMEMLINK)pb;

        } else {

            while (pML->pNext) {

                pML = pML->pNext;
            }

            pML->pNext = (PMEMLINK)pb;
            pML        = pML->pNext;
        }

        pb += sizeof(MEMLINK);

        if ((!pDCI) && (Tag == HTMEM_HT_DHI)) {

            pDCI           = &(((PHT_DHI)pb)->DCI);
            pDCI->pMemLink = *ppMH;
            pDCI->cbMemTot =
            pDCI->cbMemMax = (LONG)cb;
            pMax           = &pDCI->cbMemMax;
            pTot           = &pDCI->cbMemTot;

        } else {

            if ((*pTot += (LONG)cb) > *pMax) {

                *pMax = *pTot;
            }
        }

        pML->ID      = MEM_TRACK_ID;
        pML->pDCI    = pDCI;
        pML->pMem    = pb;
        pML->cb      = (LONG)cb;
        pML->Tag.dw  = Tag;
        pML->pNext   = NULL;

        DBGP_IF(DBGP_ALLOC,
                DBGP("%p=MemoryAlloc(pDCI=%p [%c%c%c%c] %7ld bytes): Tot=%7ld, Max=%7ld"
                    ARGPTR(pb) ARGPTR(pDCI)
                    ARGDW(pML->Tag.b[0]) ARGDW(pML->Tag.b[1])
                    ARGDW(pML->Tag.b[2]) ARGDW(pML->Tag.b[3])
                    ARGDW(cb) ARGDW(*pTot) ARGDW(*pMax)));

        DumpMemLink(pDCI, 0xFFFFFFFF);

    } else {

        DW2W4B  dw4b;

        dw4b.dw = Tag;

        DBGP("*NO MEMORY* Allocate %ld bytes of Tag=%c%c%c%c FAILED"
                ARGDW(cb)
                ARGDW(dw4b.b[0]) ARGDW(dw4b.b[1])
                ARGDW(dw4b.b[2]) ARGDW(dw4b.b[3]));

        DumpMemLink(pDCI, 0);
    }

    return((LPVOID)pb);
}




LPVOID
HTFreeMem(
    LPVOID  pMem
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    24-Feb-1999 Wed 20:24:53 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PDEVICECOLORINFO    pDCI;
    PLONG               pTot;
    PLONG               pMax;
    PMEMLINK            *ppMH;
    PMEMLINK            pML;
    PMEMLINK            pMP;
    UINT                Found = 0;
    LPVOID              pv;


    if ((pMem)                                              &&
        (pML = (PMEMLINK)((LPBYTE)pMem - sizeof(MEMLINK)))  &&
        (pML->ID == MEM_TRACK_ID)) {

        if (pDCI = pML->pDCI) {

            ppMH = &((PMEMLINK)(pDCI->pMemLink));
            pTot = &pDCI->cbMemTot;
            pMax = &pDCI->cbMemMax;

        } else {

            ppMH = &pMHGlobal;
            pTot = &cbMemTot;
            pMax = &cbMemMax;
        }

    } else {

        DBGP("Error: FreeMemeory(%p) Invalid Memory Address" ARGPTR(pMem));

        return(NULL);
    }

    if ((ppMH) && (pML = pMP = *ppMH)) {

        while ((!Found) && (pML)) {

            if (pML->pMem == pMem) {

                //
                // Find it, take it out from link
                //

                if (pML == *ppMH) {

                    ASSERT(*ppMH == pMP);

                    *ppMH = pML->pNext;
                    Found = 2;

                } else {

                    pMP->pNext = pML->pNext;
                    Found      = 1;
                }

            } else {

                pMP = pML;
                pML = pML->pNext;
            }
        }
    }

    if (!Found) {

        DBGP("Error: FreeMemeory(%p) without Allocating it" ARGPTR(pMem));

        DumpMemLink(pDCI, 0);

    } else {

        (LPBYTE)pMem -= sizeof(MEMLINK);

        if ((*pTot -= pML->cb) < 0) {

            DBGP("Error: FreeMemeory(%p) Free too much memory=%ld"
                    ARGPTR(pMem) ARGDW(*pTot));

            DumpMemLink(pDCI, 0);
        }

        if ((pML->Tag.dw == HTMEM_HT_DHI)       ||
            (pML->Tag.dw == HTMEM_DevClrAdj)    ||
            (*ppMH == NULL)) {

            DumpMemLink(pDCI, pML->Tag.dw);
        }

        DBGP_IF(DBGP_ALLOC,
                DBGP("*%p=MemoryFree(pDCI=%p [%c%c%c%c] %7ld bytes): Tot=%7ld, Max=%7ld"
                    ARGPTR(pML->pMem) ARGPTR(pDCI)
                    ARGDW(pML->Tag.b[0]) ARGDW(pML->Tag.b[1])
                    ARGDW(pML->Tag.b[2]) ARGDW(pML->Tag.b[3])
                    ARGDW(pML->cb) ARGDW(*pTot) ARGDW(*pMax)));

        DumpMemLink(pDCI, 0xFFFFFFFF);

#ifdef UMODE
        pv = (LPVOID)LocalFree((HLOCAL)pMem);
#else
        EngFreeMem(pMem);
        pv = NULL;
#endif
    }

    return((LPVOID)pv);
}


#endif



BOOL
HTENTRY
CompareMemory(
    LPBYTE  pMem1,
    LPBYTE  pMem2,
    DWORD   Size
    )

/*++

Routine Description:

    This is our version of memcmp


Arguments:

    pMem1   - Pointer to the first set of memory to be compared

    pMem2   - Pointer to the second set of memory to be compared

    Size    - Size of pMem1 and pMem2 point


Return Value:

    TRUE if memory is the same, FALSE otherwise

Author:

    13-Mar-1995 Mon 12:07:13 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    while (Size--) {

        if (*pMem1++ != *pMem2++) {

            return(FALSE);
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htmath.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htmath.h


Abstract:


    This module contains the declaration of the halftone math module.


Author:
    28-Mar-1992 Sat 20:57:11 updated  -by-  Daniel Chou (danielc)
        Support FD6 decimal fixed format (upgrade forom UDECI4) for internal
        usage.

    16-Jan-1991 Wed 11:01:46 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:

    10-Oct-1991 Thu 10:00:56 updated  -by-  Daniel Chou (danielc)

        Delete MANTISSASEARCHTABLE structure which repalced with one time
        loop up.


--*/



#ifndef _HTMATH_
#define _HTMATH_

#ifdef  HTMATH_LIB

#undef  HTENTRY
#define HTENTRY     FAR

#ifdef  ASSERT
#undef  ASSERT
#endif

#ifdef  ASSERTMSG
#undef  ASSERTMSG
#endif

#define ASSERT(exp)     assert(exp)
#define ASSERTMSG(msg)  assert(msg)

#include <assert.h>

#endif

//
// Define Fix Decimal 6 places type, the FD6 Number is a FIXED 6 decimal point
// number.  For example 123456 = 0.123456 -12345678 = -12.345678, because the
// FD6 number using total of 32-bit signed number this leads to maximum FD6
// number = 2147.4836476 and minimum FD6 number is -2147.483648
//
//

typedef long            FD6;
typedef FD6 FAR         *PFD6;

#define SIZE_FD6        sizeof(FD6)

#define FD6_0           (FD6)0
#define FD6_1           (FD6)1000000


#define FD6_p000001     (FD6)(FD6_1 / 1000000)
#define FD6_p000005     (FD6)(FD6_1 / 200000)
#define FD6_p00001      (FD6)(FD6_1 / 100000)
#define FD6_p00005      (FD6)(FD6_1 / 20000)
#define FD6_p0001       (FD6)(FD6_1 / 10000)
#define FD6_p0005       (FD6)(FD6_1 / 2000)
#define FD6_p001        (FD6)(FD6_1 / 1000)
#define FD6_p005        (FD6)(FD6_1 / 200
#define FD6_p01         (FD6)(FD6_1 / 100)
#define FD6_p05         (FD6)(FD6_1 / 20)
#define FD6_p1          (FD6)(FD6_1 / 10)
#define FD6_p5          (FD6)(FD6_1 / 2)
#define FD6_2           (FD6)(FD6_1 * 2)
#define FD6_3           (FD6)(FD6_1 * 3)
#define FD6_4           (FD6)(FD6_1 * 4)
#define FD6_5           (FD6)(FD6_1 * 5)
#define FD6_6           (FD6)(FD6_1 * 6)
#define FD6_7           (FD6)(FD6_1 * 7)
#define FD6_8           (FD6)(FD6_1 * 8)
#define FD6_9           (FD6)(FD6_1 * 9)
#define FD6_10          (FD6)(FD6_1 * 10)
#define FD6_100         (FD6)(FD6_1 * 100)
#define FD6_1000        (FD6)(FD6_1 * 1000)



#define FD6_MIN         (FD6)-2147483648
#define FD6_MAX         (FD6)2147483647

#define UDECI4ToFD6(x)  (FD6)((FD6)(DWORD)(x) * (FD6)100)
#define DECI4ToFD6(x)   (FD6)((FD6)(x) * (FD6)100)
#define INTToFD6(i)     (FD6)((LONG)(i) * (LONG)FD6_1)


//
// MATRIX3x3
//
//  a 3 x 3 matrix definitions as
//
//      | Xr Xg Xb |   | Matrix[0][0]  Matrix[0][1]  Matrix[0][2] |
//      | Yr Yg Yb | = | Matrix[1][0]  Matrix[1][1]  Matrix[1][2] |
//      | Zr Zg Zb |   | Matrix[2][0]  Matrix[2][1]  Matrix[2][2] |
//
//  Notice each number is a FD6 value.
//

typedef struct _MATRIX3x3 {
    FD6     m[3][3];
    } MATRIX3x3, FAR *PMATRIX3x3;

//
// This is used for the MulDivFD6Pairs()'s TotalFD6Pairs parameter
//

typedef struct _MULDIVCOUNT {
    WORD    Size;
    WORD    Flag;
    } MULDIVCOUNT;

typedef struct _MULDIVPAIR {
    union {
        MULDIVCOUNT Info;
        FD6         Mul;
        } Pair1;

    FD6 Pair2;
    } MULDIVPAIR, FAR *PMULDIVPAIR;


#define MULDIV_NO_DIVISOR               0x0000
#define MULDIV_HAS_DIVISOR              0x0001

#define MAKE_MULDIV_SIZE(ap, c)         (ap)[0].Pair1.Info.Size=(WORD)(c)
#define MAKE_MULDIV_FLAG(ap, f)         (ap)[0].Pair1.Info.Flag=(WORD)(f)
#define MAKE_MULDIV_INFO(ap,c,f)        MAKE_MULDIV_SIZE(ap, c);            \
                                        MAKE_MULDIV_FLAG(ap, f)
#define MAKE_MULDIV_DVSR(ap,dvsr)       (ap)[0].Pair2=(FD6)(dvsr)
#define MAKE_MULDIV_PAIR(ap,i,p1,p2)    (ap)[i].Pair1.Mul=(p1);             \
                                        (ap)[i].Pair2=(p2)

//
// Following defined is used for the RaisePower()
//
//

#define RPF_RADICAL      W_BITPOS(0)
#define RPF_INTEXP       W_BITPOS(1)


#define Power(b,i)      RaisePower((FD6)(b), (FD6)(i), 0)
#define Radical(b,i)    RaisePower((FD6)(b), (FD6)(i), RPF_RADICAL)

#define Square(x)       MulFD6((x), (x))
#define SquareRoot(x)   RaisePower((FD6)(x), (FD6)2, RPF_RADICAL | RPF_INTEXP)
#define CubeRoot(x)     RaisePower((FD6)(x), (FD6)3, RPF_RADICAL | RPF_INTEXP)

//
// Following two marcos make up the Nature Logarithm and Exponential functions
// the nature logarithm has base approximate to 2.718282 (2.718281828)
//
//  LogNature(x)   = Log10(x) / Log10(2.718281828)
//                 = Log10(x) / (1.0 / 0.434294482)
//                 = Log10(x) * 2.302585093
//                 = Log10(x) * 2.302585        <== FD6 Approximation
//
//                              x
//  Exponential(x) = 2.718281828
//                 = Power(2.718282, x)         <== FD6 Approximation
//

#define NATURE_LOG_BASE     (FD6)2718282
#define NATURE_LOG_SCALE    (FD6)2302585
#define LogN(x)             (FD6)MulFD6(Log((x), NATURE_LOG_SCALE)
#define Exp(x)              (FD6)Power(NATURE_LOG_BASE, (x))

//
// These functions are defined as macros for faster excess
//
// Radical is the root function which 'x' is the Radicand, Index is the
// radical index
//


//
// This macro multiply a FD6 number by a LONG integer.  The 'Num' is FD6
// Number, and 'l' is a long integer.
//

#define FD6xL(Num, l)       (FD6)((LONG)(Num) * (LONG)l)


//
// CIE Y <-> L Conversion
//

#define CIE_L2I(L)      (((L) > (FD6)79996) ?                               \
                            Cube(DivFD6((L) + (FD6)160000, (FD6)1160000)) : \
                            DivFD6((L), (FD6)9033000))
#define CIE_y3I2L(Y,y3) (((Y) > (FD6)8856) ?                                \
                            MulFD6((y3),(FD6)1160000) - (FD6)160000  :      \
                            MulFD6((Y), (FD6)9033000))
#define CIE_I2L(Y)      CIE_y3I2L(Y, CubeRoot(Y))


//
// Function Prototype
//

#ifdef HT_OK_GEN_80x86_CODES

FD6
HTENTRY
Cube(
    FD6 Number
    );

#else

#define Cube(x)     MulFD6((x), Square(x))

#endif


FD6
HTENTRY
Log(
    FD6 Number
    );

FD6
HTENTRY
AntiLog(
    FD6 Number
    );

FD6
HTENTRY
RaisePower(
    FD6     BaseNumber,
    FD6     Exponent,
    WORD    Flags
    );


BOOL
HTENTRY
ComputeInverseMatrix3x3(
    PMATRIX3x3  pInMatrix,
    PMATRIX3x3  pOutMatrix
    );

VOID
HTENTRY
ConcatTwoMatrix3x3(
    PMATRIX3x3  pConcat,
    PMATRIX3x3  pMatrix,
    PMATRIX3x3  pOutMatrix
    );

FD6
HTENTRY
MulFD6(
    FD6 Multiplicand,
    FD6 Multiplier
    );

FD6
HTENTRY
DivFD6(
    FD6 Dividend,
    FD6 Divisor
    );

FD6
HTENTRY
FD6DivL(
    FD6     Dividend,
    LONG    Divisor
    );

FD6
HTENTRY
MulDivFD6Pairs(
    PMULDIVPAIR pMulDivPair
    );

FD6
HTENTRY
FractionToMantissa(
    FD6     Fraction,
    DWORD   CorrectData
    );

FD6
HTENTRY
MantissaToFraction(
    FD6     Mantissa,
    DWORD   CorrectData
    );

DWORD
HTENTRY
ComputeChecksum(
    LPBYTE  pData,
    DWORD   InitialChecksum,
    DWORD   DataSize
    );


#endif  // _HTMATH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htmapclr.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htmapclr.h


Abstract:

    This module contains all halftone color mapping constants for the
    htmapclr.c


Author:
    28-Mar-1992 Sat 20:56:27 updated  -by-  Daniel Chou (danielc)
        Add in ULDECI4 type, to store the stretchfacor (source -> dest)
        add StretchFactor in StretchInfo data structure.
        Add support for StretchFactor (ULDECI4 format), so we can internally
        turn off VGA16 when the bitmap is badly compressed.

    29-Jan-1991 Tue 10:29:04 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:


--*/


#ifndef _HTMAPCLR_
#define _HTMAPCLR_

#include "htmath.h"

#define DO_CACHE_DCI            0

//
// Halftone process's DECI4 vlaues for the WHITE/BLACK/GRAY
//

#define DECI4_ONE       (DECI4)10000
#define DECI4_ZERO      (DECI4)0
#define LDECI4_ONE      (LDECI4)10000
#define LDECI4_ZERO     (LDECI4)0
#define STD_WHITE       DECI4_ONE
#define STD_BLACK       DECI4_ZERO
#define LSTD_WHITE      LDECI4_ONE
#define LSTD_BLACK      LDECI4_ZERO

#define __SCALE_FD62B(f,l,d,b)  (BYTE)(((((f)-(l))*(b))+((d)>>1))/(d))
#define RATIO_SCALE(p,l,h)      DivFD6(p - l, h - l)
#define SCALE_FD62B(f,l,h,b)    __SCALE_FD62B(f,l,(h)-(l),b)
#define SCALE_FD6(f,b)          __SCALE_FD62B(f,FD6_0,FD6_1,b)
#define SCALE_FD62B_DIF(c,d,b)  (BYTE)((((c)*(b))+((d)>>1))/(d))
#define SCALE_INT2B(c,r,b)      (BYTE)((((c)*(b))+((r)>>1))/(r))


//
// The following FD6 number are used in the color computation, using #define
// for easy reading
//


#define FD6_1p16            (FD6)1160000
#define FD6_p16             (FD6)160000
#define FD6_p166667         (FD6)166667
#define FD6_7p787           (FD6)7787000
#define FD6_16Div116        (FD6)137931
#define FD6_p008856         (FD6)8856
#define FD6_p068962         (FD6)68962
#define FD6_p079996         (FD6)79996
#define FD6_9p033           (FD6)9033000
#define FD6_p4              (FD6)400000



#define UDECI4_NTSC_GAMMA   (UDECI4)22000
#define FD6_NTSC_GAMMA      UDECI4ToFD6(UDECI4_NTSC_GAMMA)


#define NORMALIZED_WHITE            FD6_1
#define NORMALIZED_BLACK            FD6_0
#define CLIP_TO_NORMALIZED_BW(x)    if ((FD6)(x) < FD6_0) (x) = FD6_0;  \
                                    if ((FD6)(x) > FD6_1) (x) = FD6_1

#define DECI4AdjToFD6(a,f)          (FD6)((FD6)(a) * (FD6)(f) * (FD6)100)

#define VALIDATE_CLR_ADJ(a)         if ((a) < MIN_RGB_COLOR_ADJ) {          \
                                        (a) = MIN_RGB_COLOR_ADJ;            \
                                    } else if ((a) > MAX_RGB_COLOR_ADJ) {   \
                                        (a) = MAX_RGB_COLOR_ADJ; }

#define LOG_INTENSITY(i)            ((FD6)(i) > (FD6)120000) ?              \
                                        (NORMALIZED_WHITE + Log((i))) :     \
                                        (MulFD6((FD6)(i), (FD6)659844L))

#define RANGE_CIE_xy(x,y)   if ((x) < CIE_x_MIN) (x) = CIE_x_MIN; else  \
                            if ((x) > CIE_x_MAX) (x) = CIE_x_MAX;       \
                            if ((y) < CIE_y_MIN) (y) = CIE_y_MIN; else  \
                            if ((y) > CIE_y_MAX) (y) = CIE_y_MAX        \

#define MAX_OF_3(max,a,b,c) if ((c)>((max)=(((a)>(b)) ? (a) : (b)))) (max)=(c)
#define MIN_OF_3(min,a,b,c) if ((c)<((min)=(((a)<(b)) ? (a) : (b)))) (min)=(c)

#define CIE_NORMAL_MONITOR          0
#define CIE_NTSC                    1
#define CIE_CIE                     2
#define CIE_EBU                     3
#define CIE_NORMAL_PRINTER          4


//
// For  1 Bit per pel we have maximum     2 mapping table entries
// For  4 Bit per pel we have maximum    16 mapping table entries
// For  8 Bit per pel we have maximum   256 mapping table entries
// For 16 Bit per pel we have maximum 65536 mapping table entries
//
// For 24 bits per pel, we will clip each color (0 - 255) into 0-15 (16 steps)
// and provided a total 4096 colors.
//

#define CUBE_ENTRIES(c)         ((c) * (c) * (c))
#define HT_RGB_MAX_COUNT        32
#define HT_RGB_CUBE_COUNT       CUBE_ENTRIES(HT_RGB_MAX_COUNT)

#define HT_RGB_R_INC            1
#define HT_RGB_G_INC            HT_RGB_MAX_COUNT
#define HT_RGB_B_INC            (HT_RGB_MAX_COUNT * HT_RGB_MAX_COUNT)


#define VGA256_R_IDX_MAX        5
#define VGA256_G_IDX_MAX        5
#define VGA256_B_IDX_MAX        5
#define VGA256_M_IDX_MAX        25

#define VGA256_CUBE_SIZE        ((VGA256_R_IDX_MAX + 1) *                   \
                                 (VGA256_G_IDX_MAX + 1) *                   \
                                 (VGA256_B_IDX_MAX + 1))
#define VGA256_MONO_SIZE        (VGA256_M_IDX_MAX + 1)

#define VGA256_M_IDX_START      VGA256_CUBE_SIZE

#define VGA256_R_CUBE_INC       1
#define VGA256_G_CUBE_INC       (VGA256_R_IDX_MAX + 1)
#define VGA256_B_CUBE_INC       (VGA256_G_CUBE_INC * (VGA256_G_IDX_MAX + 1))
#define VGA256_W_CUBE_INC       (VGA256_R_CUBE_INC + VGA256_G_CUBE_INC +    \
                                 VGA256_B_CUBE_INC)

#define VGA256_R_INT_INC        (FD6)(FD6_1 / VGA256_R_IDX_MAX)
#define VGA256_G_INT_INC        (FD6)(FD6_1 / VGA256_G_IDX_MAX)
#define VGA256_B_INT_INC        (FD6)(FD6_1 / VGA256_B_IDX_MAX)


#define VGA256_PALETTE_COUNT    (VGA256_CUBE_SIZE + VGA256_MONO_SIZE)

#define RGB555_C_LEVELS         32
#define RGB555_P1_CUBE_INC      (RGB555_C_LEVELS * RGB555_C_LEVELS)
#define RGB555_P2_CUBE_INC      RGB555_C_LEVELS
#define RGB555_P3_CUBE_INC      1


typedef HANDLE                  HTMUTEX;
typedef HTMUTEX                 *PHTMUTEX;


#ifdef UMODE

#define CREATE_HTMUTEX()        (HTMUTEX)CreateMutex(NULL, FALSE, NULL)
#define ACQUIRE_HTMUTEX(x)      WaitForSingleObject((HANDLE)(x), (DWORD)~0)
#define RELEASE_HTMUTEX(x)      ReleaseMutex((HANDLE)(x))
#define DELETE_HTMUTEX(x)       CloseHandle((HANDLE)(x))

#else

#define CREATE_HTMUTEX()        (HTMUTEX)EngCreateSemaphore()
#define ACQUIRE_HTMUTEX(x)      EngAcquireSemaphore((HSEMAPHORE)(x))
#define RELEASE_HTMUTEX(x)      EngReleaseSemaphore((HSEMAPHORE)(x))
#define DELETE_HTMUTEX(x)       EngDeleteSemaphore((HSEMAPHORE)(x))

#endif

#define NTSC_R_INT      299000
#define NTSC_G_INT      587000
#define NTSC_B_INT      114000



typedef struct _RGBTOPRIM {
    BYTE    Flags;
    BYTE    ColorTableType;
    BYTE    SrcRGBSize;
    BYTE    DevRGBSize;
    } RGBTOPRIM;

typedef struct _FD6RGB {
    FD6     R;
    FD6     G;
    FD6     B;
    } FD6RGB, FAR *PFD6RGB;

typedef struct _FD6XYZ {
    FD6     X;
    FD6     Y;
    FD6     Z;
    } FD6XYZ, FAR *PFD6XYZ;

typedef struct _FD6PRIM123 {
    FD6 p1;
    FD6 p2;
    FD6 p3;
    } FD6PRIM123, FAR *PFD6PRIM123;


#define HTCF_STATIC_PTHRESHOLDS         0x01

typedef struct _HTCELL {
    BYTE    Flags;
    BYTE    HTPatIdx;
    WORD    wReserved;
    WORD    cxOrg;
    WORD    cxReal;
    WORD    Width;
    WORD    Height;
    DWORD   Size;
    LPBYTE  pThresholds;
    } HTCELL, *PHTCELL;


#define MAPF_MONO_PRIMS     0x00000001
#define MAPF_SKIP_LABLUV    0x00000002


#if DBG
    #define DO_REGTEST      0
#else
    #define DO_REGTEST      0
#endif


typedef struct _REGDATA {
    WORD    DMin;
    WORD    DMax;
    FD6     LMin;
    FD6     LMax;
    FD6     DMinMul;
    FD6     DMaxAdd;
    FD6     DMaxMul;
    FD6     DenAdd;
    FD6     DenMul;
    } REGDATA, *PREGDATA;

#define REG_DMIN_ADD        FD6_0


#define REG_BASE_GAMMA      (FD6) 932500
#define REG_GAMMA_IDX_BASE  (FD6)1050000
#define MASK8BPP_GAMMA_DIV  (FD6) 932500

#define GET_REG_GAMMA(Idx)  MulFD6(REG_BASE_GAMMA,                          \
                                   RaisePower(REG_GAMMA_IDX_BASE,           \
                                              (FD6)(Idx) - (FD6)3,          \
                                              RPF_INTEXP))

#define K_REP_START         (FD6) 666667
#define K_REP_POWER         (FD6)2000000

//
// Possible values:
//
//  R           G           B
//  -------     -------     -------
//  0.9859      1.0100      0.9859
//  0.9789      1.0150      0.9789
//  0.9720      1.0200      0.9720
//


#define SCM_R_GAMMA_MUL     (FD6) 978900
#define SCM_G_GAMMA_MUL     (FD6)1015000
#define SCM_B_GAMMA_MUL     (FD6) 978900

#define GRAY_MAX_IDX                0xFFFF

#define IDXBGR_2_GRAY_BYTE(p,b,g,r) (BYTE)((p[0+(b)]+p[256+(g)]+p[512+(r)])>>8)
#define BGR_2_GRAY_WORD(b,g,r)      ((b)+(g)+(r))


//
// DEVCLRADJ
//
//  This data structure describe how the color adjustment should be made
//  input RGB color and output device.
//
//  Flags                       - No flag is defined.
//
//  RedPowerAdj                 - The n-th power applied to the red color
//                                before any other color adjustment, this is
//                                a UDECI4 value. (0.0100 - 6.500)
//
//                                  For example if the RED = 0.8 (DECI4=8000)
//                                  and the RedPowerGammaAdjustment = 0.7823
//                                  (DECI4 = 7823) then the red is equal to
//
//                                         0.7823
//                                      0.8        = 0.8398
//
//  GreenPowerAdj               - The n-th power applied to the green color
//                                before any other color adjustment, this is
//                                a UDECI4 value. (0.0100 - 6.5000)
//
//  BluePowerAdj                - The n-th power applied to the blue color
//                                before any other color adjustment, this is
//                                a UDECI4 value. (0.0100 - 6.5000)
//
//                                NOTE: if the PowerGammaAdjustmenst values are
//                                      equal to 1.0 (DECI4 = 10000) then no
//                                      adjustment will be made, since any
//                                      number raised to the 1 will be equal
//                                      to itself, if this number is less than
//                                      0.0100 (ie 100) or greater than 6.5000
//                                      (ie. 65000) then it default to 1.0000
//                                      (ie. 10000) and no adjustment is made.
//
//  BrightnessAdj               - The brightness adjustment, this is a DECI4
//                                number range from -10000 (-1.0000) to
//                                10000 (1.0000).  The brightness is adjusted
//                                by apply to overall intensity for the primary
//                                colors.
//
//  ContrastAdj                 - Primary color contrast adjustment, this is
//                                a DECI4 number range from -10000 (-1.0000)
//                                to 10000 (1.0000).  The primary color
//                                curves are either compressed to the center or
//                                expanded to the black/white.
//
//  BDR                         - The ratio which the black dyes should be
//                                replaced by the non-black dyes, higher the
//                                number more black dyes are used to replace
//                                the non-black dyes.  This may saving the
//                                color dyes but it may also loose color
//                                saturation.  this is a DECI4 number range
//                                from -10000 to 10000 (ie. -1.0000 to 1.0000).
//                                if this value is 0 then no repelacement is
//                                take place.
//
//

typedef struct _CIExy2 {
    UDECI4  x;
    UDECI4  y;
    } CIExy2, *PCIExy2;

typedef struct _CIExy {
    FD6 x;
    FD6 y;
    } CIExy, FAR *PCIExy;

typedef struct _CIExyY {
    FD6 x;
    FD6 y;
    FD6 Y;
    } CIExyY, *PCIExyY;

typedef struct _CIEPRIMS {
    CIExy   r;
    CIExy   g;
    CIExy   b;
    CIExy   w;
    FD6     Yw;
    } CIEPRIMS, FAR *PCIEPRIMS;


#define CIELUV_1976             0
#define CIELAB_1976             1
#define COLORSPACE_MAX_INDEX    1


typedef struct _COLORSPACEXFORM {
    MATRIX3x3   M3x3;
    FD6XYZ      WhiteXYZ;
    FD6RGB      Yrgb;
    FD6         AUw;
    FD6         BVw;
    FD6         xW;
    FD6         yW;
    FD6         YW;
    } COLORSPACEXFORM, FAR *PCOLORSPACEXFORM;


typedef struct _CLRXFORMBLOCK {
    BYTE            Flags;
    BYTE            ColorSpace;
    BYTE            RegDataIdx;
    BYTE            bReserved;
    CIEPRIMS        rgbCIEPrims;
    CIEPRIMS        DevCIEPrims;
    MATRIX3x3       CMYDyeMasks;
    FD6             DevGamma[3];
    } CLRXFORMBLOCK, *PCLRXFORMBLOCK;

typedef struct _PRIMADJ {
    DWORD           Flags;
    FD6             SrcGamma[3];
    FD6             DevGamma[3];
    FD6             Contrast;
    FD6             Brightness;
    FD6             Color;
    FD6             TintSinAngle;
    FD6             TintCosAngle;
    FD6             MinL;
    FD6             MaxL;
    FD6             MinLMul;
    FD6             MaxLMul;
    FD6             RangeLMul;
    COLORSPACEXFORM rgbCSXForm;
    COLORSPACEXFORM DevCSXForm;
    } PRIMADJ, *PPRIMADJ;


#define CRTX_LEVEL_255              0
#define CRTX_LEVEL_RGB              1
#define CRTX_TOTAL_COUNT            2

#define CRTX_PRIMMAX_255            255
#define CRTX_PRIMMAX_RGB            (HT_RGB_MAX_COUNT - 1)
#define CRTX_SIZE_255               (sizeof(FD6XYZ) * (256 * 3))
#define CRTX_SIZE_RGB               (sizeof(FD6XYZ) * (HT_RGB_MAX_COUNT * 3))

typedef struct _CACHERGBTOXYZ {
    DWORD   Checksum;
    PFD6XYZ pFD6XYZ;
    WORD    PrimMax;
    WORD    SizeCRTX;
    } CACHERGBTOXYZ, FAR *PCACHERGBTOXYZ;


#define DCA_HAS_ICM                 0x00000001
#define DCA_HAS_SRC_GAMMA           0x00000002
#define DCA_HAS_DEST_GAMMA          0x00000004
#define DCA_HAS_BW_REF_ADJ          0x00000008
#define DCA_HAS_CONTRAST_ADJ        0x00000010
#define DCA_HAS_BRIGHTNESS_ADJ      0x00000020
#define DCA_HAS_COLOR_ADJ           0x00000040
#define DCA_HAS_TINT_ADJ            0x00000080
#define DCA_LOG_FILTER              0x00000100
#define DCA_NEGATIVE                0x00000200
#define DCA_NEED_DYES_CORRECTION    0x00000400
#define DCA_HAS_BLACK_DYE           0x00000800
#define DCA_DO_DEVCLR_XFORM         0x00001000
#define DCA_MONO_ONLY               0x00002000
#define DCA_USE_ADDITIVE_PRIMS      0x00004000
#define DCA_HAS_CLRSPACE_ADJ        0x00008000
#define DCA_MASK8BPP                0x00010000
#define DCA_REPLACE_BLACK           0x00020000
#define DCA_RGBLUTAA_MONO           0x00040000
#define DCA_BBPF_AA_OFF             0x00080000
#define DCA_ALPHA_BLEND             0x00100000
#define DCA_CONST_ALPHA             0x00200000
#define DCA_XLATE_555_666           0x00400000
#define DCA_AB_PREMUL_SRC           0x00800000
#define DCA_AB_DEST                 0x01000000
#define DCA_XLATE_332               0x02000000
#define DCA_NO_MAPPING_TABLE        0x40000000
#define DCA_NO_ANY_ADJ              0x80000000


#define SIZE_XLATE_555  (((4 << 6) | (4 << 3) | 4) + 1)
#define SIZE_XLATE_666  (((5 << 6) | (5 << 3) | 5) + 1)


#define ADJ_FORCE_MONO              0x0001
#define ADJ_FORCE_NEGATIVE          0x0002
#define ADJ_FORCE_ADDITIVE_PRIMS    0x0004
#define ADJ_FORCE_ICM               0x0008
#define ADJ_FORCE_BRUSH             0x0010
#define ADJ_FORCE_NO_EXP_AA         0x0020
#define ADJ_FORCE_IDXBGR_MONO       0x0040
#define ADJ_FORCE_ALPHA_BLEND       0x0080
#define ADJ_FORCE_CONST_ALPHA       0x0100
#define ADJ_FORCE_AB_PREMUL_SRC     0x0200
#define ADJ_FORCE_AB_DEST           0x0400
#define ADJ_FORCE_DEVXFORM          0x8000



typedef struct _CTSTDINFO {
    BYTE    cbPrim;
    BYTE    SrcOrder;
    BYTE    DestOrder;
    BYTE    BMFDest;
    } CTSTDINFO;

typedef struct _RGBORDER {
    BYTE    Index;
    BYTE    Order[3];
    } RGBORDER;

typedef union _CTSTD_UNION {
    DWORD       dw;
    CTSTDINFO   b;
    } CTSTD_UNION;


#define DMIF_GRAY                   0x01

typedef struct _DEVMAPINFO {
    BYTE        Flags;
    BYTE        LSft[3];
    CTSTDINFO   CTSTDInfo;
    DWORD       Mul[3];
    DWORD       MulAdd;
    RGBORDER    DstOrder;
    FD6         BlackChk;
    } DEVMAPINFO, *PDEVMAPINFO;

typedef struct _DEVCLRADJ {
    HTCOLORADJUSTMENT   ca;
    DEVMAPINFO          DMI;
    PRIMADJ             PrimAdj;
    PCLRXFORMBLOCK      pClrXFormBlock;
    PCACHERGBTOXYZ      pCRTXLevel255;
    PCACHERGBTOXYZ      pCRTXLevelRGB;
    } DEVCLRADJ, FAR *PDEVCLRADJ;

#define SIZE_BGR_MAPPING_TABLE      (sizeof(BGR8) * (HT_RGB_CUBE_COUNT + 2))


//
// Following define must corresponsed to the InputFuncTable[] definitions
//

#define IDXIF_BMF1BPP_START     0
#define IDXIF_BMF16BPP_START    6
#define IDXIF_BMF24BPP_START    9
#define IDXIF_BMF32BPP_START    13


#define BF_GRAY_BITS            8
#define BF_GRAY_TABLE_COUNT     (1 << BF_GRAY_BITS)


#define BFIF_RGB_888            0x01

typedef struct _BFINFO {
    BYTE        Flags;
    BYTE        BitmapFormat;
    BYTE        BitStart[3];
    BYTE        BitCount[3];
    DWORD       BitsRGB[3];
    RGBORDER    RGBOrder;
    } BFINFO, FAR *PBFINFO;


#define LUTAA_HDR_COUNT         6
#define LUTAA_HDR_SIZE          (LUTAA_HDR_COUNT * sizeof(DWORD))

#define GET_LUTAAHDR(h,p)       CopyMemory((LPBYTE)&(h[0]),                 \
                                           (LPBYTE)(p) - LUTAA_HDR_SIZE,    \
                                           LUTAA_HDR_SIZE)

typedef struct _RGBLUTAA {
    DWORD       Checksum;
    DWORD       ExtBGR[LUTAA_HDR_COUNT];
    LONG        IdxBGR[256 * 3];
    } RGBLUTAA, *PRGBLUTAA;


#define LUTSIZE_ANTI_ALIASING   (sizeof(RGBLUTAA))


//
// DEVICECOLORINFO
//
//  This data structure is a collection of the device characteristics and
//  will used by the halftone DLL to carry out the color composition for the
//  designated device.
//
//  HalftoneDLLID               - The ID for the structure, is #define as
//                                HALFTONE_DLL_ID = "DCHT"
//
//  HTCallBackFunction          - a 32-bit pointer to the caller supplied
//                                callback function which used by the halftone
//                                DLL to obtained the source/destination bitmap
//                                pointer durning the halftone process.
//
//  pPrimMonoMappingTable       - a pointer to the PRIMMONO data structure
//                                array, this is the dye density mapping table
//                                for the reduced gamut from 24-bit colors,
//                                initially is NULL, and it will cached only
//                                when the first time the source bitmap is
//                                24-bit per pel.
//
//  pPrimColorMappingTable      - a pointer to the PRIMCOLOR data structure
//                                array, this is the dye density mapping table
//                                for the reduced gamut from 24-bit colors,
//                                initially is NULL, and it will cached only
//                                when the first time the source bitmap is
//                                24-bit per pel.
//
//  Flags                       - Various flag defined the initialization
//                                requirements.
//
//                                  DCIF_HAS_BLACK_DYE
//
//                                      The device has true black dye, for this
//                                      version, this flag always set.
//
//                                  DCIF_ADDITIVE_PRIMS
//
//                                      Specified that final device primaries
//                                      are additively, that is adding device
//                                      primaries will produce lighter result.
//                                      (this is true for monitor device and
//                                      certainly false for the reflect devices
//                                      such as printers).
//
//  pPrimMonoMappingTable       - Pointer to a table which contains the cached
//                                RGB -> Single dye density entries, this table
//                                will be computed and cahced when first time
//                                halftone a 24-bit RGB bitmap to monochrome
//                                surface.
//
//  pPrimMonoMappingTable       - Pointer to a table which contains the cached
//                                RGB -> three dyes densities entries, this
//                                table will be computed and cahced when first
//                                time halftone a 24-bit RGB bitmap to color
//                                surface.
//
//  pHTDyeDensity               - Pointer to an array of DECI4 HTDensity values,
//                                size of the array are MaximumHTDensityIndex.
//
//  Prim3SolidInfo              - Device solid dyes concentration information,
//                                see RIM3SOLIDINFO data structure.
//
//  RGBToXYZ                    - a 3 x 3 matrix used to transform from device
//                                RGB color values to the C.I.E color X, Y, Z
//                                values.
//
//  DeviceResXDPI               - Specified the device horizontal (x direction)
//                                resolution in 'dots per inch' measurement.
//
//  DeviceResYDPI               - Specified the device vertical (y direction)
//                                resolution in 'dots per inch' measurement.
//
//  DevicePelsDPI               - Specified the device pel/dot/nozzle diameter
//                                (if rounded) or width/height (if squared) in
//                                'dots per inch' measurement.
//
//                                This value is measure as if each pel only
//                                touch each at edge of the pel.
//
//  HTPatGamma                  - Gamma for the input RGB value * halftone
//                                pattern gamma correction.
//
//  DensityBWRef                - The reference black/white point for the
//                                device.
//
//  IlluminantIndex             - Specified the default illuminant of the light
//                                source which the object will be view under.
//                                The predefined value has ILLUMINANT_xxxx
//                                form.
//
//  RGAdj                       - Current Red/Green Tint adjustment.
//
//  BYAdj                       - Current Blue/Yellow Tint adjustment.
//
//  HalftonePattern             - the HALFTONEPATTERN data structure.
//
//

#define DCIF_HAS_BLACK_DYE              0x00000001
#define DCIF_ADDITIVE_PRIMS             0x00000002
#define DCIF_NEED_DYES_CORRECTION       0x00000004
#define DCIF_SQUARE_DEVICE_PEL          0x00000008
#define DCIF_CLUSTER_HTCELL             0x00000010
#define DCIF_SUPERCELL_M                0x00000020
#define DCIF_SUPERCELL                  0x00000040
#define DCIF_FORCE_ICM                  0x00000080
#define DCIF_USE_8BPP_BITMASK           0x00000100
#define DCIF_MONO_8BPP_BITMASK          0x00000200
#define DCIF_DO_DEVCLR_XFORM            0x00000400
#define DCIF_CMY8BPPMASK_SAME_LEVEL     0x00000800
#define DCIF_PRINT_DRAFT_MODE           0x00001000
#define DCIF_INVERT_8BPP_BITMASK_IDX    0x00002000
#define DCIF_HAS_DENSITY                0x00004000


typedef struct _CMY8BPPMASK {
    BYTE    cC;
    BYTE    cM;
    BYTE    cY;
    BYTE    Max;
    BYTE    Mask;
    BYTE    SameLevel;
    WORD    PatSubC;
    WORD    PatSubM;
    WORD    PatSubY;
    FD6     MaxMulC;
    FD6     MaxMulM;
    FD6     MaxMulY;
    FD6     KCheck;
    FD6     DenC[6];
    FD6     DenM[6];
    FD6     DenY[6];
    BYTE    bXlate[256];
    BYTE    GenerateXlate;
    BYTE    bReserved[3];
    } CMY8BPPMASK, *PCMY8BPPMASK;


#define AB_BGR_SIZE             (sizeof(BYTE) * 256 * 3)
#define AB_BGR_CA_SIZE          (sizeof(WORD) * 256 * 3)
#define AB_CONST_SIZE           (sizeof(WORD) * 256)
#define AB_CONST_OFFSET         ((AB_BGR_SIZE + AA_BGR_CA_SIZE) / sizeof(WORD))
#define AB_CONST_MAX            0xFF
#define AB_DCI_SIZE             (AB_BGR_SIZE + AB_BGR_CA_SIZE + AB_CONST_SIZE)
#define BYTE2CONSTALPHA(b)      (((LONG)(b) << 8) | 0xFF)

typedef struct _DEVICECOLORINFO {
    DWORD               HalftoneDLLID;
    HTMUTEX             HTMutex;
    _HTCALLBACKFUNC     HTCallBackFunction;
    DWORD               HTInitInfoChecksum;
    DWORD               HTSMPChecksum;
    CLRXFORMBLOCK       ClrXFormBlock;
    HTCELL              HTCell;
    DWORD               Flags;
    WORD                DeviceResXDPI;
    WORD                DeviceResYDPI;
    FD6                 DevPelRatio;
    HTCOLORADJUSTMENT   ca;
    PRIMADJ             PrimAdj;
    CMY8BPPMASK         CMY8BPPMask;
    CACHERGBTOXYZ       CRTX[CRTX_TOTAL_COUNT];
    RGBLUTAA            rgbLUT;
    RGBLUTAA            rgbLUTPat;
    WORD                PrevConstAlpha;
    WORD                CurConstAlpha;
    LPBYTE              pAlphaBlendBGR;
#if DBG
    LPVOID              pMemLink;
    LONG                cbMemTot;
    LONG                cbMemMax;
#endif
    } DEVICECOLORINFO, FAR *PDEVICECOLORINFO;


typedef struct _CDCIDATA {
    DWORD                   Checksum;
    struct _CDCIDATA FAR    *pNextCDCIData;
    CLRXFORMBLOCK           ClrXFormBlock;
    DWORD                   DCIFlags;
    WORD                    DevResXDPI;
    WORD                    DevResYDPI;
    FD6                     DevPelRatio;
    HTCELL                  HTCell;
    } CDCIDATA, FAR *PCDCIDATA;

typedef struct _CSMPBMP {
    struct _CSMPBMP FAR *pNextCSMPBmp;
    WORD                PatternIndex;
    WORD                cxPels;
    WORD                cyPels;
    WORD                cxBytes;
    } CSMPBMP, FAR *PCSMPBMP;

typedef struct _CSMPDATA {
    DWORD                   Checksum;
    struct _CSMPDATA FAR    *pNextCSMPData;
    PCSMPBMP                pCSMPBmpHead;
    } CSMPDATA, FAR *PCSMPDATA;


typedef struct _BGRMAPCACHE {
    PBGR8   pMap;
    LONG    cRef;
    DWORD   Checksum;
    } BGRMAPCACHE, *PBGRMAPCACHE;

#define BGRMC_MAX_COUNT     5
#define BGRMC_SIZE_INC      (BGRMC_MAX_COUNT * 2)

typedef struct _HTGLOBAL {
    HMODULE         hModule;
    HTMUTEX         HTMutexCDCI;
    HTMUTEX         HTMutexCSMP;
    HTMUTEX         HTMutexBGRMC;
    PCDCIDATA       pCDCIDataHead;
    PCSMPDATA       pCSMPDataHead;
    PBGRMAPCACHE    pBGRMC;
    LONG            cBGRMC;
    LONG            cAllocBGRMC;
    LONG            cIdleBGRMC;
    WORD            CDCICount;
    WORD            CSMPCount;
    } HTGLOBAL;



#define R_INDEX     0
#define G_INDEX     1
#define B_INDEX     2

#define X_INDEX     0
#define Y_INDEX     1
#define Z_INDEX     2

//
// For easy coding/reading purpose we will defined following to be used when
// reference to the CIEMATRIX data structure.
//

#define CIE_Xr(Matrix3x3)   Matrix3x3.m[X_INDEX][R_INDEX]
#define CIE_Xg(Matrix3x3)   Matrix3x3.m[X_INDEX][G_INDEX]
#define CIE_Xb(Matrix3x3)   Matrix3x3.m[X_INDEX][B_INDEX]
#define CIE_Yr(Matrix3x3)   Matrix3x3.m[Y_INDEX][R_INDEX]
#define CIE_Yg(Matrix3x3)   Matrix3x3.m[Y_INDEX][G_INDEX]
#define CIE_Yb(Matrix3x3)   Matrix3x3.m[Y_INDEX][B_INDEX]
#define CIE_Zr(Matrix3x3)   Matrix3x3.m[Z_INDEX][R_INDEX]
#define CIE_Zg(Matrix3x3)   Matrix3x3.m[Z_INDEX][G_INDEX]
#define CIE_Zb(Matrix3x3)   Matrix3x3.m[Z_INDEX][B_INDEX]


//
// HALFTONERENDER
//
//  pDeviceColorInfo        - Pointer to the DECICECOLORINFO data structure
//
//  pDevClrAdj              - Pointer to the DEVCLRADJ data structure.
//
//  pBitbltParams           - Pointer to the BITBLTPARAMS data structure
//
//  pSrcSurfaceInfo         - Pointer to the source HTSURFACEINFO data
//                            structure.
//
//  pDestSurfaceInfo        - Pointer to the destination HTSURFACEINFO data
//                            structure.
//
//  pDeviceColorInfo        - Pointer to the DECICECOLORINFO data structure
//
//

typedef struct _HALFTONERENDER {
    PDEVICECOLORINFO    pDeviceColorInfo;
    PDEVCLRADJ          pDevClrAdj;
    PBITBLTPARAMS       pBitbltParams;
    PHTSURFACEINFO      pSrcSI;
    PHTSURFACEINFO      pSrcMaskSI;
    PHTSURFACEINFO      pDestSI;
    LPVOID              pAAHdr;
    LPBYTE              pXlate8BPP;
    BFINFO              BFInfo;
    } HALFTONERENDER, FAR *PHALFTONERENDER;


typedef struct _HT_DHI {
    DEVICEHALFTONEINFO  DHI;
    DEVICECOLORINFO     DCI;
    } HT_DHI, FAR *PHT_DHI;


#define PHT_DHI_DCI_OF(x)   (((PHT_DHI)pDeviceHalftoneInfo)->DCI.x)
#define PDHI_TO_PDCI(x)     (PDEVICECOLORINFO)&(((PHT_DHI)(x))->DCI)
#define PDCI_TO_PDHI(x)     (PDEVICEHALFTONEINFO)((DWORD)(x) -  \
                                                  FIELD_OFFSET(HT_DHI, DCI))



//
// Functions prototype
//

PDEVICECOLORINFO
HTENTRY
pDCIAdjClr(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo,
    PHTCOLORADJUSTMENT  pHTColorAdjustment,
    PDEVCLRADJ          *ppDevClrAdj,
    DWORD               cbAlooc,
    WORD                ForceFlags,
    CTSTDINFO           CTSTDInfo,
    PLONG               pError
    );


VOID
HTENTRY
ComputeColorSpaceXForm(
    PDEVICECOLORINFO    pDCI,
    PCIEPRIMS           pCIEPrims,
    PCOLORSPACEXFORM    pCSXForm,
    INT                 StdIlluminant
    );

LONG
HTENTRY
ComputeBGRMappingTable(
    PDEVICECOLORINFO    pDCI,
    PDEVCLRADJ          pDevClrAdj,
    PCOLORTRIAD         pSrcClrTriad,
    PBGR8               pbgr
    );

LONG
HTENTRY
CreateDyesColorMappingTable(
    PHALFTONERENDER pHalftoneRender
    );

VOID
HTENTRY
ComputeRGBLUTAA(
    PDEVICECOLORINFO    pDCI,
    PDEVCLRADJ          pDevClrAdj,
    PRGBLUTAA           prgbLUT
    );

LONG
TrimBGRMapCache(
    VOID
    );


PBGR8
FindBGRMapCache(
    PBGR8   pDeRefMap,
    DWORD   Checksum
    );

#define FIND_BGRMAPCACHE(Checksum)  FindBGRMapCache(NULL, Checksum)
#define DEREF_BGRMAPCACHE(pMap)     FindBGRMapCache(pMap, 0)


BOOL
AddBGRMapCache(
    PBGR8   pMap,
    DWORD   Checksum
    );



#endif  // _HTMAPCLR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htmemory.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htmemory.h


Abstract:

    This module contains some local definitions for the htmemory.c


Author:

    18-Jan-1991 Fri 17:05:22 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]

    This module may be need to modify when compile with different operating
    environment, such as Windows 3.1

Revision History:


--*/

#ifndef _HTMEMORY_
#define _HTMEMORY_

#define HTMEM_BEGIN                 (DWORD)'00TH'
#define HTMEM_CurCDCIData           (DWORD)'10TH'
#define HTMEM_CurCSMPData           (DWORD)'20TH'
#define HTMEM_CurCSMPBmp            (DWORD)'30TH'
#define HTMEM_pHTPat                (DWORD)'01TH'
#define HTMEM_HT_DHI                (DWORD)'04TH'
#define HTMEM_GetCacheThreshold     (DWORD)'14TH'
#define HTMEM_CacheCRTX             (DWORD)'24TH'
#define HTMEM_pThresholds           (DWORD)'34TH'
#define HTMEM_DyeMappingTable       (DWORD)'44TH'
#define HTMEM_AlphaBlendBGR         (DWORD)'54TH'
#define HTMEM_DevClrAdj             (DWORD)'05TH'
#define HTMEM_RGBToXYZ              (DWORD)'15TH'
#define HTMEM_pSCData               (DWORD)'25TH'
#define HTMEM_BLTAA                 (DWORD)'35TH'
#define HTMEM_EXPAA                 (DWORD)'45TH'
#define HTMEM_SRKAA                 (DWORD)'55TH'
#define HTMEM_EXPREP                (DWORD)'65TH'
#define HTMEM_SRKREP                (DWORD)'75TH'
#define HTMEM_FIXUPDIB              (DWORD)'85TH'
#define HTMEM_BGRMC_CACHE           (DWORD)'06TH'
#define HTMEM_BGRMC_MAP             (DWORD)'16TH'

//
// Checking the memory alignment size
//

#define CB_MEM_ALIGN    sizeof(UINT_PTR)
#define _ALIGN_MEM(x)   (((x) + (CB_MEM_ALIGN) - 1) & ~((CB_MEM_ALIGN) - 1))

#if DBG
    #if SHOW_MEM_ALIGN

        #define ALIGN_MEM(v, x)                                             \
        {                                                                   \
            DBGP("ALIGN_MEM(%6ld, %2ld): %6ld [+%2ld]"                      \
                    ARGDW(x) ARGDW(CB_MEM_ALIGN)  ARGDW(_ALIGN_MEM(x))      \
                    ARGDW(_ALIGN_MEM(x) - (x)));                            \
            (v) = _ALIGN_MEM(x);                                            \
        }

    #else
        #define ALIGN_MEM(v, x)     (v) = _ALIGN_MEM(x)
    #endif
#else
    #define ALIGN_MEM(v, x)     (v) = _ALIGN_MEM(x)
#endif


#define ALIGN_BPP(cx, bbp)      (((((DWORD)(cx)*(DWORD)(bbp))+31L)&~31L)>>3)
#define ASSERT_MEM_ALIGN(x, c)  ASSERT(((UINT_PTR)(x) & (UINT_PTR)((c)-1))==0)


#if DBG

    #ifdef UMODE
        #define DBG_MEMORY_TRACKING     1
    #else
        #define DBG_MEMORY_TRACKING     1
    #endif

#else
    #define DBG_MEMORY_TRACKING         0
#endif


//
// Function Prototype
//

BOOL
HTENTRY
CompareMemory(
    LPBYTE  pMem1,
    LPBYTE  pMem2,
    DWORD   Size
    );


#if DBG_MEMORY_TRACKING


LPVOID
HTFreeMem(
    LPVOID  pMem
    );

LPVOID
HTAllocMem(
    LPVOID  pDCI,
    DWORD   Tag,
    DWORD   Flags,
    DWORD   cb
    );

VOID
DumpMemLink(
    LPVOID  pInfo,
    DWORD   Tag
    );

#define CHK_MEM_LEAK(p,t)           DumpMemLink(p, t)

#else

    #ifdef UMODE
        #define HTAllocMem(p,t,f,c) LocalAlloc(f,c)
        #define HTFreeMem(p)        LocalFree((HLOCAL)(p))
    #else
        #define HTAllocMem(p,t,f,c) EngAllocMem((f==LPTR) ? FL_ZERO_MEMORY :\
                                                            0, (c), (t))
        #define HTFreeMem(p)        (EngFreeMem(p),NULL)
    #endif

#define CHK_MEM_LEAK(p,t)

#endif  // DBG_MEMORY_TRACKING


#endif  // _HTMEMORY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htpat.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htpat.c


Abstract:

    This module contains all the functions which generate the halftone
    patterns (brushs) to be used for later halftone process.


Author:
    23-Apr-1992 Thu 20:01:55 updated  -by-  Daniel Chou (danielc)
        changed 'CHAR' type to 'BYTE' type, this will make sure if compiled
        under MIPS the default 'unsigned char' will not affect the signed
        operation on the single 8 bits


    15-Jan-1991 Tue 21:09:33 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:

    Change DrawPatLine() function to DrawCornerLine(), and speed up the
    process by only using integer operation for modified DDA.


--*/


#define DBGP_VARNAME        dbgpHTPat

#include "htp.h"
#include "htmath.h"
#include "htmapclr.h"
#include "htrender.h"
#include "htpat.h"
#include "stdio.h"


#ifdef UMODE
#include <search.h>
#endif


#define DBGP_DRAWLINE           0x00000001
#define DBGP_SHOW_HTCELL        0x00000002
#define DBGP_CACHE_PAT          0x00000004
#define DBGP_GEN_PAT            0x00000008

DEF_DBGPVAR(BIT_IF(DBGP_DRAWLINE,       0)  |
            BIT_IF(DBGP_SHOW_HTCELL,    0)  |
            BIT_IF(DBGP_CACHE_PAT,      0)  |
            BIT_IF(DBGP_GEN_PAT,        0))


#define HTSC_M_CX           91
#define HTSC_M_CY           91
#define HTSC_M_COUNT        (HTSC_M_CX * HTSC_M_CY)
#define HTSC_M_OFFSET_M     (HTSC_M_COUNT * 0)
#define HTSC_M_OFFSET_C     (HTSC_M_COUNT * 1)
#define HTSC_M_OFFSET_Y     (HTSC_M_COUNT * 2)

LPWORD  ppwHTPat[HTPAT_SIZE_MAX_INDEX] = {

            NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
            NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
        };

extern HTGLOBAL HTGlobal;


CONST BYTE  RGB555Pat[CB_RGB555PAT] = {

    //
    // SuperCell: 65x65x1x0, 35%!, 0.8300, 3.2500, 0%, 05753eba
    //
    // Pattern Checksum = eaeb3b7e
    //

    161,216, 20, 87, 38,198, 19,111,208, 67,201, 75,  4,164, 40,240,  //   0
     12,109,245,159,129, 32,242,100,187, 79,248, 62,177, 78, 24,246,
     43,213, 62,254, 34, 72,188,145, 32, 74,200, 52,233, 62,125, 82,
    201,117, 68,129, 55,208,107,237,174,207, 76,236, 17,189,224,  8,
     78,  0,
    118, 69,200,163,235,137, 75,248, 43,151,103,253,123,226,142, 57,  //   1
    157,210, 87,  6,226, 60,155, 43,125, 25,196,107,236,127,183, 87,
    123,161, 11,116,156,227,103, 52,231,159,108,185,144, 14,176,249,
     57,232,171, 24,250, 81,140, 59, 11,130, 41,196,135, 93, 54,131,
    192,  0,
    246, 42,133, 10,109, 51,193,163,121,220, 21,145, 44, 80,113,192,  //   2
     74,131, 52,199,118,182, 80,223,200,159, 51,150,  2, 60,226, 15,
    192, 76,225,182, 81, 44,209,168, 80, 13,245, 34, 72,202,104, 21,
    154, 42, 94,194,147,  2,183,216, 95,252,161, 99, 50,247,155,217,
     29,  0,
    101,158,211, 75,175,223, 31, 92, 11,175, 85,216,173,208, 15,250,  //   3
     37,224,168, 97, 21,254,139,  9, 71,113,228, 86,211,164,100,143,
    243, 41,131, 22,241,144,  2,115,192,137, 95,178,125,239,159, 72,
    215,119,224, 35,108,206, 46,121,169, 67, 18,230,185, 12,114, 59,
    171,  0,
    225, 64, 27,250,120, 68,143,232,114,240, 47,121, 24, 68,159,121,  //   4
    177,101, 28,208,154, 45,110,177,239, 19,167, 41,128, 29,216, 47,
     86,170,211, 61,106,201, 70,251, 56,226, 39,214,  5, 89, 38,194,
    141,  7,166, 62,241,138, 71,238, 27,210,118,142, 65,161,207, 88,
      5,  0,
    128,195,144, 91,190,  5,199, 53,150, 73,202,157,245,109,221, 77,  //   5
      4,238,137, 61,235, 85,197, 60,122,203, 96,252,175, 92,186,130,
    222, 27, 94,147,181, 29,132,164, 16,151,116, 59,170,135,230, 98,
     57,252,104,190, 90, 20,181,106,149, 81,182, 29,220, 81,134,240,
    181,  0,
     82, 17,230, 45,134,239,110,171, 26,185,  1, 88, 41,176, 55,141,  //   6
    198, 49,188,112, 18,133,223, 24,171, 43,148, 64, 17,231, 58,  7,
    162,117,252, 12,218, 85,232,103,202, 84,181,250, 79,186, 17,125,
    198, 33,150, 48,212,153,228, 35,214, 13,246,112, 50,195, 24,112,
     43,  0,
    246,120,180, 78,172, 24, 72,221, 97,255,122,222,116,207, 21,247,  //   7
     94,158, 73,223,178, 69,151,104,243, 83,220,117,200,140,106,245,
     72,200, 52,161,125, 41,174, 27, 65,224, 18,127, 31,222, 70,237,
    168, 83,224,126,  9,108, 51, 98,183,119, 54,166,234,147, 75,214,
    163,  0,
     51,201,102, 36,212,128,184, 37,145, 66,170, 33,150, 79,164,122,  //   8
     38,233, 11,144, 46,250,  1,188, 37,161,  8,181, 43, 70,209,171,
     32,149,100,225, 71,207,109,248,130,163, 55,206,161, 91,148, 51,
    108, 14,186, 77,241,196,135,255, 62,146,220, 87,  2,117,183, 17,
    135,  0,
     89,  4,156,251, 92, 53,241,108,213, 14,206, 62,245,  7,226, 59,  //   9
    204,132, 90,198,102,127,210, 77,115,233,136, 91,243,156, 12, 86,
    126,237,  3,178, 25,149, 49,170, 16, 97,240, 73,114,188,  2,206,
    159,244,140, 54,152, 26, 67,164,  8,194, 36,132,203, 49,239, 61,
    219,  0,
    170,208,123, 23,187,146,  6,171, 82,159,127, 96,183,138,105,173,  //  10
     19,162, 50,238, 19,172, 60,147,200, 68, 47,211, 24,109,181,229,
     43,194, 85,127,239,100,227, 81,216,186,141, 14,202, 68,254,120,
     26, 93, 36,230,114,186,219, 99,231,113, 72,237,166, 89,155,128,
    105,  0,
     35, 83,234, 67,110,204, 71,222, 29,246, 44,221, 27, 68,199, 79,  //  11
    248,100,179,125, 84,222, 31,245, 11,141,178,103,150,203, 54,139,
    104,158, 54,202, 41,157,  8,139, 37, 87, 48,231,122, 36,154, 64,
    179,213,127,196,  3, 83, 43,155, 33,143,197, 14,111, 40,206, 10,
    244,  0,
    132,192, 48,154,229, 19,135,100,144, 70,198,107,168,238, 12,129,  //  12
     46,195,  4,206, 38,140,182,121, 92,194, 19,255, 34, 75,240, 19,
    218, 30,253,105,185, 73,212,173,115,251,151, 94,181,217, 90,231,
     43,148, 60, 90,170,250,126,191, 81,247, 52,137,176,253, 75,189,
     59,  0,
    224, 11,175, 95, 44,169,249, 50,213,180,  3,142, 47, 91,205,157,  //  13
    222, 66,112,148,252,105, 64,213, 40,230,115, 58,184,143,117,174,
     65,182, 82,140, 21,245, 99, 42,191, 17,209, 61,  9,131, 30,195,
    117,248, 23,219,141, 28, 91,222,  9,164, 94,219, 61, 18,145, 93,
    162,  0,
     73,111,254,139,214, 73,116,162, 20,124, 83,243,186,124, 37,100,  //  14
     18,168,234, 84, 50,197,  8,159,132, 71,148,213, 82,227,  2, 95,
    206,135, 12,212,176, 53,132,206, 74,157,101,138,246,174,103,152,
      6, 94,172,119, 70,213,164, 58,117,203, 27,118,184,227,108,205,
     29,  0,
    134,201, 52, 87,  9,199, 35,236, 76,222,160, 26, 70,227,169,254,  //  15
    136, 74,197, 25,171,122,225, 87,249, 13,179, 30,123, 47,168,249,
     37, 77,234,111, 75,154,235,  1,123,232, 25,203, 45, 76,236, 57,
    220,192, 44,239, 11,130, 40,243,145, 46,234,151, 78, 36,164, 64,
    244,  0,
    169, 18,148,236,118,159, 90,130,174, 32,111,194,139, 15, 84, 50,  //  16
    208, 33,116,142,239, 65, 31,188, 52,204,101,236,158,199, 64,139,
    115,194,144, 40,204, 26, 95,172, 51,186, 87,160,116,190, 21,167,
    127, 71,155,105,168,199,101,180, 62,193,103,  9,249,121,215,  1,
     85,  0,
    233, 75,187, 32,210, 45,231,  5,211, 60,251, 41,219,114,190,141,  //  17
     95,165,229,  9, 96,199,140,108,167, 79,136, 59, 10,106,229, 27,
    217,  7, 68,248,165,123,218, 63,253,136, 43,238,  5,142,209,102,
     32,233, 21,207, 60, 31,226,  4,137, 79,220,168, 67,153, 91,191,
    117,  0,
     29,204,101,137, 61,191,120,162, 86,134,178, 79,163, 47,214,  1,  //  18
    244, 41, 84,207,175, 39,245,  2,226, 47,211,172,245,145, 79,166,
     87,153,189,100, 14, 72,189,144, 12,107,193, 68,215, 94, 61,251,
    185, 81,137, 92,254,140, 77,166,248, 23,128, 47,192, 18,239, 40,
    143,  0,
     63,127,  6,242,166, 77, 19,246, 47,202,102, 11,239, 88,128,173,  //  19
    110,183,143, 50,133, 74,165, 96,131,160, 24,113, 66, 21,212, 51,
    237,118, 33,218,136,234, 32, 97,178,223, 28,158,113,181, 29,131,
     53,157,201, 13,174,110,215, 56,108,160,212, 96,228,118, 74,167,
    212,  0,
    248,156,209, 55, 98,225,149,104,168, 28,229,123,154, 22,226, 81,  //  20
     54,226, 22,251, 94,215, 23,192, 41,254, 83,219,190,156, 99,180,
     23,199, 65,169, 51,180,117,242, 39, 76,139,249, 17,207, 83,169,
    229, 28,115,232, 66, 39,179, 14,195, 66, 39,176, 28,146,202, 48,
    100,  0,
     18, 89, 38,190,140, 31,202, 61,221, 84,175, 63,202,113,164, 33,  //  21
    208,125, 75,152,185, 55,144,231, 76,121,170,  8,128, 37,247,135,
     93,148,255,114, 88,  7,203, 55,145,201,102, 48, 78,122,241,  8,
    103,209, 73,152,124,241, 97,137,232,113,242,130, 85,255, 10,136,
    187,  0,
    125,228,171,105,253, 75,128, 15,118,148,  4,254, 42, 78,241,134,  //  22
    178, 15,195,102,  5,239, 85,126, 12,200, 52,240, 63,196, 72,  1,
    228, 58, 15,189,229,157,128, 90,224,  3,169,226,189,156, 50,194,
    148, 42,180,  4,193, 26,208, 67, 35,172,  3,199, 55,178,102,234,
     66,  0,
    176, 28,134, 57,  1,212,165,191,236, 58,194,107,142,183,  8, 64,  //  23
     97,245, 56,220,120,160, 27,180,216,147,105,162, 98,141,215,162,
    117,177, 84,141, 32, 56,247, 21,180,114, 56,131, 13, 88,220,119,
     69,252, 89,224,110, 59,147,183,217, 85,153,104,223, 21,157, 52,
    208,  0,
    109, 75,234,195,156,101, 40, 91, 27,158, 84,217, 24,226,118,204,  //  24
    155, 37,147, 79,182, 68,225,109, 72, 37,231, 19,221, 39,111, 62,
    209, 34,239,112,213,182,101,154, 48,240,195, 96,247,142, 34,181,
     20,166,131, 36,162,248,116, 10,126, 49,238, 31,145, 75,196,118,
      5,  0,
    251,185, 45,115, 62,243,138,219,122,245, 33,169, 59, 91,172, 49,  //  25
    236,114,213, 22,253, 38,142, 47,241,138, 82,198, 68,169,252, 23,
     87,187,148, 17, 77,138, 62,220,121, 77, 18,167, 44,205, 70,237,
    109,211, 63,190, 78, 29,198, 74,233,176, 91,185,112,247, 36,218,
    155,  0,
     89, 18,144,223, 16,182, 69,  9,184, 55,111,208,131,250, 16,137,  //  26
     74,  9,190,134,102,165,207,116,167, 14,179,107,147,  8,190,135,
    232,108, 55,200,251, 36,194, 25,168,211,129,230, 83,124,169,  1,
    150, 92, 23,230,139,217,104,157, 19,138, 38,209, 11,173, 97,137,
     55,  0,
    164,118,200, 92,161,114,207,147, 86,214,161, 19, 78,193,100,223,  //  27
    197,158, 86, 48,221,  6, 79, 30,212, 66,250, 29,226,124, 91, 42,
    165,  5,127,171, 99,155,119,242, 95, 39, 61,153, 14,199, 90,224,
     56,244,160,106,  6, 89,186, 59,206,107,244, 77,150, 53,190, 22,
    225,  0,
     48,244, 68, 40,238, 30, 58,253, 26,128, 50,239,153, 54,176, 28,  //  28
    119, 42,246,142,193, 98,243,175,129, 93,156, 60,194, 51,242,201,
     64,196,235, 77, 14,231, 74,  2,151,190,218,106,250, 46,130, 37,
    193,125, 64,179,241, 54,143,255, 34,189, 60,125,219, 85,234,106,
    197,  0,
    152,  3,193,146,107,189,121,176, 97,225,180,102,  2,229,143, 90,  //  29
    235,166,106, 22, 67,162,120, 42,230,  1,217,132,102,176, 13,112,
    155, 99, 33,148,197, 47,164,206,105, 31, 75,166, 59,151,217,163,
     95, 11,219, 36,122,204, 18,125, 96,163,  2,199, 40,154,  9,135,
     73,  0,
    188,125, 82,227, 14, 69,230,  5,155, 34, 65,134,209, 84, 41,186,  //  30
     11, 71,211,172,232, 13,200, 83,153,109,181, 20,236, 74,140,221,
     23,250,183, 55,106,218,131, 54,255,132,226,  6,210,109, 72, 20,
    253,146,186, 99,158, 68,175,218, 65,237,107,142,240,103,173,249,
     28,  0,
     92,233, 57,174,119,206,141, 85,202,114,248,186, 46,125,253,108,  //  31
    215,145, 35, 80,116,148, 53,254, 27,203, 51, 88,162, 32,187, 53,
     85,134, 71,229,161, 18, 79,175, 22,189, 88,124,186, 34,227,171,
    114, 54, 81,238,  9,224,101, 26,154, 51,182, 81, 18,194, 43, 89,
    206,  0,
    160, 20,192, 44,152, 23, 57,242, 44,163, 19, 88,154,198, 16,161,  //  32
     49,101,190,249, 48,214,100,168,132, 98,241,134,215, 98,246,111,
    202,170,  6,124, 46,246,116,204, 73,150, 36,239, 80,156,127, 51,
    191,221, 28,121,170, 57,138,211,117,227, 27,205,130, 76,228,136,
     37,  0,
    245,140,107,240, 92,222,181,135, 91,217,131,232, 32, 74,218, 66,  //  33
    240,152,  3,124,163, 16,196, 62,229, 10,159, 73, 16,167, 43,149,
     21,235, 94,214,184, 83,159,  8,240,109,210, 59,174, 15,243, 86,
      3,104,143,193, 83,251, 42,167,  6, 92,161, 67,252,158, 60,179,
    103,  0,
      6, 89,204, 25,163, 67,115, 30,187,  9, 67,176,115,165, 93,136,  //  34
     22,202, 82,215, 67,233,129, 36, 89,199, 58,187,110,202, 79,225,
    123, 63,151, 32,138, 56,224,130, 66,169, 13,129,204, 70,111,205,
    159,248, 44,219, 16,133,203, 72,241,132,215, 38,112, 22,201, 46,
    212,  0,
     72,182, 58,138,216,  1,255,154,212,126,247, 39,205,  5,182,231,  //  35
    112, 48,167,114, 24,151, 95,190,149,117,247, 24,219,137,  3,172,
     46,185,254,112,204, 25,104,191, 35,201, 93,252, 33,142,181, 25,
    129, 80,180, 70,116,176, 29,109,189, 49, 86,191,139,231, 98,127,
    155,  0,
    219,133,249, 35,106,184, 97, 39, 70,101,153, 80,134,243, 52, 73,  //  36
    143,221, 69,242,192, 76,251,  5,218, 31, 84,162, 49, 91,248,107,
    211, 88,  9, 65,149,244,175, 78,232,140, 43,166,101,227, 65,237,
     53,214, 23,147,243, 58,225,141, 16,164,229,  8, 63,179, 16,247,
     35,  0,
    113, 11, 94,198,143, 63,211,134,236, 46,189,224, 32,104,151,199,  //  37
     37,179, 11,138, 38,163, 52,174, 62,124,210,133,228,169, 37,146,
     23,157,221,182, 94, 16, 59,157,  1,116,223, 71,189,  7,120,156,
     98,168,119,198,  5,105,191, 74,255,118, 90,146,209, 82,157, 61,
    170,  0,
     57,228,174, 44,237, 13,168, 25,196,123,  8, 69,175,210, 15,100,  //  38
    255, 80,116,203, 93,227,107,137,234,184, 69, 10,111, 78,197, 57,
    230, 95,128, 38,234,141,212,106,240, 53,153, 22,135,203, 47,217,
     14,246, 46, 73,216,138, 49,158, 40,194, 24,245, 36,124,233, 95,
    208,  0,
    185,131, 72,156, 86,117,229, 70, 99,164,251,114,138, 58,233,160,  //  39
     24,139,224, 56,153, 30,195, 17, 87, 38,156,254,191, 19,238,112,
    174, 62,192, 84,172,119, 34,177, 66,184,214,110,248, 72,126,165,
     69,132,182,110,160, 31,230,119,214, 67,121,160, 71,195,  4,147,
     31,  0,
     89, 17,241, 34,203,139, 36,151,220, 31, 82,199, 23,187, 78,119,  //  40
    191, 63,178,  4,241,130, 82,246,168,217,101, 45,129,176, 68,148,
     12,245, 33,210,  7, 68,251, 94,139, 12, 89, 47,151, 25,232, 93,
    192, 41,223, 11,250, 77,169, 92,  2,168,222, 94,179, 51,217,109,
    254,  0,
    152,206,110,175, 58,252, 83,193, 57,135,175, 45,240,148,  6,206,  //  41
     42,235,104,161, 76,205, 49,141,108,  2,145,197, 59, 99,222, 53,
    207, 90,147,110,227,144,191, 26,200,238,124,188,221, 87,171,  3,
    243,102,146, 69,133,201, 20,235,191,132, 56, 13,231,140, 79,169,
     52,  0,
    120, 39,191,  7, 99,165, 16,111,236,  2,205,110, 66,118,223, 88,  //  42
    152,126, 35,218, 22,114,180, 27,201, 64,227, 21,244,142, 24,166,
    121,189, 45,173, 83, 49,112,162, 71, 45,158, 21, 66,135,211, 60,
    127, 30,210,184, 36, 83,145, 71, 39,100,242,151,112, 38,201, 13,
    219,  0,
     56,236, 85,145,206,122,224,179, 89,156, 74,225,171, 52,178, 32,  //  43
    251, 71,188, 85,138,248, 74,218,155, 93,123,162, 87,188,105,240,
     77,  1,253, 61,197,237, 10,223,127,212, 96,254,193, 31,105,152,
    222,170, 62, 99,227,171,245,122,216,163, 20,203, 67,249,128, 94,
    177,  0,
    144,113, 27,231, 44, 78, 34,132, 22,249, 41,129, 26,242,136,106,  //  44
    183, 20,224,157, 51,169,  7,122, 39,252, 30,215, 55, 10,214, 60,
    142,205, 96,152, 30,120,167, 87, 34,182,  4,140, 90,164,244, 40,
     90, 10,253,137, 15,104, 57,  8,182, 64,139, 96,180, 22,171, 42,
    244,  0,
      1,216,176,126,184,246,154,216, 61,188, 90,164,202, 73, 16,208,  //  45
     53,139,116, 13,234, 96,192,227, 87,188,150,100,198,122,157, 36,
    182, 25,126,228, 86,186, 56,250,146,103,226, 54,205, 12, 76,180,
    206,113,154, 45,215,160,201,145, 98,254, 33,213, 54,135,207,112,
     71,  0,
    201, 97, 48, 83, 12,108, 53,102,161,120,224,  9,103,146,229, 80,  //  46
    170,244, 84,181, 67,125, 33,145, 46,126,  6,240, 64,177, 80,236,
     92,217, 50,192, 17,233,135, 13,205, 41,170, 84,130,231,120,142,
     22,236, 59,181,120, 77, 29,229, 45,195,115,156,238, 90, 11,231,
    166,  0,
     35,147,255,134,221,160,211,  4,243, 39, 74,183,254, 49,180,119,  //  47
      1, 55,198, 34,215,164,249, 69,197,233, 79,143, 35,209, 15,151,
    122, 65,166,107,150, 44,105,192, 85,127,246, 18,181, 42, 65,195,
     55,172, 88,222, 23,243,107,136, 78,167,  3, 82, 38,194,147, 53,
    128,  0,
     80,189, 18,197, 63, 33,121,189, 84,200,148, 30,130, 95, 23,207,  //  48
    153,224, 96,145, 60,103, 19,171,113, 29,172,220, 96,124,254, 58,
    188,232,  5,247, 81,218,176, 30,234, 60,155,113,215,149,252,104,
    220,119,  1,138,196, 67,177,214, 25,235,128,221,178,116,251, 98,
    209,  0,
    233,123, 70,110,167,232, 78,149, 25,127,231, 83,215,163,237, 86,  //  49
     61,124,177, 10,237,153,212, 81,223, 56,125, 20,185, 50,172,110,
     29, 88,138, 46,196, 63,137, 98,165,  8,207, 66, 35, 97,  7,173,
     30,150,249, 95, 46,153, 10, 85,192,104, 50,145, 18, 78, 41,180,
     15,  0,
    156, 29,185,242,  7,144, 53,239,173,102, 42,180,  5, 67,121,187,  //  50
     26,252, 48,201, 82, 42,123,  4,148,183,250, 72,208,132,  7,228,
    198,157,212,111,158, 10,252, 55,213,143, 81,174,239,142,196, 61,
     88,200, 61,174,220,111,247,149, 45,163,249, 98,214,165,222,141,
     63,  0,
     96,216,136, 54, 99,204,124, 12,210, 63,247,117,150,209, 33,142,  //  51
    204,116, 77,159,114,205,169,242, 64,102, 13,149, 92,236, 74,141,
     44, 79, 18,230, 93,177,121,184, 31,105,232, 16,118, 50,226,123,
    240,111, 34,133, 17,193, 38,121,227, 87, 27,198, 44,120,  7,111,
    243,  0,
    201, 41, 82,173,221, 32,187, 90,130,162, 16,194, 46,103,242, 91,  //  52
      7,166,220, 17,246, 27, 95, 44,129,225,187, 44,171, 52,186,101,
    177,207,131, 69, 33,236, 45, 86,225,135, 47,150,190, 79, 14,179,
     39,158,194,235, 86, 58,100,208,  6,188,150, 80,141,245, 75,187,
     26,  0,
    165,129,249, 14,118,153, 66,250, 45,205,109, 70,228,174, 65,185,  //  53
    234, 57,108, 64,123,149,190,216,159, 34, 76,241,122,213, 35,250,
     10,106,243,183,144,115,208,157,  4,196, 85,254, 92,209,146, 96,
    219, 69, 22,104,156,241,179,146, 65,127,234, 13,186, 60,211,132,
     87,  0,
      4, 63,196, 91,234, 51,210,110,149, 27,238,154, 26,136, 14,146,  //  54
     43,126,208,175,232, 51, 84, 20, 98,193,113,157,  2, 77,161,129,
     71,158, 54, 23,203, 64, 24,106,236, 54,176, 21,133, 59,245, 28,
    152,120,229,175,  3,131, 30, 81,253, 34, 93,209,115, 20,155, 42,
    197,  0,
    218,171,113, 31,179,128,  2,183, 58,173, 80,115,217, 86,248,105,  //  55
    219,160, 30, 93,  3,167,222,129,255, 12,214, 52,192,104,222, 28,
    197,220, 88,168, 98,229,136,184, 75,149,110,226,193,  2,123,178,
     56,198, 81, 50,205, 66,220,184,110,204,144, 53,167,219, 95,255,
    107,  0,
    139, 48,228,159, 67,204, 89,239,101,210, 11,195, 41,187, 50,199,  //  56
     19, 68,252,136,203,117, 65,162, 57,178,127, 90,248,133, 66,177,
    101, 15,138,235,  7,175, 40,248, 15,203, 30, 69,160, 94,217, 80,
    233, 10,148,251,124, 98,152, 15, 59,173, 21,242, 78,137, 32,164,
     66,  0,
    237, 86, 20,133,252, 49,154, 23,129, 50,255,133,170,103,149, 85,  //  57
    175,119,188, 73, 39,238, 15,204,109, 40,228, 28,167, 16,233, 45,
    152,255, 49,106,205, 76,130, 97,166,120,244,131, 36,197,146, 46,
    122,191, 92, 32,178, 55,244,123,223,130, 96,194,  1,232, 62,207,
     15,  0,
    112,152,203, 97, 10,181,115,221,190,160, 97, 64, 25,240,  9,216,  //  58
     40,230, 11,146,179,103,150, 80,243,133,173, 64,122,189, 97,200,
    120, 78,183,143, 60,152,225, 61,213, 43, 80,174,235, 73, 20,249,
    172, 26,228,133,213,  8,195, 69, 25,200, 47,141,109,169, 97,128,
    184,  0,
     46,223, 62,173,126,230, 65, 37, 88,  5,199,225,124,191, 93,132,  //  59
    162, 74,111,244, 53,215, 34,178, 60,  5,209, 94,237, 43,146,  4,
    229, 37,214, 12,243, 37,185,  3,115,155,216,  9,114,140,203,106,
     59,113,161, 40, 81,165,102,143,238, 88,173,250, 38,213, 24,247,
     83,  0,
    188,131, 25,244, 40, 91,202,158,246,111,144, 39, 82,160, 49,237,  //  60
     58,210,187, 21,134, 82,196,126,222,153,113, 25,155,210, 89,180,
     57,158,126, 88,166,124, 93,253,177, 32,108, 63,227, 56,163,  7,
    223,196, 70,238,119,218, 29,183, 48,136, 15, 71,199, 57,134,173,
      6,  0,
    238, 99,193, 80,140,179, 45,133, 20,208, 65,188,250, 28,197,118,  //  61
      2,102,147, 69,174,235, 13, 99, 30, 76,241,189, 70,125, 28,235,
    108,210, 23,235, 49,215, 29,132, 76,235,196,130,172, 28,241,131,
     76,143, 14,173, 56,150, 77,230, 99,195,228,119,152,101,231, 62,
    117,  0,
     76, 16,154,212,  3,237,103,217, 57,126,165, 13,117,151, 76,218,  //  62
    166,253, 31,227,115, 54,155,252,193,165, 43,139,  8,253,163, 75,
    149, 68,178,107,184, 71,161,211, 12,143, 42, 73,205, 90,115,187,
     36,255,122,210, 27,247,125,  4,165, 37, 93,177,  6,185, 26,207,
    159,  0,
    184,225, 48,118, 63,151, 35,183, 89,242, 95,219, 55,234, 19,137,  //  63
     48, 86,136,185, 17,202, 70,129, 52,105,217, 95,198,105, 48,206,
      9,238, 41,147,  6,233,108, 58,185, 91,170,251,  3,153, 51,230,
     99,176, 50, 81,112,190, 69,213,134,247, 56,213, 72,253, 84,139,
     33,  0,
     53,104,145,255,178, 94,228,140,  8,172, 35,141,195, 92,187,102,  //  64
    204,177, 39, 73,216,106,177,  4,226,144, 17,159, 38,221,133,170,
     97,129,186, 92,200,136, 20,247,120,220, 22,134, 99,212,182, 26,
    150,  6,197,233,153, 17,167, 44,100, 22,162,108,146, 47,168,113,
    242,  0
};




CONST BYTE  HTSC_SUPERCELL_M[] = {

    //
    // SuperCell: 91x91x3x0, 31%!, 1.4225, 10.0000, 0%, c716938f
    //
    // Pattern Checksum = 7fb46795
    //

    //
    // Magenta
    //

    166,206, 43,184,226,118,151, 71,167, 14,239,124,218,  8,228, 59,  //   0
     28,156,180,255, 89,169,101,230,150, 78,170,126,194,101,141, 28,
    131, 57,120,156, 70, 18,188,136,  9,150,181,210,  6,248, 38,132,
    102,196,162,234, 17,166,108,218, 54, 19,241,178,222, 34,146,245,
     23,219, 47, 71,166,121,217, 19,225,182,125,231,106,132,212, 80,
    122, 55,154,  5,239, 92,201, 17,154, 41,254,
     51,126,239,101, 58, 36,188,221, 56,185, 39,152, 46, 87,147,186,  //   1
    238,105, 48,  4,224, 31,127,195, 60, 33,211, 45,239, 37,213,165,
    220, 88,235, 42,180,125,244, 39,228, 89,114, 75,143,109,198,222,
     66, 35,111,135, 71,243, 41,195,132,169, 89, 66,136,106,183, 72,
    125, 98,140,254,194, 52, 93,190,108, 62,  5,163, 40, 60,155, 37,
    198,254, 73,171,126, 45,228, 67,109,213, 77,
    183, 89, 13,162,134,252, 96, 23,113,137,211, 96,178,206, 39,117,  //   2
     16,139,200, 84,149, 51,218, 13,172,252,142,106, 72,180, 60, 98,
      6,194, 25, 99,223, 81,166, 78, 59,190,219, 26,232, 46,155, 11,
    174,252,207, 25,192,149, 11, 77,234,104,205, 23,251, 58,212,  5,
    235,187, 18, 87,113,  7,241,149, 26,251,207, 76,193,240, 90,175,
     11,140, 99,221, 26,179, 97,142,190,  3,145,
     39,221,199, 66,191,  7,171,145,238, 82,  9,252, 62,133,243, 91,  //   3
    193, 67,232,119,208,175, 75,138,103, 80,  2,200,156, 15,126,249,
    143,171,122,203,145,  2,114,209,152, 13,132,169, 64,186, 85,126,
     93,139, 79, 51,105,220,125,180, 47,  1,156,118,174, 38,159, 90,
    145, 64,215,156,229,177, 70,123,170, 89,142,113, 16,140,215,111,
    233, 51,191, 65,147,215, 20,246, 60,118,237,
    167,138, 27,122,225, 50, 78,216, 30,191,161,106, 27,171,  1,217,  //   4
    151, 35,170, 21, 60,106,247, 42,222,184,123,232, 89,220,189, 84,
     39, 57,242, 74, 47,238,181, 35,243, 91, 47,255, 98,215, 28,239,
    190, 20,167,235,182, 80, 93,255,147,214, 70,235, 87,218,116,202,
     28,177, 43, 79, 29,136, 38,214, 44,187, 29,233,172, 45, 73, 24,
    165,132, 31,241,112, 53,122,169, 32,201, 95,
     10,103,244, 80,151,111,199,122, 69, 49,130,226,189,121, 79, 53,  //   5
    115,251, 92,145,235,  7,151,199, 19,157, 57, 26,146, 62, 33,166,
    225,111,183, 22,161, 96, 58,138,110,198,161,118,  3,133,167, 68,
     42,226,122,  5,140, 33,168, 24, 61,107,188, 32,142, 12, 71,248,
    131,102,243,119,211,192,101,237, 76,119,218, 58, 99,244,129,196,
     62,209,106,172, 14,158,207, 90,227,134, 69,
    175,206, 43,184, 33,241, 18,162,249,208, 92, 34, 67,235,155,199,  //   6
     20,182, 48,200,124,186, 88,119, 70,243,100,186,251,111,202,133,
     12,151, 92,200,126,220,191, 15,226, 25, 67,182,228, 59,206,109,
    147,204, 71,100,245,189,116,206,135,238, 53,126,228,196,157, 20,
     60,198,146,  2,159, 54, 18,144,197,  4,159,131,204,  9,157, 97,
    248,  4, 81,219, 77,250, 63,  6,153, 48,248,
     87,148,118,222, 93,176, 58, 97,143,  5,181,150,205, 13, 89,241,  //   7
    139,103,226, 78, 28, 62,216,169, 34,137,213, 44,131,  6, 90,236,
     71,214, 54,254,  9, 70,107,160, 84,142,209, 33, 87,149, 17,244,
     90, 26,157,212, 64, 40,230,  7, 91,159, 21,177,100, 45, 89,188,
    233, 38, 84,219, 69,241,115,170, 63,255, 87, 32,174, 77,223, 35,
    149,122,186,139, 42,184,125,197,100,181, 33,
    231, 17, 72,161,  2,138,233,195, 45,118,229, 58,107,133,177, 59,  //   8
     38,166,  9,150,248,132, 43,234, 85,181, 14, 76,169,223,182, 49,
    122,165, 32,139,176, 42,239,205, 53,250,103,129,238,195, 47,132,
    190, 54,178, 20,144,102,155, 68,183,217, 77,244,  4,210,140,117,
    162, 99,174, 23,183,141, 86,225, 43,111,191,229, 52,124,183, 67,
    213, 57,232, 18, 96,148, 28,235, 80,215,130,
    107,190,250, 52,213,117, 74, 22,214, 81,168, 20,255, 36,215,119,  //   9
    223, 74,193,106,206, 90,154,  5,202,107,149,240,103, 58,149, 22,
    245,189, 82,110,229, 90,148,123,  4,172, 43,161,  9,112,170, 68,
    218,111,248,128,221,196, 49,249,114, 38,145,119,165, 63,250, 76,
      8,208,124,253,106, 30,205, 12,183,135, 15,147, 98,250, 17, 93,
    163, 28,104,167,203,224, 55,113,160, 10, 59,
    168, 32,140,104,172, 36,187,145,106,242,136, 76,195,147, 67,  4,  //  10
    181,133,234, 47, 18,172,240,115, 63,231, 49,196, 26,124,209, 86,
    106,  1,222,157, 20,186, 37, 69,195, 97,227, 64,212, 79,252, 37,
    160,  2, 89, 38, 75, 10,170,136, 15,199, 54,221, 29,109,179, 33,
    227, 55,150, 73, 49,233,122,159, 92,237, 69,212, 35,195,136,236,
    119,193,252, 50, 72,121,175, 21,255,138,201,
     91, 63,204, 18,226, 85,252, 57,177, 11, 40,225,116, 91,164,246,  //  11
     96, 24, 63,120,189, 78, 31,140,176, 18,128, 91,173,233, 35,178,
    216,147, 74, 50,210,116,247,156,215,133, 19,180,140, 26,192, 95,
    130,230,194,152,233,123,211, 86,230,101,156, 80,189,231, 47,156,
     97,182, 17,215,164,189, 78, 55,202, 23,172,115,158, 73, 41,174,
     12, 82,147,128,  1,242, 92,208, 76, 48,226,
    153,121,235, 72,153,124,  7,205, 88,150,190, 62,171, 16,202, 45,  //  12
    142,206,168,253,134,221, 51,198, 88,219,165,255,  5, 74,152, 61,
    131, 42,251,176,133, 62, 11,105, 30, 77,248, 88,120,223,149, 16,
    180, 57,117, 45,176, 98, 29, 58,165, 40,253,128,  9, 86,116,205,
    137,246, 83,113, 34,138,  5,247,146,103, 50,243,  3,230,107,211,
     55,227, 37,216,191,156, 38,133,189,111, 28,
    194,  5,182, 44,101,211,162, 43,126,231,102,211, 43,239,126, 70,  //  13
    232,110, 82, 12, 57,101,154,247, 26,113, 40, 61,135,196, 99,228,
     12,193,109, 16, 83,233,191,168,224, 49,156,194, 39, 63,107,241,
     78,211, 21,254, 68,141,243,186,120,206, 21,176,216,142,241, 14,
     79, 36,131,234,200, 99,214,117, 34,221,190,134, 92,179,142, 84,
    154,112,173, 96, 24,110, 69,231,  8,169,246,
     55, 85,138,248,171, 27, 81,241,182, 78, 26,131,154, 80,182, 20,  //  14
    157, 37,191,145,210,177,  1,125, 67,190,155,211,110,237, 22,182,
    119, 77,224,165,204,145, 43, 88,135,201,115, 14,237,171,203, 52,
    166,109,153,191,  7,219, 89, 13,147, 61, 88,110, 55, 35,160, 64,
    197,220,162, 11, 63,158, 51,183, 83,159, 66, 32,207, 58, 20,250,
    190,  8,241, 67,166,237,200,148, 59, 89,129,
    230,201,110, 21, 68,224,146,111, 13, 52,187,249,  2,108,226, 95,  //  15
    214, 67,243,113, 45,236, 94,208,146,232, 10, 85,176, 47,161, 55,
    243,154, 30, 64,101, 22,121,255,  3, 68,232, 99,145, 85,  5,138,
     25,233, 63,130,102,164, 46,195,101,241,212,155,196,229,102,177,
    121, 54,103,185, 91,251, 25,224,124, 13,253,113,155,225,122, 36,
     77,127, 45,210,138, 56, 15,117,181,219, 19,
    158, 35,150,216,179,105, 34,201,165,234,121, 65,169,201, 35,136,  //  16
    176,  6, 91,165, 19, 71,162, 49, 31, 96,128,247, 24, 76,220,128,
     93, 48,210,141,244,183,211, 56,179,151, 29,188, 42,213,114,245,
    185, 83, 32,213, 58,203,129,229, 28,172, 45,  1,127, 82, 23,255,
      5,154,237, 26,206,115,144, 76,171,209, 88,182, 10, 81,184,149,
    221,197,159, 90, 33,188, 96,247, 29,140,100,
     72,243, 54, 95,  9,137,254, 58, 90,142, 81,221, 48,146, 74,254,  //  17
     54,124,202,230,134,193,118,251,176,216, 54,153,200,104,147, 10,
    198,163,110,  6, 83, 46,158, 94,116,221, 79,132,251, 65,163, 36,
     99,220,173,141,247, 22, 81,156, 66,113,141,237, 66,186,214,135,
     74,208, 42,139, 67,169,  1,237, 36, 64,143,233, 47,107,242, 66,
     48,101, 16,252,122,222,160, 75,208, 51,188,
      2,177,128,198,234, 51,185,116,218, 10,203, 30,118,235, 15,107,  //  18
    193,154, 47, 27, 82,217, 23, 62,134, 14,194,114, 44,239,183, 82,
    253, 27,231,176,216,132, 13,240, 25,191, 50,168, 17,122,199, 59,
    155,123,  3, 95, 41,121,184,  8,252,197, 89,176, 30,156,109, 38,
    171,115, 88,181,244, 51,212, 96,135,196, 17,120,169,203,136,  2,
    174,231,145,177, 60,  5,134, 44,166,112,221,
    144,104, 25, 64,159, 85, 19,151, 44,172,107,152,194, 91,174,217,  //  19
     22, 95,245,175,109,152, 77,229,102,164, 80,229,  7, 65,118, 36,
    141, 66,129, 55,105,168, 73,197,142, 87,237,107,209, 86,232, 11,
    193, 69,228,196,164,234, 87,212,134, 60, 14,225, 99,246, 63,199,
    238, 17,218,124, 23,107,152,186, 48,242, 94,220, 75, 24, 97,216,
     84,114, 33, 76,214,108,240,195, 15,254, 84,
    214,185,246,142,223,119,203,244, 74,228, 61,251,  7, 50,150,120,  //  20
     72,206,138, 58,227, 11,177,201, 29,245, 89,143,175,214,159,226,
    191, 95,202, 16,248, 34,221,107, 37,175,  6,144, 37,172,140,110,
    244, 35,143, 51, 75,137, 32,108, 44,170,205,132, 53,143,  7, 83,
    145, 52,158, 71,194,231, 75, 11,112,170, 57,153, 42,251,150,190,
     45,137,242,197,126, 25, 91,145, 68,126, 47,
     13, 78, 38,100,  7,173, 40, 98,138, 22,180, 97,136,226, 65,247,  //  21
     37,171,  4, 91,197,125, 44,111,147, 55,186,119, 73, 26,100, 53,
      4,167,224,149, 85,182,138, 65,252,121,212, 62,228, 73, 22,178,
     87,163,102,254, 12,215,192,151,230, 84,114, 21,212,173,223,123,
    184,101,250,  6,166, 37,131,254,199, 25,134,213,185,124, 66, 15,
    222,183, 18, 56,150,179,228, 39,218,187,157,
    239,130,208,164, 60,214, 77,194,164,118, 40,215, 76,177, 24,186,  //  22
    134,221,113,238, 51,156,253, 80,221,  2,210, 36,243,198,148,249,
    124, 72, 40,108,198, 51,  1,165,199, 51, 92,161,195,127,236, 48,
    217, 17,207,122,173, 98, 66,  3,180, 29,242,158, 71, 39, 98, 21,
    232, 30,198,136, 92,213, 57,158, 90,224, 82, 12, 98, 31,235,166,
    107, 70,159, 96,237, 49, 79,169,107, 34, 94,
     54,174, 44,112,250,134, 31,240,  2,224,189,145, 46,117,211,100,  //  23
     81, 56,162, 32,185,100, 14,188,126,165, 95,138, 56,114, 18, 90,
    185,235,136, 21,241,122,230, 81, 22,150,231, 13,105, 59,188, 98,
    133, 62,187, 35, 58,225,125,245,105,142, 50,188,126,253,198,155,
     69,126, 78, 41,228,115,186, 29,125, 41,180,247,158,205, 79,133,
     50,255,117,213, 12,121,207,  3,139,230,196,
    148, 90,225, 25,187, 93,157,111, 70, 52,105, 25,248,161,  6,146,  //  24
    242, 17,206,131, 70,225,139, 39, 62,240, 24,223,185,162,216, 61,
    153, 47,209,169, 63,148, 98,207,109,188, 42,136,247, 35,156,  2,
    249,147, 82,237,154, 19,164, 53,195, 74,225,102,  8, 79,134, 56,
    217,170,238,149,178, 10, 72,205,240,155,109, 58,120, 45,181,225,
     11,197, 31,175, 85,189,146,247, 72, 21,115,
    251, 13,197,131, 65, 10,221,191,135,236,171,207, 94, 61,230, 51,  //  25
    192,125, 92,249, 21,167,207, 91,196,113,151, 77,  8, 96, 37,231,
    117,  9,103, 84,193, 12,178, 37,244,127, 73,168,206, 81,223,109,
    202, 26,174,101,130,197, 89,217, 38,163, 22,209,175,233, 36,187,
      2,107, 52, 22, 83,249,138,103, 22, 64,197,  2,222,145, 26,102,
    160,128, 79,143,243, 29, 63,101,199,165, 47,
    178,123, 81,160,233,177, 45, 84, 18,155, 75, 11,134,197,110,170,  //  26
     33, 72,180,151, 52, 84,117,245, 27,173, 45,206,254,120,173, 72,
    191,248,161,218, 52,255, 78,134, 61,  7,233, 99, 18,120,176, 46,
     71,120,231,  6, 68,251, 26,116,139,247, 84,132, 42,112,157, 98,
    249,146,211,190,100,162, 44,177,215,142,232, 94,191, 71,246, 81,
    213, 55,230, 39,112,168,225, 43,121,221, 86,
    215, 59,242, 39, 97,119,142,252,202,117, 43,242,173, 36, 76,137,  //  27
    213,237,  1,112,229,190, 14,155, 76,231, 98,131, 59,150,209, 29,
    138, 57, 27,132,113, 32,210,167,222,154,198, 52,189,146, 28,238,
    163,196, 40,213,167, 46,151,188, 14, 97,199, 63,167,220, 17,204,
     80, 25, 67,125,221, 61,234, 12, 86,114, 43,168,127, 17,165,117,
    186,  4,154,204, 70, 15,132,184, 10,144, 36,
    158,  1,140,209, 21,194, 68, 24, 93,182,220, 90,119,205,255, 22,  //  28
     98,158, 63,208, 33,142, 56,217,125,  4,180, 32,193, 15, 83,238,
    102,183, 79,232,187,150,103, 15, 87,112, 32,135,253, 67,212, 88,
    138, 61,103,143, 85,223,104,238, 57,218,145, 10,241, 89, 60,133,
    181,113,243,169,  6,148,116,201,165,253, 19, 78,239, 50,217, 35,
     68,250, 99,128,176,213, 95,253, 76,232,112,
     93,191,107,170, 61,239,165,215,149, 52, 15,164, 60,  8,152,185,  //  29
     50,130,188, 92,127,253, 98,171, 66,202,143,245, 68,226,115,161,
      2,214,147, 13, 50, 81,235,193, 52,179,228, 74,107, 14,182,114,
      8,248,175, 23,198,130, 39, 79,156,115, 44,192,109,141,214, 41,
    234,149, 58, 40, 94,210, 32, 79, 50,134,211,182,141,102,193,151,
    124,178, 26, 56,240, 40,149, 54,173, 23,200,
    248, 28, 81,225,133,  9,109, 37,127,241,110,212,141,233,104, 70,  //  30
    240, 13,226, 57,169,  8,198, 26,242, 43,109, 90,170,136, 35,199,
     71,120,244, 93,202,162, 26,121,250,147,  3,205,167,229, 60,151,
    205, 42,126,232, 76, 17,181,209,  7,173,249, 69,163, 19,177, 75,
      8, 96,196,227,178,130,246,156,190, 26,110, 59,  5,229, 61, 13,
    233, 86,209,163, 89,120,  5,203,106,136, 46,
     77,130,202, 39, 76,154,228, 85,203, 63,175, 81, 40,192, 33,122,  //  31
    201,167,108, 35,236, 84,149,116, 81,159,210, 11, 49,191, 95,252,
     45,176, 30,113,224,134, 66,170, 35, 95,119, 54,140, 96, 34,239,
     78,184, 98, 55,157,253,144,118,227, 92, 27,102,205, 59,255,118,
    223,165, 26,109, 71, 19, 52,100,228, 72,241,152,204, 82,130,184,
    103, 39,139, 14,226,192,160,242, 83,219,161,
      7,233,150,110,255,192, 45,179,  5,152, 32,250,131, 78,221,143,  //  32
     23, 85,149,192,119,212, 39,234,187, 21,129,239,116,220, 22,147,
    125,209, 67,168, 47,  5,239,198, 72,220,182,246, 20,200,128,170,
     19,141,217,  1,204,100, 49, 73, 37,195,151,225,129, 35, 82,144,
    201, 53,134,241,158,189,221,141,  7,128,178, 30,107,169,253, 48,
    217,167,243, 74,111, 33, 63,128, 20, 53,183,
    197, 56, 30,178, 13, 64,105,133,236, 88,210,104,184,  4,166, 61,  //  33
    249, 45,223, 10, 64,163, 74,135, 97,226, 55,177, 85,155, 62,188,
     81,  9,236,139,190, 84,105,143, 17,152, 80, 40,162, 69,221, 50,
    115,250, 67,164,131, 27,194,162,245,126, 53,  5,168,218,189, 98,
     31, 78,211,  2, 57,116, 84,175, 46,203, 87, 52,224, 24, 70,153,
     21,121, 59,178,134,206,101,189,231,144, 97,
    115,157, 90,211,140,219,164, 23,196,120, 16,147, 51,235, 92,203,  //  34
    115,170, 98,138,251, 27,204,  2,168, 69,149, 31,204,  4,241,108,
    227,160, 98, 24,250,127,212, 61,235,108,208,135,236,110,  5,187,
     83,196, 32,108,242, 83,219,109, 18,178, 84,242, 70,114, 14,159,
    244,176, 94,147,196,253, 17,211,109,153,250,123,195,145,116,209,
     88,191,  3,221, 45,246, 10,153, 37, 68,249,
    205, 66,243,120, 33, 84,244, 70, 44,172,240, 75,205,129, 35,152,  //  35
     14,189, 53,207, 81,184,112,245, 45,212,101,251,133, 74,171, 35,
     58,128,205, 73, 50,167, 12,185, 36,168, 53, 15, 85,181,148,228,
    137, 52,173,211, 16,175, 43,146, 61,229,105,198,138, 47,232, 63,
    119, 24,223,122, 46, 74,161, 34,231, 62, 15,166, 81, 11,240, 36,
    159,248,104,147, 77,160, 93,216,122,171, 18,
     43,179,  9,167, 51,203,112,144,218, 94, 55,163, 19,177,109,242,  //  36
     74,228, 30,125,160, 56,145, 84,179,120, 22,190, 48,112,211,140,
    197, 20,172,218,110,229, 79,136, 94,255,121,194,220, 35, 57, 95,
     26,237,100,145, 77,126,238, 93,204,129, 14,157, 25,173,207,141,
    196, 55,158, 15,235,180,126, 89,144,102,205, 42,233,104,171, 66,
    132, 81,215, 34,200, 22,184, 50, 82,223,133,
    234,106,142,220, 97,179,  2,187, 30,135,225,117,253, 80,212, 46,  //  37
    134,158,102,241,  9,218, 32,227, 12,152,235, 87,145,228, 26, 95,
    254, 85, 48,124, 25,152, 40,193,218,  3, 63,138,102,163,250,129,
    207,159,  8, 57,218, 36,193,  3,163, 42,217, 78,249,102, 84,  4,
    105,249, 86,204,108, 31,226,198, 52,245,177,117,151, 49,193,228,
      9,181, 61,128,235,106,135,253,  2,190, 95,
     58,208, 30, 74,238,130, 69,251,103,201,  8, 49,144, 27, 99,190,  //  38
      1,203, 60,177, 88,188,102,128,201, 68, 37,167,  7,184, 62,163,
     12,184,144,241,197, 95,246,114, 73,149,175,240, 19, 68,197, 13,
     65,116,192,254,165,107,153, 73,250, 98,174, 52,124,193, 54,235,
    163, 36,133,174, 59,153, 78, 11,157, 38, 83,  3,212, 79,137, 42,
    116,206, 23,168, 86,190, 65,166,110,150, 25,
    164,122,187, 48,155, 26,173, 46,156, 74,168, 92,183,223,159,123,  //  39
     86,226, 24,122,148, 39,234, 58,170, 95,218,123,247,103,135,236,
    119,216,100,  1, 58,177, 17,166, 46,209, 29, 90,203,146,111,177,
    229, 37, 81,130, 22, 66,232,133, 27,202,140,231, 34,146,216, 26,
    123,194, 67,217,  8,250,119,214,105,192,135,237,167, 22,220, 93,
    255,156,105,243, 54, 12,228, 42,214, 68,240,
     79,  5,254,109,213, 83,233,125,221, 26,206,237,125, 61, 18,247,  //  40
     48,140,184,255, 64,206,159, 16,251,115, 46,195, 75, 28,200, 43,
     75, 34,159, 78,221,140, 66,236,132, 99,234,128, 60,231, 34, 89,
    131,203,171, 96,214,185, 11,196,116, 56, 87,  6,186, 72,112,173,
     83,228, 28, 97,135,190, 36,167, 62,224, 28, 94, 61,118,180,149,
     16, 76, 44,131,217,154, 89,128, 19,196,131,
    216,179, 87,139, 16,195,101, 12, 66,136,109, 81, 41,192, 74,206,  //  41
    166,104, 37, 78,  7,115, 84,133, 39,183,142, 13,157,223, 91,152,
    210,175,233,129,188, 30,108,204,  9,186, 40,160,  8,180, 72,163,
    249,  2, 55,240, 40,139,104, 50,224,156,214,121,243,159, 15,254,
     50,148,117,242,168, 64, 92,238, 16,120,176,145,206,241, 32, 58,
    191,223,173,201, 31,116,197,236,175, 99, 36,
     63,149, 32,230,174, 41,145,205,164,249,182,  5,163,240,144, 95,  //  42
      9,197,232,157,220,173,240,203, 70,227, 89,240, 53,121,179,  5,
    115, 53, 24,103, 68,253,148, 86,167, 64,220,107,246,133,208, 26,
    109, 73,152,116,178, 71,236,171, 93, 16,180, 42, 95, 60,211,104,
    187,  5,199, 55, 24,207,126,147,201, 75,245, 52,  7,100,142,232,
     91,122,  3, 67, 99,171,  9, 77, 49,154,245,
     96,203,123, 56, 75,113,245, 54, 95, 30, 62,218,129, 23,112,226,  //  43
     58,124, 80,135, 99, 55, 32,150,  2,110,160, 67,206, 31,236, 70,
    219,139,244,197,  7,172, 46,229, 31,125, 80,201, 44, 90, 55,222,
    142,194,231, 27,211, 16,146, 37,253,135, 76,229,143,192, 40,139,
     73,224,160, 84,111,225,  1, 52,164, 31,108,196,168, 80,201,115,
     36,161,248,143,228, 41,252,145,111,193, 20,
    172,  8,247,156,221,188,  3,171,125,226,153, 87,194, 70,173, 34,  //  44
    187,249, 25,211, 16,196, 77,121,192,219, 22,124,166,103,144, 22,
    188, 87, 60,153,118,216,133, 99,199,249,142, 27,158,189,117,170,
     18, 94, 48,167,108, 86,197,113, 62,204, 29,168, 11,122,231,170,
     21,126, 37,239,142,172, 78,254, 95,215,144, 38,127,252, 17,179,
     60,205, 29, 82,178,133, 62,208, 27,230,132,
    221,108, 49, 93, 27,133, 84,235, 21,200, 44,119,254, 48,210,137,  //  45
     86,158, 48,178,108,228,162,246, 93, 61,184,254, 50,192, 79,247,
    112,169, 15,227, 40, 75, 18,181, 54, 12,176,104,217,  4,232, 49,
    247,126,217, 74,248,157,226,  3,185,123,218,106,249, 73, 31, 89,
    247,183, 97,205, 18, 47,196,134,182, 10,236, 88,208, 57,153, 77,
    240,131,103,220, 16,112,185, 91,160, 52, 78,
     36,150,190,216,169, 53,197,148, 71,101,181, 17,149,105,  6,234,  //  46
    116, 64,218,141, 68,131, 53, 12,175, 31,131, 85,  9,224, 36,155,
     51,215,125,180, 90,203,243,155,119, 86,231, 56,134, 71,102,148,
     79,173,  7,143, 25, 56,130, 77,161, 38, 81,150, 51,202,156,214,
    113, 48,157, 66,125,232,105, 27, 69,121, 53,184, 23,105,228,123,
      9,190,159, 55,197, 44,225,  1,243,123,180,
    240, 65,128, 20,119,230,103, 34,210,136,240, 74,225,183, 79,166,  //  47
     24,182, 96,  9,253, 34,208,146,105,230,152,205,114,172,129,210,
    100, 25, 70,252,142,107, 34, 69,222,185,147, 20,253,165,194, 19,
    210, 41,200,114,187,216, 39,245,104,194,237,  7,182, 92,133, 13,
     70,201,  9,243,171, 81,155,204,240,171,150,230,132,173, 31,201,
     97, 41, 74,244,128,166, 75,143,102,199, 13,
     85,203, 41,249, 78,  9,159,244, 63,  6,161, 36,124, 51,217,132,  //  48
    245, 42,226,150,184,110, 80,238, 38,195, 73, 53,241, 90, 64,  3,
    175,230,152, 44,  6,168,191,135,  9, 46, 95,202, 66,121, 38,239,
    131,101,235, 60,162, 95,140,200, 18, 55,135,101,222, 33,244,188,
    124,226,141,106, 32,220,  7, 57,109, 34, 92, 14, 65,217, 51,166,
    237,153,207,  6, 97,232, 24,206, 40, 66,158,
    136,106,174,145,208,187, 87,127,176,109,216, 93,202,152, 15, 64,  //  49
    102,196,125, 75, 22,202,136,180, 91,124, 13,178, 24,151,197,248,
    138, 85,198,118,220, 61,238, 99,204,234,125,169, 31,223, 81,176,
     53,159, 85, 23,254,  8, 66,166,119,212,179, 24,153,119, 77, 45,
    169, 23, 83,196, 55,181, 91,138,218,185,252,118,188, 96,138, 85,
     20,128,106,180, 52,152,118,177,255,116,216,
     18,238, 29, 71, 45,112, 28,207, 44,238, 56,187, 28,251, 94,206,  //  50
    158,  1, 58,173,234, 46, 72,  4,158,251,209, 97,219,120, 34, 57,
    111, 29, 67,173, 88,128, 25, 52,152, 72, 16,243,101,146,201,109,
      1,222,185,137,104,190,221, 37,241, 90, 65,252, 48,175,217,108,
    233, 63,163,253,136,110,238,160, 17, 76, 49,148,227,  5,249,195,
     66,222, 47,250, 85,211, 46, 92, 10,167, 51,
    185, 91,211,130,233,173,254, 74,155, 17,122,146, 72,115,177, 35,  //  51
    235,139,216, 92,113,154,210,229, 61, 34,140, 45,166, 75,227,186,
    164,233,210, 14,247,160,214,174,110,190,141, 51,184, 12, 62,251,
    134, 74, 33,230, 46,150,114, 74,146,  7,166,124,193, 69,  1,147,
     35,203, 97,  5, 43,213, 24, 60,201,131,178, 24, 78,162,120, 35,
    147,183, 14,138,169, 22,237,133,203, 79,227,
    149, 59,166, 15, 86,147,  1,130,194, 97,180,217,  5,232,138, 70,  //  52
    112, 45,187, 21,243, 32,127, 99,194, 87,176,108,246, 17,135, 93,
     10,133, 55,146, 39,103, 70,  2,255, 30,226, 89,212,121,163, 40,
    172,206,120,164, 89,239, 16,208,181,102,215, 29, 95,209,127,249,
     85,155,129,218,173, 84,196,120,245, 90,217,112,196, 41,212,103,
    241, 87,118,199, 65,111,190, 59,155, 28,124,
      4,251,101,192,219, 53,103,226, 58,235, 69, 41,160, 85,192, 19,  //  53
    168,249, 76,134,167, 59,182, 15,133,235,  8,195, 65,150,215, 47,
    252,101,189, 87,179,222,143,204, 93,131, 58,152, 23,236, 86,218,
     99, 21, 54,213, 29,175, 59,133, 32,233, 53,148,238, 21,164, 58,
    187, 27,240, 56,113,145, 66,164, 43,  2,154, 59,246,135, 64, 22,
    168, 55,219, 30,232,159,  6, 98,213,240,104,
    207, 49,138, 34,121,170,209, 39,167, 23,140,246,105,206, 42,228,  //  54
     88,124, 10,211,101,200, 79,250,160, 57,117,223, 38,105,188, 78,
    127,204, 24,235,118, 18, 56,183, 39,168,209,106,176, 46,141, 10,
    190,153,248,103,145, 79,192,245, 83,128,198, 70,118,179, 42,104,
    217,119, 77, 18,193,248, 11,228,108,189,225, 27, 97,180,235,122,
    208,  3,147, 97,127, 43,249,144, 38, 67,181,
     86,163,223, 70,245, 17, 73,150,111,199, 84,176, 15,124, 68,142,  //  55
    185,221, 51,144, 28,231, 42,110, 30,214,142, 84,165,238,  1,168,
     30,148, 61,161, 77,246,128,100,237, 78,  7,249, 73,204,113,244,
     75,129, 63,198, 20,226,117,  3,168, 42,175, 10,213, 79,244,139,
     10,174,209,159, 99, 42,135,178, 57,140, 80,127,165,  8, 76,154,
     91,188,254, 69,179,207, 79,186,112,159, 30,
    243,112, 10,153,105,201,132,236,  8,224,131, 63,219,154,255,  6,  //  56
     57, 97,172,247, 83,155,127,173,196, 76, 43,190, 24,125, 62,207,
    242, 88,224,  5,186, 48,158,213, 21,145,192,126, 28,157, 59,168,
     34,231,  6,165,127, 51,161, 94,219,113,255, 91,156, 29,191, 66,
    230, 93, 36,123,225, 73,203, 90, 30,255,205, 50,232,199, 44,226,
     58,129, 35,215, 12, 57,134, 19,230,200,132,
     62,189,213, 43,181, 89, 33,177, 61, 99, 28,191, 38, 82,193,113,  //  57
    158,207, 23,115,188,  2,213, 92, 21,227,154,255, 92,220,157,100,
     39,124,198,101,135,207, 29, 64,179,107, 44,219, 96,236, 14,209,
    103,176, 90,213, 68,251, 37,204, 27, 67,144, 39,234,129,107,166,
     50,149,253, 60,168, 21,114,222,159,116, 13,155, 85,114,141,184,
     22,169,100,153,115,164,242, 83, 41, 96, 13,
    171, 34, 82,128,228, 55,253,107,205,165,247,150,106,233, 51, 32,  //  58
    239, 73,138, 41,229, 58, 78,247,140,104,  6,114, 47,181, 15,140,
    189, 67,156, 34,234, 90,121,251, 88,230,169, 70,140,189,120, 80,
    144,222, 38,112,183,145,101,176,134,227,187,100,200,  4,222, 34,
    199,117,  6,205,138,244,182,  7, 69,194, 94,184, 32,250, 14, 98,
    243,204, 80,239, 45,218,104,176,211,154,234,
    137,103,249,155, 15,118,160, 12,139, 41, 75,  4,208,139,171,122,  //  59
    185, 12,220,168, 99,137,166, 37,186, 55,170,200,136, 65,246, 83,
    215, 10,253, 56,165, 16,184,143,  3,130, 31,200, 19, 55,165,254,
     44, 72,137,234, 16, 57,236, 10, 85, 52, 17,164, 54, 82,152, 96,
    238, 75,171, 99, 27, 77, 44,146,240, 48,216,123, 62,202,161, 65,
    123, 50,137, 23,197, 74,  1,139, 53,116, 67,
    193,  4,179, 66,218,196, 69,216, 91,236,183,127, 86, 26, 72,222,  //  60
     96,146, 82, 48,196,239, 15,209,119,231, 71,238, 25,205,120, 32,
    172,105,133,201,114, 70,219, 54,202, 62,159,248, 94,227,104,  3,
    181,202, 28,159, 94,195,118,210,149,249,116,217,135,246,179, 24,
    134,186, 48,237,121,165,200,100,127,161, 26,236,143,105, 37,221,
    192,  6,231,180,119,157, 41,189,244, 19,219,
     91,229,116, 40,100, 29,127,169, 24,115, 50,218,162,251,187, 18,  //  61
     54,248,179,120, 29, 70,128, 97, 42,157, 12,101,148, 89,165,229,
     49,220, 35, 84,173,245, 34,157,108,236, 83,117,147, 47,207,152,
    123, 91,245, 64,220,141, 30, 49,174, 93,191, 69, 20,104, 45,214,
     64, 13,208,144, 60,230, 86,221, 14, 70,177, 79,  3,229,175, 83,
    147,110,166, 60, 90,251,206,107, 81,168, 45,
    157, 25,139,239,151,184,244, 56,227,190,152, 13,105, 41,129,153,  //  62
    204,111,  8,234,208,156,187,250, 77,213,125,191, 40,242,  4,110,
    143, 71,159,209,  9,137, 94,212, 23,179, 39,194, 10,178, 78, 39,
    224, 19,173,127,  6,170, 82,227,129,  1, 44,161,234,201,148,111,
    251,162, 89, 33,183,  1,137, 42,188,252, 97,200,154, 49,125, 18,
    253, 75, 32,210, 13,137, 65, 24,135,199,120,
     59,214, 83,199, 50, 75,  2,104,141, 83, 63,239,195, 69,230,100,  //  63
     33,162, 67,137, 96, 54,  4,142, 25,171, 80,223,160, 76,184, 60,
    197,249, 21,111,235, 49,185,125, 76,133,224, 67,214,128,247,113,
    187, 62,108,209, 45,253,106,199, 62,239,212,118, 85, 53,  6,191,
     81,124,218,108,239, 74,209,162, 57,141,118, 33,245, 90,216,185,
     43,203,141,236,113,182,227,160,216,  7,255,
    179, 38,170, 11,114,222,163,194, 21,211,113, 44,124,166,  1,209,  //  64
     86,226,193, 23,170,217,115,202, 62,239,111, 20, 57,129,214, 20,
    125, 93,182, 58,152, 79,222,  5,246,171, 20,109,161, 28, 56,146,
     32,242,153, 87,186, 67,149, 15,160, 97,141, 24,186,136,232, 68,
    174, 18,152, 52,164,128, 26,111,226, 17,216, 66,129,168, 62,113,
    155, 98, 51,169, 80, 28, 56,118, 40, 77,104,
    228, 92,131,242,156, 81,129,254, 48,171,231,157, 28,246, 77,177,  //  65
    142, 47,122,254, 75, 38,237, 90,155, 34,205,145,249,172, 91,236,
    156, 42,224,121,203, 32,161,103, 43, 63,140,242, 73,222,102,172,
    213, 73,  9,234,132, 23,236,122,185, 47,204, 65,243, 96,160, 29,
    222, 60,245, 31,193, 95,248, 70,181, 88,157,192, 10,205, 30,225,
     15,244,130,  3,191,247, 95,169,240,187,148,
    125, 19,198, 60, 23,207, 35, 66, 99,131,  8, 87,200,137, 51,117,  //  66
    242, 10, 65,184,105,136,173, 11,124,180, 71,101,  7, 47,119, 31,
    203, 77,169, 20, 94,252,132,209,178,219, 86,197,  1,132,192, 17,
     92,130,199, 41,175, 94,202, 32, 83,250,  8,173,125, 44,198,119,
     93,201,130, 80,214,  9,173,136, 38,243,107, 48,237, 96,131,165,
     69,180, 88,223,108,146,202, 45,130, 12, 65,
     47,248,151,106,233,180,118,160,235,208, 56,183,105,215, 15,191,  //  67
     80,164,219,144, 14,222, 68,197,252, 53,224,158,197,228,178, 84,
    130,  2,241,139,190, 67, 13, 82,122, 21,152,106,180, 42,255, 64,
    231,166,106, 61,227,116, 65,163,220,109,152, 88,212, 14, 73,255,
    143,  4,182,103,150, 53,222, 60,201,  4,147,183, 72,151, 38,238,
    108,211, 29,156, 42, 70, 19,228, 88,195,217,
    113,183, 71, 37,137, 89,  6,194, 31, 82,145,250, 38, 66,151,231,  //  68
    109, 36, 93,196, 59,161, 30, 85,108, 21,129, 40, 78,138, 59,255,
    161,212, 65,105, 41,158,224,196, 54,250, 46,232, 71,159,100,147,
     40,208, 16,137,158,  4,214, 44,135, 68,192, 32,143,229,180, 53,
    170, 76,220, 24,243,121, 94,163,124, 86,226, 28,119,214,177, 57,
      7,144, 65,203,234,139,181,106,161, 32,153,
     91,  3,225,172,211, 49,246,139,105,174, 20,119,169,224, 94, 23,  //  69
    179,239,130, 27,248,120,232,141,216,164,190,245,115, 12,200, 23,
    108, 46,151,200,236,123, 33,110,167,136,202, 17,127,219,  9,196,
    121, 79,240,187, 70,252,127,177, 13,230, 49,246,104, 80,116, 19,
    231, 45,126,166, 41,186, 15,251, 43,210,137, 56,250, 12, 81,195,
    126,255,174,115, 14, 79,251, 51,215, 72,235,
    202,137,100, 28,116,162, 75,215, 55,203,227, 69,  5,130,199, 49,  //  70
    143, 65,208, 77,178, 94, 43,187,  1, 61, 92, 31,169,223,146, 87,
    225,187, 25, 75, 12,178, 88,239,  4, 75, 96,169, 57,186, 84,244,
     29,141, 46,102, 29,193, 76,100,201,154,119,174,  3,161,198,134,
     88,204, 99,232, 71,208,143, 82,181, 19, 97,186,161,110,143,229,
     93, 31, 50, 95,197,126,167,  6,115,141, 22,
    170, 45,252,189, 82,229, 17,125, 25,150, 96,181,242, 84,165,111,  //  71
    215,  3,168,117, 12,205,152, 72,126,233,141,207,100, 63, 35,172,
    123, 80,248,130,222, 54,149,191, 61,181,243,117,227, 31,151,108,
    177,219,159,206,121,154, 19,234, 62, 24, 91,214, 57,224, 27,243,
    165, 33,153,  8,132, 98, 47,233,118,148,239, 71, 37,207, 27, 67,
    156,215,191,148,238, 36, 67,208,182,246, 56,
    221, 75,156, 11,131, 41,198,174,251, 80,127, 28, 48,210, 59,237,  //  72
     40, 98,246,148, 63,227, 33,245,105,197, 52,  9,240,130,195,233,
     43,153, 91,167,106,207, 39,121,224,144, 20, 41,142, 69,207, 19,
     55, 94,  7, 64,245, 40,213,109,140,244,191, 73,143,112, 47,100,
     62,186,252, 59,185,225,163,  6, 74,200, 46,218,132, 89,246,172,
     16,124, 62,  3, 87,219,144,102, 43, 88,121,
    148, 30,114,207,239,150,109, 72, 46,162,232,194,147,121, 14,154,  //  73
    129,195, 69, 35,189,132, 95,172, 15,156, 79,186,150, 28, 76,111,
     16,211,185,  5, 68,135,254, 13,103, 53,217, 86,175,252,116,185,
    224,127,233,181, 86,130,164, 54,178, 36,128, 17,252,189,151,209,
    131, 16,110,144, 85, 27,108,215,174, 30,104,166,  2,193,114, 42,
    223, 99,248,162,119,183, 18,230,174, 11,193,
     99,231,175, 51, 68, 89,224,  1,188,114, 12, 62, 90,254,179, 76,  //  74
    224, 24,174,230,103, 18,202, 68,220, 38,253,116, 91,206,166,251,
     61,126, 75,238,201, 29,174, 83,193,158,124,199, 99,  3, 47,140,
     83,163, 38,109, 46,203,  2,229, 82,207, 99,170, 41, 87,  9,237,
     72,195,224, 36,198,246,151, 54,135,254,125, 56,237,148, 61,185,
    140,199, 71, 30,203, 50, 76,129,153,240, 63,
    136,  4, 91,195, 18,165,201,127,243, 94,219,170,206, 34,104,204,  //  75
     58,109,139, 82,157,249, 43,150,127, 92,175, 20,229, 50,  3,137,
    179,224, 24,143, 50, 94,151,220, 43,247, 11, 65,230,154,213, 71,
    247, 12,210,154,241,174, 96,122, 26,155,238, 65,218,130,177, 56,
    164, 96, 49,171,114, 67, 17,191, 84, 11,211,177, 77, 26,230, 92,
      8, 50,172,226, 97,149,253, 38, 90, 25,210,
     41,243,154,121,254,101, 59, 32,155, 44,139, 26,117, 64,141,  6,  //  76
    167,248, 17,191, 50,120,180,237, 59,215,133, 56,161,125,216, 98,
     33, 88,164,106,181,242,115, 25, 74,111,177,143, 29,114,173, 22,
    188,104, 53,134, 19, 72,146,255,187, 48,137,  5,196,108,227, 22,
    119,249,148,  2,210,134,236,102,227,158, 40, 98,137,206,113,160,
    241,127, 83,135,  9,210,107,188,222,123,176,
    193, 76, 46,210, 27,139,227,182, 84,204, 70,246,153,225,188,237,  //  77
    122, 44,212, 68,220,  4, 91, 37,112,  8,190,241, 88,193, 65,154,
    244,192, 57,212, 14, 68,209,138,190,235, 56,208, 77,245, 94, 57,
    127,237,176, 93,225, 40,206, 11, 70,114,228, 96,156, 76, 37,143,
    211, 80, 59,228, 83, 33,172, 42,123, 65,201,242, 15,182, 38, 59,
    211, 20,192,246, 57,174, 65, 12,163, 53,104,
    148,224,107,180, 82,170, 15,114,234,  9,176,103, 20, 85, 36, 55,  //  78
     93,160,132,102,171,128,228,148,207,163, 79, 30,116, 13,230, 41,
    114,  7,141,233,123,161, 48,  2,155, 85, 16,162, 37,135,192,216,
    158, 34, 71,200,117,178, 89,130,220,167, 21,202, 50,184,243, 94,
    170, 16,190,120,182,150, 71,220,181, 19,146, 72,120,223, 88,142,
    175, 69,110,158, 29,123,238,141, 83,246, 27,
     66, 11,132, 35,238, 52,213, 92,148, 51,131,219,198,162,118,181,  //  79
    215, 10,202, 36,255, 64,194, 20, 85,232, 46,153,213,143,179, 83,
    169,205, 96, 40, 84,200,252,102,226,124,214,105,234, 86,  5, 49,
    108,223,  9,144, 48,247,157, 35,194, 93, 67,250,131, 12, 64,200,
     41,132,241, 28, 92,252,  7,137, 92,248,105,192, 47,167,  6,253,
    117, 43,219, 93,229, 81,198, 31,215,129,202,
    174,249,156,204, 97,126,162, 63,194,241, 81, 41, 96,  3,229,140,  //  80
     80,237, 72,153, 95, 25,162, 57,138,118,182,252, 92, 60, 27,238,
    133, 49,248,178, 23,133, 58,180, 74, 27,174, 44,200,153,182,254,
    142, 89,169,236, 82, 23,112, 65,235,144, 31,161,110,229,150,117,
    225, 99,156, 69,210,111,195, 38,212, 60,164, 25,234,136,102,184,
     23,199,134,  1,186,151, 46,110,165,  4, 93,
    120, 47, 73, 16,183, 39,250,  4,123, 30,172,144,253,184, 70, 31,  //  81
    109,170, 21,192,136,221,107,242,202, 31, 69,  3,129,199,112,212,
     18, 75,115,143,225,106,164, 37,198,139,247, 68,123, 22,113, 64,
     27,204, 40,107,208,163,220,179,  7,116,189,216, 46, 80,178, 20,
     57,194,  5,176, 45,146, 77,167,122, 14,204,117, 66,205, 51,227,
     74,163,240, 72, 38,117,217, 75,194, 51,225,
     21,189,216,116,230,143, 80,188,223,102,207, 23,122, 49,154,242,  //  82
    195, 53,120,244, 48, 73,179, 11,155,100,210,162,227, 46,152, 90,
    164,192,216,  8, 65,202, 14,239,113, 56,  6,148,215, 79,233,158,
    219,129,186, 60,136, 14, 52,127, 87,241, 54,100,  2,204, 93,254,
    136, 86,237,125,218, 22,239, 48,227,146, 83,239,157, 30, 95,149,
    123, 49,104,205,159,243, 25,139,254,104,155,
    240,142, 81,163, 50, 20,170, 90, 47,158, 64,229, 87,202,104, 13,  //  83
    136,217, 87,157,  1,214,130, 51, 78,234,115, 39, 72,180, 11,251,
     64, 36, 98,174,236, 81,150, 95,208,172,222, 82,167, 38,194, 16,
    101, 73,  1,241,195, 91,253,199,154, 21,131,171,245,115,158, 43,
    212,154, 34, 60, 94,183,115,200, 93, 39,186,  3,106,183,248, 10,
    212,186, 19,129, 55, 97,183, 64, 16,179, 79,
     54,110,  6,246,100,212,118,231,132, 11,186,140, 18,162,223, 78,  //  84
     44,163, 27,229,111,194, 92,251,173, 28,185,147,242,106,135,201,
    119,224,148, 55, 30,127,188, 43, 72,130, 34,100,250,127, 54,140,
    245,178,147,113, 35,172,106, 31, 68,223,198, 60,142, 33,189, 68,
     10, 99,204,167,250,140,  8, 67,157,255,123, 69,222,132, 63,161,
     41, 85,252,172,213,  8,223,161,118,208, 33,
    227,171,195, 56,140,186, 60, 28,200,241, 80,110,247, 38,126,192,  //  85
    252,103,184, 68,142, 39,162, 22,137,219, 63,  8, 88,216, 32, 52,
    159, 14,112,248,160,215,105,255, 10,231,159,203, 13,182, 97,204,
     66, 29,214, 82,225, 64,137,232,162,110, 83, 25,209, 86,232,123,
    242,178,130, 14, 71, 42,222,178,107, 19,209,171, 49, 25,215,110,
    234,142,102, 36, 74,144,106, 39,237, 86,149,
     95,128, 37,225, 86, 11,255,151, 97, 39,165,207, 58, 91,176,  7,  //  86
     66,131,207, 16,245, 62,222,114, 80, 98,203,126,191,151, 78,183,
    242, 71,187, 87,  1, 69, 35,151,181, 89,117, 60,141, 78,230,  8,
    167,132, 50,182,153, 21,188, 55,  4,185,139,230,112,174, 26,151,
     82, 49,226,113,206,160,123, 33,235, 52,144, 82,245,153, 86,185,
     71,  4,217,157,193,242, 67,189,135,  2,185,
     29, 76,209,152,112,169, 69,114,181, 62,128,  4,185,229,114,148,  //  87
    221, 33, 93,155,106,176,  6,198,237,165, 20,254, 54, 24,234, 95,
    129, 30,208,122,170,197,223,112, 54,206, 19,241,193, 46,160,111,
    218, 94,250, 10,102,236,121,208, 87,244, 49, 16,148, 54,217, 98,
    203, 18, 68,152, 88,244, 76,192,138, 74,198,117, 10,194,123, 22,
    164,199, 54,114, 14,126, 23,220, 53,111,248,
    157,187,  9, 58,235, 33,219,195, 19,236,214,101,139, 43, 73,199,  //  88
     47,171,238, 71,218,131, 85,144, 34, 61,139,103,178,120,162,  5,
    219,149, 59,233, 47, 91,133, 15,234,146, 83,169, 31,123,244, 73,
     33,189, 61,129,201, 74, 42,151,106,164, 73,189,253, 75,  3,184,
    137,249,175, 30,189, 53,  1, 96,211, 15,161,227,101, 48,210,239,
     40,126,247, 78,222,179, 97,147,174,209, 61,
    222, 82,245,129,176, 94,134, 49,144, 87,160, 28,251,164, 20,244,  //  89
    104,136, 11,192, 26, 47,247,180, 95,188,213, 41,226, 64,201,112,
     44,172, 94,138, 27,247,163, 72,177, 45,128,224,102,207, 18,146,
    173,116,223,151, 31,175,252, 11,226, 33,213, 98,124,160,231,118,
     36, 76,111,232,100,137,236,175,114,247, 37, 66,175,145, 68,103,
    149, 87,175, 41,141, 29,250, 44, 86, 13,134,
     24,108,150, 21, 73,205,  2,246,108,203, 77, 59,187, 97,129,175,  //  90
     82,217, 61,115,145,205, 65, 17,120,240,  8, 88,154, 17,244, 77,
    188,253, 11,215,195,111, 52,212,101,251, 28, 63,158, 88,183, 59,
    238,  3, 87, 53,210, 92,137, 69,184,117,146, 52, 13,199, 90, 56,
    168,199,149, 11,210, 36,155, 73, 45,146, 89,200, 25,250,  7,180,
    228, 22,213,108,193, 64,163,121,232,184, 98
    ,

    //
    // Cyan
    //

     87,195,141,  6,185,154, 78,141, 94,121,252, 82,161,226,195,100,  //   0
    255, 12,201,232, 79,126,230, 48, 75,130,102, 34,139, 16,198,152,
     11,188, 37,100,199,228, 68,191,252,151,  8,101,245, 19,204, 85,
     14, 57,206, 26,103, 45,182, 12,227,153,195,233, 57,147,194, 47,
    151,204,111,248, 80, 32, 51,113,181, 17,141, 69, 13,243, 34,145,
    237,216, 26,117, 62,161, 42,241,175,119,158,
    110, 22,176, 62, 98,209, 30,176,197, 25,207,  8,106,137, 63,128,  //   1
    166, 83,109,149, 34,189,155, 21,253,209,171, 86,211,174, 78, 48,
    212, 80,128,156,  2,138, 44,100, 24, 80,231,139, 42,187, 52,234,
    166,123,247, 77,164,208,142, 59,123, 27, 89,127, 32,210, 10,128,
    227, 39,168, 17,199,124,237,149, 60,250, 86,188,113,204, 60,177,
     19, 56,149,248, 14,191,121, 87, 17, 57,245,
    211, 70,224,118,238, 54,127,227, 58,151, 73,173,219, 37,240, 18,  //   2
    215,191, 23,246, 66,218, 82,114,145, 66, 10,243,109, 40,132,255,
    104,170,232, 69,250,114,212,161,220,183, 56,199,116,159, 79,135,
     95,191,  6,114,229, 20, 92,191,215, 50,252,182, 74,241, 85,184,
     98, 64,219,137, 59,170, 89, 22,207,124,167,223, 42,160, 90,126,
    206,104,189, 76,141,235, 32,217,200,146, 33,
    127,168, 36,151, 17,195, 90,  2,107,239,125, 47, 93,200,157, 52,  //   3
     78,124, 49,174,116, 10,177,227, 28,195,120,153, 68,223,183, 24,
    144, 53, 17,186, 33,176, 74, 10,109,132, 28, 91,225,  2,253, 24,
    208, 38,149,177, 43,133,246, 71,159,104,137, 11,160,112,152, 21,
    255,119, 31, 93,242,  2,219,186, 43,101,  5, 76,131,232,  9,255,
     71,164,  4,210,100, 54,132,163,107, 73,181,
      3, 94,248, 78,178,133,255,165,206, 33,188,234,140, 12,114,182,  //   4
    232,147,220, 91,205,139, 49, 99,164, 53,232, 38,199,  6,116, 88,
    221,193,120, 91,219, 49,149,243, 44,174,248,149, 64,175,102,154,
     55,232, 87,214, 64,184,107,  4, 41,228,195, 61,221, 36,197, 70,
    136,166,208,183,153,106,130, 70,143,231,198,153, 35,192,109,150,
     27,225,129, 43,179,220, 75,  8,254, 41,232,
    192,144, 52,204,105, 28, 49, 79,143, 99, 64, 25,180, 80,245, 91,  //   5
     31, 72,  1,159, 35,238,186, 70,248,135, 89,173,100,145,242,163,
     41, 73,246,164,134,105,195, 81,206, 67, 11,109,209, 34,219,120,
    180, 71,138,104, 15,220,154,236,174, 81, 26,123,174, 99,238, 47,
    213,  9, 78, 56, 28,202, 47,253,175, 32, 64,246,101, 62,216, 43,
    180, 97, 63,250,149, 20,169,194, 91,154,109,
     70,214,116, 12,231,159,219,187, 12,244,160,118,210, 48,151,125,  //   6
    208,167,251,123, 62,107, 19,208,112,  4,214, 25,229, 51, 77, 18,
    212,137,  5, 66, 30,238, 15,140,114,161,233,187, 48,144, 74, 26,
    240,  8,195,251,127, 79, 49,131, 98,205,149,246, 73,  1,142,171,
     87,109,246,133,232, 86,164, 10,117, 92,134,180, 25,170,133, 80,
    238,143,200, 32,114, 88,238,123, 28,208, 47,
    245, 34,152,187, 66, 92,121, 59,133,197, 77,228,  4,170, 66,189,  //   7
     16, 89, 47,190,223,169,138, 40,157,192, 71,153,123,185,205,125,
    176,103,227,187,210, 88,179, 41,218, 22, 74,131, 96,247,199,159,
     97,147, 61, 35,157,197, 18,211, 59, 10,109, 41,185,219,118, 23,
    227,146,192, 17,102,146,210, 80,187,228, 15,212,117,237, 10,191,
    114, 17, 77,174,223, 50,141, 65,228,117,175,
    132, 89,235, 40,137,242, 33,212,102, 26, 53,146, 90,254, 33,215,  //   8
    111,230,146, 96, 11, 74,245, 93,231, 51,108,245, 42, 92, 27,252,
     54, 83,146, 45,123,159, 61,235, 96,145,201, 31,172,  7,116, 46,
    225,204,122,186, 91,238,107,145,254,178,223,160, 97, 53,201, 65,
    179, 74, 44,166,218, 72, 21,243,139, 43,161, 56, 86,156, 70,221,
     51,161,243,126,  7,208,186, 16,160, 77, 22,
    167,  5,177,107,205,  9,181,144,249,164,207,112,193,130, 80,138,  //   9
     56,177, 37,209,135,186, 54,205, 17,147,179, 11,216,168,112,152,
     10,236,180, 19,100,248, 11,124,188, 50,226, 83,236,140, 67,178,
     25, 81, 13,229, 55, 24,170, 69, 30,123, 76, 18,241,145, 32,250,
    125,  6,233,113, 50,196, 40,110, 68,199,100,247,188, 41,127,174,
    103,207, 39, 98,156, 69,106,251, 44,200,224,
     63,123,219, 57, 84,163, 52, 76, 40, 95, 15,238, 48, 18,221,165,  //  10
    243,  6, 78,249,111, 26,160,104,128, 83,208, 75,140, 58,195, 79,
    208,128, 68,204,150, 75,213,161, 69,  4,157,105, 54,194,219, 93,
    254,141,175,104,163,127,222,188, 97,151,215, 56,111,189, 81,103,
    164,207, 91,142,252,177,130,165,234,  9,147, 31,113,205, 24,253,
      1,139, 66,194,234, 35,173,124, 81,139, 98,
    248,197, 44,147,253,116,224,191,128,227,171, 70,153,183,107, 29,  //  11
     90,126,194,156, 63,202,239, 46,193,255, 31,122,241, 23,225, 45,
    173, 29,108,225, 47,178, 30,105,202,253,126,188, 16,118, 31,154,
    115, 51,216, 37,249, 87, 57,  3,239, 42,196,132,227,  9,153,212,
     25, 61,188, 31, 75,  2, 95,208, 55,126,221,176, 76,234,151, 61,
     94,229,178, 16,132, 90,216,  3,236,182, 18,
    154, 28, 93,172, 18, 39,142,100,  2,198, 32,133, 91,233, 58,206,  //  12
    147,226, 44,100, 10,131, 86,150,  2,168, 55,156, 94,179,114,143,
     95,244,157,  1,136,115,230, 54,138, 88, 45,215,162,243, 61,184,
      1,199, 72,133, 12,198,141,211,117,161, 87, 36,167, 68,234, 51,
    137,241,157,117,222,155,239, 78, 34,192, 88, 18,139, 45,106,200,
    165, 32,117,249, 72,200,144, 56,157, 41,113,
     74,186,237,108,194,218, 62,245,157, 57,111,248,200,  5,124,176,  //  13
     67, 17,166,236,179,210, 34,232,116, 78,227,196,  7, 69,234, 13,
    211, 37, 65,183,250, 84,190, 13,166,221, 20, 68, 92,135,204, 80,
    236,165,107,224,156, 48,102,170, 74, 24,247,183, 99,128, 22,184,
    109, 86, 10,205, 46,128, 21,175,146,103,252, 60,215,187, 13,127,
    222, 85,155, 55,169, 19,110,226, 87,201,223,
    143,121,  7, 68,131, 89,173, 27, 77,222,177, 49, 81,168, 38,251,  //  14
    103,215,120, 82, 51,112,163, 60,200,132, 35,102,218,127,157, 62,
    177,132,203, 96, 27, 59,149,239, 71,121,185,148,226, 12, 45,103,
    134, 21, 44,182, 90,242, 17,226, 52,205,124,  5,224,197, 85,254,
    166, 55,230,101,170, 64,202,110,227,  6,168,117,157, 94,246, 68,
     38,189,  9,214, 98,240, 41,184,130, 11, 59,
    243, 48,199,230,163, 13,213,126,200, 93,135, 26,153,226, 90,137,  //  15
     53,193, 33,150,253, 19,217,102, 23,248,176,149, 49,186, 26,252,
    109, 76,238,122,162,218,105, 36,203, 98,243, 31,109,173,251,158,
    211, 69,247,123, 62,191,148,121,180, 92,150, 71, 46,153, 36,134,
     17,198,144, 26,192, 92,250, 39, 68,203, 45,234, 21, 56,163,203,
    138,236,106,142, 31,192,154, 78,255,105,173,
     20, 95,152, 60, 38,243,108, 47,153,  7,231,190,115, 18,204,181,  //  16
     13,156,228, 66,189,140, 76,183,147, 57, 90, 16,240,111, 83,198,
     47,168, 20, 52,188,  8,130,180, 63,  3,168, 76,203, 59,125, 38,
     89,177,144,  6,209, 34, 82, 41,253, 16,216,177,244,107,217, 67,
    227,116, 74,240,131, 10,159,135,185, 94,148, 75,132,225,107,  4,
     82, 45,176, 69,224,125, 57, 18,167, 44,209,
    125,181,220,115,140,185, 72,168,254, 61,104, 70,247, 57,121, 74,  //  17
    244, 85,106,  5,122, 40,225, 10,236,113,212,193,133, 54,223,145,
      5,232,137,212, 91,232, 78,254,146,216,123, 44,139,222,  6,194,
    229, 27,103,233,153,114,229,163,104,136, 51, 90,129, 13,185,101,
    168, 47,180, 36,215, 56,224, 29,114,246, 12,212,190, 47,179,145,
    220,120,249, 16,168, 81,209,118,225,140, 67,
    239, 35, 85,  3,209, 92, 18,207, 33,140,216,164, 34,150,221,165,  //  18
     28,132,173,201,236, 88,166,131, 45,170, 34, 68,161, 12,176,119,
     93,192, 67,112,154, 30,172, 55,106, 35,190,247, 96,180, 78,108,
    147, 62,197, 46, 87,184, 20,206, 60,194,231, 22,164,208, 57,143,
      7,249, 88,151,101,123,177, 83,205, 50,171,108, 82, 27,254, 91,
     23,183, 59,150, 94,241, 37,185, 91,  7,193,
     73,144,171,251, 43,150,236,123, 96,178, 12,126,205,101,  1, 65,  //  19
    195,219, 69, 31,152, 51,195,105, 73,220,121,254, 99,233, 74,209,
     53,158, 24,245, 45,199,128, 11,223,163, 82, 11,156, 29,240,167,
     17,255,132,170, 28,245, 67,126,  5,154,100,187, 72, 38,235, 82,
    212,128,189, 16,207, 67,245,  2,158,130, 68,237,141,168, 63,206,
    158, 39,211,108,196,  2,142, 71,246,164,108,
     14,229, 50,131,106,192, 67, 40,199, 75,244, 43, 86,172,236,142,  //  20
     98, 40,119,244,102,216, 16,249,184,  1,152, 25,186, 43,148, 22,
    251,102,205,133, 74,227, 85,189,135, 62,234,113,214, 68,133, 48,
    202,114, 73,211,110,138,176,218, 86,239, 33,134,252,123,158,195,
     25,106, 45,234,161, 28,145,105,234, 36,214, 19,196,102, 14,131,
    110,235, 85,138, 55,222,170, 43,131, 32,211,
    178,105,203, 69,226, 10,173,133,223,156, 58,186,222, 21,117, 49,  //  21
    255,153,179, 20,144, 79,134, 56,144,100,200, 70,125,218,110,179,
    130, 40,176,  2,168,117, 27,246, 98, 19,182,137, 39,196,103,224,
     82,183,  2, 55,235, 14, 97, 38,143,172, 57,197, 91,  1,101, 51,
    140,226, 66,133, 87,187, 57,200, 79,181, 96,123, 43,244,185,221,
     68, 10,168,243, 23,118, 85,195,220, 63,124,
     82, 39,156, 27,164, 82,249, 31,108, 20,100,124,146, 72,211,184,  //  22
     77,  7,229, 67,201,173, 34,219, 83,241, 46,230,156, 85,  6,234,
     66,219, 86,239, 54,213,155, 51,145,221, 46, 90,252,172, 21,155,
     37,140,227,166, 84,156,195,251, 66,108,210, 25,164,220,185,245,
     77,175,202,  5,255,114,217, 42,139, 11,157,233, 65,152, 85, 32,
    149,198, 47, 74,188,152,254, 13,104,160,243,
    194,132,248, 97,214,117,147, 56,178,239,202,  6,250, 40,151, 27,  //  23
    132,203,103,125, 46,238, 96,180, 14,162,114, 18,181, 39,201, 94,
    154, 19,123,148,103, 14,194,113,174, 80,206,152,  4,123, 62,242,
    205,102, 47,128,202, 63, 29,117,183,  8,232,121, 69, 41,129, 15,
    152, 29,112,156, 71,169, 20,120,243,195, 55,204,136,  3,171,117,
    251, 95,133,211,104, 33, 70,135,184, 54, 19,
    226, 75,  8,187, 54, 22,198,218, 88,141, 67,169, 87,191,106,235,  //  24
     85,171, 35,218,159,  4,119,138,209, 77,195,140, 58,242,134,172,
     52,209,190, 61,177,250, 71, 37,239, 16,120,192, 71,232,144, 95,
     10,176,249, 19,108,237,136,206, 45,156, 77,142,247,177, 84,194,
    104,241, 50,225, 36, 98,230,154, 69, 99, 27,113, 80,212,231, 60,
    186, 37,226,  5,162,233,200, 45,238, 96,149,
     29,177,110,230,137,174, 76,  2,126, 40,232, 31,122,224, 52,160,  //  25
     12,246, 66,139, 89,205, 62,251, 50, 28,236, 98,207, 78,112, 11,
    249,101, 32,232, 21,126, 97,212,129, 63,230, 38,109,175, 27,193,
     66,134, 81,212, 54,173, 12, 82,243,103,192, 52, 14,109,228, 47,
    216, 67,179,122,208,186, 59,  7,179,220,162,251,187, 42,103, 21,
    143, 75,175,121, 55, 91,115,148,  3,210,120,
    198, 47,143, 34, 67,246,111,235,167,193, 99,150,180, 20, 74,215,  //  26
    125, 97,190, 19,242,170, 30,189,111,159,128,  4,166, 30,217,186,
     72,149,119, 76,153,221,170,  4,149,182, 93,166,221, 50,213,119,
    228,164, 34,187,142, 95,215,164,129, 20,225,168,209,148, 26,160,
    128,  7,149, 81, 22,143,110,247,127, 37,140, 14, 65,132,161,199,
    238,111, 30,248,195, 16,176,226, 86,173, 60,
     95,234,165,208,103, 24,157, 50, 80, 16,213, 58,240,108,144,185,  //  27
     42,167,228, 50,117, 72,144, 93,214, 64,184, 86,255,140, 56,121,
     23,236,169,208, 41, 87, 55,200, 46,251, 29,140,  8,101,153, 56,
     14,102,238,120, 17,252, 45, 73,198, 64, 38,118, 93, 60,241, 72,
    207, 98,188,251, 56,219, 83,196, 54, 79,200, 93,179,241,  7, 79,
     46,211,155, 62,130,219, 77, 42,134, 25,245,
     67,125,  5, 82,180,216,132,196,224,113,138, 29, 79,205,  8,253,  //  28
     82, 24,106,152,196, 16,226,174, 12,239, 36,198, 43,103,232,171,
    203, 49, 90,  7,185,144,237,122, 84,113,209, 76,242,191, 80,254,
    136,184, 49, 74,200,154,125,  6,237,141,161,255,  3,189,121,176,
     19,232, 41,116,163, 15,173, 30,156,237,115,218, 27,107,217,123,
    183, 87, 11,180, 93, 26,161,252,203,110,155,
    217,193, 54,255,118, 66,  9, 97, 41,161,251,190,128,165, 52,119,  //  29
    209,138,218, 63,237,124, 82, 43,137, 79,148,118,218,160, 14, 85,
    141,108,223,127,253,107, 19,158,223, 11,132,161, 55,121,166, 26,
    202, 89,144,219, 28, 87,230,171,111, 90,191, 73,135,224, 35,104,
    149, 78,137,217, 91,242,131,206,103,  1,173, 67,155, 51,167, 34,
    146,236,114,226,138,197, 53,101,  9,180, 48,
     18,100,163,140, 35,228,150,242,181, 70,  4, 92, 43,218, 96,172,  //  30
     60,182, 10, 94, 35,156,189,252,111,221,177,  8, 93, 65,191, 46,
    248, 19,175, 55, 30, 71,197, 42,180, 64,202, 32,233, 14,223, 68,
     44,229,  1,162,112,186, 50, 75,213, 19, 51,217, 28,162, 58,250,
    182, 30,202,  4, 63,112, 40, 72,229,142, 50,254,133,197, 91,244,
     61, 22,200, 44, 74,233,120,154, 72,227,141,
    173,230, 24,214, 96,170, 56,126, 26,109,210,158,236, 23,141,240,  //  31
     39,108,248,168,204,102,  1, 68,165, 23, 61,245,201,145,236,123,
    162, 74,209,150,217,132,232, 82,139,247,100,178, 86,148,106,181,
    126,170,102,247, 37,139,205, 26,149,240,122,173, 85,111,196, 93,
     53,236,109,165,190,146,222,163, 21, 89,202, 16, 76,226,  9,190,
    130,173,100,157,  1,175, 24,239,190, 37, 83,
    120, 57,130, 72,194, 13,207, 88,192,238,135, 61,111,191, 85,  5,  //  32
    199,151, 66,130, 49,238,136,216, 45,207,105,134, 30, 55,105,  3,
    198, 40,115, 87,182,101,  1,167,108, 18, 49,123,207, 40,216, 81,
    240, 21, 72,196, 65,232, 98,130,182, 57,201, 12,245,140,218,  7,
    123,152, 84, 44,213, 56, 27,192,116,240,179,127,105, 41,150,110,
     72,223, 53,252,115,215, 95, 55,131,106,242,
      3,186,245, 39,148,112,251, 46,155, 75, 22,178, 47,152,225,119,  //  33
     76,229, 15,217, 88, 23,192,116, 90,146,186, 78,166,227,182, 85,
    222,134,242, 13, 46,246,191, 68,222,197,165,239, 62,172,  7,140,
     55,202,131,155, 10,171, 41,253, 15, 83,103,157, 47, 79, 38,164,
    192,220, 21,240,123, 99,248, 82,150, 36, 60,159,219,176,248, 33,
    207, 12,146, 79,167, 37,143,178,220, 29,202,
    143, 98,159, 80,230, 31,167,132, 11,224,103,204,254, 17, 67,180,  //  34
    139, 38,191,108,178,144, 73,231,  9,248, 38,214, 11,128, 44,155,
     23, 62,173,146, 72,154, 30,129, 45,145, 81, 11,131, 94,252,184,
    112, 32,224, 83,113,215, 89,119,210,170,236,128,209,175,233,105,
     27, 67,137,173, 14,183,133,  5,221,101,205, 22, 82, 55,131, 93,
    182,120,232, 26,209, 64,246,  8, 88,160, 67,
     39,197, 16,209,101,188, 67, 96,199,171, 42,136, 80,124,214, 48,  //  35
    247, 94,158, 60,255, 38,164, 54,124,159, 69,111,240, 95,196,254,
    113,191, 93,213,112,225, 92,201,254, 26,115,223,196,158, 25, 79,
    217,167, 64,250,185, 21,160, 49,145, 65, 32, 75,  8,116, 64,148,
    244, 96,205, 55, 90,212, 63,159, 75,174,124,230,147,195,  5,225,
     66, 39,172,104,134,193,112, 49,204,114,253,
     90,222,123, 59,137,  4,213,239, 53,115,242,  1,165,196, 30,112,  //  36
    172, 19,213,122,  5,203,101,182,216, 20,205,178,148, 19, 64,140,
     37,230, 16, 52,181,  8,166, 56,103,162,186, 56, 35,110,228, 48,
    148,  4,120, 36,142, 60,238,194,  3,226,199,137,251,192, 20,214,
     42,165,115,251,148, 32,238,196, 29,253, 14, 94, 38,242,106,163,
    135,203, 81,241, 12, 86,162,235,135, 15,169,
     50,154, 32,180,235,162,121, 37,150, 75,158, 61,233, 95,144,230,  //  37
     81,135, 43,230, 86,130,242, 29, 92,135, 47, 87, 39,232,107,215,
     84,158,121,250,138, 68,239,127, 16,233, 89,138,244, 73,136,200,
     92,241,176,206, 99,219, 77,130, 88,114,163, 92, 39,157, 94,131,
     81,199,  2, 48,178,124, 96, 46,107,135, 57,189,127,170, 24, 55,
    255, 20,157, 47,180,222, 30, 58,181, 76,232,
    190,105,247, 86, 24, 61, 91,184, 22,212,190,110, 27,175, 71,  9,  //  38
    206,188,103,156,184, 46,152, 66,229,165,251,121,208,154,188, 24,
    174, 61,203, 33,100,191, 36,208,146, 65,197,  3,168,208, 15,172,
    116, 45, 80,133, 10,155, 43,174,249, 54, 25,183,219, 56,235,182,
     33,139,230, 79,220, 14,185,145,219,202,156,236, 63,212, 84,191,
    116, 95,217,140, 60,120,152,107,215, 28,124,
      6, 63,136,214,116,200,254,138,227, 96, 13,142,218, 45,244,151,  //  39
     38, 76,248, 13, 71,225, 18,201,113, 12, 58,183,  3, 78, 51,127,
    246,  5,145, 86,235,157,115, 84,178, 33,220,123, 46,105, 60,233,
     28,193,219, 57,245,188,119, 16,203,135,233, 76,118,146, 13,110,
    246, 60,173,101,153, 71,234, 56, 25, 84,  8,101, 40,118,155,224,
     36,176,  9, 85,249,188,  3,240, 90,163,206,
    233,174, 21,155, 44,168, 17, 77, 48,123,249, 64,198,129, 98,212,  //  40
    119,166, 49,137,207, 97,127,170, 75,194,146, 93,235,136,226, 90,
    194,104,226,171, 17, 53,214,  6,250,102,157, 77,192,248,133, 85,
    156,123, 20,168, 85, 34,214, 67, 98,159,  7,198, 32,177, 73,211,
    153, 21,123,201, 29,208,113,162,248,126,175,200,146,246,  2, 60,
    142,239,122,201, 35,102, 68,197,134, 39, 77,
    119, 94,196, 72,234,100,131,178,204,154, 35,167, 88,  5,186, 64,  //  41
     15,223,193,107,174, 53,253, 42,217, 30,243,115, 36,176, 18,165,
     34, 70,126, 62,219,136, 73,163,130, 51,235, 25,148, 10,178,214,
     50,255, 97,143,232,109,148,235,189, 46, 88,130,253,101,194, 42,
     92,190, 73,255, 51,140,  5, 92,190, 66, 35,219, 23, 71,173,102,
    208, 74, 48,167,135,216,172, 22, 58,252,150,
    215, 34,249,122,  9,212, 52,244,  3, 70,222,105,237, 53,162,250,  //  42
    130, 89, 28, 66,232,  1,158,102,135, 83,165, 70,200, 59,217,108,
    236,157,199, 39,183, 95,240, 40,186, 87,202,120,218, 53, 75,113,
     15,175,203, 62,  2,181, 54, 19,126,242,169,211, 52,156,  4,242,
    128,222,  9,149, 89,178,238, 47,138,229,107,134, 87,195,227,133,
     29,186,109,229, 12, 80,114,222,165,105, 14,
     75,159, 58,182,147, 82,161,116, 92,198,130, 19,194,137,109, 23,  //  43
    197,151,242,163,126, 91,208, 26,233,190,  7,221,125,154, 84,139,
     54, 15,255,112,153, 10,198,117,230, 12,167, 42,104,189,241,163,
    131, 78, 30,225,134,210, 96,173, 75, 36,106, 18, 75,230,138, 64,
    169, 45,117,186,221, 59,122,213, 22,169, 56,251,162,118, 15, 55,
    158,252, 21, 72,155,247, 45,142, 84,202,181,
    137,224,107, 26,204, 41,221, 32,236,164, 53,174, 79,215, 44,226,  //  44
     74, 40,109, 16,201, 58,131,172, 64,112,152, 55, 31,237, 11,210,
    189,124, 86, 32,228, 57,142, 33,100,145, 77,253,139, 89, 30, 60,
    234,192,153,107, 72, 39,244,141,197,225,149,186,122,202, 28,106,
    215, 85,236, 35,108, 15,160, 84,197, 79,  6,185, 36, 65,239,182,
     93,123,210,176, 38,124,187,  9,230, 29, 51,
     89,  1,168,234, 95,130,189, 68,141, 14,110,254, 36,157, 99,179,  //  45
    126,168,213, 52,177,225, 19,246, 36,212, 89,254,182, 98,164, 41,
     78,161,217,192,100,176,249, 71,219,188, 28,174,  8,222,149,206,
      6, 95, 45,249,165,191, 14,113, 65,  7, 85,247, 35, 95,178,149,
     14,192,159, 71,136,206,250, 38,117,238,139, 84,202,150,100,214,
     18, 60,141, 88,201, 97,236, 74,121,154,242,
    127,197, 45,141, 63,243,  8,122,177,217, 61,187,128,  7,238, 58,  //  46
     13,252, 85,146,115, 77,153, 93,120,165, 15,141,121, 64,227,115,
    246, 58,  1,144, 64,122, 20,164,125, 53,210,111, 64,184,119, 81,
    173,125,204, 23,121, 93, 57,228,168,214,139, 57,166,219, 48,252,
     66,125, 21,244,172, 62, 95,145,180, 29,211,108,231, 10,130, 72,
    163,237, 33,227,  2,157, 51,175,216, 62,187,
     19,255, 84,214, 20,170,103,227, 84, 30,149, 88,227, 70,201,146,  //  47
    188,106, 34,219, 11,242, 51,182,220, 71,193, 49,218,  6,195, 29,
    138,182, 96,237, 30,189,210, 96,  4,245, 88,152,238, 43, 20,250,
     53,223,147, 66,236,202,156, 31,125, 39,108,203, 15,133, 88,196,
    110,231,151, 97, 30,195,  1,227, 54, 88,157, 23, 59,169,246, 45,
    203, 98,189,118, 70,209,138, 17, 99, 39,107,
    164, 52,155,112,192,133, 41, 59,186,246,116,206, 44,172,114, 37,  //  48
     76,206,159, 63,179,134,206,  4,139, 39,235,101,149, 87,157,100,
    211, 45,128,201,159, 79, 39,226,141,169, 37,201,133, 83,203,140,
    103, 15, 88,180,  4,136, 75,254,198, 94,237,151, 79,233, 27,143,
      4, 57,203, 46,222,129,158,104,203,124,253,189,119, 81,193,110,
     14,150, 53,168,239, 28,110,250,198,144,224,
     67,121,229, 31, 69,250,204,156,129,  4, 58,159, 16, 96,247,131,  //  49
    224, 20,124,235, 97, 33,107, 79,249,111,170, 18,200,250, 50,175,
     16,242, 72, 13,110,248,129, 58,198,112, 70, 16,102,226,167, 47,
    191,154,232,114, 44,221,104, 21,178, 68,  5,175, 43,106,161,226,
    179, 86,136,174,109, 68,247, 28,172, 12, 75, 48,226,143, 31,224,
    128,255, 26, 83,134,184, 66,161, 80, 25,192,
    239,  5,202, 97,163,  9, 91, 35,231,106,193,240,137,210, 72,  2,  //  50
    150,180, 89, 47,200,172,229,157, 28,187, 57,129, 74, 27,115,230,
     84,145,172,223, 36,152,184, 93, 24,230,175,217,156, 64,  1,122,
    240, 72, 33,199,159, 59,187,150, 47,141,210,121,247,188, 74, 35,
    113,212, 24,242, 11,188, 48, 81,233,136,215,154,  3,186, 58, 91,
    175, 70,194,223, 97, 43,211,  6,229,130, 94,
    172,141, 47,182,127,214,115,184, 81,166, 77, 23,111, 51,190,234,  //  51
    104, 65,250,145,  7, 76,128, 53,201, 90,231,161,219,180,138, 58,
    204,119, 49, 91,204, 62,  7,240,120, 45, 84,127, 41,252,185, 90,
     25,209,134, 92,249,125, 10,231,115,243, 90, 58, 21,134,208, 58,
    250,129, 52,160, 87,138,210,155, 99, 40,182,111, 89,243,120,210,
      7,147,116, 16,155,245,118,146, 53,184, 35,
    109,218, 83,241, 64, 44,234,139, 15,211, 38,226,181,145, 26,160,  //  52
     42,192, 26,212,117,244, 20,215,138, 12,120, 46,  3, 86,211, 33,
    161,  6,251,178,139,107,210,166,141,196,238, 10,200,106,139,223,
    162, 50,179, 13, 69,196, 97,205, 70, 25,194,158,222,100,  8,171,
     92,191, 76,221,120,238, 16,114,201, 70, 19,232, 49,169, 23,156,
    241, 60,204, 53,188, 31, 78,204,103,252, 69,
    134, 22,160, 11,148,199, 25, 75,254,113,154, 97, 56,249, 83,112,  //  53
    219,132, 99,160, 67,169, 96,179, 69,254,184, 98,238,154,107,244,
     76,197,110, 20, 74,231, 32, 85, 17, 56,159, 94,149, 58, 21, 75,
    119,246,102,206,142, 31,164, 43,145,174,112, 38, 78,184,238,137,
     33,147,  5,199, 37, 65,177, 45,251,162,119,207,143, 79,196,103,
     36, 91,230,143,106,233,177, 13,161, 24,209,
     63,245,102,216,117, 85,176,152, 53,191, 65,206,122,  8,169,201,  //  54
     63, 11,230, 36,204, 51,236,115, 35,150, 59,136,192, 62, 21,171,
    129, 54,148,223, 42,153,116,198,253,107,187, 26,212,242,170,198,
      8, 62,155, 39,239,119,226, 86,239,  1,207,253,147, 48,111, 70,
    207,233,113,168, 98,148,229, 88,138, 33,187, 95, 11,253, 46,138,
    218,127,167,  9, 73,134, 57,221,129, 92,181,
     35,189, 52,169, 66,246,124,224,  3,134,233, 21,178,223,135, 32,  //  55
    243,144,181, 92,125, 22,143, 77,228,199, 15,220, 38,116,205, 83,
    234, 26,207, 80,184,243, 50,170, 70,135,229, 77,123, 34, 99,144,
    214,129,223, 80,175, 56, 15,183,105,134, 58, 97, 12,220,161, 17,
    175, 40, 62,255, 18,207,118,  9,212, 69,237, 57,176,113,204, 68,
    185, 25, 81,252,197, 27,170, 83, 44,235,150,
     83,222,137, 29,186, 16, 47, 92,185, 81, 42,148, 89, 40, 71,104,  //  56
    174, 81, 47,253,152,219,183,  4,165, 89,125, 79,176,250,147,  8,
    181, 97,164,126,  2, 94,132, 25,221,  5, 48,154,181, 65,230, 45,
     87, 36,185, 11, 96,217,141, 68,213, 32,167,188,119,199, 83,247,
    125, 94,189,132, 84,165, 59,194,109,158, 22,132,231, 31,160,  6,
    241,112,178, 46,153,218,105,248,194, 15,118,
    165,  1, 91,237,107,206,162,217,111,243,173,114,252,188,156,234,  //  57
     15,127,206,  9, 69,101, 59,208,132, 27,235,156, 24, 93, 57,228,
    118, 48,254, 60,218,176,207, 86,158,193, 98,249, 19,205,127,174,
    255,150,113,243,166,117,195, 25,156,245, 79,228, 64, 29,144, 52,
    213,159, 23,224, 50,240,143, 29,245, 87,216, 99,151, 76,224, 95,
    144, 38,224, 94,121, 59,  4,131,156, 69,214,
    252,128,201,156, 59,134, 78, 33,142, 24, 55,197,  6, 60,120,199,  //  58
     54,225, 96,164,193,239,119, 42,249,102,195, 66,224,133,203, 37,
    143,196, 18,111,142, 30, 58,247,114, 60,215,118, 83,148, 30,109,
      2, 63,200, 27, 74, 44,240, 89,114, 43,143, 22,128,175,223,109,
      6, 69,200,100,175,  4, 81,180,129, 40,174,  2,193, 52,129,182,
     69,205,157, 14,243,143,210, 39, 98,188, 49,
    102, 24, 79, 40,222,  8,253,191, 71,164,229, 94,143,213, 22, 91,  //  59
    146,183, 28,137, 54, 24,172,148, 74,177, 49,118,  1,169,107,177,
     71,237, 85,163,231, 99,167, 11,145, 33,167, 11,191,238, 77,218,
    180,232, 99,140,224,151,  5,172,222,190,101,204,248, 94, 39,188,
    148,245,118, 39,136,198,106,221, 72,205, 62,251,117,211, 38,247,
     20,122, 52,190, 69,175, 87,164,233, 18,143,
    173,194,242,115,181, 97,152,119,222, 12,129, 66,238,108,168,241,  //  60
     36, 66,249,114,217, 81,229,  9,205, 30,154,241,207, 80, 28,218,
     11,128,183, 36, 65,200,127,224,185, 89,244,136, 44,169, 54,135,
     92, 20,164, 54,109,209, 65,130, 52, 17,161, 59,  7,140, 71,237,
     85, 32,171,214, 64,234, 50,151, 12,163, 98,139, 25, 89,162,105,
    146,236, 88,220,113, 25,238, 61,121,204, 74,
     33,130, 64,165, 26,215, 37, 56, 96,180,207, 42,176, 30, 63,124,  //  61
    203,106,174,  2,155,195,131, 90,113,222,133, 91, 43,149,250, 97,
    158, 49,209,119,246, 20, 86, 42, 65,208,111, 68,220,100, 23,205,
    153, 48,193,248, 14,184, 98,251,196, 83,236,121,184,217,160, 14,
    127,221, 95, 13,161,123, 27,248,111,216, 35,170,191,230,  9,215,
     62,178,  3,151, 44,188,137,  9,178, 42,239,
    106,220,  5,231,136, 70,198,166,243, 34,112,154, 84,191,223,  9,  //  62
    162, 83,227, 48,101, 61, 38,255,183, 71, 16,175,196, 65,131,192,
     73,231, 95,  4,172,142,194,241,140,  5,177, 34,150,197,119,244,
     71,220,125, 83,135, 42,158, 29,106,140,208, 74, 33,100, 56,205,
    175, 63,144,253, 72,191, 93,174, 55,131,236, 78, 44,126, 69,186,
     39,102,207,125,247, 92,223,108,216, 89,157,
    202, 82,151, 51, 98,247,123,  8,140, 88,217,  1,251,133, 99,147,  //  63
    245, 21,138,206,168,236,148, 14,162, 52,244,105, 29,214,  7,114,
     41,167,136, 69,220,102, 31,116,169, 95,231,127,240, 16, 84,172,
     10,108, 31,169,202,237, 81,213,173,  3, 49,158,254,135,227, 25,
    106, 41,201,108, 44,231,139, 17,198, 87,  7,206,155,239,107,142,
    254,160, 32, 59,169, 15, 69,160, 55,132, 19,
     47,175,113,205,161, 20,183, 75,234, 53,178,120, 65, 23,214, 44,  //  64
     72,189, 64,119, 24, 78,210,122, 95,201,129,159,228, 94,172,237,
    202, 22,251,187, 40,160, 75,212, 53, 23,195, 81, 55,182,140, 44,
    198,147,243, 76, 50,111, 16,134, 68,244,182,109, 20,194, 84,129,
    187,240,  1,169,132, 30,211, 75,241,147,178,103, 62, 15,213, 29,
     73,119,233, 82,212,143,195, 37,228,180,253,
    126, 13,242, 35, 80,217, 49,114,200,155, 27,229,193,162, 89,179,  //  65
    126,221, 38,249,179,109, 44,186, 34,232,  4, 74, 50,139, 36, 67,
    144, 86,108, 55,129,239, 20,179,255,153,119, 29,212, 98,249, 69,
    226, 92,189,  4,227,155,192,221, 40,119, 81,210, 65,151, 40,234,
     70,148, 89,225, 79,183,111,162, 45,116, 25,252,134,196, 93,163,
    222, 14,189,132, 22,102,235,117,  2, 94, 67,
    220,188, 58,129,177,100,144,224, 16, 95,131, 77, 36,116,231,  7,  //  66
     81,159,100,146,  6,231,142,222, 65,152,114,179,199,253,118,191,
     13,209,163,222,  9,196, 83,125, 61,102,226,166,131,  2,161,120,
     18,136, 56,166, 85,126, 30, 96,159,232,146, 10,241,117,181,  9,
    163, 46,118,198, 24,247, 65,  5,224,190, 77,213, 35,173, 50,130,
    199, 56, 92,174,250, 48, 78,170,136,199,159,
    104, 78,149,227,  3,254, 31,168, 61,187,244,158,206, 57,144,192,  //  67
    239, 20,216, 75,198, 54, 93, 12,173, 86,242, 43,104, 10,164, 90,
    241,122, 29, 79,143,104,218,148,  6,202, 43, 72,236,196, 41,217,
    185, 35,239,105,211, 53,252,174, 14, 57,198, 48,171, 86,216,101,
    202,249, 17,145, 54,154,125,177, 94,138, 51,154,109, 71,246,  1,
    100,154,228, 40,117,149,190, 60,241, 22, 52,
    248, 16,209,108, 60,194,125, 87,234,113, 51,  6,107,255, 29, 99,  //  68
     48,135,176, 36,127,165,251,116,215,136, 19,208,153, 69,215, 42,
    147, 64,184,245,169, 59, 35,174,235, 90,183, 22, 88,117, 61,103,
    156, 84,196,140, 20,187, 69,129,218, 86,111,137,221, 29, 54,141,
     66,128, 91,219,190, 83,204, 37,242, 17,197,231, 23,209,119,179,
    237, 34,129, 74,201,  8,220, 30,108,210,144,
    124,184, 37,166, 83,152, 46,203, 11,146,218,172, 83,183,129,167,  //  69
    206, 63,245,103,208, 71, 41,192, 29, 63,184,125, 91,230, 22,197,
    105,229, 47,115, 15,193,249,109, 51,121,155,250,136,176,231, 21,
    254,127, 70, 46,230,154,109, 33,183,148,250, 23, 96,157,245,190,
     39,226,174, 34,112, 10,231, 57,151,105, 80,127,177, 88,152, 27,
     67,210,170, 18,238,104,163,129, 80,172, 41,
     94, 56,137,245,205, 21,241,108,174, 70, 25,119,210, 60, 13,227,  //  70
     89,123,  2,155, 28,225,142, 97,163,220, 79,244, 33,178,137, 77,
    171,  4,153,203, 90,133, 73, 25,144,220, 11, 66,209, 43,151, 79,
    199,  6,217,169, 97, 12,207,238, 76,  2,190, 70,204,121, 17,112,
    166,  4, 70,134,254,165,101,129,211,181,248, 64, 13,235, 51,201,
    143,112, 91,188,142, 85, 36,255,196,  5,234,
    199,228, 76,  7,104,131,161, 53,224, 96,246,150, 38,237, 75,151,  //  71
     31,185,214, 88,179,118, 13,235, 44,121,  2,166, 57,106,250, 49,
    220,131, 70,233, 27,216,157,230,187, 77,198,113, 27, 99,190,114,
     60,149, 37,125,246, 72,139, 43,165,122, 50,236,169, 61,228, 79,
    208, 98,235,187, 50, 77,195, 29, 73,  3, 48,170,138,189,115, 86,
    226, 21,251, 66, 43,224,185, 58,141, 74,155,
     18,110,150,188, 45,213, 85, 26,192,137, 59,195, 94,134,190,109,  //  72
    249, 68,130, 46,247, 67,203,172, 84,151,228, 93,207,127, 13,192,
    102, 25,187, 98,169, 59,113,  1, 98, 34,163,233,142,246, 12,215,
    171,241, 89,182, 54,200,105,186, 92,225,150,110,  9,143,185, 32,
    132,159, 44,104,152, 14,219,139,233,158,122,225, 99, 35,248,  7,
    158, 59,135,204,167,125, 26,102,213,118, 47,
    166,215, 30,234,171, 62,232,167,117,  3,213, 31,170,  8,216, 43,  //  73
    169, 15,223,158, 23,145,101, 55,255, 21,183,136, 24,235,162, 84,
    154,241, 62,137,244, 38,205,171,253,133, 58, 84,178, 48, 73,131,
     50, 23,116,220,  8,160, 34,253, 18,199, 36, 86,202, 49, 99,252,
     59,218, 18,203,242,121,176, 38, 93,194, 82, 24,205, 61,168,122,
    191,218, 36,103,  6, 78,241,159, 12,245,191,
    130, 58, 80, 99,124, 11,144, 90,243, 76,155,110,251, 56,101,147,  //  74
     80,199,112, 90,187,213,  8,130,197,108, 50, 75,193, 67, 44,214,
    124, 37,200,  9,108,152, 71,122, 49,183,224,  7,121,220,151,237,
    100,195,155, 78,134,209,115, 60,140, 68,177,247,128,225,172, 11,
    190,122, 86,141, 28, 91, 63,239,118, 45,253,179,145, 90,212, 45,
     99, 75,152,234,180,207,135, 54,177, 69, 92,
     23,253,193,146,240, 77,185, 24,199, 40,223, 82,126,188,235, 24,  //  75
    226,133, 61,237, 50,120,227,169, 37,146,212,243,103,141,179,  6,
     73,222,163, 83,180,216, 20,235, 91, 23,150,100,203, 30, 85,175,
      2,225, 58,249, 24, 85,233,167,214,119, 13,154, 71, 24,118,150,
     70,228,170, 56,186,215,164,  6,207,141, 76,  8,114,239, 27,142,
    243,176, 29,126, 61, 19,110,233, 33,142,226,
    157,115,  9, 53,204, 38,225,102,133,170, 60,181, 17,150, 74,114,  //  76
    175,  5,160, 33,176, 85, 30, 70,237, 87,  7,155, 39,219,116,254,
    151,110, 53,248, 33, 95,140,166,194,214, 70,244,165, 63,197,113,
     65,137,183, 41,152,187, 45,  4, 95,240, 82,210, 42,217, 90,242,
     44,107,  5,250,110, 37,136,101,180, 33,167,231, 59,158, 79,195,
      2, 65,220, 95,253,164, 80,190, 99,207, 46,
     88,218,181,155, 94,126,160, 49,253, 11, 99,237, 51,199, 32,207,  //  77
     53,252,104,217,135,247,162,106,202,122,177, 65,190, 19, 87, 50,
    187, 27,141,195,121,223, 54, 10,114, 42,127, 34,136, 12,255,145,
    211, 28,120, 90,214,107,135,203,158, 28,193,130,104,159,194, 17,
    179,142,205, 81,153,228, 77,244, 60,221, 94,122,202, 19,225,106,
    132,156,193, 22,139, 51,223,147,  1,122,183,
     17, 61,104, 29,247,  4,209, 71,190,120,153,205,136, 90,244,158,  //  78
    129, 85,182, 18, 68,113,  2,182, 58, 26,250,100,131,237,159,208,
     97,237, 73,  3,161, 69,187,250, 82,160,236,189, 86,178,102, 38,
     82,241,163,231, 10, 73,250, 54,124, 64,171, 54,254, 28, 80,128,
    232, 92, 32,181, 52, 12,192, 25,125,151, 12,185, 49,129,173, 47,
    249, 88, 43,112,210,181, 35, 75,248, 66,229,
    172,124,231,189, 75,173,106,146, 21,222, 41, 78,  1,174,105, 67,  //  79
     13,213, 46,152,193,213, 48,233,132,214,151, 15,200, 76, 37,135,
     13,171,206,108,240, 34, 98,138,216, 57,  3,105,215, 49,225,165,
    200, 14,105, 61,198,161, 26,177,228, 87,212,  8,146,182,223, 55,
    158, 63,244,124,213,145,114,171,212, 42,228, 74,247, 93,208, 73,
     23,213,168,240,  8, 99,126,200,157, 39,138,
    245, 36,149, 52,130,226, 33,241, 93, 59,167,248,124,226, 26,193,  //  80
    237,137,110,243, 25,130, 84,153, 95, 36, 72,223, 49,115,179,230,
     62,122, 42, 82,147,212,171, 17,121,175,203,139, 67,151, 18,118,
     54,150,188, 32,142,115,218, 97, 15,154,110,230, 93, 41,118,  1,
    201,115, 15,165, 94, 60,255, 87, 64,111,177,142, 32,162,  9,147,
    186,121, 55,138, 73,161,235, 16,111,215, 95,
     68,196, 91,207, 14,157, 57,185,127,211,104, 28,197, 57,116,146,  //  81
     40, 72,186, 92, 55,174,254, 12,206,184,106,168,143,240, 18,103,
    211,159,234,185, 23,117, 53,234, 72, 26, 81,228, 31,249,182, 92,
    233,128,252, 91,208, 69, 44,139,245, 42,198, 58,137,240,166,216,
     97,181,220, 48,231, 30,196,  5,159,240, 19, 96,216,113,240, 84,
    228, 98, 31,204,184, 27, 62,178, 80,190,  8,
    162,116, 22,255,118, 95,217, 78,152,  7,183,142, 86,160,214, 88,  //  82
    172,209,  4,145,225,117, 68,160, 42,127,246,  7, 87,196, 67,173,
     35, 78, 11,132,255, 78,204,140,193,244,114,164, 96,129, 63,203,
      3, 73, 41,166,  9,242,171,196, 72,124,168, 22,185, 67, 24, 83,
    148, 22, 76,119,147,175,105,140,204, 50,133,182, 55,193, 65,130,
     18,165,255, 83,115,211,142,251, 31,137,221,
     28,228,180, 78,168,197, 46, 26,251, 82,225, 42,241,  9, 52,253,  //  83
     20,106,240, 43,194, 22,216,111,233, 63, 32,202,128, 39,141,251,
    116,149,221, 89, 43,167,  5, 93, 42,153, 65,188,  8,211, 34,139,
    171,213,111,222,134,101, 35,110,  3,221, 83,250,102,206,133,228,
     41,245,160,203, 13, 74,235, 38, 95,224, 70,252,  1,140, 39,217,
    183, 63,148,  3,228, 46, 90,120,171, 52, 99,
    153, 65,138, 43,  2,141,235,101,163,117, 63,133,178,112,194,125,  //  84
    148, 68,162,126, 87,169, 50, 79,180,141,216, 76,176,230, 96,  2,
    199, 51,171,112,211,135,232,183,125, 14,221, 51,240,156,101,231,
     80, 28,148, 51,185, 64,229,162,206,143, 41,129,  7,156, 47,105,
    191,127, 52, 96,249, 43,199,128,187, 28,119,152, 83,229,161, 80,
    111,210, 40,101,158,181, 18,216, 68,193,243,
     48,215,103,239,207, 64,115,185, 14,210,190, 24, 92,221, 73, 33,  //  85
    231,201, 53,220, 11,243,136,201,  3, 97,163,116, 17, 62,209,167,
     71,237, 17,194, 66, 21,107, 73,249,171, 94,142,118, 41,181, 58,
    122,193,241, 87, 17,203,123, 23, 56, 97,234,179,213, 80,237,169,
     73, 26,221,179,139,110,162, 10, 76,164,210, 22,197,116, 32,244,
     10,135,172,245,128, 61,239,146,108,  5,126,
    176, 13,189, 84,126,171, 31,224, 76,136, 51,234,150, 13,159,187,  //  86
     96, 23,115,178,100,155, 35,117,251, 59,225, 41,247,150,113, 25,
    129, 99,146, 37,247,151,218, 32, 57,208, 25,195, 72,209, 20,244,
    162, 14,104,173,234,153, 81,255,182,151, 15, 60,107, 36,198, 10,
    147,204, 82,  3, 59,222, 88,206,242,104, 49,235, 98,177, 61,189,
     89,225, 52, 78, 13,192, 95, 27,201,229, 81,
    246,112,148, 21, 53,249, 89,149, 40,246,100,171, 67,120,247, 59,  //  87
    135,166,250, 47,208, 68,225, 84,160, 27,181,132, 89,186, 45,243,
    181,211, 82,174,118, 87,191,165,136,104,155, 49,254,102,149, 82,
     47,201, 66,133, 49,106, 34,132, 76,222,117,164,247,144,124, 62,
    252, 97,137,239,169, 31,148, 61, 27,145,184, 65,138, 17,222,145,
    118, 22,186,213,112,227,158, 55,169, 40,144,
     26, 63,202,229,157,193,  9,213,116,162,  3,213, 34,197, 91, 39,  //  88
    209,  2, 76,147, 24,122,180, 19,212,122, 73,207,  6,220, 77,144,
     52,  7,235, 61,206, 51,  6, 93,238, 15,228,120,163,  4,190,126,
    216,145,251,  1,217,167,196,215, 19, 46,189, 81, 24,184, 93,213,
     34,167, 48,116,202, 99,254,189,126,232,  5, 92,248,165, 78, 53,
    252,161, 99,147, 28,134, 77,253,124, 99,210,
    134,170, 96, 32, 73,131,103,173, 62,201, 73,112,238,133,170,230,  //  89
    110,181,224, 97,194,245, 57,142, 91,241, 46,150,105,166, 29,205,
    108,160,124, 21,147,243,131,211, 61,181, 84, 34,215, 60,237, 28,
     97, 37,115,188, 86, 22, 61,147,109,242,135,211, 50,229, 17,160,
    120,192,229, 23, 63,131,  8, 80, 40,165,115,194, 37,121,215,  3,
    197, 37, 66,241, 48,182,  1,203, 31,184, 77,
    219, 46,252,120,218, 43,244, 19,229, 38,145,185, 52, 15, 79, 30,  //  90
    152, 58,129, 41,166,  6,104,203,169, 13,189,228, 62,246,120, 88,
    239, 64,222,179, 84, 31,167,110, 38,125,207,171, 77,143,111,158,
    227,179, 71,151,231,127,248, 88,175, 65,  3,101,170,117, 82,244,
     71,  6, 90,147,180,217,162,227, 97,211, 52,227,153, 87,184,110,
     81,128,171,201, 94,223,105,143, 66,229,  9
    ,

    //
    // Yellow
    //

     28, 84,145,176, 68, 21,101,253, 50,178, 35,225,  7,162, 28,195,  //   0
    152,115, 55,  4,212, 39, 67,148,110,171, 15,235, 84,225, 10,252,
    134, 99,170, 69,224, 90,172, 53,141, 76,132,  7, 97,210,116,241,
     96,176, 49,108,243,183, 68,253,139,171, 55, 23,106,223, 20, 89,
    153, 42,164,121, 98,168,231,111, 22,124, 66,209,107, 41,130,102,
     20, 91,145,189,221, 51,240,151, 31,250, 71,
    127,239, 12,204,129,227,155,  6,204, 94,149,124,201, 58,142, 73,  //   1
     15,173,255,104,126,239, 15,197, 87,253, 51,193, 31,165,107,152,
     59,222, 31,119,154, 18,244,112,220,194, 62,227,143, 21,165, 35,
    147,226, 16,201,133, 47,158, 98, 18,202, 85,248,189, 46,138,232,
     65,247,  3,203, 47,139, 11, 63,217,181,248, 30,148,186,252,158,
    215,121,243, 34,108,138, 85,211,172,114,182,
     50,158,108, 54, 28,192, 78,126,161, 25,245, 44, 83,222,116,238,  //   2
    208, 39, 89,197,160, 86,138,228, 30,126,156, 79,136, 93,218, 41,
    203, 79,147,248, 60,202, 44, 87,156, 38,108,164, 56,246, 87,190,
     80, 64,138, 93, 33,215,126,191, 52,235, 69,122,146, 93,183,116,
     33,180,142, 84,235,184, 81,199,134, 85, 52,120,230, 10, 85, 59,
    180,  4, 69,154,182, 15,194, 70,  7, 95,224,
    206, 78,219,167,249,113, 43,231, 64,213,105,190,164, 21, 65,159,  //   3
    100,134,224, 63, 23,188,105, 55,180,100,218,  2,246,197, 70,172,
      6,112,185, 23, 97,167,119,189, 12,254,185, 26,198,110,132,217,
     20,255,195,163,240, 81, 24,226,116,156,  6,177, 38,240, 15,215,
     78,127,223, 54, 24,120,251, 32,170,  1,157,204, 97, 67,223, 34,
    137,203, 97,223, 41,248,127, 46,237,146, 24,
    173,  1,134, 91, 61,146,183, 27,173,121, 10, 71,137,249,183,  3,  //   4
     56,175, 14,147,245, 43,221,155, 12,203, 59,168, 40,123, 20,243,
    132,227, 46,209,133,237, 31,218,137, 69,127, 82,220,  5,176, 42,
    156,119, 50,  4,112,180, 66,170, 91, 42,196,227, 80,168, 61,153,
    199, 12,106,191,163, 71,149, 98,227, 69,242, 43,141,173,198,100,
    236, 54,168,129, 63,100,163,213,120,185, 69,
    127, 45,240,196, 14,218,100,245, 91,148,237,202, 33, 90,126,206,  //   5
    243,108,194, 76,119,171, 79,129,248, 74,140,228, 84,186,149, 49,
     94,160, 74,173, 15, 62,150, 99, 52,169,237, 48,155,100, 63,238,
     96,184, 75,231,149,211, 14,250,142,217, 98,134, 25,117,223,102,
     43,250,145, 89,238,  7,218, 40,125,194,110,184, 16,117, 25,157,
    122, 29,244, 20,216,192, 74, 26, 84, 35,254,
    189, 83,154,109,172, 52,130,  3,192, 39, 62,174,107,213, 47, 77,  //   6
    148, 42,233, 31,216,  4,204, 37,110,191, 23,119, 54,237,106,212,
    192, 12,253,107,221, 82,197,246,  2,195,111, 18,230,191,127,205,
     11,142,202, 27, 57, 96,126, 40, 79, 11,162, 52,254,191,  3,136,
    176, 75, 25,211, 50,132,174,203, 63,150, 36, 81,207,246, 52,220,
     70,185, 90,151,109,  3,149,235,198,157,101,
     39,231, 66, 27,234, 81,201,162, 74,212,132, 20,233,138,170, 27,  //   7
    189, 82,130,161, 98,143, 66,230,167, 48,156,203,  8,171, 66, 23,
    127, 60,148, 43,125,177, 26,117,157, 91,214,143, 83, 29,165, 55,
     82,248,100,133,173,239,201,154,188,238,119,206, 69,148, 81,235,
     59,203,158,115,184, 80, 28,102,245, 12,232,162, 57,146, 92,192,
      6,135,210, 43,174,251, 65,128, 11, 59,211,
     16,169,117,205,134, 20,241, 45,119,254,102,160, 78, 11,250,118,  //   8
    224,  7,206, 59,252,182,118, 28, 99,213, 90,255,135, 83,222,151,
    240, 89,208,167,  8,237,141, 70,224, 28, 60,176, 51,240,114,219,
     33,157, 47,227, 80, 22, 49,104, 65, 32,174, 18,109,179, 39,209,
     18,128, 97,228, 16,255,148, 55,122,186, 84,126,219, 11,114,163,
    255,105, 57,229,127, 36,104,176,229,110,140,
     82,214, 48,157, 57,181,105,149, 16,179, 30,202, 50,180, 95, 55,  //   9
    152,107,177, 38, 81, 17,200,151,244, 21, 60,111, 38,193, 29,110,
    180, 40,104,227, 80, 58,204, 39,169,104,252,118,205,  8,146, 98,
    193,118,209,  8,188,130,167,230,208,146, 91,216, 49,242,134, 91,
    162,246, 72, 53,167,108,198,223,166, 46,209, 30, 77,176,236, 32,
     79,146,196, 22, 75,186,218, 23, 87,163,247,
    182,131,  5,252, 93,218, 86,198,230, 55, 92,232,147,215,127,195,  //  10
     20,241, 91,215,137,231, 48, 71,127,170,190,147,220,162, 63,230,
      3,142,191, 26,129,183, 98,244,132,194, 14,150, 93,188, 62,246,
     15,168, 71,146,110,253, 73,  1,124, 41,248,116,161,  8,193,118,
     33,186,  4,201,134, 44, 24, 78,  3,108,147,251,191, 43,136, 65,
    225, 15,169, 99,239,151, 56,141,193, 31, 51,
     73,229,103,176, 36,145,  7,128, 80,168,134,112,  1, 81, 37,227,  //  11
     82,168,124, 10,161,101,176,220,  1,104,229, 13, 50, 99,209,131,
     77,251, 87,160,241, 35,156,  6, 78, 45,214, 66,237,128,171, 43,
     79,232, 32,219, 55, 25,199,160, 84,183, 60,198, 70,102,221, 56,
    231,140,105,221, 92,240,188,124,244,183, 70, 15,115, 95,205,159,
    113,209, 45,136,203, 12, 84,245, 99,206,121,
     24,147, 60,204,120,233,172, 59,210, 38,241,181, 61,247,171,142,  //  12
     42, 64,202, 53,242, 23,131, 83,195, 43,136, 75,249,122, 24,175,
     47,200, 14,106, 51,201,115,222,180,107,164, 22, 84, 39,222,120,
    183,130, 98,158,192, 85,137,233, 29,220, 11,139,240,153, 22,164,
     76, 44,178, 25,157, 60,144, 93,158, 52,217,137,167,232,  2, 55,
    182, 89,235, 62,117, 42,181,127,  3,153,238,
    188,213, 17,161, 78, 27,104,247, 18,156, 72, 23,198,118, 15,106,  //  13
    182,254,136,104,185, 76,228, 33,159,245, 96,205,182,153, 70,232,
    144,114,169,225,135, 88, 24,142, 63,240,123,218,191,156,  2, 90,
    215, 48,248,  9,121,241, 39, 62,107,129,174, 84, 34, 63,188,113,
    203,253,120, 74,228, 11,211, 33,232, 19, 81,194, 34, 76,132,250,
     36,148,  9,171,253,155,214, 67,223, 82, 42,
    110, 90,133,248, 47,215,182,135, 92,201,109,224, 89,155,235,206,  //  14
     26, 94, 38,218,153, 50,144,207,111, 56,147, 30, 60,  5,192, 96,
     19,238, 37, 66,207,175,253, 46,202, 13, 78,143, 58,106,255,163,
     20,144,197, 67,167, 78,182,211,159,250, 51,195,216,122,232, 89,
      7,147, 36,193,130,172,113, 66,186,133,113,247, 57,212,176, 94,
    215,125,191,103, 73, 25,109, 46,186,133,170,
      8,227, 40,185, 99,151,  9, 62,229,143, 52,169,132, 44, 82, 63,  //  15
    141,231,168,  4, 90,250, 15, 71,179,  9,225,170,106,240,125,207,
     61,179, 93,155,  1,120, 77,161,100,182, 43,232, 32,204,134, 66,
    208, 92,112, 37,226, 25,143,  5, 68, 85, 24,111,161, 15,145, 50,
    172,216, 63,239, 83, 52,250,147, 98,221,174,  8,104,146, 19,120,
     86, 28,229, 41,218,193,145,238, 18, 74,245,
    139,164, 74,122,231, 72,203,124, 37,183,  5,248, 30,215,164,  8,  //  16
    194,115, 69,211,122,191,106,231,126,196, 80,130,210, 86,156, 33,
    110,213,133,246, 50,228, 21,217,126,245,153,114,177, 93, 24,174,
     43,244,184,134,206,105,234,122,198,222,136,238, 59, 97,249,197,
    101, 20,136,106,  2,183, 24,202, 53, 28, 78,156,229,192, 64,238,
    197,153, 75,166,133,  8, 91,172,121,202, 55,
    216, 28,204, 11,143, 34,161,255, 78,113,203, 93,119,185,102,246,  //  17
     90,156, 46,175, 30,150, 44,166, 28, 64,254, 18, 42,185, 67,251,
    166, 10, 72,183,107,192,138, 41, 67,  5, 90,207, 18,239,111,224,
     76,152,  6, 83, 51,157, 90, 44,164, 17,183, 36,209,177, 68, 28,
    123,236,178,210,158,232,131, 92,164,245,207, 38, 90,126, 44,165,
    102,  4,248,113, 61,243, 48,214, 31,161, 98,
    115,182, 93,244, 57,216, 97, 24,175,236, 59,159,229, 17,137, 41,  //  18
    218, 19,237, 99,219, 66,242, 95,217,158,105,144,229,119, 16,135,
     53,230,121, 26, 62,161, 90,201,169,222,130, 50,164, 64,138,195,
     34,121,202,171,241, 13,179,254,110, 64, 85,154,120,  3,140,224,
    159, 56, 85, 72, 41,111, 63,219,  6,114,137, 67,173,251, 14,209,
    134, 55,189, 31,178,203,142,111, 71,254, 42,
    234, 55,128,156,181,118,192, 56,149, 12,133, 37, 85, 73,200,168,  //  19
    120, 74,189,131, 10,142,199, 20,133, 36,191, 56,162, 91,196,221,
    102,192,154,240,205, 10,245,116, 77, 34,187,249, 79,214,  4,163,
     98,233, 27, 58,141, 79,204, 27,146,192,232, 46,243,100,184, 86,
     37,202, 24,252,146,193, 33,149,182, 48,195, 18,218, 98,149, 72,
    233, 95,216,131, 72,102, 17,225,148,  1,169,
     88, 13,223, 38, 68,  4,230,127,213, 92,224,194,166,252, 26, 60,  //  20
    210,151, 48,253, 78,181,113, 60,175,244, 79,212, 10,245, 44,151,
     23, 81, 36, 99,132, 86,149, 19,232,144,105, 15,150,124, 56,252,
     72,135,210,109,218, 36,132, 84,224,  8,131, 74,189, 39,216,117,
    243,138,174,121, 12,226, 94,243, 71,105,235,152,117, 53,194, 31,
    176, 39,158, 13,235,161, 57,180, 94,199,124,
    212,142,195,108,250, 87,159, 21, 68,181,113, 50,  6,144,115,237,  //  21
    100,  2,173,118, 39,231, 88,207,  7,110, 45,139,103,178, 68,117,
    181,212, 58,220,179, 37,208,176, 66,206, 47,180,224,101,194, 36,
    176, 10,161, 89,183,246, 61,176, 49, 98,211,165, 16,147, 72,170,
      7, 63,101,216, 66,170,132, 18,209,171, 24, 69,204,  1,229,126,
    106,254, 86,112,186, 28,249,121, 37,237, 60,
    166, 98, 27,175,136,200,100,242, 41,151,236, 72,207, 94,186, 35,  //  22
    137,229, 69,201,145, 17,165,127,223,152,196,231, 32,125,218,  8,
    249,133,167,  5,117,255, 91,110, 25,122,242, 83, 61, 23,154,218,
    110,242, 65, 38,122,  1,147,207,124,248, 37,114,202,253, 52,108,
    193,224, 22,187, 84, 51,199,114, 44,135, 94,248,138,171, 86,161,
     18,192,138,209, 51,148, 86,189, 70,154, 29,
    246, 53,225, 77, 14, 47,171,124,207, 79, 14,169,124,228, 51,160,  //  23
     86,180, 23,104,220, 61,249, 42, 93, 26, 65,167, 90,192,153, 83,
     49,107, 75,228, 62,142, 43,234,151,196,  5,136,166,239,130, 78,
     52,144,193,230,168, 99,226, 69, 18,170,146, 61, 94,136, 20,235,
    149, 91,159,131,236,  8,152,255, 76,220,194, 58, 36,105,242, 62,
    218, 45, 73,  3,226,104,205,136, 15,197,118,
      5,181,121,156,237,212, 67, 33,179,111,139,247, 30, 67,196, 11,  //  24
    213,123,247, 49,170,123, 82,159,189,241,126,  1,253, 56, 27,234,
    170,201, 28,154,195, 15,165,203, 58, 93,176, 53,203, 94, 11,181,
    211, 17, 88,133, 22,190, 44,112,197, 87,236,  4,219,181, 87,127,
     31, 54,250, 35,112,209, 95, 37,168,  6,153,119,184,210, 28,133,
    103,180,241,159,124, 62, 22,234,109,221, 77,
    141,209, 62, 35, 96,118,150,250, 19,221, 42,181, 84,146,111,242,  //  25
     97, 41,157, 76,196,  4,205, 32,112,145, 76,214,107,141,205,119,
     13,140,246,102, 88,239, 71,126, 29,226,114,248, 34,121,229, 43,
    152,115,220, 54,248, 79,155,240,139, 32,182,119,154, 38,211,170,
    222,117,198, 87,169, 57,184,133,226,108, 50,236, 12, 88,152,195,
     10,144, 87, 31,178,246,150, 76,174, 48,163,
     33,102,254,190,168,  2,197, 88,142, 58, 99,213,  7,233,164, 53,  //  26
    141,207, 12,235,106,140,224, 73,233, 16,198,155, 38,181, 62, 91,
    224, 68, 43,172,130, 40,215, 99,186,148, 19, 75,156,192, 67, 99,
    253, 33,184,104,147, 34,212,  9, 63,227, 93, 49,232, 70,107, 17,
     62,181,  1,145,217, 26,234, 66, 21,203, 80,176,128,219, 41,249,
     58,228,110,201, 53, 97, 33,209, 10, 85,235,
     57,126, 18,138, 70,231, 52,109,234,191,160,131, 64,202, 91, 17,  //  27
    189, 64,115,173, 33, 89,166, 53,177,102, 44, 70,220, 11,246,135,
    186,107,217,  2,230,182,143,  9,244, 49,208,130,222,  2,171,135,
    199, 71,161,  5,202,121,179,102,128,161,207,144, 11,191,160,240,
    141, 99,228, 55,125, 97,151,114,175,129,244, 27, 63,162,111, 90,
    126,173, 23,222,129,193,162,119,250,132,188,
    226,160,197, 92,214, 32,132,172, 10, 80, 25,254,108, 35,180,122,  //  28
    250,154,220, 46,198,254,116, 22,204,125,248,172,128,101,162, 20,
     54,148,198,121, 60, 26, 79,170,117, 70,182, 91, 51,105,238, 59,
     16,127,240, 91,231, 70, 47,254,194, 16, 57,114,250, 81,130, 39,
    201, 68,159, 23,239,186, 10,250, 43, 69,157,105,202,233, 13,188,
    215, 51,146, 71,  5,239, 43, 65,179, 26, 79,
      6, 67,237, 48,120,184,239, 71,217,121,209, 48,171,140,227, 46,  //  29
     97, 25, 80,143, 73, 11,153,236, 86,158,  7, 84,234, 49,196, 88,
    240, 37, 74,161, 98,251,202, 45,212,142, 13,252,151,205, 26,145,
    225, 81, 46,188,137, 17,162, 94, 38, 82,221,180, 30, 52,228, 95,
     11,253,107,175, 82, 62,208, 91,190,222,  2,184, 46,133, 72,151,
     34, 85,255,182, 83,148,113,226, 96,151,211,
    177,103,140, 11,159, 96, 18,153, 39,185,149, 73,236,  4, 71,212,  //  30
    135,194,238,113,212,181, 59,135, 33,222, 56,187, 21,150,217,114,
    173,208, 18,227,187,124,150,102, 28,230,111,172, 34,124,187, 91,
    175,211,152, 29,108,220,198,143,230,171,126, 96,146,199,169,119,
    184,134, 41,213,141, 29,161,131, 32,112,145, 89,252, 26,195,115,
    234,163, 19,109,219, 36,172, 14,200, 41,120,
    251, 33,207,182,244, 60,197,112,247, 97, 16,116,199, 98,165, 20,  //  31
    177, 52,  8,168, 30,106,219, 96,195,107,143,210,117, 75, 32, 58,
    132, 93,144, 83, 58,  7, 87,241,175, 74, 48,208, 83, 64,243, 44,
    111,  9, 66,250,178, 74, 52,105, 19, 67,246, 11,215, 88, 18, 66,
    219, 57,198,  5,246,111,231, 59,170,242, 53,207,152, 98,218,  5,
     76,203, 60,131,199, 74,236, 57,137,222, 86,
    145,111, 54, 90, 23,135,222, 46,143, 65,225,176, 27,138,249,116,  //  32
     86,226,125, 65,244, 44,157,  3,174,251, 64, 35,175,247,166,224,
     14,254,193, 42,238,179,215, 20,128,200,145,  6,227,136, 15,158,
    228,132,171, 91,126,  2,244,129,211,152, 39,187, 54,130,248,147,
     26,163, 88,122, 66,172, 97,  8,215, 82, 28,125, 64,176, 48,160,
    123, 37,241,177,  9,152,123,194,102,165, 21,
    188,230,152,215,114,165, 74,182,  3,200,157, 59,231, 87, 45,208,  //  33
    158, 99,199,145,184,123,228, 55, 80, 21,130,228, 88,  4,137, 87,
    180,108, 27,166,117,139, 54,161, 93, 56,247,116,163,190,100,199,
     86, 31,207, 39,223,154,189, 45,178, 89,121,162,229,107,175, 74,
    236,101,225,148,191, 42,206,147,118,190,159,238, 10,224,108,237,
    193,144,105, 89, 53,250, 29, 81,  1,238, 62,
     35, 80,  8,177, 40,251, 31,108,235, 80,121, 34,106,150,186, 26,  //  34
     68,241, 42, 77, 13, 89,190,133,237,164,103,190,152,106,199, 46,
    126,213, 77,226, 93, 30,198,112,228, 32,170, 87, 25, 70,255, 49,
    144,238,110,188, 60,102, 30, 77,237,  9,218, 47, 86,  3,205, 44,
    124,181, 22, 49,241, 14, 88,255, 50, 19, 76,199, 90,143, 22, 61,
     81, 27,225,165,211,111,180,227,133,200,115,
    245,135,221, 65,127, 94,203,169,132, 26,253,180,212,  9,243,113,  //  35
    141,  1,161,205,252,110, 22,208, 97, 39,218, 17, 51,243, 24,233,
    157,  7, 50,152,205, 68,251,  4,183,132,213,106,205, 42,113,170,
      4, 95,160, 13,146,233,197,160,114,144,100,193,150,240, 98,158,
     14,209, 84,168,112,140,196,107,177,228,129, 35,113,184,208,157,
    253,178, 57, 19,128, 44, 75,158, 38, 71,153,
    175, 41,109,192,236,154, 10, 63,215, 54,151, 89,128, 75,167, 57,  //  36
    230,185,117, 28,135,176, 47,153, 60,181,137, 75,206,119,177, 70,
    101,187,247,114, 15,168,100,149, 48, 82, 20,241,144,180,225,129,
    215,195, 54,251, 89,118, 16, 56,203, 24,255, 40,126, 30,185, 58,
    246,138, 69,235, 57,220, 77, 24,143, 70,211,172,246, 67, 38,118,
     12,134,108,201,152,233, 11,187, 95,214, 15,
    206, 83,164, 47, 20, 78,229,148,104,190, 14,201, 45,221, 29,205,  //  37
     93, 51,223, 85,212, 75,235,119,223,  5,254, 86,161, 61,144, 36,
    219, 86,139, 57,229,131,190, 65,232,199,160, 75, 11, 95, 32, 59,
     79, 23,134,184, 65,213,137,244, 83,163, 68,177,214, 73,119,219,
    104, 30,201,122, 20,178, 40,165,234,  4,103, 51, 14,135,233, 96,
    216,192, 88,245, 63, 85,206,138,254,112, 60,
    131,  4,246,143,214,184,123, 49,244, 69,115,239,164,105,154,126,  //  38
    174, 18,150, 64, 35,144, 12,194, 73,109,171, 38,220, 21,235,197,
    113,167, 18,199, 83, 31,243, 13, 95,115, 37,188,132,237,158,187,
    244,106,222, 30,156, 45,175,105, 35,229,135, 97, 21,237,166,  8,
    151,187, 51,156,210, 92,243,113, 50,193,139,161,215, 88,177,148,
     76, 34,165,  8,182, 30,120, 56, 19,157,235,
    103,178, 67,117, 57, 98, 32,202, 23,172,143, 81, 33,230,  5, 73,  //  39
    254,105,233,169,191,248,100,165, 27,201,131, 68,185, 99,129,  1,
     51,240, 76,160,216, 50,121,164,221,140,252, 56,209, 65,116, 10,
    141,174, 87,120,242, 92, 12,217,187, 58,  4,203,149, 51, 92,207,
     63, 94,253,  1,110,145, 63,199,130, 89,251, 62,116,194, 56,  2,
    248, 61,219,141,105,239,150,226, 78,184, 34,
    149,221,199, 37,171,249,132,162, 91,215,  9,189, 60,137,185, 50,  //  40
    198, 40,131,  7,112, 66, 39,127,242, 49,226, 10,147,249, 78,178,
    137,194, 30,130,101,181, 90,205, 44, 81,  1,161,100, 27,203,227,
     71, 41,204,  2,179,206,115,150, 79,130,168,247,114,194,140, 34,
    230,129,167, 75,228, 28,172, 38,225, 29,168, 17,236, 36,105,204,
    156, 97,122, 49,207, 79,176, 43,116,203, 91,
     52, 18, 83,139,216,  5, 69,234,112, 55,252,118,214, 96,240,122,  //  41
    157, 81,212, 93,201,158,218,180, 89,151, 78,191,116, 44,209, 66,
    233, 97, 58,255,  5,226,136, 19,152,184,217,125,239,177, 89, 37,
    129,253,155, 69,140, 34, 65,249, 25,227, 85, 44, 74, 11,240,178,
    115, 22,215, 45,192,122,249, 81,150,109,219, 82,126,173,223,132,
     39,183,228, 22,159, 61,  5,211,142, 13,229,
    127,252,164, 25,102,186,147, 19,197,141, 39,158, 23,169, 77, 12,  //  42
    228, 26,172,245, 21,137, 52,  2,114,215, 22,239, 91,174, 24,160,
     14,123,166,203,149, 45, 73,214, 61,112, 34, 75, 18,147,119,196,
    165, 94, 25,235, 99,226,125,165, 60,198, 17,185,222,132, 98, 46,
     67,199,142,101,160, 17, 57,201, 12,179, 52,203,155, 24, 54, 80,
    239, 15,147, 88,253,190,133, 90,244, 69,170,
    105, 64,209,117,242, 89, 45,224, 81,180,102,206, 66,221, 42,184,  //  43
    107, 63,136, 40, 75,229, 97,249,189, 41,129,156, 34,223,140,104,
    213,183, 35, 69,109,237,167, 85,242,195,158,228,200, 62,244,  5,
     54,207,116,185, 53,175,  8,205,104,153,127,100,159, 32,212,169,
    246, 89,  9,237, 70,217,138,113,235, 88,140,  4, 71,255,191,116,
    165, 69,197,113, 31,103,224, 38,154, 29,194,
      1,144, 40,176, 54,203,168,124, 27, 59,239,  2,148,106,131,250,  //  44
    149,214,189,114,160,183,123, 60,161, 74,210,103,181, 64, 87,245,
     49, 81,239,140, 17,189, 34,142,  7, 53, 97,137, 45, 84,170,107,
    223, 74,151, 14,213,144, 83, 47,231, 33,217, 55,252, 67,142, 13,
    119,154,187,126, 39,178, 90,163, 36,191,244,117,212, 95,143,  9,
    203, 45,134,230,161, 55,178,113,200, 93,232,
     76,185,225, 80,152, 25, 95,251,156,202,121, 77,186,237, 17, 78,  //  45
     55,  4, 91,219, 57, 10,207, 32,133,237, 13, 53,252,  6,196,121,
    154,  9,196, 84,223,125, 97,217,179,128,253, 11,187,225, 22,142,
    176, 42,242,127, 67, 32,252,186,139, 87,179,  3,196,114,187, 78,
    223, 34, 63,208,107,243,  5,221, 56,105, 28,167, 43,176, 37,217,
     98,247, 79,  3,212, 77, 26,249, 59,124,160,
    241, 30,122, 13,238,136,213,  6,110, 37,168,222, 28, 93,140,197,  //  46
    166,233,125, 24,254, 89,150,222, 83,173,113,203,138,109,171, 27,
    229,102,170, 38,159, 54,247, 67, 24,209, 75,168,109,134, 51,251,
     96, 19,188,101,223,170,115, 95, 13,243,124, 95,148, 23,234, 47,
    171,103,255,165, 21,148, 72,186,129,155,225, 73,133,230, 64,121,
    160, 29,183,104,144,193,131,164,  9,216, 43,
    108, 86,202,160,103, 41, 67,187, 88,243, 66,136, 49,172,213, 31,  //  47
    114, 41,204,173,134,190,107, 18, 63,196, 35,159, 68,224, 55,211,
     73,129,252, 68,210, 12,173,115,154, 85, 40,229, 27,213, 86,195,
    124,217, 77,159,  3, 74,204,152, 66,164, 42,207,240, 62, 85,145,
    197,  2,138, 45, 96,200,117, 27,252, 85, 15,200,101, 22,184,239,
     73,140,219, 43,240, 16, 96,231, 75,144,197,
    172,135,255, 50,192,230,166,131,208,149, 10,198,110,235, 59, 97,  //  48
    247,148, 71,101, 36, 65,231,160,248,140, 94,237, 19, 85,162,136,
     43,204, 19,117,145,101,202, 35,231,195,124, 67,148, 97,158, 29,
     67,151, 48,245,129, 43,234, 28,196,223, 78, 20,165,129,210, 29,
    122,214, 75,179,238, 54,216,173, 68,208, 50,175,248,152, 94, 36,
    201, 13,118,171, 68,123,205, 31,184,100, 22,
    224, 68,  5, 94,120, 29, 84, 15, 58,116,231, 79,154, 18,129,191,  //  49
      9,178, 49,242,161,206, 26,121, 52,  5,216,128,186, 47,246,  2,
    183, 86,168,220, 56,241, 72,127, 58,  7,173,247,190, 12,226,177,
    238, 10,197,108,211,178, 97,134, 53,111,141,189,104, 46,175,249,
     59,101,232, 19,122,156, 36,105,  7,161,139,109, 68,  3,222,114,
    164, 61,253, 89,215, 38,156, 55,133,245, 59,
    116,190,145,177,214,149,250,175,220, 37,165, 27,253, 71,163,228,  //  50
     76,133,216,119,  1,136, 91,178,209, 79,175, 61,105,209,122, 96,
    230,148,101, 34,188,  4,158,185,244,140, 92, 32, 61,128,105, 43,
    137, 90,172, 21, 57,146, 13,241,170,  9,254, 54,231,  6, 89,154,
     16,189,141, 51,196, 78,225,127,238, 92,218, 41,198,136,174, 48,
    209,101,151, 22,136,185,249,111,212, 12,154,
     26, 45,234, 59, 17, 79, 49,128,102,190, 92,214,125,187, 45,109,  //  51
     24,199, 35, 81,184,225, 40,245,113,153, 34,255, 14,156, 37,201,
     58, 17,245,138, 84,232,109, 25, 76,206,110,219,165,237,197, 74,
    212,112,250, 83,224, 78,204,116, 69,209, 83,155,120,216,195,106,
    229, 73,170,112,251, 10,142,201, 48,178, 19,123,234, 35, 74,243,
    131,  7,224,178, 53, 95,  2, 73,170, 94,199,
     80,208,102,129,242,180,205, 24,229, 63,146, 44, 99,  9,219,142,  //  52
    249,102,171,238, 54,109,166, 76, 12,196, 85,139,180,224, 81,144,
    178,125,197, 41,177, 62,145,223, 48,163, 12,144, 43, 84,  1,156,
     24,147, 33,128,180, 29,161, 39,182,135, 35,187, 27, 72,143, 47,
    128, 37,222, 25, 62,182, 95, 29, 73,146,250, 79,157, 99,189, 28,
     84,192, 43,113,235,199,125,232, 36,131,240,
    139,173, 23,163, 68,108,139, 87,160,  7,241,181,139,200, 86,167,  //  53
     67, 45,149, 12,138,217, 22,141,231, 49,220, 66,115, 59, 22,249,
    101, 49, 75,214,118, 21,203, 95,182,123,255, 79,202,123,179,243,
     62,221,167, 68,233,109,213, 99,245, 59,225, 99,240,172, 14,245,
    163,201, 91,149,207,115,160,244,189,114, 59,183,  9,211,115,162,
    231,141, 76,164, 62, 32,154,194, 65,181, 52,
    106,251, 50,223,  2,213, 45,237,105,203,118, 27, 68,245,111, 15,  //  54
    225,185,116,196, 69, 92,200, 58,180,120,162,  3,238,194,136,207,
      8,233,153, 13,248,168,130, 36,236, 22, 58,177, 31,233, 53,115,
    193, 98, 48,198,  3,151, 55, 16,157,118,  5,139, 52,124,211, 98,
     64,  7,116,234, 72, 16,219, 81,  1,214, 37,226,142, 45,255, 15,
     56,211, 21,248,131,219,100, 23,117,226,  6,
    152, 72,198,134, 95,150,192, 19,174, 42, 87,224,153, 47,176,132,  //  55
     38, 76,215, 30,254,170,116,241, 97, 21,204, 88,151, 32,111, 88,
    165,128,191,109, 91, 52,222, 71,148, 91,159,224, 93,148, 17, 76,
    139, 11,238,135, 93,253,122,221, 76,188,216,166,200, 89, 37,182,
    230,141,188, 30,174,140, 44,123,149,168, 96,121, 69,179, 90,151,
     79,117,182, 93,  8,175, 86,254,146, 76,213,
    192, 19,116,174, 42,247,121, 78,141,254,124,191,  3,216, 92,200,  //  56
    246,147,100, 60,144,  4, 48,154, 39,136,251,108,177, 51,230,182,
     29, 82, 57,227,143,199,  2,117,187,208,114,  6,126,214,175,252,
    163,216,116,181, 42,166, 64,194, 31,102, 46, 77, 24,252,144,108,
     46, 81,248, 51,104,241,186, 71,233, 27,190,238, 23,218,127,206,
    174, 32,229,151,204,114, 44,206, 15,169, 42,
     96,238, 54,227, 80, 28,178, 60,200, 15,158, 64,107,137, 29, 59,  //  57
    112,  7,173,234,121,192,218, 72,228,186, 53, 25,221, 81,146, 63,
    201,254, 38,169, 28, 85,164,249, 20, 62,239, 72,198, 47,107, 64,
     23, 84, 35, 72,204, 22,229,135,163,247,129,229,113,163,  3,209,
    173, 18,159,129,214, 87, 20,208, 51, 84,137, 54,163, 95, 11, 49,
    242,140, 55, 77, 39,233,159,130,104,242,125,
     61,141,201, 12,153,214,104,227, 47, 94,211, 37,243,168,223,192,  //  58
    158,225, 45,201, 20, 88,106,172, 11, 77,163,133,201, 17,243,123,
      4,155,106,213, 68,234,131, 47, 85,179, 37,144,168, 26,232,124,
    210,191,155,246,130,103, 80,  8, 58,184, 13,152, 41,192, 71,127,
    226,102,200, 72,  6,165,120,145,175,242,  6,210,110,248,181, 74,
    109,  3,213,124,182, 13, 67,191, 75, 31,184,
     17,170,111, 92,188,130,  5,146,170,237,110,183, 84, 16,120, 78,  //  59
     23, 95,134, 69,162,247, 26,129,203,120,238, 60,102,161, 45, 96,
    222, 86,194,127, 10,186, 74,220,155,122,211,103,249, 91,184, 55,
    139,100, 50, 11,218,176,150,240,117, 93,211, 72,221, 97,241, 49,
     24,150, 57,228,185,100,249, 35, 96,116,193, 70,148, 29,134,225,
    165,195, 99,251,147,102,239, 46,214,153,227,
     73,247, 33,233, 67, 41,251, 74, 38,131,  9,145, 67,230,153, 47,  //  60
    253,176,214,108, 40,185,148,233, 46, 99,211,  6,188,130,210,176,
    143, 32, 56,236,150,111, 21,200, 32,235, 10, 53,135, 14,152,222,
     19,239,166,121, 76, 25,211, 38,196,156, 25,132,175, 22,141,184,
     87,255,117, 43,134, 27,203, 58,219, 19,157, 41,223, 77,204, 36,
     59,143, 75, 24, 53,198,134,167,  2, 92,118,
    190, 53,157,120,206,174, 99,187,220, 82,202,250, 40,198, 98,184,  //  61
    124, 64,  9,142,228, 96, 55, 80,188, 21,154, 82,250, 30, 77, 14,
    247,120,171, 94, 40,252,174,137,104, 69,150,196, 73,209,112, 41,
     78,200, 62,226,193, 53,109,134, 70,232, 50,251,115, 65,212,108,
    162,203, 11,167,238, 70,158, 81,186,125,254, 94,173, 21,103,125,
    246, 17,210,176,231, 84, 29,108,250,143,210,
     14,138,218,  7, 60,147, 32,125, 20,154, 50,114,172,132,  6,208,  //  62
     34,161,242,189, 23,126,207, 30,167,240,129, 54,172,118,218, 61,
    101,200, 22,217,188, 63, 84, 53,244,187,115,228,169, 49,243,182,
    156,118,  5,140, 96,159,255,185,  1,104,167, 87,199, 10,237, 52,
     32,132, 83,212, 96,192,  4,234,139, 30, 52,197,132,234,163,188,
     90,159,117, 47,155, 63,221,175, 66, 36, 80,
    177,103, 87,167,243,112,230,197, 66,236,188, 90, 31,216, 59, 82,  //  63
    226,111, 92, 48, 72,174,255,141,112, 91,202, 33,230, 95,187,153,
    226, 48,147,125,  3,157,228, 13,167, 46, 25, 90,  1,144, 87, 17,
     97,250,187, 46,236, 14, 89, 45,221,144,207, 41,138,173, 98,151,
    192,234, 61, 23,147,123, 53,107,179, 85,230,109,  2, 80, 58, 12,
    223, 39,235, 93,  5,201,121, 19,195,159,234,
    117,255, 23,201, 41, 88, 10,157,101,134,  2,227,143,103,239,156,  //  64
    134, 20,199,148,219,100, 14, 57,220,  4, 66,164,142, 16, 44,124,
     10,177, 83,246,109, 87,206,140, 94,218,155,252,123,192,232,131,
    205, 27, 68,168,115,213,135,174,117, 64, 18,242,107, 30,206, 86,
      2,104,179,243, 68,200,251,155, 16,204, 61,144,179,246,121,200,
    139, 67,183,125,253,103,148,242, 97,127, 46,
     72,185, 60,144,121,182,210, 54,242, 40,180, 64,165, 18,183, 38,  //  65
     62,175,231,  1,115,163,196, 82,157,190,244, 99,208, 80,254,196,
     74,236, 57,196, 43,177,119, 35,190,128, 63,204,102, 40, 72,174,
     43,149,233, 92, 21,188, 73, 27,236,187, 92,158,195, 72,249,121,
    221,145, 35,119,161, 14, 42, 94,220, 78,167, 28,207, 40,157, 30,
    107,210, 24,162,189, 71, 30, 56,206,  7,222,
     33,151,216, 95,229, 28,138,110,168, 80,211,127,247, 75,116,205,  //  66
    251, 88,125, 54,245, 63, 36,236,116, 45,135, 21,123,172, 60,141,
    109,160, 23,129,223, 17,244, 61,234,  7, 84, 26,164,222, 13,109,
    216, 76,118,210,142, 44,245,154,101, 47,230,120,  7,145, 38,163,
     75,193, 58,210, 90,227,139,181,120, 45,249,124, 96, 66,221, 76,
    244,153, 85, 61, 13,220,156,180, 81,139,173,
    242,124,  2, 48,159, 75,251, 35,218, 17,111, 56, 34,197,145,  7,  //  67
    105,154, 31,191,137, 93,213,145, 18,181, 73,230, 47,218,  1,226,
     29,208, 98,171, 70,150, 90,166,108,158,226,188, 56,147,125,239,
     57,191,  3,178, 65,219,122,  6,180,139, 31,206, 56,227,185, 59,
     16,246,134, 20,173,111, 62,239, 23,188,146,  8,236,189,134,175,
      6, 48,236,143,198, 92,126,230, 36,215,103,
     51,202,101,236,190, 17,173, 84,133,195,158,229,171, 99,222, 49,  //  68
    178,211, 69,227,169, 16,183,106, 67,252,148,191,108,155, 91,175,
     66,135,234,  6,193,110,212, 20,198, 45,134,103,247, 79,203, 40,
    163,133,253, 37,109,169, 92,200, 67,214, 79,174, 85,132,106,208,
     95,166, 78,232, 49,214,  4,160, 82,228, 69,110,161, 57, 21, 97,
    204,122,178,102, 42,242, 20,112, 65,160, 18,
     82,170,140, 65,128,104,205, 61,231, 46, 92,  9,128, 26, 66,244,  //  69
     82,130, 11,108, 44,123,240, 31,208,121,  8, 79, 25,199,124,247,
     39,182, 88, 51,247, 31,136, 55,255, 76, 16,171, 49,  8,179,101,
     23, 86, 98,151,235, 16, 59,251,126, 19,241,152, 12,254, 30,149,
    228,113, 41,188,120,153,101,196,131, 55,170,209, 36,225,120,255,
    155, 64, 24,219,132,169, 54,193,250,130,190,
     58,248, 12,211, 43,239,149,  4,119,184,149,255,212,180,121,155,  //  70
     22,218,162,253,199, 78,157, 52,167, 92,225,164,243, 65, 33,152,
     78,211,122,167,145, 65,224,170,113,150,229,197,118,216,135,245,
    172,220,195, 49,207,130,187, 36, 98,145, 57,111,197, 68,178, 53,
      7,194,142, 17,239, 65, 32,252, 40,217, 21, 94,139, 76,180, 43,
     83,234,188, 80,  1,207, 87,150,  8, 95,226,
     23,111,160, 91,183, 30, 86,169,241, 27, 77, 41,105, 87,206, 42,  //  71
    192,103, 74, 51,142,  5,226,104,193, 61,138, 44,128,209,113,223,
     11,106,238, 18,197,118, 78,  3,190, 92, 26, 67,157, 90, 31, 64,
    111,  9,138, 76, 26,100,150,216,168,227,185, 35,221, 97,136,212,
     81,248, 68,174, 94,202,166,113, 88,185,119,247,190,  9,147,207,
     17,131, 40,152,251,105,125,217, 52,177,122,
    220,198, 48,233,146,115,215, 98, 56,210,135,195,163, 15,236, 69,  //  72
    141,231, 29,186,100,213,131, 28,248, 14,214,181, 80,  6,173, 54,
    189,155, 60, 83, 42,211,160,235, 43,215,131,245, 46,224,190,148,
    234, 57,184,246,167,231, 12, 77, 49,  2, 82,122,154, 15,240,120,
    169, 33,123,224, 50,138, 15,221,143,  8,157, 45, 70,230, 85,114,
    226,174,100,195, 71, 34,185, 25,239, 78,155,
     70,136, 99, 19, 61,252, 13,197,159,114,  7,234, 58,128,172,112,  //  73
      3,169,123,241,159, 42, 70,179,149, 94,115, 31,240,149, 87,254,
    133, 36,206,173,250, 95, 28,137, 72,175,105,165,  5,128, 96, 18,
    201,125, 82, 41,119, 64,189,116,243,133,205,237, 51,188, 66, 26,
     99,205,154,  1,110,245, 74,190, 62,239,102,215,127,170, 34,194,
     71, 50,239, 15,140,226,162, 67,133,195, 40,
      3,187,226,169,125,178, 47,137, 34,247, 95,153, 80,216, 32,249,  //  74
     90,209, 62, 12, 79,200,238,111, 47,229,166,204, 63,107,200, 28,
     99,230, 87,129, 16,146,189,103,248, 13, 61,205, 77,183,249, 52,
    165, 35,225,155,206, 33,142,210, 92,173, 64, 20,162, 85,209,147,
    232, 41, 82,185,210, 37,175,100, 40,202, 31,178, 13, 63,251,158,
      6,150,118,210, 59,114, 93,208, 13,109,254,
    162,113, 32, 77,208,103, 79,223, 72,172, 41,223, 18,193, 55,145,  //  75
    195, 36,150,217,119, 34,142, 17,195, 71,  9,141, 38,224,162,123,
    182,  3,164,106,214, 51,228, 58,122,195,143,232, 32,156,116, 87,
    217,102,137,  3, 92,254, 72, 21,150, 35,194,110,130,251,  5,106,
    177, 60,253,133, 62,152,120,227,161,123, 88,142,235,101,133, 77,
    221, 88,171, 34,181,242, 52,148,234,174, 83,
    217, 47,245,135,  6,237,151,191, 16,130,186,110,140, 94,175,120,  //  76
     68,108,244, 88,188,167, 95,226,158, 85,252,117,189, 84, 13, 65,
    242, 50,222, 64,186, 80,  6,171,218, 25, 94, 48,103,219, 11,145,
    186, 24,242,197,169,113,183,220, 54,247, 97,220,176, 73, 48,194,
    128, 19,169,103, 12,240, 30, 69,  5,254,190, 50,200, 38,207, 23,
    186,106,249, 73,146,  4,199, 29, 74, 44,142,
     68,195,153, 55,186, 65, 33,108,243, 89,209, 51,253, 37,220,  8,  //  77
    231,167, 25,136, 16,250, 49,126, 58,214, 24,160, 51,236,135,205,
     83,144,116, 20,152,235,130,100, 42,150,182,254,132,192, 67,238,
     48,129, 65, 84, 48,146, 10,106,166,127,  7, 66, 25,215,155,235,
     77,213, 89,223,196, 86,184,216,151,105, 22, 72,157,112,168,232,
     58,138, 12,208,123, 96,167,119,221,190, 20,
    128,104, 18,222, 94,139,213,174, 47,158,  2, 72,164,200,103,155,  //  78
     47,197, 63,206,111, 71,210,  7,184,138,109,204, 74,179, 36,165,
     19,210,181,247, 40, 90,163,204,240, 86,118,  1,166, 85, 30,171,
     98,206,159, 19,233,203, 70,231, 78,205,154,238,135, 90,108, 14,
     40,159,119, 27,138,163,104,132, 46,179,208,127,241,  3, 68,126,
     33,163,191, 64,232, 39,250, 86,138,100,247,
    160,231, 75,166,117,253, 11, 80,128,219,112,232,125, 22, 70,241,  //  79
    122, 90,143,228, 40,177,147,103,241, 46, 89,245,  1,122, 93,250,
    112, 67, 34, 96,125,194, 68, 50, 15,188,214, 58, 77,210,233,137,
      6,252,113,178,124, 34,135,186, 25, 45,114,190, 49,174,206,145,
    241,184, 49,246, 80, 42,237, 16, 82,244, 53, 97,217, 83,192,246,
     99,223, 82, 26,154,184, 60,210, 14,178, 52,
      5,183, 42,202, 27, 60,153,198, 36,177, 93,152, 46,188,146, 13,  //  80
    204, 37,185,  4,125,234, 88,199, 31,153,176, 38,146,225,196, 45,
    140,233,169,145,221, 12,245,140,102,156, 31,235,145, 40,119, 71,
    190, 83, 45,215, 95,243, 56,157,251, 85,218, 75, 29,249, 57,117,
     66, 84,141,193,  4,208, 62,189,140,161, 10,173,135, 35,151, 15,
    180, 40,132,200,104, 17,115,156, 45,228, 81,
    243,125,100,140,229,180,109,225, 70,248, 21,206, 80,246,108,225,  //  81
    169,101,255, 79,165, 56, 17,133, 70,226,115,192, 83, 54,157, 16,
    187, 88,  4, 64,179, 44,120,172,228, 86,130,107,199,179, 16,164,
    227, 29,155, 71,  7,192,106, 17,124,173,  9,164,140,101,  2,193,
    217, 16,232, 98,173,130,107,227, 29,115,231, 69,195, 60,215,112,
    143, 66,255, 88,217,137,239, 90,204,120,149,
    189, 54,210, 11, 74, 39, 91,124,  6,139, 57,171, 28,135, 43, 77,  //  82
     29,129,158, 46,219,108,243,171,207, 10, 61,238, 25,208,116, 76,
    227,128,202,255,110, 88,217, 19, 54,177,247, 10, 55, 93,249, 60,
    141,115,204,236,127,166,220, 75,196, 51,232,118,198,227,168,136,
     46,163,119, 34, 56,251, 70,166, 51,207, 95, 25,252,102,169, 47,
    237,187,  1,166, 38, 56,193,  7,169, 24, 64,
     93, 29,167,249,152,200,239,162,189,212,110,237, 85,219,164,191,  //  83
    215, 68, 11,205,137,187, 41, 89,107,144,168, 97,134,175,248, 57,
    172,106, 48, 26,136,199,153, 79,193, 35, 95,162,224,146,112,207,
     20, 94,178, 49, 25, 82,142, 35,240,148, 93, 59, 19, 79, 39, 94,
    253, 70,213,143,205,153, 24,219, 81,147,186,128,156,  6,230, 88,
     29, 95,116,141,232,176, 77,129,252,105,216,
    131,235,114, 89,128, 16, 81, 34, 65, 92,155, 10,194, 73, 16, 97,  //  84
    146,242,178, 84, 25, 73,151,222, 27,253, 44,213,  7, 80, 33,148,
     13,216, 81,163,236,  8, 65,245,119,219,139,204, 28, 72,182, 50,
    168,244, 65,146,190,255, 59,170,108, 14,212,180,242,131,211,187,
    114, 22,177, 76, 12,100,193,116,  2,246, 33, 87,219, 51,118,202,
    162,220,194, 69, 27,106,220, 33,150, 52,174,
    205,  2, 63,196, 55,173,208,138,252, 23,221,125, 52,143,251,123,  //  85
     26, 53,114,229,128,249,  2,193,123, 71,179,112,155,234,196, 94,
    240,138,191, 58,103,180, 38, 99,160,  3, 83, 47,123,238,  6,220,
     89,131,  9,222,101,123,  4,224,189, 46,137,106, 32,157, 62,  9,
    155,222, 44,245,123,232, 53,175,135,201, 59,174,106,191,150, 14,
    131, 56, 19,247,162,126, 58,191, 83,227, 39,
     73,142,164,225, 36,235,109, 50,171,100,187, 37,171,202, 61,218,  //  86
    174,206, 76,164, 39,173,111, 54,157,209, 21,227, 64, 41,118,179,
     48,113, 32,230,130,212,143,224,187, 72,251,195,166, 91,153,119,
     35,212,159, 75, 36,202,155, 92,129, 71,250,162, 69,220,104,241,
    129, 86,103,149,182, 28, 74,223, 38, 92,126,233, 22, 66,250, 77,
    235,107,147, 92,209, 13,243,159,  9,122,162,
    111,255, 26,100,137, 75,153,  3,225,127, 73,244,110, 81,  1,107,  //  87
     47,137,  9,221, 63,199, 87,233, 31, 96,133, 82,185,136,222,  5,
     70,213,169, 14, 75, 44, 85, 17,126, 32,144,103, 14,205, 61,253,
    186, 55,110,246,178, 65,241, 22,215, 30,201, 89, 15,193, 47,181,
     27,169,208,  5, 83,205,152,107,166,241, 13,158,208,137, 33,186,
     42,171,225, 48,186, 72,139,102,198,241, 30,
    215, 87,183,212, 11,194,243, 83,201, 53,160, 14,207,154,233,188,  //  88
    159,247, 99,123,152, 21,214,139,181,243,165,  9,249, 28, 98,165,
    244,150, 96,201,252,162,193,242, 57,217,183, 53,233,130, 24,101,
    164, 21,194,134, 15,104,141, 53,181,146,103,177,234,113,147, 78,
    229, 57,115,241, 50,129,255,  9, 64,190,110, 52, 81,172, 96,117,
    213, 79,  6,121,155, 39,232, 26, 80, 56,179,
      8,136, 56,118,159, 60, 33,117,167, 21,214,138, 65, 43,129, 35,  //  89
     70, 22,196, 42,243, 95,119,  8, 82, 39,112,204, 55,150,212, 76,
    123, 40, 62,141,104, 31, 71,149,105,163, 86,118, 36,177,222,142,
     69,236, 82, 58,217,166,225,122, 77,239,  1, 61,131, 37,253,  8,
    127,185, 30,143,180, 68, 96,196,136, 37,221,133,244,  3,226,151,
     29,132,200,254,101,206,118,183,223,149,103,
    167,224, 38,245, 96,216,183,139, 71,236,112, 89,181,251,104,217,  //  90
     93,228,140,179, 75,162,189,236, 55,213,140, 70,177,120, 50,185,
     21,198,236,  1,187,126,212,  9,234, 26,200,248,158, 73, 46,194,
      2,125,210,154, 32, 85,  8,197, 38,114,217,156,202, 73,165,199,
    101,216, 74,232, 19,211, 40,156,237, 82,165, 20,179, 74,198, 54,
    237,176, 61, 22, 77,166, 10, 73,128, 44,205
};


CONST BYTE  Cluster2x2[] = { 1, 2 };

CONST BYTE  Cluster4x4[] = { 7,  1,  2,  5,
                             6,  3,  4,  8 };

CONST BYTE  Cluster6x6[] = { 12,  9,  6,  7, 10, 14,
                             17,  5,  1,  2, 15, 18,
                             11,  8,  3,  4, 13, 16 };

CONST BYTE  Cluster8x8[] = { 28, 18, 14,  5,  9, 16, 19, 21,
                             29, 27,  1,  2,  6, 10, 22, 32,
                             30, 26,  3,  4,  7, 11, 23, 31,
                             25, 20, 13,  8, 12, 15, 17, 24 };

CONST BYTE  Cluster10x10[] = { 36, 28, 25, 21, 10, 11, 22, 26, 30, 38,
                               45, 37, 20,  9,  1,  2, 12, 31, 42, 46,
                               50, 41, 19,  8,  3,  4,  5, 40, 47, 49,
                               43, 35, 18, 16,  7,  6, 13, 33, 44, 48,
                               34, 27, 24, 17, 15, 14, 23, 29, 32, 39 };

CONST BYTE  Cluster12x12[] = {

                50, 48, 39, 36, 32, 24, 13, 25, 33, 37, 41, 49,
                67, 59, 47, 31, 23, 12,  5, 14, 26, 42, 57, 61,
                70, 68, 53, 22, 11,  1,  2,  6, 15, 56, 62, 69,
                71, 64, 54, 21, 10,  3,  4,  7, 16, 55, 65, 72,
                63, 58, 44, 30, 20,  9,  8, 17, 27, 45, 60, 66,
                52, 43, 40, 35, 29, 19, 18, 28, 34, 38, 46, 51 };

CONST BYTE  Cluster14x14[] = {

                76, 68, 58, 53, 48, 38, 23, 22, 37, 43, 47, 50, 54, 62,
                88, 82, 73, 59, 39, 24, 15, 14, 21, 36, 42, 55, 70, 78,
                94, 92, 83, 69, 25, 16, 12,  5, 13, 20, 35, 63, 79, 90,
                98, 97, 86, 74, 26, 11,  1,  2,  6, 19, 34, 75, 87, 95,
                96, 91, 81, 64, 27, 10,  3,  4,  7, 18, 33, 66, 84, 93,
                89, 80, 72, 56, 44, 28,  9,  8, 17, 32, 41, 60, 71, 85,
                77, 65, 57, 52, 49, 45, 29, 30, 31, 40, 46, 51, 61, 67 };

CONST BYTE  Cluster16x16[] = {

         93, 82, 74, 67, 64, 60, 52, 33, 34, 35, 53, 61, 65, 69, 77, 94,
        110,102, 87, 73, 59, 51, 32, 24, 13, 25, 36, 54, 70, 85, 97,105,
        122,115,101, 81, 50, 31, 23, 12,  5, 14, 26, 37, 78, 98,113,117,
        127,121,109, 91, 49, 22, 11,  1,  2,  6, 15, 38, 89,106,118,125,
        128,119,107, 92, 48, 21, 10,  3,  4,  7, 16, 39, 90,111,123,126,
        120,114, 99, 79, 47, 30, 20,  9,  8, 17, 27, 40, 83,103,116,124,
        108,100, 86, 71, 58, 46, 29, 19, 18, 28, 41, 55, 75, 88,104,112,
         95, 80, 72, 66, 63, 57, 45, 44, 43, 42, 56, 62, 68, 76, 84, 96 };


#define REAL_PAT_CX(x)      ((x) + ((PAT_CX_ADD / (x)) * (x)))
#define FINAL_PAT_CX(x)     (REAL_PAT_CX(x) + PAT_CX_ADD)
#define PAT_DATA(x,y,p)     (x), (y), sizeof(p), (p)

CONST STDHTPAT    DefStdHTPat[HTPAT_SIZE_MAX_INDEX / 2] = {

        { PAT_DATA(        2,         2, Cluster2x2)       },
        { PAT_DATA(        4,         4, Cluster4x4)       },
        { PAT_DATA(        6,         6, Cluster6x6)       },
        { PAT_DATA(        8,         8, Cluster8x8)       },
        { PAT_DATA(       10,        10, Cluster10x10)     },
        { PAT_DATA(       12,        12, Cluster12x12)     },
        { PAT_DATA(       14,        14, Cluster14x14)     },
        { PAT_DATA(       16,        16, Cluster16x16)     },
        { PAT_DATA(HTSC_M_CX, HTSC_M_CY, HTSC_SUPERCELL_M) }
    };

const MONOPATRATIO MonoPatRatio[] = {

                {  2680,  2589 },       // 15 degree
                {  5774,  5000 },       // 30 degree
                { 10000,  7071 },       // 45 degree
                { 17321,  8660 },       // 60 degree
                { 37321,  9659 }        // 75 degree
            };


#if DBG


VOID
DbgShowThresholds(
    LPBYTE  pTitle,
    LPWORD  pwPat,
    UINT    cx,
    UINT    cy
    )

/*++

Routine Description:

    This is a debug functions which show all the HTCELL Infomation

Arguments:

    pHTCell - HTCELL to be displayed


Return Value:

    VOID


Author:

    01-Feb-1995 Wed 14:24:45 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    //
    // Output some information
    //

    DBGP_IF(DBGP_SHOW_HTCELL,
        {
            LPBYTE  pbBuf;
            BYTE    Buf[1024];
            UINT    xLoop;
            UINT    yLoop;
            UINT    cData;
            UINT    cRow;


            DBGP("\n*** %hs ****\n\n%ldx%ld=%ld\n\n"
                    ARGPTR(pTitle)
                    ARGDW(cx) ARGDW(cy)
                    ARGDW(cx * cy));

            yLoop = (UINT)cy;

            while (yLoop--) {

                xLoop  = (UINT)cx;
                pbBuf  = Buf;
                cData  = 0;
                cRow   = 0;

                while (xLoop--) {

                    pbBuf += sprintf(pbBuf, "%04lx:%04lx:%04lx ",
                                        (DWORD)pwPat[0],
                                        (DWORD)pwPat[1],
                                        (DWORD)pwPat[2]);

                    pwPat += 3;

                    if ((pbBuf >= &Buf[250]) || (xLoop == 0)) {

                        DBGP(Buf);

                        pbBuf = Buf;
                        cData = 0;
                        ++cRow;
                    }
                }

                if (cRow > 1) {

                    DBGP("");
                }
            }
        }
    )
}

#endif



VOID
HTENTRY
RotateHTPatXY(
    LPWORD  pPatSrc,
    LPWORD  pPatDst,
    UINT    cx,
    UINT    cy,
    UINT    cyNext,
    UINT    x,
    UINT    y
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    19-May-1998 Tue 18:45:03 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPWORD  pwS;
    LPWORD  pwD;
    UINT    cbCX;
    UINT    cCX;
    UINT    cCY;


    cCY              = cy;
    (LPBYTE)pPatSrc += ((y * cyNext) + x) * SIZE_PER_PAT;
    cyNext          *= SIZE_PER_PAT;
    cbCX             = cx * SIZE_PER_PAT;

    DBGP_IF(DBGP_SHOW_HTCELL,
        DBGP("RotatePatXY: %p --> %p, %ld x %ld, Offset=(%ld, %ld)"
                ARGPTR(pPatSrc) ARGPTR(pPatDst) ARGDW(cx) ARGDW(cy)
                ARGDW(x) ARGDW(y)));

    while (cCY--) {

        pwS              = pPatSrc;
        (LPBYTE)pPatSrc += cyNext;
        pwD              = pPatDst;
        (LPBYTE)pPatDst += cyNext;
        cCX              = cx - x;

        while (cCX--) {

            *pwD  = *pwS;
            pwS  += COUNT_PER_PAT;
            pwD  += COUNT_PER_PAT;
        }

        (LPBYTE)pwS -= cbCX;
        cCX          = x;

        while (cCX--) {

            *pwD  = *pwS;
            pwS  += COUNT_PER_PAT;
            pwD  += COUNT_PER_PAT;
        }

        if (++y == cy) {

            y                = 0;
            (LPBYTE)pPatSrc -= (cy * cyNext);
        }
    }
}




VOID
HTENTRY
RotateHTPat45(
    LPBYTE  pPatSrc,
    LPWORD  pPatDst,
    UINT    cx,
    UINT    cy,
    UINT    cMax,
    UINT    cyNext,
    BOOL    SplitThreshold
    )

/*++

Routine Description:

    This function rotate the pattern 45 degree by copy first top half
    and exchange left/right


Arguments:

    pHTCell - Pointer to the cell to be rotated


Return Value:

    VOID


Author:

    07-Mar-1995 Tue 17:45:09 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPWORD  pPatDst1;
    LPWORD  pPatDst2;
    UINT    xLoop;
    UINT    yLoop;
    UINT    cxHalf;
    UINT    cAdd;
    UINT    PatSrc;
    UINT    cbCX;
    UINT    cbDst2Off;
    WORD    wPat;

    ASSERT((cx & 0x01) == 0);
    ASSERT((cy & 0x01) == 0);


    cAdd         = cMax;
    cMax       <<= 1;
    yLoop        = (UINT)(cy >> 1);
    cxHalf       = (UINT)(cx >> 1);
    cbDst2Off    = (((yLoop * cyNext) + cxHalf) * SIZE_PER_PAT);
    cyNext      *= SIZE_PER_PAT;
    cbCX         = cx * SIZE_PER_PAT;

    while (yLoop--) {

        //
        // for each scan line, we need to swap first half of the bytes
        // with second half of the bytes, this will make the halftone
        // pattern as 45 degree angle.
        //

        pPatDst1          = pPatDst;
        pPatDst2          = (LPWORD)((LPBYTE)pPatDst1 + cbDst2Off);
        (LPBYTE)pPatDst  += cyNext;
        xLoop             = cx;

        while (xLoop--) {

            //
            // Make range from 1 to MAX_PAT_IDX
            //

            PatSrc     = (UINT)((((UINT)*pPatSrc++ << 1) * MAX_BGR_IDX) + cAdd);
            *pPatDst1  =
            wPat       = (WORD)(PatSrc / cMax);
            *pPatDst2  = (WORD)((SplitThreshold) ?
                                    ((PatSrc - MAX_BGR_IDX) / cMax) : wPat);
            pPatDst1  += COUNT_PER_PAT;
            pPatDst2  += COUNT_PER_PAT;

            if (xLoop == cxHalf) {

                (LPBYTE)pPatDst2 -= cbCX;
            }
        }
    }
}




VOID
HTENTRY
ExpandHTPatX(
    LPWORD  pwSrc,
    UINT    cx,
    UINT    cy,
    UINT    cxExp
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    25-Nov-1998 Wed 11:06:43 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    cx    *= SIZE_PER_PAT;
    cxExp *= SIZE_PER_PAT;

    if (cxExp > cx) {

        while (cy--) {

            LPWORD  pwD;
            UINT    cbCopy;
            UINT    cbRem;

            pwD     = (LPWORD)((LPBYTE)pwSrc + cx);
            cbRem   = cxExp - cx;
            cbCopy  = 0;

            while (cbRem -= cbCopy) {

                cbCopy = (cbRem > cx) ? cx : cbRem;

                CopyMemory(pwD, pwSrc, cbCopy);

                (LPBYTE)pwD += cbCopy;
            }

            (LPBYTE)pwSrc += cxExp;
        }
    }
}




INT
__cdecl
SCDataCompare(
    const void  *pA,
    const void  *pB
    )
{
    return((INT)(((PSCDATA)pA)->Value) - (INT)(((PSCDATA)pB)->Value));
}



BOOL
GenerateWORDPat(
    LPBYTE  pPatR,
    LPBYTE  pPatG,
    LPBYTE  pPatB,
    LPWORD  pwDst,
    UINT    cxReal,
    UINT    cx,
    UINT    cy
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    27-Aug-1998 Thu 17:17:13 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPBYTE  ppSrc[3];
    LPBYTE  pbAlloc;
    LPWORD  pw;
    UINT    cxAdd;
    DWORD   Count;


    ppSrc[0] = pPatB;
    ppSrc[1] = pPatG;
    ppSrc[2] = pPatR;

    //
    // Since the cx is add one to the real cx so sub on now
    //

    cxAdd = cx - cxReal;
    Count = cxReal * cy;

    if (pbAlloc = (LPBYTE)HTAllocMem(NULL,
                                     HTMEM_pSCData,
                                     LPTR,
                                     Count * sizeof(SCDATA))) {

        PSCDATA pSC;
        LPBYTE  pb;
        UINT    iPat;
        UINT    jPat;
        DWORD   i;
        DWORD   j;
        UINT    x;
        UINT    y;
        WORD    Idx;
        DWORD   MaxV;
        DWORD   VAdd;
        BYTE    PreV;

        for (iPat = 0; iPat < 3; iPat++) {

            pSC = (PSCDATA)pbAlloc;
            i   = iPat;
            pb  = ppSrc[iPat];
            y   = cy;

            while (y--) {

                x = cxReal;

                while (x--) {

                    (pSC  )->Value  = *pb++;
                    (pSC++)->Index  = (WORD)i;
                    i              += COUNT_PER_PAT;
                }

                i += (COUNT_PER_PAT * cxAdd);
            }

            pSC = (PSCDATA)pbAlloc;

            qsort((LPVOID)pSC, Count, sizeof(SCDATA), SCDataCompare);

            Idx  = 0;
            MaxV = (DWORD)pSC[Count - 1].Value;
            VAdd = MaxV >> 1;
            PreV = 0;
            i    = Count;

            while (i--) {

                if (pSC->Value != PreV) {

                    PreV = pSC->Value;
                    Idx  = (WORD)((((DWORD)PreV * MAX_BGR_IDX) + VAdd) / MaxV);
                }

                pwDst[(pSC++)->Index] = Idx;
            }

            ASSERT(Idx == MAX_BGR_IDX);

        }

        //
        // Now copy the last one from the first pixel
        //

        ExpandHTPatX(pwDst, cxReal, cy, cx);

        HTFreeMem(pbAlloc);

        return(TRUE);
    }

    return(FALSE);
}



BOOL
Generate_HTSC_WORD(
    PHTCELL pHTCell
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    27-Aug-1998 Thu 17:17:13 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPWORD      pwPat;
    LPBYTE      pbC;
    LPBYTE      pbM;
    LPBYTE      pbY;
    PSTDHTPAT   pStdHTPat;
    DWORD       dw;
    HTCELL      HTCell;
    UINT        RotX;
    UINT        RotY;


    if (pHTCell->HTPatIdx >= HTPAT_SIZE_USER) {

        ASSERT(pHTCell->HTPatIdx < HTPAT_SIZE_USER);

        return(FALSE);
    }

    ACQUIRE_HTMUTEX(HTGlobal.HTMutexCDCI);

    if (!(pHTCell->pThresholds = (LPBYTE)ppwHTPat[pHTCell->HTPatIdx])) {

        HTCell = *pHTCell;

        if ((dw = (DWORD)HTCell.HTPatIdx) > 9) {

            dw += 'A' - '9' - 1;
        }

        dw        = (dw << 24) + HTMEM_pHTPat;
        pStdHTPat = (PSTDHTPAT)&DefStdHTPat[HTCell.HTPatIdx >> 1];
        pbC       = (LPBYTE)pStdHTPat->pbSrcPat;

        DBGP_IF(DBGP_GEN_PAT,
                DBGP("Allocating %ld bytes for HTPatIdx=%ld, %ldx%ld, cxOrg=%ld, cxReal=%ld"
                ARGDW(HTCell.Size)
                ARGDW(HTCell.HTPatIdx)
                ARGDW(HTCell.Width) ARGDW(HTCell.Height)
                ARGDW(HTCell.cxOrg) ARGDW(HTCell.cxReal)));

        if (pwPat = (LPWORD)HTAllocMem(NULL, dw, LPTR, HTCell.Size)) {

            if (HTCell.HTPatIdx <= HTPAT_SIZE_16x16_M) {

                //
                // The first pattern to make is M/G, the second C/R and third is Y/B
                // and the pattern order in the pattern is BGR or YMC
                // so we need to make in offset of 1, 2, 0
                //

                dw = (DWORD)HTCell.cxOrg;

                ASSERT((dw * (HTCell.Height/2)) == (DWORD)pStdHTPat->cbSrcPat);

                RotateHTPat45(pbC,
                              pwPat + 1,
                              (UINT)dw,
                              (UINT)HTCell.Height,
                              (UINT)pStdHTPat->cbSrcPat,
                              (UINT)HTCell.Width,
                              TRUE);
#if DBG
                DbgShowThresholds("RotateHTPat45",
                                  pwPat,
                                  HTCell.Width,
                                  HTCell.Height);
#endif
                RotX = (UINT)((HTCell.HTPatIdx & 0x01) ? (dw >> 1) : 0);
                RotY = 0;

                RotateHTPatXY((LPWORD)pwPat + 1,
                              (LPWORD)pwPat + 2,
                              (UINT)dw,
                              (UINT)HTCell.Height,
                              (UINT)HTCell.Width,
                              RotX,
                              RotY);
#if DBG
                DbgShowThresholds("RotateHTPatXY 1",
                                  pwPat,
                                  HTCell.Width,
                                  HTCell.Height);
#endif
                if (HTCell.HTPatIdx & 0x01) {

                    RotX = (UINT)(dw >> 2);
                    RotY = (UINT)(HTCell.Height >> 2);

                } else {

                    RotX =
                    RotY = 0;
                }

                RotateHTPatXY((LPWORD)pwPat + 1,
                              (LPWORD)pwPat + 0,
                              (UINT)dw,
                              (UINT)HTCell.Height,
                              (UINT)HTCell.Width,
                              RotX,
                              RotY);
#if DBG
                DbgShowThresholds("RotateHTPatXY 2",
                                  pwPat,
                                  HTCell.Width,
                                  HTCell.Height);
#endif
                ExpandHTPatX(pwPat,
                             (UINT)dw,
                             (UINT)HTCell.Height,
                             (UINT)HTCell.Width);
#if DBG
                DbgShowThresholds("ExpandHTPatX",
                                  pwPat,
                                  HTCell.Width,
                                  HTCell.Height);
#endif

            } else {

                if (HTCell.HTPatIdx == HTPAT_SIZE_SUPERCELL) {

                    pbC =
                    pbM =
                    pbY = (LPBYTE)pbC + HTSC_M_OFFSET_M;

                } else {

                    pbY = (LPBYTE)pbC + HTSC_M_OFFSET_Y;
                    pbM = (LPBYTE)pbC + HTSC_M_OFFSET_M;
                    pbC = (LPBYTE)pbC + HTSC_M_OFFSET_C;
                }

                ASSERT(HTCell.cxReal == HTCell.cxOrg);

                if (!(GenerateWORDPat(pbC,
                                      pbM,
                                      pbY,
                                      pwPat,
                                      HTCell.cxOrg,
                                      HTCell.Width,
                                      HTCell.Height))) {

                    HTFreeMem(pwPat);
                    pwPat = NULL;
                }
            }
        }

        ppwHTPat[HTCell.HTPatIdx] = pwPat;
        pHTCell->pThresholds      = (LPBYTE)pwPat;
    }

    RELEASE_HTMUTEX(HTGlobal.HTMutexCDCI);

    return((pHTCell->pThresholds) ? TRUE : FALSE);
}



LONG
HTENTRY
ComputeHTCell(
    WORD                HTPatternIndex,
    PHALFTONEPATTERN    pHalftonePattern,
    PDEVICECOLORINFO    pDCI
    )

/*++

Routine Description:

    This function creates the halftone threshold pattern and places them in
    to supplied buffer.

Arguments:

    HTPatternIndex      - index to the internal halftone pattern, if this
                          number is not 0xffff.

    pHalftonePattern    - pointer to user's halftone pattern

    pDCI                - pointer to the DEVICECOLORINFO data structure.  This
                          structure describes the required halftone pattern.


Return Value:

    The return value is the size of the pattern copied or a zero
    to indicate failure.

Author:

    21-Jan-1991 Mon 12:47:48 created  -by-  Daniel Chou (danielc)

    30-Mar-1995 Thu 13:56:45 updated  -by-  Daniel Chou (danielc)
        Adding new brush regression

    22-Oct-1997 Wed 20:01:53 updated  -by-  Daniel Chou (danielc)
        Remove Regression but using computation in the HTMapClr.c


Revision History:


--*/

{
    LPBYTE      pPatSrc;
    LPBYTE      pPatABC[3];
    PATINFO     PatInfo;
    DWORD       Checksum;
    DWORD       cbPat;
    DWORD       dw;
    DWORD       DCIFlags;


    ZeroMemory(&PatInfo, sizeof(PATINFO));

    if (HTPatternIndex > HTPAT_SIZE_MAX_INDEX) {

        return(HTERR_INVALID_HTPATTERN_INDEX);
    }

    PatInfo.HTCell.HTPatIdx = (BYTE)HTPatternIndex;

    //
    // Setup basic PatInfo information
    //


    if (pDCI) {

        DCIFlags = pDCI->Flags & ~(DCIF_CLUSTER_HTCELL |
                                   DCIF_SUPERCELL      |
                                   DCIF_SUPERCELL_M);
    }

    if (HTPatternIndex == HTPAT_SIZE_USER) {

        if ((!pHalftonePattern) ||
            (pHalftonePattern->cbSize != sizeof(HALFTONEPATTERN))) {

            return(HTERR_INVALID_HALFTONE_PATTERN);
        }

        pPatABC[0]            = pHalftonePattern->pHTPatA;
        pPatABC[1]            = pHalftonePattern->pHTPatB;
        pPatABC[2]            = pHalftonePattern->pHTPatC;
        PatInfo.HTCell.cxOrg  = (WORD)pHalftonePattern->Width;
        PatInfo.HTCell.Height = (WORD)pHalftonePattern->Height;
        cbPat                 = (DWORD)PatInfo.HTCell.cxOrg *
                                (DWORD)PatInfo.HTCell.Height;

        if (!(pPatSrc = pPatABC[0])) {

            if (!(pPatSrc = pPatABC[1])) {

                if (!(pPatSrc = pPatABC[2])) {

                    return(HTERR_INVALID_HALFTONE_PATTERN);
                }
            }
        }

        if ((!pPatABC[0]) || (!pPatABC[1]) || (!pPatABC[2])) {

            pPatABC[0] =
            pPatABC[1] =
            pPatABC[2] = pPatSrc;
            dw         = (DWORD)'Usr1';

        } else {

            if ((pPatABC[0] == pPatABC[1]) && (pPatABC[0] == pPatABC[2])) {

                dw = (DWORD)'Usr2';

            } else {

                dw = (DWORD)'Usr3';
            }

            if (!pPatABC[0]) {

                pPatABC[0] = pPatSrc;
            }

            if (!pPatABC[1]) {

                pPatABC[1] = pPatSrc;
            }

            if (!pPatABC[2]) {

                pPatABC[2] = pPatSrc;
            }
        }

        Checksum = ComputeChecksum((LPBYTE)&HTPatternIndex,
                                   dw,
                                   sizeof(HTPatternIndex));
        Checksum = ComputeChecksum((LPBYTE)pPatSrc, Checksum, cbPat);

        if (dw == (DWORD)'Usr3') {

            Checksum = ComputeChecksum((LPBYTE)pPatABC[1], Checksum, cbPat);
            Checksum = ComputeChecksum((LPBYTE)pPatABC[2], Checksum, cbPat);
        }

    } else {

        Checksum = ComputeChecksum((LPBYTE)&HTPatternIndex,
                                   'HTSC',
                                   sizeof(HTPatternIndex));

        if (HTPatternIndex == HTPAT_SIZE_SUPERCELL) {

            DCIFlags |= DCIF_SUPERCELL;

        } else if (HTPatternIndex == HTPAT_SIZE_SUPERCELL_M) {

            DCIFlags |= DCIF_SUPERCELL_M;
        }

        HTPatternIndex        >>= 1;
        PatInfo.HTCell.cxOrg    = (WORD)DefStdHTPat[HTPatternIndex].cx;
        PatInfo.HTCell.Height   = (WORD)DefStdHTPat[HTPatternIndex].cy;
        PatInfo.HTCell.Flags    = HTCF_STATIC_PTHRESHOLDS;
    }

    PatInfo.HTCell.cxReal = (WORD)REAL_PAT_CX(PatInfo.HTCell.cxOrg);
    PatInfo.HTCell.Width  = (WORD)FINAL_PAT_CX(PatInfo.HTCell.cxOrg);
    PatInfo.HTCell.Size   = (DWORD)PatInfo.HTCell.Width *
                            (DWORD)PatInfo.HTCell.Height * SIZE_PER_PAT;

    DBGP_IF((DBGP_CACHE_PAT | DBGP_GEN_PAT),
            DBGP("HTCell(%3ldx%3ld): pDCI=%p, Idx=%2ld, cxOrg=%3ld, cxReal=%3ld, Size=%ld"
                ARGDW(PatInfo.HTCell.Width) ARGDW(PatInfo.HTCell.Height)
                ARGPTR(pDCI) ARGDW(PatInfo.HTCell.HTPatIdx)
                ARGDW(PatInfo.HTCell.cxOrg) ARGDW(PatInfo.HTCell.cxReal)
                ARGDW(PatInfo.HTCell.Size)));

    ASSERT(PatInfo.HTCell.cxReal > PAT_CX_ADD);

    //
    // Add width by one because we want to be able to do two pixel at end, and
    // pattern always in 3 plane mode
    //

    if (!pDCI) {

        //
        // Return checksum if pDCI passed is NULL
        //

        return(ComputeChecksum((LPBYTE)&PatInfo, Checksum, sizeof(PATINFO)));
    }

    //
    // Allocate the memory for the pattern buffer which we will stored the
    // final halftone pattern for this device.
    //

    if (PatInfo.HTCell.Flags & HTCF_STATIC_PTHRESHOLDS) {

        PatInfo.HTCell.pThresholds = NULL;

    } else {

        if (!(PatInfo.HTCell.pThresholds =
                                    (LPBYTE)HTAllocMem(pDCI,
                                                       HTMEM_pThresholds,
                                                       NONZEROLPTR,
                                                       PatInfo.HTCell.Size))) {

            return(HTERR_INSUFFICIENT_MEMORY);
        }

        if (!(GenerateWORDPat(pPatABC[0],
                              pPatABC[1],
                              pPatABC[2],
                              (LPWORD)PatInfo.HTCell.pThresholds,
                              (UINT)PatInfo.HTCell.cxOrg,
                              (UINT)PatInfo.HTCell.Width,
                              (UINT)PatInfo.HTCell.Height))) {

            HTFreeMem(PatInfo.HTCell.pThresholds);
            return(HTERR_INSUFFICIENT_MEMORY);
        }
    }

    pDCI->Flags  = DCIFlags;
    pDCI->HTCell = PatInfo.HTCell;

    return(PatInfo.HTCell.Size);
}




VOID
HTENTRY
DrawCornerLine(
    LPBYTE  pPattern,
    WORD    cxPels,
    WORD    cyPels,
    WORD    BytesPerScanLine,
    WORD    LineWidthPels,
    BOOL    FlipY
    )

/*++

Routine Description:

    This function draw a line from lower left corner to the upper right
    corner, to draw a line from upper left corner to the lower right corner
    just set the FlipY to true.

    This is the modified integer DDA algorithm which the line always symmetry,
    it make the line look less starsteps, if need to draw line from specified
    (x1, y1) to (x2, y2) then this function can be modified whih only changed
    to the startingt/end points for calculating the ErrorInc/ErrorDec/Error
    and Length parameters.

        Origin X, Y     - at first pel of last scan line and the X moving to
                          the right and Y moving to the top.

        Color           - only black/white where white=0, and black=1

Arguments:

    pPattern            - The pointer to the buffer, it must already initialize
                          to all zero and must have the size in bytes of
                          BytesPerScanLine * cyPels

    cxPels              - The width in pels of the visible area in the pattern.

    cyPels              - The height of the pattern buffer in scan line.

    BytesPerScanLine    - Total bytes of one scan line.

    LineWidthPels       - The line width in pels which will be draw into the
                          pattern buffer, (pen width).

    FlipY               - If true then the final pattern will be up-side-down


Return Value:

    No return value


Author:

    24-May-1991 Fri 22:30:43 created  -by-  Daniel Chou (danielc)


Revision History:

    20-Sep-1991 Fri 18:14:28 updated  -by-  Daniel Chou (danielc)

        Updated so it only using interger operation only (fast) and plus
        modified DDA so it will symmetric for better line constant brightness,
        the parameters for this call is reduced by assuming that the line
        is always drawing from corner to corner only.



--*/

{
    LPBYTE  pCurPat;
    INT     NextScanLine;
    INT     x;
    INT     y;
    INT     xLast;
    INT     yLast;
    INT     MinPels;
    INT     TotalPels;
    INT     xyInc[2];
    INT     Error;
    INT     ErrorInc;
    INT     ErrorDec;
    INT     Length;
    BYTE    DestMask;
    BYTE    DestByte;


    ASSERT((LineWidthPels) && (LineWidthPels <= cxPels));

    if (!LineWidthPels) {

        return;
    }

    if ((cxPels == 1) || (cyPels == 1) || (LineWidthPels >= cxPels)) {

        FillMemory(pPattern, BytesPerScanLine * cyPels, 0xff);
        return;
    }

    if (FlipY) {

        //
        // Flip the Y, draw from top/left, it located at first line
        //

        NextScanLine = (INT)BytesPerScanLine;

    } else {

        //
        // no Y flip so we have to draw from the lower left corner, and its
        // buffer location is at last scan line
        //

        pPattern += ((LONG)BytesPerScanLine * (LONG)(cyPels - 1));
        NextScanLine = -(INT)BytesPerScanLine;
    }

    //
    // Calculate the X/Y increment and initial error values, remember we must
    // always truncate the XInc/YInc values. how this works is that we keep a
    // fixed floating point version of the error terms (15-bit fixed point
    // value, one unit of fixed value is 0.000031) and has bit 15 (ie. 0x8000)
    // as the overrun indicator, if after the X/Y increment and this bit is
    // set then X/Y will need to increment by 1.
    //
    // At first we initialize the X/Y error terms to the half of the slope
    // different, this way the DDA lines will be balanced distributed
    // for the pels in the line resulting better constant line brightness and
    // less stairsteps than the round up type of error term for reqular DDA.
    //
    // For drawing from starting points (x1, x2) to (x2, y2) (ie. point at
    // (x2, y2) is exclusive) then using following changes
    //
    //  xLast = x = x1;
    //  yLast = y = y1;
    //
    //  change 'cxPels' to '(x2 - x1)' when calcaulate Inc/Dec/Error terms
    //  change 'cyPels' to '(y2 - y1)' when calcaulate Inc/Dec/Error terms
    //

    if (cxPels >= cyPels) {

        xyInc[0] = 1;
        xyInc[1] = 0;
        ErrorDec = (INT)cxPels;
        ErrorInc = (INT)cyPels;

    } else {

        xyInc[0] = 0;
        xyInc[1] = 1;
        ErrorDec = (INT)cyPels;
        ErrorInc = (INT)cxPels;
    }

    Length    = ErrorDec;               // DeltaX = total run (larger one)
    ErrorDec += ErrorDec;               // Delta2X
    Error     = ErrorInc - ErrorDec;    // DeltaY - Delta2X (initlal negative)
    ErrorInc += ErrorInc;               // Delta2Y

    MinPels = (INT)LineWidthPels - 1;

    if (cxPels > cyPels) {

        if ((MinPels -= (INT)(cxPels / cyPels)) < 0) {

            MinPels = 0;
        }
    }

    TotalPels = MinPels;
    xLast     =
    yLast     =
    x         =
    y         = 0;

    DBGP_IF(DBGP_DRAWLINE,
            DBGP("[%3u:%3u]: pPat=%p, Err=%d, Inc=%d, Dec=%d, Pels=%d)"
                ARGW(cxPels)
                ARGW(cyPels)
                ARG(pPattern)
                ARGS(Error)
                ARGS(ErrorInc)
                ARGS(ErrorDec)
                ARGW(LineWidthPels)));

    //
    // The single pel version of modified integer DDA for all octants is as
    // following:
    //                                      ;
    //  while (Length--) {                  ; do until all DeltaX finished
    //                                      ;
    //      PlotPoint(x, y);                ; Ploting point at (x,y)
    //                                      ;
    //      x += xyInc[0];                  ; Increment either x or y by one
    //      y += xyInc[1];                  ; unit depends on which octant.
    //                                      ;
    //      if ((Error += ErrorInc) >= 0) { ; adding error terms for shorter
    //                                      ; axis, integer sign operation.
    //          x     += xyInc[1];          ; adding either x or y by one if
    //          y     += xyInc[0];          ; 'pel' is closer to the slop.
    //          Error -= ErrorDec;          ; reset the error term
    //      }                               ;
    //  }
    //


    while (Length--) {                          // do all the DeltaX pels

        ++TotalPels;

        x += xyInc[0];                          // x=running number 0-up
        y += xyInc[1];                          // y only need 0/1

        if ((Error += ErrorInc) >= 0) {

            x     += xyInc[1];
            y     += xyInc[0];
            Error -= ErrorDec;
        }

        if (y != yLast) {

            ASSERT(y <= (INT)cyPels);

            DestMask  = (BYTE)(0x80 >> (xLast & 0x07));     // starting mask
            pCurPat   = pPattern + (xLast >> 3);            // byte start
            DestByte  = (BYTE)0x00;                         // start w/0

            DBGP_IF(DBGP_DRAWLINE,
                    DBGP("3u: Plot(%3d, %3d) %3d Pels, Next(x,y)=(%3d,%3d), Error=%d"
                            ARGS(Length)
                            ARGS(xLast)
                            ARGS(yLast)
                            ARGS(TotalPels)
                            ARGW(x)
                            ARGW(y)
                            ARGS(Error)));

            while (TotalPels--) {

                DestByte |= DestMask;

                if (++xLast >= (INT)cxPels) {

                    //
                    // If we wrap around, we have get the old data byte back
                    // since first byte may already has some on bits.
                    //

                    *pCurPat = DestByte;
                    DestByte = *(pCurPat = pPattern);
                    DestMask = (BYTE)0x80;
                    xLast    = 0;

                } else if (!(DestMask >>= 1)) {

                    *pCurPat++ = DestByte;
                    DestMask   = 0x80;
                    DestByte   = 0x00;
                }
            }

            //
            // Since we using DestByte as temparory data area, we need to make
            // sure that last modified data byte is saved back to the buffer,
            // to do that we only need to check if Mask=0x80, because if the
            // mask is equal to 0x80 then we just saved the byte, otherwise
            // we are in middle of the byte processing, we could do this by
            // extra checking for (TotalPels == 0) but this should check
            // at outside of the (DestMask >>= 1) loop to reduced the overhead.
            //

            if (DestMask != (BYTE)0x80) {

                *pCurPat = DestByte;                // last one if any
            }

            pPattern += NextScanLine;               // next scan line start
            xLast     = x;                          // remember this one
            yLast     = y;                          // reset y
            TotalPels = MinPels;
        }
    }

    ASSERT(y == (INT)cyPels);
}




LONG
HTENTRY
CreateStandardMonoPattern(
    PDEVICECOLORINFO    pDeviceColorInfo,
    PSTDMONOPATTERN     pStdMonoPat
    )

/*++

Routine Description:

    This function create standard pre-defined monochrome pattern to a
    1 bit per pel bitmap, alignment of each bitmap scan line to the
    specified

Arguments:

    pDeviceColorInfo    - Pointer to the DEVICECOLORINFO data structure, this
                          is used to get the device resolution information

    pStdMonoPat         - Pointer to the STDMONOPATTERN data structure.


    NOTE: The pStdMonoPat->PatternIndex must be < HT_SMP_0_PERCENT_SCREEN


Return Value:

    Retrun value will be the size of the final pattern, it will be <= 0 if an
    error occurred and the return value is the halftone error code.

    If the pPattern field in the pStdMonoPat data structure then only the
    pattern size is returned.

Author:

    24-May-1991 Fri 12:39:33 created  -by-  Daniel Chou (danielc)


Revision History:

    18-Sep-1991 Wed 18:49:50 updated  -by-  Daniel Chou (danielc)

        Fixed the bugs for the HORZ_VERT cross lines which has bad LineHeight
        and LineWidh variables,

        adding 2 decimal points accuracy when calculation the device pels to
        prevent run away intermediate result.



--*/

{
    LPBYTE          pPat;
    LPBYTE          pTempPat;
    STDMONOPATTERN  StdMonoPat;
    MONOPATRATIO    PatRatio;
    WORD            DeviceResXDPI;
    WORD            DeviceResYDPI;
    WORD            DevicePelsDPI;
    DWORD           DevPelSub;
    WORD            Index;
    WORD            Loop;
    WORD            LineMode;
    LONG            PatSize;
    DWORD           YPels2;                 // retain 2 decimal points
    DWORD           LineWidth2;             // retain 2 decimal points
    DWORD           LineHeight2;            // retain 2 decimal points
    DWORD           LineSpace2;             // retain 2 decimal points
    WORD            LineWidthPels;
    WORD            LineHeightPels;
    BOOL            FlipY;
    BYTE            Mask;
    BYTE            TempByte;


    StdMonoPat = *pStdMonoPat;

    ASSERTMSG("CreateStdMonoPattern: PatIndex >= HT_SMP_PERCENT_SCREEN(0)",
               StdMonoPat.PatternIndex < HT_SMP_PERCENT_SCREEN(0));

    DeviceResXDPI = pDeviceColorInfo->DeviceResXDPI;
    DeviceResYDPI = pDeviceColorInfo->DeviceResYDPI;
    // DevicePelsDPI = pDeviceColorInfo->DevicePelsDPI;
    DevPelSub     = DivFD6(100, pDeviceColorInfo->DevPelRatio) - 100;

    FlipY = (BOOL)((StdMonoPat.Flags & SMP_TOPDOWN) ? FALSE : TRUE);

    if (!StdMonoPat.LineWidth) {

        StdMonoPat.LineWidth = DEFAULT_SMP_LINE_WIDTH;
    }

    if (!StdMonoPat.LinesPerInch) {

        StdMonoPat.LinesPerInch = DEFAULT_SMP_LINES_PER_INCH;
    }

    LineSpace2  = (DWORD)DIVRUNUP((DWORD)DeviceResXDPI * 100L,
                                 (DWORD)StdMonoPat.LinesPerInch);
    LineWidth2  = (DWORD)DIVRUNUP((DWORD)StdMonoPat.LineWidth *
                                                        (DWORD)DeviceResXDPI,
                                  10L);

    switch (StdMonoPat.PatternIndex) {

    case HT_SMP_HORZ_LINE:
    case HT_SMP_VERT_LINE:
    case HT_SMP_HORZ_VERT_CROSS:

        YPels2 = LineSpace2;                        // default cyPels size

        StdMonoPat.cxPels = (WORD)DIVRUNUP(LineSpace2, 100L);

        if (StdMonoPat.PatternIndex == HT_SMP_HORZ_LINE) {

            // Maximize to the width size of the alignbytes

            StdMonoPat.cxPels = (WORD)StdMonoPat.ScanLineAlignBytes << 3;

        } else if (StdMonoPat.PatternIndex == HT_SMP_VERT_LINE) {

            YPels2 = 800L;                          // using 8 pels
        }

        break;

    case HT_SMP_DIAG_15_LINE_UP:
    case HT_SMP_DIAG_15_LINE_DOWN:
    case HT_SMP_DIAG_15_CROSS:
    case HT_SMP_DIAG_30_LINE_UP:
    case HT_SMP_DIAG_30_LINE_DOWN:
    case HT_SMP_DIAG_30_CROSS:
    case HT_SMP_DIAG_45_LINE_UP:
    case HT_SMP_DIAG_45_LINE_DOWN:
    case HT_SMP_DIAG_45_CROSS:
    case HT_SMP_DIAG_60_LINE_UP:
    case HT_SMP_DIAG_60_LINE_DOWN:
    case HT_SMP_DIAG_60_CROSS:
    case HT_SMP_DIAG_75_LINE_UP:
    case HT_SMP_DIAG_75_LINE_DOWN:
    case HT_SMP_DIAG_75_CROSS:

        Index = StdMonoPat.PatternIndex - (WORD)HT_SMP_DIAG_15_LINE_UP;

        if (LineMode = (WORD)(Index % 3)) {

            FlipY = !FlipY;                 //  Down or Cross
        }

        PatRatio = MonoPatRatio[Index / 3];

        StdMonoPat.cxPels = (WORD)DIVRUNUP(LineSpace2 * 100L,
                                             (DWORD)PatRatio.Distance);

        YPels2 = (DWORD)DIVRUNUP((DWORD)PatRatio.YSize * LineSpace2,
                                 (DWORD)PatRatio.Distance);

        LineWidth2 = (DWORD)DIVRUNUP(LineWidth2 * 10000L,
                                     (DWORD)PatRatio.Distance);

        break;

    default:                    // all other percentage density

        //
        // 04-Aug-2000 Fri 10:31:59 updated  -by-  Daniel Chou (danielc)
        //  All other non HT_SMP_xxxx should not be here, we already has
        //  a ASSERTMSG at begining of this function
        //

        return(0);
    }

    //
    // Now LineWidth2 = width of the line in pels (2 decimal points) and
    // we have to compensate the size of pels which at most time is greater
    // than its 'resolution', but since the distance between two device pels
    // is assume to be its point 'resolution' so actually we just have to
    // compensate the left/right edges of the total line width, the first
    // and last pels that is.
    //
    //  ResPels to reduced = (SizePel / SizeResolution)
    //                     = (PelDPI / ResDPI) - 1.0
    //

    LineWidth2 -= DevPelSub;
#if 0

    if (DevicePelsDPI) {

        DBGP("<<< XPels=%ld, ResX=%ld, Width=%ld, Ratio=%s, Sub=%ld, New=%ld"
                ARGDW(DevicePelsDPI) ARGDW(DeviceResXDPI)
                ARGDW(LineWidth2) ARGFD6(pDeviceColorInfo->DevPelRatio, 1, 6)
                ARGDW(DevPelSub) ARGDW(LineWidth2 - DevPelSub));

        LineWidth2 -= (DWORD)DIVRUNUP((DWORD)DevicePelsDPI * 100L,
                                      (DWORD)DeviceResXDPI) - (DWORD)100;

        DBGP(">>> XPels=%ld, ResX=%ld, Width=%ld"
                ARGDW(DevicePelsDPI) ARGDW(DeviceResXDPI)
                ARGDW(LineWidth2));
    }
#endif

    //
    // Adjust YPels2 for the non-equal X/Y aspect ratio, the ratio is based
    // one the XDPI
    //

    if (DeviceResXDPI != DeviceResYDPI) {

        YPels2 = (DWORD)DIVRUNUP(YPels2 * (DWORD)DeviceResYDPI,
                                 (DWORD)DeviceResXDPI);
    }

    //
    // Convert to device pels and check all the zero term, the LineHeightPels
    // only check later for the HORZ/VERT/HORZ_VERT_CROSS line types
    //

    if (!StdMonoPat.cxPels) {

        ++StdMonoPat.cxPels;
    }

    if (!(StdMonoPat.cyPels = (WORD)DIVRUNUP(YPels2, 100))) {

        ++StdMonoPat.cyPels;
    }

    if ((LineWidthPels = (WORD)DIVRUNUP(LineWidth2, 100)) >
                                                        StdMonoPat.cxPels) {

        LineWidthPels = (WORD)(StdMonoPat.cxPels - 1);
    }

    if (!LineWidthPels) {

        ++LineWidthPels;
    }

    //
    // calculate the buffer size for storing the pattern
    //

    StdMonoPat.BytesPerScanLine = (WORD)
                ComputeBytesPerScanLine((UINT)BMF_1BPP,
                                        (UINT)StdMonoPat.ScanLineAlignBytes,
                                        (DWORD)StdMonoPat.cxPels);
    PatSize = (LONG)(StdMonoPat.BytesPerScanLine * StdMonoPat.cyPels);


    ASSERTMSG("StdMonoPattern Size Too big", PatSize < 0x10000L);

    if (pPat = StdMonoPat.pPattern) {

        ZeroMemory(pPat, (WORD)PatSize);

        switch (StdMonoPat.PatternIndex) {

        case HT_SMP_VERT_LINE:
        case HT_SMP_HORZ_VERT_CROSS:

            Index    = (StdMonoPat.cxPels - (Loop = LineWidthPels)) >> 1;
            pTempPat = pPat + (Index >> 3);
            Mask     = (BYTE)(0x80 >> (Index & 0x07));
            TempByte = (BYTE)0;

            //
            // Do this for the first row then copy the rest
            //

            while (Loop--) {

                TempByte |= Mask;

                if ((!(Mask >>= 1)) || (!Loop)) {

                    *pTempPat++ = TempByte;
                    TempByte    = (BYTE)0;
                    Mask        = (BYTE)0x80;
                }
            }

            for (Index = 0, pTempPat = pPat;
                 Index < StdMonoPat.cyPels;
                 Index++) {

                CopyMemory(pTempPat, pPat, StdMonoPat.BytesPerScanLine);
                pTempPat += StdMonoPat.BytesPerScanLine;
            }

            //
            // Fall through
            //

        case HT_SMP_HORZ_LINE:

            if (StdMonoPat.PatternIndex != HT_SMP_VERT_LINE) {

                //
                // Set Line Height according to the size of device Y
                // resolution and its pel resolution. (see above for
                // resolution pels reduction)
                //

                LineHeight2 = (DWORD)DIVRUNUP((DWORD)StdMonoPat.LineWidth *
                                                        (DWORD)DeviceResYDPI,
                                              10L) - DevPelSub;
#if 0
                if (DevicePelsDPI) {

                    LineHeight2 -= (DWORD)DIVRUNUP((DWORD)DevicePelsDPI * 100L,
                                                   (DWORD)DeviceResYDPI) -
                                   (DWORD)100;
                }
#endif
                if ((LineHeightPels = (WORD)DIVRUNUP(LineHeight2, 100)) >=
                                                        StdMonoPat.cyPels) {

                    LineHeightPels = (WORD)(StdMonoPat.cyPels - 1);
                }

                if (!LineHeightPels) {

                    ++LineHeightPels;
                }

                FillMemory(pPat + (((StdMonoPat.cyPels -
                                     LineHeightPels) >> 1) *
                                 StdMonoPat.BytesPerScanLine),
                           LineHeightPels * StdMonoPat.BytesPerScanLine,
                           0xff);
            }

            break;

        case HT_SMP_DIAG_15_LINE_UP:
        case HT_SMP_DIAG_15_LINE_DOWN:
        case HT_SMP_DIAG_15_CROSS:
        case HT_SMP_DIAG_30_LINE_UP:
        case HT_SMP_DIAG_30_LINE_DOWN:
        case HT_SMP_DIAG_30_CROSS:
        case HT_SMP_DIAG_45_LINE_UP:
        case HT_SMP_DIAG_45_LINE_DOWN:
        case HT_SMP_DIAG_45_CROSS:
        case HT_SMP_DIAG_60_LINE_UP:
        case HT_SMP_DIAG_60_LINE_DOWN:
        case HT_SMP_DIAG_60_CROSS:
        case HT_SMP_DIAG_75_LINE_UP:
        case HT_SMP_DIAG_75_LINE_DOWN:
        case HT_SMP_DIAG_75_CROSS:

            DrawCornerLine(StdMonoPat.pPattern,
                           StdMonoPat.cxPels,
                           StdMonoPat.cyPels,
                           StdMonoPat.BytesPerScanLine,
                           LineWidthPels,
                           FlipY);

            if (LineMode == 2) {                // cross section

                pTempPat = pPat + ((StdMonoPat.cyPels - 1) *
                                   StdMonoPat.BytesPerScanLine);

                //
                // Make the up-side-down mirror which create a cross section
                //

                Index = StdMonoPat.cyPels >> 1;

                while (Index--) {

                    Loop = StdMonoPat.BytesPerScanLine;

                    while (Loop--) {

                        *pPat++ = *pTempPat++ = (*pPat | *pTempPat);
                    }

                    pTempPat -= (StdMonoPat.BytesPerScanLine << 1);
                }

                pPat = StdMonoPat.pPattern;             // restore address
            }

            break;

        default:                    // all other percentage density

            break;
        }

        if (StdMonoPat.Flags & SMP_0_IS_BLACK) {

            Index = (WORD)PatSize;

            while (Index--) {

                *pPat++ ^= 0xff;
            }
        }
    }

    *pStdMonoPat = StdMonoPat;


    return(PatSize);

}



LONG
HTENTRY
CachedHalftonePattern(
    PDEVICECOLORINFO    pDCI,
    PDEVCLRADJ          pDevClrAdj,
    PAAPATINFO          pAAPI,
    LONG                PatX,
    LONG                PatY,
    BOOL                FlipYPat
    )

/*++

Routine Description:

    This function create a cached pattern depends on the source color table,
    if the source color table only has one entry and we are using the pattern
    solid fill then the cached table will be the final color mask bits, else
    the color table will be the color threshold values.

    Note: the cached pattern will rotate both X, Y direction to aligned with
          destination so that first pel/scanline in the cached pattern will
          be corresponsed to the first pel in the destination.

Arguments:

    pHR - Pointer to the HALFTONERENDER data structure.


Return Value:

    The return value will be <= 0 if an error occurred and the return value is
    the error code, otherwise the return value is the size of the cached
    pattern allocated.

Author:

    05-Mar-1991 Tue 11:08:18 created  -by-  Daniel Chou (danielc)


Revision History:

    07-Jun-1991 Fri 17:23:16 updated  -by-  Daniel Chou (danielc)
        Fixed pattern solid fill's pattern alignment problems


--*/

{
    HTCELL      HTCell;
    AAPATINFO   AAPI;
    LONG        cxPat;
    LONG        cbPat;
    LONG        x;
    LONG        y;


    //
    // If pDCI->HTCell.pThresholds == NULL then we need to make the pattern
    // now
    //


    if (pDCI->HTCell.pThresholds == NULL) {

        ASSERT((pDCI->HTCell.Flags & HTCF_STATIC_PTHRESHOLDS) &&
               (pDCI->HTCell.HTPatIdx < HTPAT_SIZE_USER));

        if (!(Generate_HTSC_WORD(&(pDCI->HTCell)))) {

            return(HTERR_INSUFFICIENT_MEMORY);
        }
    }

    HTCell = pDCI->HTCell;

    //
    // We will always make the pattern width is multiple of 8, this will make
    // the output process faster.
    //

    AAPI.DstOrder = pDevClrAdj->DMI.DstOrder;

    //
    // Figure out the 555 pattern first
    //

    MOD_PAT_XY(x, PatX, CX_RGB555PAT);
    MOD_PAT_XY(y, PatY, CY_RGB555PAT);

    AAPI.pbPat555  = (LPBYTE)RGB555Pat + (CX_SIZE_RGB555PAT * y) + x;
    AAPI.cyNext555 = CX_SIZE_RGB555PAT;
    AAPI.cbEnd555  = CX_RGB555PAT - x - 1;

    if (FlipYPat) {

        AAPI.pbWrap555 = (LPBYTE)RGB555Pat - CX_SIZE_RGB555PAT + x;
        AAPI.pbBeg555  = AAPI.pbWrap555 + CB_RGB555PAT;
        AAPI.cyNext555 = -CX_SIZE_RGB555PAT;

    } else {

        AAPI.pbWrap555 = (LPBYTE)RGB555Pat + CB_RGB555PAT + x;
        AAPI.pbBeg555  = AAPI.pbWrap555 - CB_RGB555PAT;
        AAPI.cyNext555 = CX_SIZE_RGB555PAT;
    }

    DBGP_IF(DBGP_CACHE_PAT,
            DBGP("555: Orgin=(%ld, %ld)->(%ld, %ld), pbPat=%p->%p, cyNext=%ld, cbEnd=%ld, "
                ARGDW(PatX) ARGDW(PatY) ARGDW(x) ARGDW(y)
                ARGPTR(RGB555Pat) ARGPTR(AAPI.pbPat555)
                ARGDW(AAPI.cyNext555) ARGDW(AAPI.cbEnd555)));

    //
    // Figure out the ABC pattern now
    //

    cxPat  = (LONG)HTCell.Width * SIZE_PER_PAT;
    cbPat  = (LONG)HTCell.Height * cxPat;

    MOD_PAT_XY(x, PatX, HTCell.cxReal);
    MOD_PAT_XY(y, PatY, HTCell.Height);

    x              *= SIZE_PER_PAT;
    AAPI.pbPatBGR   = (LPBYTE)HTCell.pThresholds + (y * cxPat) + x;
    AAPI.cbWrapBGR  = -(LONG)HTCell.cxReal * SIZE_PER_PAT;
    AAPI.cbEndBGR   = -AAPI.cbWrapBGR - x;

    DBGP_IF(DBGP_CACHE_PAT,
        DBGP("HTCell=%ld (%ld) x %ld, cbPat=%ld, pbPat=%p, Flags=%04lx"
            ARGDW(HTCell.Width) ARGDW(HTCell.cxReal) ARGDW(HTCell.Height)
            ARGDW(HTCell.Size) ARGPTR(HTCell.pThresholds)
            ARGDW(HTCell.Flags)));

    if (FlipYPat) {

        AAPI.pbWrapBGR = (LPBYTE)HTCell.pThresholds - cxPat + x;
        AAPI.pbBegBGR   = AAPI.pbWrapBGR + cbPat;
        AAPI.cyNextBGR = -cxPat;

    } else {

        AAPI.pbWrapBGR  = (LPBYTE)HTCell.pThresholds + cbPat + x;
        AAPI.pbBegBGR   = AAPI.pbWrapBGR - cbPat;
        AAPI.cyNextBGR  = cxPat;
    }

    *pAAPI = AAPI;

    DBGP_IF(DBGP_CACHE_PAT,
            DBGP("BGR[%ld=%ld:%ld:%ld]: Org=(%ld, %ld)->(%ld, %ld), pbPat=%p->%p"
                ARGDW(AAPI.DstOrder.Index)      ARGDW(AAPI.DstOrder.Order[0])
                ARGDW(AAPI.DstOrder.Order[1])   ARGDW(AAPI.DstOrder.Order[2])
                ARGDW(PatX) ARGDW(PatY)
                ARGDW(x / SIZE_PER_PAT) ARGDW(y)
                ARGPTR(HTCell.pThresholds) ARGPTR(AAPI.pbPatBGR)));

    DBGP_IF(DBGP_CACHE_PAT,
            DBGP("pbBeg=%p, pbWrap=%p, cyNext=%ld, cbEnd=%ld, cbWrap=%ld"
                ARGPTR(AAPI.pbBegBGR) ARGPTR(AAPI.pbWrapBGR)
                ARGDW(AAPI.cyNextBGR) ARGDW(AAPI.cbEndBGR)
                ARGDW(AAPI.cbWrapBGR)));



    return((LONG)cbPat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htpat.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htpat.h


Abstract:

    This module contains the local structures, constants definitions for the
    htpat.c


Author:
    23-Oct-1997 Thu 15:14:14 updated  -by-  Daniel Chou (danielc)
        Re-write regress for color mapping

    23-Apr-1992 Thu 20:01:55 updated  -by-  Daniel Chou (danielc)
        1. Changed SHIFTMASK data structure.

            A. changed the NextDest[] from 'CHAR' to SHORT, this is will make
               sure if compiled under MIPS the default 'unsigned char' will
               not affect the signed operation.

            B. Change Shift1st From 'BYTE' to 'WORD'

    28-Mar-1992 Sat 20:58:07 updated  -by-  Daniel Chou (danielc)
        Add all the functions which related the device pel/intensities
        regression analysis.

    18-Jan-1991 Fri 16:53:41 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:

    20-Sep-1991 Fri 18:09:50 updated  -by-  Daniel Chou (danielc)

        Change DrawPatLine() prototype to DrawCornerLine()

    13-Apr-1992 Mon 18:40:44 updated  -by-  Daniel Chou (danielc)
        Rewrite MakeHalftoneBrush()

--*/


#ifndef _HTPAT_
#define _HTPAT_


#define MOD_PAT_XY(s,xy,c)  if (((s) = (SHORT)(xy)%(c)) < 0) { (s) += (c); }


typedef struct _PATINFO {
    LPBYTE  pYData;
    HTCELL  HTCell;
    } PATINFO, FAR *PPATINFO;


typedef struct _SCDATA {
    BYTE    Value;
    BYTE    xSubC;
    WORD    Index;
    } SCDATA, FAR *PSCDATA;

typedef struct _STDHTPAT {
    BYTE        cx;
    BYTE        cy;
    WORD        cbSrcPat;
    CONST BYTE  *pbSrcPat;
    } STDHTPAT, *PSTDHTPAT;


//
// This is the default using by the NT GDI
//

#define DEFAULT_SMP_LINE_WIDTH      8           // 0.008 inch
#define DEFAULT_SMP_LINES_PER_INCH  15          // 15 lines per inch


typedef struct _MONOPATRATIO {
    UDECI4  YSize;
    UDECI4  Distance;
    } MONOPATRATIO;


#define CACHED_PAT_MIN_WIDTH        64
#define CACHED_PAT_MAX_WIDTH        256


#define CHB_TYPE_PACK8              0
#define CHB_TYPE_PACK2              1
#define CHB_TYPE_BYTE               2
#define CHB_TYPE_WORD               3
#define CHB_TYPE_DWORD              4

#define CX_RGB555PAT                65
#define CY_RGB555PAT                65
#define CX_SIZE_RGB555PAT           (CX_RGB555PAT + 1)
#define CB_RGB555PAT                (CX_SIZE_RGB555PAT * CY_RGB555PAT)


typedef struct _AAPATINFO {
    LPBYTE      pbPatBGR;           // Starting pattern scan X/Y offset
    LPBYTE      pbWrapBGR;          // point of wrapping of whole pattern
    LPBYTE      pbBegBGR;           // Whole pattern wrapping location
    LONG        cyNextBGR;          // cb to next pattern scan
    LONG        cbEndBGR;           // cb to the LAST PAT of scan from pbPatBGR
    LONG        cbWrapBGR;          // cb to wrap from LAST PATTERN
    RGBORDER    DstOrder;           // Destination order
    LPBYTE      pbPat555;           // Starting pattern scan X/Y offset
    LPBYTE      pbWrap555;          // point of wrapping of whole pattern
    LPBYTE      pbBeg555;           // Whole pattern wrapping location
    LONG        cyNext555;          // cb to next pattern scan
    LONG        cbEnd555;           // cb to the LAST PAT of scan from pbPat555
    } AAPATINFO, *PAAPATINFO;

#define MAX_BGR_IDX             0xFFF
#define MAX_K_IDX               ((MAX_BGR_IDX + 2) / 3)
#define PAT_CX_ADD              7
#define CB_PAT                  sizeof(WORD)
#define COUNT_PER_PAT           3
#define SIZE_PER_PAT            (CB_PAT * COUNT_PER_PAT)
#define INC_PPAT(p,i)           (LPBYTE)(p) += (i * SIZE_PER_PAT)
#define GETPAT(p, Order, Idx)                                               \
            (DWORD)*((LPWORD)((LPBYTE)(p) + Order + (Idx * SIZE_PER_PAT)))
#define GETMONOPAT(p, Idx)      GETPAT(p, 2, Idx)



//
// Function Prototype
//

LONG
HTENTRY
ComputeHTCell(
    WORD                HTPatternIndex,
    PHALFTONEPATTERN    pHalftonePattern,
    PDEVICECOLORINFO    pDeviceColorInfo
    );

VOID
HTENTRY
DrawCornerLine(
    LPBYTE  pPattern,
    WORD    cxPels,
    WORD    cyPels,
    WORD    BytesPerScanLine,
    WORD    LineWidthPels,
    BOOL    FlipY
    );

LONG
HTENTRY
CreateStandardMonoPattern(
    PDEVICECOLORINFO    pDeviceColorInfo,
    PSTDMONOPATTERN     pStdMonoPat
    );

LONG
HTENTRY
CachedHalftonePattern(
    PDEVICECOLORINFO    pDCI,
    PDEVCLRADJ          pDevClrAdj,
    PAAPATINFO          pAAPI,
    LONG                PatX,
    LONG                PatY,
    BOOL                FlipYPat
    );


#endif  // _HTPAT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htp.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htp.h


Abstract:

    This module contains all the private data structures, constant used
    by this DLL


Author:

    15-Jan-1991 Tue 21:26:24 created  -by-  Daniel Chou (danielc)

[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:
    23-Apr-1992 Thu 20:01:55 updated  -by-  Daniel Chou (danielc)
        changed 'CHAR' type to 'SHORT' type, this will make sure if compiled
        under MIPS the default 'unsigned char' will not affect the signed
        operation.

    20-Sep-1991 Fri 19:27:49 updated  -by-  Daniel Chou (danielc)

        Delete #define SRCRGBF_PERCENT_SCREEN_IN_BLUE which will be processes
        at API call level (htapi.c)

    12-Dec-1991 Thu 20:44:05 updated  -by-  Daniel Chou (danielc)

        Move all color adjustments relative things to htmapclr.h

--*/


#ifndef _HTP_
#define _HTP_

#include <stddef.h>
#include <stdarg.h>

#include "windef.h"
#include "wingdi.h"
#include "winbase.h"
#include "winddi.h"

#include "ht.h"

#define HALFTONE_DLL_ID     (DWORD)0x54484344L          // "DCHT"
#define HTENTRY             NEAR                        // local functions

typedef unsigned long       ULDECI4;

#ifndef UMODE

#define qsort   EngSort

#endif  // UMODE


//
// Followings are the internal error IDs, this internal error number are
// all negative number and started at HTERR_INTERNAL_ERRORS_START
//

#define INTERR_STRETCH_FACTOR_TOO_BIG       HTERR_INTERNAL_ERRORS_START
#define INTERR_XSTRETCH_FACTOR_TOO_BIG      HTERR_INTERNAL_ERRORS_START-1
#define INTERR_STRETCH_NEG_OVERHANG         HTERR_INTERNAL_ERRORS_START-2
#define INTERR_COLORSPACE_NOT_MATCH         HTERR_INTERNAL_ERRORS_START-3
#define INTERR_INVALID_SRCRGB_SIZE          HTERR_INTERNAL_ERRORS_START-4
#define INTERR_INVALID_DEVRGB_SIZE          HTERR_INTERNAL_ERRORS_START-5



#if defined(_OS2_) || defined(_OS_20_) || defined(_DOS_)
#define HT_LOADDS   _loadds
#else
#define HT_LOADDS
#endif

#define DIVRUNUP(a, b)      (((a) + ((b) >> 1)) / (b))
#define SWAP(a, b, t)       { (t)=(a); (a)=(b); (b)=(t); }


typedef LPBYTE FAR          *PLPBYTE;


#include "htdebug.h"
#include "htmemory.h"

#define BMF_8BPP_MONO       (BMF_HT_LAST - 1)
#define BMF_8BPP_B332       (BMF_HT_LAST - 2)
#define BMF_8BPP_L555       (BMF_HT_LAST - 3)
#define BMF_8BPP_L666       (BMF_HT_LAST - 4)
#define BMF_8BPP_K_B332     (BMF_HT_LAST - 5)
#define BMF_8BPP_K_L555     (BMF_HT_LAST - 6)
#define BMF_8BPP_K_L666     (BMF_HT_LAST - 7)


#define COLOR_SWAP_23       0x01
#define COLOR_SWAP_12       0x02
#define COLOR_SWAP_13       0x04

typedef struct _RGB4B {
    BYTE    b;
    BYTE    g;
    BYTE    r;
    BYTE    a;
    } RGB4B, *PRGB4B;

typedef struct _BGR3 {
    BYTE    b;
    BYTE    g;
    BYTE    r;
    } BGR3, *PBGR3;

typedef struct _BGR8 {
    BYTE    b;
    BYTE    g;
    BYTE    r;
    } BGR8, *PBGR8;

typedef struct _GRAYF {
    WORD    Gray;
    BYTE    bReserved;
    BYTE    f;
    } GRAYF, *PGRAYF;

typedef struct _BGRF {
    BYTE    b;
    BYTE    g;
    BYTE    r;
    BYTE    f;
} BGRF, *PBGRF;

typedef struct _RGBL {
    LONG    r;
    LONG    g;
    LONG    b;
    } RGBL, *PRGBL;


typedef union _W2B {
    WORD    w;
    BYTE    b[2];
    } W2B, *PW2B;

typedef union _DW2W4B {
    DWORD   dw;
    WORD    w[2];
    BYTE    b[4];
    } DW2W4B, *PDW2W4B;

typedef union _TW6B {
    WORD    w[3];
    BYTE    b[6];
    } TW6B, *PTW6B;

typedef union _QW8B {
    DWORDLONG   qw;
    DWORD       dw[2];
    WORD        w[4];
    BYTE        b[8];
    } QW8B, *PQW8B;



/////////////////////////////////////////////////////////////////////////////

#ifndef i8086
#define i8086   0
#endif

#ifndef i286
#define i286    0
#endif

#ifndef i386
#define i386    0
#endif

#if defined(_OS2_)      ||  /* OS/2 PM 1.x  */  \
    defined(_OS2_20_)   ||  /* OS/2 PM 2.x  */  \
    defined(_DOS_)      ||  /* DOS Win3     */  \
    (i8086 > 0)         ||                      \
    (i286 > 0)          ||                      \
    (i386 > 0)

#define Compile80x86Mode

#ifdef  HAS_80x86_EQUIVALENT_CODES

#ifndef NO_ASM
#define HT_OK_GEN_80x86_CODES
#pragma message("                            <--- *** Using 80x86 assembly equivalent codes.")

#else   // otherwise using C codes

#pragma message("                            <--- *** Compile C codes.")

#endif  // NO_ASM
#endif  // HAS_80x86_EQUIVALENT_CODES

#endif  // 80x86 cpu

/////////////////////////////////////////////////////////////////////////////


#endif  // _HTP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htsetbmp.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htsetbmp.h


Abstract:

    This module contains all local definitions for the htsetbmp.c


Author:
    28-Mar-1992 Sat 20:59:29 updated  -by-  Daniel Chou (danielc)
        Add Support for VGA16, and also make output only 1 destinaiton pointer
        for 3 planer.

    03-Apr-1991 Wed 10:32:00 created  -by-  Daniel Chou (danielc)


[Environment:]

    Printer Driver.


[Notes:]


Revision History:



--*/


#ifndef _HTSETBMP_
#define _HTSETBMP_


//
//**************************************************************************
// Anti-Aliasing macros that getting the primary color table
//**************************************************************************


#define _DEF_LUTAAHDR                                                       \
    DWORD       ExtBGR[LUTAA_HDR_COUNT]


#define DEF_COPY_LUTAAHDR                                                   \
    _DEF_LUTAAHDR;                                                          \
    GET_LUTAAHDR(ExtBGR, pIdxBGR)


#define PPAT_NEXT(pCur, pEnd, cbWrap)                                       \
{                                                                           \
    if (((LPBYTE)(pCur) += SIZE_PER_PAT) >= (LPBYTE)(pEnd)) {               \
                                                                            \
        (LPBYTE)(pCur) += (cbWrap);                                         \
    }                                                                       \
}

#define PPAT_NEXT_CONTINUE(pCur, pEnd, cbAdd, cbWrap)                       \
{                                                                           \
    if (((LPBYTE)(pCur) += (cbAdd)) < (LPBYTE)(pEnd)) {                     \
                                                                            \
        continue;                                                           \
    }                                                                       \
                                                                            \
    (LPBYTE)(pCur) += (cbWrap);                                             \
}


//
// Access to BGRF's MACROs
//

#define _GET_B_CLR(pClr)            (pIdxBGR[      (UINT)(pClr)->b])
#define _GET_G_CLR(pClr)            (pIdxBGR[256 + (UINT)(pClr)->g])
#define _GET_R_CLR(pClr)            (pIdxBGR[512 + (UINT)(pClr)->r])


#define GET_GRAY_PRIM(pClr)         (DWORD)(_GET_B_CLR(pClr) +              \
                                            _GET_G_CLR(pClr) +              \
                                            _GET_R_CLR(pClr))

#define GET_GRAY_IDX(pClr,pPat,i)   (GET_GRAY_PRIM(pClr)-GETMONOPAT(pPat, i))

#define _GET_B_IDX(pClr,pPat,i)     (_GET_B_CLR(pClr) - GETPAT(pPat, 0, i))
#define _GET_G_IDX(pClr,pPat,i)     (_GET_G_CLR(pClr) - GETPAT(pPat, 2, i))
#define _GET_R_IDX(pClr,pPat,i)     (_GET_R_CLR(pClr) - GETPAT(pPat, 4, i))

//
//**************************************************************************
// 1BPP Macros
//**************************************************************************


#define GRAY_GRAY_PRIM(pClr)         (DWORD)(((pClr)->Gray ^ 0xFFFF) >> 4)

#define GRAY_GRAY_IDX(pClr,pPat,i)   (GRAY_GRAY_PRIM(pClr)-GETMONOPAT(pPat, i))



#define GRAY_1BPP_COPY(pPat, dwMask) (GRAY_GRAY_IDX(pbgrf, pPat, 0) & (dwMask))

#define _GRAY_1BPP_BIT(pPat, Idx, M) (GRAY_GRAY_IDX(pbgrf+Idx, pPat, Idx) & (M))


#define GRAY_1BPP_COPY_BYTE(pPat)                                            \
    (BYTE)((_GRAY_1BPP_BIT(pPat, 0, 0x800000) |                              \
            _GRAY_1BPP_BIT(pPat, 1, 0x400000) |                              \
            _GRAY_1BPP_BIT(pPat, 2, 0x200000) |                              \
            _GRAY_1BPP_BIT(pPat, 3, 0x100000) |                              \
            _GRAY_1BPP_BIT(pPat, 4, 0x080000) |                              \
            _GRAY_1BPP_BIT(pPat, 5, 0x040000) |                              \
            _GRAY_1BPP_BIT(pPat, 6, 0x020000) |                              \
            _GRAY_1BPP_BIT(pPat, 7, 0x010000)) >> 16)

#define GET_1BPP_MASK_BYTE(pbgrf)   (BYTE)(((pbgrf + 0)->f & 0x80) |        \
                                           ((pbgrf + 1)->f & 0x40) |        \
                                           ((pbgrf + 2)->f & 0x20) |        \
                                           ((pbgrf + 3)->f & 0x10) |        \
                                           ((pbgrf + 4)->f & 0x08) |        \
                                           ((pbgrf + 5)->f & 0x04) |        \
                                           ((pbgrf + 6)->f & 0x02) |        \
                                           ((pbgrf + 7)->f & 0x01))

//
//**************************************************************************
// 4BPP Macros
//**************************************************************************

#define _GET_4BPP_CLR_COPY_NIBBLE(pPat, b, g, r, mb, mg, mr, XM)            \
            ((BYTE)((((b-GETPAT(pPat, 0, 0)) & ExtBGR[mb]) |                \
                     ((g-GETPAT(pPat, 2, 0)) & ExtBGR[mg]) |                \
                     ((r-GETPAT(pPat, 4, 0)) & ExtBGR[mr])) >> 16) ^ (XM))

#define _GET_4BPP_CLR_COPY_BYTE(pPat, b1, g1, r1, b2, g2, r2, XM)           \
            ((BYTE)((((b1-GETPAT(pPat, 0, 0)) & ExtBGR[0]) |                \
                     ((g1-GETPAT(pPat, 2, 0)) & ExtBGR[1]) |                \
                     ((r1-GETPAT(pPat, 4, 0)) & ExtBGR[2]) |                \
                     ((b2-GETPAT(pPat, 0, 1)) & ExtBGR[3]) |                \
                     ((g2-GETPAT(pPat, 2, 1)) & ExtBGR[4]) |                \
                     ((r2-GETPAT(pPat, 4, 1)) & ExtBGR[5])) >> 16) ^ (XM))


#define GET_4BPP_CLR_COPY_HIDX(pDst, pPat, pbgrf, XorMask)                  \
{                                                                           \
    *pDst = (*pDst & 0x0F) |                                                \
             _GET_4BPP_CLR_COPY_NIBBLE(pPat,                                \
                                      _GET_B_CLR(pbgrf),                    \
                                      _GET_G_CLR(pbgrf),                    \
                                      _GET_R_CLR(pbgrf), 0, 1, 2, XorMask); \
}

#define GET_4BPP_CLR_COPY_LIDX(pDst, pPat, pbgrf, XorMask)                  \
{                                                                           \
    *pDst = (*pDst & 0xF0) |                                                \
             _GET_4BPP_CLR_COPY_NIBBLE(pPat,                                \
                                      _GET_B_CLR(pbgrf),                    \
                                      _GET_G_CLR(pbgrf),                    \
                                      _GET_R_CLR(pbgrf), 3, 4, 5, XorMask); \
}

#define GET_4BPP_CLR_COPY_BYTE(pDst, pPat, XorMask)                         \
{                                                                           \
    *pDst = _GET_4BPP_CLR_COPY_BYTE(pPat,                                   \
                                    _GET_B_CLR(pbgrf),                      \
                                    _GET_G_CLR(pbgrf),                      \
                                    _GET_R_CLR(pbgrf),                      \
                                    _GET_B_CLR(pbgrf+1),                    \
                                    _GET_G_CLR(pbgrf+1),                    \
                                    _GET_R_CLR(pbgrf+1), XorMask);          \
}


//
//**************************************************************************
// VGA16 Macros
//**************************************************************************

#define _GET_VGA16_CLR_COPY_NIBBLE(pPat, b, g, r, mb, mg, mr, XM)           \
        VGA16Xlate[((((b-GETPAT(pPat, 0, 0)) & ExtBGR[mb]) |                \
                     ((g-GETPAT(pPat, 2, 0)) & ExtBGR[mg]) |                \
                     ((r-GETPAT(pPat, 4, 0)) & ExtBGR[mr])) >> 16) ^ (XM)]

#define _GET_VGA16_CLR_COPY_BYTE(pPat, b1, g1, r1, b2, g2, r2, XM)          \
        VGA16Xlate[((((b1-GETPAT(pPat, 0, 0)) & ExtBGR[0]) |                \
                     ((g1-GETPAT(pPat, 2, 0)) & ExtBGR[1]) |                \
                     ((r1-GETPAT(pPat, 4, 0)) & ExtBGR[2]) |                \
                     ((b2-GETPAT(pPat, 0, 1)) & ExtBGR[3]) |                \
                     ((g2-GETPAT(pPat, 2, 1)) & ExtBGR[4]) |                \
                     ((r2-GETPAT(pPat, 4, 1)) & ExtBGR[5])) >> 16) ^ (XM)]


#define GET_VGA16_CLR_COPY_HIDX(pDst, pPat, pbgrf, XorMask)                 \
{                                                                           \
    *pDst = (*pDst & 0x0F) |                                                \
             _GET_VGA16_CLR_COPY_NIBBLE(pPat,                               \
                                      _GET_B_CLR(pbgrf),                    \
                                      _GET_G_CLR(pbgrf),                    \
                                      _GET_R_CLR(pbgrf), 0, 1, 2, XorMask); \
}

#define GET_VGA16_CLR_COPY_LIDX(pDst, pPat, pbgrf, XorMask)                 \
{                                                                           \
    *pDst = (*pDst & 0xF0) |                                                \
             _GET_VGA16_CLR_COPY_NIBBLE(pPat,                               \
                                      _GET_B_CLR(pbgrf),                    \
                                      _GET_G_CLR(pbgrf),                    \
                                      _GET_R_CLR(pbgrf), 3, 4, 5, XorMask); \
}

#define GET_VGA16_CLR_COPY_BYTE(pDst, pPat, XorMask)                        \
{                                                                           \
    *pDst = _GET_VGA16_CLR_COPY_BYTE(pPat,                                  \
                                    _GET_B_CLR(pbgrf),                      \
                                    _GET_G_CLR(pbgrf),                      \
                                    _GET_R_CLR(pbgrf),                      \
                                    _GET_B_CLR(pbgrf+1),                    \
                                    _GET_G_CLR(pbgrf+1),                    \
                                    _GET_R_CLR(pbgrf+1), XorMask);          \
}


//
//**************************************************************************
// VGA256 8BPP Macros
//**************************************************************************

#define GET_VGA256_IDX_CLR_XLATE(pDst, pPat, p1, p2, p3, pXlate)            \
{                                                                           \
    *pDst++ = pXlate[((((DWORD)p1 - GETPAT(pPat, 0, 0)) >>  6) & 0x1c0) |   \
                     ((((DWORD)p2 - GETPAT(pPat, 2, 0)) >>  9) & 0x038) |   \
                     ((((DWORD)p3 - GETPAT(pPat, 4, 0)) >> 12) & 0x007)];   \
}

#define _GET_VGA256_CLR_COPY_XLATE(pPat, pXlate, b, g, r)                   \
            pXlate[(((b - GETPAT(pPat, 0, 0)) & 0x1c00000) |                \
                    ((g - GETPAT(pPat, 2, 0)) & 0x0380000) |                \
                    ((r - GETPAT(pPat, 4, 0)) & 0x0070000)) >> 16]


#define GET_VGA256_CLR_COPY_XLATE(pPat, pXlate)                             \
            _GET_VGA256_CLR_COPY_XLATE(pPat, pXlate,                        \
                                       _GET_B_CLR(pbgrf),                   \
                                       _GET_G_CLR(pbgrf),                   \
                                       _GET_R_CLR(pbgrf))

#define GET_VGA256_GRAY_COPY(pPat)  (BYTE)(GET_GRAY_IDX(pbgrf, pPat, 0) >> 12)

#define GET_VGA256_GRAY_COPY_XLATE(pPat, pXlate)                            \
                                pXlate[GET_GRAY_IDX(pbgrf, pPat, 0) >> 12]


//
//**************************************************************************
// Mask 8BPP Macros
//**************************************************************************

#define GET_P8BPPXLATE(p, bm8i)                                             \
    ASSERT((bm8i).Data.pXlateIdx <= XLATE_IDX_MAX);                         \
    p = p8BPPXlate[(bm8i).Data.pXlateIdx]

#define _GET_MASK8BPP_K_332(b, g, r, pXlate)                                \
        (BYTE)((((r-PatC) & (PatC-ExtBGR[2]) & 0xe0000) |                   \
                ((g-PatM) & (PatM-ExtBGR[1]) & 0x1c000) |                   \
                ((b-PatY) & (PatY-ExtBGR[0]) & 0x03000))>>12)

#define _GET_MASK8BPP_332(pDst, pPat, b, g, r, pXlate)                      \
        *pDst = (BYTE)((((b-GETPAT(pPat,0,0))&0x030000) |                   \
                        ((g-GETPAT(pPat,2,0))&0x1C0000) |                   \
                        ((r-GETPAT(pPat,4,0))&0xE00000))>>16)

#define _GET_MASK8BPP_K_332_XLATE(b, g, r, pXlate)                          \
        (BYTE)pXlate[((((r-PatC) & (PatC-ExtBGR[2]) & 0xe0000) |            \
                       ((g-PatM) & (PatM-ExtBGR[1]) & 0x1c000) |            \
                       ((b-PatY) & (PatY-ExtBGR[0]) & 0x03000))>>12)]

#define _GET_MASK8BPP_332_XLATE(pDst, pPat, b, g, r, pXlate)                \
        *pDst = (BYTE)pXlate[((((b-GETPAT(pPat,0,0))&0x030000) |            \
                               ((g-GETPAT(pPat,2,0))&0x1C0000) |            \
                               ((r-GETPAT(pPat,4,0))&0xE00000))>>16)]

#define _GET_MASK8BPP_XLATE(pDst, pPat, b, g, r, pXlate)                    \
        *pDst = (BYTE)pXlate[((((b-GETPAT(pPat,0,0))&0x0070000) |           \
                               ((g-GETPAT(pPat,2,0))&0x0380000) |           \
                               ((r-GETPAT(pPat,4,0))&0x1c00000))>>16)]

#define _GET_MASK8BPP_K_XLATE(b, g, r, pXlate)                              \
        (BYTE)pXlate[((((r-PatC) & (PatC-ExtBGR[2]) & 0x1c0000) |           \
                       ((g-PatM) & (PatM-ExtBGR[1]) & 0x038000) |           \
                       ((b-PatY) & (PatY-ExtBGR[0]) & 0x007000)) >> 12)]


#define _GET_MASK8BPP_REP_K(pDst, pPat, b, g, r, BMACRO, pMacData)          \
{                                                                           \
    DWORD   u;                                                              \
    DWORD   PatC;                                                           \
    DWORD   PatM;                                                           \
    DWORD   PatY;                                                           \
    DWORD   irgb[4];                                                        \
    DWORD   dwDst;                                                          \
    BYTE    bDst;                                                           \
                                                                            \
    dwDst    = ((irgb[0] = r) < (irgb[1] = g)) ? 0 : 1;                     \
    irgb[2]  =                                                              \
    irgb[3]  = b;                                                           \
    dwDst   |= ((irgb[dwDst] < irgb[2]) ? 0 : 1) << 1;                      \
    u        = irgb[dwDst] >> 21;                                           \
    PatY     = (DWORD)GETPAT(pPat, 0, 0);                                   \
    PatM     = (DWORD)GETPAT(pPat, 2, 0);                                   \
    PatC     = (DWORD)GETPAT(pPat, 4, 0);                                   \
    bDst     = bm8i.Data.bBlack;                                            \
                                                                            \
    if ((u < PatC) && (u < PatM) && (u < PatY)) {                           \
                                                                            \
        bDst = BMACRO(irgb[2], irgb[1], irgb[0], pMacData);                 \
    }                                                                       \
                                                                            \
    *pDst = bDst;                                                           \
}


#define GET_MASK8BPP(pDst, pPat, bMac, pMacData)                            \
            bMac(pDst, pPat,                                                \
                 _GET_B_CLR(pbgrf), _GET_G_CLR(pbgrf),  _GET_R_CLR(pbgrf),  \
                 pMacData)

#define GET_MASK8BPP_REP_K(pDst, pPat, bMac, pMacData)                      \
            _GET_MASK8BPP_REP_K(pDst, pPat,                                 \
                                _GET_B_CLR(pbgrf),                          \
                                _GET_G_CLR(pbgrf),                          \
                                _GET_R_CLR(pbgrf),                          \
                                bMac, pMacData)

#define GET_MASK8BPP_MONO(pDst, pPat, g1, bXor)                             \
            *pDst = (BYTE)(((g1)-GETMONOPAT(pPat, 0)) >> 12) ^ (bXor)


//
//**************************************************************************
// 16BPP_555 Macros/16BPP_565
//**************************************************************************

#define _GET_16BPP_COPY_W_MASK(pPat, b, g, r, bm, gm, rm, xm)               \
            (WORD)((((((b) - GETPAT(pPat, 0, 0)) & (bm)) |                  \
                     (((g) - GETPAT(pPat, 2, 0)) & (gm)) |                  \
                     (((r) - GETPAT(pPat, 4, 0)) & (rm))) ^ (xm)) >> 16)

#define _GET_16BPP_COPY_DW_MASK(pPat, b1, g1, r1, b2, g2, r2, bm,gm,rm,xm)  \
            ((DWORD)((((((b1) - GETPAT(pPat, 0, 0)) & (bm)) |               \
                       (((g1) - GETPAT(pPat, 2, 0)) & (gm)) |               \
                       (((r1) - GETPAT(pPat, 4, 0)) & (rm))) >> 16)   |     \
                     ( (((b2) - GETPAT(pPat, 0, 1)) & (bm)) |               \
                       (((g2) - GETPAT(pPat, 2, 1)) & (gm)) |               \
                       (((r2) - GETPAT(pPat, 4, 1)) & (rm)))) ^ (xm))

#define GET_16BPP_COPY_W_MASK(pPat, bm, gm, rm, xm)                         \
            _GET_16BPP_COPY_W_MASK(pPat,                                    \
                                   _GET_B_CLR(pbgrf),                       \
                                   _GET_G_CLR(pbgrf),                       \
                                   _GET_R_CLR(pbgrf),                       \
                                   bm, gm, rm, xm)

#define GET_16BPP_COPY_DW_MASK(pPat, bm, gm, rm, xm)                        \
            _GET_16BPP_COPY_DW_MASK(pPat,                                   \
                                    _GET_B_CLR(pbgrf),                      \
                                    _GET_G_CLR(pbgrf),                      \
                                    _GET_R_CLR(pbgrf),                      \
                                    _GET_B_CLR(pbgrf + 1),                  \
                                    _GET_G_CLR(pbgrf + 1),                  \
                                    _GET_R_CLR(pbgrf + 1),                  \
                                    bm, gm, rm, xm)



//
// Functions prototype
//


VOID
HTENTRY
OutputAATo1BPP(
    PAAHEADER       pAAHdr,
    PGRAYF          pbgrf,
    PGRAYF          pInEnd,
    LPBYTE          pbDst,
    LPDWORD         pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );


VOID
HTENTRY
OutputAATo4BPP(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    LPDWORD         pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAAToVGA16(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    LPDWORD         pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

LPBYTE
HTENTRY
BuildVGA256Xlate(
    LPBYTE  pXlate,
    LPBYTE  pNewXlate
    );

VOID
HTENTRY
OutputAAToVGA256(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo8BPP_B332(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo8BPP_K_B332(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo8BPP_B332_XLATE(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo8BPP_K_B332_XLATE(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo8BPP_XLATE(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo8BPP_K_XLATE(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo8BPP_MONO(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo8BPP_MONO(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo16BPP_ExtBGR(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPWORD          pwDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo16BPP_555_RGB(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPWORD          pwDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo16BPP_555_BGR(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPWORD          pwDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo16BPP_565_RGB(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPWORD          pwDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo16BPP_565_BGR(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPWORD          pwDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo24BPP_RGB(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo24BPP_BGR(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo24BPP_ORDER(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo32BPP_RGB(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo32BPP_BGR(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo32BPP_ORDER(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

LONG
HTENTRY
CreateHalftoneBrushPat(
    PDEVICECOLORINFO    pDCI,
    PCOLORTRIAD         pColorTriad,
    PDEVCLRADJ          pDevClrAdj,
    LPBYTE              pDest,
    LONG                cbDestNext
    );


#if DBG

LPSTR
GetAAOutputFuncName(
    AAOUTPUTFUNC    AAOutputFunc
    );

#endif


#endif  // _HTSETBMP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htrender.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htrender.h


Abstract:

    This module contains halftone rendering declarations


Author:
    28-Mar-1992 Sat 20:58:50 updated  -by-  Daniel Chou (danielc)
        Update for VGA16 support, so it intenally compute at 4 primaries.

    22-Jan-1991 Tue 12:46:48 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:


--*/



#ifndef _HTRENDER_
#define _HTRENDER_




#define GET_PHTSI_CXSIZE(pHTSI)     (pHTSI->ScanLineDelta)


#define VALIDATE_HTSI_SRC           0
#define VALIDATE_HTSI_DEST          1
#define VALIDATE_HTSI_MASK          2



//
// Function prototypes
//


BOOL
HTENTRY
ValidateRGBBitFields(
    PBFINFO pBFInfo
    );

LONG
HTENTRY
ValidateHTSI(
    PHALFTONERENDER pHR,
    UINT            ValidateMode
    );

LONG
HTENTRY
ComputeBytesPerScanLine(
    UINT            SurfaceFormat,
    UINT            AlignmentBytes,
    DWORD           WidthInPel
    );

BOOL
HTENTRY
IntersectRECTL(
    PRECTL  prclA,
    PRECTL  prclB
    );

LONG
HTENTRY
ComputeByteOffset(
    UINT    SurfaceFormat,
    LONG    xLeft,
    LPBYTE  pPixelInByteSkip
    );

LONG
HTENTRY
AAHalftoneBitmap(
    PHALFTONERENDER pHR
    );


#endif  // _HTRENDER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htsetbmp.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htsetbmp.c


Abstract:

    This module is used to provide set of functions to set the bits into the
    final destination bitmap.


Author:
    11-Nov-1998 Wed 09:27:34 updated  -by-  Daniel Chou (danielc)
        Re-write for anti-aliasing

    28-Mar-1992 Sat 20:59:29 updated  -by-  Daniel Chou (danielc)
        Add Support for VGA16, and also make output only 1 destinaiton pointer
        for 3 planer.


    03-Apr-1991 Wed 10:28:50 created  -by-  Daniel Chou (danielc)


[Environment:]

    Printer Driver.


[Notes:]


Revision History:

    11-Jan-1999 Mon 16:07:37 updated  -by-  Daniel Chou (danielc)
        re-structure



--*/


#define DBGP_VARNAME        dbgpHTSetBmp

#include "htp.h"
#include "htmapclr.h"
#include "htrender.h"
#include "htpat.h"
#include "htdebug.h"
#include "htalias.h"
#include "htstret.h"
#include "htsetbmp.h"


#define DBGP_VGA256XLATE        0x00000001
#define DBGP_BRUSH              0x00000002


DEF_DBGPVAR(BIT_IF(DBGP_VGA256XLATE,    0)  |
            BIT_IF(DBGP_BRUSH,          0))


CONST BYTE VGA16Xlate[120] = {

        0xff,0xfe,0xfd,0xfc,0xfb,0xfa,0xf9,0xf0,
        0xff,0xfe,0xfd,0xfc,0xfb,0xfa,0xf9,0xf8,
        0xef,0xee,0xed,0xec,0xeb,0xea,0xe9,0xe0,
        0xef,0xee,0xed,0xec,0xeb,0xea,0xe9,0xe8,
        0xdf,0xde,0xdd,0xdc,0xdb,0xda,0xd9,0xd0,
        0xdf,0xde,0xdd,0xdc,0xdb,0xda,0xd9,0xd8,
        0xcf,0xce,0xcd,0xcc,0xcb,0xca,0xc9,0xc0,
        0xcf,0xce,0xcd,0xcc,0xcb,0xca,0xc9,0xc8,
        0xbf,0xbe,0xbd,0xbc,0xbb,0xba,0xb9,0xb0,
        0xbf,0xbe,0xbd,0xbc,0xbb,0xba,0xb9,0xb8,
        0xaf,0xae,0xad,0xac,0xab,0xaa,0xa9,0xa0,
        0xaf,0xae,0xad,0xac,0xab,0xaa,0xa9,0xa8,
        0x9f,0x9e,0x9d,0x9c,0x9b,0x9a,0x99,0x90,
        0x9f,0x9e,0x9d,0x9c,0x9b,0x9a,0x99,0x98,
        0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x00 
    };

//
// Xlate table has 3 bits for each of C=6-8, M=3-5, Y=0-2
//
// For 5:5:5,  1 0010 0100 = 0x124 = 0-292  (293 Entries)
// for 6:6:6,  1 0110 1101 = 0x169 = 0-365  (366 Entries)
//

CONST BYTE VGA256Xlate[SIZE_XLATE_666] = {

        215,214,213,212,211,210,210,210,209,208,207,206,205,204,204,204,
        203,202,201,200,199,198,198,198,197,196,195,194,193,192,192,192,
        191,190,189,188,187,186,186,186,185,184,183,182,181,180,180,180,
        185,184,183,182,181,180,180,180,185,184,183,182,181,180,180,180,
        179,178,177,176,175,174,174,174,173,172,171,170,169,168,168,168,
        167,166,165,164,163,162,162,162,161,160,159,158,157,156,156,156,
        155,154,153,152,151,150,150,150,149,148,147,146,145,144,144,144,
        149,148,147,146,145,144,144,144,149,148,147,146,145,144,144,144,
        143,142,141,140,139,138,138,138,137,136,135,134,133,132,132,132,
        131,130,129,128,127,126,126,126,125,124,123,122,121,120,120,120,
        119,118,117,116,115,114,114,114,113,112,111,110,109,108,108,108,
        113,112,111,110,109,108,108,108,113,112,111,110,109,108,108,108,
        107,106,105,104,103,102,102,102,101,100, 99, 98, 97, 96, 96, 96,
         95, 94, 93, 92, 91, 90, 90, 90, 89, 88, 87, 86, 85, 84, 84, 84,
         83, 82, 81, 80, 79, 78, 78, 78, 77, 76, 75, 74, 73, 72, 72, 72,
         77, 76, 75, 74, 73, 72, 72, 72, 77, 76, 75, 74, 73, 72, 72, 72,
         71, 70, 69, 68, 67, 66, 66, 66, 65, 64, 63, 62, 61, 60, 60, 60,
         59, 58, 57, 56, 55, 54, 54, 54, 53, 52, 51, 50, 49, 48, 48, 48,
         47, 46, 45, 44, 43, 42, 42, 42, 41, 40, 39, 38, 37, 36, 36, 36,
         41, 40, 39, 38, 37, 36, 36, 36, 41, 40, 39, 38, 37, 36, 36, 36,
         35, 34, 33, 32, 31, 30, 30, 30, 29, 28, 27, 26, 25, 24, 24, 24,
         23, 22, 21, 20, 19, 18, 18, 18, 17, 16, 15, 14, 13, 12, 12, 12,
         11, 10,  9,  8,  7,  6,  6,  6,  5,  4,  3,  2,  1,  0
    };


CONST BYTE CMY555Xlate[SIZE_XLATE_555] = {

          0,  1,  2,  3,  4,  4,  4,  4,  5,  6,  7,  8,  9,  9,  9,  9,
         10, 11, 12, 13, 14, 14, 14, 14, 15, 16, 17, 18, 19, 19, 19, 19,
         20, 21, 22, 23, 24, 24, 24, 24, 20, 21, 22, 23, 24, 24, 24, 24,
         20, 21, 22, 23, 24, 24, 24, 24, 20, 21, 22, 23, 24, 24, 24, 24,
         25, 26, 27, 28, 29, 29, 29, 29, 30, 31, 32, 33, 34, 34, 34, 34,
         35, 36, 37, 38, 39, 39, 39, 39, 40, 41, 42, 43, 44, 44, 44, 44,
         45, 46, 47, 48, 49, 49, 49, 49, 45, 46, 47, 48, 49, 49, 49, 49,
         45, 46, 47, 48, 49, 49, 49, 49, 45, 46, 47, 48, 49, 49, 49, 49,
         50, 51, 52, 53, 54, 54, 54, 54, 55, 56, 57, 58, 59, 59, 59, 59,
         60, 61, 62, 63, 64, 64, 64, 64, 65, 66, 67, 68, 69, 69, 69, 69,
         70, 71, 72, 73, 74, 74, 74, 74, 70, 71, 72, 73, 74, 74, 74, 74,
         70, 71, 72, 73, 74, 74, 74, 74, 70, 71, 72, 73, 74, 74, 74, 74,
         75, 76, 77, 78, 79, 79, 79, 79, 80, 81, 82, 83, 84, 84, 84, 84,
         85, 86, 87, 88, 89, 89, 89, 89, 90, 91, 92, 93, 94, 94, 94, 94,
         95, 96, 97, 98, 99, 99, 99, 99, 95, 96, 97, 98, 99, 99, 99, 99,
         95, 96, 97, 98, 99, 99, 99, 99, 95, 96, 97, 98, 99, 99, 99, 99,
        100,101,102,103,104,104,104,104,105,106,107,108,109,109,109,109,
        110,111,112,113,114,114,114,114,115,116,117,118,119,119,119,119,
        120,121,122,123,124
    };

CONST BYTE RGB555Xlate[SIZE_XLATE_555] = {

        190,189,188,187,186,186,186,186,185,184,183,182,181,181,181,181,
        180,179,178,177,176,176,176,176,175,174,173,172,171,171,171,171,
        170,169,168,167,166,166,166,166,170,169,168,167,166,166,166,166,
        170,169,168,167,166,166,166,166,170,169,168,167,166,166,166,166,
        165,164,163,162,161,161,161,161,160,159,158,157,156,156,156,156,
        155,154,153,152,151,151,151,151,150,149,148,147,146,146,146,146,
        145,144,143,142,141,141,141,141,145,144,143,142,141,141,141,141,
        145,144,143,142,141,141,141,141,145,144,143,142,141,141,141,141,
        140,139,138,137,136,136,136,136,135,134,133,132,131,131,131,131,
        130,129,127,126,125,125,125,125,124,123,122,121,120,120,120,120,
        119,118,117,116,115,115,115,115,119,118,117,116,115,115,115,115,
        119,118,117,116,115,115,115,115,119,118,117,116,115,115,115,115,
        114,113,112,111,110,110,110,110,109,108,107,106,105,105,105,105,
        104,103,102,101,100,100,100,100, 99, 98, 97, 96, 95, 95, 95, 95,
         94, 93, 92, 91, 90, 90, 90, 90, 94, 93, 92, 91, 90, 90, 90, 90,
         94, 93, 92, 91, 90, 90, 90, 90, 94, 93, 92, 91, 90, 90, 90, 90,
         89, 88, 87, 86, 85, 85, 85, 85, 84, 83, 82, 81, 80, 80, 80, 80,
         79, 78, 77, 76, 75, 75, 75, 75, 74, 73, 72, 71, 70, 70, 70, 70,
         69, 68, 67, 66, 65 
    };

CONST BYTE CMY666Xlate[SIZE_XLATE_666] = {

          0,  1,  2,  3,  4,  5,  5,  5,  6,  7,  8,  9, 10, 11, 11, 11,
         12, 13, 14, 15, 16, 17, 17, 17, 18, 19, 20, 21, 22, 23, 23, 23,
         24, 25, 26, 27, 28, 29, 29, 29, 30, 31, 32, 33, 34, 35, 35, 35,
         30, 31, 32, 33, 34, 35, 35, 35, 30, 31, 32, 33, 34, 35, 35, 35,
         36, 37, 38, 39, 40, 41, 41, 41, 42, 43, 44, 45, 46, 47, 47, 47,
         48, 49, 50, 51, 52, 53, 53, 53, 54, 55, 56, 57, 58, 59, 59, 59,
         60, 61, 62, 63, 64, 65, 65, 65, 66, 67, 68, 69, 70, 71, 71, 71,
         66, 67, 68, 69, 70, 71, 71, 71, 66, 67, 68, 69, 70, 71, 71, 71,
         72, 73, 74, 75, 76, 77, 77, 77, 78, 79, 80, 81, 82, 83, 83, 83,
         84, 85, 86, 87, 88, 89, 89, 89, 90, 91, 92, 93, 94, 95, 95, 95,
         96, 97, 98, 99,100,101,101,101,102,103,104,105,106,107,107,107,
        102,103,104,105,106,107,107,107,102,103,104,105,106,107,107,107,
        108,109,110,111,112,113,113,113,114,115,116,117,118,119,119,119,
        120,121,122,123,124,125,125,125,126,127,128,129,130,131,131,131,
        132,133,134,135,136,137,137,137,138,139,140,141,142,143,143,143,
        138,139,140,141,142,143,143,143,138,139,140,141,142,143,143,143,
        144,145,146,147,148,149,149,149,150,151,152,153,154,155,155,155,
        156,157,158,159,160,161,161,161,162,163,164,165,166,167,167,167,
        168,169,170,171,172,173,173,173,174,175,176,177,178,179,179,179,
        174,175,176,177,178,179,179,179,174,175,176,177,178,179,179,179,
        180,181,182,183,184,185,185,185,186,187,188,189,190,191,191,191,
        192,193,194,195,196,197,197,197,198,199,200,201,202,203,203,203,
        204,205,206,207,208,209,209,209,210,211,212,213,214,215
    };



CONST BYTE RGB666Xlate[SIZE_XLATE_666] = {

        235,234,233,232,231,230,230,230,229,228,227,226,225,224,224,224,
        223,222,221,220,219,218,218,218,217,216,215,214,213,212,212,212,
        211,210,209,208,207,206,206,206,205,204,203,202,201,200,200,200,
        205,204,203,202,201,200,200,200,205,204,203,202,201,200,200,200,
        199,198,197,196,195,194,194,194,193,192,191,190,189,188,188,188,
        187,186,185,184,183,182,182,182,181,180,179,178,177,176,176,176,
        175,174,173,172,171,170,170,170,169,168,167,166,165,164,164,164,
        169,168,167,166,165,164,164,164,169,168,167,166,165,164,164,164,
        163,162,161,160,159,158,158,158,157,156,155,154,153,152,152,152,
        151,150,149,148,147,146,146,146,145,144,143,142,141,140,140,140,
        139,138,137,136,135,134,134,134,133,132,131,130,129,128,128,128,
        133,132,131,130,129,128,128,128,133,132,131,130,129,128,128,128,
        127,126,125,124,123,122,122,122,121,120,119,118,117,116,116,116,
        115,114,113,112,111,110,110,110,109,108,107,106,105,104,104,104,
        103,102,101,100, 99, 98, 98, 98, 97, 96, 95, 94, 93, 92, 92, 92,
         97, 96, 95, 94, 93, 92, 92, 92, 97, 96, 95, 94, 93, 92, 92, 92,
         91, 90, 89, 88, 87, 86, 86, 86, 85, 84, 83, 82, 81, 80, 80, 80,
         79, 78, 77, 76, 75, 74, 74, 74, 73, 72, 71, 70, 69, 68, 68, 68,
         67, 66, 65, 64, 63, 62, 62, 62, 61, 60, 59, 58, 57, 56, 56, 56,
         61, 60, 59, 58, 57, 56, 56, 56, 61, 60, 59, 58, 57, 56, 56, 56,
         55, 54, 53, 52, 51, 50, 50, 50, 49, 48, 47, 46, 45, 44, 44, 44,
         43, 42, 41, 40, 39, 38, 38, 38, 37, 36, 35, 34, 33, 32, 32, 32,
         31, 30, 29, 28, 27, 26, 26, 26, 25, 24, 23, 22, 21, 20 
    };

CONST LPBYTE  p8BPPXlate[] = { (LPBYTE)CMY555Xlate,           // 00
                               (LPBYTE)CMY666Xlate,           // 01
                               (LPBYTE)RGB555Xlate,           // 10
                               (LPBYTE)RGB666Xlate };         // 11



CONST DWORD dwGrayIdxHB[] = {

    0x0ff010,0x0fe020,0x0fd030,0x0fc040,0x0fb050,0x0fa060,0x0f9070,0x0f8080,
    0x0f7090,0x0f60a0,0x0f50b0,0x0f40c0,0x0f30d0,0x0f20e0,0x0f10f0,0x0f0100,
    0x0ef110,0x0ee120,0x0ed130,0x0ec140,0x0eb150,0x0ea160,0x0e9170,0x0e8180,
    0x0e7190,0x0e61a0,0x0e51b0,0x0e41c0,0x0e31d0,0x0e21e0,0x0e11f0,0x0e0200,
    0x0df210,0x0de220,0x0dd230,0x0dc240,0x0db250,0x0da260,0x0d9270,0x0d8280,
    0x0d7290,0x0d62a0,0x0d52b0,0x0d42c0,0x0d32d0,0x0d22e0,0x0d12f0,0x0d0300,
    0x0cf310,0x0ce320,0x0cd330,0x0cc340,0x0cb350,0x0ca360,0x0c9370,0x0c8380,
    0x0c7390,0x0c63a0,0x0c53b0,0x0c43c0,0x0c33d0,0x0c23e0,0x0c13f0,0x0c0400,
    0x0bf410,0x0be420,0x0bd430,0x0bc440,0x0bb450,0x0ba460,0x0b9470,0x0b8480,
    0x0b7490,0x0b64a0,0x0b54b0,0x0b44c0,0x0b34d0,0x0b24e0,0x0b14f0,0x0b0500,
    0x0af510,0x0ae520,0x0ad530,0x0ac540,0x0ab550,0x0aa560,0x0a9570,0x0a8580,
    0x0a7590,0x0a65a0,0x0a55b0,0x0a45c0,0x0a35d0,0x0a25e0,0x0a15f0,0x0a0600,
    0x09f610,0x09e620,0x09d630,0x09c640,0x09b650,0x09a660,0x099670,0x098680,
    0x097690,0x0966a0,0x0956b0,0x0946c0,0x0936d0,0x0926e0,0x0916f0,0x090700,
    0x08f710,0x08e720,0x08d730,0x08c740,0x08b750,0x08a760,0x089770,0x088780,
    0x087790,0x0867a0,0x0857b0,0x0847c0,0x0837d0,0x0827e0,0x0817f0,0x080800,
    0x07f810,0x07e820,0x07d830,0x07c840,0x07b850,0x07a860,0x079870,0x078880,
    0x077890,0x0768a0,0x0758b0,0x0748c0,0x0738d0,0x0728e0,0x0718f0,0x070900,
    0x06f910,0x06e920,0x06d930,0x06c940,0x06b950,0x06a960,0x069970,0x068980,
    0x067990,0x0669a0,0x0659b0,0x0649c0,0x0639d0,0x0629e0,0x0619f0,0x060a00,
    0x05fa10,0x05ea20,0x05da30,0x05ca40,0x05ba50,0x05aa60,0x059a70,0x058a80,
    0x057a90,0x056aa0,0x055ab0,0x054ac0,0x053ad0,0x052ae0,0x051af0,0x050b00,
    0x04fb10,0x04eb20,0x04db30,0x04cb40,0x04bb50,0x04ab60,0x049b70,0x048b80,
    0x047b90,0x046ba0,0x045bb0,0x044bc0,0x043bd0,0x042be0,0x041bf0,0x040c00,
    0x03fc10,0x03ec20,0x03dc30,0x03cc40,0x03bc50,0x03ac60,0x039c70,0x038c80,
    0x037c90,0x036ca0,0x035cb0,0x034cc0,0x033cd0,0x032ce0,0x031cf0,0x030d00,
    0x02fd10,0x02ed20,0x02dd30,0x02cd40,0x02bd50,0x02ad60,0x029d70,0x028d80,
    0x027d90,0x026da0,0x025db0,0x024dc0,0x023dd0,0x022de0,0x021df0,0x020e00,
    0x01fe10,0x01ee20,0x01de30,0x01ce40,0x01be50,0x01ae60,0x019e70,0x018e80,
    0x017e90,0x016ea0,0x015eb0,0x014ec0,0x013ed0,0x012ee0,0x011ef0,0x010f00,
    0x00ff10,0x00ef20,0x00df30,0x00cf40,0x00bf50,0x00af60,0x009f70,0x008f80,
    0x007f90,0x006fa0,0x005fb0,0x004fc0,0x003fd0,0x002fe0,0x001ff0,0x001000 
    };

CONST WORD wGrayIdxLB[] = {

    0x0fef,0x0fdf,0x0fcf,0x0fbf,0x0faf,0x0f9f,0x0f8f,0x0f7f,
    0x0f6f,0x0f5f,0x0f4f,0x0f3f,0x0f2f,0x0f1f,0x0f0f,0x0eff,
    0x0eef,0x0edf,0x0ecf,0x0ebf,0x0eaf,0x0e9f,0x0e8f,0x0e7f,
    0x0e6f,0x0e5f,0x0e4f,0x0e3f,0x0e2f,0x0e1f,0x0e0f,0x0dff,
    0x0def,0x0ddf,0x0dcf,0x0dbf,0x0daf,0x0d9f,0x0d8f,0x0d7f,
    0x0d6f,0x0d5f,0x0d4f,0x0d3f,0x0d2f,0x0d1f,0x0d0f,0x0cff,
    0x0cef,0x0cdf,0x0ccf,0x0cbf,0x0caf,0x0c9f,0x0c8f,0x0c7f,
    0x0c6f,0x0c5f,0x0c4f,0x0c3f,0x0c2f,0x0c1f,0x0c0f,0x0bff,
    0x0bef,0x0bdf,0x0bcf,0x0bbf,0x0baf,0x0b9f,0x0b8f,0x0b7f,
    0x0b6f,0x0b5f,0x0b4f,0x0b3f,0x0b2f,0x0b1f,0x0b0f,0x0aff,
    0x0aef,0x0adf,0x0acf,0x0abf,0x0aaf,0x0a9f,0x0a8f,0x0a7f,
    0x0a6f,0x0a5f,0x0a4f,0x0a3f,0x0a2f,0x0a1f,0x0a0f,0x09ff,
    0x09ef,0x09df,0x09cf,0x09bf,0x09af,0x099f,0x098f,0x097f,
    0x096f,0x095f,0x094f,0x093f,0x092f,0x091f,0x090f,0x08ff,
    0x08ef,0x08df,0x08cf,0x08bf,0x08af,0x089f,0x088f,0x087f,
    0x086f,0x085f,0x084f,0x083f,0x082f,0x081f,0x080f,0x07ff,
    0x07f0,0x07e0,0x07d0,0x07c0,0x07b0,0x07a0,0x0790,0x0780,
    0x0770,0x0760,0x0750,0x0740,0x0730,0x0720,0x0710,0x0700,
    0x06f0,0x06e0,0x06d0,0x06c0,0x06b0,0x06a0,0x0690,0x0680,
    0x0670,0x0660,0x0650,0x0640,0x0630,0x0620,0x0610,0x0600,
    0x05f0,0x05e0,0x05d0,0x05c0,0x05b0,0x05a0,0x0590,0x0580,
    0x0570,0x0560,0x0550,0x0540,0x0530,0x0520,0x0510,0x0500,
    0x04f0,0x04e0,0x04d0,0x04c0,0x04b0,0x04a0,0x0490,0x0480,
    0x0470,0x0460,0x0450,0x0440,0x0430,0x0420,0x0410,0x0400,
    0x03f0,0x03e0,0x03d0,0x03c0,0x03b0,0x03a0,0x0390,0x0380,
    0x0370,0x0360,0x0350,0x0340,0x0330,0x0320,0x0310,0x0300,
    0x02f0,0x02e0,0x02d0,0x02c0,0x02b0,0x02a0,0x0290,0x0280,
    0x0270,0x0260,0x0250,0x0240,0x0230,0x0220,0x0210,0x0200,
    0x01f0,0x01e0,0x01d0,0x01c0,0x01b0,0x01a0,0x0190,0x0180,
    0x0170,0x0160,0x0150,0x0140,0x0130,0x0120,0x0110,0x0100,
    0x00f0,0x00e0,0x00d0,0x00c0,0x00b0,0x00a0,0x0090,0x0080,
    0x0070,0x0060,0x0050,0x0040,0x0030,0x0020,0x0010,0x0000
    };


extern CONST WORD GrayIdxWORD[];

#define GRAY_W2DW(l, h)         (dwGrayIdxHB[h] + (DWORD)wGrayIdxLB[l])

#define PBGRF_2_GRAYDW(pbgrf)   GRAY_W2DW((pbgrf)->b, (pbgrf)->g)



//
//**************************************************************************
// Monochrome 1BPP Output Functions
//**************************************************************************


VOID
HTENTRY
OutputAATo1BPP(
    PAAHEADER       pAAHdr,
    PGRAYF          pbgrf,
    PGRAYF          pInEnd,
    LPBYTE          pbDst,
    LPDWORD         pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    UINT    Loop;
    DW2W4B  Dst;

#define XorMask (AAOutputInfo.bm.XorMask)


    if (Loop = (UINT)AAOutputInfo.bm.cFirst) {

        Dst.dw = 0;

        while (Loop--) {

            Dst.b[0] = (++pbgrf)->f;
            Dst.dw   = GRAY_1BPP_COPY(pbPat, 0x010000) | (Dst.dw << 1);

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
        }

        //
        // Dst.b[1] = Destination mask (1) for wanted bits
        // Dst.b[2] = Destination bits
        //
        // Shift left for LeftShift is in case that we only have 1 byte and
        // the last bit not at bit 0
        //

        Dst.b[0]   = 0;
        Dst.dw   <<= AAOutputInfo.bm.LSFirst;
        *pbDst++   = (*pbDst & ~Dst.b[1]) | ((Dst.b[2] ^ XorMask) & Dst.b[1]);
    }

    pbgrf -= 7;

    if (pAAHdr->Flags & AAHF_HAS_MASK) {

#if defined(_X86_)

        _asm {

                cld
                mov     ebx, pbgrf
                mov     esi, pbPat
                mov     edi, pbDst
                mov     ecx, pbPatEnd
                mov     ch, XorMask
BYTELoopMask:
                add     ebx, 32
                cmp     ebx, pInEnd
                jae     DoneLoopMask

                xor     ax, ax
                cmp     BYTE PTR [ebx + 3], 0
                jz      BIT1
                or      ah, 0x80
                mov     dx, WORD PTR [ebx + 0]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  0]
BIT1:
                rcl     al, 1
                cmp     BYTE PTR [ebx + 4 + 3], 0
                jz      BIT2
                or      ah, 0x40
                mov     dx, WORD PTR [ebx + 4]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  6]
BIT2:
                rcl     al, 1
                cmp     BYTE PTR [ebx + 8 + 3], 0
                jz      BIT3
                or      ah, 0x20
                mov     dx, WORD PTR [ebx + 8]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  12]
BIT3:
                rcl     al, 1
                cmp     BYTE PTR [ebx + 12 + 3], 0
                jz      BIT4
                or      ah, 0x10
                mov     dx, WORD PTR [ebx + 12]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  18]
BIT4:
                rcl     al, 1
                cmp     BYTE PTR [ebx + 16 + 3], 0
                jz      BIT5
                or      ah, 0x08
                mov     dx, WORD PTR [ebx + 16]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  24]
BIT5:
                rcl     al, 1
                cmp     BYTE PTR [ebx + 20 + 3], 0
                jz      BIT6
                or      ah, 0x04
                mov     dx, WORD PTR [ebx + 20]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  30]
BIT6:
                rcl     al, 1
                cmp     BYTE PTR [ebx + 24 + 3], 0
                jz      BIT7
                or      ah, 0x02
                mov     dx, WORD PTR [ebx + 24]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  36]
BIT7:
                rcl     al, 1
                cmp     BYTE PTR [ebx + 28 + 3], 0
                jz      BIT8
                or      ah, 0x01
                mov     dx, WORD PTR [ebx + 28]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  42]
BIT8:
                rcl     al, 1
                xor     al, ch                      ;; do xor mask
                and     al, ah                      ;; mask out src 0 bits
                not     ah                          ;; invert
                and     BYTE PTR [edi], ah          ;; mask out dst 0 bits
                or      BYTE PTR [edi], al
                inc     edi
                add     esi, 48
                cmp     esi, pbPatEnd
                jb      BYTELoopMask
                add     esi, cbWrapBGR
                jmp     BYTELoopMask
DoneLoopMask:
                mov     pbgrf, ebx
                mov     pbPat, esi
                mov     pbDst, edi
        }
#else
        while ((pbgrf += 8) < pInEnd) {

            Dst.b[0] = GET_1BPP_MASK_BYTE(pbgrf);
            *pbDst++ = (*pbDst & ~Dst.b[0]) |
                       ((GRAY_1BPP_COPY_BYTE(pbPat) ^ XorMask) & Dst.b[0]);

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, (SIZE_PER_PAT * 8), cbWrapBGR);
        }
#endif

    } else {

#if defined(_X86_)

        _asm {

                cld
                mov     ebx, pbgrf
                mov     esi, pbPat
                mov     edi, pbDst
                mov     ecx, pbPatEnd
                mov     ah, XorMask
BYTELoop:
                add     ebx, 32
                cmp     ebx, pInEnd
                jae     DoneLoop

                xor     al, al
                mov     dx, WORD PTR [ebx + 0]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  0]
                rcl     al, 1

                mov     dx, WORD PTR [ebx + 4]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  6]
                rcl     al, 1

                mov     dx, WORD PTR [ebx + 8]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  12]
                rcl     al, 1

                mov     dx, WORD PTR [ebx + 12]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  18]
                rcl     al, 1

                mov     dx, WORD PTR [ebx + 16]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  24]
                rcl     al, 1

                mov     dx, WORD PTR [ebx + 20]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  30]
                rcl     al, 1

                mov     dx, WORD PTR [ebx + 24]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  36]
                rcl     al, 1

                mov     dx, WORD PTR [ebx + 28]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  42]
                rcl     al, 1

                xor     al, ah
                stosb
                add     esi, 48
                cmp     esi, ecx
                jb      BYTELoop
                add     esi, cbWrapBGR
                jmp     BYTELoop
DoneLoop:
                mov     pbgrf, ebx
                mov     pbPat, esi
                mov     pbDst, edi
        }
#else
        while ((pbgrf += 8) < pInEnd) {

            *pbDst++ = GRAY_1BPP_COPY_BYTE(pbPat) ^ XorMask;

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, (SIZE_PER_PAT * 8), cbWrapBGR);
        }
#endif
    }

    if (Loop = (UINT)AAOutputInfo.bm.cLast) {

        Dst.dw                 = 0;
        AAOutputInfo.bm.LSFirst = (BYTE)(8 - Loop);

        while (Loop--) {

            Dst.b[0] = pbgrf->f;
            Dst.dw   = GRAY_1BPP_COPY(pbPat, 0x010000) | (Dst.dw << 1);

            ++pbgrf;

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
        }

        //
        // Dst.b[1] = Destination mask (1) for wanted bits
        // Dst.b[2] = Destination bits
        //
        // Shift left for (LeftShift) is for the last un-make bits
        //

        Dst.b[0]   = 0;
        Dst.dw   <<= AAOutputInfo.bm.LSFirst;
        *pbDst     = (*pbDst & ~Dst.b[1]) | ((Dst.b[2] ^ XorMask) & Dst.b[1]);
    }

#undef XorMask
}


//
//**************************************************************************
// Standard 4BPP (RGB/CMY) Output Functions
//**************************************************************************


VOID
HTENTRY
OutputAATo4BPP(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    LPDWORD         pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    DW2W4B  dw4b;
    DEF_COPY_LUTAAHDR;


    dw4b.dw = 0;

    if (AAOutputInfo.bm.XorMask) {

        dw4b.dw = 0x77700777;
    }

    if (AAOutputInfo.bm.cFirst) {

        if (PBGRF_HAS_MASK(++pbgrf)) {

            GET_4BPP_CLR_COPY_LIDX(pbDst, pbPat, pbgrf, dw4b.b[1]);
        }

        ++pbDst;

        PPAT_NEXT(pbPat, pbPatEnd, cbWrapBGR);
    }

    --pbgrf;

    if (pAAHdr->Flags & AAHF_HAS_MASK) {

        while ((pbgrf += 2) < pInEnd) {

            switch (((pbgrf->f) & 0x02) | ((pbgrf + 1)->f & 0x01)) {

            case 0:

                break;

            case 1:

                GET_4BPP_CLR_COPY_LIDX(pbDst, pbPat, pbgrf + 1, dw4b.b[1]);
                break;

            case 2:

                GET_4BPP_CLR_COPY_HIDX(pbDst, pbPat, pbgrf, dw4b.b[2]);
                break;

            case 3:
            default:

                GET_4BPP_CLR_COPY_BYTE(pbDst, pbPat, dw4b.b[0]);
                break;
            }

            ++pbDst;

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT*2, cbWrapBGR);
        }

    } else {

        while ((pbgrf += 2) < pInEnd) {

            GET_4BPP_CLR_COPY_BYTE(pbDst++, pbPat, dw4b.b[0]);

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT*2, cbWrapBGR);
        }
    }

    if ((AAOutputInfo.bm.cLast) && (PBGRF_HAS_MASK(pbgrf))) {

        GET_4BPP_CLR_COPY_HIDX(pbDst, pbPat, pbgrf, dw4b.b[2]);
    }
}

//
//**************************************************************************
// VGA16 4BPP Output Functions
//**************************************************************************


VOID
HTENTRY
OutputAAToVGA16(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    LPDWORD         pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    DW2W4B  dw4b;
    DEF_COPY_LUTAAHDR;


    dw4b.dw = 0;

    if (AAOutputInfo.bm.cFirst) {

        if (PBGRF_HAS_MASK(++pbgrf)) {

            GET_VGA16_CLR_COPY_LIDX(pbDst, pbPat, pbgrf, 0x07);
        }

        ++pbDst;

        PPAT_NEXT(pbPat, pbPatEnd, cbWrapBGR);
    }

    --pbgrf;

    if (pAAHdr->Flags & AAHF_HAS_MASK) {

        while ((pbgrf += 2) < pInEnd) {

            switch (((pbgrf->f) & 0x02) | ((pbgrf + 1)->f & 0x01)) {

            case 0:

                break;

            case 1:

                GET_VGA16_CLR_COPY_LIDX(pbDst, pbPat, pbgrf + 1, 0x07);
                break;

            case 2:

                GET_VGA16_CLR_COPY_HIDX(pbDst, pbPat, pbgrf, 0x70);
                break;

            case 3:
            default:

                GET_VGA16_CLR_COPY_BYTE(pbDst, pbPat, 0x77);
                break;
            }

            ++pbDst;

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT*2, cbWrapBGR);
        }

    } else {

        while ((pbgrf += 2) < pInEnd) {

            GET_VGA16_CLR_COPY_BYTE(pbDst++, pbPat, 0x77);

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT*2, cbWrapBGR);
        }
    }

    if ((AAOutputInfo.bm.cLast) && (PBGRF_HAS_MASK(pbgrf))) {

        GET_VGA16_CLR_COPY_HIDX(pbDst, pbPat, pbgrf, 0x70);
    }
}


//
//**************************************************************************
// VGA 256 8BPP Output Functions
//**************************************************************************



LPBYTE
HTENTRY
BuildVGA256Xlate(
    LPBYTE  pXlate,
    LPBYTE  pNewXlate
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    13-May-1998 Wed 14:02:56 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{

    if (pXlate) {

        UINT    i;
        LPBYTE  pVGA256Xlate;
        LPBYTE  pRet;

        ASSERTMSG("Has pXlate8BPP but buffer is NULL", pNewXlate);

        DBGP_IF(DBGP_VGA256XLATE, DBGP("Build New Xlate 256"));

        if (pRet = pNewXlate) {

            pVGA256Xlate = (LPBYTE)VGA256Xlate;
            i            = sizeof(VGA256Xlate);

            while (i--) {

                DBGP_IF(DBGP_VGA256XLATE,
                        DBGP("Xlate8BPP (%3ld) ---> %3ld --> %3ld"
                            ARGDW(i) ARGDW(pXlate[i])
                            ARGDW(pXlate[*pVGA256Xlate])));

                *pNewXlate++ = pXlate[*pVGA256Xlate++];
            }
        }

        return(pRet);

    } else {

        ASSERTMSG("No pXlate8BPP but buffer is Not NULL", pNewXlate==NULL);
        DBGP_IF(DBGP_VGA256XLATE, DBGP("Use Default VGA256Xlate"));

        return((LPBYTE)VGA256Xlate);
    }
}



VOID
HTENTRY
OutputAAToVGA256(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    if (pAAHdr->Flags & AAHF_HAS_MASK) {

        while (++pbgrf < pInEnd) {

            if (PBGRF_HAS_MASK(pbgrf)) {

                *pbDst = GET_VGA256_CLR_COPY_XLATE(pbPat,
                                                   AAOutputInfo.pXlate8BPP);
            }

            ++pbDst;

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
        }

    } else {

        while (++pbgrf < pInEnd) {

            *pbDst++ = GET_VGA256_CLR_COPY_XLATE(pbPat,
                                                 AAOutputInfo.pXlate8BPP);
            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
        }
    }
}


//
//**************************************************************************
// Mask 8BPP Output Functions
//**************************************************************************

#define bm8i    (*(PBM8BPPINFO)&ExtBGR[3])


VOID
HTENTRY
OutputAATo8BPP_B332(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    DEF_COPY_LUTAAHDR;


    while (++pbgrf < pInEnd) {

        if (PBGRF_HAS_MASK(pbgrf)) {

            GET_MASK8BPP(pbDst,
                         pbPat,
                         _GET_MASK8BPP_332,
                         NULL);
        }

        ++pbDst;

        PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
    }
}



VOID
HTENTRY
OutputAATo8BPP_K_B332(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    DEF_COPY_LUTAAHDR;


    while (++pbgrf < pInEnd) {

        if (PBGRF_HAS_MASK(pbgrf)) {

            GET_MASK8BPP_REP_K(pbDst,
                               pbPat,
                               _GET_MASK8BPP_K_332,
                               NULL);
        }

        ++pbDst;

        PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
    }

}



VOID
HTENTRY
OutputAATo8BPP_B332_XLATE(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    DEF_COPY_LUTAAHDR;


    while (++pbgrf < pInEnd) {

        if (PBGRF_HAS_MASK(pbgrf)) {

            GET_MASK8BPP(pbDst,
                         pbPat,
                         _GET_MASK8BPP_332_XLATE,
                         AAOutputInfo.pXlate8BPP);
        }

        ++pbDst;

        PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
    }
}



VOID
HTENTRY
OutputAATo8BPP_K_B332_XLATE(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    DEF_COPY_LUTAAHDR;


    while (++pbgrf < pInEnd) {

        if (PBGRF_HAS_MASK(pbgrf)) {

            GET_MASK8BPP_REP_K(pbDst,
                               pbPat,
                               _GET_MASK8BPP_K_332_XLATE,
                               AAOutputInfo.pXlate8BPP);
        }

        ++pbDst;

        PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
    }

}



VOID
HTENTRY
OutputAATo8BPP_XLATE(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    DEF_COPY_LUTAAHDR;


    while (++pbgrf < pInEnd) {

        if (PBGRF_HAS_MASK(pbgrf)) {

            GET_MASK8BPP(pbDst,
                         pbPat,
                         _GET_MASK8BPP_XLATE,
                         AAOutputInfo.pXlate8BPP);
        }

        ++pbDst;

        PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
    }
}



VOID
HTENTRY
OutputAATo8BPP_K_XLATE(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    DEF_COPY_LUTAAHDR;


    while (++pbgrf < pInEnd) {

        if (PBGRF_HAS_MASK(pbgrf)) {

            GET_MASK8BPP_REP_K(pbDst,
                               pbPat,
                               _GET_MASK8BPP_K_XLATE,
                               AAOutputInfo.pXlate8BPP);
        }

        ++pbDst;

        PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
    }
}

#undef bm8i



VOID
HTENTRY
OutputAATo8BPP_MONO(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    if (pAAHdr->Flags & AAHF_HAS_MASK) {

        while (++pbgrf < pInEnd) {

            if (PBGRF_HAS_MASK(pbgrf)) {

                GET_MASK8BPP_MONO(pbDst,
                                  pbPat,
                                  PBGRF_2_GRAYDW(pbgrf),
                                  AAOutputInfo.bm.XorMask);
            }

            ++pbDst;

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
        }

    } else {

        while (++pbgrf < pInEnd) {

            GET_MASK8BPP_MONO(pbDst,
                              pbPat,
                              PBGRF_2_GRAYDW(pbgrf),
                              AAOutputInfo.bm.XorMask);

            ++pbDst;

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
        }
    }
}



//
//**************************************************************************
// 16BPP_555/16BPP_565 Output Functions
//**************************************************************************


#define OUTPUTAATO16BPP_MASK(BM, GM, RM, XorM)                              \
{                                                                           \
    if (AAOutputInfo.bm.cFirst) {                                           \
                                                                            \
        if (PBGRF_HAS_MASK(++pbgrf)) {                                      \
                                                                            \
            *pwDst = GET_16BPP_COPY_W_MASK(pbPat, BM, GM, RM, XorM);        \
        }                                                                   \
                                                                            \
        ++pwDst;                                                            \
                                                                            \
        PPAT_NEXT(pbPat, pbPatEnd, cbWrapBGR);                              \
    }                                                                       \
                                                                            \
    if (pAAHdr->Flags & AAHF_HAS_MASK) {                                    \
                                                                            \
        while (++pbgrf < pInEnd) {                                          \
                                                                            \
            if (PBGRF_HAS_MASK(pbgrf)) {                                    \
                                                                            \
                *pwDst = GET_16BPP_COPY_W_MASK(pbPat, BM, GM, RM, XorM);    \
            }                                                               \
                                                                            \
            ++pwDst;                                                        \
                                                                            \
            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);   \
        }                                                                   \
                                                                            \
    } else {                                                                \
                                                                            \
        --pbgrf;                                                            \
                                                                            \
        while ((pbgrf += 2) < pInEnd) {                                     \
                                                                            \
            *((LPDWORD)pwDst)++ = GET_16BPP_COPY_DW_MASK(pbPat,             \
                                                         BM,                \
                                                         GM,                \
                                                         RM,                \
                                                         XorM);             \
                                                                            \
            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT*2, cbWrapBGR); \
        }                                                                   \
    }                                                                       \
                                                                            \
    if ((AAOutputInfo.bm.cLast) && (PBGRF_HAS_MASK(pbgrf))) {               \
                                                                            \
        *pwDst = GET_16BPP_COPY_W_MASK(pbPat, BM, GM, RM, XorM);            \
    }                                                                       \
}


VOID
HTENTRY
OutputAATo16BPP_ExtBGR(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPWORD          pwDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    DEF_COPY_LUTAAHDR;

    OUTPUTAATO16BPP_MASK(ExtBGR[0], ExtBGR[1], ExtBGR[2], ExtBGR[3]);
}



VOID
HTENTRY
OutputAATo16BPP_555_RGB(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPWORD          pwDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    OUTPUTAATO16BPP_MASK(0x001F0000, 0x03e00000, 0x7c000000, 0x7FFF7FFF);
}



VOID
HTENTRY
OutputAATo16BPP_555_BGR(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPWORD          pwDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    OUTPUTAATO16BPP_MASK(0x7c000000, 0x03e00000, 0x001F0000, 0x7FFF7FFF);
}




VOID
HTENTRY
OutputAATo16BPP_565_RGB(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPWORD          pwDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    OUTPUTAATO16BPP_MASK(0x001F0000, 0x07e00000, 0xF8000000, 0xFFFFFFFF);
}




VOID
HTENTRY
OutputAATo16BPP_565_BGR(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPWORD          pwDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    OUTPUTAATO16BPP_MASK(0xF8000000, 0x07e00000, 0x001F0000, 0xFFFFFFFF);
}

//
//**************************************************************************
// 24BPP/32 Output Functions
//**************************************************************************


#define OUTPUTAATO24_32BPP(iR, iG, iB, cbNext)                              \
{                                                                           \
    if (pAAHdr->Flags & AAHF_HAS_MASK) {                                    \
                                                                            \
        while (++pbgrf < pInEnd) {                                          \
                                                                            \
            if (PBGRF_HAS_MASK(pbgrf)) {                                    \
                                                                            \
                pbDst[iR] = ~(BYTE)_GET_R_CLR(pbgrf);                       \
                pbDst[iG] = ~(BYTE)_GET_G_CLR(pbgrf);                       \
                pbDst[iB] = ~(BYTE)_GET_B_CLR(pbgrf);                       \
            }                                                               \
                                                                            \
            pbDst += cbNext;                                                \
        }                                                                   \
                                                                            \
    } else {                                                                \
                                                                            \
        while (++pbgrf < pInEnd) {                                          \
                                                                            \
            pbDst[iR]  = ~(BYTE)_GET_R_CLR(pbgrf);                          \
            pbDst[iG]  = ~(BYTE)_GET_G_CLR(pbgrf);                          \
            pbDst[iB]  = ~(BYTE)_GET_B_CLR(pbgrf);                          \
            pbDst     += cbNext;                                            \
        }                                                                   \
    }                                                                       \
}



VOID
HTENTRY
OutputAATo24BPP_RGB(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{

    OUTPUTAATO24_32BPP(2, 1, 0, 3);
}



VOID
HTENTRY
OutputAATo24BPP_BGR(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    OUTPUTAATO24_32BPP(0, 1, 2, 3);
}


VOID
HTENTRY
OutputAATo24BPP_ORDER(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    UINT    iR;
    UINT    iG;
    UINT    iB;

    iR = (UINT)AAOutputInfo.bgri.iR;
    iG = (UINT)AAOutputInfo.bgri.iG;
    iB = (UINT)AAOutputInfo.bgri.iB;


    OUTPUTAATO24_32BPP(iR, iG, iB, 3);
}



VOID
HTENTRY
OutputAATo32BPP_RGB(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{

    OUTPUTAATO24_32BPP(2, 1, 0, 4);
}



VOID
HTENTRY
OutputAATo32BPP_BGR(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    OUTPUTAATO24_32BPP(0, 1, 2, 4);
}


VOID
HTENTRY
OutputAATo32BPP_ORDER(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    UINT    iR;
    UINT    iG;
    UINT    iB;

    iR = (UINT)AAOutputInfo.bgri.iR;
    iG = (UINT)AAOutputInfo.bgri.iG;
    iB = (UINT)AAOutputInfo.bgri.iB;


    OUTPUTAATO24_32BPP(iR, iG, iB, 4);
}


//
//****************************************************************************
// BRUSH Generation FUNCTION
//****************************************************************************
//



LONG
HTENTRY
CreateHalftoneBrushPat(
    PDEVICECOLORINFO    pDCI,
    PCOLORTRIAD         pColorTriad,
    PDEVCLRADJ          pDevClrAdj,
    LPBYTE              pDest,
    LONG                cbDestNext
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    26-Feb-1997 Wed 13:23:52 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPBYTE          pPat;
    LPBYTE          pB;
    PLONG           pIdxBGR;
    LPBYTE          pXlate8BPP;
    AAPATINFO       AAPI;
    DW2W4B          dw4b;
    DWORD           dwB;
    DWORD           dwG;
    DWORD           dwR;
    DWORD           DCAFlags;
    LONG            Result;
    BGR8            bgr;
    UINT            cCX;
    UINT            cCY;
    UINT            Count;
    UINT            uTmp;
    BYTE            XorMask;
    BYTE            DestFormat;

    _DEF_LUTAAHDR;

#define pW      ((LPWORD)pB)
#define pDW     ((LPDWORD)pB)
#define bm8i    (*(PBM8BPPINFO)&ExtBGR[3])

    //
    // Compute the rgbLUTAA then compute the BGR
    //

    ComputeRGBLUTAA(pDCI, pDevClrAdj, &(pDCI->rgbLUTPat));

    Result = INTERR_INVALID_DEVRGB_SIZE;

    if ((ComputeBGRMappingTable(pDCI, pDevClrAdj, pColorTriad, &bgr) != 1) ||
        ((Result = CachedHalftonePattern(pDCI,
                                         pDevClrAdj,
                                         &AAPI,
                                         0,
                                         0,
                                         FALSE)) <= 0)) {


        //-------------------------------------------------------------
        // Release the semaphore and return error
        //-------------------------------------------------------------

        RELEASE_HTMUTEX(pDCI->HTMutex);
        return(Result);
    }

    //
    // Copy down the ExtBGR and release the semaphore now
    //

    cCX     = (UINT)pDCI->HTCell.cxReal;
    cCY     = (UINT)pDCI->HTCell.Height;
    pIdxBGR = pDCI->rgbLUTPat.IdxBGR;

    //
    // Copy down the necessary infomation
    //

    GET_LUTAAHDR(ExtBGR, pIdxBGR);

    DestFormat = pDevClrAdj->DMI.CTSTDInfo.BMFDest;

    if ((DCAFlags = pDevClrAdj->PrimAdj.Flags) & DCA_XLATE_555_666) {

        GET_P8BPPXLATE(pXlate8BPP, bm8i);
    }

    if (DCAFlags & DCA_XLATE_332) {

        pXlate8BPP = pDCI->CMY8BPPMask.bXlate;
    }

    dwB = _GET_B_CLR(&bgr);
    dwG = _GET_G_CLR(&bgr);
    dwR = _GET_R_CLR(&bgr);

    //----------------------------------------------------------------------
    // Release Semaphore now before we compose the pattern brush
    //----------------------------------------------------------------------

    RELEASE_HTMUTEX(pDCI->HTMutex);

    DBGP_IF(DBGP_BRUSH,
            DBGP("DstOrder=%ld [%ld:%ld:%ld], bgr=%08lx:%08lx:%08lx, ExtBGR=%08lx:%08lx:%08lx %08lx:%08lx:%08lx"
                ARGDW(AAPI.DstOrder.Index)
                ARGDW(AAPI.DstOrder.Order[0])
                ARGDW(AAPI.DstOrder.Order[1])
                ARGDW(AAPI.DstOrder.Order[2])
                ARGDW(dwB) ARGDW(dwG) ARGDW(dwR)
                ARGDW(ExtBGR[0]) ARGDW(ExtBGR[1]) ARGDW(ExtBGR[2])
                ARGDW(ExtBGR[3]) ARGDW(ExtBGR[4]) ARGDW(ExtBGR[5])));

    switch (DestFormat = pDevClrAdj->DMI.CTSTDInfo.BMFDest) {

    case BMF_1BPP:

        //
        // Use only Green/Magenta Pattern
        //

        dwB     = ((dwR + dwG + dwB) ^ GRAY_MAX_IDX) >> 4;
        XorMask = (DCAFlags & DCA_USE_ADDITIVE_PRIMS) ? 0x00 : 0xFF;

#if defined(_X86_)

        _asm {
                mov     esi, AAPI.pbPatBGR
                mov     edi, pDest
                cld
                mov     edx, dwB
                mov     ah, XorMask
CYLoop:
                push    esi
                push    edi
                mov     ebx, cCX
                mov     ecx, ebx
                shr     ecx, 3
                jz      DoBIT
BYTELoop:
                xor     al, al
                cmp     dx, WORD PTR [esi + 2 +  0]
                rcl     al, 1
                cmp     dx, WORD PTR [esi + 2 +  6]
                rcl     al, 1
                cmp     dx, WORD PTR [esi + 2 + 12]
                rcl     al, 1
                cmp     dx, WORD PTR [esi + 2 + 18]
                rcl     al, 1
                cmp     dx, WORD PTR [esi + 2 + 24]
                rcl     al, 1
                cmp     dx, WORD PTR [esi + 2 + 30]
                rcl     al, 1
                cmp     dx, WORD PTR [esi + 2 + 36]
                rcl     al, 1
                cmp     dx, WORD PTR [esi + 2 + 42]
                rcl     al, 1
                xor     al, ah
                stosb
                add     esi, 48
                dec     ecx
                jnz     BYTELoop
DoBIT:
                and     ebx, 7
                jz      DoneLoop
                mov     ecx, 8
                sub     ecx, ebx
                xor     al, al
BITLoop:
                cmp     dx, WORD PTR [esi + 2]
                rcl     al, 1
                add     esi, 6
                dec     ebx
                jnz     BITLoop
                xor     al, ah
                shl     al, cl
                stosb
DoneLoop:
                pop     edi
                pop     esi
                add     esi, AAPI.cyNextBGR
                add     edi, cbDestNext
                dec     cCY
                jnz     CYLoop
        }
#else
        while (cCY--) {

            pPat           = AAPI.pbPatBGR;
            AAPI.pbPatBGR += AAPI.cyNextBGR;
            pB             = pDest;
            pDest         += cbDestNext;
            Count          = cCX >> 3;

            while (Count--) {

                *pB++ = (BYTE)((((dwB - GETMONOPAT(pPat, 0)) & 0x800000) |
                                ((dwB - GETMONOPAT(pPat, 1)) & 0x400000) |
                                ((dwB - GETMONOPAT(pPat, 2)) & 0x200000) |
                                ((dwB - GETMONOPAT(pPat, 3)) & 0x100000) |
                                ((dwB - GETMONOPAT(pPat, 4)) & 0x080000) |
                                ((dwB - GETMONOPAT(pPat, 5)) & 0x040000) |
                                ((dwB - GETMONOPAT(pPat, 6)) & 0x020000) |
                                ((dwB - GETMONOPAT(pPat, 7)) & 0x010000))
                               >> 16) ^ XorMask;

                INC_PPAT(pPat, 8);
            }

            if (Count = cCX & 0x07) {

                dw4b.dw = 0;
                uTmp    = 8 - Count;

                while (Count--) {

                    dw4b.dw = ((dwB - GETMONOPAT(pPat, 0)) & 0x10000) |
                              (dw4b.dw << 1);

                    INC_PPAT(pPat, 1);
                }

                dw4b.b[2]  ^= XorMask;
                dw4b.dw   <<= uTmp;
                *pB         = dw4b.b[2];
            }
        }
#endif

        break;

    case BMF_4BPP:

        XorMask = (DCAFlags & DCA_USE_ADDITIVE_PRIMS) ? 0x00 : 0x77;

        while (cCY--) {

            pPat           = AAPI.pbPatBGR;
            AAPI.pbPatBGR += AAPI.cyNextBGR;
            pB             = pDest;
            pDest         += cbDestNext;
            Count          = cCX >> 1;

            while (Count--) {

                *pB++ = _GET_4BPP_CLR_COPY_BYTE(pPat,
                                                dwB, dwG, dwR, dwB, dwG, dwR,
                                                XorMask);
                INC_PPAT(pPat, 2);
            }

            if (cCX & 0x01) {

                *pB = _GET_4BPP_CLR_COPY_NIBBLE(pPat, dwB, dwG, dwR,
                                                0, 1, 2, XorMask);
            }
        }

        break;

    case BMF_4BPP_VGA16:

        while (cCY--) {

            pPat           = AAPI.pbPatBGR;
            AAPI.pbPatBGR += AAPI.cyNextBGR;
            pB             = pDest;
            pDest         += cbDestNext;
            Count          = cCX >> 1;

            while (Count--) {

                *pB++ = _GET_VGA16_CLR_COPY_BYTE(pPat,
                                                 dwB, dwG, dwR, dwB, dwG, dwR,
                                                 0x77);
                INC_PPAT(pPat, 2);
            }

            if (cCX & 0x01) {

                *pB = _GET_VGA16_CLR_COPY_NIBBLE(pPat, dwB, dwG, dwR,
                                                 0, 1, 2, 0x70);
            }
        }

        break;

    case BMF_8BPP_MONO:

        dw4b.dw = dwB + dwR + dwG;
        dwB     = GRAY_W2DW(dw4b.b[0], dw4b.b[1]);

        while (cCY--) {

            pPat           = AAPI.pbPatBGR;
            AAPI.pbPatBGR += AAPI.cyNextBGR;
            pB             = pDest;
            pDest         += cbDestNext;
            Count          = cCX;

            while (Count--) {

                GET_MASK8BPP_MONO(pB, pPat, dwB, bm8i.Data.bXor);

                ++pB;

                INC_PPAT(pPat, 1);
            }
        }

        break;

    case BMF_8BPP_B332:

        if (DCAFlags & DCA_XLATE_332) {

            while (cCY--) {

                pPat           = AAPI.pbPatBGR;
                AAPI.pbPatBGR += AAPI.cyNextBGR;
                pB             = pDest;
                pDest         += cbDestNext;
                Count          = cCX;

                while (Count--) {

                    _GET_MASK8BPP_332_XLATE(pB, pPat, dwB,dwG,dwR, pXlate8BPP);

                    ++pB;

                    INC_PPAT(pPat, 1);
                }
            }

        } else {

            while (cCY--) {

                pPat           = AAPI.pbPatBGR;
                AAPI.pbPatBGR += AAPI.cyNextBGR;
                pB             = pDest;
                pDest         += cbDestNext;
                Count          = cCX;

                while (Count--) {

                    _GET_MASK8BPP_332(pB, pPat, dwB, dwG, dwR, NULL);

                    ++pB;

                    INC_PPAT(pPat, 1);
                }
            }
        }

        break;

    case BMF_8BPP_K_B332:

        if (DCAFlags & DCA_XLATE_332) {

            while (cCY--) {

                pPat           = AAPI.pbPatBGR;
                AAPI.pbPatBGR += AAPI.cyNextBGR;
                pB             = pDest;
                pDest         += cbDestNext;
                Count          = cCX;

                while (Count--) {

                    _GET_MASK8BPP_REP_K(pB,
                                        pPat,
                                        dwB,
                                        dwG,
                                        dwR,
                                        _GET_MASK8BPP_K_332_XLATE,
                                        pXlate8BPP);

                    ++pB;

                    INC_PPAT(pPat, 1);
                }
            }

        } else {

            while (cCY--) {

                pPat           = AAPI.pbPatBGR;
                AAPI.pbPatBGR += AAPI.cyNextBGR;
                pB             = pDest;
                pDest         += cbDestNext;
                Count          = cCX;

                while (Count--) {

                    _GET_MASK8BPP_REP_K(pB,
                                        pPat,
                                        dwB,
                                        dwG,
                                        dwR,
                                        _GET_MASK8BPP_K_332,
                                        NULL);

                    ++pB;

                    INC_PPAT(pPat, 1);
                }
            }
        }

        break;

    case BMF_8BPP_L555:
    case BMF_8BPP_L666:

        while (cCY--) {

            pPat           = AAPI.pbPatBGR;
            AAPI.pbPatBGR += AAPI.cyNextBGR;
            pB             = pDest;
            pDest         += cbDestNext;
            Count          = cCX;

            while (Count--) {

                _GET_MASK8BPP_XLATE(pB, pPat, dwB, dwG, dwR, pXlate8BPP);

                ++pB;

                INC_PPAT(pPat, 1);
            }
        }

        break;

    case BMF_8BPP_K_L555:
    case BMF_8BPP_K_L666:

        while (cCY--) {

            pPat           = AAPI.pbPatBGR;
            AAPI.pbPatBGR += AAPI.cyNextBGR;
            pB             = pDest;
            pDest         += cbDestNext;
            Count          = cCX;

            while (Count--) {

                _GET_MASK8BPP_REP_K(pB,
                                    pPat,
                                    dwB,
                                    dwG,
                                    dwR,
                                    _GET_MASK8BPP_K_XLATE,
                                    pXlate8BPP);

                ++pB;

                INC_PPAT(pPat, 1);
            }
        }

        break;

    case BMF_8BPP_VGA256:

        while (cCY--) {

            pPat           = AAPI.pbPatBGR;
            AAPI.pbPatBGR += AAPI.cyNextBGR;
            pB             = pDest;
            pDest         += cbDestNext;
            Count          = cCX;

            while (Count--) {

                *pB++ = _GET_VGA256_CLR_COPY_XLATE(pPat,
                                                   VGA256Xlate,
                                                   dwB,
                                                   dwG,
                                                   dwR);

                INC_PPAT(pPat, 1);
            }
        }

        break;

    case BMF_16BPP_555:
    case BMF_16BPP_565:

        while (cCY--) {

            pPat           = AAPI.pbPatBGR;
            AAPI.pbPatBGR += AAPI.cyNextBGR;
            pDW            = (LPDWORD)pDest;
            pDest         += cbDestNext;
            Count          = cCX >> 1;

            while (Count--) {

                *pDW++ = _GET_16BPP_COPY_DW_MASK(pPat,
                                                 dwB, dwG, dwR,
                                                 dwB, dwG, dwR,
                                                 ExtBGR[0],
                                                 ExtBGR[1],
                                                 ExtBGR[2],
                                                 ExtBGR[3]);

                INC_PPAT(pPat, 2);
            }

            if (cCX & 0x01) {

                *pW = _GET_16BPP_COPY_W_MASK(pPat,
                                             dwB, dwG, dwR,
                                             ExtBGR[0],
                                             ExtBGR[1],
                                             ExtBGR[2],
                                             ExtBGR[3]);
            }
        }

        break;

    case BMF_24BPP:
    case BMF_32BPP:

        pB                         = pDest;
        pB[AAPI.DstOrder.Order[0]] = ~(BYTE)dwR;
        pB[AAPI.DstOrder.Order[1]] = ~(BYTE)dwG;
        pB[AAPI.DstOrder.Order[2]] = ~(BYTE)dwB;

        if (DestFormat == BMF_24BPP) {

            dwB = 3;
            dwG = (cCX << 1) + cCX;

        } else {

            dwB   = 4;
            dwG   = (cCX << 2);
            pB[3] = 0;

        }

        pB    += (uTmp = dwB);
        Count  = dwG;

        while (Count -= uTmp) {

            if ((uTmp = dwB) > Count) {

                uTmp = Count;
            }

            CopyMemory(pB, pDest, uTmp);

            pB  += uTmp;
            dwB += uTmp;
        }

        //
        // Now copy down the remaining scanlines from first scanline
        //

        pB = pDest;

        while (--cCY) {

            CopyMemory(pDest += cbDestNext, pB, dwG);
        }

        break;

    default:

        return(HTERR_INVALID_DEST_FORMAT);
    }

    return(Result);


#undef  bm8i
#undef  pW
#undef  pDW
}


#if DBG


LPSTR
GetAAOutputFuncName(
    AAOUTPUTFUNC    AAOutputFunc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    06-Jan-1999 Wed 19:11:27 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo1BPP) {

        return("OutputAATo1BPP");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo4BPP) {

        return("OutputAATo4BPP");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAAToVGA16) {

        return("OutputAAToVGA16");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAAToVGA256) {

        return("OutputAAToVGA256");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo8BPP_B332) {

        return("OutputAATo8BPP_B332");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo8BPP_B332_XLATE) {

        return("OutputAATo8BPP_B332_XLATE");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo8BPP_XLATE) {

        return("OutputAATo8BPP_XLATE");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo8BPP_K_XLATE) {

        return("OutputAATo8BPP_K_XLATE");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo8BPP_K_B332) {

        return("OutputAATo8BPP_K_B332");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo8BPP_K_B332_XLATE) {

        return("OutputAATo8BPP_K_B332_XLATE");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo8BPP_MONO) {

        return("OutputAATo8BPP_MONO");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo16BPP_ExtBGR) {

        return("OutputAATo16BPP_ExtBGR");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo16BPP_555_RGB) {

        return("OutputAATo16BPP_555_RGB");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo16BPP_555_BGR) {

        return("OutputAATo16BPP_555_BGR");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo16BPP_565_RGB) {

        return("OutputAATo16BPP_565_RGB");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo16BPP_565_BGR) {

        return("OutputAATo16BPP_565_BGR");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo24BPP_RGB) {

        return("OutputAATo24BPP_RGB");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo24BPP_BGR) {

        return("OutputAATo24BPP_BGR");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo24BPP_ORDER) {

        return("OutputAATo24BPP_ORDER");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo32BPP_RGB) {

        return("OutputAATo32BPP_RGB");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo32BPP_BGR) {

        return("OutputAATo32BPP_BGR");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo32BPP_ORDER) {

        return("OutputAATo32BPP_ORDER");

    } else {

        return("ERROR: Unknow Function");
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htsort.c ===
/******************************Module*Header*******************************\
* Module Name: sort.c
*
*
* Created: 20-Mar-1995 09:52:19
* Author:  Eric Kutter [erick]
*
* Copyright (c) 1993 Microsoft Corporation
*
*
\**************************************************************************/

#include "htp.h"

typedef struct _SORTSTACK
{
    ULONG iStart;
    ULONG c;
} SORTSTACK;

#define MAXSORT 20

typedef struct _SORTDATA
{
    PBYTE     pjBuf;
    ULONG     iStack;
    ULONG     cjElem;
    SORTCOMP  pfnComp;
    SORTSTACK sStack[MAXSORT];

} SORTDATA;

/******************************Public*Routine******************************\
* vSortSwap()
*
*   Swap the data pointed to by pj1 and pj2, each containing cj bytes.
*
*   Note: this assumes cj is a multiple of 4.
*
*   NOTE: vSortSwap should be inline.
*
* History:
*  18-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vSortSwap(
    PBYTE pj1,
    PBYTE pj2,
    ULONG cj)
{
    PLONG pl1 = (PLONG)pj1;
    PLONG pl2 = (PLONG)pj2;

    do
    {
        LONG l;

        l    = *pl1;
        *pl1++ = *pl2;
        *pl2++ = l;

    } while (cj -= 4);
}

/******************************Public*Routine******************************\
* vSortPush()
*
*   Add a range to the stack to be sorted.
*
*   If there are 0 or 1 elements, just return, sorting done.
*   If there are 2, 3, 4, or 5 elements, just do a bubble sort. sorting done.
*   If the stack is full, just do a bubble sort. sorting done.
*   Otherwise, add a new range to the stack.
*
* History:
*  18-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vSortPush(
    SORTDATA *psd,
    ULONG    iStart,
    ULONG    c)
{
    PBYTE  pj   = psd->pjBuf + iStart;

#if DBGSORT
    DbgPrintf("vSortPush - iStack = %ld, iStart = %ld, c = %ld\n",psd->iStack,iStart,c);
#endif

    if (c > psd->cjElem)
    {
        ULONG i,j;
        ULONG cjElem = psd->cjElem;

        //for (i = 0; i < (c - cjElem); i += cjElem)
        {
        //    if ((*psd->pfnComp)(&pj[i],&pj[i+cjElem]) > 0)
            {
                if ((c <= (4 * psd->cjElem)) || (psd->iStack == MAXSORT))
                {
                    // we have 4 or fewer elements.  Just do a buble sort.  With 4 elements
                    // this will be a 6 compares and upto 6 swaps.
                    // We make c-1 passes over then entire array.  Each pass guarantees that
                    // the next smallest element is shifted to location i.  After the first pass
                    // the smallest element is in location 0.  After the second pass the second
                    // smallest element is in location 1. etc.


                #if DBGSORT
                    if (c > (4 * cjElem))
                        DbgPrintf("******* Stack too deep: c = %ld\n",c / cjElem);
                #endif

                    for (i = 0; i < (c - cjElem); i += cjElem)
                        for (j = c - cjElem; j > i; j -= cjElem)
                            if ((*psd->pfnComp)(&pj[j-cjElem],&pj[j]) > 0)
                                vSortSwap(&pj[j-cjElem],&pj[j],cjElem);
                }
                else
                {
                    psd->sStack[psd->iStack].iStart = iStart;
                    psd->sStack[psd->iStack].c      = c;
                    psd->iStack++;
                }
        //        break;
            }
        }
    }
}

/******************************Public*Routine******************************\
*
*
* History:
*  18-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vDrvSort(
    PBYTE pjBuf,
    ULONG c,
    ULONG cjElem,
    SORTCOMP pfnComp)
{
    SORTDATA sd;

#if DBGSORT
    ULONG cOrg = c;
    ULONG i;

    DbgPrintf("\n\nvDrvSort - c = %d\n",c);

#endif

    if (cjElem & 3)
        return;

    sd.pjBuf   = pjBuf;
    sd.iStack  = 0;
    sd.pfnComp = pfnComp;
    sd.cjElem  = cjElem;

    vSortPush(&sd,0,c * cjElem);

    while (sd.iStack)
    {
        PBYTE pj;
        ULONG iStart;
        ULONG iLow;
        ULONG iHi;

        --sd.iStack;
        iStart = sd.sStack[sd.iStack].iStart;
        pj     = &pjBuf[iStart];
        c      = sd.sStack[sd.iStack].c;

    #if DBGSORT

        for (i = 0; i < cOrg;++i)
            vPrintElem(&pjBuf[i * cjElem]);
        DbgPrintf("\n");

        DbgPrintf("iStart = %ld, c = %ld, iStack = %lx - ",iStart/cjElem,c/cjElem,sd.iStack);

        for (i = 0; i < c;i += cjElem)
            vPrintElem(&pj[i]);
        DbgPrintf("\n");

    #endif

        // pick a random value to use for dividing.  Don't use the first since this
        // will reduce the chances of worst case if the list is sorted in reverse order.

        vSortSwap(&pj[0],&pj[(c / cjElem) / 2 * cjElem],cjElem);

        // initialize the starting and ending indexes.  Note that all operations
        // use cjElem as the increment instead of 1.

        iLow = 0;
        iHi  = c - cjElem;

        // divide the array into two pieces, all elements <= before current one

        for (;;)
        {
            // while (pj[iHi] > pj[0]))

            while ((iHi > iLow) && ((*pfnComp)(&pj[iHi],&pj[0]) >= 0))
                iHi -= cjElem;

            // while (pj[iLow] <= pj[0]))

            while ((iLow < iHi) && ((*pfnComp)(&pj[iLow],&pj[0]) <= 0))
                iLow += cjElem;

            if (iHi == iLow)
                break;

            vSortSwap(&pj[iLow],&pj[iHi],cjElem);

            iHi -= cjElem;
            //if (iLow < iHi)
            //    iLow += cjElem;

        #if DBGSORT
            DbgPrintf("\tiLow = %ld, iHi = %ld\n",iLow/cjElem,iHi/cjElem);
        #endif
        }

        // now add the two pieces to stack
        // 0 -> (iLow - 1), (iLow + 1) -> (c - 1)

        if (iLow != 0)
        {
            vSortSwap(&pj[0],&pj[iLow],cjElem);
            if (iLow > 1)
                vSortPush(&sd,iStart,iLow);
        }

        c = c - iLow - cjElem;
        if (c > 1)
            vSortPush(&sd,iStart + iLow + cjElem,c);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htrender.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htrender.c


Abstract:

    This module contains all low levels halftone rendering functions.


Author:

    22-Jan-1991 Tue 12:49:03 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:

    12-Jan-1999 Tue 11:09:50 updated  -by-  Daniel Chou (danielc)


--*/

#define DBGP_VARNAME        dbgpHTRender



#include "htp.h"
#include "htmapclr.h"
#include "htpat.h"
#include "limits.h"
#include "htalias.h"
#include "htrender.h"
#include "htstret.h"
#include "htgetbmp.h"
#include "htsetbmp.h"

#define DBGP_BFINFO         0x00000001
#define DBGP_FUNC           0x00000002
#define DBGP_AAHT_MEM       0x00000004



DEF_DBGPVAR(BIT_IF(DBGP_BFINFO,         0)  |
            BIT_IF(DBGP_FUNC,           0)  |
            BIT_IF(DBGP_AAHT_MEM,       0))


extern CONST RGBORDER   SrcOrderTable[PRIMARY_ORDER_MAX + 1];
extern const RGBORDER   DstOrderTable[PRIMARY_ORDER_MAX + 1];
extern CONST BYTE       RGB666Xlate[];
extern CONST BYTE       CMY666Xlate[];
extern CONST BYTE       RGB555Xlate[];
extern CONST BYTE       CMY555Xlate[];
extern CONST LPBYTE     p8BPPXlate[];

#define COLOR_SWAP_BC       0x01
#define COLOR_SWAP_AB       0x02
#define COLOR_SWAP_AC       0x04


#if DBG

CHAR    *pOrderName[] = { "RGB", "RBG", "GRB", "GBR", "BGR", "BRG" };

#endif


#define BFINFO_BITS_A       BFInfo.BitsRGB[0]
#define BFINFO_BITS_B       BFInfo.BitsRGB[1]
#define BFINFO_BITS_C       BFInfo.BitsRGB[2]

#define PHR_BFINFO_BITS_A   pHR->BFInfo.BitsRGB[0]
#define PHR_BFINFO_BITS_B   pHR->BFInfo.BitsRGB[1]
#define PHR_BFINFO_BITS_C   pHR->BFInfo.BitsRGB[2]



BOOL
HTENTRY
ValidateRGBBitFields(
    PBFINFO pBFInfo
    )

/*++

Routine Description:

    This function determined the RGB primary order from the RGB bit fields

Arguments:

    pBFInfo - Pointer to the BFINFO data structure, following field must
              set before the call

                BitsRGB[0]    = Red Bits
                BitsRGB[1]    = Green Bits
                BitsRGB[2]    = Blue Bits
                BitmapFormat  = BMF_16BPP/BMF_24BPP/BMF_32BPP
                RGB1stBit     = Specifed PRIMARY_ORDER_xxx ONLY for BMF_1BPP,
                                BMF_4BPP, BMF_8BPP, BMF_24BPP

              requested order.


Return Value:

    FALSE if BitsRGB[] or BitmapFormat passed are not valid

    else TRUE and following fields are returned

        BitsRGB[]       - corrected mask bits
        BitmapFormat    - BMF_16BPP/BMF_24BPP/BMF_32BPP
        Flags           - BFIF_xxxx
        SizeLUT         - Size of LUT table
        BitStart[]      - Starting bits for each of RGB
        BitCount[]      - Bits Count for each of RGB
        RGBOrder        - Current RGB order, for BMF_1BPP, BMF_4BPP, BMF_8BPP
                          and BMF_24BPP the RGBOrder.Index must specified a
                          PRIMARY_ORDER_xxx, for BMF_16BPP, BMF_32BPP the
                          RGBOrder.Index will be set by this function
        RGB1stBit       - The bit start for first on bit in BitsRGB[]
        GrayShr[]       - The right shift count so that most significant bit
                          of each RGB color is aligned to bit 7 if the total
                          bit count of RGB is greater than 8 otherwise this
                          value is 0, it is used when construct the monochrome
                          Y value.

Author:

    03-Mar-1993 Wed 12:33:22 created  -by-  Daniel Chou (danielc)


Revision History:

    06-Apr-1993 Tue 12:15:58 updated  -by-  Daniel Chou (danielc)
        Add 24bpp support for any other order than BGR


--*/

{
    BFINFO  BFInfo = *pBFInfo;
    DWORD   AllBits;
    DWORD   PrimBits;
    INT     Index;
    BYTE    BitCount;
    BYTE    BitStart;


    switch (BFInfo.BitmapFormat) {

    case BMF_1BPP:
    case BMF_4BPP:
    case BMF_8BPP:

        BFInfo.RGBOrder    = SrcOrderTable[BFInfo.RGBOrder.Index];
        BFInfo.BitCount[0] =
        BFInfo.BitCount[1] =
        BFInfo.BitCount[2] = 8;
        PrimBits           = (DWORD)0x000000ff;
        BitStart           = 0;

        for (Index = 0; Index < 3; Index++) {

            BitCount                    = BFInfo.RGBOrder.Order[Index];
            BFInfo.BitsRGB[BitCount]    = PrimBits;
            BFInfo.BitStart[BitCount]   = BitStart;
            PrimBits                  <<= 8;
            BitStart                   += 8;
        }

        break;

    case BMF_16BPP:
    case BMF_16BPP_555:
    case BMF_16BPP_565:

        BFInfo.BitsRGB[0] &= 0xffff;
        BFInfo.BitsRGB[1] &= 0xffff;
        BFInfo.BitsRGB[2] &= 0xffff;

        //
        // FALL THROUGH to compute
        //

    case BMF_24BPP:
    case BMF_32BPP:

        //
        // The bit fields cannot be overlaid
        //

        if (!(AllBits = (BFInfo.BitsRGB[0] |
                         BFInfo.BitsRGB[1] |
                         BFInfo.BitsRGB[2]))) {

            DBGP_IF(DBGP_BFINFO, DBGP("ERROR: BitsRGB[] all zeros"));

            return(FALSE);
        }

        if ((BFInfo.BitsRGB[0] & BFInfo.BitsRGB[1]) ||
            (BFInfo.BitsRGB[0] & BFInfo.BitsRGB[2]) ||
            (BFInfo.BitsRGB[1] & BFInfo.BitsRGB[2])) {

            DBGP_IF(DBGP_BFINFO,
                    DBGP("ERROR: BitsRGB[] Overlay: %08lx:%08lx:%08lx"
                        ARGDW(BFInfo.BitsRGB[0])
                        ARGDW(BFInfo.BitsRGB[1])
                        ARGDW(BFInfo.BitsRGB[2])));

            return(FALSE);
        }

        //
        // Now Check the bit count, we will allowed bit count to be 0
        //

        for (Index = 0; Index < 3; Index++) {

            BitStart =
            BitCount = 0;

            if (PrimBits = BFInfo.BitsRGB[Index]) {

                while (!(PrimBits & 0x01)) {

                    PrimBits >>= 1;         // get to the first bit
                    ++BitStart;
                }

                do {

                    ++BitCount;

                } while ((PrimBits >>= 1) & 0x01);

                if (PrimBits) {

                    //
                    // The bit fields is not contiguous
                    //

                    DBGP_IF(DBGP_BFINFO,
                            DBGP("ERROR: BitsRGB[%u]=%08lx is not contiguous"
                                    ARGU(Index)
                                    ARGDW(BFInfo.BitsRGB[Index])));

                    return(FALSE);
                }
            }

            BFInfo.BitStart[Index] = BitStart;
            BFInfo.BitCount[Index] = BitCount;

            if (!BitCount) {

                DBGP_IF(DBGP_BFINFO,
                        DBGP("WARNING: BitsRGB[%u] is ZERO"
                             ARGU(Index)));
            }
        }

        if ((AllBits == 0x00FFFFFF)     &&
            (BFInfo.BitCount[0] == 8)   &&
            (BFInfo.BitCount[1] == 8)   &&
            (BFInfo.BitCount[2] == 8)) {

            BFInfo.Flags |= BFIF_RGB_888;
        }

        //
        // Check what primary order is this, remember the Primary Order we
        // are checking is source, the source order defines is
        //
        //  PRIMARY_ORDER_ABC
        //                |||
        //                ||+---- Highest memory location
        //                |+----- middle memory location
        //                +------ lowest memory location
        //

        if ((BFINFO_BITS_A < BFINFO_BITS_B) &&
            (BFINFO_BITS_A < BFINFO_BITS_C)) {

            //
            // A is the smallest, so ABC or ACB
            //

            Index = (INT)((BFINFO_BITS_B < BFINFO_BITS_C) ? PRIMARY_ORDER_ABC :
                                                            PRIMARY_ORDER_ACB);

        } else if ((BFINFO_BITS_B < BFINFO_BITS_A) &&
                   (BFINFO_BITS_B < BFINFO_BITS_C)) {

            //
            // B is the smallest, so BAC or BCA
            //

            Index = (INT)((BFINFO_BITS_A < BFINFO_BITS_C) ? PRIMARY_ORDER_BAC :
                                                            PRIMARY_ORDER_BCA);

        } else {

            //
            // C is the smallest, so CAB or CBA
            //

            Index = (INT)((BFINFO_BITS_A < BFINFO_BITS_B) ? PRIMARY_ORDER_CAB :
                                                            PRIMARY_ORDER_CBA);
        }

        BFInfo.RGBOrder = SrcOrderTable[Index];

        break;

    default:

        DBGP("ERROR: Invalid BFInfo.BitmapFormat=%u"
                            ARGDW(pBFInfo->BitmapFormat));

        return(FALSE);
    }

    //
    // Put it back to return to the caller
    //

    *pBFInfo = BFInfo;

    //
    // Output some helpful information
    //

    DBGP_IF(DBGP_BFINFO,
            DBGP("============ BFINFO: BMP Format=%ld ==========="
                        ARGDW(pBFInfo->BitmapFormat));
            DBGP("   BitsRGB[] = 0x%08lx:0x%08lx:0x%08lx"
                             ARGDW(pBFInfo->BitsRGB[0])
                             ARGDW(pBFInfo->BitsRGB[1])
                             ARGDW(pBFInfo->BitsRGB[2]));
            DBGP("       Flags = 0x%02x %s"
                            ARGU(pBFInfo->Flags)
                            ARGPTR((pBFInfo->Flags & BFIF_RGB_888) ?
                                    "BFIF_RGB_888" : ""));
            DBGP("  RGBOrder[] = %2u - %2u:%2u:%2u [PRIMARY_ORDER_%hs]"
                            ARGU(pBFInfo->RGBOrder.Index)
                            ARGU(pBFInfo->RGBOrder.Order[0])
                            ARGU(pBFInfo->RGBOrder.Order[1])
                            ARGU(pBFInfo->RGBOrder.Order[2])
                            ARGPTR(pOrderName[pBFInfo->RGBOrder.Index]));
            DBGP("  BitStart[] = %2u:%2u:%2u"
                            ARGU(pBFInfo->BitStart[0])
                            ARGU(pBFInfo->BitStart[1])
                            ARGU(pBFInfo->BitStart[2]));
            DBGP("  BitCount[] = %2u:%2u:%2u"
                            ARGU(pBFInfo->BitCount[0])
                            ARGU(pBFInfo->BitCount[1])
                            ARGU(pBFInfo->BitCount[2])));

    return(TRUE);
}



LONG
HTENTRY
ValidateHTSI(
    PHALFTONERENDER pHR,
    UINT            ValidateMode
    )

/*++

Routine Description:

    This function read the HTSurfaceInfo and set it to the pHTCBParams

Arguments:

    pHR             - ponter to HALFTONERENDER data structure

    ValiateMode     - VALIDATE_HTSC_SRC/VALIDATE_HTSI_DEST/VALIDATE_HTSI_MASK

Return Value:

    >= 0     - Sucessful
    <  0     - HTERR_xxxx error codes

Author:

    28-Jan-1991 Mon 09:55:53 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPDWORD             pBitsRGB;
    PHTSURFACEINFO      pHTSI;
    COLORTRIAD          ColorTriad;
    RGBORDER            RGBOrder;
    DWORD               MaxColors;
    BYTE                MaxBytesPerEntry;



    switch (ValidateMode) {

    case VALIDATE_HTSI_MASK:

        if (pHTSI = pHR->pSrcMaskSI) {

            if (pHTSI->SurfaceFormat != BMF_1BPP) {

                return(HTERR_INVALID_SRC_MASK_FORMAT);
            }
        }

        break;

    case VALIDATE_HTSI_DEST:

        if (!(pHTSI = pHR->pDestSI)) {

            return(HTERR_NO_DEST_HTSURFACEINFO);
        }

        pHR->pXlate8BPP = NULL;

        switch(pHTSI->SurfaceFormat) {

        case BMF_1BPP:

            break;

        case BMF_8BPP_VGA256:

            //
            // Check if we have xlate table for the 8bpp device
            //

            if (pHTSI->pColorTriad) {

                ColorTriad = *(pHTSI->pColorTriad);

                if ((ColorTriad.pColorTable)                &&
                    (ColorTriad.ColorTableEntries == 256)   &&
                    (ColorTriad.PrimaryValueMax   == 255)   &&
                    (ColorTriad.BytesPerEntry     == 1)     &&
                    (ColorTriad.Type == COLOR_TYPE_RGB)) {

                    pHR->pXlate8BPP = (LPBYTE)ColorTriad.pColorTable;
                }
            }

            break;

        case BMF_4BPP:
        case BMF_4BPP_VGA16:
        case BMF_16BPP_555:
        case BMF_16BPP_565:
        case BMF_24BPP:
        case BMF_32BPP:

            break;

        default:

            return(HTERR_INVALID_DEST_FORMAT);
        }

        break;

    case VALIDATE_HTSI_SRC:

        if (!(pHTSI = pHR->pSrcSI)) {

            return(HTERR_NO_SRC_HTSURFACEINFO);
        }

        if (!(pHTSI->pColorTriad)) {

            return(HTERR_NO_SRC_COLORTRIAD);
        }

        ColorTriad = *(pHTSI->pColorTriad);

        //
        // We will accept other color type (ie. YIQ/XYZ/LAB/LUV) when graphic
        // system has type defined for the api, currently halftone can handle
        // all these types for 16bpp/24bpp/32bpp sources.
        //

        if (ColorTriad.Type > COLOR_TYPE_MAX) {

            return(HTERR_INVALID_COLOR_TYPE);
        }

        MaxColors                  = 0;
        MaxBytesPerEntry           = 4;
        pHR->BFInfo.RGBOrder.Index = (BYTE)ColorTriad.PrimaryOrder;

        switch(pHR->BFInfo.BitmapFormat = (BYTE)pHTSI->SurfaceFormat) {

        case BMF_1BPP:

            MaxColors = 2;
            break;

        case BMF_4BPP:

            MaxColors = 16;
            break;

        case BMF_8BPP:

            MaxColors = 256;
            break;

        case BMF_16BPP:

            MaxBytesPerEntry = 2;       // and fall through

        case BMF_32BPP:

            //
            // 16BPP/32BPP bit fields type of input the parameter of
            // COLORTRIAD must
            //
            //  Type                = COLOR_TYPE_RGB
            //  BytesPerPrimary     = 0
            //  BytesPerEntry       = (16BPP=2, 32BPP=4)
            //  PrimaryOrder        = *Ignored*
            //  PrimaryValueMax     = *Ignored*
            //  ColorTableEntries   = 3
            //  pColorTable         = Point to 3 DWORD RGB bit masks
            //

            if ((ColorTriad.Type != COLOR_TYPE_RGB)             ||
                (ColorTriad.BytesPerEntry != MaxBytesPerEntry)  ||
                (ColorTriad.ColorTableEntries != 3)             ||
                ((pBitsRGB = (LPDWORD)ColorTriad.pColorTable) == NULL)) {

                return(HTERR_INVALID_COLOR_TABLE);
            }

            PHR_BFINFO_BITS_A = *(pBitsRGB + 0);
            PHR_BFINFO_BITS_B = *(pBitsRGB + 1);
            PHR_BFINFO_BITS_C = *(pBitsRGB + 2);

            break;

        case BMF_24BPP:

            //
            // 24BPP must has COLORTRIAD as
            //
            //  Type                = COLOR_TYPE_xxxx
            //  BytesPerPrimary     = 1
            //  BytesPerEntry       = 3;
            //  PrimaryOrder        = PRIMARY_ORDER_xxxx
            //  PrimaryValueMax     = 255
            //  ColorTableEntries   = *Ignorde*
            //  pColorTable         = *Ignored*
            //

            if ((ColorTriad.Type != COLOR_TYPE_RGB)             ||
                (ColorTriad.BytesPerPrimary != 1)               ||
                (ColorTriad.BytesPerEntry != 3)                 ||
                (ColorTriad.PrimaryOrder > PRIMARY_ORDER_MAX)   ||
                (ColorTriad.PrimaryValueMax != 255)) {

                return(HTERR_INVALID_COLOR_ENTRY_SIZE);
            }

            RGBOrder          = SrcOrderTable[ColorTriad.PrimaryOrder];
            PHR_BFINFO_BITS_A = (DWORD)0xFF << (RGBOrder.Order[0] << 3);
            PHR_BFINFO_BITS_B = (DWORD)0xFF << (RGBOrder.Order[1] << 3);
            PHR_BFINFO_BITS_C = (DWORD)0xFF << (RGBOrder.Order[2] << 3);

            DBGP_IF(DBGP_BFINFO,
                    DBGP("24BPP Order=%ld [%ld:%ld:%ld]"
                        ARGDW(RGBOrder.Index)
                        ARGDW(RGBOrder.Order[0])
                        ARGDW(RGBOrder.Order[1])
                        ARGDW(RGBOrder.Order[2])));

            break;

        default:

            return(HTERR_INVALID_SRC_FORMAT);
        }

        //
        // This is a source surface, let's check the color table format
        //

        if (MaxColors) {

            if (ColorTriad.BytesPerPrimary != 1) {

                return(HTERR_INVALID_COLOR_TABLE_SIZE);
            }

            if (ColorTriad.BytesPerEntry < 3) {

                return(HTERR_INVALID_COLOR_ENTRY_SIZE);
            }

            if (ColorTriad.PrimaryOrder > PRIMARY_ORDER_MAX) {

                return(HTERR_INVALID_PRIMARY_ORDER);
            }

            if (!ColorTriad.pColorTable) {

                return(HTERR_INVALID_COLOR_TABLE);
            }

            if ((ColorTriad.ColorTableEntries > MaxColors) ||
                (!ColorTriad.ColorTableEntries)) {

                return(HTERR_INVALID_COLOR_TABLE_SIZE);
            }

            if ((ColorTriad.BytesPerPrimary != 1)       ||
                (ColorTriad.PrimaryValueMax != 255)) {

                return(HTERR_INVALID_PRIMARY_VALUE_MAX);
            }
        }

        if (!ValidateRGBBitFields(&(pHR->BFInfo))) {

            return(HTERR_INVALID_COLOR_TABLE);
        }

        break;
    }

    return(1);
}




LONG
HTENTRY
ComputeBytesPerScanLine(
    UINT            SurfaceFormat,
    UINT            AlignmentBytes,
    DWORD           WidthInPel
    )

/*++

Routine Description:

    This function calculate total bytes needed for a single scan line in the
    bitmap according to its format and alignment requirement.

Arguments:

    SurfaceFormat   - Surface format of the bitmap, this is must one of the
                      standard format which defined as SURFACE_FORMAT_xxx

    AlignmentBytes  - This is the alignment bytes requirement for one scan
                      line, this number can be range from 0 to 65535, some
                      common ones are:

                        0, 1    - Alignment in 8-bit boundary (BYTE)
                        2       - Alignment in 16-bit boundary (WORD)
                        3       - Alignment in 24-bit boundary
                        4       - Alignment in 32-bit boundary (DWORD)
                        8       - Alignment in 64-bit boundary (QWROD)

    WidthInPel      - Total Pels per scan line in the bitmap.

Return Value:

    The return value is the total bytes in one scan line if it is greater than
    zero, some error conditions may be exists when the return value is less
    than or equal to 0.

    Return Value == 0   - The WidthInPel is <= 0

    Return Value  < 0   - Invalid Surface format is passed.


Author:

    14-Feb-1991 Thu 10:03:35 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{

    DWORD   BytesPerScanLine;
    DWORD   OverhangBytes;


    if (WidthInPel <= 0L) {

        return(0L);
    }

    switch (SurfaceFormat) {

    case BMF_1BPP:

        BytesPerScanLine = (WidthInPel + 7L) >> 3;
        break;

    case BMF_4BPP_VGA16:
    case BMF_4BPP:

        BytesPerScanLine = (WidthInPel + 1) >> 1;
        break;

    case BMF_8BPP:
    case BMF_8BPP_VGA256:
    case BMF_8BPP_MONO:
    case BMF_8BPP_B332:
    case BMF_8BPP_L555:
    case BMF_8BPP_L666:
    case BMF_8BPP_K_B332:
    case BMF_8BPP_K_L555:
    case BMF_8BPP_K_L666:

        BytesPerScanLine = WidthInPel;
        break;

    case BMF_16BPP:
    case BMF_16BPP_555:
    case BMF_16BPP_565:

        BytesPerScanLine = WidthInPel << 1;
        break;

    case BMF_24BPP:

        BytesPerScanLine = WidthInPel + (WidthInPel << 1);
        break;

    case BMF_32BPP:

        BytesPerScanLine = WidthInPel << 2;
        break;

    default:

        return(0);

    }

    if ((AlignmentBytes <= 1) ||
        (!(OverhangBytes = BytesPerScanLine % (DWORD)AlignmentBytes))) {

        return((LONG)BytesPerScanLine);

    } else {

        return((LONG)BytesPerScanLine +
               (LONG)AlignmentBytes - (LONG)OverhangBytes);
    }

}




BOOL
HTENTRY
IntersectRECTL(
    PRECTL  prclA,
    PRECTL  prclB
    )

/*++

Routine Description:

    This function intersect prclA and prclB and write the result back to
    prclA, it return TRUE if two rect are intersected


Arguments:




Return Value:




Author:

    01-Apr-1998 Wed 20:41:00 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    RECTL   rcl;


    if ((rcl.left = prclA->left) < prclB->left) {

        rcl.left = prclB->left;
    }

    if ((rcl.top = prclA->top) < prclB->top) {

        rcl.top = prclB->top;
    }

    if ((rcl.right = prclA->right) > prclB->right) {

        rcl.right = prclB->right;
    }

    if ((rcl.bottom = prclA->bottom) > prclB->bottom) {

        rcl.bottom = prclB->bottom;
    }

    *prclA = rcl;

    return((rcl.right > rcl.left) && (rcl.bottom > rcl.top));
}




LONG
HTENTRY
ComputeByteOffset(
    UINT    SurfaceFormat,
    LONG    xLeft,
    LPBYTE  pPixelInByteSkip
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    13-Apr-1998 Mon 22:51:28 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    BYTE    BitOff = 0;


    switch (SurfaceFormat) {

    case BMF_1BPP:

        BitOff   = (BYTE)(xLeft & 0x07);
        xLeft  >>= 3;

        break;

    case BMF_4BPP_VGA16:
    case BMF_4BPP:

        BitOff   = (BYTE)(xLeft & 0x01);
        xLeft  >>= 1;

        break;

    case BMF_8BPP:
    case BMF_8BPP_VGA256:
    case BMF_8BPP_MONO:
    case BMF_8BPP_B332:
    case BMF_8BPP_L555:
    case BMF_8BPP_L666:
    case BMF_8BPP_K_B332:
    case BMF_8BPP_K_L555:
    case BMF_8BPP_K_L666:

        break;

    case BMF_16BPP:
    case BMF_16BPP_555:
    case BMF_16BPP_565:

        xLeft  <<= 1;
        break;

    case BMF_24BPP:

        xLeft  += (xLeft << 1);
        break;

    case BMF_32BPP:

        xLeft  <<= 2;
        break;

    default:

        return(0);
    }

    *pPixelInByteSkip = BitOff;

    return(xLeft);
}



VOID
GetDstBFInfo(
    PAAHEADER   pAAHdr,
    PABINFO     pABInfo,
    BYTE        DstSurfFormat,
    BYTE        DstOrder
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    19-Feb-1999 Fri 13:37:22 created  -by-  Daniel Chou (danielc)


Revision History:

    08-Aug-2000 Tue 18:34:22 updated  -by-  Daniel Chou (danielc)
        Fixing bug for alpha blending, in gray scale mode, the destination
        can only be 1bpp or 8bpp mask mono, so when we read back from the
        destination to do alpha blending, it will double color mapping pixels.
        In gray scale mode, the input function will map the source RGB value
        to gray value with the current device transform, color adjustment and
        so on, so if we read back from destination then this transform is not
        desired.


--*/

{
    LPBYTE      pbPal;
    BFINFO      BFInfo;
    DWORD       Tmp;


    ZeroMemory(&BFInfo, sizeof(BFINFO));
    pbPal = NULL;

    switch (BFInfo.BitmapFormat = (BYTE)DstSurfFormat) {

    case BMF_16BPP_555:

        BFINFO_BITS_A = 0x7c00;
        BFINFO_BITS_B = 0x03e0;
        BFINFO_BITS_C = 0x001F;

        break;

    case BMF_16BPP_565:

        BFINFO_BITS_A  = 0xF800;
        BFINFO_BITS_B  = 0x07e0;
        BFINFO_BITS_C  = 0x001F;
        break;

    case BMF_24BPP:
    case BMF_32BPP:

        BFINFO_BITS_A  = 0x00FF0000;
        BFINFO_BITS_B  = 0x0000FF00;
        BFINFO_BITS_C  = 0x000000FF;
        break;

    default:

        pbPal    = (LPBYTE)pABInfo->pDstPal;
        DstOrder = (pABInfo->Flags & ABIF_DSTPAL_IS_RGBQUAD) ?
                                    PRIMARY_ORDER_BGR : PRIMARY_ORDER_RGB;
        break;
    }

    if (!pbPal) {

        if (DstOrder & COLOR_SWAP_BC) {

            XCHG(BFINFO_BITS_B, BFINFO_BITS_C, Tmp);
        }

        if (DstOrder & COLOR_SWAP_AB) {

            XCHG(BFINFO_BITS_A, BFINFO_BITS_B, Tmp);

        } else if (DstOrder & COLOR_SWAP_AC) {

            XCHG(BFINFO_BITS_A, BFINFO_BITS_C, Tmp);
        }

        ValidateRGBBitFields(&BFInfo);
    }

    ComputeInputColorInfo(pbPal,
                          4,
                          DstOrder,
                          &BFInfo,
                          &(pAAHdr->DstSurfInfo));

    //
    // We only do this if this is a 1bpp, 8bpp devices
    //

    SetGrayColorTable(NULL, &(pAAHdr->DstSurfInfo));
}




LONG
HTENTRY
AAHalftoneBitmap(
    PHALFTONERENDER pHR
    )

/*++

Routine Description:

    This function read the 1/4/8/24 bits per pel source bitmap and composed it
    (compress or expand if necessary) into PRIMCOLOR data structures array for
    later halftone rendering.

Arguments:

    pHalftoneRender     - Pointer to the HALFTONERENDER data structure.


Return Value:

    The return value will be < 0 if an error encountered else it will be
    1L.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#define bm8i    (*(PBM8BPPINFO)&pAAHdr->prgbLUT->ExtBGR[3])

    PDEVICECOLORINFO    pDCI;
    PDEVCLRADJ          pDevClrAdj;
    AAOUTPUTFUNC        AAOutputFunc;
    AACYFUNC            AACYFunc;
    AAOUTPUTINFO        AAOutputInfo;
    PAAHEADER           pAAHdr;
    LONG                Result;
    BOOL                IsReleaseSem;


    DBG_TIMER_BEG(TIMER_SETUP);

    pDCI       = pHR->pDeviceColorInfo;
    pDevClrAdj = pHR->pDevClrAdj;
    pAAHdr     = (PAAHEADER)pHR->pAAHdr;

    if (((Result = ValidateHTSI(pHR, VALIDATE_HTSI_SRC)) < 0)   ||
        ((Result = ValidateHTSI(pHR, VALIDATE_HTSI_DEST)) < 0)  ||
        ((Result = ValidateHTSI(pHR, VALIDATE_HTSI_MASK)) < 0)  ||
        ((Result = SetupAAHeader(pHR, pDCI, pAAHdr, &AACYFunc)) <= 0)) {

        //================================================================
        // Release SEMAPHORE NOW and return error
        //================================================================

        RELEASE_HTMUTEX(pDCI->HTMutex);
        return(Result);
    }

    if (IsReleaseSem =
                (BOOL)((Result = CreateDyesColorMappingTable(pHR)) > 0)) {

        LPBYTE      pOut;
        LONG        cFirst;
        LONG        BitOff;
        LONG        cOut;
        RGBORDER    DstOrder;
        DWORD       AAHFlags;
        DWORD       DCAFlags;
        BYTE        DstSurfFmt;
        BYTE        DMIFlags;


        DstSurfFmt = pDevClrAdj->DMI.CTSTDInfo.BMFDest;
        DMIFlags   = pDevClrAdj->DMI.Flags;
        AAHFlags   = pAAHdr->Flags;
        pOut       = pAAHdr->DstSurfInfo.pb;
        cOut       = pAAHdr->pAAInfoCX->cOut;
        DstOrder   = pAAHdr->AAPI.DstOrder;
        DCAFlags   = (DWORD)pDevClrAdj->PrimAdj.Flags;


        ZeroMemory(&AAOutputInfo, sizeof(AAOUTPUTINFO));

        if (DCAFlags & DCA_XLATE_332) {

            AAOutputInfo.pXlate8BPP = pDCI->CMY8BPPMask.bXlate;
        }

        if (AAHFlags & AAHF_USE_DCI_DATA) {

            IsReleaseSem = FALSE;

            DBGP_IF(DBGP_FUNC, DBGP("AAHF_USE_DCI_DATA"));

            if (AAHFlags & AAHF_ALPHA_BLEND) {

                ASSERT(pDCI->pAlphaBlendBGR);

                pAAHdr->pAlphaBlendBGR = pDCI->pAlphaBlendBGR;

                if (AAHFlags & AAHF_CONST_ALPHA) {

                    pAAHdr->pAlphaBlendBGR += AB_BGR_SIZE;
                }
            }

        } else {

            CopyMemory(pAAHdr->prgbLUT, &(pDCI->rgbLUT), sizeof(RGBLUTAA));

            if (AAHFlags & AAHF_ALPHA_BLEND) {

                if (AAHFlags & AAHF_CONST_ALPHA) {

                    CopyMemory(pAAHdr->pAlphaBlendBGR,
                               (LPBYTE)(pDCI->pAlphaBlendBGR + AB_BGR_SIZE),
                               (AB_BGR_CA_SIZE + AB_CONST_SIZE));

                } else {

                    CopyMemory(pAAHdr->pAlphaBlendBGR,
                               pDCI->pAlphaBlendBGR,
                               AB_BGR_SIZE);
                }
            }

            //============================================================
            // Release SEMAPHORE NOW for pDCI when we halftone the output
            //============================================================

            RELEASE_HTMUTEX(pDCI->HTMutex);
        }

        if (pAAHdr->SrcSurfInfo.Flags & AASIF_GRAY) {

            ASSERT((DstSurfFmt == BMF_1BPP) ||
                   (DstSurfFmt == BMF_8BPP_MONO));

            SetGrayColorTable(pAAHdr->pIdxBGR, &(pAAHdr->SrcSurfInfo));
        }

        if (pAAHdr->FUDI.cbbgr) {

            InitializeFUDI(pAAHdr);
        }

        DBGP_IF(DBGP_FUNC,
                DBGP("\ncOut=%ld, pOutputBuf=%p-%p, (%ld), pOut=%p"
                        ARGDW(cOut) ARGPTR(pAAHdr->pOutputBeg)
                        ARGPTR(pAAHdr->pOutputEnd)
                        ARGDW(pAAHdr->pOutputEnd - pAAHdr->pOutputBeg)
                        ARGPTR(pOut)));

        --pAAHdr->pOutputBeg;

        switch (DstSurfFmt) {

        case BMF_1BPP:

            AAOutputInfo.bm.XorMask = (AAHFlags & AAHF_ADDITIVE) ? 0x00 : 0xFF;

            if (BitOff = (LONG)pAAHdr->DstSurfInfo.BitOffset) {

                cFirst = 8 - BitOff;

                if ((cOut -= cFirst) < 0) {

                    //
                    // Only One byte
                    //

                    cFirst                  += cOut;
                    cOut                     = -cOut;
                    AAOutputInfo.bm.LSFirst  = (BYTE)cOut;
                    cOut                     = 0;
                }

                AAOutputInfo.bm.cFirst = (BYTE)cFirst;
            }

            if (AAOutputInfo.bm.cLast = (BYTE)(cOut & 0x7)) {

                pAAHdr->pOutputEnd -= AAOutputInfo.bm.cLast;
            }

            DBGP_IF(DBGP_FUNC,
                DBGP("1BPP: DstBitOff=%ld, cFirst=%ld, XorMask=0x%02lx, LSFirst=%ld, cLast=%ld [%ld]"
                    ARGDW(BitOff)
                    ARGDW(AAOutputInfo.bm.cFirst)
                    ARGDW(AAOutputInfo.bm.XorMask)
                    ARGDW(AAOutputInfo.bm.LSFirst)
                    ARGDW(AAOutputInfo.bm.cLast)
                    ARGDW(pAAHdr->pOutputEnd - pAAHdr->pOutputBeg)));

            ASSERT(pAAHdr->SrcSurfInfo.Flags & AASIF_GRAY);

            AAOutputFunc = (AAOUTPUTFUNC)OutputAATo1BPP;

            break;

        case BMF_4BPP:
        case BMF_4BPP_VGA16:

            //
            // 4BPP do pre-increment
            //

            AAOutputInfo.bm.XorMask = (AAHFlags & AAHF_ADDITIVE) ? 0x00 : 0x77;

            if (pAAHdr->DstSurfInfo.BitOffset) {

                AAOutputInfo.bm.cFirst = 1;
                --cOut;
            }

            if (cOut & 0x01) {

                AAOutputInfo.bm.cLast = 1;
                --pAAHdr->pOutputEnd;
            }

            AAOutputFunc = (AAOUTPUTFUNC)((DstSurfFmt ==  BMF_4BPP) ?
                                            OutputAATo4BPP : OutputAAToVGA16);
            break;

        case BMF_8BPP_MONO:

            ASSERT(pAAHdr->SrcSurfInfo.Flags & AASIF_GRAY);

            AAOutputInfo.bm.XorMask = bm8i.Data.bXor;
            AAOutputFunc            = (AAOUTPUTFUNC)OutputAATo8BPP_MONO;
            break;

        case BMF_8BPP_B332:

            AAOutputFunc = (DCAFlags & DCA_XLATE_332) ?
                                            OutputAATo8BPP_B332_XLATE :
                                            OutputAATo8BPP_B332;

            break;

        case BMF_8BPP_K_B332:

            AAOutputFunc = (DCAFlags & DCA_XLATE_332) ?
                                            OutputAATo8BPP_K_B332_XLATE :
                                            OutputAATo8BPP_K_B332;

            break;

        case BMF_8BPP_L555:
        case BMF_8BPP_L666:
        case BMF_8BPP_K_L555:
        case BMF_8BPP_K_L666:

            ASSERT(DCAFlags & DCA_XLATE_555_666);

            GET_P8BPPXLATE(AAOutputInfo.pXlate8BPP, bm8i);

            AAOutputFunc = (AAOUTPUTFUNC)(((DstSurfFmt == BMF_8BPP_L555) ||
                                           (DstSurfFmt == BMF_8BPP_L666)) ?
                                OutputAATo8BPP_XLATE : OutputAATo8BPP_K_XLATE);
            break;

        case BMF_8BPP_VGA256:

            AAOutputInfo.pXlate8BPP = BuildVGA256Xlate(pHR->pXlate8BPP,
                                                       pAAHdr->pXlate8BPP);

            AAOutputFunc = (AAOUTPUTFUNC)OutputAAToVGA256;

            break;

        case BMF_16BPP_555:
        case BMF_16BPP_565:

            //
            // Find out if we are in DWORD boundary
            //

            if ((UINT_PTR)pOut & 0x03) {

                AAOutputInfo.bm.cFirst = 1;
                --cOut;
            }

            if (cOut & 0x01) {

                AAOutputInfo.bm.cLast = 1;
                --pAAHdr->pOutputEnd;
            }

            switch (DstOrder.Index) {

            case PRIMARY_ORDER_RGB:

                AAOutputFunc = (DstSurfFmt == BMF_16BPP_555) ?
                                    (AAOUTPUTFUNC)OutputAATo16BPP_555_RGB :
                                    (AAOUTPUTFUNC)OutputAATo16BPP_565_RGB;
                break;

            case PRIMARY_ORDER_BGR:

                AAOutputFunc = (DstSurfFmt == BMF_16BPP_555) ?
                                    (AAOUTPUTFUNC)OutputAATo16BPP_555_BGR :
                                    (AAOUTPUTFUNC)OutputAATo16BPP_565_BGR;
                break;

            default:

                AAOutputFunc = (AAOUTPUTFUNC)OutputAATo16BPP_ExtBGR;
                break;
            }

            break;

        case BMF_24BPP:

            AAOutputInfo.bgri.iR = DstOrder.Order[0];
            AAOutputInfo.bgri.iG = DstOrder.Order[1];
            AAOutputInfo.bgri.iB = DstOrder.Order[2];

            switch (AAOutputInfo.bgri.Order = DstOrder.Index) {

            case PRIMARY_ORDER_RGB:

                AAOutputFunc = (AAOUTPUTFUNC)OutputAATo24BPP_RGB;
                break;

            case PRIMARY_ORDER_BGR:

                AAOutputFunc = (AAOUTPUTFUNC)OutputAATo24BPP_BGR;
                break;

            default:

                AAOutputFunc = (AAOUTPUTFUNC)OutputAATo24BPP_ORDER;
                break;
            }

            DBGP_IF(DBGP_FUNC,
                    DBGP("24BPP: Order=%ld, iR=%ld, iG=%ld, iB=%ld"
                        ARGDW(DstOrder.Index)
                        ARGDW(AAOutputInfo.bgri.iR)
                        ARGDW(AAOutputInfo.bgri.iG)
                        ARGDW(AAOutputInfo.bgri.iB)));

            break;

        case BMF_32BPP:

            AAOutputInfo.bgri.iR = DstOrder.Order[0];
            AAOutputInfo.bgri.iG = DstOrder.Order[1];
            AAOutputInfo.bgri.iB = DstOrder.Order[2];

            switch (AAOutputInfo.bgri.Order = DstOrder.Index) {

            case PRIMARY_ORDER_RGB:

                AAOutputFunc = (AAOUTPUTFUNC)OutputAATo32BPP_RGB;
                break;

            case PRIMARY_ORDER_BGR:

                AAOutputFunc = (AAOUTPUTFUNC)OutputAATo32BPP_BGR;
                break;

            default:

                AAOutputFunc = (AAOUTPUTFUNC)OutputAATo32BPP_ORDER;
                break;
            }

            DBGP_IF(DBGP_FUNC,
                    DBGP("32BPP: Order=%ld, iR=%ld, iG=%ld, iB=%ld"
                        ARGDW(DstOrder.Index)
                        ARGDW(AAOutputInfo.bgri.iR)
                        ARGDW(AAOutputInfo.bgri.iG)
                        ARGDW(AAOutputInfo.bgri.iB)));

            break;

        default:

            ASSERTMSG("Invalid Bitmap format", TRUE);

            AAOutputFunc = (AAOUTPUTFUNC)NULL;
            Result       = HTERR_INVALID_DEST_FORMAT;
            break;
        }

        if (pAAHdr->AAOutputFunc = AAOutputFunc) {

            pAAHdr->AAOutputInfo = AAOutputInfo;

            if (pAAHdr->Flags & AAHF_ALPHA_BLEND) {

                GetDstBFInfo(pAAHdr,
                             pHR->pBitbltParams->pABInfo,
                             DstSurfFmt,
                             DstOrder.Index);
            }

            DBGP_IF(DBGP_FUNC,
                    DBGP("*%s (%p), cOut=%ld, pOut=%p-%p, (%ld), c1st=%ld, XM=%02lx, Bit1st=%02lx, cLast=%02lx, pXlate=%p"
                        ARGPTR(GetAAOutputFuncName(AAOutputFunc))
                        ARGPTR(AAOutputFunc)
                        ARGDW(pAAHdr->pAAInfoCX->cOut)
                        ARGPTR(pAAHdr->pOutputBeg)
                        ARGPTR(pAAHdr->pOutputEnd)
                        ARGDW(pAAHdr->pOutputEnd - pAAHdr->pOutputBeg)
                        ARGDW(AAOutputInfo.bm.cFirst)
                        ARGDW(AAOutputInfo.bm.XorMask)
                        ARGDW(AAOutputInfo.bm.LSFirst)
                        ARGDW(AAOutputInfo.bm.cLast)
                        ARGPTR(pAAHdr->AAOutputInfo.pXlate8BPP)));

            DBG_TIMER_END(TIMER_SETUP);

            Result = AACYFunc(pAAHdr);

            DBG_TIMER_BEG(TIMER_SETUP);
        }

        if ((AAHFlags & AAHF_DO_CLR_MAPPING) && (pAAHdr->pBGRMapTable)) {

            DEREF_BGRMAPCACHE(pAAHdr->pBGRMapTable);
        }

        DBGP_IF(DBGP_AAHT_MEM,
                DBGP("AAHT: pHR=%ld, pDevClrAdj=%ld, pAAInfoX/Y=%ld:%ld, pAAHdr=%ld, Total=%ld"
                    ARGDW(sizeof(HALFTONERENDER))
                    ARGDW(sizeof(DEVCLRADJ)) ARGDW(pAAHdr->pAAInfoCX->cbAlloc)
                    ARGDW(pAAHdr->pAAInfoCY->cbAlloc) ARGDW(pAAHdr->cbAlloc)
                    ARGDW(sizeof(HALFTONERENDER) +
                          sizeof(DEVCLRADJ) + pAAHdr->pAAInfoCX->cbAlloc +
                          pAAHdr->pAAInfoCY->cbAlloc + pAAHdr->cbAlloc)));
    }

    if (!IsReleaseSem) {

        //============================================================
        // Release SEMAPHORE NOW since we did not release it yet
        //============================================================

        RELEASE_HTMUTEX(pDCI->HTMutex);
    }

    HTFreeMem(pAAHdr->pAAInfoCX);
    HTFreeMem(pAAHdr->pAAInfoCY);

    DBG_TIMER_END(TIMER_SETUP);

    return(Result);

#undef  bm8i
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htstret.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htstret.h


Abstract:

    This module has private definition for htstret.c


Author:

    24-Jan-1991 Thu 10:11:10 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:


--*/


#ifndef _HTSTRET_
#define _HTSTRET_


#define MULRGB(b,l)     (LONG)((LONG)(b) * (LONG)(l))
#define MULQW(a,b)      ((DWORDLONG)(a) * (DWORDLONG)(b))


#define INC_PIN_BY_1ST_LEFT(p,f)        (p) += ((f) & AAIF_EXP_HAS_1ST_LEFT)
#define INC_PIN_BY_EDF_LOAD_PIXEL(p,f)  (p) += ((f) >> 15)


#define PMAP_EXP4(Max)                                                      \
{                                                                           \
    do {                                                                    \
                                                                            \
        *(pMap +   0) = (Mul0 += ed.Mul[0]);                                \
        *(pMap + 256) = (Mul1 += ed.Mul[1]);                                \
        *(pMap + 512) = (Mul2 += ed.Mul[2]);                                \
        *(pMap + 768) = (Mul3 += ed.Mul[3]) + ((Max) >> 1);                 \
                                                                            \
    } while (++pMap < pMap0End);                                            \
}

#define PMAP_EXP3(Max)                                                      \
{                                                                           \
    do {                                                                    \
                                                                            \
        *(pMap + 256) = (Mul1 += ed.Mul[1]);                                \
        *(pMap + 512) = (Mul2 += ed.Mul[2]);                                \
        *(pMap + 768) = (Mul3 += ed.Mul[3]) + ((Max) >> 1);                 \
                                                                            \
    } while (++pMap < pMap0End);                                            \
}


#define PMAP_EXP2(Max)                                                      \
{                                                                           \
    do {                                                                    \
                                                                            \
        *(pMap + 512) = (Mul2 += ed.Mul[2]);                                \
        *(pMap + 768) = (Mul3 += ed.Mul[3]) + ((Max) >> 1);                 \
                                                                            \
    } while (++pMap < pMap0End);                                            \
}


#define PMAP_EXP1(Max)                                                      \
{                                                                           \
    do {                                                                    \
                                                                            \
        *(pMap + 768) = (Mul3 += ed.Mul[3]) + ((Max) >> 1);                 \
                                                                            \
    } while (++pMap < pMap0End);                                            \
}


#define INC_EXP4()      { ++prgb3; ++prgb2; ++prgb1; ++prgb0;  }
#define INC_EXP3()      { ++prgb3; ++prgb2; ++prgb1; }
#define INC_EXP2()      { ++prgb3; ++prgb2;  }
#define INC_EXP1()      { ++prgb3;  }

#define INC2_EXP4()     { prgb3 += 4; prgb2 += 4; prgb1 += 4; prgb0 += 4;  }
#define INC2_EXP3()     { prgb3 += 4; prgb2 += 4; prgb1 += 4; }
#define INC2_EXP2()     { prgb3 += 4; prgb2 += 4;  }
#define INC2_EXP1()     { prgb3 += 4;  }


#define GET_EXP4(cType, c, rs)                                              \
            (cType)(((pMap0[prgb3->c + 768]) +                              \
                     (pMap0[prgb2->c + 512]) +                              \
                     (pMap0[prgb1->c + 256]) +                              \
                     (pMap0[prgb0->c      ])) >> (rs))

#define GET_EXP3(cType, c, rs)                                              \
            (cType)(((pMap0[prgb3->c + 768]) +                              \
                     (pMap0[prgb2->c + 512]) +                              \
                     (pMap0[prgb1->c + 256])) >> (rs))

#define GET_EXP2(cType, c, rs)                                              \
            (cType)(((pMap0[prgb3->c + 768]) +                              \
                     (pMap0[prgb2->c + 512])) >> (rs))

#define GET_EXP1(cType, c, rs)                                              \
            (cType)(((pMap0[prgb3->c + 768])) >> (rs))


#define GET_EXP_PC(MacMap, MacMul, MacIncPtr, pDst)                         \
{                                                                           \
    MacMap(DI_MAX_NUM);                                                     \
                                                                            \
    do {                                                                    \
                                                                            \
        pDst->r = MacMul(BYTE, r, DI_R_SHIFT);                              \
        pDst->g = MacMul(BYTE, g, DI_R_SHIFT);                              \
        pDst->b = MacMul(BYTE, b, DI_R_SHIFT);                              \
                                                                            \
        MacIncPtr();                                                        \
                                                                            \
    } while (((LPBYTE)pDst += AAHdr.AABufInc) != (LPBYTE)AAHdr.pAABufEnd);  \
}



#define GRAY_INC_EXP4() { ++pb3; ++pb2; ++pb1; ++pb0;  }
#define GRAY_INC_EXP3() { ++pb3; ++pb2; ++pb1; }
#define GRAY_INC_EXP2() { ++pb3; ++pb2;  }
#define GRAY_INC_EXP1() { ++pb3;  }


#define GRAY_GET_EXP4(cType, rs)                                            \
            (cType)(((pMap0[*pb3 + 768]) +                                  \
                     (pMap0[*pb2 + 512]) +                                  \
                     (pMap0[*pb1 + 256]) +                                  \
                     (pMap0[*pb0      ])) >> (rs))

#define GRAY_GET_EXP3(cType, rs)                                            \
            (cType)(((pMap0[*pb3 + 768]) +                                  \
                     (pMap0[*pb2 + 512]) +                                  \
                     (pMap0[*pb1 + 256])) >> (rs))

#define GRAY_GET_EXP2(cType, rs)                                            \
            (cType)(((pMap0[*pb3 + 768]) +                                  \
                     (pMap0[*pb2 + 512])) >> (rs))

#define GRAY_GET_EXP1(cType, rs)                                            \
            (cType)(((pMap0[*pb3 + 768])) >> (rs))


#define GRAY_GET_EXP_PC(MacMap, MacMul, MacIncPtr, pDst)                    \
{                                                                           \
    MacMap((DI_MAX_NUM >> 4));                                              \
                                                                            \
    do {                                                                    \
                                                                            \
        pDst->Gray = MacMul(WORD, (DI_R_SHIFT - 8));                        \
                                                                            \
        MacIncPtr();                                                        \
                                                                            \
    } while (((LPBYTE)pDst += AAHdr.AABufInc) != (LPBYTE)AAHdr.pAABufEnd);  \
}



#define OUTPUT_AA_CURSCAN                                                   \
{                                                                           \
    ASSERT(((LPBYTE)AAHdr.DstSurfInfo.pb >= AAHdr.pOutBeg) &&               \
           ((LPBYTE)AAHdr.DstSurfInfo.pb <= AAHdr.pOutEnd));                \
                                                                            \
    if (AAHdr.Flags & AAHF_HAS_MASK) {                                      \
                                                                            \
        DBG_TIMER_BEG(TIMER_MASK);                                          \
                                                                            \
        AAHdr.AAMaskCYFunc(&AAHdr);                                         \
                                                                            \
        DBG_TIMER_BEG(TIMER_MASK);                                          \
    }                                                                       \
                                                                            \
    DBG_TIMER_BEG(TIMER_OUTPUT);                                            \
                                                                            \
    if (AAHdr.Flags & AAHF_ALPHA_BLEND) {                                   \
                                                                            \
        AlphaBlendBGRF(&AAHdr);                                             \
    }                                                                       \
                                                                            \
    if (AAHdr.Flags & AAHF_DO_DST_CLR_MAPPING) {                            \
                                                                            \
        MappingBGRF((PBGRF)AAHdr.pRealOutBeg,                               \
                    (PBGRF)AAHdr.pRealOutEnd,                               \
                    (PBGR8)AAHdr.pBGRMapTable,                              \
                    (LPBYTE)AAHdr.AAPI.pbPat555);                           \
                                                                            \
        if ((AAHdr.AAPI.pbPat555 += AAHdr.AAPI.cyNext555) ==                \
                                                AAHdr.AAPI.pbWrap555) {     \
                                                                            \
            AAHdr.AAPI.pbPat555 = AAHdr.AAPI.pbBeg555;                      \
        }                                                                   \
    }                                                                       \
                                                                            \
    AAHdr.AAOutputFunc(&AAHdr,                                              \
                       AAHdr.pOutputBeg,                                    \
                       AAHdr.pOutputEnd,                                    \
                       AAHdr.DstSurfInfo.pb,                                \
                       AAHdr.pIdxBGR,                                       \
                       AAHdr.AAPI.pbPatBGR,                                 \
                       AAHdr.AAPI.pbPatBGR + AAHdr.AAPI.cbEndBGR,           \
                       AAHdr.AAPI.cbWrapBGR,                                \
                       AAHdr.AAOutputInfo);                                 \
                                                                            \
    if ((AAHdr.AAPI.pbPatBGR += AAHdr.AAPI.cyNextBGR) ==                    \
                                                AAHdr.AAPI.pbWrapBGR) {     \
                                                                            \
        AAHdr.AAPI.pbPatBGR = AAHdr.AAPI.pbBegBGR;                          \
    }                                                                       \
                                                                            \
    AAHdr.DstSurfInfo.pb += AAHdr.DstSurfInfo.cyNext;                       \
                                                                            \
    DBG_TIMER_END(TIMER_OUTPUT);                                            \
}


#define _SHARPEN_CLR_LRTB(cS, cL, cC, cR, cT, cB, ExtraRS)                  \
{                                                                           \
    register LONG   c;                                                      \
                                                                            \
    if (((c) = (((LONG)(cC) << 3) + ((LONG)(cC) << 2) -                     \
                (LONG)(cL) - (LONG)(cR) - (LONG)(cT) -                      \
                (LONG)(cB)) >> (ExtraRS + 3)) & 0xFF00) {                   \
                                                                            \
        (c) = (LONG)~((DWORD)(c) >> 24);                                    \
    }                                                                       \
                                                                            \
    (cS) = (BYTE)(c);                                                       \
}


#define _SHARPEN_CLR_LR(cS, cL, cC, cR, ExtraRS)                            \
{                                                                           \
    register LONG   c;                                                      \
                                                                            \
    if (((c) = (((LONG)(cC) << 2) + ((LONG)(cC) << 1) -                     \
                (LONG)(cL) - (LONG)(cR)) >> (ExtraRS + 2)) & 0xFF00) {      \
                                                                            \
        (c) = (LONG)~((DWORD)(c) >> 24);                                    \
    }                                                                       \
                                                                            \
    (cS) = (BYTE)(c);                                                       \
}


#define _SHARPEN_WCLR_LR(cS, cL, cC, cR, ExtraRS)                           \
{                                                                           \
    register LONG   c;                                                      \
                                                                            \
    if (((c) = (((LONG)(cC) << 2) + ((LONG)(cC) << 1) -                     \
                (LONG)(cL) - (LONG)(cR)) >> (ExtraRS + 2)) & 0xFF0000) {    \
                                                                            \
        (c) = (LONG)~((DWORD)(c) >> 16);                                    \
    }                                                                       \
                                                                            \
    (cS) = (WORD)(c);                                                       \
}


#define SHARPEN_RGB_LR(rgbSP, rgbL, rgbC, rgbR, ExtraRS)                    \
{                                                                           \
    _SHARPEN_CLR_LR((rgbSP).b, (rgbL).b, (rgbC).b, (rgbR).b, ExtraRS);      \
    _SHARPEN_CLR_LR((rgbSP).g, (rgbL).g, (rgbC).g, (rgbR).g, ExtraRS);      \
    _SHARPEN_CLR_LR((rgbSP).r, (rgbL).r, (rgbC).r, (rgbR).r, ExtraRS);      \
}


#define SHARPEN_PRGB_LR(prgbSP, rgbL, rgbC, rgbR, ExtraRS)                  \
{                                                                           \
    _SHARPEN_CLR_LR((prgbSP)->b, (rgbL).b, (rgbC).b, (rgbR).b, ExtraRS);    \
    _SHARPEN_CLR_LR((prgbSP)->g, (rgbL).g, (rgbC).g, (rgbR).g, ExtraRS);    \
    _SHARPEN_CLR_LR((prgbSP)->r, (rgbL).r, (rgbC).r, (rgbR).r, ExtraRS);    \
}


#define SHARPEN_GRAY_LR(GraySP, GrayL, GrayC, GrayR, ExtraRS)               \
{                                                                           \
    _SHARPEN_CLR_LR(GraySP, GrayL, GrayC, GrayR, ExtraRS);                  \
}


#define SHARPEN_PGRAY_LR(pbSP, bL, bC, bR, ExtraRS)                         \
{                                                                           \
    _SHARPEN_CLR_LR(*(pbSP), (bL), bC, bR, ExtraRS);                        \
}

#define SHARPEN_PWGRAY_LR(pSP, bL, bC, bR)                                  \
{                                                                           \
    _SHARPEN_WCLR_LR((pSP)->Gray, (bL), bC, bR, (DI_R_SHIFT - 8));          \
}


#define SHARPEN_PRGB_LRTB(pS, pT, pC, pB, ExtraRS)                          \
{                                                                           \
    _SHARPEN_CLR_LRTB(((pS)    )->b,                                        \
                      ((pC) - 1)->b,                                        \
                      ((pC)    )->b,                                        \
                      ((pC) + 1)->b,                                        \
                      ((pT)    )->b,                                        \
                      ((pB)    )->b,                                        \
                      ExtraRS);                                             \
                                                                            \
    _SHARPEN_CLR_LRTB(((pS)    )->g,                                        \
                      ((pC) - 1)->g,                                        \
                      ((pC)    )->g,                                        \
                      ((pC) + 1)->g,                                        \
                      ((pT)    )->g,                                        \
                      ((pB)    )->g,                                        \
                      ExtraRS);                                             \
                                                                            \
    _SHARPEN_CLR_LRTB(((pS)    )->r,                                        \
                      ((pC) - 1)->r,                                        \
                      ((pC)    )->r,                                        \
                      ((pC) + 1)->r,                                        \
                      ((pT)    )->r,                                        \
                      ((pB)    )->r,                                        \
                      ExtraRS);                                             \
}


#define RGB_DIMAX_TO_BYTE(prgb, rgbL, prgbLast)                             \
{                                                                           \
    prgb->r       = (BYTE)(((DWORD)(rgbL.r)+(DI_MAX_NUM>>1)) >> DI_R_SHIFT);\
    prgb->g       = (BYTE)(((DWORD)(rgbL.g)+(DI_MAX_NUM>>1)) >> DI_R_SHIFT);\
    (prgbLast)->b = (BYTE)(((DWORD)(rgbL.b)+(DI_MAX_NUM>>1)) >> DI_R_SHIFT);\
}


#define SHARPEN_PB_LRTB(pS, pT, pC, pB, ExtraRS)                            \
{                                                                           \
    _SHARPEN_CLR_LRTB(*((pS)    ),                                          \
                      *((pC) - 1),                                          \
                      *((pC)    ),                                          \
                      *((pC) + 1),                                          \
                      *((pT)    ),                                          \
                      *((pB)    ),                                          \
                      ExtraRS);                                             \
}

#define GRAY_DIMAX_TO_BYTE(pb, Gray)                                        \
{                                                                           \
    *(pb) = (BYTE)(((DWORD)(Gray) + (DI_MAX_NUM >> 1)) >> DI_R_SHIFT);             \
}


//
// GET_ALPHA_BLEND(s,d,a) is based on (s=Src, d=Dst, c=Alpha)
//  d = (s * a) + (1 - a) * d
//    = (s * a) + d - (d * a)
//    = d + (s * a) - (d * a)
//    = d + (s - d) * a
//  This macro will do the [(s - d) * a] by shifting to left of 16 bits to
//  obtain more precisions.
//
// GET_GRAY_ALPHA_BLEND(s,d,a) is same as GET_ALPHA_BLEND() except it is
// using only 12 bits for precision, because gray level is already 16 bits
// and a LONG can only up to 31 bits plus a sign bit
//
// GET_AB_DEST_CA(s,d,a) is based on (s=Src, d=Dst, srcAlpha)
// GET_AB_DEST(s,d) is based on (s=Src Alpha, d=Dst Alpha)
//  d = s + (1 - s) * d
//    = s + d - (s * d)
//  This macro will do the [(s * d)] by shifting to left of 16 bits to
//  obtain more precisions.
//
//

#define __B2W(b)                ((WORD)GrayIdxWORD[b])
#define GRAY_B2W(b)             (WORD)__B2W(b)
#define GET_CA_VALUE(b)         (LONG)__B2W(b)
#define _GET_GRAY_CA_VALUE(b)   ((LONG)__B2W(b) >> 4)

#define GET_GRAY_AB_SRC(s,d)
#define GET_GRAY_AB_DST(s,d)    (s)=(d)
#define GET_GRAY_ALPHA_BLEND(s,d,a)                                         \
        (s) = (WORD)(((LONG)(d) + (((((LONG)(s)-(LONG)(d))                  \
                    * _GET_GRAY_CA_VALUE(a)) + 0x800) >> 12)))

#define _GET_BGR_BLEND(s,d,a)                                               \
        (BYTE)(((LONG)(d)+(((((LONG)(s)-(LONG)(d))*(LONG)(a))+0x8000) >> 16)))

#define GET_AB_BGR_SRC(pS, pbXlate, pD)                                     \
{                                                                           \
    pS->b = (BYTE)pbXlate[pS->b];                                           \
    pS->g = (BYTE)pbXlate[pS->g];                                           \
    pS->r = (BYTE)pbXlate[pS->r];                                           \
}

#define GET_AB_BGR_DST(pS, pbXlate, pD)     *(PBGR8)(pS) = *(PBGR8)(pD)
#define GET_ALPHA_BLEND_BGR(pS, pbXlate, pD, a)                             \
{                                                                           \
    pS->b = (BYTE)_GET_BGR_BLEND(pbXlate[pS->b +   0], pD->b, a);           \
    pS->g = (BYTE)_GET_BGR_BLEND(pbXlate[pS->g + 256], pD->g, a);           \
    pS->r = (BYTE)_GET_BGR_BLEND(pbXlate[pS->r + 512], pD->r, a);           \
}

#define GET_AB_DEST_CA_SRC(s,d)     (d)=(s)
#define GET_AB_DEST_CA_DST(s,d)

#define GET_AB_DEST_CA(s,d,a)                                               \
        (d)=(BYTE)(((LONG)(s)+(LONG)(d)-((((LONG)(d)*(LONG)(a))+0x8000)>>16)))

#define GET_AB_DEST(s,d)                                                    \
        (BYTE)(((LONG)(s)+(LONG)(d)-((((LONG)(d)*GET_CA_VALUE(s))+0x8000)>>16)))

#define _GET_CONST_ALPHA(a, b, p)   (BYTE)(((a) + p[(b) + (256 * 3)]) >> 8)
#define _GRAY_CONST_ALPHA(a, b, p)  (WORD)(((a) + p[(b) + (256 * 3)]))

#define GET_CONST_ALPHA_BGR(pS, pD, pwBGR)                                  \
{                                                                           \
    pS->b = _GET_CONST_ALPHA(pwBGR[pS->b +   0], pD->b, pwBGR);             \
    pS->g = _GET_CONST_ALPHA(pwBGR[pS->g + 256], pD->g, pwBGR);             \
    pS->r = _GET_CONST_ALPHA(pwBGR[pS->r + 512], pD->r, pwBGR);             \
}

#define GET_CONST_ALPHA_GRAY(pS, pbD, pwBGR)                                \
        ((PGRAYF)pS)->Gray = _GRAY_CONST_ALPHA(pwBGR[pS->g], *pbD, pwBGR)




typedef LPBYTE (HTENTRY *AASHARPENFUNC)(DWORD   AAHFlags,
                                        LPBYTE  pS,
                                        LPBYTE  pT,
                                        LPBYTE  pC,
                                        LPBYTE  pB,
                                        LONG    cbIn);


typedef VOID (HTENTRY *FASTEXPAACXFUNC)(PAAINFO   pAAInfo,
                                        LPBYTE    pIn,
                                        LPBYTE    pOut,
                                        LPBYTE    pOutEnd,
                                        LONG      OutInc);

#define _MUL1(x)        ((LONG)(x))
#define _MUL2(x)        ((LONG)(x)<<1)
#define _MUL3(x)        (_MUL2(x)+(LONG)(x))
#define _MUL4(x)        ((LONG)(x)<<2)
#define _MUL5(x)        (_MUL4(x)+_MUL1(x))
#define _MUL6(x)        (_MUL4(x)+_MUL2(x))
#define _MUL8(x)        ((LONG)(x)<<3)
#define _MUL10(x)       (_MUL8(x)+_MUL2(x))
#define _MUL12(x)       (_MUL8(x)+_MUL4(x))
#define _MUL16(x)       ((LONG)(x)<<4)
#define _MUL22(x)       (_MUL16(x)+_MUL6(x))
#define _MUL24(x)       (_MUL4(_MUL6(x)))
#define _MUL14(x)       (_MUL16(x)-_MUL2(x))


#define CLR_13(l,c)     ((_MUL1(l)+_MUL3(c)+2) >> 2)
#define CLR_35(l,c)     ((_MUL3(l)+_MUL5(c)+4) >> 3)
#define CLR_1319(l,c)   ((_MUL4(_MUL3(l)+_MUL5(c))+_MUL1(l)-_MUL1(c)+16)>>5)

#define CLR_1141(l,c,r) ((_MUL1(l)+_MUL14(c)+_MUL1(r)+8) >> 4)
#define CLR_5225(l,c,r) ((_MUL5(_MUL1(l)+_MUL1(r))+_MUL22(c)+16) >> 5)
#define CLR_3121(l,c,r) ((_MUL3(l)+_MUL12(c)+_MUL1(r)+8) >> 4)
#define CLR_6251(l,c,r) ((_MUL6(l)+_MUL24(c)+_MUL1(c)+_MUL1(r)+16) >> 5)
#define CLR_3263(l,c,r) ((_MUL3(_MUL1(l)+_MUL1(r))+_MUL24(c)+_MUL2(c)+16)>>5)


#define BGR_MACRO(pO, Mac, cl, cc)                                          \
{                                                                           \
    pO->r = (BYTE)Mac((cl).r, (cc).r);                                      \
    pO->g = (BYTE)Mac((cl).g, (cc).g);                                      \
    pO->b = (BYTE)Mac((cl).b, (cc).b);                                      \
}

#define BGR_MACRO3(pO, Mac, cl, cc, cr)                                     \
{                                                                           \
    pO->r = (BYTE)Mac((cl).r, (cc).r, (cr).r);                              \
    pO->g = (BYTE)Mac((cl).g, (cc).g, (cr).g);                              \
    pO->b = (BYTE)Mac((cl).b, (cc).b, (cr).b);                              \
}

#define GRAY_MACRO(pO, Mac, cl, cc)                                         \
{                                                                           \
    pO->Gray = (WORD)Mac((cl), (cc));                                       \
}

#define GRAY_MACRO3(pO, Mac, cl, cc, cr)                                    \
{                                                                           \
    pO->Gray = (WORD)Mac((cl), (cc), (cr));                                 \
}



//
// Function Prototype
//

VOID
HTENTRY
MappingBGR(
    PBGR8   pbgr,
    LONG    cbgr,
    PBGR8   pBGRMapTable,
    LPBYTE  pbPat555
    );


VOID
HTENTRY
MappingBGRF(
    PBGRF   pbgrf,
    PBGRF   pbgrfEnd,
    PBGR8   pBGRMapTable,
    LPBYTE  pbPat555
    );


PBGR8
HTENTRY
SharpenInput(
    DWORD   AAHFlags,
    PBGR8   pbgrS,
    PBGR8   pbgr0,
    PBGR8   pbgr1,
    PBGR8   pbgr2,
    LONG    cbBGRIn
    );

LPBYTE
HTENTRY
GraySharpenInput(
    DWORD   AAHFlags,
    LPBYTE  pbS,
    LPBYTE  pb0,
    LPBYTE  pb1,
    LPBYTE  pb2,
    LONG    cbIn
    );

LONG
HTENTRY
TileDIB_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
RepDIB_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

LONG
HTENTRY
RepDIB_CY(
    PAAHEADER   pAAHdr
    );

LONG
HTENTRY
FastExpAA_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
SkipDIB_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

LONG
HTENTRY
SkipDIB_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
CopyDIB_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

LONG
HTENTRY
BltDIB_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
ShrinkDIB_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

LONG
HTENTRY
ShrinkDIB_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
SrkYDIB_SrkCX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut
    );

LONG
HTENTRY
ShrinkDIB_CY_SrkCX(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
ExpandDIB_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

VOID
HTENTRY
ExpYDIB_ExpCX(
    PEXPDATA    pED,
    PBGR8       pIn,
    PBGR8       pOut,
    PBGR8       pOutEnd
    );

LONG
HTENTRY
ExpandDIB_CY_ExpCX(
    PAAHEADER   pAAHdr
    );

LONG
HTENTRY
ExpandDIB_CY(
    PAAHEADER   pAAHdr
    );


//
// Gray functions
//


VOID
HTENTRY
GrayRepDIB_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    PGRAYF  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

VOID
HTENTRY
GraySkipDIB_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    PGRAYF  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

VOID
HTENTRY
GrayCopyDIB_CXGray(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    PGRAYF  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

VOID
HTENTRY
GrayCopyDIB_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    LPBYTE  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

LONG
HTENTRY
GrayExpandDIB_CY_ExpCX(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
GrayExpandDIB_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    LPBYTE  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

LONG
HTENTRY
GrayExpandDIB_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
GrayShrinkDIB_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    LPBYTE  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

LONG
HTENTRY
GrayShrinkDIB_CY(
    PAAHEADER   pAAHdr
    );

#endif  // _HTSTRET_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\htstret.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htstret.c


Abstract:

    This module contains stretching functions to setup the parameters for
    compress or expanding the bitmap.


Author:

    24-Jan-1991 Thu 10:08:11 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:


--*/

#define DBGP_VARNAME        dbgpHTStret



#include "htp.h"
#include "htmapclr.h"
#include "htpat.h"
#include "htalias.h"
#include "htrender.h"
#include "htgetbmp.h"
#include "htsetbmp.h"
#include "htstret.h"
#include "limits.h"


#define DBGP_PSD                0x00000001
#define DBGP_EXP                0x00000002
#define DBGP_AAHT_MEM           0x00000004
#define DBGP_EXPAND             0x00000008
#define DBGP_SRK2               0x00000010


DEF_DBGPVAR(BIT_IF(DBGP_PSD,        0)  |
            BIT_IF(DBGP_EXP,        0)  |
            BIT_IF(DBGP_AAHT_MEM,   0)  |
            BIT_IF(DBGP_EXPAND,     0)  |
            BIT_IF(DBGP_SRK2,       0))


CONST WORD BGR555Idx[] = {

    0x0100,0x011f,0x013e,0x015d,0x017c,0x019c,0x01bb,0x01da,
    0x01f9,0x0218,0x0237,0x0256,0x0275,0x0295,0x02b4,0x02d3,
    0x02f2,0x0311,0x0330,0x034f,0x036e,0x038d,0x03ad,0x03cc,
    0x03eb,0x040a,0x0429,0x0448,0x0467,0x0486,0x04a6,0x04c5,
    0x04e4,0x0503,0x0522,0x0541,0x0560,0x057f,0x059e,0x05be,
    0x05dd,0x05fc,0x061b,0x063a,0x0659,0x0678,0x0697,0x06b7,
    0x06d6,0x06f5,0x0714,0x0733,0x0752,0x0771,0x0790,0x07af,
    0x07cf,0x07ee,0x080d,0x082c,0x084b,0x086a,0x0889,0x08a8,
    0x08c8,0x08e7,0x0906,0x0925,0x0944,0x0963,0x0982,0x09a1,
    0x09c0,0x09e0,0x09ff,0x0a1e,0x0a3d,0x0a5c,0x0a7b,0x0a9a,
    0x0ab9,0x0ad9,0x0af8,0x0b17,0x0b36,0x0b55,0x0b74,0x0b93,
    0x0bb2,0x0bd1,0x0bf1,0x0c10,0x0c2f,0x0c4e,0x0c6d,0x0c8c,
    0x0cab,0x0cca,0x0cea,0x0d09,0x0d28,0x0d47,0x0d66,0x0d85,
    0x0da4,0x0dc3,0x0de2,0x0e02,0x0e21,0x0e40,0x0e5f,0x0e7e,
    0x0e9d,0x0ebc,0x0edb,0x0efb,0x0f1a,0x0f39,0x0f58,0x0f77,
    0x0f96,0x0fb5,0x0fd4,0x0ff3,0x1013,0x1032,0x1051,0x1070,
    0x108f,0x10ae,0x10cd,0x10ec,0x110c,0x112b,0x114a,0x1169,
    0x1188,0x11a7,0x11c6,0x11e5,0x1204,0x1224,0x1243,0x1262,
    0x1281,0x12a0,0x12bf,0x12de,0x12fd,0x131d,0x133c,0x135b,
    0x137a,0x1399,0x13b8,0x13d7,0x13f6,0x1415,0x1435,0x1454,
    0x1473,0x1492,0x14b1,0x14d0,0x14ef,0x150e,0x152e,0x154d,
    0x156c,0x158b,0x15aa,0x15c9,0x15e8,0x1607,0x1626,0x1646,
    0x1665,0x1684,0x16a3,0x16c2,0x16e1,0x1700,0x171f,0x173f,
    0x175e,0x177d,0x179c,0x17bb,0x17da,0x17f9,0x1818,0x1837,
    0x1857,0x1876,0x1895,0x18b4,0x18d3,0x18f2,0x1911,0x1930,
    0x1950,0x196f,0x198e,0x19ad,0x19cc,0x19eb,0x1a0a,0x1a29,
    0x1a48,0x1a68,0x1a87,0x1aa6,0x1ac5,0x1ae4,0x1b03,0x1b22,
    0x1b41,0x1b61,0x1b80,0x1b9f,0x1bbe,0x1bdd,0x1bfc,0x1c1b,
    0x1c3a,0x1c59,0x1c79,0x1c98,0x1cb7,0x1cd6,0x1cf5,0x1d14,
    0x1d33,0x1d52,0x1d72,0x1d91,0x1db0,0x1dcf,0x1dee,0x1e0d,
    0x1e2c,0x1e4b,0x1e6a,0x1e8a,0x1ea9,0x1ec8,0x1ee7,0x1f06,
    0x1f25,0x1f44,0x1f63,0x1f83,0x1fa2,0x1fc1,0x1fe0,0x1fff
    };


CONST WORD GrayIdxWORD[] = {

    0x0000,0x0101,0x0202,0x0303,0x0404,0x0505,0x0606,0x0707,
    0x0808,0x0909,0x0a0a,0x0b0b,0x0c0c,0x0d0d,0x0e0e,0x0f0f,
    0x1010,0x1111,0x1212,0x1313,0x1414,0x1515,0x1616,0x1717,
    0x1818,0x1919,0x1a1a,0x1b1b,0x1c1c,0x1d1d,0x1e1e,0x1f1f,
    0x2020,0x2121,0x2222,0x2323,0x2424,0x2525,0x2626,0x2727,
    0x2828,0x2929,0x2a2a,0x2b2b,0x2c2c,0x2d2d,0x2e2e,0x2f2f,
    0x3030,0x3131,0x3232,0x3333,0x3434,0x3535,0x3636,0x3737,
    0x3838,0x3939,0x3a3a,0x3b3b,0x3c3c,0x3d3d,0x3e3e,0x3f3f,
    0x4040,0x4141,0x4242,0x4343,0x4444,0x4545,0x4646,0x4747,
    0x4848,0x4949,0x4a4a,0x4b4b,0x4c4c,0x4d4d,0x4e4e,0x4f4f,
    0x5050,0x5151,0x5252,0x5353,0x5454,0x5555,0x5656,0x5757,
    0x5858,0x5959,0x5a5a,0x5b5b,0x5c5c,0x5d5d,0x5e5e,0x5f5f,
    0x6060,0x6161,0x6262,0x6363,0x6464,0x6565,0x6666,0x6767,
    0x6868,0x6969,0x6a6a,0x6b6b,0x6c6c,0x6d6d,0x6e6e,0x6f6f,
    0x7070,0x7171,0x7272,0x7373,0x7474,0x7575,0x7676,0x7777,
    0x7878,0x7979,0x7a7a,0x7b7b,0x7c7c,0x7d7d,0x7e7e,0x7f7f,
    0x8080,0x8181,0x8282,0x8383,0x8484,0x8585,0x8686,0x8787,
    0x8888,0x8989,0x8a8a,0x8b8b,0x8c8c,0x8d8d,0x8e8e,0x8f8f,
    0x9090,0x9191,0x9292,0x9393,0x9494,0x9595,0x9696,0x9797,
    0x9898,0x9999,0x9a9a,0x9b9b,0x9c9c,0x9d9d,0x9e9e,0x9f9f,
    0xa0a0,0xa1a1,0xa2a2,0xa3a3,0xa4a4,0xa5a5,0xa6a6,0xa7a7,
    0xa8a8,0xa9a9,0xaaaa,0xabab,0xacac,0xadad,0xaeae,0xafaf,
    0xb0b0,0xb1b1,0xb2b2,0xb3b3,0xb4b4,0xb5b5,0xb6b6,0xb7b7,
    0xb8b8,0xb9b9,0xbaba,0xbbbb,0xbcbc,0xbdbd,0xbebe,0xbfbf,
    0xc0c0,0xc1c1,0xc2c2,0xc3c3,0xc4c4,0xc5c5,0xc6c6,0xc7c7,
    0xc8c8,0xc9c9,0xcaca,0xcbcb,0xcccc,0xcdcd,0xcece,0xcfcf,
    0xd0d0,0xd1d1,0xd2d2,0xd3d3,0xd4d4,0xd5d5,0xd6d6,0xd7d7,
    0xd8d8,0xd9d9,0xdada,0xdbdb,0xdcdc,0xdddd,0xdede,0xdfdf,
    0xe0e0,0xe1e1,0xe2e2,0xe3e3,0xe4e4,0xe5e5,0xe6e6,0xe7e7,
    0xe8e8,0xe9e9,0xeaea,0xebeb,0xecec,0xeded,0xeeee,0xefef,
    0xf0f0,0xf1f1,0xf2f2,0xf3f3,0xf4f4,0xf5f5,0xf6f6,0xf7f7,
    0xf8f8,0xf9f9,0xfafa,0xfbfb,0xfcfc,0xfdfd,0xfefe,0xffff
    };


#define GET_555IDX(b,g,r,s) (((((LONG)BGR555Idx[b]-(s)) & 0x1F00) << 2) |   \
                             ((((LONG)BGR555Idx[g]-(s)) & 0x1F00) >> 3) |   \
                             ((((LONG)BGR555Idx[r]-(s))         ) >> 8))


#if _MSC_FULL_VER >= 13008827 && defined(_M_IX86)
#pragma warning(disable:4731)           // EBP modified with inline asm
#endif




VOID
HTENTRY
MappingBGR(
    PBGR8   pbgr,
    LONG    cbgr,
    PBGR8   pBGRMapTable,
    LPBYTE  pbPat555
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    17-Dec-1998 Thu 12:37:53 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#if defined(_X86_)

    _asm {

        push    ebp

        cld
        mov     edi, pbgr
        mov     ecx, cbgr
        mov     esi, pBGRMapTable
        mov     ebx, pbPat555

LoadPat555:
        movzx   ebp, BYTE PTR [ebx]
        inc     ebx

BGRLoop:
        movzx   eax, BYTE PTR [edi]
        movzx   eax, WORD PTR BGR555Idx[eax * 2];
        sub     eax, ebp
        shl     ah, 2

        movzx   edx, BYTE PTR [edi + 1]
        movzx   edx, WORD PTR BGR555Idx[edx * 2];
        sub     edx, ebp
        xor     dl, dl
        shr     edx, 3
        or      dh, ah

        movzx   eax, BYTE PTR [edi + 2]
        movzx   eax, WORD PTR BGR555Idx[eax * 2];
        sub     eax, ebp
        or      dl, ah
        lea     edx, DWORD PTR [edx * 2 + edx]

        mov     ax, WORD PTR [esi + edx]
        stosw
        mov     al, BYTE PTR [esi + edx + 2]
        stosb

        dec     ecx
        jz      Done

        movzx   ebp, BYTE PTR [ebx]
        inc     ebx
        or      ebp, ebp
        jnz     BGRLoop
        sub     ebx, CX_SIZE_RGB555PAT
        jmp     LoadPat555

Done:
        pop     ebp
    }

#else
    PBGR8   pbgrEnd;
    LONG    Pat555;


    pbgrEnd = pbgr + cbgr;
    Pat555  = (LONG)*pbPat555++;

    do {

        *pbgr = pBGRMapTable[GET_555IDX(pbgr->b, pbgr->g, pbgr->r, Pat555)];

        if (!(Pat555 = (LONG)*pbPat555++)) {

            Pat555 = (LONG)*(pbPat555 -= CX_SIZE_RGB555PAT);
        }

    } while (++pbgr < pbgrEnd);

#endif
}



VOID
HTENTRY
MappingBGRF(
    PBGRF   pbgrf,
    PBGRF   pbgrfEnd,
    PBGR8   pBGRMapTable,
    LPBYTE  pbPat555
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    17-Dec-1998 Thu 12:37:53 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#if defined(_X86_)

    _asm {

        push    ebp

        cld
        mov     edi, pbgrf
        mov     ecx, pbgrfEnd
        mov     esi, pBGRMapTable
        mov     ebx, pbPat555

LoadPat555:
        movzx   ebp, BYTE PTR [ebx]
        inc     ebx

BGRLoop:
        movzx   eax, BYTE PTR [edi]
        movzx   eax, WORD PTR BGR555Idx[eax * 2];
        sub     eax, ebp
        shl     ah, 2

        movzx   edx, BYTE PTR [edi + 1]
        movzx   edx, WORD PTR BGR555Idx[edx * 2];
        sub     edx, ebp
        xor     dl, dl
        shr     edx, 3
        or      dh, ah

        movzx   eax, BYTE PTR [edi + 2]
        movzx   eax, WORD PTR BGR555Idx[eax * 2];
        sub     eax, ebp
        or      dl, ah
        lea     edx, DWORD PTR [edx * 2 + edx]

        mov     ax, WORD PTR [esi + edx]
        stosw
        mov     al, BYTE PTR [esi + edx + 2]
        stosb
        inc     edi

        cmp     edi, ecx
        jae     Done

        movzx   ebp, BYTE PTR [ebx]
        inc     ebx
        or      ebp, ebp
        jnz     BGRLoop
        sub     ebx, CX_SIZE_RGB555PAT
        jmp     LoadPat555

Done:
        pop     ebp
    }

#else
    LONG    Pat555;


    Pat555  = (LONG)*pbPat555++;

    do {

        *(PBGR8)pbgrf = *(PBGR8)(pBGRMapTable + GET_555IDX(pbgrf->b,
                                                           pbgrf->g,
                                                           pbgrf->r,
                                                           Pat555));

        if (!(Pat555 = (LONG)*pbPat555++)) {

            Pat555 = (LONG)*(pbPat555 -= CX_SIZE_RGB555PAT);
        }

    } while (++pbgrf < pbgrfEnd);

#endif
}




VOID
AlphaBlendBGRF(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    19-Feb-1999 Fri 15:18:26 created  -by-  Daniel Chou (danielc)


Revision History:

    06-Sep-2000 Wed 11:13:59 updated  -by-  Daniel Chou (danielc)
        Adding the supports for pre-multiply source alpha and optimized for
        different alphablending cases

--*/

{
#define pGrayF  ((PGRAYF)pbgrf)
#define pwBGR   ((LPWORD)pbBGR)
#define pbDst   ((LPBYTE)pDstBGR)

    PBGRF   pbgrf;
    PBGRF   pbgrfEnd;
    LPBYTE  pbBGR;
    PBGR8   pDstBGR;
    DWORD   AAHFlags;
    DWORD   r;
    DWORD   g;
    DWORD   b;
    BOOL    DoGray;


    //
    // Start Alpha Blend
    //

    AAHFlags = pAAHdr->Flags;
    DoGray   = (BOOL)(pAAHdr->SrcSurfInfo.Flags & AASIF_GRAY);
    pbgrf    = (PBGRF)pAAHdr->pRealOutBeg;
    pbgrfEnd = (PBGRF)pAAHdr->pRealOutEnd;
    pbBGR    = pAAHdr->pAlphaBlendBGR;

    //
    // Read in the destination first
    //

    pAAHdr->DstSurfInfo.InputFunc(&(pAAHdr->DstSurfInfo),
                                  pDstBGR = pAAHdr->pInputBeg);

    if (AAHFlags & AAHF_CONST_ALPHA) {

        //
        // Const alpha blending case, we only need to read the destination
        // and blend it with compute/cached constant alpha table
        //

        if (AAHFlags & AAHF_HAS_MASK) {

            if (DoGray) {

                do {

                    if (PBGRF_HAS_MASK(pbgrf)) {

                        GET_CONST_ALPHA_GRAY(pbgrf, pbDst, pwBGR);
                    }

                    ++pbDst;

                } while (++pbgrf < pbgrfEnd);

            } else {

                do {

                    if (PBGRF_HAS_MASK(pbgrf)) {

                        GET_CONST_ALPHA_BGR(pbgrf, pDstBGR, pwBGR);
                    }

                    ++pDstBGR;

                } while (++pbgrf < pbgrfEnd);
            }

        } else {

            if (DoGray) {

                do {

                    GET_CONST_ALPHA_GRAY(pbgrf, pbDst, pwBGR);
                    ++pbDst;

                } while (++pbgrf < pbgrfEnd);

            } else {

                do {

                    GET_CONST_ALPHA_BGR(pbgrf, pDstBGR, pwBGR);
                    ++pDstBGR;

                } while (++pbgrf < pbgrfEnd);
            }
        }

    } else {

        LPBYTE      pCA;
        LONG        CA;
        WORD        DstGray;
        BYTE        bCA;

        //
        // This is per-pixel alpha blending, we first read the source alpha
        // channel information, the source may be stretched (expand, same or
        // shrinked)
        //

        pAAHdr->GetAVCYFunc(pAAHdr);

        pCA = (LPBYTE)pAAHdr->pSrcAV;

        if (DoGray) {

            //
            // This is gray scale destination case
            //

            if (AAHFlags & AAHF_HAS_MASK) {

                do {

                    if (PBGRF_HAS_MASK(pbgrf)) {

                        DstGray = GRAY_B2W(*pbDst);

                        switch (*pCA) {

                        case 0:

                            GET_GRAY_AB_DST(pGrayF->Gray, DstGray);
                            break;

                        case 0xFF:

                            GET_GRAY_AB_SRC(pGrayF->Gray, DstGray);
                            break;

                        default:

                            pGrayF->Gray = GET_GRAY_ALPHA_BLEND(pGrayF->Gray,
                                                                DstGray,
                                                                *pCA);
                        }
                    }

                    ++pCA;
                    ++pbDst;

                } while (++pbgrf < pbgrfEnd);

            } else {

                do {

                    DstGray = GRAY_B2W(*pbDst++);

                    switch (*pCA) {

                    case 0:

                        GET_GRAY_AB_DST(pGrayF->Gray, DstGray);
                        break;

                    case 0xFF:

                        GET_GRAY_AB_SRC(pGrayF->Gray, DstGray);
                        break;

                    default:

                        pGrayF->Gray = GET_GRAY_ALPHA_BLEND(pGrayF->Gray,
                                                            DstGray,
                                                            *pCA);
                    }

                    ++pCA;

                } while (++pbgrf < pbgrfEnd);
            }

        } else if (AAHFlags & AAHF_AB_DEST) {

            PBGRF   pbgrfDst;

            //
            // This is color RGB alpha blend WITH alpha channel blending.
            // so we already read from the destination into the BGR order in
            // pDstBGR, and pCA points to the alpha value in the source
            // pbgrf is current source stretching/aliasing result.  We need to
            // get destination alpha channel information from pbgrfDst->f
            //
            // The source and destination both is 32bpp and we also need to
            // update the destination alpha value
            //

            pbgrfDst = (PBGRF)pAAHdr->DstSurfInfo.pb;

            if (AAHFlags & AAHF_HAS_MASK) {

                do {

                    if (PBGRF_HAS_MASK(pbgrf)) {

                        switch (bCA = *pCA) {

                        case 0:

                            GET_AB_BGR_DST(pbgrf, pbBGR, pDstBGR);
                            GET_AB_DEST_CA_DST(bCA, pbgrfDst->f);
                            break;

                        case 0xFF:

                            GET_AB_BGR_SRC(pbgrf, pbBGR, pDstBGR);
                            GET_AB_DEST_CA_SRC(bCA, pbgrfDst->f);
                            break;

                        default:

                            CA = GET_CA_VALUE(bCA);
                            GET_AB_DEST_CA(bCA, pbgrfDst->f, CA);
                            GET_ALPHA_BLEND_BGR(pbgrf, pbBGR, pDstBGR, CA);
                            break;
                        }
                    }

                    ++pCA;
                    ++pbgrfDst;
                    ++pDstBGR;

                } while (++pbgrf < pbgrfEnd);

            } else {

                do {

                    switch (bCA = *pCA++) {

                    case 0:

                        GET_AB_BGR_DST(pbgrf, pbBGR, pDstBGR);
                        GET_AB_DEST_CA_DST(bCA, pbgrfDst->f);
                        break;

                    case 0xFF:

                        GET_AB_BGR_SRC(pbgrf, pbBGR, pDstBGR);
                        GET_AB_DEST_CA_SRC(bCA, pbgrfDst->f);
                        break;

                    default:

                        CA = GET_CA_VALUE(bCA);
                        GET_AB_DEST_CA(bCA, pbgrfDst->f, CA);
                        GET_ALPHA_BLEND_BGR(pbgrf, pbBGR, pDstBGR, CA);
                        break;
                    }

                    ++pbgrfDst;
                    ++pDstBGR;

                } while (++pbgrf < pbgrfEnd);
            }

        } else {

            //
            // This is color RGB alpha blend only without alpha channel blend
            // so we already read from the destination into the BGR order in
            // pDstBGR, and pCA points to the alpha value in the source
            // pbgrf is current source stretching/aliasing result
            //

            if (AAHFlags & AAHF_HAS_MASK) {

                do {

                    if (PBGRF_HAS_MASK(pbgrf)) {

                        switch (*pCA) {

                        case 0:

                            GET_AB_BGR_DST(pbgrf, pbBGR, pDstBGR);
                            break;

                        case 0xFF:

                            GET_AB_BGR_SRC(pbgrf, pbBGR, pDstBGR);
                            break;

                        default:

                            CA = GET_CA_VALUE(*pCA);
                            GET_ALPHA_BLEND_BGR(pbgrf, pbBGR, pDstBGR, CA);
                            break;
                        }
                    }

                    ++pCA;
                    ++pDstBGR;

                } while (++pbgrf < pbgrfEnd);

            } else {

                do {

                    switch (*pCA) {

                    case 0:

                        GET_AB_BGR_DST(pbgrf, pbBGR, pDstBGR);
                        break;

                    case 0xFF:

                        GET_AB_BGR_SRC(pbgrf, pbBGR, pDstBGR);
                        break;

                    default:

                        CA = GET_CA_VALUE(*pCA);
                        GET_ALPHA_BLEND_BGR(pbgrf, pbBGR, pDstBGR, CA);
                        break;
                    }

                    ++pCA;
                    ++pDstBGR;

                } while (++pbgrf < pbgrfEnd);
            }
        }
    }

#undef pbDst
#undef pwBGR
#undef pGrayF
}



LONG
HTENTRY
TileDIB_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#define pGrayF  ((PGRAYF)pOut)
#define pbIn    ((LPBYTE)pIn)
#define pwIn    ((LPWORD)pInCur)

    AAHEADER    AAHdr;
    LPWORD      pwGray;
    LONG        cyLoop;
    LONG        xSrcBeg;
    LONG        xSrcInc;
    LONG        cxAvai;
    LONG        cxFirst;


    AAHdr   = *pAAHdr;
    pwGray  = (LPWORD)AAHdr.pAAInfoCY->pbExtra;
    cyLoop  = AAHdr.DstSurfInfo.cy;
    xSrcBeg = (LONG)AAHdr.pAAInfoCX->iSrcBeg;
    xSrcInc = xSrcBeg * ((AAHdr.SrcSurfInfo.Flags & AASIF_GRAY) ? sizeof(WORD) :
                                                                  sizeof(BGR8));
    cxFirst = AAHdr.SrcSurfInfo.cx - xSrcBeg;

    while (cyLoop--) {

        PBGR8   pIn;
        PBGR8   pInCur;
        PBGR8   pOut;
        LONG    cInCur;
        LONG    cOutCur;
        LONG    cxAvai;


        pIn = GetFixupScan(&AAHdr, AAHdr.pInputBeg);

        if (AAHdr.SrcSurfInfo.Flags & AASIF_GRAY) {

            cxAvai = AAHdr.SrcSurfInfo.cx;
            pwIn   = pwGray;

            while (cxAvai--) {

                *pwIn++ = GRAY_B2W(*pbIn++);
            }

            pIn = (PBGR8)pwGray;
        }

        pInCur  = (PBGR8)((LPBYTE)pIn + xSrcInc);
        pOut    = (PBGR8)AAHdr.pAABufBeg;
        cOutCur = AAHdr.DstSurfInfo.cx;
        cxAvai  = cxFirst;

        while (cOutCur) {

            if ((cInCur = cxAvai) > cOutCur) {

                cInCur = cOutCur;
            }

            cxAvai   = AAHdr.SrcSurfInfo.cx;
            cOutCur -= cInCur;

            if (AAHdr.SrcSurfInfo.Flags & AASIF_GRAY) {

                while (cInCur--) {

                    pGrayF->Gray  = *pwIn++;
                    (LPBYTE)pOut += AAHdr.AABufInc;
                }

            } else {

                while (cInCur--) {

                    *pOut         = *pInCur++;
                    (LPBYTE)pOut += AAHdr.AABufInc;
                }
            }

            pInCur = pIn;
        }

        OUTPUT_AA_CURSCAN;
    }

    return(AAHdr.DstSurfInfo.cy);

#undef  pGrayF
#undef  pbIn
#undef  pwIn
}



VOID
HTENTRY
GrayCopyDIB_CXGray(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    PGRAYF  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    14-Apr-1999 Wed 15:22:05 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    do {

        pOut->Gray = GRAY_B2W(*pIn++);

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);
}




VOID
HTENTRY
GrayRepDIB_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    PGRAYF  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:54:25 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    DWORD       cRep;
    WORD        wGray;


    pRep     = pAAInfo->Src.pRep;
    pRepEnd  = pAAInfo->Src.pRepEnd;
    cRep     = 1;

    do {

        if (--cRep == 0) {

            cRep  = (DWORD)pRep->c;
            wGray = GRAY_B2W(*pIn);

            if (pRep < pRepEnd) {

                ++pRep;
                ++pIn;
            }
        }

        pOut->Gray = wGray;

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);
}




VOID
HTENTRY
RepDIB_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:54:25 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    DWORD       cRep;
    BGR8        bgr8;



    pRep    = pAAInfo->Src.pRep;
    pRepEnd = pAAInfo->Src.pRepEnd;
    cRep    = 1;

    do {

        if (--cRep == 0) {

            cRep = (DWORD)pRep->c;
            bgr8 = *pIn;

            if (pRep < pRepEnd) {

                ++pRep;
                ++pIn;
            }
        }

        *pOut = bgr8;

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);
}




LONG
HTENTRY
RepDIB_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER    AAHdr = *pAAHdr;
    PAAINFO     pAAInfo;
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    DWORD       cRep;
    PBGRF       pAABufBeg;
    PBGRF       pAABufEnd;
    LONG        AABufInc;



    pAAInfo  = AAHdr.pAAInfoCY;
    pRep     = pAAInfo->Src.pRep;
    pRepEnd  = pAAInfo->Src.pRepEnd;
    cRep     = 1;

    if (AAHdr.Flags & AAHF_ALPHA_BLEND) {

        pAABufBeg = (PBGRF)pAAInfo->pbExtra;
        pAABufEnd = (PBGRF)((PBGR8)pAAInfo->pbExtra + AAHdr.DstSurfInfo.cx);
        AABufInc  = sizeof(BGR8);

    } else {

        pAABufBeg = AAHdr.pAABufBeg;
        pAABufEnd = AAHdr.pAABufEnd;
        AABufInc  = AAHdr.AABufInc;
    }

    while (AAHdr.DstSurfInfo.cy--) {

        if (--cRep == 0) {

            cRep = (DWORD)pRep->c;

            if (pRep < pRepEnd) {

                AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                               GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                               (PBGR8)pAABufBeg,
                               (LPBYTE)pAABufEnd,
                               AABufInc);

                ++pRep;
            }
        }

        if (AAHdr.Flags & AAHF_ALPHA_BLEND) {

            CopyDIB_CX(NULL,
                       (PBGR8)pAABufBeg,
                       (PBGR8)AAHdr.pAABufBeg,
                       (LPBYTE)AAHdr.pAABufEnd,
                       AAHdr.AABufInc);
        }

        OUTPUT_AA_CURSCAN;
    }

    return(pAAHdr->DstSurfInfo.cy);
}




VOID
HTENTRY
CopyDIB_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    26-Jun-1998 Fri 11:33:20 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    do {

        *pOut = *pIn++;

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);
}



LONG
HTENTRY
BltDIB_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER    AAHdr;
    PBGR8       pIn;
    LONG        cLoop;

    AAHdr = *pAAHdr;
    cLoop = AAHdr.pAAInfoCY->cOut;

    while (cLoop--) {

        AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                       GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                       (PBGR8)AAHdr.pAABufBeg,
                       (LPBYTE)AAHdr.pAABufEnd,
                       AAHdr.AABufInc);

        if (AAHdr.SrcSurfInfo.Flags & AASIF_GRAY) {

            PBGRF   pbgrf;

            pbgrf = AAHdr.pRealOutBeg;

            do {

                ((PGRAYF)pbgrf)->Gray = GRAY_B2W(pbgrf->b);

            } while (++pbgrf < AAHdr.pRealOutEnd);
        }

        OUTPUT_AA_CURSCAN;
    }

    return(AAHdr.DstSurfInfo.cy);
}



VOID
HTENTRY
GraySkipDIB_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    PGRAYF  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    05-Apr-1999 Mon 12:57:42 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    DWORD       cRep;


    pRep    = pAAInfo->Src.pRep;
    pRepEnd = pAAInfo->Src.pRepEnd;

    do {

        ASSERT(pRep < pRepEnd);

        pIn        += pRep++->c;
        pOut->Gray  = GRAY_B2W(*(pIn - 1));

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);
}




VOID
HTENTRY
SkipDIB_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    05-Apr-1999 Mon 12:57:42 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PREPDATA    pRep;
    PREPDATA    pRepEnd;


    pRep    = pAAInfo->Src.pRep;
    pRepEnd = pAAInfo->Src.pRepEnd;

    do {

        ASSERT(pRep < pRepEnd);

        pIn   += pRep++->c;
        *pOut  = *(pIn - 1);

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);
}





LONG
HTENTRY
SkipDIB_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    05-Apr-1999 Mon 12:58:00 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER    AAHdr = *pAAHdr;
    PAAINFO     pAAInfo;
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    LONG        cRep;


    pAAInfo = AAHdr.pAAInfoCY;
    pRep    = pAAInfo->Src.pRep;
    pRepEnd = pAAInfo->Src.pRepEnd;

    while (AAHdr.DstSurfInfo.cy--) {

        ASSERT(pRep < pRepEnd);

        //
        // Skip the source scan lines (cRep - 1) by calling GetFixupScan()
        // with a NULL buffer pointer, !!!! we must not alter the
        // SrcSurfInfo.pb at here
        //

        cRep = (LONG)(pRep++->c);

        while (--cRep > 0) {

            GetFixupScan(&AAHdr, NULL);
        }

        AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                       GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                       (PBGR8)AAHdr.pAABufBeg,
                       (LPBYTE)AAHdr.pAABufEnd,
                       AAHdr.AABufInc);

        OUTPUT_AA_CURSCAN;
    }

    return(pAAHdr->DstSurfInfo.cy);
}




VOID
HTENTRY
ShrinkDIB_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PSHRINKDATA pSD;
    PLONG       pMap;
    PLONG       pMap256X;
    PBGR8       pInEnd;
    RGBL        rgbOut[3];
    RGBL        rgbT;
    UINT        Mul;
    UINT        cPreLoad;



    pInEnd = pIn + pAAInfo->cIn;

    if (Mul = (UINT)pAAInfo->PreMul) {

        rgbOut[2].r  = MULRGB(pIn->r, Mul);
        rgbOut[2].g  = MULRGB(pIn->g, Mul);
        rgbOut[2].b  = MULRGB(pIn->b, Mul);
        pIn         += pAAInfo->PreSrcInc;

    } else {

        ZeroMemory(&rgbOut[2], sizeof(rgbOut[2]));
    }

    pSD      = (PSHRINKDATA)(pAAInfo->pAAData);
    pMap256X = pAAInfo->pMapMul;
    cPreLoad = (UINT)pAAInfo->cPreLoad;

    while (cPreLoad) {

        Mul  = (UINT)((pSD++)->Mul);
        pMap = (PLONG)((LPBYTE)pMap256X + GET_SDF_LARGE_OFF(Mul));

        if (Mul & SDF_DONE) {

            //
            // Finished a pixel
            //

            Mul         &= SDF_MUL_MASK;
            rgbOut[2].r += (rgbT.r = MULRGB(pIn->r, Mul));
            rgbOut[2].g += (rgbT.g = MULRGB(pIn->g, Mul));
            rgbOut[2].b += (rgbT.b = MULRGB(pIn->b, Mul));

            CopyMemory(&rgbOut[0], &rgbOut[1], sizeof(rgbOut[0]) * 2);

            rgbOut[2].r  = pMap[(pIn  )->r] - rgbT.r;
            rgbOut[2].g  = pMap[(pIn  )->g] - rgbT.g;
            rgbOut[2].b  = pMap[(pIn++)->b] - rgbT.b;

            --cPreLoad;

        } else {

            rgbOut[2].r += pMap[(pIn  )->r];
            rgbOut[2].g += pMap[(pIn  )->g];
            rgbOut[2].b += pMap[(pIn++)->b];
        }
    }

    if (pAAInfo->cPreLoad == 1) {

        rgbOut[0] = rgbOut[1];
    }

    while (Mul = (UINT)((pSD++)->Mul)) {

        pMap = (PLONG)((LPBYTE)pMap256X + GET_SDF_LARGE_OFF(Mul));

        if (Mul & SDF_DONE) {

            //
            // Finished a pixel
            //

            Mul         &= SDF_MUL_MASK;
            rgbOut[2].r += (rgbT.r = MULRGB(pIn->r, Mul));
            rgbOut[2].g += (rgbT.g = MULRGB(pIn->g, Mul));
            rgbOut[2].b += (rgbT.b = MULRGB(pIn->b, Mul));

            SHARPEN_PRGB_LR(pOut, rgbOut[0], rgbOut[1], rgbOut[2], DI_R_SHIFT);

            (LPBYTE)pOut += OutInc;

            CopyMemory(&rgbOut[0], &rgbOut[1], sizeof(rgbOut[0]) * 2);

            rgbOut[2].r = pMap[(pIn  )->r] - rgbT.r;
            rgbOut[2].g = pMap[(pIn  )->g] - rgbT.g;
            rgbOut[2].b = pMap[(pIn++)->b] - rgbT.b;

        } else {

            rgbOut[2].r += pMap[(pIn  )->r];
            rgbOut[2].g += pMap[(pIn  )->g];
            rgbOut[2].b += pMap[(pIn++)->b];
        }
    }

    ASSERT(pIn == pInEnd);

    if ((LPBYTE)pOut == (pOutEnd - OutInc)) {

        SHARPEN_PRGB_LR(pOut, rgbOut[0], rgbOut[1], rgbOut[1], DI_R_SHIFT);
    }
}




LONG
HTENTRY
ShrinkDIB_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:

    This function shrink the scanline down first in Y direction from source
    bitmap when it is done for group of scanlines then it call AXFunc to
    compose current scanline (it may be Shrink(CX) or Expand(CX)) to the
    final output BGR8 buffer

    The shrink is done by sharpen the current pixel first.



Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER    AAHdr;
    PSHRINKDATA pSD;
    SHRINKDATA  sd;
    PBGR8       pIBuf;
    PBGR8       pICur;
    PBGR8       pOCur;
    PRGBL       prgbIn[3];
    PRGBL       prgb0;
    PRGBL       prgb1;
    PRGBL       prgb2;
    PRGBL       prgb2End;
    PLONG       pMap;
    PLONG       pMapMul;
    PLONG       pMapMul2;
    PLONG       pMap256Y;
    RGBL        rgbT;
    BGR8        rgbCur;
    LONG        cbrgbY;
    LONG        Mul;
    LONG        cAAData;
    BOOL        CopyFirst;
    LONG        cyOut;
    INT         cPreLoad;
    BYTE        Mask;

    //
    // Adding 3 to each side of pIBuf for ExpandDIB_CX
    //

    AAHdr     = *pAAHdr;
    pMap256Y  = AAHdr.pAAInfoCY->pMapMul;
    pMapMul   = (PLONG)(AAHdr.pAAInfoCY->pbExtra);
    pMapMul2  = pMapMul + 256;
    cbrgbY    = (LONG)(AAHdr.SrcSurfInfo.cx * sizeof(RGBL));
    prgbIn[0] = (PRGBL)(pMapMul2 + 256);
    prgbIn[1] = (PRGBL)((LPBYTE)prgbIn[0] + cbrgbY);
    prgbIn[2] = (PRGBL)((LPBYTE)prgbIn[1] + cbrgbY);
    pIBuf     = (PBGR8)((LPBYTE)prgbIn[2] + cbrgbY) + 3;

    ASSERT_MEM_ALIGN(prgbIn[0], sizeof(LONG));
    ASSERT_MEM_ALIGN(prgbIn[1], sizeof(LONG));
    ASSERT_MEM_ALIGN(prgbIn[2], sizeof(LONG));

    if (Mul = AAHdr.pAAInfoCY->PreMul) {

        pMap   = pMapMul;
        rgbT.r = -Mul;

        do {

            pMap[0] = (rgbT.r += Mul);

        } while (++pMap < pMapMul2);

        pICur    = GetFixupScan(&AAHdr, AAHdr.pInputBeg);
        pOCur    = pIBuf;
        prgb2    = prgbIn[2];
        prgb2End = (PRGBL)((LPBYTE)prgb2 + cbrgbY);

        do {

            prgb2->r     = pMapMul[(pICur  )->r];
            prgb2->g     = pMapMul[(pICur  )->g];
            prgb2->b     = pMapMul[(pICur++)->b];

        } while (++prgb2 < prgb2End);

        //
        // The AAInputFunc() will increment the pointer, so reduced it
        //

        if (!(AAHdr.pAAInfoCY->PreSrcInc)) {

            AAHdr.Flags |= AAHF_GET_LAST_SCAN;
        }
    }

    pSD       = (PSHRINKDATA)(AAHdr.pAAInfoCY->pAAData);
    cPreLoad  = (INT)AAHdr.pAAInfoCY->cPreLoad;
    CopyFirst = (BOOL)(cPreLoad == 1);
    cAAData   = AAHdr.pAAInfoCY->cAAData;
    cyOut     = 0;

    while (cAAData--) {

        pICur    = GetFixupScan(&AAHdr, AAHdr.pInputBeg);
        sd       = *pSD++;
        prgb2    = prgbIn[2];
        prgb2End = (PRGBL)((LPBYTE)prgb2 + cbrgbY);
        Mask     = GET_SDF_LARGE_MASK(sd.Mul);

        if (sd.Mul & SDF_DONE) {

            //
            // Build current Mul Table
            //

            Mul    = (LONG)(sd.Mul & SDF_MUL_MASK);
            pMap   = pMapMul;
            rgbT.r = -Mul;
            rgbT.b = (LONG)(pMap256Y[1] - Mul + (LONG)(Mask & 0x01));
            rgbT.g = -rgbT.b;

            do {

                pMap[  0] = (rgbT.r += Mul);
                pMap[256] = (rgbT.g += rgbT.b);

            } while (++pMap < pMapMul2);

            //
            // Finished a scanline, so to see if have prev/next to sharpen with
            //

            prgb0 = prgbIn[0];
            prgb1 = prgbIn[1];

            if (cPreLoad-- > 0) {

                do {

                    prgb2->r     += pMapMul[pICur->r];
                    prgb2->g     += pMapMul[pICur->g];
                    prgb2->b     += pMapMul[pICur->b];
                    prgb0->r      = pMapMul[pICur->r + 256];
                    prgb0->g      = pMapMul[pICur->g + 256];
                    prgb0->b      = pMapMul[pICur->b + 256];

                    ++pICur;
                    prgb0++;

                } while (++prgb2 < prgb2End);

                if (CopyFirst) {

                    CopyMemory(prgb1, prgbIn[2], cbrgbY);
                    CopyFirst = FALSE;
                }

            } else {

                pOCur = pIBuf;

                do {

                    rgbCur    = *pICur++;
                    prgb2->r += pMapMul[rgbCur.r];
                    prgb2->g += pMapMul[rgbCur.g];
                    prgb2->b += pMapMul[rgbCur.b];

                    SHARPEN_PRGB_LR(pOCur,
                                    (*prgb0),
                                    (*prgb1),
                                    (*prgb2),
                                    DI_R_SHIFT);

                    prgb0->r = pMapMul[rgbCur.r + 256];
                    prgb0->g = pMapMul[rgbCur.g + 256];
                    prgb0->b = pMapMul[rgbCur.b + 256];

                    ++pOCur;
                    ++prgb0;
                    ++prgb1;

                } while (++prgb2 < prgb2End);

                AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                               pIBuf,
                               (PBGR8)AAHdr.pAABufBeg,
                               (LPBYTE)AAHdr.pAABufEnd,
                               AAHdr.AABufInc);

                OUTPUT_AA_CURSCAN;

                ++cyOut;
            }

            prgb2     = prgbIn[0];
            prgbIn[0] = prgbIn[1];
            prgbIn[1] = prgbIn[2];
            prgbIn[2] = prgb2;

        } else {

            pMap = (PLONG)((LPBYTE)pMap256Y + GET_SDF_LARGE_OFF(sd.Mul));

            do {

                prgb2->r     += pMap[(pICur  )->r];
                prgb2->g     += pMap[(pICur  )->g];
                prgb2->b     += pMap[(pICur++)->b];

            } while (++prgb2 < prgb2End);
        }
    }

    if (AAHdr.DstSurfInfo.pb != AAHdr.pOutLast) {

        //
        // Do the last line if exist
        //

        pOCur    = pIBuf;
        prgb0    = prgbIn[0];
        prgb2    = prgbIn[1];
        prgb2End = (PRGBL)((LPBYTE)prgb2 + cbrgbY);

        do {

            SHARPEN_PRGB_LR(pOCur,
                            (*prgb0),
                            (*prgb2),
                            (*prgb2),
                            DI_R_SHIFT);

            ++prgb0;
            ++pOCur;

        } while (++prgb2 < prgb2End);

        AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                       pIBuf,
                       (PBGR8)AAHdr.pAABufBeg,
                       (LPBYTE)AAHdr.pAABufEnd,
                       AAHdr.AABufInc);

        OUTPUT_AA_CURSCAN;

        ++cyOut;
    }

    ASSERTMSG("Shrink: cScan not equal", cyOut == AAHdr.DstSurfInfo.cy);

    return(cyOut);
}





VOID
HTENTRY
SrkYDIB_SrkCX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PSHRINKDATA pSD;
    PLONG       pMap;
    PLONG       pMap256X;
    BGR8        rgbIn;
    RGBL        rgbOut;
    RGBL        rgbT;
    UINT        Mul;


    if (Mul = (UINT)pAAInfo->PreMul) {

        rgbOut.r  = MULRGB(pIn->r, Mul);
        rgbOut.g  = MULRGB(pIn->g, Mul);
        rgbOut.b  = MULRGB(pIn->b, Mul);
        pIn      += pAAInfo->PreSrcInc;

    } else {

        ZeroMemory(&rgbOut, sizeof(rgbOut));
    }

    pSD      = (PSHRINKDATA)(pAAInfo->pAAData);
    pMap256X = pAAInfo->pMapMul;

    while (Mul = (UINT)((pSD++)->Mul)) {

        pMap   = (PLONG)((LPBYTE)pMap256X + GET_SDF_LARGE_OFF(Mul));
        rgbIn  = *pIn++;

        if (Mul & SDF_DONE) {

            //
            // Finished a pixel
            //

            Mul         &= SDF_MUL_MASK;
            rgbOut.r    += (rgbT.r = MULRGB(rgbIn.r, Mul));
            rgbOut.g    += (rgbT.g = MULRGB(rgbIn.g, Mul));
            rgbOut.b    += (rgbT.b = MULRGB(rgbIn.b, Mul));

            RGB_DIMAX_TO_BYTE(pOut, rgbOut, pOut++);

            rgbOut.r     = pMap[rgbIn.r] - rgbT.r;
            rgbOut.g     = pMap[rgbIn.g] - rgbT.g;
            rgbOut.b     = pMap[rgbIn.b] - rgbT.b;

        } else {

            rgbOut.r += pMap[rgbIn.r];
            rgbOut.g += pMap[rgbIn.g];
            rgbOut.b += pMap[rgbIn.b];
        }
    }
}




LONG
HTENTRY
ShrinkDIB_CY_SrkCX(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:

    This function shrink the scanline down first in Y direction from source
    bitmap when it is done for group of scanlines then it call AXFunc to
    compose current scanline (it may be Shrink(CX) or Expand(CX)) to the
    final output BGR8 buffer

    The shrink is done by sharpen the current pixel first.



Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER    AAHdr;
    PSHRINKDATA pSD;
    PBGR8       pICur;
    PBGR8       pOCur;
    PRGBL       prgbIn[4];
    PRGBL       prgb0;
    PRGBL       prgb1;
    PRGBL       prgb2;
    PRGBL       prgb1End;
    PRGBL       prgb2End;
    PLONG       pMap;
    PLONG       pMapMul;
    PLONG       pMapMul2;
    PLONG       pMap256Y;
    RGBL        rgbT;
    BGR8        rgbIn;
    LONG        cbrgbY;
    LONG        cyOut;
    UINT        cPreLoad;
    UINT        cPLCX;
    UINT        LargeInc;
    UINT        Mul;


    AAHdr     = *pAAHdr;
    pMap256Y  = AAHdr.pAAInfoCY->pMapMul;
    pMapMul   = (PLONG)(AAHdr.pAAInfoCY->pbExtra);
    pMapMul2  = pMapMul + 256;
    cbrgbY    = (LONG)((AAHdr.pAAInfoCX->cAADone + 2) * sizeof(RGBL));
    prgbIn[0] = (PRGBL)(pMapMul2 + 256);
    prgbIn[1] = (PRGBL)((LPBYTE)prgbIn[0] + cbrgbY);
    prgbIn[2] = (PRGBL)((LPBYTE)prgbIn[1] + cbrgbY);

    ++prgbIn[0];
    ++prgbIn[1];
    ++prgbIn[2];

    cbrgbY -= (sizeof(RGBL) * 2);
    cPLCX   = (UINT)(AAHdr.pAAInfoCX->cPreLoad - 1);

    if (Mul = (UINT)AAHdr.pAAInfoCY->PreMul) {

        SrkYDIB_SrkCX(AAHdr.pAAInfoCX,
                      GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                      pICur = AAHdr.pInputBeg);

        pMap   = pMapMul;
        rgbT.r = -(LONG)Mul;

        do {

            pMap[0] = (rgbT.r += Mul);

        } while (++pMap < pMapMul2);

        prgb2    = prgbIn[2];
        prgb2End = (PRGBL)((LPBYTE)prgb2 + cbrgbY);

        do {

            prgb2->r = pMapMul[(pICur  )->r];
            prgb2->g = pMapMul[(pICur  )->g];
            prgb2->b = pMapMul[(pICur++)->b];

        } while (++prgb2 < prgb2End);

        //
        // The AAInputFunc() will increment the pointer, so reduced it
        //

        if (!(AAHdr.pAAInfoCY->PreSrcInc)) {

            AAHdr.Flags |= AAHF_GET_LAST_SCAN;
        }
    }

    pSD       = (PSHRINKDATA)(AAHdr.pAAInfoCY->pAAData);
    cPreLoad  = (UINT)AAHdr.pAAInfoCY->cPreLoad;
    cyOut     = 0;

    while (cPreLoad) {

        Mul      = (UINT)(pSD++)->Mul;
        prgb2    = prgbIn[2];
        prgb2End = (PRGBL)((LPBYTE)prgb2 + cbrgbY);

        DBGP_IF(DBGP_PSD,
                DBGP("pSD[%3ld]=%4ld, Flags=0x%04lx"
                    ARGDW(pSD - (PSHRINKDATA)(AAHdr.pAAInfoCY->pAAData) - 1)
                    ARGDW(Mul & DI_NUM_MASK) ARGDW(Mul & ~DI_NUM_MASK)));

        SrkYDIB_SrkCX(AAHdr.pAAInfoCX,
                      GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                      pICur = AAHdr.pInputBeg);

        if (Mul & SDF_DONE) {

            //
            // Build current Mul Table
            //

            LargeInc  = GET_SDF_LARGE_INC(Mul);
            Mul      &= SDF_MUL_MASK;
            pMap      = pMapMul;
            rgbT.r    = -(LONG)Mul;
            rgbT.b    = (LONG)(pMap256Y[1] - Mul + LargeInc);
            rgbT.g    = -rgbT.b;

            do {

                pMap[  0] = (rgbT.r += Mul);
                pMap[256] = (rgbT.g += rgbT.b);

            } while (++pMap < pMapMul2);

            //
            // Finished a scanline, so to see if have prev/next to sharpen with
            //

            prgbIn[3] =
            prgb0     = prgbIn[0];

            do {

                (prgb2  )->r += pMapMul[(pICur  )->r      ];
                (prgb2  )->g += pMapMul[(pICur  )->g      ];
                (prgb2  )->b += pMapMul[(pICur  )->b      ];
                (prgb0  )->r  = pMapMul[(pICur  )->r + 256];
                (prgb0  )->g  = pMapMul[(pICur  )->g + 256];
                (prgb0++)->b  = pMapMul[(pICur++)->b + 256];

            } while (++prgb2 < prgb2End);

            prgbIn[0] = prgbIn[1];
            prgbIn[1] = prgbIn[2];
            prgbIn[2] = prgbIn[3];

            --cPreLoad;

        } else {

            pMap = (PLONG)((LPBYTE)pMap256Y + GET_SDF_LARGE_OFF(Mul));

            do {

                prgb2->r += pMap[(pICur  )->r];
                prgb2->g += pMap[(pICur  )->g];
                prgb2->b += pMap[(pICur++)->b];

            } while (++prgb2 < prgb2End);
        }
    }

    if (AAHdr.pAAInfoCY->cPreLoad == 1) {

        CopyMemory(prgbIn[0], prgbIn[1], cbrgbY);
    }

    while (Mul = (UINT)((pSD++)->Mul)) {

        prgb2    = prgbIn[2];
        prgb2End = (PRGBL)((LPBYTE)prgb2 + cbrgbY);

        DBGP_IF(DBGP_PSD,
                DBGP("pSD[%3ld]=%4ld, Flags=0x%04lx"
                    ARGDW(pSD - (PSHRINKDATA)(AAHdr.pAAInfoCY->pAAData) - 1)
                    ARGDW(Mul & DI_NUM_MASK) ARGDW(Mul & ~DI_NUM_MASK)));

        SrkYDIB_SrkCX(AAHdr.pAAInfoCX,
                      GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                      pICur = AAHdr.pInputBeg);

        if (Mul & SDF_DONE) {

            //
            // Build current Mul Table
            //

            LargeInc  = GET_SDF_LARGE_INC(Mul);
            Mul      &= SDF_MUL_MASK;
            pMap      = pMapMul;
            rgbT.r    = -(LONG)Mul;
            rgbT.b    = (LONG)(pMap256Y[1] - Mul + LargeInc);
            rgbT.g    = -rgbT.b;

            do {

                pMap[  0] = (rgbT.r += Mul);
                pMap[256] = (rgbT.g += rgbT.b);

            } while (++pMap < pMapMul2);

            //
            // Finished a scanline, so to see if have prev/next to sharpen with
            //

            prgbIn[3]    =
            prgb0        = prgbIn[0];
            prgb1        = prgbIn[1];
            prgb1End     = (PRGBL)((LPBYTE)prgb1 + cbrgbY);
            *(prgb1End ) = *(prgb1End - 1);
            pOCur        = (PBGR8)AAHdr.pAABufBeg;

            if (cPLCX) {

                rgbIn         = *pICur++;
                (prgb2  )->r += pMapMul[rgbIn.r      ];
                (prgb2  )->g += pMapMul[rgbIn.g      ];
                (prgb2++)->b += pMapMul[rgbIn.b      ];
                (prgb0  )->r  = pMapMul[rgbIn.r + 256];
                (prgb0  )->g  = pMapMul[rgbIn.g + 256];
                (prgb0++)->b  = pMapMul[rgbIn.b + 256];
                ++prgb1;

            } else {

                *(prgb1 - 1) = *prgb1;
            }

            do {

                rgbIn         = *pICur++;
                (prgb2  )->r += pMapMul[rgbIn.r];
                (prgb2  )->g += pMapMul[rgbIn.g];
                (prgb2  )->b += pMapMul[rgbIn.b];

                SHARPEN_PRGB_LRTB(pOCur, prgb0, prgb1, prgb2, DI_R_SHIFT);

                (prgb0  )->r  = pMapMul[rgbIn.r + 256];
                (prgb0  )->g  = pMapMul[rgbIn.g + 256];
                (prgb0++)->b  = pMapMul[rgbIn.b + 256];

                ++prgb1;
                ++prgb2;

            } while (((LPBYTE)pOCur += AAHdr.AABufInc) !=
                                                    (LPBYTE)AAHdr.pAABufEnd);

            if (prgb2 < prgb2End) {

                rgbIn       = *pICur;
                (prgb2)->r += pMapMul[rgbIn.r      ];
                (prgb2)->g += pMapMul[rgbIn.g      ];
                (prgb2)->b += pMapMul[rgbIn.b      ];
                (prgb0)->r  = pMapMul[rgbIn.r + 256];
                (prgb0)->g  = pMapMul[rgbIn.g + 256];
                (prgb0)->b  = pMapMul[rgbIn.b + 256];
            }

            prgbIn[0] = prgbIn[1];
            prgbIn[1] = prgbIn[2];
            prgbIn[2] = prgbIn[3];

            OUTPUT_AA_CURSCAN;

            ++cyOut;

        } else {

            pMap = (PLONG)((LPBYTE)pMap256Y + GET_SDF_LARGE_OFF(Mul));

            do {

                prgb2->r += pMap[(pICur  )->r];
                prgb2->g += pMap[(pICur  )->g];
                prgb2->b += pMap[(pICur++)->b];

            } while (++prgb2 < prgb2End);
        }
    }

    if (AAHdr.DstSurfInfo.pb != AAHdr.pOutLast) {

        //
        // Do the last line if exist
        //

        prgb0         = prgbIn[0];
        prgb1         = prgbIn[1];
        prgb1End      = (PRGBL)((LPBYTE)prgb1 + cbrgbY);
        *(prgb1End )  = *(prgb1End - 1);
        pOCur         = (PBGR8)AAHdr.pAABufBeg;

        *(prgb1 - 1)  = *prgb1;
        prgb0        += cPLCX;
        prgb1        += cPLCX;

        do {

            SHARPEN_PRGB_LRTB(pOCur, prgb0, prgb1, prgb1, DI_R_SHIFT);

            ++prgb0;
            ++prgb1;

        } while (((LPBYTE)pOCur += AAHdr.AABufInc) != (LPBYTE)AAHdr.pAABufEnd);

        OUTPUT_AA_CURSCAN;

        ++cyOut;
    }

    ASSERTMSG("Shrink: cScan not equal", cyOut == AAHdr.DstSurfInfo.cy);

    return(cyOut);
}




PBGR8
HTENTRY
SharpenInput(
    DWORD   AAHFlags,
    PBGR8   pbgrS,
    PBGR8   pbgr0,
    PBGR8   pbgr1,
    PBGR8   pbgr2,
    LONG    cbBGRIn
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    24-Apr-1998 Fri 15:06:58 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PBGR8   pSBeg;
    PBGR8   pSEnd;
    PBGR8   pbgr1End;


    pSBeg    = pbgrS;
    pSEnd    = (PBGR8)((LPBYTE)pbgrS + cbBGRIn);
    pbgr1End = (PBGR8)((LPBYTE)pbgr1 + cbBGRIn);

    if (AAHFlags & AAHF_BBPF_AA_OFF) {

        pSBeg = pbgr1;
        pSEnd = pbgr1End;

    } else {

        *(pbgr1 - 1) = *pbgr1;
        *pbgr1End    = *(pbgr1End - 1);

#if defined(_X86_)

        _asm {

            push    ebp

            cld

            mov     edi, pbgrS
            mov     ebx, pbgr0
            mov     esi, pbgr1
            mov     edx, pbgr2
            mov     ebp, pbgr1End
            jmp     DoLoop

Special1:
            shr     eax, 24
            not     al
            jmp     StoreClr1
Special2:
            shr     eax, 24
            not     al
            jmp     StoreClr2
Special3:
            shr     eax, 24
            not     al
            jmp     StoreClr3

DoLoop:
            movzx   eax, BYTE PTR [esi]
            lea     eax, [eax * 2 + eax]
            shl     eax, 2
            movzx   ecx, BYTE PTR [esi - 3]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [esi + 3]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [ebx]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [edx]
            sub     eax, ecx

            sar     eax, 3
            or      ah, ah
            jnz     Special1
StoreClr1:
            stosb
            movzx   eax, BYTE PTR [esi + 1]
            lea     eax, [eax * 2 + eax]
            shl     eax, 2
            movzx   ecx, BYTE PTR [esi - 3 + 1]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [esi + 3 + 1]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [ebx + 1]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [edx + 1]
            sub     eax, ecx

            sar     eax, 3
            or      ah, ah
            jnz     Special2
StoreClr2:
            stosb
            movzx   eax, BYTE PTR [esi + 2]
            lea     eax, [eax * 2 + eax]
            shl     eax, 2
            movzx   ecx, BYTE PTR [esi - 3 + 2]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [esi + 3 + 2]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [ebx + 2]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [edx + 2]
            sub     eax, ecx

            sar     eax, 3
            or      ah, ah
            jnz     Special3
StoreClr3:
            stosb

            add     ebx, 3
            add     edx, 3
            add     esi, 3

            cmp     esi, ebp
            jb      DoLoop

            pop     ebp
        }

#else
        while (pbgr1 < pbgr1End) {

            SHARPEN_PRGB_LRTB(pbgrS, pbgr0, pbgr1, pbgr2, 0);

            ++pbgrS;
            ++pbgr0;
            ++pbgr1;
            ++pbgr2;
        }
#endif
    }

    *(pSBeg - 3) =
    *(pSBeg - 2) =
    *(pSBeg - 1) = *pSBeg;
    *(pSEnd    ) =
    *(pSEnd + 1) = *(pSEnd - 1);

    return(pSBeg);
}




VOID
HTENTRY
ExpandDIB_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAINFO      AAI = *pAAInfo;
    PBGR8       pInEnd;
    PEXPDATA    pED;
    BGR8        rgbIn[8];
    RGBL        rgbOut;
    UINT        cPreLoad;
    UINT        cAAData;
    UINT        Idx;


    pInEnd        = pIn + AAI.cIn + 2;
    *(pInEnd - 0) =
    *(pInEnd - 1) =
    *(pInEnd - 2) = *(pInEnd - 3);
    rgbIn[5]      = *pIn;
    INC_PIN_BY_1ST_LEFT(pIn, AAI.Flags);

    rgbIn[6] = *pIn++;
    cPreLoad = (UINT)AAI.cPreLoad;
    cAAData  = (UINT)(cPreLoad >> 4);

    if ((!(cPreLoad &= 0x0F)) && (cAAData)) {

        rgbIn[6] = rgbIn[5];
        ++cPreLoad;
        --cAAData;
        --pIn;
    }

    Idx = 4 - cPreLoad;

    while (cPreLoad--) {

        CopyMemory(&rgbIn[0], &rgbIn[1], sizeof(rgbIn[0]) * 6);

        rgbIn[6] = *pIn++;

        if (AAI.Flags & AAIF_EXP_NO_SHARPEN) {

            rgbIn[3] = rgbIn[5];

        } else {

            SHARPEN_RGB_LR(rgbIn[3], rgbIn[4], rgbIn[5], rgbIn[6], 0);
        }

        DBGP_IF(DBGP_EXP, DBGP("ExpDIB: PreLoad=%ld, pIn=%8lx"
                                        ARGDW(cPreLoad) ARGPTR(pIn)));
    }

    rgbIn[7] = rgbIn[Idx--];

    while (cAAData--) {

        rgbIn[Idx--] = rgbIn[7];
    }

    pED         = (PEXPDATA)(AAI.pAAData);
    pOutEnd    += OutInc;

    do {

        EXPDATA ed = *pED++;


        if (ed.Mul[0] & EDF_LOAD_PIXEL) {

            CopyMemory(&rgbIn[0], &rgbIn[1], sizeof(rgbIn[0]) * 6);

            rgbIn[6] = *pIn++;

            if (AAI.Flags & AAIF_EXP_NO_SHARPEN) {

                rgbIn[3] = rgbIn[5];

            } else {

                SHARPEN_RGB_LR(rgbIn[3], rgbIn[4], rgbIn[5], rgbIn[6], 0);
            }

            ed.Mul[0] &= ~(EDF_LOAD_PIXEL | EDF_NO_NEWSRC);
        }

        rgbOut.r = MULRGB(rgbIn[3].r, ed.Mul[3]);
        rgbOut.g = MULRGB(rgbIn[3].g, ed.Mul[3]);
        rgbOut.b = MULRGB(rgbIn[3].b, ed.Mul[3]);

        if (ed.Mul[2]) {

            rgbOut.r += MULRGB(rgbIn[2].r, ed.Mul[2]);
            rgbOut.g += MULRGB(rgbIn[2].g, ed.Mul[2]);
            rgbOut.b += MULRGB(rgbIn[2].b, ed.Mul[2]);

            if (ed.Mul[1]) {

                rgbOut.r += MULRGB(rgbIn[1].r, ed.Mul[1]);
                rgbOut.g += MULRGB(rgbIn[1].g, ed.Mul[1]);
                rgbOut.b += MULRGB(rgbIn[1].b, ed.Mul[1]);

                if (ed.Mul[0]) {

                    rgbOut.r += MULRGB(rgbIn[0].r, ed.Mul[0]);
                    rgbOut.g += MULRGB(rgbIn[0].g, ed.Mul[0]);
                    rgbOut.b += MULRGB(rgbIn[0].b, ed.Mul[0]);
                }
            }
        }

        RGB_DIMAX_TO_BYTE(pOut, rgbOut, pOut);

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);

    ASSERT(pIn <= pInEnd);
}




VOID
HTENTRY
ExpYDIB_ExpCX(
    PEXPDATA    pED,
    PBGR8       pIn,
    PBGR8       pOut,
    PBGR8       pOutEnd
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    RGBL        rgbOut;

    do {

        UINT    Mul;
        EXPDATA ed = *pED++;


        INC_PIN_BY_EDF_LOAD_PIXEL(pIn, ed.Mul[0]);

        Mul      = (UINT)ed.Mul[3];
        rgbOut.r = MULRGB(pIn->r, Mul);
        rgbOut.g = MULRGB(pIn->g, Mul);
        rgbOut.b = MULRGB(pIn->b, Mul);

        if (Mul = (UINT)ed.Mul[2]) {

            rgbOut.r += MULRGB((pIn - 1)->r, Mul);
            rgbOut.g += MULRGB((pIn - 1)->g, Mul);
            rgbOut.b += MULRGB((pIn - 1)->b, Mul);

            if (Mul = (UINT)ed.Mul[1]) {

                rgbOut.r += MULRGB((pIn - 2)->r, Mul);
                rgbOut.g += MULRGB((pIn - 2)->g, Mul);
                rgbOut.b += MULRGB((pIn - 2)->b, Mul);

                if (Mul = (UINT)(ed.Mul[0] & ~(EDF_LOAD_PIXEL |
                                               EDF_NO_NEWSRC))) {

                    rgbOut.r += MULRGB((pIn - 3)->r, Mul);
                    rgbOut.g += MULRGB((pIn - 3)->g, Mul);
                    rgbOut.b += MULRGB((pIn - 3)->b, Mul);
                }
            }
        }

        RGB_DIMAX_TO_BYTE(pOut, rgbOut, pOut);

    } while (++pOut != pOutEnd);
}



LONG
HTENTRY
ExpandDIB_CY_ExpCX(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:

    This funtion anti-alias the bitmap by query scanlines from CX direction
    (may be Shrink(CX) or Expand(CX)) then compose current scanlines and output
    it to real BGR8 final buffer,

    The complication is need to have scanline one before current destination
    scanline, this may be because the source is not available or because the
    clipping is done on destination.

    Since the anti-alias for expanding requred at least four surounding
    scanlines to compose current scanline, it required large amount of
    memory to retain the prevous result scanlines

    The expanding is by sharpen the source pixel first before anti-aliasing
    smooth through

    prgbIn[0] - Previous un-sharpen source scan
                AND Last The 4th composition sharpened scan after sharpen
    prgbIn[1] - Current un-sharpen source scan
    prgbIn[2] - Next un-sharpen source scan
    prgbIn[3] - The 1st composition sharpened scan
    prgbIn[4] - The 2nd composition sharpened scan
    prgbIn[5] - The 3rd composition sharpened scan


    Exp=Load Sharpen Exp
    Srk=Load Srk Sharpen
    Cpy=Load Cpy


    Exp_CY:Exp_CX   Exp_CX:(LoadX SharpenX     ExpX) SharpenY ExpY
    Exp_CY:Srk_CX   Srk_CX:(LoadX     SrkX SharpenX) SharpenY ExpY
    Exp_CY:Cpy_CX   Cpy_CX:(LoadX     CpyX         ) SharpenY ExpY

    Srk_CY:Exp_CX   InputCX SrkY SharpenY Exp_CX:(LoadX SharpenX     ExpX)
    Srk_CY:Srk_CX   InputCX SrkY SharpenY Srk_CX:(LoadX     SrkX SharpenX)
    Srk_CY:Cpy_CX   InputCX SrkY SharpenY Cpy_CX:(LoadX     CpyX         )

    Cpy_CY:Exp_CX   Exp_CX:(LoadX SharpenX     ExpX)
    Cpy_CY:Srk_CX   Srk_CX:(LoadX     SrkX SharpenX)
    Cpy_CY:Cpy_CX   Cpy_CX:(LoadX     CpyX         )



Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER    AAHdr = *pAAHdr;
    PAAINFO     pAAInfo;
    PEXPDATA    pED;
    PEXPDATA    pEDCX;
    PBGR8       prgbOut[4];
    PBGR8       prgbS;
    PLONG       pMap;
    PLONG       pMap0;
    PLONG       pMap0End;
    PBGR8       prgbIn0;
    PBGR8       prgbIn1;
    PBGR8       prgbIn2;
    PBGR8       prgb0;
    PBGR8       prgb1;
    PBGR8       prgb2;
    PBGR8       prgb3;
    PBGR8       pOCur;
    EXPDATA     ed;
    LONG        cb1stSharpen;
    LONG        cbrgbY;
    LONG        cbrgbIn;
    LONG        cAAData;
    LONG        cPreLoad;
    UINT        IdxOut;

    //
    // Figure out the horizontal scan line increment
    //

    pAAInfo  = AAHdr.pAAInfoCX;
    cPreLoad = (LONG)(pAAInfo->cPreLoad & 0x0F) - 1 +
               (LONG)((pAAInfo->Flags & AAIF_EXP_HAS_1ST_LEFT) ? 1 : 0);

    pEDCX        = (PEXPDATA)(pAAInfo->pAAData);
    pAAInfo      = AAHdr.pAAInfoCY;
    pMap0        = (PLONG)pAAInfo->pbExtra;
    pMap0End     = pMap0 + 256;
    cbrgbIn      = AAHdr.SrcSurfInfo.cx * sizeof(BGR8);
    cbrgbY       = AAHdr.DstSurfInfo.cx * sizeof(BGR8);
    prgbOut[0]   = (PBGR8)(pMap0 + (256 * 4));
    prgbOut[1]   = (PBGR8)((LPBYTE)prgbOut[0] + cbrgbY);
    prgbOut[2]   = (PBGR8)((LPBYTE)prgbOut[1] + cbrgbY);
    prgbOut[3]   = (PBGR8)((LPBYTE)prgbOut[2] + cbrgbY);
    prgbIn0      = (PBGR8)((LPBYTE)prgbOut[3] + cbrgbY) + 3;
    prgbIn1      = (PBGR8)((LPBYTE)prgbIn0    + cbrgbIn) + 6;
    prgbIn2      = (PBGR8)((LPBYTE)prgbIn1    + cbrgbIn) + 6;
    prgbS        = AAHdr.pInputBeg + 3;
    cb1stSharpen = (LONG)(sizeof(BGR8) * cPreLoad);
    IdxOut     = ~0;

    DBGP_IF(DBGP_AAHT_MEM,
            DBGP("prgbIn=%p:%p:%p, prgbOut=%p:%p:%p:%p, prgbS=%p, cb1stSharpen=%ld"
                ARGPTR(prgbIn0) ARGPTR(prgbIn1) ARGPTR(prgbIn2)
                ARGPTR(prgbOut[0]) ARGPTR(prgbOut[1]) ARGPTR(prgbOut[2])
                ARGPTR(prgbOut[3]) ARGPTR(prgbS) ARGDW(cb1stSharpen)));

    //
    // Always read first source
    //

    DBGP_IF(DBGP_EXPAND, DBGP("\nExpand: PRE-LOAD FIRST SCAN"));

    GetFixupScan(&AAHdr, prgbIn1);

    if (pAAInfo->Flags & AAIF_EXP_HAS_1ST_LEFT) {

        DBGP_IF(DBGP_EXPAND, DBGP("Expand: LOAD FIRST LEFT"));

        GetFixupScan(&AAHdr, prgbIn2);

    } else {

        DBGP_IF(DBGP_EXPAND, DBGP("Expand: COPY FIRST LEFT"));

        CopyMemory(prgbIn2, prgbIn1, cbrgbIn);
    }

    //
    // cPreLoad: Low 4 bits means real load, high 4 bit means imaginary load
    //

    DBGP_IF(DBGP_EXPAND,
        DBGP("cPreLoad=%02lx: AAData[0]=%6ld:%6ld:%6ld:%6ld, %hs"
                ARGDW(pAAInfo->cPreLoad)
                ARGDW(((PEXPDATA)(pAAInfo->pAAData))->Mul[0] &
                            ~(EDF_LOAD_PIXEL | EDF_NO_NEWSRC))
                ARGDW(((PEXPDATA)(pAAInfo->pAAData))->Mul[1])
                ARGDW(((PEXPDATA)(pAAInfo->pAAData))->Mul[2])
                ARGDW(((PEXPDATA)(pAAInfo->pAAData))->Mul[3])
                ARGPTR((((PEXPDATA)(pAAInfo->pAAData))->Mul[0] & EDF_LOAD_PIXEL) ?
                        "Load Pixel" : "")));

    cPreLoad = (LONG)pAAInfo->cPreLoad;
    cAAData  = (LONG)(cPreLoad >> 4);
    cPreLoad = (cPreLoad & 0x0F) + cAAData;

    while (cPreLoad--) {

        //
        // Scroll up one input scan line
        //

        prgb0   = prgbIn0;
        prgbIn0 = prgbIn1;
        prgbIn1 = prgbIn2;
        prgbIn2 = prgb0;
        prgb3   = prgbOut[++IdxOut & 0x03];

        if (cAAData-- > 0) {

            DBGP_IF(DBGP_EXPAND,
                    DBGP("FAKE SCAN: cPreLoad=%ld/cAAData=%ld, Compose IdxOut=%ld"
                            ARGDW(cPreLoad + 1) ARGDW(cAAData + 1)
                            ARGDW(IdxOut & 0x03)));

            CopyMemory(prgbIn2, prgbIn1, cbrgbIn);

        } else {

            DBGP_IF(DBGP_EXPAND,
                    DBGP("REAL SCAN: cPreLoad=%ld, Compose IdxOut=%ld"
                            ARGDW(cPreLoad + 1) ARGDW(IdxOut & 0x03)));

            GetFixupScan(&AAHdr, prgbIn2);
        }

        prgbS = SharpenInput(AAHdr.Flags,
                             prgbS,
                             prgbIn0,
                             prgbIn1,
                             prgbIn2,
                             cbrgbIn);

        ExpYDIB_ExpCX(pEDCX,
                      (PBGR8)((LPBYTE)prgbS + cb1stSharpen),
                      prgb3,
                      (PBGR8)((LPBYTE)prgb3 + cbrgbY));
    }

    pED     = (PEXPDATA)(pAAInfo->pAAData);
    cAAData = pAAInfo->cAAData;

    while (cAAData--) {

        LONG    Mul0;
        LONG    Mul1;
        LONG    Mul2;
        LONG    Mul3;


        ed = *pED++;

        if (ed.Mul[0] & EDF_LOAD_PIXEL) {

            prgb0   = prgbIn0;
            prgbIn0 = prgbIn1;
            prgbIn1 = prgbIn2;
            prgbIn2 = GetFixupScan(&AAHdr, prgb0);
            prgbS   = SharpenInput(AAHdr.Flags,
                                   prgbS,
                                   prgbIn0,
                                   prgbIn1,
                                   prgbIn2,
                                   cbrgbIn);

            prgb3   = prgbOut[++IdxOut & 0x03];

            ExpYDIB_ExpCX(pEDCX,
                          (PBGR8)((LPBYTE)prgbS + cb1stSharpen),
                          prgb3,
                          (PBGR8)((LPBYTE)prgb3 + cbrgbY));

            ed.Mul[0] &= ~(EDF_LOAD_PIXEL | EDF_NO_NEWSRC);
        }

        //
        // Build Mul Table here
        //

        pMap  = pMap0;
        Mul0  = -ed.Mul[0];
        Mul1  = -ed.Mul[1];
        Mul2  = -ed.Mul[2];
        Mul3  = -ed.Mul[3];
        prgb3 = prgbOut[(IdxOut    ) & 0x03];
        prgb2 = prgbOut[(IdxOut - 1) & 0x03];
        pOCur = (PBGR8)AAHdr.pAABufBeg;

        if (ed.Mul[0]) {

            prgb1 = prgbOut[(IdxOut - 2) & 0x03];
            prgb0 = prgbOut[(IdxOut - 3) & 0x03];

            GET_EXP_PC(PMAP_EXP4, GET_EXP4, INC_EXP4, pOCur);

        } else if (ed.Mul[1]) {

            prgb1 = prgbOut[(IdxOut - 2) & 0x03];

            GET_EXP_PC(PMAP_EXP3, GET_EXP3, INC_EXP3, pOCur);

        } else if (ed.Mul[2]) {

            GET_EXP_PC(PMAP_EXP2, GET_EXP2, INC_EXP2, pOCur);

        } else {

            GET_EXP_PC(PMAP_EXP1, GET_EXP1, INC_EXP1, pOCur);
        }

        OUTPUT_AA_CURSCAN;
    }

    return(AAHdr.DstSurfInfo.cy);
}




LONG
HTENTRY
ExpandDIB_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:

    This funtion anti-alias the bitmap by query scanlines from CX direction
    (may be Shrink(CX) or Expand(CX)) then compose current scanlines and output
    it to real BGR8 final buffer,

    The complication is need to have scanline one before current destination
    scanline, this may be because the source is not available or because the
    clipping is done on destination.

    Since the anti-alias for expanding requred at least four surounding
    scanlines to compose current scanline, it required large amount of
    memory to retain the prevous result scanlines

    The expanding is by sharpen the source pixel first before anti-aliasing
    smooth through

    prgbIn[0] - Previous un-sharpen source scan
                AND Last The 4th composition sharpened scan after sharpen
    prgbIn[1] - Current un-sharpen source scan
    prgbIn[2] - Next un-sharpen source scan
    prgbIn[3] - The 1st composition sharpened scan
    prgbIn[4] - The 2nd composition sharpened scan
    prgbIn[5] - The 3rd composition sharpened scan


    Exp=Load Sharpen Exp
    Srk=Load Srk Sharpen
    Cpy=Load Cpy


    Exp_CY:Exp_CX   Exp_CX:(LoadX SharpenX     ExpX) SharpenY ExpY
    Exp_CY:Srk_CX   Srk_CX:(LoadX     SrkX SharpenX) SharpenY ExpY
    Exp_CY:Cpy_CX   Cpy_CX:(LoadX     CpyX         ) SharpenY ExpY

    Srk_CY:Exp_CX   InputCX SrkY SharpenY Exp_CX:(LoadX SharpenX     ExpX)
    Srk_CY:Srk_CX   InputCX SrkY SharpenY Srk_CX:(LoadX     SrkX SharpenX)
    Srk_CY:Cpy_CX   InputCX SrkY SharpenY Cpy_CX:(LoadX     CpyX         )

    Cpy_CY:Exp_CX   Exp_CX:(LoadX SharpenX     ExpX)
    Cpy_CY:Srk_CX   Srk_CX:(LoadX     SrkX SharpenX)
    Cpy_CY:Cpy_CX   Cpy_CX:(LoadX     CpyX         )



Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER    AAHdr = *pAAHdr;
    PEXPDATA    pED;
    PBGR8       prgbIn[6];
    PLONG       pMap;
    PLONG       pMap0;
    PLONG       pMap0End;
    PBGR8       prgb0;
    PBGR8       prgb1;
    PBGR8       prgb2;
    PBGR8       prgb3;
    PBGR8       prgb4;
    PBGR8       prgb5;
    PBGR8       pOCur;
    LPBYTE      prgbYEnd;
    LONG        cbrgbY;
    LONG        cAAData;
    LONG        cPreLoad;


    pMap0      = (PLONG)AAHdr.pAAInfoCY->pbExtra;
    pMap0End   = pMap0 + 256;
    cbrgbY     = (AAHdr.DstSurfInfo.cx + 6) * (LONG)sizeof(BGR8);
    prgbIn[0]  = (PBGR8)(pMap0 + (256 * 4)) + 3;
    prgbIn[1]  = (PBGR8)((LPBYTE)prgbIn[0] + cbrgbY);
    prgbIn[2]  = (PBGR8)((LPBYTE)prgbIn[1] + cbrgbY);
    prgbIn[3]  = (PBGR8)((LPBYTE)prgbIn[2] + cbrgbY);
    prgbIn[4]  = (PBGR8)((LPBYTE)prgbIn[3] + cbrgbY);
    prgbIn[5]  = (PBGR8)((LPBYTE)prgbIn[4] + cbrgbY);
    cbrgbY    -= (sizeof(BGR8) * 6);

    //
    // Always read first source
    //

    DBGP_IF(DBGP_EXPAND, DBGP("\nLoad First Scan"));

    AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                   GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                   prgbIn[4],
                   (LPBYTE)prgbIn[4] + cbrgbY,
                   sizeof(BGR8));


    //
    // Load the PRE-SOURCE LEFT first source first
    //

    if (AAHdr.pAAInfoCY->Flags & AAIF_EXP_HAS_1ST_LEFT) {

        AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                       GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                       prgbIn[5],
                       (LPBYTE)prgbIn[5] + cbrgbY,
                       sizeof(BGR8));

        DBGP_IF(DBGP_EXPAND, DBGP("Load First Left"));

    } else {

        CopyMemory(prgbIn[5], prgbIn[4], cbrgbY);

        DBGP_IF(DBGP_EXPAND, DBGP("Copy First Left"));
    }

    cPreLoad = (LONG)AAHdr.pAAInfoCY->cPreLoad;
    cAAData  = (LONG)(cPreLoad >> 4);
    cPreLoad = (cPreLoad & 0x0F) + cAAData;

    while (cPreLoad--) {

        //
        // Scroll up prgbIn by one scan
        //

        prgb5 = prgbIn[0];

        CopyMemory(&prgbIn[0], &prgbIn[1], sizeof(prgbIn[0]) * 5);

        prgbIn[5] = prgb5;
        prgb3     = prgbIn[3];
        prgb4     = prgbIn[4];
        prgb5     = prgbIn[5];
        prgbYEnd  = (LPBYTE)prgb5 + cbrgbY;

        if (cAAData-- > 0) {

            DBGP_IF(DBGP_EXPAND,
                    DBGP("FAKE SCAN: cPreLoad=%ld/cAAData=%ld"
                            ARGDW(cPreLoad + 1) ARGDW(cAAData + 1)));

            CopyMemory(prgb5, prgb4, cbrgbY);

        } else {

            DBGP_IF(DBGP_EXPAND,
                    DBGP("REAL SCAN: cPreLoad=%ld/cAAData=%ld"
                            ARGDW(cPreLoad + 1) ARGDW(cAAData + 1)));

            AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                           GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                           prgb5,
                           prgbYEnd,
                           sizeof(BGR8));
        }

        DBGP_IF(DBGP_EXPAND,
                DBGP("Compose Sharpen Scan=%ld" ARGDW(cPreLoad + 1)));

        //
        // Now, let's sharpen the input
        //

        if (AAHdr.Flags & AAHF_BBPF_AA_OFF) {

            CopyMemory(prgb3, prgb4, cbrgbY);

        } else {

            do {

                SHARPEN_PRGB_LR(prgb3, (*prgb3), (*prgb4), (*prgb5), 0);

                prgb3++;
                prgb4++;

            } while (++prgb5 < (PBGR8)prgbYEnd);
        }
    }

    pED      = (PEXPDATA)(AAHdr.pAAInfoCY->pAAData);
    cAAData  = AAHdr.pAAInfoCY->cAAData;

    while (cAAData--) {

        EXPDATA ed = *pED++;
        LONG    Mul0;
        LONG    Mul1;
        LONG    Mul2;
        LONG    Mul3;


        if (ed.Mul[0] & EDF_LOAD_PIXEL) {

            prgb5 = prgbIn[0];

            CopyMemory(&prgbIn[0], &prgbIn[1], sizeof(prgbIn[0]) * 5);

            prgbIn[5] = prgb5;
            prgb3     = prgbIn[3];
            prgb4     = prgbIn[4];
            prgb5     = prgbIn[5];
            prgbYEnd  = (LPBYTE)prgb5 + cbrgbY;

            AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                           GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                           prgb5,
                           prgbYEnd,
                           sizeof(BGR8));

            if (AAHdr.Flags & AAHF_BBPF_AA_OFF) {

                CopyMemory(prgb3, prgb4, cbrgbY);

            } else {

                do {

                    SHARPEN_PRGB_LR(prgb3, (*prgb3), (*prgb4), (*prgb5), 0);

                    prgb3++;
                    prgb4++;

                } while (++prgb5 < (PBGR8)prgbYEnd);
            }

            ed.Mul[0] &= ~(EDF_LOAD_PIXEL | EDF_NO_NEWSRC);
        }

        //
        // Build Mul Table here
        //

        pMap  = pMap0;
        Mul0  = -ed.Mul[0];
        Mul1  = -ed.Mul[1];
        Mul2  = -ed.Mul[2];
        Mul3  = -ed.Mul[3];
        prgb3 = prgbIn[3];
        prgb2 = prgbIn[2];
        pOCur = (PBGR8)AAHdr.pAABufBeg;

        if (ed.Mul[0]) {

            prgb1 = prgbIn[1];
            prgb0 = prgbIn[0];

            GET_EXP_PC(PMAP_EXP4, GET_EXP4, INC_EXP4, pOCur);

        } else if (ed.Mul[1]) {

            prgb1 = prgbIn[1];

            GET_EXP_PC(PMAP_EXP3, GET_EXP3, INC_EXP3, pOCur);

        } else if (ed.Mul[2]) {

            GET_EXP_PC(PMAP_EXP2, GET_EXP2, INC_EXP2, pOCur);

        } else {

            GET_EXP_PC(PMAP_EXP1, GET_EXP1, INC_EXP1, pOCur);
        }

        OUTPUT_AA_CURSCAN;
    }

    return(AAHdr.DstSurfInfo.cy);
}


//
// Monochrome routine
//


LPBYTE
HTENTRY
GraySharpenInput(
    DWORD   AAHFlags,
    LPBYTE  pbS,
    LPBYTE  pb0,
    LPBYTE  pb1,
    LPBYTE  pb2,
    LONG    cbIn
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    24-Apr-1998 Fri 15:06:58 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPBYTE   pSBeg;
    LPBYTE   pSEnd;
    LPBYTE   pb1End;


    pSBeg  = pbS;
    pSEnd  = (LPBYTE)((LPBYTE)pbS + cbIn);
    pb1End = (LPBYTE)((LPBYTE)pb1 + cbIn);

    if (AAHFlags & AAHF_BBPF_AA_OFF) {

        pSBeg = pb1;
        pSEnd = pb1End;

    } else {

        *(pb1 - 1) = *pb1;
        *pb1End    = *(pb1End - 1);

#if defined(_X86_)

        _asm {


            cld

            mov     edi, pbS
            mov     ebx, pb0
            mov     esi, pb1
            mov     edx, pb2
            mov     eax, cbIn
            shr     eax, 2
            jz      DoneLoop1
            push    ebp
            mov     ebp, eax
            jmp     DoLoop1

DoSP1:      shr     eax, 24
            not     al
            jmp     StoreClr1

DoSP2:      shr     eax, 24
            not     al
            jmp     StoreClr2

DoSP3:      shr     eax, 24
            not     al
            jmp     StoreClr3

DoSP4:      shr     eax, 24
            not     al
            jmp     StoreClr4
DoLoop1:
            movzx   eax, BYTE PTR [esi]
            lea     eax, [eax * 2 + eax]
            shl     eax, 2
            movzx   ecx, BYTE PTR [esi - 1]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [esi + 1]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [ebx]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [edx]
            sub     eax, ecx
            sar     eax, 3
            or      ah, ah
            jnz     DoSP1
StoreClr1:
            stosb
            movzx   eax, BYTE PTR [esi + 1]
            lea     eax, [eax * 2 + eax]
            shl     eax, 2
            movzx   ecx, BYTE PTR [esi - 1 + 1]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [esi + 1 + 1]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [ebx + 1]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [edx + 1]
            sub     eax, ecx
            sar     eax, 3
            or      ah, ah
            jnz     DoSP2
StoreClr2:
            stosb
            movzx   eax, BYTE PTR [esi + 2]
            lea     eax, [eax * 2 + eax]
            shl     eax, 2
            movzx   ecx, BYTE PTR [esi - 1 + 2]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [esi + 1 + 2]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [ebx + 2]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [edx + 2]
            sub     eax, ecx
            sar     eax, 3
            or      ah, ah
            jnz     DoSP3
StoreClr3:
            stosb
            movzx   eax, BYTE PTR [esi + 3]
            lea     eax, [eax * 2 + eax]
            shl     eax, 2
            movzx   ecx, BYTE PTR [esi - 1 + 3]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [esi + 1 + 3]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [ebx + 3]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [edx + 3]
            sub     eax, ecx
            sar     eax, 3
            or      ah, ah
            jnz     DoSP4
StoreClr4:
            stosb
            add     ebx, 4
            add     edx, 4
            add     esi, 4
            dec     ebp
            jnz     DoLoop1
            pop     ebp
DoneLoop1:
            mov     eax, cbIn
            and     eax, 3
            jz      DoneLoop2
            push    ebp
            mov     ebp, eax
            jmp     DoLoop2

DoSP5:      shr     eax, 24
            not     al
            jmp     StoreClr5
DoLoop2:
            movzx   eax, BYTE PTR [esi]
            lea     eax, [eax * 2 + eax]
            shl     eax, 2
            movzx   ecx, BYTE PTR [esi - 1]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [esi + 1]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [ebx]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [edx]
            sub     eax, ecx
            sar     eax, 3
            or      ah, ah
            jnz     DoSP5
StoreClr5:
            stosb
            inc     esi
            inc     ebx
            inc     edx
            dec     ebp
            jnz     DoLoop2
            pop     ebp
DoneLoop2:
        }

#else
        while (pb1 < pb1End) {

            SHARPEN_PB_LRTB(pbS, pb0, pb1, pb2, 0);

            ++pbS;
            ++pb0;
            ++pb1;
            ++pb2;
        }
#endif
    }

    *(pSBeg - 3) =
    *(pSBeg - 2) =
    *(pSBeg - 1) = *pSBeg;
    *(pSEnd    ) =
    *(pSEnd + 1) = *(pSEnd - 1);

    return(pSBeg);
}



VOID
HTENTRY
GrayCopyDIB_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    LPBYTE  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    26-Jun-1998 Fri 11:33:20 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    do {

        *pOut = *pIn++;

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);
}



VOID
HTENTRY
GrayExpYDIB_ExpCX(
    PEXPDATA    pED,
    LPBYTE      pIn,
    LPBYTE      pOut,
    LPBYTE      pOutEnd
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    do {

        EXPDATA ed = *pED++;
        LONG    Gray;
        UINT    Mul;


        INC_PIN_BY_EDF_LOAD_PIXEL(pIn, ed.Mul[0]);

        Mul  = (UINT)ed.Mul[3];
        Gray = MULRGB(*pIn, Mul);

        if (Mul = (UINT)ed.Mul[2]) {

            Gray += MULRGB(*(pIn - 1), Mul);

            if (Mul = (UINT)ed.Mul[1]) {

                Gray += MULRGB(*(pIn - 2), Mul);

                if (Mul = (UINT)(ed.Mul[0] & ~(EDF_LOAD_PIXEL |
                                               EDF_NO_NEWSRC))) {

                    Gray += MULRGB(*(pIn - 3), Mul);
                }
            }
        }

        GRAY_DIMAX_TO_BYTE(pOut, Gray);

    } while (++pOut != pOutEnd);
}




LONG
HTENTRY
GrayExpandDIB_CY_ExpCX(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:

    This funtion anti-alias the bitmap by query scanlines from CX direction
    (may be Shrink(CX) or Expand(CX)) then compose current scanlines and output
    it to real BGR8 final buffer,

    The complication is need to have scanline one before current destination
    scanline, this may be because the source is not available or because the
    clipping is done on destination.

    Since the anti-alias for expanding requred at least four surounding
    scanlines to compose current scanline, it required large amount of
    memory to retain the prevous result scanlines

    The expanding is by sharpen the source pixel first before anti-aliasing
    smooth through

    prgbIn[0] - Previous un-sharpen source scan
                AND Last The 4th composition sharpened scan after sharpen
    prgbIn[1] - Current un-sharpen source scan
    prgbIn[2] - Next un-sharpen source scan
    prgbIn[3] - The 1st composition sharpened scan
    prgbIn[4] - The 2nd composition sharpened scan
    prgbIn[5] - The 3rd composition sharpened scan


    Exp=Load Sharpen Exp
    Srk=Load Srk Sharpen
    Cpy=Load Cpy


    Exp_CY:Exp_CX   Exp_CX:(LoadX SharpenX     ExpX) SharpenY ExpY
    Exp_CY:Srk_CX   Srk_CX:(LoadX     SrkX SharpenX) SharpenY ExpY
    Exp_CY:Cpy_CX   Cpy_CX:(LoadX     CpyX         ) SharpenY ExpY

    Srk_CY:Exp_CX   InputCX SrkY SharpenY Exp_CX:(LoadX SharpenX     ExpX)
    Srk_CY:Srk_CX   InputCX SrkY SharpenY Srk_CX:(LoadX     SrkX SharpenX)
    Srk_CY:Cpy_CX   InputCX SrkY SharpenY Cpy_CX:(LoadX     CpyX         )

    Cpy_CY:Exp_CX   Exp_CX:(LoadX SharpenX     ExpX)
    Cpy_CY:Srk_CX   Srk_CX:(LoadX     SrkX SharpenX)
    Cpy_CY:Cpy_CX   Cpy_CX:(LoadX     CpyX         )



Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER    AAHdr = *pAAHdr;
    PAAINFO     pAAInfo;
    PEXPDATA    pED;
    PEXPDATA    pEDCX;
    LPBYTE      pbOut[4];
    LPBYTE      pbS;
    PLONG       pMap;
    PLONG       pMap0;
    PLONG       pMap0End;
    LPBYTE      pbIn0;
    LPBYTE      pbIn1;
    LPBYTE      pbIn2;
    LPBYTE      pb0;
    LPBYTE      pb1;
    LPBYTE      pb2;
    LPBYTE      pb3;
    PGRAYF      pOCur;
    EXPDATA     ed;
    LONG        cb1stSharpen;
    LONG        cbY;
    LONG        cbIn;
    LONG        cAAData;
    LONG        cPreLoad;
    UINT        IdxOut;

    //
    // Figure out the horizontal scan line increment
    //

    pAAInfo  = AAHdr.pAAInfoCX;
    cPreLoad = (LONG)(pAAInfo->cPreLoad & 0x0F) - 1 +
               (LONG)((pAAInfo->Flags & AAIF_EXP_HAS_1ST_LEFT) ? 1 : 0);

    pEDCX        = (PEXPDATA)(pAAInfo->pAAData);
    pAAInfo      = AAHdr.pAAInfoCY;
    pMap0        = (PLONG)pAAInfo->pbExtra;
    pMap0End     = pMap0 + 256;
    cbIn         = AAHdr.SrcSurfInfo.cx * sizeof(BYTE);
    cbY          = AAHdr.DstSurfInfo.cx * sizeof(BYTE);
    pbOut[0]     = (LPBYTE)(pMap0 + (256 * 4));
    pbOut[1]     = (LPBYTE)((LPBYTE)pbOut[0] + cbY);
    pbOut[2]     = (LPBYTE)((LPBYTE)pbOut[1] + cbY);
    pbOut[3]     = (LPBYTE)((LPBYTE)pbOut[2] + cbY);
    pbIn0        = (LPBYTE)((LPBYTE)pbOut[3] + cbY) + 3;
    pbIn1        = (LPBYTE)((LPBYTE)pbIn0    + cbIn) + 6;
    pbIn2        = (LPBYTE)((LPBYTE)pbIn1    + cbIn) + 6;
    pbS          = (LPBYTE)AAHdr.pInputBeg + 3;
    cb1stSharpen = (LONG)(sizeof(BYTE) * cPreLoad);
    IdxOut       = ~0;

    DBGP_IF(DBGP_AAHT_MEM,
            DBGP("pbIn=%p:%p:%p, pbOut=%p:%p:%p:%p, pbS=%p, cb1stSharpen=%ld"
                ARGPTR(pbIn0) ARGPTR(pbIn1) ARGPTR(pbIn2)
                ARGPTR(pbOut[0]) ARGPTR(pbOut[1]) ARGPTR(pbOut[2])
                ARGPTR(pbOut[3]) ARGPTR(pbS) ARGDW(cb1stSharpen)));

    //
    // Always read first source
    //

    DBGP_IF(DBGP_EXPAND, DBGP("\nExpand: PRE-LOAD FIRST SCAN"));

    GetFixupScan(&AAHdr, (PBGR8)pbIn1);

    if (pAAInfo->Flags & AAIF_EXP_HAS_1ST_LEFT) {

        DBGP_IF(DBGP_EXPAND, DBGP("Expand: LOAD FIRST LEFT"));

        GetFixupScan(&AAHdr, (PBGR8)pbIn2);

    } else {

        DBGP_IF(DBGP_EXPAND, DBGP("Expand: COPY FIRST LEFT"));

        CopyMemory(pbIn2, pbIn1, cbIn);
    }

    //
    // cPreLoad: Low 4 bits means real load, high 4 bit means imaginary load
    //

    DBGP_IF(DBGP_EXPAND,
        DBGP("cPreLoad=%02lx: AAData[0]=%6ld:%6ld:%6ld:%6ld, %hs"
                ARGDW(pAAInfo->cPreLoad)
                ARGDW(((PEXPDATA)(pAAInfo->pAAData))->Mul[0] &
                            ~(EDF_LOAD_PIXEL | EDF_NO_NEWSRC))
                ARGDW(((PEXPDATA)(pAAInfo->pAAData))->Mul[1])
                ARGDW(((PEXPDATA)(pAAInfo->pAAData))->Mul[2])
                ARGDW(((PEXPDATA)(pAAInfo->pAAData))->Mul[3])
                ARGPTR((((PEXPDATA)(pAAInfo->pAAData))->Mul[0] & EDF_LOAD_PIXEL) ?
                        "Load Pixel" : "")));

    cPreLoad = (LONG)pAAInfo->cPreLoad;
    cAAData  = (LONG)(cPreLoad >> 4);
    cPreLoad = (cPreLoad & 0x0F) + cAAData;

    while (cPreLoad--) {

        //
        // Scroll up one input scan line
        //

        pb0   = pbIn0;
        pbIn0 = pbIn1;
        pbIn1 = pbIn2;
        pbIn2 = pb0;
        pb3   = pbOut[++IdxOut & 0x03];

        if (cAAData-- > 0) {

            DBGP_IF(DBGP_EXPAND,
                    DBGP("FAKE SCAN: cPreLoad=%ld/cAAData=%ld, Compose IdxOut=%ld"
                            ARGDW(cPreLoad + 1) ARGDW(cAAData + 1)
                            ARGDW(IdxOut & 0x03)));

            CopyMemory(pbIn2, pbIn1, cbIn);

        } else {

            DBGP_IF(DBGP_EXPAND,
                    DBGP("REAL SCAN: cPreLoad=%ld, Compose IdxOut=%ld"
                            ARGDW(cPreLoad + 1) ARGDW(IdxOut & 0x03)));

            GetFixupScan(&AAHdr, (PBGR8)pbIn2);
        }

        pbS = GraySharpenInput(AAHdr.Flags,
                               pbS,
                               pbIn0,
                               pbIn1,
                               pbIn2,
                               cbIn);

        GrayExpYDIB_ExpCX(pEDCX,
                          (LPBYTE)((LPBYTE)pbS + cb1stSharpen),
                          (LPBYTE)pb3,
                          (LPBYTE)((LPBYTE)pb3 + cbY));

    }

    pED     = (PEXPDATA)(pAAInfo->pAAData);
    cAAData = pAAInfo->cAAData;

    while (cAAData--) {

        LONG    Mul0;
        LONG    Mul1;
        LONG    Mul2;
        LONG    Mul3;


        ed = *pED++;

        if (ed.Mul[0] & EDF_LOAD_PIXEL) {

            pb0   = pbIn0;
            pbIn0 = pbIn1;
            pbIn1 = pbIn2;
            pbIn2 = (LPBYTE)GetFixupScan(&AAHdr, (PBGR8)pb0);
            pbS   = GraySharpenInput(AAHdr.Flags,
                                     pbS,
                                     pbIn0,
                                     pbIn1,
                                     pbIn2,
                                     cbIn);
            pb3   = pbOut[++IdxOut & 0x03];

            GrayExpYDIB_ExpCX(pEDCX,
                              (LPBYTE)((LPBYTE)pbS + cb1stSharpen),
                              (LPBYTE)pb3,
                              (LPBYTE)((LPBYTE)pb3 + cbY));

            ed.Mul[0] &= ~(EDF_LOAD_PIXEL | EDF_NO_NEWSRC);
        }

        //
        // Build Mul Table here
        //

        pMap  = pMap0;
        Mul0  = -ed.Mul[0];
        Mul1  = -ed.Mul[1];
        Mul2  = -ed.Mul[2];
        Mul3  = -ed.Mul[3];
        pb3   = pbOut[(IdxOut    ) & 0x03];
        pb2   = pbOut[(IdxOut - 1) & 0x03];
        pOCur = (PGRAYF)AAHdr.pAABufBeg;

        if (ed.Mul[0]) {

            pb1 = pbOut[(IdxOut - 2) & 0x03];
            pb0 = pbOut[(IdxOut - 3) & 0x03];

            GRAY_GET_EXP_PC(PMAP_EXP4, GRAY_GET_EXP4, GRAY_INC_EXP4, pOCur);

        } else if (ed.Mul[1]) {

            pb1 = pbOut[(IdxOut - 2) & 0x03];

            GRAY_GET_EXP_PC(PMAP_EXP3, GRAY_GET_EXP3, GRAY_INC_EXP3, pOCur);

        } else if (ed.Mul[2]) {

            GRAY_GET_EXP_PC(PMAP_EXP2, GRAY_GET_EXP2, GRAY_INC_EXP2, pOCur);

        } else {

            GRAY_GET_EXP_PC(PMAP_EXP1, GRAY_GET_EXP1, GRAY_INC_EXP1, pOCur);
        }

        OUTPUT_AA_CURSCAN;
    }

    return(AAHdr.DstSurfInfo.cy);
}




VOID
HTENTRY
GrayExpandDIB_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    LPBYTE  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAINFO      AAI = *pAAInfo;
    LPBYTE      pInEnd;
    PEXPDATA    pED;
    BYTE        GrayIn[8];
    LONG        Gray;
    UINT        cPreLoad;
    UINT        cAAData;
    UINT        Idx;


    pInEnd        = pIn + AAI.cIn + 2;
    *(pInEnd - 0) =
    *(pInEnd - 1) =
    *(pInEnd - 2) = *(pInEnd - 3);
    GrayIn[5]     = *pIn;
    INC_PIN_BY_1ST_LEFT(pIn, AAI.Flags);

    GrayIn[6] = *pIn++;
    cPreLoad = (UINT)AAI.cPreLoad;
    cAAData  = (UINT)(cPreLoad >> 4);

    if ((!(cPreLoad &= 0x0F)) && (cAAData)) {

        GrayIn[6] = GrayIn[5];
        ++cPreLoad;
        --cAAData;
        --pIn;
    }

    Idx = 4 - cPreLoad;

    while (cPreLoad--) {

        CopyMemory(&GrayIn[0], &GrayIn[1], sizeof(GrayIn[0]) * 6);

        GrayIn[6] = *pIn++;

        if (AAI.Flags & AAIF_EXP_NO_SHARPEN) {

            GrayIn[3] = GrayIn[5];

        } else {

            SHARPEN_GRAY_LR(GrayIn[3], GrayIn[4], GrayIn[5], GrayIn[6], 0);
        }

        DBGP_IF(DBGP_EXP, DBGP("ExpDIB: PreLoad=%ld, pIn=%8lx"
                                        ARGDW(cPreLoad) ARGPTR(pIn)));
    }

    GrayIn[7] = GrayIn[Idx--];

    while (cAAData--) {

        GrayIn[Idx--] = GrayIn[7];
    }

    pED         = (PEXPDATA)(AAI.pAAData);
    pOutEnd    += OutInc;

    do {

        EXPDATA ed = *pED++;


        if (ed.Mul[0] & EDF_LOAD_PIXEL) {

            CopyMemory(&GrayIn[0], &GrayIn[1], sizeof(GrayIn[0]) * 6);

            GrayIn[6] = *pIn++;

            if (AAI.Flags & AAIF_EXP_NO_SHARPEN) {

                GrayIn[3] = GrayIn[5];

            } else {

                SHARPEN_GRAY_LR(GrayIn[3], GrayIn[4], GrayIn[5], GrayIn[6], 0);
            }

            ed.Mul[0] &= ~(EDF_LOAD_PIXEL | EDF_NO_NEWSRC);
        }

        Gray = MULRGB(GrayIn[3], ed.Mul[3]);

        if (ed.Mul[2]) {

            Gray += MULRGB(GrayIn[2], ed.Mul[2]);

            if (ed.Mul[1]) {

                Gray += MULRGB(GrayIn[1], ed.Mul[1]);

                if (ed.Mul[0]) {

                    Gray += MULRGB(GrayIn[0], ed.Mul[0]);
                }
            }
        }

        GRAY_DIMAX_TO_BYTE(pOut, Gray);

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);

    ASSERT(pIn <= pInEnd);
}




LONG
HTENTRY
GrayExpandDIB_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:

    This funtion anti-alias the bitmap by query scanlines from CX direction
    (may be Shrink(CX) or Expand(CX)) then compose current scanlines and output
    it to real BGR8 final buffer,

    The complication is need to have scanline one before current destination
    scanline, this may be because the source is not available or because the
    clipping is done on destination.

    Since the anti-alias for expanding requred at least four surounding
    scanlines to compose current scanline, it required large amount of
    memory to retain the prevous result scanlines

    The expanding is by sharpen the source pixel first before anti-aliasing
    smooth through

    prgbIn[0] - Previous un-sharpen source scan
                AND Last The 4th composition sharpened scan after sharpen
    prgbIn[1] - Current un-sharpen source scan
    prgbIn[2] - Next un-sharpen source scan
    prgbIn[3] - The 1st composition sharpened scan
    prgbIn[4] - The 2nd composition sharpened scan
    prgbIn[5] - The 3rd composition sharpened scan


    Exp=Load Sharpen Exp
    Srk=Load Srk Sharpen
    Cpy=Load Cpy


    Exp_CY:Exp_CX   Exp_CX:(LoadX SharpenX     ExpX) SharpenY ExpY
    Exp_CY:Srk_CX   Srk_CX:(LoadX     SrkX SharpenX) SharpenY ExpY
    Exp_CY:Cpy_CX   Cpy_CX:(LoadX     CpyX         ) SharpenY ExpY

    Srk_CY:Exp_CX   InputCX SrkY SharpenY Exp_CX:(LoadX SharpenX     ExpX)
    Srk_CY:Srk_CX   InputCX SrkY SharpenY Srk_CX:(LoadX     SrkX SharpenX)
    Srk_CY:Cpy_CX   InputCX SrkY SharpenY Cpy_CX:(LoadX     CpyX         )

    Cpy_CY:Exp_CX   Exp_CX:(LoadX SharpenX     ExpX)
    Cpy_CY:Srk_CX   Srk_CX:(LoadX     SrkX SharpenX)
    Cpy_CY:Cpy_CX   Cpy_CX:(LoadX     CpyX         )



Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER    AAHdr = *pAAHdr;
    PEXPDATA    pED;
    LPBYTE      pbIn[6];
    PLONG       pMap;
    PLONG       pMap0;
    PLONG       pMap0End;
    LPBYTE      pb0;
    LPBYTE      pb1;
    LPBYTE      pb2;
    LPBYTE      pb3;
    LPBYTE      pb4;
    LPBYTE      pb5;
    PGRAYF      pOCur;
    LPBYTE      pbYEnd;
    LONG        cbScan;
    LONG        cAAData;
    LONG        cPreLoad;


    pMap0     = (PLONG)AAHdr.pAAInfoCY->pbExtra;
    pMap0End  = pMap0 + 256;
    cbScan    = (AAHdr.DstSurfInfo.cx + 6) * (LONG)sizeof(BYTE);
    pbIn[0]   = (LPBYTE)(pMap0 + (256 * 4)) + 3;
    pbIn[1]   = (LPBYTE)((LPBYTE)pbIn[0] + cbScan);
    pbIn[2]   = (LPBYTE)((LPBYTE)pbIn[1] + cbScan);
    pbIn[3]   = (LPBYTE)((LPBYTE)pbIn[2] + cbScan);
    pbIn[4]   = (LPBYTE)((LPBYTE)pbIn[3] + cbScan);
    pbIn[5]   = (LPBYTE)((LPBYTE)pbIn[4] + cbScan);
    cbScan   -= (sizeof(BYTE) * 6);

    //
    // Always read first source
    //

    DBGP_IF(DBGP_EXPAND, DBGP("\nLoad First Scan"));

    AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                   GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                   (PBGR8)pbIn[4],
                   (LPBYTE)pbIn[4] + cbScan,
                   sizeof(BYTE));


    //
    // Load the PRE-SOURCE LEFT first source first
    //

    if (AAHdr.pAAInfoCY->Flags & AAIF_EXP_HAS_1ST_LEFT) {

        AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                       GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                       (PBGR8)pbIn[5],
                       (LPBYTE)pbIn[5] + cbScan,
                       sizeof(BYTE));

        DBGP_IF(DBGP_EXPAND, DBGP("Load First Left"));

    } else {

        CopyMemory(pbIn[5], pbIn[4], cbScan);

        DBGP_IF(DBGP_EXPAND, DBGP("Copy First Left"));
    }

    cPreLoad = (LONG)AAHdr.pAAInfoCY->cPreLoad;
    cAAData  = (LONG)(cPreLoad >> 4);
    cPreLoad = (cPreLoad & 0x0F) + cAAData;

    while (cPreLoad--) {

        //
        // Scroll up pbIn by one scan
        //

        pb5 = pbIn[0];

        CopyMemory(&pbIn[0], &pbIn[1], sizeof(pbIn[0]) * 5);

        pbIn[5] = pb5;
        pb3     = pbIn[3];
        pb4     = pbIn[4];
        pb5     = pbIn[5];
        pbYEnd  = (LPBYTE)pb5 + cbScan;

        if (cAAData-- > 0) {

            DBGP_IF(DBGP_EXPAND,
                    DBGP("FAKE SCAN: cPreLoad=%ld/cAAData=%ld"
                            ARGDW(cPreLoad + 1) ARGDW(cAAData + 1)));

            CopyMemory(pb5, pb4, cbScan);

        } else {

            DBGP_IF(DBGP_EXPAND,
                    DBGP("REAL SCAN: cPreLoad=%ld/cAAData=%ld"
                            ARGDW(cPreLoad + 1) ARGDW(cAAData + 1)));

            AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                           GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                           (PBGR8)pb5,
                           pbYEnd,
                           sizeof(BYTE));
        }

        DBGP_IF(DBGP_EXPAND,
                DBGP("Compose Sharpen Scan=%ld" ARGDW(cPreLoad + 1)));

        //
        // Now, let's sharpen the input
        //

        if (AAHdr.Flags & AAHF_BBPF_AA_OFF) {

            CopyMemory(pb3, pb4, cbScan);

        } else {

            do {

                SHARPEN_PGRAY_LR(pb3, (*pb3), (*pb4), (*pb5), 0);

                pb3++;
                pb4++;

            } while (++pb5 < (LPBYTE)pbYEnd);
        }
    }

    pED      = (PEXPDATA)(AAHdr.pAAInfoCY->pAAData);
    cAAData  = AAHdr.pAAInfoCY->cAAData;

    while (cAAData--) {

        EXPDATA ed = *pED++;
        LONG    Mul0;
        LONG    Mul1;
        LONG    Mul2;
        LONG    Mul3;


        if (ed.Mul[0] & EDF_LOAD_PIXEL) {

            pb5 = pbIn[0];

            CopyMemory(&pbIn[0], &pbIn[1], sizeof(pbIn[0]) * 5);

            pbIn[5] = pb5;
            pb3     = pbIn[3];
            pb4     = pbIn[4];
            pb5     = pbIn[5];
            pbYEnd  = (LPBYTE)pb5 + cbScan;

            AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                           GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                           (PBGR8)pb5,
                           pbYEnd,
                           sizeof(BYTE));

            if (AAHdr.Flags & AAHF_BBPF_AA_OFF) {

                CopyMemory(pb3, pb4, cbScan);

            } else {

                do {

                    SHARPEN_PGRAY_LR(pb3, (*pb3), (*pb4), (*pb5), 0);

                    pb3++;
                    pb4++;

                } while (++pb5 < (LPBYTE)pbYEnd);
            }

            ed.Mul[0] &= ~(EDF_LOAD_PIXEL | EDF_NO_NEWSRC);
        }

        //
        // Build Mul Table here
        //

        pMap  = pMap0;
        Mul0  = -ed.Mul[0];
        Mul1  = -ed.Mul[1];
        Mul2  = -ed.Mul[2];
        Mul3  = -ed.Mul[3];
        pb3   = pbIn[3];
        pb2   = pbIn[2];
        pOCur = (PGRAYF)AAHdr.pAABufBeg;

        if (ed.Mul[0]) {

            pb1 = pbIn[1];
            pb0 = pbIn[0];

            GRAY_GET_EXP_PC(PMAP_EXP4, GRAY_GET_EXP4, GRAY_INC_EXP4, pOCur);

        } else if (ed.Mul[1]) {

            pb1 = pbIn[1];

            GRAY_GET_EXP_PC(PMAP_EXP3, GRAY_GET_EXP3, GRAY_INC_EXP3, pOCur);

        } else if (ed.Mul[2]) {

            GRAY_GET_EXP_PC(PMAP_EXP2, GRAY_GET_EXP2, GRAY_INC_EXP2, pOCur);

        } else {

            GRAY_GET_EXP_PC(PMAP_EXP1, GRAY_GET_EXP1, GRAY_INC_EXP1, pOCur);
        }

        OUTPUT_AA_CURSCAN;
    }

    return(AAHdr.DstSurfInfo.cy);
}



VOID
HTENTRY
GrayShrinkDIB_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    LPBYTE  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PSHRINKDATA pSD;
    PLONG       pMap;
    PLONG       pMap256X;
    LPBYTE      pInEnd;
    LONG        GrayOut[3];
    LONG        GrayT;
    UINT        Mul;
    UINT        cPreLoad;



    pInEnd = pIn + pAAInfo->cIn;

    if (Mul = (UINT)pAAInfo->PreMul) {

        GrayOut[2]  = MULRGB(*pIn, Mul);
        pIn        += pAAInfo->PreSrcInc;

    } else {

        ZeroMemory(&GrayOut[2], sizeof(GrayOut[2]));
    }

    pSD      = (PSHRINKDATA)(pAAInfo->pAAData);
    pMap256X = pAAInfo->pMapMul;
    cPreLoad = (UINT)pAAInfo->cPreLoad;

    while (cPreLoad) {

        Mul  = (UINT)((pSD++)->Mul);
        pMap = (PLONG)((LPBYTE)pMap256X + GET_SDF_LARGE_OFF(Mul));

        if (Mul & SDF_DONE) {

            //
            // Finished a pixel
            //

            Mul        &= SDF_MUL_MASK;
            GrayOut[2] += (GrayT = MULRGB(*pIn, Mul));

            CopyMemory(&GrayOut[0], &GrayOut[1], sizeof(GrayOut[0]) * 2);

            GrayOut[2] = pMap[*pIn++] - GrayT;

            --cPreLoad;

        } else {

            GrayOut[2] += pMap[*pIn++];
        }
    }

    if (pAAInfo->cPreLoad == 1) {

        GrayOut[0] = GrayOut[1];
    }

    while (Mul = (UINT)((pSD++)->Mul)) {

        pMap = (PLONG)((LPBYTE)pMap256X + GET_SDF_LARGE_OFF(Mul));

        if (Mul & SDF_DONE) {

            //
            // Finished a pixel
            //

            Mul        &= SDF_MUL_MASK;
            GrayOut[2] += (GrayT = MULRGB(*pIn, Mul));

            SHARPEN_PGRAY_LR(pOut,
                             GrayOut[0],
                             GrayOut[1],
                             GrayOut[2],
                             DI_R_SHIFT);

            (LPBYTE)pOut += OutInc;

            CopyMemory(&GrayOut[0], &GrayOut[1], sizeof(GrayOut[0]) * 2);

            GrayOut[2] = pMap[*pIn++] - GrayT;

        } else {

            GrayOut[2] += pMap[*pIn++];
        }
    }

    ASSERT(pIn == pInEnd);

    if ((LPBYTE)pOut == (pOutEnd - OutInc)) {

       SHARPEN_PGRAY_LR(pOut,
                        GrayOut[0],
                        GrayOut[1],
                        GrayOut[1],
                        DI_R_SHIFT);
    }
}



LONG
HTENTRY
GrayShrinkDIB_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:

    This function shrink the scanline down first in Y direction from source
    bitmap when it is done for group of scanlines then it call AXFunc to
    compose current scanline (it may be Shrink(CX) or Expand(CX)) to the
    final output BGR8 buffer

    The shrink is done by sharpen the current pixel first.



Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER    AAHdr;
    PSHRINKDATA pSD;
    SHRINKDATA  sd;
    LPBYTE      pIBuf;
    LPBYTE      pIBufEnd;
    LPBYTE      pICur;
    PGRAYF      pOCur;
    PLONG       pGrayIn[3];
    PLONG       pGray0;
    PLONG       pGray1;
    PLONG       pGray2;
    PLONG       pGray2End;
    PLONG       pMap;
    PLONG       pMapMul;
    PLONG       pMapMul2;
    PLONG       pMap256Y;
    RGBL        GrayT;
    LONG        cbGrayY;
    LONG        Mul;
    LONG        cAAData;
    BOOL        CopyFirst;
    LONG        cyOut;
    INT         cPreLoad;
    BYTE        Mask;

    DEFDBGVAR(LONG, MulTot)

    //
    // Adding 3 to each side of pIBuf for ExpandDIB_CX
    //

    AAHdr      = *pAAHdr;
    pMap256Y   = AAHdr.pAAInfoCY->pMapMul;
    pMapMul    = (PLONG)(AAHdr.pAAInfoCY->pbExtra);
    pMapMul2   = pMapMul + 256;
    cbGrayY    = (LONG)(AAHdr.DstSurfInfo.cx * sizeof(LONG));
    pGrayIn[0] = (PLONG)(pMapMul2 + 256);
    pGrayIn[1] = (PLONG)( (LPBYTE)pGrayIn[0] + cbGrayY);
    pGrayIn[2] = (PLONG)( (LPBYTE)pGrayIn[1] + cbGrayY);
    pIBuf      = (LPBYTE)((LPBYTE)pGrayIn[2] + cbGrayY);
    pIBufEnd   = pIBuf + AAHdr.DstSurfInfo.cx;

    ASSERT_MEM_ALIGN(pGrayIn[0], sizeof(LONG));
    ASSERT_MEM_ALIGN(pGrayIn[1], sizeof(LONG));
    ASSERT_MEM_ALIGN(pGrayIn[2], sizeof(LONG));

    if (Mul = AAHdr.pAAInfoCY->PreMul) {

        pMap   = pMapMul;
        GrayT.r = -Mul;

        do {

            pMap[0] = (GrayT.r += Mul);

        } while (++pMap < pMapMul2);

        AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                       GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                       (PBGR8)(pICur = pIBuf),
                       pIBufEnd,
                       sizeof(BYTE));

        pGray2    = pGrayIn[2];
        pGray2End = (PLONG)((LPBYTE)pGray2 + cbGrayY);

        do {

            *pGray2 = pMapMul[*pICur++];

        } while (++pGray2 < pGray2End);

        //
        // The AAInputFunc() will increment the pointer, so reduced it
        //

        if (!(AAHdr.pAAInfoCY->PreSrcInc)) {

            AAHdr.Flags |= AAHF_GET_LAST_SCAN;
        }
    }

    pSD       = (PSHRINKDATA)(AAHdr.pAAInfoCY->pAAData);
    cPreLoad  = (INT)AAHdr.pAAInfoCY->cPreLoad;
    CopyFirst = (BOOL)(cPreLoad == 1);
    cAAData   = AAHdr.pAAInfoCY->cAAData;
    cyOut     = 0;

    SETDBGVAR(MulTot, Mul);

    while (cAAData--) {

        AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                       GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                       (PBGR8)(pICur = pIBuf),
                       pIBufEnd,
                       sizeof(BYTE));

        sd        = *pSD++;
        pGray2    = pGrayIn[2];
        pGray2End = (PLONG)((LPBYTE)pGray2 + cbGrayY);
        Mask      = GET_SDF_LARGE_MASK(sd.Mul);

        if (sd.Mul & SDF_DONE) {

            //
            // Build current Mul Table
            //

            Mul     = (LONG)(sd.Mul & SDF_MUL_MASK);
            pMap    = pMapMul;
            GrayT.r = -Mul;
            GrayT.b = (LONG)(pMap256Y[1] - Mul + (LONG)(Mask & 0x01));
            GrayT.g = -GrayT.b;

            do {

                pMap[  0] = (GrayT.r += Mul);
                pMap[256] = (GrayT.g += GrayT.b);

            } while (++pMap < pMapMul2);

            //
            // Finished a scanline, so to see if have prev/next to sharpen with
            //

            pGray0 = pGrayIn[0];
            pGray1 = pGrayIn[1];

            if (cPreLoad-- > 0) {

                do {

                    *pGray2   += pMapMul[*pICur];
                    *pGray0++  = pMapMul[*pICur++ + 256];

                } while (++pGray2 < pGray2End);

                if (CopyFirst) {

                    CopyMemory(pGray1, pGrayIn[2], cbGrayY);
                    CopyFirst = FALSE;
                }

            } else {

                pOCur = (PGRAYF)AAHdr.pAABufBeg;

                do {

                    *pGray2 += pMapMul[*pICur];

                    SHARPEN_PWGRAY_LR(pOCur, (*pGray0), (*pGray1), (*pGray2));

                    (LPBYTE)pOCur += AAHdr.AABufInc;
                    *pGray0++      = pMapMul[*pICur++ + 256];
                    ++pGray1;

                } while (++pGray2 < pGray2End);

                DBGP_IF(DBGP_SRK2,
                        DBGP("*%ld**In=%3lx, Mul=%08lx [%08lx], (%p)           Gray=%8lx [%08lx]"
                            ARGDW((cPreLoad > 0) ? cPreLoad : 0)
                            ARGDW(*pIBuf) ARGDW(Mul)
                            ARGDW(MulTot += Mul)
                            ARGPTR(pGrayIn[2])
                            ARGDW(*pGrayIn[2]) ARGDW(pMapMul[*(pICur - 1)])));

                DBGP_IF(DBGP_SRK2,
                        DBGP("   *In=%3lx, Mul=%08lx [%08lx], (%p) Gray=%8lx [%08lx]"
                            ARGDW(*pIBuf) ARGDW(sd.Mul & SDF_MUL_MASK)
                            ARGDW(MulTot = GrayT.b)
                            ARGPTR(pGrayIn[0])
                            ARGDW(*pGrayIn[0])
                            ARGDW(pMapMul[*(pICur - 1) + 256])));


                OUTPUT_AA_CURSCAN;

                ++cyOut;
            }

            pGray2     = pGrayIn[0];
            pGrayIn[0] = pGrayIn[1];
            pGrayIn[1] = pGrayIn[2];
            pGrayIn[2] = pGray2;

        } else {

            pMap = (PLONG)((LPBYTE)pMap256Y + GET_SDF_LARGE_OFF(sd.Mul));

            do {

                *pGray2 += pMap[*pICur++];

            } while (++pGray2 < pGray2End);

            DBGP_IF(DBGP_SRK2,
                    DBGP("    In=%3lx, Mul=%08lx [%08lx], (%p) Gray=%8lx [%08lx]"
                        ARGDW(*pIBuf) ARGDW(sd.Mul & SDF_MUL_MASK)
                        ARGDW(MulTot += (sd.Mul & SDF_MUL_MASK))
                        ARGPTR(pGrayIn[2])
                        ARGDW(*pGrayIn[2]) ARGDW(pMap[*(pICur - 1)])));
        }

    }

    if (AAHdr.DstSurfInfo.pb != AAHdr.pOutLast) {

        pOCur     = (PGRAYF)AAHdr.pAABufBeg;
        pGray0    = pGrayIn[0];
        pGray2    = pGrayIn[1];
        pGray2End = (PLONG)((LPBYTE)pGray2 + cbGrayY);

        do {

            SHARPEN_PWGRAY_LR(pOCur, (*pGray0), (*pGray2), (*pGray2));

            (LPBYTE)pOCur += AAHdr.AABufInc;
            ++pGray0;

        } while (++pGray2 < pGray2End);

        OUTPUT_AA_CURSCAN;

        ++cyOut;
    }

    ASSERTMSG("Shrink: cScan not equal", cyOut == AAHdr.DstSurfInfo.cy);

    return(cyOut);
}



//
//****************************************************************************
// Following ae defines and functions for VERY FAST Anti-Aliasing expansion,
// the Fast mode is turn on when is stretching up and both X and Y is less or
// equal to 500%
//****************************************************************************
//


#define MAC_FROM_2(Mac, pO, p1, p2, cCX)                                    \
{                                                                           \
    LONG    Count;                                                          \
                                                                            \
    Count  = cCX >> 2;                                                      \
    cCX   &= 0x03;                                                          \
                                                                            \
    while (Count--) {                                                       \
                                                                            \
        *(pO + 0) = (BYTE)Mac((*(p1+0)), (*(p2+0)));                        \
        *(pO + 1) = (BYTE)Mac((*(p1+1)), (*(p2+1)));                        \
        *(pO + 2) = (BYTE)Mac((*(p1+2)), (*(p2+2)));                        \
        *(pO + 3) = (BYTE)Mac((*(p1+3)), (*(p2+3)));                        \
                                                                            \
        pO += 4;                                                            \
        p1 += 4;                                                            \
        p2 += 4;                                                            \
    }                                                                       \
                                                                            \
    while (cCX--) {                                                         \
                                                                            \
        *pO++ = (BYTE)Mac((*p1), (*p2));                                    \
                                                                            \
        ++p1;                                                               \
        ++p2;                                                               \
    }                                                                       \
}


#define MAC_FROM_3(Mac, pO, p1, p2, p3, cCX)                                \
{                                                                           \
    LONG    Count;                                                          \
                                                                            \
    Count  = cCX >> 2;                                                      \
    cCX   &= 0x03;                                                          \
                                                                            \
    while (Count--) {                                                       \
                                                                            \
        *(pO + 0) = (BYTE)Mac((*(p1+0)), (*(p2+0)), (*(p3+0)));             \
        *(pO + 1) = (BYTE)Mac((*(p1+1)), (*(p2+1)), (*(p3+1)));             \
        *(pO + 2) = (BYTE)Mac((*(p1+2)), (*(p2+2)), (*(p3+2)));             \
        *(pO + 3) = (BYTE)Mac((*(p1+3)), (*(p2+3)), (*(p3+3)));             \
                                                                            \
        pO += 4;                                                            \
        p1 += 4;                                                            \
        p2 += 4;                                                            \
        p3 += 4;                                                            \
    }                                                                       \
                                                                            \
    while (cCX--) {                                                         \
                                                                            \
        *pO++ = (BYTE)Mac((*p1), (*p2), (*p3));                             \
                                                                            \
        ++p1;                                                               \
        ++p2;                                                               \
        ++p3;                                                               \
    }                                                                       \
}




VOID
HTENTRY
Do5225(
    LPBYTE  pO,
    LPBYTE  p1,
    LPBYTE  p2,
    LPBYTE  p3,
    LONG    cCX
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Apr-1999 Thu 18:57:47 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    MAC_FROM_3(CLR_5225, pO, p1, p2, p3, cCX);
}



VOID
HTENTRY
Do1141(
    LPBYTE  pO,
    LPBYTE  p1,
    LPBYTE  p2,
    LPBYTE  p3,
    LONG    cCX
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Apr-1999 Thu 18:57:47 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    MAC_FROM_3(CLR_1141, pO, p1, p2, p3, cCX);
}



VOID
HTENTRY
Do3121(
    LPBYTE  pO,
    LPBYTE  p1,
    LPBYTE  p2,
    LPBYTE  p3,
    LONG    cCX
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Apr-1999 Thu 18:57:47 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    MAC_FROM_3(CLR_3121, pO, p1, p2, p3, cCX);
}



VOID
HTENTRY
Do6251(
    LPBYTE  pO,
    LPBYTE  p1,
    LPBYTE  p2,
    LPBYTE  p3,
    LONG    cCX
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Apr-1999 Thu 18:57:47 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    MAC_FROM_3(CLR_6251, pO, p1, p2, p3, cCX);
}




VOID
HTENTRY
Do3263(
    LPBYTE  pO,
    LPBYTE  p1,
    LPBYTE  p2,
    LPBYTE  p3,
    LONG    cCX
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Apr-1999 Thu 18:57:47 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    MAC_FROM_3(CLR_3263, pO, p1, p2, p3, cCX);
}



VOID
HTENTRY
Do1319(
    LPBYTE  pO,
    LPBYTE  p1,
    LPBYTE  p2,
    LONG    cCX
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Apr-1999 Thu 18:57:47 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    MAC_FROM_2(CLR_1319, pO, p1, p2, cCX);
}



VOID
HTENTRY
Do35(
    LPBYTE  pO,
    LPBYTE  p1,
    LPBYTE  p2,
    LONG    cCX
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Apr-1999 Thu 18:57:47 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    MAC_FROM_2(CLR_35, pO, p1, p2, cCX);
}



VOID
HTENTRY
Do13(
    LPBYTE  pO,
    LPBYTE  p1,
    LPBYTE  p2,
    LONG    cCX
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Apr-1999 Thu 18:57:47 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    MAC_FROM_2(CLR_13, pO, p1, p2, cCX);
}




VOID
HTENTRY
GrayFastExpAA_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    PGRAYF  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:54:25 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    DWORD       cRep;
    WORD        wIn[3];


    pRep     = pAAInfo->Src.pRep;
    pRepEnd  = pAAInfo->Src.pRepEnd;
    cRep     = 1;
    pIn     += pAAInfo->Src.cPrevSrc;
    wIn[1]   = GRAY_B2W(*(pIn - 1));
    wIn[2]   = GRAY_B2W(*pIn++);

    do {

        ASSERT(pRep < pRepEnd);

        cRep   = (DWORD)pRep++->c;
        wIn[0] = wIn[1];
        wIn[1] = wIn[2];
        wIn[2] = GRAY_B2W(*pIn++);

        switch (cRep) {

        case 1:

            GRAY_MACRO3(pOut, CLR_5225, wIn[0], wIn[1], wIn[2]);
            break;

        case 2:

            GRAY_MACRO(pOut, CLR_13, wIn[0], wIn[1]);
            (LPBYTE)pOut += OutInc;
            GRAY_MACRO(pOut, CLR_13, wIn[2], wIn[1]);
            break;

        case 3:

            GRAY_MACRO(pOut, CLR_35,    wIn[0], wIn[1]);
            (LPBYTE)pOut += OutInc;

            GRAY_MACRO3(pOut, CLR_1141, wIn[0], wIn[1], wIn[2]);
            (LPBYTE)pOut += OutInc;

            GRAY_MACRO(pOut, CLR_35,    wIn[2], wIn[1]);

            break;

        case 4:

            GRAY_MACRO(pOut, CLR_35,    wIn[0], wIn[1]);
            (LPBYTE)pOut += OutInc;

            GRAY_MACRO3(pOut, CLR_3121, wIn[0], wIn[1], wIn[2]);
            (LPBYTE)pOut += OutInc;

            GRAY_MACRO3(pOut, CLR_3121, wIn[2], wIn[1], wIn[0]);
            (LPBYTE)pOut += OutInc;

            GRAY_MACRO(pOut, CLR_35,    wIn[2], wIn[1]);

            break;

        case 5:

            GRAY_MACRO(pOut, CLR_1319,  wIn[0], wIn[1]);
            (LPBYTE)pOut += OutInc;

            GRAY_MACRO3(pOut, CLR_6251, wIn[0], wIn[1], wIn[2]);
            (LPBYTE)pOut += OutInc;

            GRAY_MACRO3(pOut, CLR_3263, wIn[0], wIn[1], wIn[2]);
            (LPBYTE)pOut += OutInc;

            GRAY_MACRO3(pOut, CLR_6251, wIn[2], wIn[1], wIn[0]);
            (LPBYTE)pOut += OutInc;

            GRAY_MACRO(pOut, CLR_1319,  wIn[2], wIn[1]);

            break;

        default:

            DBGP("GrayFastExpCX Error: Invalid cRep=%ld" ARGDW(cRep));
            ASSERT(cRep <= FAST_MAX_CX);
            break;
        }

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);
}



VOID
HTENTRY
FastExpAA_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:54:25 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    DWORD       cRep;
    BGR8        bgr8[3];



    pRep     = pAAInfo->Src.pRep;
    pRepEnd  = pAAInfo->Src.pRepEnd;
    cRep     = 1;
    pIn     += pAAInfo->Src.cPrevSrc;
    bgr8[1]  = *(pIn - 1);
    bgr8[2]  = *pIn++;

    do {
        //  Bug 27036: ensure loop is exited
        INT_PTR  EntriesRemain = (pOutEnd - (LPBYTE)pOut) / OutInc ;

        if (pRep >= pRepEnd) {

            DBGP("pRep Too big=%ld" ARGDW(pRep - pRepEnd + 1));
            ASSERT(pRep < pRepEnd);
            break;  //  Bug 27036: ensure loop is exited
        }

        cRep    = (DWORD)pRep++->c;

        //  Bug 27036: ensure loop is exited
        if(cRep > (DWORD)EntriesRemain)
            cRep = (DWORD)EntriesRemain ;

        bgr8[0] = bgr8[1];
        bgr8[1] = bgr8[2];
        bgr8[2] = *pIn++;

        switch (cRep) {

        case 1:

            BGR_MACRO3(pOut, CLR_5225, bgr8[0], bgr8[1], bgr8[2]);
            break;

        case 2:

            BGR_MACRO(pOut, CLR_13, bgr8[0], bgr8[1]);
            (LPBYTE)pOut += OutInc;
            BGR_MACRO(pOut, CLR_13, bgr8[2], bgr8[1]);
            break;

        case 3:

            BGR_MACRO(pOut, CLR_35,    bgr8[0], bgr8[1]);
            (LPBYTE)pOut += OutInc;

            BGR_MACRO3(pOut, CLR_1141, bgr8[0], bgr8[1], bgr8[2]);
            (LPBYTE)pOut += OutInc;

            BGR_MACRO(pOut, CLR_35,    bgr8[2], bgr8[1]);

            break;

        case 4:

            BGR_MACRO(pOut, CLR_35,    bgr8[0], bgr8[1]);
            (LPBYTE)pOut += OutInc;

            BGR_MACRO3(pOut, CLR_3121, bgr8[0], bgr8[1], bgr8[2]);
            (LPBYTE)pOut += OutInc;

            BGR_MACRO3(pOut, CLR_3121, bgr8[2], bgr8[1], bgr8[0]);
            (LPBYTE)pOut += OutInc;

            BGR_MACRO(pOut, CLR_35,    bgr8[2], bgr8[1]);

            break;

        case 5:

            BGR_MACRO(pOut, CLR_1319,  bgr8[0], bgr8[1]);
            (LPBYTE)pOut += OutInc;

            BGR_MACRO3(pOut, CLR_6251, bgr8[0], bgr8[1], bgr8[2]);
            (LPBYTE)pOut += OutInc;

            BGR_MACRO3(pOut, CLR_3263, bgr8[0], bgr8[1], bgr8[2]);
            (LPBYTE)pOut += OutInc;

            BGR_MACRO3(pOut, CLR_6251, bgr8[2], bgr8[1], bgr8[0]);
            (LPBYTE)pOut += OutInc;

            BGR_MACRO(pOut, CLR_1319,  bgr8[2], bgr8[1]);

            break;

        default:

            DBGP("FastExpCX Error: Invalid cRep=%ld" ARGDW(cRep));
            ASSERT(cRep <= FAST_MAX_CX);
            break;
        }

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);
}




LONG
HTENTRY
FastExpAA_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER        AAHdr = *pAAHdr;
    AASHARPENFUNC   AASPFunc;
    FASTEXPAACXFUNC FastExpAACXFunc;
    LPBYTE          pIn[6];
    PAAINFO         pAAInfo;
    PREPDATA        pRep;
    PREPDATA        pRepEnd;
    LPBYTE          pCur;
    PBGRF           pAABufBeg;
    PBGRF           pAABufEnd;
    LONG            AABufInc;
    LONG            cRep;
    LONG            iRep;
    LONG            cbSrc;
    LONG            iY;
    LONG            cbCX;


    //
    // Fixup the CX first, the *pRep and *(pRepEnd - 1) are fixed, pAABufBeg and
    // pAABufEnd are expanded so we do not need to check the cRep during each
    // of CX functions
    //

    pAAInfo            = AAHdr.pAAInfoCX;
    pRep               = pAAInfo->Src.pRep;
    pRepEnd            = pAAInfo->Src.pRepEnd;
    pAABufBeg          = AAHdr.pAABufBeg;
    pAABufEnd          = AAHdr.pAABufEnd;
    AABufInc           = AAHdr.AABufInc;
    pRep->c           += pAAInfo->Src.cFirstSkip;
    (pRepEnd - 1)->c  += pAAInfo->Src.cLastSkip;
    (LPBYTE)pAABufBeg -= ((LONG)pAAInfo->Src.cFirstSkip * AABufInc);
    (LPBYTE)pAABufEnd += ((LONG)pAAInfo->Src.cLastSkip * AABufInc);

    //
    // Working on the CY now, fixup *(pRepEnd - 1) so it check the correct
    // cRep
    //

    pAAInfo            = AAHdr.pAAInfoCY;
    pRep               = pAAInfo->Src.pRep;
    pRepEnd            = pAAInfo->Src.pRepEnd;
    (pRepEnd - 1)->c  += pAAInfo->Src.cLastSkip;
    cbSrc              = (AAHdr.SrcSurfInfo.Flags & AASIF_GRAY) ? sizeof(BYTE) :
                                                                  sizeof(BGR8);
    pIn[0]             = pAAInfo->pbExtra + (cbSrc * 3);
    cbCX               = (LONG)AAHdr.SrcSurfInfo.cbCX + (cbSrc * 6);
    pIn[1]             = (LPBYTE)pIn[0] + cbCX;
    pIn[2]             = (LPBYTE)pIn[1] + cbCX;
    pIn[3]             = (LPBYTE)pIn[2] + cbCX;
    pIn[4]             = (LPBYTE)pIn[3] + cbCX;
    cbCX              -= (cbSrc * 6);

    if (cbSrc == 1) {

        AASPFunc        = (AASHARPENFUNC)GraySharpenInput;
        FastExpAACXFunc = (FASTEXPAACXFUNC)GrayFastExpAA_CX;

    } else {

        AASPFunc        = (AASHARPENFUNC)SharpenInput;
        FastExpAACXFunc = (FASTEXPAACXFUNC)FastExpAA_CX;
    }

    iY = (LONG)pAAInfo->Src.cPrevSrc;

    GetFixupScan(&AAHdr, (PBGR8)pIn[3]);

    if (--iY < 0) {

        AAHdr.Flags |= AAHF_GET_LAST_SCAN;
    }

    GetFixupScan(&AAHdr, (PBGR8)pIn[4]);

    if (--iY < 0) {

        AAHdr.Flags |= AAHF_GET_LAST_SCAN;
    }

    iY               = -3;
    AAHdr.pInputBeg += 3;

    do {

        pCur   = pIn[0];
        pIn[0] = pIn[1];
        pIn[1] = pIn[2];
        pIn[2] = pIn[3];
        pIn[3] = pIn[4];
        pIn[4] = pCur;

        GetFixupScan(&AAHdr, (PBGR8)pCur);

        AASPFunc(0, pIn[2], pIn[2], pIn[3], pIn[4], cbCX);

        if (++iY < 0) {

            continue;
        }

        iRep =
        cRep = (LONG)pRep++->c;

        if (!iY) {

            cRep += pAAInfo->Src.cFirstSkip;
        }

        pCur = (LPBYTE)AAHdr.pInputBeg;

        while ((iRep--) && (AAHdr.DstSurfInfo.cy)) {

            switch (cRep) {

            case 1:

                Do5225(pCur, pIn[0], pIn[1], pIn[2], cbCX);
                break;

            case 2:

                Do13(pCur, (iRep == 1) ? pIn[0] : pIn[2], pIn[1], cbCX);
                break;

            case 3:

                if (iRep == 1) {

                    Do1141(pCur, pIn[0], pIn[1], pIn[2], cbCX);

                } else {

                    Do35(pCur, (iRep == 2) ? pIn[0] : pIn[2], pIn[1], cbCX);
                }

                break;

            case 4:

                switch (iRep) {

                case 3:

                    Do35(pCur, pIn[0], pIn[1], cbCX);
                    break;

                case 2:

                    Do3121(pCur, pIn[0], pIn[1], pIn[2], cbCX);
                    break;

                case 1:

                    Do3121(pCur, pIn[2], pIn[1], pIn[0], cbCX);
                    break;

                case 0:

                    Do35(pCur, pIn[2], pIn[1], cbCX);
                    break;
                }

                break;

            case 5:

                switch (iRep) {

                case 4:

                    Do1319(pCur, pIn[0], pIn[1], cbCX);
                    break;

                case 3:

                    Do6251(pCur, pIn[0], pIn[1], pIn[2], cbCX);
                    break;

                case 2:

                    Do3263(pCur, pIn[0], pIn[1], pIn[2], cbCX);
                    break;

                case 1:

                    Do6251(pCur, pIn[2], pIn[1], pIn[0], cbCX);
                    break;

                case 0:

                    Do1319(pCur, pIn[2], pIn[1], cbCX);
                    break;

                }

                break;

            default:

                DBGP("FastExpCY Invalid cRep=%ld" ARGDW(cRep));
                ASSERT(cRep <= FAST_MAX_CY);

                break;
            }

            CopyMemory(pCur - cbSrc, pCur, cbSrc);
            CopyMemory(pCur + cbCX, pCur + cbCX - cbSrc, cbSrc);

            FastExpAACXFunc(AAHdr.pAAInfoCX,
                            pCur,
                            (LPBYTE)pAABufBeg,
                            (LPBYTE)pAABufEnd,
                            AABufInc);

            OUTPUT_AA_CURSCAN;

            --AAHdr.DstSurfInfo.cy;
        }

    } while (AAHdr.DstSurfInfo.cy);

    return(pAAHdr->DstSurfInfo.cy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\i386\htutils.asm ===
PAGE 60, 132
    TITLE   miscellaneous utilities sub-functions

COMMENT `


Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htutils.asm


Abstract:

    This module provided a set of sub-functions for math speed up
    subfunctions.

    This function is the equivelant codes in the htmath.c

Author:

    24-Sep-1991 Tue 18:33:44 updated  -by-  Daniel Chou (danielc)

[Environment:]

    Printer Driver.


[Notes:]


Revision History:

`


        .XLIST
        INCLUDE i386\i80x86.inc
        .LIST


IF  HT_ASM_80x86


;------------------------------------------------------------------------------
        .XLIST
        INCLUDE i386\htp.inc
        .LIST
;------------------------------------------------------------------------------

        .CODE


FD6NUM_1_DW     equ     0f4240h
FD6NUM_1_HW     equ     0fh
FD6NUM_1_LW     equ     4240h




SUBTTL  ComputeChecksum
PAGE

COMMENT `

Routine Description:

    This function compute 32-bit checksum of the passed data

Arguments:

    pData       - Pointer to a byte array to be computed for the checksum

    DataSize    - Size of the data in bytes

Return Value:

    32-bit checksum in dx:ax or EAX

Author:

    18-Mar-1991 Mon 13:48:51 created  -by-  Daniel Chou (danielc)


Revision History:

`


@BEG_PROC   ComputeChecksum <pData:DWORD,           \
                             InitialChecksum:DWORD, \
                             DataSize:DWORD>



IF i8086 OR i286                        ; lots of works for this kind of CPU

;==================================
; ds:si = data
; bx:cx = size
; ax    = Checksum Octet S
; dx    = Checksun Octet R
;============================================================================
;We have two 16-bit checksum octet R,S , inital are zero
;
;   S(n) = S(n-1) + Data
;   R(n) = R(n-1) + S(n)
;============================================================================

        @ENTER  _DS _SI                     ; Save environment registers

        LDS_SI  pData
        cld

        mov     cx, WPTR DataSize
        mov     bx, WPTR DataSize+2

        mov     ax, WPTR InitialChecksum    ; assume no odd byte
        mov     dx, WPTR InitialChecksum+2

        shr     bx, 1
        rcr     cx, 1
        jnc     short CheckSum1

CheckSum0:
        xor     ax, ax
        lodsb
        add     ax, WPTR InitialChecksum

CheckSum1:
        inc     cx
        inc     bx
        jmp     short CheckSumStart

CheckSumLoop:
        add     ax, WPTR [_SI]              ; S(n) = one's complement arithmic
        adc     dx, ax,
        add     _SI, 2

CheckSumStart:
        dec     cx
        jnz     CheckSumLoop
        dec     bx
        jnz     short CheckSumLoop

        @EXIT

ELSE

    ;*************************************************************************
    ; for i386 or upward compatble
    ;*************************************************************************

;==================================
; _BX   = data
; _CX   = size
; ax    = Checksum Octet S
; dx    = Checksun Octet R
;============================================================================
;We have two 16-bit checksum octet R,S , inital are zero
;
;   S(n) = S(n-1) + Data
;   R(n) = R(n-1) + S(n)
;============================================================================


        @ENTER

        mov     _BX, DPTR pData
        mov     _CX, DPTR DataSize

        movzx   _AX, WPTR InitialChecksum   ; assume no odd byte
        movzx   _DX, WPTR InitialChecksum+2 ; assume no odd byte

        shr     _CX, 1
        jnc     short CheckSum1

CheckSum0:
        xor     ax, ax
        mov     al, BPTR [_BX]
        add     ax, WPTR InitialChecksum
        inc     _BX

CheckSum1:
        inc     _CX
        jmp     short CheckSumStart

CheckSumLoop:
        add     ax, WPTR [_BX]              ; S(n) = one's complement arithmic
        add     dx, ax                      ; R(n) = one's complement arithmic
        add     _BX, 2

CheckSumStart:
        dec     _CX
        jnz     CheckSumLoop

Done:   shl     _DX, 16                     ; R:S = dx:ax = _AX = 32-bits
        or      _AX, _DX                    ; return at EAX

        @EXIT

ENDIF

@END_PROC




SUBTTL  MulFD6
PAGE

COMMENT `

Routine Description:

    This function multiply two FD6 numbers (FIX decimal point decimal long
    number, the LONG DECIMAL POINT SIX (FD6) is a number with lowest 6 digits
    as fraction to the right of the decimal point), so like 1234567 = 1.234567,
    the range for this data type is -2147.483647 to 2147.483647.

Arguments:

    Multiplicand    - a 32-bit FD6 multiplicand dividend number.

    Multiplier      - a 32-bit FD6 multiplier number.

Return Value:

    The return value is the 32-bit FD6 number which is round up from 7th
    decimal points, there is no remainder returned.

    NO ERROR returned, if divisor is zero the return value will be 0, if
    overflow happened, then maximum FD6 number will be returned (ie.
    2147.483647)

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

Revision History:

`


@BEG_PROC   MulFD6  <Multiplicand:DWORD,    \
                     Multiplier:DWORD>



IF i8086 OR i286                        ; lots of works for this kind of CPU

    @ENTER  _SI _DI _BP                 ; save these registers

    mov     ax, WPTR Multiplier
    mov     dx, WPTR Multiplier + 2
    mov     cx, ax
    or      cx, dx
    jz      short MulFD6_Zero

    mov     bx, WPTR Multiplicand
    mov     bp, WPTR Multiplicand + 2
    mov     cx, bx
    or      cx, bp
    jz      short MulFD6_Zero           ; if any one of them is zero then
                                        ; result must be zero
MulFD6_1:

    xor     cx, cx
    or      bp, bp
    jns     short MulFD6_2

    NEG32_FROMR16HL bp, bx
    not     cx                          ; cx=0 if positive, cx=0xffff negative

MulFD6_2:

    or      dx, dx
    jns     short MulFD6_3

    NEG32_FROMR16HL dx, ax
    not     cx                          ; flip the final sign indicator

MulFD6_3:

    cmp     bp, FD6NUM_1_HW             ; check if bp:bx == 1000000 (1.0)
    jnz     short MulFD6_31
    cmp     bx, FD6NUM_1_LW
    jz      short MulFD6_4              ; bp:bx = 1.0 return dx:ax

MulFD6_31:

    cmp     dx, FD6NUM_1_HW
    jnz     short MulFD6_32             ;
    cmp     ax, FD6NUM_1_LW             ; check if dx:ax == 1000000 (1.0)
    jnz     short MulFD6_32
    mov     ax, bx
    mov     dx, bp                      ; dx:ax = 1.0 return bp:bx
    jmp     short MulFD6_4

MulFD6_32:

    push    cx                          ; save it
    call    U32MulU32_U64               ; dx:ax * bp:bx = dx:ax:bp:bx
    call    U64Div1000000               ; dx:ax:bp:bx / 1000000 = dx:ax
    pop     cx                          ; restore sign indicator

MulFD6_4:

    S32_FROMR16HL_SR16  dx, ax, cx      ; flip sign if sign

    @EXIT

MulFD6_Zero:

    xor     ax, ax                      ; return 0
    xor     dx, dx
    jmp     short MulFD6_4

ELSE

    ;*************************************************************************
    ; for i386 or upward compatble
    ;*************************************************************************

    @ENTER                              ; entering function

    mov     _AX, DPTR Multiplier        ; see if this guy is zero
    cdq                                 ; save dx sign
    xor     _AX, _DX                    ; take absolute Multiplier in _AX
    sub     _AX, _DX                    ; zero ?
    jz      short MulFD6_Done           ; return zero

    mov     _BX, _DX                    ; _BX = sign
    mov     _CX, _AX                    ; save absolute Multiplier in _CX
    mov     _AX, DPTR Multiplicand      ; edx:eax now
    cdq                                 ; sign extended, saved the sign at here
    xor     _AX, _DX
    sub     _AX, _DX                    ; eax=absolute dividend now
    jz      short MulFD6_Done           ; dividend = 0, return 0

    xor     _BX, _DX                    ; _BX=final sign only if _BX != _DX

    ;
    ; _AX=Multiplicand, _CX=Multiplier, _BX = final sign indicator
    ;

    mov     _DX, _CX
    mov     _CX, FD6NUM_1_DW            ; multiply dividend by 1.0 (decimal)

    ;
    ; _AX=Multiplicand, _DX=Multiplier, _BX=sign, _CX=1.0
    ;

    cmp     _DX, _CX                    ; if Multiplier=1.0 or -1.0 then exit
    jz      short MulFD6_Sign           ; return Multiplicand

    xchg    _DX, _AX                    ; _AX=Multiplier, _DX=Multiplicand

    ;
    ; _AX=Multiplier, _DX=Multiplicand, _BX=sign, _CX=1.0
    ;

    cmp     _DX, _CX                    ; if Multiplicand=1.0 or -1.0 then exit
    jz      short MulFD6_Sign           ; return Multiplier

    mul     _DX                         ; _DX x _AX = _DX:_AX
    add     _AX, (FD6NUM_1_DW / 2)      ; try to round up
    adc     _DX, 0

    cmp     _DX, _CX                    ; will divison overflow?
    jae     short MulFD6_Overflow

    div     _CX                         ; _DX=remainder, _AX=quotient

MulFD6_Sign:

    xor     _AX, _BX                    ; do any sign if necessary
    sub     _AX, _BX

MulFD6_Done:

    cdq                                 ; make it 64-bits
    @EXIT                               ; exiting function

MulFD6_Overflow:

    mov     _AX, 07fffffffh             ; return maximum number
    jmp     short MulFD6_Sign

ENDIF                                   ; i8086 or i286


@END_PROC



SUBTTL  Cube
PAGE

COMMENT `

Routine Description:

    This function compute the cube of the Number (ie. Number ^ 3)
    the range for this data type is -2147.483647 to 2147.483647.

Arguments:

    Number  - a 32-bit FD6 multiplicand dividend number.

Return Value:

    The return value is the 32-bit FD6 number which is round up from 7th
    decimal points, there is no remainder returned.

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

Revision History:

`


@BEG_PROC   Cube    <Number:DWORD>



IF i8086 OR i286                        ; lots of works for this kind of CPU

    @ENTER  _SI _DI _BP                 ; save these registers

    mov     ax, WPTR Number
    mov     dx, WPTR Number + 2
    mov     cx, ax
    or      cx, dx
    jz      short Cube_Done             ; return 0
                                        ; result must be zero
Cube_1:

    xor     cx, cx
    or      dx, dx
    jns     short Cube_2

    NEG32_FROMR16HL dx, ax
    not     cx                          ; flip the final sign indicator

Cube_2:

    cmp     dx, FD6NUM_1_HW
    jnz     short Cube_3                ;
    cmp     ax, FD6NUM_1_LW             ; check if dx:ax == 1000000 (1.0)
    jz      Cube_Sign                   ; done

Cube_3:

    push    cx                          ; save it (sign)
    push    dx
    push    ax
    mov     bp, dx
    mov     bx, ax
    call    U32MulU32_U64               ; dx:ax * bp:bx = dx:ax:bp:bx
    call    U64Div1000000               ; dx:ax:bp:bx / 1000000 = dx:ax
    pop     bx                          ; now multiply the original again
    pop     bp
    call    U32MulU32_U64               ; dx:ax * bp:bx = dx:ax:bp:bx
    call    U64Div1000000               ; dx:ax:bp:bx / 1000000 = dx:ax
    pop     cx                          ; restore sign indicator

Cube_Sign:

    S32_FROMR16HL_SR16  dx, ax, cx      ; flip sign if sign

Cube_Done:

    @EXIT

ELSE

    ;*************************************************************************
    ; for i386 or upward compatble
    ;*************************************************************************

    @ENTER                              ; entering function

    mov     _AX, DPTR Number            ; see if this guy is zero
    cdq                                 ; save dx sign
    xor     _AX, _DX                    ; take absolute Multiplier in _AX
    sub     _AX, _DX                    ; zero ?
    jz      short Cube_Done             ; return zero
    push    _DX                         ; save sign
    mov     _CX, _AX                    ; save absolute Multiplier in _CX
    mov     _BX, FD6NUM_1_DW

    ;
    ; _AX=_CX=ABS(Number), esp= final sign indicator, _BX=1.0
    ;

    cmp     _AX, _BX
    jz      Cube_Sign                   ; return 1.0 or -1.0

    mul     _CX                         ; _DX:_AX=result
    add     _AX, (FD6NUM_1_DW / 2)      ; try to round up
    adc     _DX, 0
    cmp     _DX, FD6NUM_1_DW            ; will divison overflow?
    jae     short Cube_Overflow
    div     _BX                         ; _DX=remainder, _AX=quotient

    mul     _CX
    add     _AX, (FD6NUM_1_DW / 2)      ; try to round up
    adc     _DX, 0
    cmp     _DX, FD6NUM_1_DW            ; will divison overflow?
    jae     short Cube_Overflow
    div     _BX                         ; _DX=remainder, _AX=quotient

Cube_Sign:

    pop     _BX
    xor     _AX, _BX                    ; do any sign if necessary
    sub     _AX, _BX

Cube_Done:

    cdq                                 ; make it 64-bits
    @EXIT                               ; exiting function

Cube_Overflow:

    mov     _AX, 07fffffffh             ; return maximum number
    jmp     short Cube_Sign

ENDIF                                   ; i8086 or i286


@END_PROC




SUBTTL  MulDivFD6Pairs
PAGE

COMMENT `

Routine Description:

    This function multiply each pair of FD6 numbers and add the each pair
    of the result together. (FIX decimal point decimal long number, the LONG
    DECIMAL POINT SIX (FD6) is a number with lowest 6 digits as fraction to
    the right of the decimal point), so like 1234567 = 1.234567, the range
    for this data type is -2147.483647 to 2147.483647.

Arguments:

    pMulDivPair - Pointer to array of MULDIVPAIR data structure, the first
                  structure in the array tell the count of the FD6 pairs,
                  a Divisor present flag and a Divisor, the FD6 pairs start
                  from second element in the array.

Return Value:

    The return value is the 32-bit FD6 number which is round up from 7th
    decimal points, there is no remainder returned.

    NO ERROR returned, if divisor is zero then it assume no divisor is present,
    if Count of FD6 pairs is zero then it return FD6_0

Author:

    27-Aug-1992 Thu 18:13:55 updated  -by-  Daniel Chou (danielc)
        Re-write to remove variable argument conflict, and make it only passed
        a pointer to the MULDIVPAIR structure array

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

Revision History:

`



@BEG_PROC   MulDivFD6Pairs  <pMulDivPair:DWORD>



IF i8086 OR i286                        ; lots of works for this kind of CPU

    @ENTER  _DS _SI _DI _BP

    lds     si, pMulDivPair
    lodsw                               ; get count
    xor     dx, dx                      ; clear dx for quick exit
    or      ax, ax
    jnz     short MulDivFD6PairCount

    jmp     MulDivFD6Pair9              ; exit with 0

MulDivFD6PairCount:

    mov     cx, ax                      ; cx=count
    lodsw                               ; get divisor present flag
    or      ax, ax                      ; has divisor ?
    jz      short MulDivFD6PairsStart

    mov     ax, WPTR [si]               ; get divisor = dx:ax
    mov     dx, WPTR [si + 2]           ;

MulDivFD6PairStart:

    push    dx                          ; save divisor dx:ax on stack
    push    ax
    add     si, 4                       ; jump to first pair

MulDivFD6PairsStart:

    xor     dx, dx                      ; sum = 0 to start with
    xor     ax, ax
    xor     bp, bp
    xor     bx, bx

MulDivFD6PairsLoop:

    push    cx                          ; save count
    push    dx                          ; save sum dx:ax:bp:bx
    push    ax
    push    bp
    push    bx

    lodsw
    mov     cx, ax
    lodsw
    mov     dx, ax
    lodsw
    mov     bx, ax
    lodsw

    ;
    ; now dx:cx is multipler, ax:bx=multiplicand
    ;

    mov     bp, ax                      ; bp:bx=multiplicand
    mov     ax, cx                      ; dx:ax=multiplier

MulDivFD6Pairs0:

    or      cx, dx
    jz      short MulDivFD6PairsZero   ; zero content

    mov     cx, bx
    or      cx, bp
    jz      short MulDivFD6PairsZero   ; zero content

MulDivFD6Pairs1:

    xor     cx, cx                      ; initialize sign to zero
    or      bp, bp
    jns     short MulDivFD6Pairs2

    NEG32_FROMR16HL bp, bx
    not     cx                          ; flip the sign

MulDivFD6Pairs2:

    or      dx, dx
    jns     short MulDivFD6Pairs3

    NEG32_FROMR16HL dx, ax
    not     cx

MulDivFD6Pairs3:

    push    si                          ; save pFD6Pairs
    push    cx                          ; save it
    call    U32MulU32_U64               ; dx:ax * bp:bx = dx:ax:bp:bx
    pop     cx                          ; restore sign indicator
    pop     si
    jcxz    short MulDivFD6PairsPos

MulDivFD6PairsNeg:

    pop     cx
    sub     cx, bx
    mov     bx, cx
    pop     cx
    sbb     cx, bp
    mov     bp, cx
    pop     cx
    sbb     cx, ax
    mov     ax, cx
    pop     cx
    sbb     cx, dx
    mov     dx, cx
    jmp     short MulDivFD6PairsLoop2

MulDivFD6PairsZero:

    pop     bx
    pop     bp
    pop     ax
    pop     dx
    jmp     short MulDivFD6PairsLoop2

MulDivFD6PairsPos:

    pop     cx
    add     bx, cx
    pop     cx
    adc     bp, cx
    pop     cx
    adc     ax, cx
    pop     cx
    adc     dx, cx

MulDivFD6PairsLoop2:

    pop     cx
    dec     cx
    jz      short MulDivFD6Pairs4
    jmp     MulDivFD6PairsLoop

MulDivFD6Pairs4:                           ; dx:ax:bp:bx=number

    xor     cx, cx
    or      dx, dx
    jns     short MulDivFD6Pairs5

    not     bx
    not     bp
    not     ax
    not     dx
    add     bx, 1
    adc     bp, cx
    adc     ax, cx
    adc     dx, cx
    not     cx                          ; flip sign

MulDivFD6Pairs5:

    pop     di                          ; get divisor si:di
    pop     si

    or      si, si                      ; a negative number ?
    jns     short MulDivFD6Pair6
    not     cx

MulDivFD6Pair6:

    push    cx                          ; save sign indicator
    mov     cx, si
    or      cx, si                      ; if divisor = 0, then divide by 1.0
    jz      short MulDivFD6Pair7

    call    U64DivU32_U32               ; dx:ax:bp:bx / si:di = dx:ax/bx:cx

    ;
    ; need to round up (if remainder (bx:cx * 2) >= si:di
    ;

    add     cx, cx
    adc     bx, bx
    sub     cx, di
    sbb     bx, si
    cmc
    adc     ax, 0
    adc     dx, 0
    jmp     short MulDivFD6Pairs8

MulDivFD6Pairs7:

    call    U64Div1000000               ; dx:ax:bp:bx / 1000000 = dx:ax

MulDivFD6Pairs8:

    pop     cx                          ; restore sign indicator

    S32_FROMR16HL_SR16  dx, ax, cx

MulDivFD6Pairs9:

    @EXIT

ELSE

    ;*************************************************************************
    ; for i386 or upward compatble
    ;*************************************************************************

    @ENTER  _SI _DI

    mov     _SI, DPTR pMulDivPair
    xor     _AX, _AX                    ; clear return
    lodsw                               ; get count
    or      ax, ax                      ; if count=0, then return 0.0
    jz      short MulDivFD6PairsNone

    mov     _CX, _AX                    ; _CX=count

    lodsw                               ; get divisor present flag
    or      ax, ax                      ; if none then divisor=0
    jz      short MulDivFD6PairStart

    mov     _AX, DPTR [_SI]

MulDivFD6PairStart:

    push    _AX                         ; save divisor
    add     _SI, 4                      ; jump to first pair

    xor     _BX, _BX
    xor     _DI, _DI                    ; _BX:_DI is the sum = initialize to 0

MulDivFD6PairsLoop:

    lodsd                               ; get multiplicand
    mov     _DX, _AX
    lodsd
    or      _AX, _AX                    ; see if zero, if zero do nothing
    jz      short MulDivFD6PairsLoop2
    or      _DX, _DX
    jz      short MulDivFD6PairsLoop2
    imul    _DX                         ; _DX:_AX = result

MulDivFD6Pairs1:

    add     _DI, _AX
    adc     _BX, _DX

MulDivFD6PairsLoop2:

    loop    MulDivFD6PairsLoop

MulDivFD6Pairs2:

    mov     _AX, _DI
    mov     _DX, _BX

    shl     _BX, 1
    sbb     _BX, _BX                    ; _BX=sign indicator

    S64_FROMR32HL_SR32  _DX, _AX, _BX   ; flip the _DX, _AX according the sign

    mov     _DI, FD6NUM_1_DW            ; now _DX:_AX / _DI 1.0 (decimal)

    pop     _CX                         ; get divisor
    jecxz   short MulDivFD6Pairs3       ; divide by 1.0 if divisor=0.0
    cmp     _CX, _DI                    ; divisor=1.0?
    jz      short MulDivFD6Pairs3

    mov     _DI, _CX                    ; using new divisor
    shl     _CX, 1
    sbb     _CX, _CX                    ; _CX=sign indicator
    xor     _DI, _CX
    sub     _DI, _CX                    ; _DI=absolute divisor
    xor     _BX, _CX                    ; flip the final sign if any

MulDivFD6Pairs3:

    cmp     _DX, _DI                    ; will divison overflow?
    jae     short MulDivFD6PairsOverflow

    div     _DI                         ; edx=remainder, eax=quotient

    shr     _DI, 1                      ; if remainder >= (divisor / 2) then
    sub     _DX, _DI                    ; round it up
    cmc
    adc     _AX, 0                      ; round it up

MulDivFD6PairsSign:

    xor     _AX, _BX                    ; do any sign if necessary
    sub     _AX, _BX

MulDivFD6Pairs4:

    cdq                                 ; convert to 64-bit

    @EXIT

MulDivFD6PairsNone:

    xor     _AX, _AX
    jmp     short MulDivFD6Pairs4

MulDivFD6PairsOverflow:

    mov     _AX, 07fffffffh             ; return maximum number
    jmp     short MulDivFD6PairsSign

ENDIF                                   ; i8086 or i286


@END_PROC




SUBTTL  DivFD6
PAGE

COMMENT `

Routine Description:

    This function divide two FD6 numbers (FIX decimal point decimal long
    number, the LONG DECIMAL POINT SIX (FD6) is a number with lowest 6 digits
    as fraction to the right of the decimal point), so like 1234567 = 1.234567,
    the range for this data type is -2147.483647 to 2147.483647.

Arguments:

    Dividend    - a 32-bit FD6 dividend number.

    Divisor     - a 32-bit FD6 divisor number.

Return Value:

    The return value is the 32-bit FD6 number which is round up from 7th
    decimal points, there is no remainder returned.

    NO ERROR returned, if divisor is zero the return value will be dividend, if
    overflow happened, then maximum FD6 number will be returned (ie.
    2147.483647)

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

Revision History:

`

@BEG_PROC   DivFD6  <Dividend:DWORD, Divisor:DWORD>



IF i8086 OR i286                        ; lots of works for this kind of CPU

    @ENTER  _SI _DI _BP                 ; save used registers

    mov     di, WPTR Divisor
    mov     si, WPTR Divisor + 2
    mov     ax, WPTR Dividend
    mov     dx, WPTR Dividend + 2

    mov     cx, si
    or      cx, di
    jz      short DivFD6_Divisor0

DivFD6_Chk1:

    mov     cx, dx
    or      cx, ax
    jz      short DivFD6_Done

DivFD6_Chk1:                            ; dx:ax=dividend, si:di=divisor

    xor     cx, cx
    or      si, si
    jns     short DivFD6_1

    NEG32_FROMR16HL si, di
    not     cx

DivFD6_1:                               ; check if divided by 1.0 or -1.0

    cmp     si, FD6NUM_1_HW
    jnz     short DivFD6_1a
    cmp     di, FD6NUM_1_LW
    jz      short DivFD6_Sign           ; exit with dx:ax and sign in cx

DivFD6_1a:

    or      dx, dx
    jns     short DivFD6_2

    NEG32_FROMR16HL dx, ax
    not     cx

DivFD6_2:

    cmp     dx, si
    jnz     short DivFD6_3
    cmp     ax, di
    jnz     short DivFD6_3

    mov     dx, FD6NUM_1_HW
    mov     ax, FD6NUM_1_LW
    jmp     short DivFD6_Sign           ; dx:ax=si:di, return 1.0 or -1.0

DivFD6_3:

    push    cx                          ; save sign
    call    u32Mul1000000               ; dx:ax * 0xf4240 = dx:ax:bp:bx
    call    U64DivU32_U32               ; dx:ax:bp:bx / si:di = dx:ax/bx:cx

    ;
    ; Check if we have 0.0000005 to round up, Divisor - (reminder * 2) >= 0
    ; that is.
    ;

    sub     di, cx                      ; Divisor - Remainder = X (si:di)
    sbb     si, bx
    sub     cx, di
    sbb     bx, si                      ; Remainder - X = U (bx:cx)
    cmc
    adc     ax, 0                       ; if (U >= 0) then round up
    adc     dx, 0

    pop     cx                          ; cx=sign

DivFD6_Sign:

    S32_FROMR16HL_SR16  dx, ax cx

DivFD6_Done:

    @EXIT

DivFD6_Divisor0:

    inc     ax
    jmp     short DivFD6_Chk0


ELSE                                    ; assume i386 or up at here

    ;*************************************************************************
    ; for i386 or upward compatble
    ;*************************************************************************

    @ENTER                              ; entering function

    mov     _AX, DPTR Divisor           ; see if this guy is zero
    cdq                                 ; save dx sign
    mov     _BX, _DX                    ; _BX = sign
    xor     _AX, _DX                    ; take divisor as absolute number _AX
    sub     _AX, _DX                    ; zero ? DO NOT DESTROY ZERO FLAG
    jz      short DivFD6_Divisor0

DivFD6_1:

    mov     _CX, _AX                    ; save absolute divisor in _CX
    mov     _AX, DPTR Dividend          ; _AX=Dividend, _CX=Divisor, _BX=Sign
    cdq                                 ; sign extended, saved the sign at here
    xor     _AX, _DX
    sub     _AX, _DX                    ; eax=absolute dividend now
    jz      short DivFD6_Done           ; dividend = 0, return 0
    xor     _BX, _DX                    ; _BX=final sign only if _BX != _DX

    ;
    ; _AX=Dividend, _CX=Divisor, _BX = final sign indicator
    ;

    mov     _DX, FD6NUM_1_DW            ; multiply dividend by 1.0 (decimal)
    cmp     _CX, _DX                    ; if divisor == 1.0 or -1.0 then exit
    jz      short DivFD6_Sign

    xchg    _AX, _DX                    ; _AX = 1.0, _DX=Dividend
    cmp     _DX, _CX
    jz      short DivFD6_Sign           ; Divisor=Dividend, return 1.0 or -1.0

    mul     _DX                         ; edx:eax = 64-bit product

    cmp     _DX, _CX                    ; will division overflow ?
    jae     short DivFD6_Overflow

    div     _CX                         ; edx=remainder, eax=quotient

    ;
    ; Check if we have 0.0000005 to round up, Divisor - (reminder * 2) >= 0
    ; that is.
    ;

    sub     _CX, _DX                    ; divisor - remainder = X
    sub     _DX, _CX                    ; Remainder - X = U
    cmc                                 ; if U >= 0 then round up
    adc     _AX, 0

DivFD6_Sign:

    xor     _AX, _BX                    ; do any sign if necessary
    sub     _AX, _BX
    cdq                                 ; make it 64-bits

DivFD6_Done:

    @EXIT                               ; exiting function

DivFD6_Overflow:

    mov     _AX, 07fffffffh             ; return maximum number
    jmp     short DivFD6_Sign

DivFD6_Divisor0:

    inc     _AX
    jmp     short DivFD6_1


ENDIF                                   ; i8086 or i286


@END_PROC



SUBTTL  FD6DivL
PAGE

COMMENT `

Routine Description:

    This function divide a FD6 number by a LONG integer.

Arguments:

    Dividend    - a 32-bit FD6 dividend number.

    Divisor     - a 32-bit signed number.

Return Value:

    The return value is the 32-bit FD6 number which is round up from 7th
    decimal points, there is no remainder returned.

    NO ERROR returned, if divisor is zero the return value will be dividend, if
    overflow happened, then maximum FD6 number will be returned (ie.
    2147.483647)

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

Revision History:

`


@BEG_PROC   FD6DivL <Dividend:DWORD, Divisor:DWORD>



IF i8086 OR i286                        ; lots of works for this kind of CPU

    @ENTER  _SI _DI _BP                 ; save used registers

    mov     di, WPTR Divisor
    mov     si, WPTR Divisor + 2
    mov     ax, WPTR Dividend
    mov     dx, WPTR Dividend + 2

    mov     cx, si
    or      cx, di
    jz      short FD6DivL_Done
    mov     cx, dx
    or      cx, ax
    jz      short FD6DivL_Done

FD6DivL_Chk1:                            ; dx:ax=dividend, si:di=divisor

    xor     cx, cx
    or      si, si
    jns     short FD6DivL_1

    NEG32_FROMR16HL si, di
    not     cx

FD6DivL_1:                               ; check if divided by 1.0 or -1.0

    or      dx, dx
    jns     short FD6DivL_2

    NEG32_FROMR16HL dx, ax
    not     cx

FD6DivL_2:

    push    cx                          ; save sign
    call    U32DivU32_U32               ; dx:ax / si:di = dx:ax / bx:cx
    jz      short FD6DivL_3             ; zero flag set if no remainder

    ;
    ; Check if we have 0.0000005 to round up, Divisor - (reminder * 2) >= 0
    ; that is.
    ;

    sub     di, cx                      ; Divisor - Remainder = X (si:di)
    sbb     si, bx
    sub     cx, di
    sbb     bx, si                      ; Remainder - X = U (bx:cx)
    cmc
    adc     ax, 0                       ; if (U >= 0) then round up
    adc     dx, 0

FD6DivL_3:

    pop     cx                          ; cx=sign

FD6DivL_Sign:

    S32_FROMR16HL_SR16  dx, ax cx

FD6DivL_Done:

    @EXIT

ELSE                                    ; assume i386 or up at here

    ;*************************************************************************
    ; for i386 or upward compatble
    ;*************************************************************************

    @ENTER                              ; entering function

    mov     _AX, DPTR Divisor           ; see if this guy is zero
    cdq                                 ; save dx sign
    mov     _BX, _DX                    ; _BX = sign
    xor     _AX, _DX                    ; take divisor as absolute number _AX
    sub     _AX, _DX                    ; zero ? DO NOT DESTROY ZERO FLAG
    mov     _CX, _AX                    ; save absolute divisor in _CX
    mov     _AX, DPTR Dividend          ; _AX=Dividend, _CX=Divisor, _BX=Sign
    jz      short FD6DivL_Done          ; If Divisor=0, return Dividend

    cdq                                 ; sign extended, saved the sign at here
    xor     _AX, _DX
    sub     _AX, _DX                    ; eax=absolute dividend now
    jz      short FD6DivL_Done          ; dividend = 0, return 0
    xor     _BX, _DX                    ; _BX=final sign only if _BX != _DX

    ;
    ; _AX=Dividend, _CX=Divisor, _BX = final sign indicator
    ;

    xor     _DX, _DX                    ; 0:_AX / _CX
    div     _CX                         ; _DX=remainder, _AX=quotient

    ;
    ; Check if we have 0.0000005 to round up, Divisor - (reminder * 2) >= 0
    ; that is.
    ;

    sub     _CX, _DX                    ; divisor - remainder = X
    sub     _DX, _CX                    ; Remainder - X = U
    cmc                                 ; if U >= 0 then round up
    adc     _AX, 0

FD6DivL_Sign:

    xor     _AX, _BX                    ; do any sign if necessary
    sub     _AX, _BX
    cdq                                 ; make it 64-bits

FD6DivL_Done:

    @EXIT                               ; exiting function

ENDIF                                   ; i8086 or i286


@END_PROC



;=============================================================================

IF 0

SUBTTL  FD6IntFrac
PAGE

COMMENT `

Routine Description:

    This function is used to extract integer/fraction portion of the FIX
    decimal point decimal long number, the LONG DECIMAL POINT SIX (FD6)
    is a number with lowest 6 digits as fraction to the right of the decimal
    point), so like 1234567 = 1.234567, the range for this data type is
    -2147.483647 - 2147.483647.

Arguments:

    Number      - the FD6 number which will be break down as integer portion
                  and fraction portion.  if -1.123456 is passed then return
                  will be INTEGER = -1 (16-bit extended to 32-bit), and
                  FRACTION = -123456 (ie. -0.123456)

    pFrac       - pointer to the DWORD (32-bit) to store the fraction portion
                  of the FD6 (Num) number.

Return Value:

    The return value is the sign 16-bit integer of the number passed in, it
    will be extented to 32-bit for caller's convinent.

    Since the integer portion for the FD6 only -2147 to 2147 it only need
    16-bit number to retreat.

    The fraction portion is stored at pointer points by the pFrac parameter.

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

Revision History:

`



@BEG_PROC   FD6IntFrac  <Number:DWORD, pFrac:DWORD>



IF i8086 OR i286                        ; lots of works for this kind of CPU


    @ENTER                              ; enter function

    mov     ax, WPTR Number
    mov     dx, WPTR Number + 2

    mov     bx, dx
    shl     bx, 1
    sbb     bx, bx                      ; bx=0xffff if dx:ax is negative

    S32_FROMR16HL_SR16  dx, ax, bx

    mov     bl, al                      ;
    and     bl, 0fh                     ; save lowest 4 bits of dividend in BL

    shr     dx, 1
    rcr     ax, 1
    shr     dx, 1
    rcr     ax, 1
    shr     dx, 1
    rcr     ax, 1
    shr     dx, 1
    rcr     ax, 1

    mov     cx, 0f424h
    div     cx                          ; dx:bl=remainder, ax=quotient

    rol     dx, 1                       ; rotate the dx left 4 times to put
    rol     dx, 1                       ; saved lowest 4 remainder bits back
    rol     dx, 1
    rol     dx, 1
    mov     cx, 0fh
    and     cx, dx                      ; cx=high portion of remainder
    xor     dx, cx                      ; clear dx low 4 bits
    or      dl, bl                      ; move low 4 bits in, cx:dx=remainder
    ;
    mov     bl, bh
    xor     ax, bx
    sub     ax, bx

    S32_FROMR16HL_SR16  dx, cx, bx

    les     bx, pFrac
    mov     WPTR es:[bx], dx            ; save fraction
    mov     WPTR es:[bx+2], cx
    cwd                                 ; dx:ax=quotient

    @EXIT

ELSE                                    ; assume i386 or up at here

    ;*************************************************************************
    ; for i386 or upward compatble
    ;*************************************************************************

    @ENTER                              ; entering function

    mov     _AX, DPTR Number            ; load the 32-bit number
    cdq                                 ; extended to 64-bits
    mov     _CX, 1000000                ; divisor = 1000000 decimal
    idiv    _CX                         ; edx=r, eax=q
    mov     _BX, DPTR pFrac
    mov     DPTR [_BX], _DX             ; save remainder
    cdq                                 ; _AX=quotient, now sign extended

    @EXIT                               ; exiting function

ENDIF                                   ; i8086 or i286


@END_PROC


ENDIF

;=============================================================================



SUBTTL  FractionToMantissa
PAGE

COMMENT `

Routine Description:

    This function convert a fraction FD6 number to the logarithm mantissa
    with correction data.

Arguments:

    Fraction        - the fraction number after decimal place, because
                      we have mantissa table up to two decimal places, the
                      correction is necessary because logarithm numbers are
                      no linear.  The number is range from 0.000000-0.999999

    CorrectData     - The correction data which from MantissaCorrectData[]


Return Value:

    No error returned, the return value is the Mantissa value for the fraction
    passed in.

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

Revision History:

`


@BEG_PROC   FractionToMantissa  <Fraction:DWORD, CorrectData:DWORD>



IF i8086 OR i286                        ; lots of works for this kind of CPU


    @ENTER  _SI _DI _BP                 ; save used registers

    mov     ax, WPTR Fraction
    mov     dx, WPTR Fraction + 2       ; 0-999999 decimal
    mov     si, ax
    and     si, 1                           ; 1 bit remainder
    shr     dx, 1                           ; divide by (100000/2) so dividend
    rcr     ax, 1                           ; must shift right by 1
    mov     cx, 0c350h                      ; 100000 / 2
    div     cx                              ; dx=remainder, ax=quotient
    mov     cx, ax                          ; cx=0-9, quotient
    inc     cx                              ; make it 1-10
    mov     di, dx                          ; remainder = (remainder*2) + save
    shr     si, 1                           ; check the lowest remainder bit
    adc     di, di                          ; put it into final remainder
    adc     si, si                          ; si = 0/1

    ;
    ; starting correction
    ;
    ;       <---High Word---> <----Low Word--->
    ;  Bit#  3          2          1          0
    ;       10987654 32109876 54321098 76543210
    ;       | | | |  | |  |   ||  |  |
    ;       | | | |  | |  |   ||  |  +-- x.000 Minimum Difference
    ;       | | | |  | |  |   ||  +----- x.001-x.002 (0-7) Correct 1
    ;       | | | |  | |  |   |+-------- x.000-x.001 (0-7) Correct 2
    ;       | | | |  | |  |   +--------- x.009-y.000 (0-1) Correct 10
    ;       | | | |  | |  +------------- x.009-y.000 (0-7) Correct 3
    ;       | | | |  | +---------------- x.008-x.009 (0-7) Correct 4
    ;       | | | |  +------------------ x.007-x.008 (0-3) Correct 5
    ;       | | | +--------------------- x.006-x.007 (0-3) Correct 6
    ;       | | +----------------------- x.005-x.006 (0-3) Correct 7
    ;       | +------------------------- x.004-x.005 (0-3) Correct 8
    ;       +--------------------------- x.003-x.004 (0-3) Correct 9
    ;

    mov     ax, WPTR CorrectData
    mov     dx, WPTR CorrectData + 2    ; dx:ax=correct data

    mov     bp, ax                          ; first get the DifMin = 9 bits
    and     bp, 01ffh                       ; bp=base
    xor     bx, bx                          ; different accumulator=base

Frac2Mant1:

    mov     ch, ah
    mov     ax, 7
    shr     ch, 1
    and     al, ch
    dec     cl
    jz      short Frac2MantGetFrac          ; bx=total, next dif=ax
    add     bx, ax
    add     bx, bp

Frac2Mant2:

    shr     ch, 1                           ; shift away correction 1
    shr     ch, 1
    shr     ch, 1                           ; ch bit 3 is the correction 10
    mov     al, 7
    and     al, ch
    dec     cl
    jz      short Frac2MantGetFrac          ;
    add     bx, ax                          ; correct 2
    add     bx, bp

Frac2Mant3:

    mov     ax, 7
    and     ax, dx
    dec     cl                              ; correct 3
    jz      short Frac2MantGetFrac
    add     bx, ax
    add     bx, bp

Frac2Mant4:

    mov     ax, 7
    cmp     al, ch                          ; if bit 3 of ch is on then carry
    rcr     dx, 1                           ; we actually move that bit into
    shr     dx, 1                           ; bit 15 of dx
    shr     dx, 1                           ; shift away correction 3
    and     ax, dx
    dec     cl
    jz      short Frac2MantGetFrac

    shr     dx, 1                           ; shift away correction 4
    mov     ch, 3                           ; this is the mask, all 2 bits now

Frac2Mant5_10:

    add     bx, ax
    add     bx, bp
    shr     dx, 1
    shr     dx, 1
    mov     al, ch
    and     ax, dx
    dec     cl
    jnz     short Frac2Mant5_10

Frac2MantGetFrac:

    add     bp, ax                          ; add minimum diff. to next table

    ;
    ; Now,    bx=Minimum x.00x,
    ;         bp=different to the next mantissa x.000x + 0.0001
    ;      si:di=fraction ratio (0.000000 - 0.099999)
    ;
    ; Total Dif = bx + ((bp * si:di) / 100000)
    ;
    ; si:di * ax will never greater than 32-bit because (si:di < 100000) and
    ; BP < (2^9 = 512)
    ;

    mov     ax, si
    or      ax, di
    jz      short Frac2MantDoneFrac
    mov     ax, si                          ; if si=0, then no 'mul si'
    or      ax, ax
    jz      short Frac2MantDoneHF
    mov     ax, bp                          ;        si:di
    mul     si                              ;  *        ax

Frac2MantDoneHF:

    xchg    bp, ax                          ; ---------------
    mul     di                              ;        dx:ax
    add     dx, bp                          ;        bp
    mov     cx, 0c350h                      ; ----------------
    add     ax, cx                          ;        dx:ax
    adc     dx, 0                           ; now round up
    shr     dx, 1                           ; divide by (100000/2) so dividend
    rcr     ax, 1                           ; must also right shift by 1
    div     cx                              ; ax=qotient, ignored the remainder

Frac2MantDoneFrac:

    xor     dx, dx                          ; using dx:ax=final number
    add     ax, bx
    adc     dx, dx                          ; dx:ax=fraction mantissa number

    @EXIT

ELSE

    ;*************************************************************************
    ; for i386 or upward compatble
    ;*************************************************************************

    @ENTER  _SI _DI _BP                     ; entering function

    mov     _AX, DPTR Fraction
    cdq
    mov     _CX, 100000
    div     _CX                             ; _DX=r, _AX=q
    mov     _CX, _AX                        ; _CX=q+1
    inc     _CX                             ; _CX= 1-10

    ;
    ; starting correction
    ;
    ;       <---High Word---> <----Low Word--->
    ;  Bit#  3          2          1          0
    ;       10987654 32109876 54321098 76543210
    ;       | | | |  | |  |   ||  |  |
    ;       | | | |  | |  |   ||  |  +-- x.000 Minimum Difference
    ;       | | | |  | |  |   ||  +----- x.001-x.002 (0-7) Correct 1
    ;       | | | |  | |  |   |+-------- x.000-x.001 (0-7) Correct 2
    ;       | | | |  | |  |   +--------- x.009-y.000 (0-1) Correct 10
    ;       | | | |  | |  +------------- x.009-y.000 (0-7) Correct 3
    ;       | | | |  | +---------------- x.008-x.009 (0-7) Correct 4
    ;       | | | |  +------------------ x.007-x.008 (0-3) Correct 5
    ;       | | | +--------------------- x.006-x.007 (0-3) Correct 6
    ;       | | +----------------------- x.005-x.006 (0-3) Correct 7
    ;       | +------------------------- x.004-x.005 (0-3) Correct 8
    ;       +--------------------------- x.003-x.004 (0-3) Correct 9
    ;

    mov     _DI, DPTR CorrectData      ; _AX=correct data
    mov     _BP, _DI
    and     _BP, 01ffh                      ; _SI = 9 bit of the DifMin
    mov     _SI, 7
    mov     bx, di
    shl     bx, 1                           ; get the correction 10
    rcr     _DI, 1                          ; put into bit 31
    shr     _DI, 8
    xor     _BX, _BX

Frac2Mant1:

    mov     _AX, _SI
    and     _AX, _DI
    dec     cl
    jz      short Frac2MantGetFrac
    add     _BX, _AX
    add     _BX, _BP

Frac2Mant2:

    shr     _DI, 3
    mov     _AX, _SI
    and     _AX, _DI
    dec     cl
    jz      short Frac2MantGetFrac          ;
    add     _BX, _AX                        ; correct 2
    add     _BX, _BP

Frac2Mant3:

    shr     _DI, 4                          ; shift away correction 2/10
    mov     _AX, _SI
    and     _AX, _DI
    dec     cl                              ; correct 3
    jz      short Frac2MantGetFrac          ;
    add     _BX, _AX                        ;
    add     _BX, _BP

Frac2Mant4:

    shr     _DI, 3
    mov     _AX, _SI
    and     _AX, _DI
    dec     cl                              ; correct 4
    jz      short Frac2MantGetFrac          ;
    shr     _DI, 1                          ; pre-shift, remainding all 2 bits
    mov     _SI, 3

Frac2Mant5_10:

    add     _BX, _AX
    add     _BX, _BP
    shr     _DI, 2
    mov     _AX, _SI
    and     _AX, _DI
    dec     cl
    jnz     short Frac2Mant5_10

Frac2MantGetFrac:

    add     _BP, _AX

    ;
    ; Now,    _BX=Minimum x.00x,
    ;         _BP=different to the next mantissa x.000x + 0.0001
    ;         _DX=fraction ratio (0.000000 - 0.099999)
    ;
    ; Total Dif = _BX + ((_BP * _DX) / 100000)
    ;
    ; _BP * _DX will never greater than 32-bit because (_DX < 100000) and
    ; _BP < (2^9 = 512)
    ;

    mov     _AX, _BX
    or      _DX, _DX                        ; zero fraction?
    jz      short Frac2MantDoneFrac
    mov     _AX, _BP
    mul     _DX                             ; _DX:_AX=products
    add     _AX, 50000                      ; round up
    adc     _DX, 0
    mov     _CX, 100000
    div     _CX                             ; _AX=quotient
    add     _AX, _BX

Frac2MantDoneFrac:

    cdq                                     ; _DX:_AX=final number

    @EXIT                                   ; exiting function

ENDIF                                       ; i8086 or i286


@END_PROC



FD6P1ToP9   dd   100000
            dd   200000
            dd   300000
            dd   400000
            dd   500000
            dd   600000
            dd   700000
            dd   800000
            dd   900000
            dd  1000000



SUBTTL  MantissaToFraction
PAGE

COMMENT `

Routine Description:

    This function take mantissa number and convert it to the decimal fraction
    in FD6 format.

Arguments:

    Mantissa        - the mantissa values which will converted to the the
                      fraction number.

    CorrectData     - The correction data which from MantissaCorrectData[]

Return Value:

    No error returned, the return value is the fraction value for the mantissa
    passed in, it range from 0.000000 - 1.000000

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

Revision History:

`


@BEG_PROC   MantissaToFraction  <Mantissa:DWORD, CorrectData:DWORD>




IF i8086 OR i286                        ; lots of works for this kind of CPU


    @ENTER  _SI _DI _BP                 ; saved used registers

    ;
    ; starting correction
    ;
    ;       <---High Word---> <----Low Word--->
    ;  Bit#  3          2          1          0
    ;       10987654 32109876 54321098 76543210
    ;       | | | |  | |  |   ||  |  |
    ;       | | | |  | |  |   ||  |  +-- x.000 Minimum Difference
    ;       | | | |  | |  |   ||  +----- x.001-x.002 (0-7) Correct 1
    ;       | | | |  | |  |   |+-------- x.000-x.001 (0-7) Correct 2
    ;       | | | |  | |  |   +--------- x.009-y.000 (0-1) Correct 10
    ;       | | | |  | |  +------------- x.009-y.000 (0-7) Correct 3
    ;       | | | |  | +---------------- x.008-x.009 (0-7) Correct 4
    ;       | | | |  +------------------ x.007-x.008 (0-3) Correct 5
    ;       | | | +--------------------- x.006-x.007 (0-3) Correct 6
    ;       | | +----------------------- x.005-x.006 (0-3) Correct 7
    ;       | +------------------------- x.004-x.005 (0-3) Correct 8
    ;       +--------------------------- x.003-x.004 (0-3) Correct 9
    ;

    mov     ax, WPTR Mantissa           ; only 16-bit needed
    mov     cx, WPTR CorrectData
    mov     dx, WPTR CorrectData + 2    ; dx:cx=correct data

    mov     bp, cx                          ; first get the DifMin = 9 bits
    and     bp, 01ffh                       ; bp=base
    xor     si, si                          ; si=fraction index
    mov     di, 7

Mant2Frac1:

    mov     bh, ch
    shr     bh, 1
    mov     cx, di
    and     cl, bh
    inc     si                              ; increase the fraction index
    add     cx, bp                          ; cx=range
    sub     ax, cx                          ; ax=mantissa
    jle     short Mant2FracGetFrac

Mant2Frac2:

    shr     bh, 1                           ; shift away correction 1
    shr     bh, 1
    shr     bh, 1                           ; bh bit 3 is the correction 10
    mov     cx, di
    and     cl, bh
    inc     si                              ; increase the fraction index
    add     cx, bp                          ; cx=range
    sub     ax, cx                          ; ax=mantissa
    jle     short Mant2FracGetFrac

Mant2Frac3:

    mov     cx, di
    and     cx, dx
    inc     si                              ; increase the fraction index
    add     cx, bp                          ; cx=range
    sub     ax, cx                          ; ax=mantissa
    jle     short Mant2FracGetFrac

Mant2Frac4:

    mov     cx, di
    cmp     cl, bh                          ; if bit 3 of bh is on then carry
    rcr     dx, 1                           ; we actually move that bit into
    shr     dx, 1                           ; bit 15 of dx
    shr     dx, 1                           ; shift away correction 3
    and     cx, dx
    inc     si                              ; increase the fraction index
    add     cx, bp                          ; cx=range
    sub     ax, cx                          ; ax=mantissa
    jle     short Mant2FracGetFrac

    shr     dx, 1                           ; shift away correction 4
    mov     di, 3                           ; this is the mask, all 2 bits now

Mant2Frac5_10:

    shr     dx, 1
    shr     dx, 1
    mov     cx, di
    and     cx, dx
    inc     si
    add     cx, bp                          ; cx=range
    sub     ax, cx                          ; ax=mantissa
    jg      short Mant2Frac5_10

Mant2FracGetFrac:

    ;
    ; si = fraction index of 000000 - 900000 (0-9)
    ; cx = range,
    ; ax = mantissa, if (ax=0) then si=frac else if (ax<0) then add range back
    ;
    ; Final Frac = (si * 1000000) + (((ax * 100000) + cx / 2) / cx)
    ;

    mov     dx, 0
    jz      short Mant2FracGetFracH         ; si=fraction index

    add     ax, cx                          ; move it back since negative
    dec     si                              ; move the index back by one
    mov     dx, 0c350h                      ; 100000 = (50000 * 2)
    mul     dx                              ; dx:ax= ax * 50000 of the mantissa
    add     ax, ax
    adc     dx, dx                          ; dx:ax = ax * 100000

    xor     di, di
    cmp     dx, cx
    jb      short Mant2FracDiv2

    mov     di, ax                          ; save dividend L
    mov     ax, dx
    xor     dx, dx
    div     cx                              ; 0:ax / bx, dx=r, ax=q
    xchg    di, ax                          ; dx:ax=remainder, di=q

Mant2FracDiv2:

    div     cx                              ; dx=remainder, di:ax=q

    add     dx, dx                          ; to round up, check if
    sub     dx, cx                          ; (remainder * 2) > divisor, if yes
    mov     dx, 0
    cmc                                     ; then increase the qoutient by 1
    adc     ax, dx
    adc     dx, di                          ; dx:ax=((ax*100000) + cx/2) / cx)

Mant2FracGetFracH:

    dec     si
    js      short Mant2FracDone
    add     si, si                          ; 4 bytes alignment
    add     si, si
    add     ax, WORD PTR cs:FD6P1ToP9[si]
    adc     dx, WORD PTR cs:FD6P1ToP9[si+2]

Mant2FracDone:

    @EXIT

ELSE

    ;*************************************************************************
    ; for i386 or upward compatble
    ;*************************************************************************

    @ENTER  _SI _DI                          ; entering function

    ;
    ; starting correction
    ;
    ;       <---High Word---> <----Low Word--->
    ;  Bit#  3          2          1          0
    ;       10987654 32109876 54321098 76543210
    ;       | | | |  | |  |   ||  |  |
    ;       | | | |  | |  |   ||  |  +-- x.000 Minimum Difference
    ;       | | | |  | |  |   ||  +----- x.001-x.002 (0-7) Correct 1
    ;       | | | |  | |  |   |+-------- x.000-x.001 (0-7) Correct 2
    ;       | | | |  | |  |   +--------- x.009-y.000 (0-1) Correct 10
    ;       | | | |  | |  +------------- x.009-y.000 (0-7) Correct 3
    ;       | | | |  | +---------------- x.008-x.009 (0-7) Correct 4
    ;       | | | |  +------------------ x.007-x.008 (0-3) Correct 5
    ;       | | | +--------------------- x.006-x.007 (0-3) Correct 6
    ;       | | +----------------------- x.005-x.006 (0-3) Correct 7
    ;       | +------------------------- x.004-x.005 (0-3) Correct 8
    ;       +--------------------------- x.003-x.004 (0-3) Correct 9
    ;

    movzx   _AX, WPTR Mantissa          ; only 16-bit needed
    mov     _DX, DPTR CorrectData      ; _DX=correct data
    mov     _CX, _DX                        ; first get the DifMin = 9 bits
    and     _CX, 01ffh                      ; _CX=base
    mov     bx, dx                          ; move correction 10 (1 bit) to
    shl     bx, 1                           ; _DX bit 31
    rcr     _DX, 1
    shr     _DX, 8                          ; shift out rest of the bits
    xor     _BX, _BX                        ; _BX=fraction count
    mov     _SI, 7                          ; si=mask

Mant2Frac1:

    mov     _DI, _SI                        ; get mask
    and     _DI, _DX                        ; _DI=current correction 1
    inc     _BX                             ; increase the fraction index
    add     _DI, _CX                        ; _DI=range to next
    sub     _AX, _DI                        ; substract the mantissa from it
    jle     short Mant2FracGetFrac

Mant2Frac2:

    shr     _DX, 3                          ; shift away correction 1
    mov     _DI, _SI
    and     _DI, _DX
    inc     _BX                             ; increase the fraction index
    add     _DI, _CX                        ; _DI=range to next
    sub     _AX, _DI                        ; substract the mantissa from it
    jle     short Mant2FracGetFrac

Mant2Frac3:

    shr     _DX, 4                          ; shift away correction 2/10
    mov     _DI, _SI
    and     _DI, _DX
    inc     _BX                             ; increase the fraction index
    add     _DI, _CX                        ; _DI=range to next
    sub     _AX, _DI                        ; substract the mantissa from it
    jle     short Mant2FracGetFrac

Mant2Frac4:

    shr     _DX, 3                          ; shift away correction 3
    mov     _DI, _SI
    and     _DI, _DX
    inc     _BX                             ; increase the fraction index
    add     _DI, _CX                        ; _DI=range to next
    sub     _AX, _DI                        ; substract the mantissa from it
    jle     short Mant2FracGetFrac

    mov     _SI, 3                          ; all the rest are 2 bits
    shr     _DX, 1                          ; pre-shift 1 bit for correction 4

Mant2Frac5_10:

    shr     _DX, 2
    mov     _DI, _SI
    and     _DI, _DX
    inc     _BX
    add     _DI, _CX
    sub     _AX, _DI
    jg      short Mant2Frac5_10

Mant2FracGetFrac:

    ;
    ; _BX = fraction index of 000000 - 900000 (0-9)
    ; _DI = range,
    ; _AX = mantissa, if (_AX=0) then _BX=frac
    ;                 else if (_AX<0) then add range back
    ;
    ; Final Frac = (_BX * 1000000) + (((_AX * 100000) + _DI / 2) / _DI)
    ;

    or      _AX, _AX
    jz      short Mant2FracGetFracH         ; BX=fraction index
    add     _AX, _DI                        ; _AX is negative, move it back
    dec     _BX                             ; by 1 step
    mov     _CX, 100000
    mul     _CX                             ; _DX:_AX=products
    mov     _CX, _DI
    shr     _CX, 1                          ; round up
    add     _AX, _CX
    adc     _DX, 0
    div     _DI                             ; _DX=r, _AX=q

Mant2FracGetFracH:

    dec     _BX                             ; see if alrady 0
    js      short Mant2FracDone
    add     _AX, DPTR cs:FD6P1ToP9[_BX * 4]     ; 4 bytes alignment

Mant2FracDone:

    cdq                                     ; _AX --> _DX:_AX

    @EXIT                                   ; exiting function

ENDIF                                       ; i8086 or i286


@END_PROC



;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
;@ Following codes only for 8086/80286, and all functions are used for       @
;@ internally                                                                @
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


IF i8086 OR i286                    ; lots of works for this kind of CPU


SUBTTL  U64Div1000000
PAGE

COMMENT `

Routine Description:

    This function divide a 64-bit number by 1000000 (decimal), this function
    only assembly under 8086/80286 cpu, for 80386 and up it will use in line
    code to do divison

Arguments:

    dx:ax:bp:bx - dividend

Return Value:

    dx:ax = round up quotient (dx:ax:bp:bx / 1000000 decimal)
            if dx:ax = 0x7fff:ffff then an overflow has been occurred.

    bp:bx registers are destroyed.

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)


Revision History:

`


    PUBLIC  U64Div1000000

U64Div1000000   label   near

    ;
    ; dx:ax:bp:bx / FD6NUM_1_DW (0f4240h) --> dx:ax=round up quotient
    ; registers bp/bx are destroyed
    ;
    ; dx:ax:bp:bx / FD6NUM_1_DW (0f4240h) = (dx:ax:bp:bx >> 4)/f424h)
    ;                                     = remainder << 4
    ;

    add     bx, 0a120h                  ; 0f4240h / 2 = 7a120h
    adc     bp, 7
    adc     ax, 0
    adc     dx, 0                       ; round up

    ; shift the dividend right by 4 (64 bits shifts)

    shr     dx, 1
    rcr     ax, 1
    rcr     bp, 1
    rcr     bx, 1

    shr     dx, 1
    rcr     ax, 1
    rcr     bp, 1
    rcr     bx, 1

    shr     dx, 1
    rcr     ax, 1
    rcr     bp, 1
    rcr     bx, 1

    shr     dx, 1
    rcr     ax, 1
    rcr     bp, 1
    rcr     bx, 1

u64Div1000000_0:

    or      dx, dx                      ; dx must be zero (lower 48 bits only)
    jnz     short u64Div1000000_OF      ; 0:ax:bp:bx / divisor
    mov     dx, ax                      ; aligned the dividend in dx:ax:bx
    mov     ax, bp                      ; dx:ax:bx / bp
    mov     bp, 0f424h                  ; divisor = f424h
    cmp     dx, bp
    jae     short u64Div1000000_OF      ; dx:ax:bx / bp
    div     bp                          ; dx=r, ax=q
    xchg    ax, bx                      ; bx=q, dx:ax=remainder
    div     bp                          ; bx:ax=q
    mov     dx, bx                      ; dx:ax=q
    ret

u64Div1000000_OF:

    mov     ax, 0ffffh
    mov     dx, 07fffh
    ret



SUBTTL  U32Mul1000000
PAGE

COMMENT `

Routine Description:

    This function multiply a 32-bit number by 1000000 (decimal), this function
    only assembly under 8086/80286 cpu, for 80386 and up it will use in line
    code to do divison

Arguments:

    dx:ax   - multiplicand

Return Value:

    dx:ax:bp:bx - final 64-bit number which is dx:ax * 1000000 decimal

    CX register destroyed

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)


Revision History:

`


    PUBLIC  u32Mul1000000

u32Mul1000000   label   near

    ;
    ; at return dx:ax:bp:bx is the (dx:ax * 1000000 (decimal))
    ; cx is destroyed
    ;
    ; dx:ax * FD6NUM_1_DW0 (0f4240h) = (dx:ax * f424h) << 4
    ;
    ;            dx:ax
    ;       x       bp
    ;    -----------------
    ;            ax:bp    x0 =    bp:bx
    ;         dx:bp       x1 = dx:ax
    ;---------------------
    ;

    mov     cx, 0f424h
    xor     bp, bp                      ; assuem x0=0
    xor     bx, bx
    or      ax, ax
    jz      short u32Mul1000000_1       ; jmp if ax=0
    mov     bx, dx                      ; save it
    mul     cx                          ; dx:ax=result = x0
    xchg    dx, bp
    xchg    ax, bx                      ; bp:bx=x0, ax=high 16-bit, dx=0
    xchg    dx, ax                      ; dx=high 16-bit, ax=0 to fall through

u32Mul1000000_1:

    xchg    dx, ax                      ; dx=0, ax=next 16-bit
    or      ax, ax
    jz      short u32Mul1000000_2       ; nothing to do
    mul     cx                          ; dx:ax=x1
    add     bp, ax                      ;         bp:bx = x0
    mov     ax, dx                      ;  +   dx:ax    = x1
    mov     dx, 0                       ;-----------------------
    adc     ax, dx                      ;   dx:ax:bp:bx = products
    adc     dx, dx

u32Mul1000000_2:

    add     bx, bx
    adc     bp, bp
    adc     ax, ax
    adc     dx, dx

    add     bx, bx
    adc     bp, bp
    adc     ax, ax
    adc     dx, dx

    add     bx, bx
    adc     bp, bp
    adc     ax, ax
    adc     dx, dx

    add     bx, bx
    adc     bp, bp
    adc     ax, ax
    adc     dx, dx
    ret




SUBTTL  U64DivU32_U32
PAGE

COMMENT `

Routine Description:

    This function divide a 64-bit number by 32-bit number.
    only assembly under 8086/80286 cpu, for 80386 and up it will use in line
    code to do divison

Arguments:

    dx:ax:bp:bx - dividend
    si:di       - divisor

Return Value:

    bx:cx       - 32-bit unsigned quotient, if dx:ax = 7fff:ffff then overflow.
    dx:ax       - 32-bit unsigned remainder
    si:di       = divisor (unchanged)

    all other registers are destroyed

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

        Total re-construct, re-write, it make it calculate the 6 decimal
        points precision easier for not using slow floating emulation, the
        speed is faster then the reqular (long/long) routine in the
        standard library while it provide me all the necessary color calcuation
        with good precisions.

Revision History:

`

;==========================================================================
; Defined several useful data at here
;==========================================================================


RShiftTable equ this word
    dw      RShift_0
    dw      RShift_1
    dw      RShift_2
    dw      RShift_3
    dw      RShift_4
    dw      RShift_5
    dw      RShift_6
    dw      RShift_7

ShiftTable1     equ     this word
    dw      1000h       ; 00010000 00000000
    dw      0010h       ; 00000000 00010000

ShiftTable2     equ     this word
    dw      4000h       ; 01000000 00000000
    dw      0400h       ; 00000100 00000000
    dw      0040h       ; 00000000 01000000
    dw      0004h       ; 00000000 00000100

ShiftTable3     equ     this word
    dw      8000h       ; 10000000 00000000
    dw      2000h       ; 00100000 00000000
    dw      0800h       ; 00001000 00000000
    dw      0200h       ; 00000010 00000000
    dw      0080h       ; 00000000 10000000
    dw      0020h       ; 00000000 00100000
    dw      0008h       ; 00000000 00001000
    dw      0002h       ; 00000000 00000010

;***************************************************************************
; END OF LOCAL DATA
;***************************************************************************


uDiv6432_L16:

    ;
    ; dx:ax:bp:bx / si:di (si=0) = dx:ax/bx:cx
    ;

    or      di, di
    jz      short uDiv6432_Overflow
    or      dx, dx
    jnz     short uDiv6432_Overflow     ; dx=0 otherwise overflow
    cmp     ax, di
    jae     short uDiv6432_Overflow
    mov     dx, ax
    mov     ax, bp                      ; move up
    div     di                          ; dx:bx=remainder, ax=quotient
    xchg    bx, ax                      ; dx:ax=remainder, bx=quotient
    div     di                          ; dx=remainder, bx:ax=quotient

    mov     cx, dx                      ; cx=remainder, bx:ax=quotient
    mov     dx, bx                      ; cx=remainder, dx:ax=quotient
    xor     bx, bx                      ; bx:cx=remainder, dx:ax=quotient
    ret

uDiv6432_H16:

    ;
    ; dx:ax:bp:bx / si:di (di=0) = dx:ax/bx:cx
    ;

    cmp     dx, si
    jae     short uDiv6432_Overflow     ; the dividend too big
    div     si                          ; dx:bp:bx=remainder, ax=quotient
    xchg    bp, ax                      ; dx:ax:bx=remainder, bp=quotient
    div     si                          ; dx:bx=remainder, bp:ax=quotient
    mov     cx, bx                      ; dx:cx=remainder, bp:ax=quotient
    mov     bx, dx                      ; bx:cx=remainder, bp:ax=quotient
    mov     dx, bp                      ; bx:cx=remainder, dx:ax=quotient
    ret

uDiv6432_Overflow:

    mov     dx, 07fffh                  ; return quotient (dx:ax) = max. number
    mov     ax, 0ffffh
    xor     bx, bx
    xor     cx, cx
    ret


    PUBLIC  U64DivU32_U32

U64DivU32_U32   label   near

    ;
    ; dx:ax:bp:bx / si:di = dx:ax/bx:cx
    ;

    or      si, si
    jz      short uDiv6432_L16
    or      di, di
    jz      short uDiv6432_H16
    cmp     dx, si                      ; have to make sure dx/si != 0
    jae     short uDiv6432_Overflow     ; the dividend too big

uDiv6432_M1a:

    ;
    ; dx:ax:bp:bx / si:di
    ; dx:ax=remainder, bx:cx=quotient
    ;

    push    bx                          ; save lowest 16-bit of dividend
    div     si                          ; dx=r, ax=q
    mov     cx, dx                      ; cx:bp:sp=r, bx=q
    mov     bx, ax
    mul     di                          ; dx:ax=overrun, cx:bp=remainder
                                        ; bx=quotient
    xchg    ax, bp                      ; cx:bp=overrun, dx:ax=last remainder
    xchg    dx, cx
    sub     ax, bp                      ; remainder - overrun
    sbb     dx, cx

    mov     bp, 0                       ; no shift count
    jnc     short uDiv6432_M1c          ; remainder >= overrun

    ;
    ; now we have -(dx:ax) of overrun, we need to add the divisor back until
    ; dx:ax is not negative, for every divisor (si:di) we add the quotient (bx)
    ; must decrement by one.
    ;
uDiv6432_M1b:

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1c          ; carry on...

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1c          ; carry on...

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1c          ; carry on...

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1c          ; carry on...

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1c          ; carry on...

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1c          ; carry on...

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1c          ; carry on...

    call    uDiv6432_QR                 ; at return BP=shift count
                                        ; bx=adjusted quot, dx:ax=remainder
uDiv6432_M1c:

    mov     cx, bp                      ; save shift count in CX
    pop     bp                          ; bp=lowest 16-bit of dividend
    push    bx                          ; save high 16-bit of quotient

    cmp     dx, si
    jae     short uDiv6432_NegDiv       ; using negative division algorithm

    push    cx                          ; save shift count

uDiv6432_M1d:

    div     si                          ; dx=r, ax=q
    mov     cx, dx                      ; cx=r, sp:bx=q
    mov     bx, ax                      ; cx:bp=r, sp:bx=q
    mul     di                          ; dx:ax=remainder 2

    xchg    ax, bp                      ; cx:bp=overrun, dx:ax=last remainder
    xchg    dx, cx
    sub     ax, bp                      ; remainder - overrun
    sbb     dx, cx

    pop     bp                          ; get shift count

    jnc     short uDiv6432_M1e          ; remainder >= overrun

    ;
    ; now we have -(dx:ax) of overrun, we need to add the divisor back until
    ; dx:ax is not negative, for every divisor (si:di) we add the quotient (bx)
    ; must decrement by one.
    ;

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1e          ; do until positive number

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1e          ; do until positive number

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1e          ; do until positive number

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1e          ; do until positive number

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1e          ; do until positive number

    call    uDiv6432_QR                 ; too many call-up the division
                                        ; bx=adjusted quot, dx:ax=remainder
uDiv6432_M1e:                           ; sp:bx=quotient, dx:ax=remainder

    mov     cx, ax                      ; sp:bx=quotient, dx:cx=remainder
    mov     ax, bx                      ; sp:ax=quotient, dx:cx=remainder
    mov     bx, dx                      ; sp:ax=quotient, bx:cx=remainder
    pop     dx                          ; dx:ax=quotient, bx:cx=remainder
    ret

;
;
;============================================================================
; interal subfunctions to the uDiv6432
;============================================================================
;
;
; uDiv6432_NegDiv --- Negate and divide algorithm
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;
; dx:ax:bp / si:di, *sp=high qoutient
;
; (dx == si) and (ax < di) at here
;
; now we use maximum difference (di:0 - ax:bp) as estimate 32-bit
; dividend number then divide it by divisor, the (0xffff - resulting
; quotient) is the original quotient, and remainder is equal to
; (divisor - resulting remainder), the only exception is that if remainder
; is zero then the quotient need to increment by 1.
;

uDiv6432_NegDiv:

    mov     dx, di
    neg     bp
    sbb     dx, ax
    mov     ax, bp                          ; dx:ax=inverted 32-bit dividend
    call    uDiv3232_32Divisor              ; dx:ax=quot (0:ax) bx:cx=remainder
    jz      short uDiv6432_NegDiv1          ; remainder = 0, just negate quot
    inc     ax                              ; compensate for non-zero remainder
    neg     bx                              ; remainder = divosr - remainder
    neg     cx                              ; bx=0 at here
    sbb     bx, dx
    add     cx, di
    adc     bx, si                          ; bx:cx=final remainder

uDiv6432_NegDiv1:

    neg     ax                              ; negate the quotient
    pop     dx                              ; dx:ax=quot, bx:cx=remainder
    ret

;
; uDiv6432_QR - 32-bit/32-bit with previos quotient adjustment
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;
; Entry:
;       bp      = shift count
;       bx      = Previous quotient to be adjusted
;       dx:ax   = Negative overrun factor
;       si:di   = Divisor
;
; Exit:
;       bx      = Adjusted quotient
;       dx:ax   = positive/0 remainder after overun adjustment
;       si:di   = divisor (unchanged)
;
; cx, bp destroyed
;

uDiv6432_QR:


    NEG32_FROMR16HL dx, ax

    ;
    ; dx:ax / si:di (bx:di)
    ; remainder = dx:ax
    ;

uDiv6432_QR_0:

    xchg    bx, bp                      ; bp=quotient, bx=shift count

    ; dx:ax / cx:di


uDiv6432_QR_1:


    or      bx, bx
    jnz     short HasShiftCount

    ;
    ; shift dx:ax/cx:di right by bp shift count
    ;

    cmp     si, 0100h                   ; right side set the carry
    adc     bl, bl                      ; 0 <= bx <= 1

    add     bx, bx                      ; bx = 0, 2, pre-shift for word table
    cmp     si, cs:ShiftTable1[bx]      ; split again
    adc     bl, bh                      ; 0 <= bx <= 3

    add     bx, bx                      ; bx = 0,2,4,6, shift for word table
    cmp     si, cs:ShiftTable2[bx]
    adc     bl, bh                      ; 0 <= bx <= 7

    add     bx, bx                      ; bx = 0,2,4,6,8,10,12,14
    cmp     si, cs:ShiftTable3[bx]
    adc     bl, bh                      ; 0 <= bx <= 15
    neg     bx
    add     bx, 16

HasShiftCount:

    push    bx                          ; save shift count back

    push    dx                          ; save dividend high
    push    di                          ; save divisor low
    push    bp                          ; save quotient
    mov     bp, ax                      ; save dividend low
    mov     cx, si

    ;
    ; dx:ax / cx:di,  sp=shift count, sp+2=dx, sp+4=di, sp+6=quotient

    cmp     bx, 8
    jb      short Shift1

    mov     al, ah
    mov     ah, dl
    mov     dl, dh
    xor     dh, dh

    xchg    ax, di
    mov     al, ah
    mov     ah, cl
    mov     cl, ch
    xor     ch, ch
    xchg    ax, di

    and     bx, 7

Shift1:

    add     bx, bx
    jmp     cs:RShiftTable[bx]

RShift_7:
    shr     dx, 1
    rcr     ax, 1
    shr     cx, 1
    rcr     di, 1
RShift_6:
    shr     dx, 1
    rcr     ax, 1
    shr     cx, 1
    rcr     di, 1
RShift_5:
    shr     dx, 1
    rcr     ax, 1
    shr     cx, 1
    rcr     di, 1
RShift_4:
    shr     dx, 1
    rcr     ax, 1
    shr     cx, 1
    rcr     di, 1
RShift_3:
    shr     dx, 1
    rcr     ax, 1
    shr     cx, 1
    rcr     di, 1
RShift_2:
    shr     dx, 1
    rcr     ax, 1
    shr     cx, 1
    rcr     di, 1
RShift_1:
    shr     dx, 1
    rcr     ax, 1
    shr     cx, 1
    rcr     di, 1

RShift_0:

    pop     bx                      ; restore quotient

    div     di                      ; get estimate quotient = ax
    sub     bx, ax                  ; decrement the quotient
    mov     cx, ax                  ; ax=bx=estimate quotient
    pop     di                      ; si:di=original divisor

    ;
    ;    estimation of Quotient = eQ
    ;
    ;               vH:vL
    ;                  eQ
    ;    -------------------
    ;               vL:eQ          -- x0    dx:ax
    ;            vH:eQ             -- x1 ..:cx
    ;   -----------------------------------------------
    ;                                    ..:dx:ax
    ;
    ;
    ;   dx += cx;
    ;
    ;   if (carry)              return (eQ - 1);
    ;   if (dx:ax > original dividend) return(eQ - 1) else return(eQ)
    ;
    ; now multiply the eQ (bx) with original divisor (si:di)
    ; now cx:bp=original dividend
    ;

    mul     si                      ; dx:ax, using only ax
    xchg    ax, cx                  ; ax=eQ, cx=H(eQ * Divisor)
    mul     di                      ; dx:ax=L(eQ * Divisor)
    add     dx, cx
    pop     cx                      ; restore cx (original High dividend)

    jc      short uDiv6432_QR_s1

    cmp     dx, cx
    ja      short uDiv6432_QR_s1
    jb      short uDiv6432_QR_s2
    cmp     ax, bp
    jbe     short uDiv6432_QR_s2

uDiv6432_QR_s1:

    inc     bx                      ; add 1 back to the quotient
    sub     ax, di                  ; substract divisor
    sbb     dx, si

uDiv6432_QR_s2:
                                    ; substract original dividend
    sub     ax, bp                  ; at here, we either carry or zero
    sbb     dx, cx
    jnc     short uDiv6432_QR_Done

    ;
    ; still has overrun, that is we have remainder,
    ;

    dec     bx                      ; substract one from the qoutient
    add     ax, di
    adc     dx, si

uDiv6432_QR_Done:

    pop     bp                      ; return BP=shift count
    ret





SUBTTL  U32MulU32_U64
PAGE

COMMENT `

Routine Description:

    This function multiply a 32-bit multipicand with a 32-bit multiplier
    and return a 64-bit product.

    only assembly under 8086/80286 cpu, for 80386 and up it will use in line
    code to do divison

Arguments:

    bp:bx = multiplicand
    dx:ax = multiplier

Return Value:

    dx:ax:bp:bx - 64-bit products (dx:ax * bp:bx)

    all other registers are destroyed.

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

        Total re-construct, re-write, it make it calculate the 6 decimal
        points precision easier for not using slow floating emulation, the
        speed is faster then the reqular (long/long) routine in the
        standard library while it provide me all the necessary color calcuation
        with good precisions.

Revision History:

`


    PUBLIC  U32MulU32_U64

U32MulU32_U64   label   near


    ;           bp:bx                        bp:bx
    ;         x dx:ax                      x si:di
    ; ----------------             ----------------
    ;           bx*ax    x0                  bx*di    x0
    ;        bp*ax       x1               bp*di       x1
    ;        bx*dx       x2               bx*si       x2
    ;   + bp*dx          x3          + bp*si          x3
    ; =====================        =====================
    ;     dx:ax:bp:bx    products      dx:ax:bp:bx    products

uMul3232_Low:

    mov     di, ax                      ; save multiplier in si:di
    mov     si, dx

    xor     cx, cx
    xor     dx, dx
    xor     ax, ax

    or      di, di                      ; see if zero (no business here)
    jz      short uMul3232_High

uMul3232_x0:

    or      bx, bx                      ; zero ?
    jz      short uMul3232_x1
    mov     ax, di
    mul     bx                          ; dx:ax = x0

uMul3232_x1:

    or      bp, bp
    jz      short uMul3232_x1a          ; zeroing the DI

    xchg    di, ax                      ; cx:di = x0, ax=di
    mov     cx, dx
    mul     bp                          ; dx:ax = x1

    xchg    di, ax                      ;         dx:ax = x0
    xchg    cx, dx                      ;      cx:di    = x1
                                        ; --------------------
    add     dx, di                      ;   di:cx:dx:ax

uMul3232_x1a:

    mov     di, 0
    adc     cx, di
    adc     di, di

uMul3232_High:

    or      si, si                      ; now di:cx:dx:ax = x0+x1
    jz      short uMul3232_Done

uMul3232_x2:

    or      bx, bx
    jz      short uMul3232_x3           ; di:cx:dx:ax

    push    ax
    xchg    bx, dx                      ; di:cx:dx:ax ===> di:cx:bx:push
    mov     ax, si                      ;                     dx:ax     = x3
    mul     dx                          ;

    add     bx, ax
    mov     ax, 0
    adc     cx, dx
    adc     di, ax                      ; di:cx:bx:ax
    pop     ax
    mov     dx, bx                      ; di:cx:bx:ax -> di:cx:dx:ax

uMul3232_x3:

    or      bp, bp
    jz      short uMul3232_Done         ;

    mov     bx, dx
    xchg    si, ax                      ; di:cx:dx:ax --> di:cx:bx:si
    mul     bp                          ; dx:ax        = x3

    add     cx, ax
    adc     di, dx                      ; di:cx:bx:si => dx:ax:bp:bx

    mov     dx, di
    mov     ax, cx
    mov     bp, bx
    mov     bx, si
    ret

uMul3232_Done:                          ; di:cx:dx:ax -> dx:ax:bp:bx

    mov     bp, dx
    mov     bx, ax
    mov     dx, di
    mov     ax, cx
    ret




SUBTTL  U32DivU32_U32
PAGE

COMMENT `

Routine Description:

    This function divide a 32-bit number by 32-bit number and return both
    32-bit quotient and 32-bit remainder.

    only assembly under 8086/80286 cpu, for 80386 and up it will use in line
    code to do divison

Arguments:

    dx:ax       - 32-bit unsigned Dividend
    si:di       - 32-bit unsigned Divisor

Return Value:

    dx:ax       - 32-bit unsigned quotient,
    bx:cx       - 32-bit unsigned remainder
    si:di       - Divisor, unchanged.
    zero flag   - set if remainder is zero, clear otherwise
    cx/bp       - destroyed.

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

        Total re-construct, re-write, it make it calculate the 6 decimal
        points precision easier for not using slow floating emulation, the
        speed is faster then the reqular (long/long) routine in the
        standard library while it provide me all the necessary color calcuation
        with good precisions.

Revision History:

`

    PUBLIC  U32DivU32_U32

U32DivU32_U32   label   near

;
; dx:ax / si:di ====> dx:ax=quotient, bx:cx=remainder
;

    or      si, si
    jnz     short uDiv3232_32Divisor

    or      di, di                      ; if di=0, then error
    jz      short uDiv3232_Err

    xor     bx, bx                      ; assume quotient H = 0
    cmp     dx, di                      ; see if will overflow ?
    jb      short uDiv3232_1

    mov     bx, ax                      ; save dividend L in bx
    mov     ax, dx
    xor     dx, dx
    div     di                          ; 0:ax/di, dx=r, ax=q
    xchg    bx, ax                      ; dx:ax=remainder, bx=quotient H

uDiv3232_1:

    div     di                          ; bx:ax=quotient, dx=remainder
    mov     cx, dx                      ; bx:ax=quotient, cx=remainder
    mov     dx, bx                      ; dx:ax=quotient, cx=remainder
    xor     bx, bx                      ; dx:ax=quotient, bx:cx(0:cx)=remainder
    or      cx, cx                      ; return zero flag for remainder
    ret

uDiv3232_Err:

    sub     bx, bx
    sub     cx, cx                      ; remainder = 0
    ret


uDiv3232_Zero:

    mov     cx, ax
    mov     bx, dx                      ; return remainder = dividend
    or      ax, dx                      ; return (BOOL)(remainder == 0)
    mov     ax, 0
    mov     dx, 0                       ; dx:ax=quotient, bx:cx=remainder
    ret

uDiv3232_One:

    mov     ax, 1                       ; return quotient = 1 and no remainder
    sub     dx, dx                      ; return dx:ax=1 (quotient) bx:cx=0
    sub     bx, bx                      ; (remainder) and zero flag set to
    sub     cx, cx                      ; indicate that remainder is zero
    ret                                 ; indicate that remainder is zero


    PUBLIC  uDiv3232_32Divisor

uDiv3232_32Divisor  label  near         ; full 32-bit divisor

    ;
    ; dx:ax / si:di = dx:ax/bx:cx
    ;

    mov     bx, dx
    mov     cx, ax
    sub     cx, di
    sbb     bx, si
    jc      short uDiv3232_Zero         ; if carry then dx:ax < si:di
    or      cx, bx                      ; if bx:cx=0 then dx:ax=si:di
    jz      short uDiv3232_One

    ;
    ; dx:ax / si:di     (bx:cx / bp:ss:sp)
    ;

    mov     bx, dx
    mov     cx, ax
    mov     bp, si
    push    di

    ; dx:ax / bp:di

    shl     di, 1                   ; prepare to fall through

uDiv3232_3:

    rcr     di, 1                   ; first pass, so that we do not
    ;===============                ; need to do a seperate check to
    shr     dx, 1                   ; see if 'bp' alreay zero
    rcr     ax, 1
    shr     bp, 1
    jnz     short uDiv3232_3
    rcr     di, 1                   ; do the last one

    ;
    ; ready to divide a 32-bit number by 16-bit number

    div     di                      ; get estimate quotient = ax
    mov     bp, ax                  ; ax=bp=estimate quotient
    pop     di                      ; si:di=original divisor

    ;
    ;    estimation of Quotient = eQ
    ;
    ;               vH:vL
    ;                  eQ
    ;    -------------------
    ;               vL:eQ          -- x0    dx:ax
    ;            vH:eQ             -- x1 ..:cx
    ;   -----------------------------------------------
    ;                                    ..:dx:ax
    ;
    ;
    ;   dx += cx;
    ;
    ;   if (carry)              return (eQ - 1);
    ;   if (dx:ax > original dividend) return(eQ - 1) else return(eQ)
    ;
    ; now multiply the eQ (bp) with original divisor (si:di)
    ; now bx:cx=original dividend
    ;

    mul     si                      ; dx:ax, using only ax
    push    bp                      ; save eQ
    xchg    ax, bp                  ; ax=eQ, bp=H(eQ * Divisor)
    mul     di                      ; dx:ax=L(eQ * Divisor)
    add     dx, bp
    pop     bp                      ; get the eQ back
    jc      short uDiv3232_EQm1     ; the eQ*Divisor is one divisor higher
    cmp     dx, bx                  ; if the eQ*Divisor > original dividend
    jc      short uDiv3232_EQ       ; then the quotient need decrement by 1
    ja      short uDiv3232_EQm1     ; if less or equal then is ok
    cmp     ax, cx
    jbe     short uDiv3232_EQ

uDiv3232_EQm1:                      ; eQ-1: bp=eQ, dx:ax=eQ*Divisor, bx:cx=dvnd

    dec     bp                      ; decrement the eQ by 1
    sub     ax, di                  ; and also substract the divisor one more
    sbb     dx, si                  ; time to compensate for the eQ-1

uDiv3232_EQ:                        ; eQ: bp=q, dx:ax=eQ * Divisor, bx:cx=dvnd

    sub     cx, ax                  ; remainder of the number is
    sbb     bx, dx                  ; original dividend - (eQ * Divisor)
    mov     ax, bp                  ; 0:ax (dx:ax)=quotient, bx:cx=remainder
    mov     dx, cx
    or      dx, bx                  ; return zero flag for (remainder == 0)
    mov     dx, 0                   ; quotient high always zero at here
    ret

;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
;@ End of only for 8086/80286 only, and all functions are used internally    @
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

ENDIF                               ; i8086/i286
ENDIF                               ; HT_ASM_80x86




END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\i386\htstub.asm ===
PAGE 60, 132
    TITLE   Stub for halftone DLL

COMMENT `


Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htstub.asm


Abstract:

    This module is provided as necessary for OS/2 as a DLL entry point


Author:

    05-Apr-1991 Fri 15:55:08 created  -by-  Daniel Chou (danielc)


[Environment:]

    Printer Driver.


[Notes:]


Revision History:

`



        .XLIST
        INCLUDE i386\i80x86.inc
        .LIST


        EndFunctionName CATSTR <>

IF  HT_ASM_80x86

NeedStub = 0

IFDEF _OS2_
NeedStub = 1
ENDIF

IFDEF _OS_20_
NeedStub = 1
ENDIF

IF NeedStub

        EndFunctionName CATSTR <HalftoneInitProc>

        .CODE

extrn   HalftoneInitProc:FAR

HalftoneDLLEntry    proc FAR

        push    di                              ; push the hModule
        call    HalftoneInitProc
        pop     bx                              ; C calling convention
        ret

HalftoneDLLEntry    ENDP

ENDIF       ; NeedStub
ENDIF       ; HT_ASM_80x86

% END EndFunctionName                           ; make this one at offset 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\i386\i80x86.inc ===
COMMENT `

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    i80x86.inc

Abstract:

    This module header provide set of defined/macros to be includes in all
    assembly files assembled under halftone directory, it provide a generalized
    convensions to make the single codes fragment to be complied under
    8086, 80186, 80286, 80386, 80486, 80586 family.

Author:

    03-Apr-1991 Wed 10:28:50 created  -by-  Daniel Chou (danielc)


[Environment:]

    Printer Driver.


[Notes:]


Revision History:
    28-Mar-1992 Sat 21:10:26 updated  -by-  Daniel Chou (danielc)
        Add in macros for debugging support



    18-Oct-1991 Fri 11:38:51 updated  -by-  Daniel Chou (danielc)

        Add in following new macros

            NEG32_FROMR16HL
            NEG64_FROMR32HL
            S32_FROMR16HL_SR16
            S64_FROMR32HL_SR32

        Add in comment for each macro

`

IF1

AllNoCaseRegs   equ <al,ah,ax,bl,bh,bx,cl,ch,cx,dl,dh,dx,si,di,bp>
AllCaseRegs     equ <_AX,_BX,_CX,_DX,_SI,_DI,_BP>


;
; __@@VALID_PARAM:    INTERNAL MACRO
;
;   This macro provide a early validation of input registers for other macros
;   It will generate an error message and exiting from assembler if invalid
;   registers are found.
;

__@@VALID_PARAM? macro CallerName, NameIdx, Name, NoCaseNameList

    OkName = 0

    IFB <Name>
        IF1
            %OUT Error: (&CallerName) parameter NameIdx not specified.
            %OUT Valid= NoCaseNameList
        ENDIF
        .ERR
        EXITM
        EXITM
    ENDIF

    IRP OneName,<NoCaseNameList>
        IFIDNI <OneName>,<Name>
            OkName = 1
            EXITM
        ENDIF
    ENDM

    IFE OkName
        IF1
            %OUT Error: (&CallerName) Invalid Parameter NameIdx specified '&Name'.
            %OUT Valid= NoCaseNameList
        ENDIF
        .ERR
        EXITM
        EXITM
    ENDIF
ENDM


;
; __@@VALID_REG:    INTERNAL MACRO
;
;   This macro provide a early validation of input registers for other macros
;   It will generate an error message and exiting from assembler if invalid
;   registers are found.
;

__@@VALID_REG? macro CallerName, Reg, NoCaseRegsList, CaseRegsList
    OkReg = 0

    IFB <Reg>
        IF1
            %OUT Error: (&CallerName) no register name '&Reg' specified.
            %OUT Valid= NoCaseRegsList, CaseRegsList
        ENDIF
        .ERR
        EXITM
        EXITM
    ENDIF

    IFNB <NoCaseRegsList>
        IRP RegName,<NoCaseRegsList>
            IFIDNI <RegName>,<Reg>
                OkReg = 1
                EXITM
            ENDIF
        ENDM
    ENDIF

    IFNB <CaseRegsList>
        IRP RegName,<CaseRegsList>
            IFIDN <RegName>,<Reg>
                OkReg = 1
                EXITM
            ENDIF
        ENDM
    ENDIF

    IFE OkReg
        IF1
            %OUT Error: (&CallerName) Invalid register name '&Reg'.
            %OUT Valid= NoCaseRegsList, CaseRegsList
        ENDIF
        .ERR
        EXITM
        EXITM
    ENDIF
ENDM

;
; __@@EMIT: INTERNAL MACRO
;
;   This macro generate a single line of assembly code with left alignment so
;   the output can be easily referenced.
;


__@@EMIT macro OpCode, Operand1, Operand2
IFNB <Operand2>
    OpCode Operand1, Operand2
ELSE
IFNB <Operand1>
    OpCode Operand1
ELSE
    OpCode
ENDIF
ENDIF
ENDM


IFNDEF HT_STDCALL
    DoStdCall   EQU     <0>
ELSE
    DoStdCall   EQU     <HT_STDCALL>
ENDIF


IFNDEF DBG
    DBG             EQU <0>
ENDIF


IFDEF I8086
    i8086           EQU <I8086>
ENDIF

IFDEF I286
    i286            EQU <I286>
ENDIF

IFDEF I386
    i386            EQU <I386>
ENDIF

IFNDEF i8086
    i8086           EQU <0>
ENDIF

IFNDEF i286
    i286            EQU <0>
ENDIF

IFNDEF i386
    i386            EQU <0>
ENDIF


;
; If we can compile 80x86 assembly code, the HT_ASM_80x86 will be defined
;

IFDEF  _DOS_
    i8086           EQU <1>
    i286            EQU <0>
    i386            EQU <0>
ENDIF  ; _DIS_

IFDEF  _OS2_
    i8086           EQU <0>
    i286            EQU <1>
    i386            EQU <0>
ENDIF  ; _OS2_

IFDEF  _OS_20_
    i8086           EQU <0>
    i286            EQU <0>
    i386            EQU <1>
ENDIF  ; _OS_20_

IFDEF NO_ASM
    i8086           EQU <0>
    i286            EQU <0>
    i386            EQU <0>
ENDIF

HT_ASM_80x86    =   0                   ;; assume no assembly codes

ENDIF                                   ;; pass 1

;*****************************************************************************
IF i8086 OR i286 OR i386
;*****************************************************************************

HT_ASM_80x86    =   1

;
; To make the assembly code can run under 8088/8086/80286 and 80386 mode
; with single code to maintained, following guide lines should be obeied.
;
;  1. To load ds:si/esi from memory only using LDS_SI(mem) macro.
;
;  2. To load es:di/edi from memory only using LES_DI(mem) macro.
;
;  3. never using movzx, movsx 80386 instructions, using MOVZX_W and MOVSX_W
;     macros only, these macros must use to move only the 16-bit (word)
;     source operand.
;
;  4. To extend a 80386 16-bit registers to signed/unsigned 32-bit registers
;     only using WSXE(r) and WZXE(r) macros.
;
;  5. Memory access to seg:[si] or seg:[di] only using following macrors
;
;          BPTR_DS(RegIndex),          WPTR_DS(RegIndex)
;          BPTR_ES(RegIndex),          WPTR_ES(RegIndex)
;          BPTR_SS(Var, RegIndex),     WPTR_SS(Var, RegIndex)
;
;      Note:   A. When i80386 is enabled then BPTR_ES() and WPTR_ES are same
;                 as BPTR_DS() and WPTR_DS()
;
;  6. using _AX, _BX, _CX, _DX, _BP, _SI, _DI macro when there are used for
;     computing memory address.
;
;  7. when using loop instruction, remember ECX must has zero extend, when
;     loading cx for looping instruction later, it should using the macro
;     as MOVZX_W ECX, xxx.  where xxx is the register or memory locaiton
;
;  8. using BSXEAX <Byte> BZXEAX <Byte> macros to convert a signed 8-bit
;     register or memory value to either signed 16-bit AX or signed 32-bit EAX.
;
;  9. When using XLATE_BYTE(seg), the bx (ebx in i80386) must points to the
;     table starting address, and (seg) is the segment which the table resides
;     (only needed for i8088/i8086/i80286), the content in AL will be used as
;     an index to mapped the content in the bx+al and the result in move into
;     the AL register.
;
; 10. When using DSSI_RGB_TO_AX_INDEX macro, the ds:si/esi must points to the
;     current RGB (one byte for each color in that order) bytes array, after
;     the conversion the ds:si/esi will automatically advance 3 bytes, and
;     ax/eax contains the converted index number (0-4095) from 24-bit RGB
;     value.
;
; 11. Use LPTR_BX(Mem, Reg) to load 32-bit pointer to Reg:bx in
;     i8088/i8086/i80286 and and load 32-bit to ebx in i80386.
;


;*****************************************************************************
IF i386
;*****************************************************************************

ExtRegSet   = 1


;
; Because this is the 32-bit segment, for a 32-bit pointer type, a word is
; 32-bit long
;



        .386


        .MODEL SMALL, C                         ;; All 32-bit operation

;        assume cs:flat,ds:flat,es:flat,ss:flat
;        assume fs:nothing,gs:nothing


        IF1
        %OUT    *** Compiling 80386 Assembly Codes ***
        %OUT
        ENDIF

;
; Macros definition for the in-line assembly when the processor is i80386 or
; later (ie. i80486/i80586)
;

_AX             equ         <eax>
_BX             equ         <ebx>
_CX             equ         <ecx>
_DX             equ         <edx>
_BP             equ         <ebp>
_SI             equ         <esi>
_DI             equ         <edi>
_SP             equ         <esp>

REG_MAX_SIZE    equ         4

;
; ZXMUL3:   80386 or later CPUs.
;
;   It take SrcReg and multiply by 3 then put the result into DestReg
;

ZXMUL3 macro DestReg, SrcReg
%   __@@VALID_REG? <ZXMUL3>, <SrcReg>, <>, <AllCaseRegs>
%   __@@VALID_REG? <AXMUL3>, <DestReg>,<>, <AllCaseRegs>

    __@@EMIT <lea  > DestReg, <[SrcReg + (SrcReg*2)]>
ENDM

;
; MOVS_CB:  80386 or later CPUs.
;
;   Move the data from ds:si (esi) to es:di edi) by 'Count' of bytes, the
;   'Count' can be either constant value or in _CX register. If 'ByteReg' is
;   not blank it will be used rather than do a 'push _CX',
;
;   This macro will generate fastest code for the constant count value.
;

MOVS_CB macro Count, ByteReg

    .ERRB <Count>

    IF ((.TYPE Count) AND 00004h)                   ;; if constant value
        IF (Count AND (NOT 3h))
            IF ((Count SHR 2) LE 3)
                REPT (Count SHR 2)
                    __@@EMIT movsD
                ENDM
            ELSE
                __@@EMIT <mov  > ecx, <(Count SHR 2)> ;; if dwrod count > 3
                __@@EMIT <rep  > movsD
            ENDIF                               ;; endif dword count <= 3
        ENDIF                                   ;; endif has any dword

        IF (Count AND 2h)
            __@@EMIT <movsW>
        ENDIF

        IF (Count AND 1h)
            __@@EMIT <movsB>
        ENDIF
    ELSE

        .ERRDIF <_CX>,<Count>

        IFB <ByteReg>
            __@@EMIT <push > cx
        ELSE

            .ERRIDNI <cl>, <ByteReg>
            .ERRIDNI <ch>, <ByteReg>

            __@@EMIT <mov  > ByteReg, cl
        ENDIF

            __@@EMIT <shr  > ecx, 2
            __@@EMIT <repz > movsD

        IFB <ByteReg>
            __@@EMIT <pop  > cx
        ELSE
            __@@EMIT <mov  > cl, ByteReg
        ENDIF

        __@@EMIT <and  > cx, 3
        __@@EMIT <repz > movsB
    ENDIF
ENDM

;
; MOV_SEG:  80386 or later CPUs.
;
;   Since flat mode will not do any segment registers modification
;


MOV_SEG macro DestSeg, SrcSeg, TempReg
ENDM


BPTR_DS     equ     <BYTE PTR >
WPTR_DS     equ     <WORD PTR >
BPTR_ES     equ     <BYTE PTR >
WPTR_ES     equ     <WORD PTR >
DPTR        equ     <DWORD PTR>
FULL_PTR    equ     <DWORD PTR>

;*****************************************************************************
ELSE    ; if i386 = 0
;*****************************************************************************

ExtRegSet   = 0

;
; Because this is the 16-bit segment, for a 32-bit pointer type, a word is
; 16-bit long
;


IF i286
        .286

        IF1
        %OUT    *** Compiling 80286 Assembly Codes ***
        %OUT
        ENDIF
ELSE
        .8086

        IF1
        %OUT    *** Compiling 8086 Assembly Codes ***
        %OUT
        ENDIF
ENDIF


        .MODEL SMALL, C                         ;; All 32-bit operation


; Macros definition for the in-line assembly when the processor is i80286 or
; earlier (ie. i8088/i8086)
;

_AX             equ         <ax>
_BX             equ         <bx>
_CX             equ         <cx>
_DX             equ         <dx>
_BP             equ         <bp>
_SI             equ         <si>
_DI             equ         <di>
_SP             equ         <sp>

REG_MAX_SIZE    equ         2

;
; ZXMUL3:   8086, 80286 or ealier CPUs.
;
;   It take SrcReg and multiply by 3 then put the result into DestReg
;

ZXMUL3 macro DestReg, SrcReg

%   __@@VALID_REG? <ZXMUL3>, <SrcReg>, <>, <AllCaseRegs>
%   __@@VALID_REG? <ZXMUL3>, <DestReg>, <>, <AllCaseRegs>

    SourceReg   CATSTR <SrcReg>
    NeedPush    = 0

    IFIDN <DestReg>, <SrcReg>
        NeedPush = 1

        IFDIF <DestReg>, <_AX>
            SourceReg CATSTR <_AX>
        ELSE
            SourceReg CATSTR <_BX>
        ENDIF
    ENDIF

    IF NeedPush
        __@@EMIT <push > % SourceReg                    ;; 3
        __@@EMIT <mov  > % SourceReg, DestReg           ;; 2
    ELSE
        __@@EMIT <mov  > DestReg, SrcReg                ;; 2
    ENDIF

    __@@EMIT <shl  > DestReg, 1                         ;; 2
    __@@EMIT <add  > DestReg, % SourceReg               ;; 2 = 6

    IF NeedPush
        __@@EMIT <pop  > % SourceReg                    ;; 5 = 14
    ENDIF
ENDM


;
; MOVS_CB:  8086, 80286 or ealier CPUs.
;
;   Move the data from ds:si (esi) to es:di edi) by 'Count' of bytes, the
;   'Count' can be either constant value or in _CX register. If 'ByteReg' is
;   not blank it will be used rather than do a 'push _CX',
;
;   This macro will generate fastest code for the constant count value.
;

MOVS_CB macro Count, ByteReg

    .ERRB <Count>

    IF ((.TYPE Count) AND 00004h)                       ;; if constant value
        IF (Count AND (NOT 1h))
            IF ((Count SHR 1) LE 3)
                REPT (Count SHR 1)
                    __@@EMIT <movsW>
                ENDM
            ELSE
                __@@EMIT <mov  > cx, <(Count SHR 1)>
                __@@EMIT <rep  > movsW
            ENDIF
        ENDIF

        IF (Count AND 1h)
            __@@EMIT <movsB>
        ENDIF
    ELSE
        .ERRDIF <_CX>,<Count>
        __@@EMIT <shr  > cx, 1
        __@@EMIT <repz > movsw
        __@@EMIT <adc  > cx, cx
        __@@EMIT <repz > movsb
    ENDIF
ENDM

;
; MOV_SEG:  8086, 80286 or ealier CPUs.
;
;   Copy between DS/ES/SS segment registers, or move a constant value into the
;   DS/ES/SS.
;
;   DestSeg:    can be DS/ES/SS
;   SrcReg:     can be DS/ES/SS or constant value
;   TempReg:    can be ax/bx/cx/dx/si/di/bp or blank, if blank then a push is
;               is used
;

MOV_SEG macro DestSeg, SrcSeg, TempReg

    IFB <DestSeg>
        IF1
            %OUT Error: MOV_SEG missing destination segment name in parameter 1.
        ENDIF
        .ERR
        EXITM
    ENDIF

    IFB <SrcSeg>
        IF1
            %OUT Error: MOV_SEG missing source segment name in parameter 2.
        ENDIF
        .ERR
        EXITM
    ENDIF

    IsSegName = 0

    IFIDNI <DestSeg>,<SrcSeg>
        IF1
            %OUT Error: MOV_SEG source/destination seg name are same (&DestSeg:&SrcSeg)
        ENDIF
        .ERR
        EXITM
    ENDIF

    IF ((.TYPE SrcSeg) AND 0010h)                   ;; if SrcSeg is a register

        IsSegName = 0

        % IRP RegName, <ds,es,ss>
%           IFIDNI <RegName>,<DestSeg>
                IsSegName = 1
                EXITM
            ENDIF
        ENDM

        IF IsSegName
            IFNB <TempReg>                              ;; if TempReg is not blank
                IF ((.TYPE TempReg) AND 0010h)          ;; if TempSeg is a register
%		    __@@VALID_REG? <MOV_SEG>, <TempReg>, <ax,bx,cx,dx,si,di,bp>, <_AX,_BX,_CX,_DX,_SI,_DI,_BP>
                    __@@EMIT <mov  > TempReg, SrcSeg
                    __@@EMIT <mov  > DestSeg, TempReg
                ELSE
                    __@@EMIT <push > SrcSeg             ;; TempReg not a register
                    __@@EMIT <pop  > DestSeg
                ENDIF
            ELSE
                __@@EMIT <push > SrcSeg                 ;; TempReg is not specified
                __@@EMIT <pop  > DestSeg
            ENDIF
        ELSE
            __@@EMIT <mov  > DestSeg, SrcSeg
        ENDIF
    ELSE
        __@@EMIT <mov  > DestSeg, <WORD PTR SrcSeg>     ;; SrcReg is in memory
    ENDIF
ENDM

BPTR_DS     equ     <BYTE PTR >
WPTR_DS     equ     <WORD PTR >
BPTR_ES     equ     <BYTE PTR es:>
WPTR_ES     equ     <WORD PTR es:>
FULL_PTR    equ     <WORD PTR>

;*****************************************************************************
ENDIF   ; i386
;*****************************************************************************

;-----------------------------------------------------------------------------
; Common to all 80x86 process
;-----------------------------------------------------------------------------


_DS         equ     <ds>
_ES         equ     <es>
_SS         equ     <ss>


BPTR_SS     equ     <BYTE PTR ss:>
WPTR_SS     equ     <WORD PTR ss:>
BPTR        equ     <BYTE PTR >
WPTR        equ     <WORD PTR >


IF1


;
; INC_LPBYTE:  80x86 famliy
;
;   Increment the IndexReg by 'Increment' and put the result in MemLoc
;

INC_LPBYTE  macro MemLoc, IncReg
    IFNB <IncReg>
        IF ((.TYPE IncReg) AND 0010h)               ;; if IncSeg is a register
%	    __@@VALID_REG? <INC_LPBYTE>, <IncReg>, <>, <_AX,_BX,_CX,_DX,_SI,_DI,_BP>
        ENDIF

        IF ExtRegSet
            __@@EMIT <add  > <DWORD PTR MemLoc>, % IncReg
        ELSE                                                ;; for non i386 cpu
            __@@EMIT <add  > <WORD PTR MemLoc>, % IncReg
        ENDIF
    ELSE
        IF ExtRegSet
            __@@EMIT <inc  > <DWORD PTR MemLoc>
        ELSE                                                ;; for non i386 cpu
            __@@EMIT <inc  > <WORD PTR MemLoc>
        ENDIF
    ENDIF
ENDM

;
; LDS_SI:   80x86 famliy
;
;   move a 32 bits address into either DS:SI or ESI register
;

LDS_SI macro Mem
    IF i386
        __@@EMIT <mov  > esi, <DWORD PTR Mem>
    ELSE
        __@@EMIT <lds  > si, <DWORD PTR Mem>
    ENDIF
ENDM

;
; LES_DI:   80x86 famliy
;
;   move a 32 bits address into either ES:DI or EDI register
;


LES_DI macro Mem
    IF i386
        __@@EMIT <mov  > edi, <DWORD PTR Mem>
    ELSE
        __@@EMIT <les  > di, <DWORD PTR Mem>
    ENDIF
ENDM

;
; LPTR_BX:   80x86 famliy
;
;   16 bit  bx: load 16 bit offset into BX register
;   32 bit ebx: load 32 bit offset into EBX register
;

LPTR_BX macro Mem
    IF i386
        __@@EMIT <mov  > ebx, <DWORD PTR Mem>
    ELSE
        __@@EMIT <mov  > bx, <WORD PTR Mem>
    ENDIF
ENDM

;
; PUSHSEG:  80x86 family
;
;   Push 'SegName' register onto stack, for 80386 or later CPUs in flat model
;   it generate no code
;

PUSHSEG macro   SegName
    IFE i386
        __@@EMIT <push > SegName                    ;; only at non i386 mode
    ENDIF
ENDM

;
; POPSEG:  80x86 family
;
;   Pop 'SegName' register from stack, for 80386 or later CPUs in flat model
;   it generate no code
;

POPSEG  macro   SegName
    IFE i386
        __@@EMIT <pop  > SegName                    ;; only at non i386 mode
    ENDIF
ENDM

;
; NEG32_FROMR16HL:   80x86 fmaily
;
;   take two 16-bit registers (RegH:RegL) as 32-bit sign number and negate that
;   number.  RegH:RegL = -(RegH:RegL)
;

NEG32_FROMR16HL  macro   RegH, RegL
%   __@@VALID_REG? <NEG32_FROMR16HL>, <RegH>, <ax,bx,cx,dx,si,di,bp>, <>
%   __@@VALID_REG? <NEG32_FROMR16HL>, <RegL>, <ax,bx,cx,dx,si,di,bp>, <>

    IFIDNI <RegH>, <RegL>
        IF1
            %OUT Error: (NEG32_FROMR16HL) RegH (&RegH) = RegL (&RegL)'
        ENDIF
        .ERR
        EXITM
    ENDIF

    __@@EMIT <neg  > RegH
    __@@EMIT <neg  > RegL
    __@@EMIT <sbb  > RegH, 0
ENDM

;
; NEG64_FROMR32HL:   80386 or later CPUs
;
;   take two 32-bit registers (RegH:RegL) as 64-bit sign number and negate that
;   number.  RegH:RegL = -(RegH:RegL)
;


NEG64_FROMR32HL  macro   RegH, RegL

    IFE ExtRegSet
        IF1
            %OUT Error: (NEG64_FROMR32HL) this macro only for 80386 or later CPUs'
        ENDIF
        .ERR
        EXITM
    ENDIF

%   __@@VALID_REG? <NEG64_FROMR32HL>, <RegL>, <>, <_AX,_BX,_CX,_DX,_SI,DI_BP>
%   __@@VALID_REG? <NEG64_FROMR32HL>, <RegH>, <>, <_AX,_BX,_CX,_DX,_SI,DI_BP>

    IFIDNI <RegH>, <RegL>
        IF1
            %OUT Error: (NEG64_FROMR32HL) RegH (&RegH) = RegL (&RegL)'
        ENDIF
        .ERR
        EXITM
    ENDIF

    __@@EMIT <neg  > RegH
    __@@EMIT <neg  > RegL
    __@@EMIT <sbb  > RegH, 0
ENDM

;
; S32_FROMR16HL_SR16:    80x86 family
;
;   It take two 16-bit registers (RegH:RegL) as a 32-bit number and SignReg
;   as sign indicator (either 0 or 0xffff) then flip (RegH:RegL) if SignReg
;   is equal to 0xffff
;
;   RegH:       Can be ax/bx/cx/dx/si/di/bp
;   RegL:       Can be ax/bx/cx/dx/si/di/bp
;   SignReg:    Can be ax/bx/cx/dx/si/di/bp
;
;   Note: The RegH/RegL/SignReg must resides in different register
;

S32_FROMR16HL_SR16  macro   RegH, RegL, SignReg
%   __@@VALID_REG? <S32_FROMR16HL_SR16>, <RegL>, <ax,bx,cx,dx,si,di,bp>, <>
%   __@@VALID_REG? <S32_FROMR16HL_SR16>, <RegH>, <ax,bx,cx,dx,si,di,bp>, <>
%   __@@VALID_REG? <S32_FROMR16HL_SR16>, <SignReg>, <ax,bx,cx,dx,si,di,bp>, <>

    IFIDNI <RegH>, <RegL>
        IF1
            %OUT Error: (S32_FROMR16HL_SR16) RegH (&RegH) = RegL (&RegL)'
        ENDIF
        .ERR
        EXITM
    ENDIF

    IFIDNI <SignReg>, <RegH>
        IF1
            %OUT Error: (S32_FROMR16HL_SR16) RegH (&RegH) = SignReg (&SignReg)'
        ENDIF
        .ERR
        EXITM
    ENDIF

    IFIDNI <SignReg>, <RegL>
        IF1
            %OUT Error: (S32_FROMR16HL_SR16) RegL (&RegL) = SignReg (&SignReg)'
        ENDIF
        .ERR
        EXITM
    ENDIF

    __@@EMIT <xor  > RegL, SignReg
    __@@EMIT <xor  > RegH, SignReg
    __@@EMIT <sub  > RegL, SignReg
    __@@EMIT <sbb  > RegH, SignReg
ENDM


;
; S64_FROMR32HL_SR32:    80386 or later CPUs
;
;   It take two 32-bit registers (RegH:RegL) as a 64-bit number and SignReg
;   as sign indicator (either 0 or 0xffffffff) then flip (RegH:RegL) if SignReg
;   is equal to 0xffffffff
;
;   RegH:       Can be eax/ebx/ecx/edx/esi/edi/ebp
;   RegL:       Can be eax/ebx/ecx/edx/esi/edi/ebp
;   SignReg:    Can be eax/ebx/ecx/edx/esi/edi/ebp
;
;   Note: The RegH/RegL/SignReg must resides in different register
;

S64_FROMR32HL_SR32  macro   RegH, RegL, SignReg
    IFE ExtRegSet
        IF1
            %OUT Error: (NEG64_FROMR32HL_SR32) this macro only for 80386 or later CPUs'
        ENDIF
        .ERR
        EXITM
    ENDIF

%   __@@VALID_REG? <S64_FROMR32HL_SR32>, <RegL>, <>, <_AX,_BX,_CX,_DX,_SI,_DI,_BP>
%   __@@VALID_REG? <S64_FROMR32HL_SR32>, <RegH>, <>, <_AX,_BX,_CX,_DX,_SI,_DI,_BP>
%   __@@VALID_REG? <S64_FROMR32HL_SR32>, <SignReg>, <>, <_AX,_BX,_CX,_DX,_SI,_DI,_BP>

    IFIDNI <RegH>, <RegL>
        IF1
            %OUT Error: (S64_FROMR32HL_SR32) RegH (&RegH) = RegL (&RegL)'
        ENDIF
        .ERR
        EXITM
    ENDIF

    IFIDNI <SignReg>, <RegH>
        IF1
            %OUT Error: (S64_FROMR32HL_SR32) RegH (&RegH) = SignReg (&SignReg)'
        ENDIF
        .ERR
        EXITM
    ENDIF

    IFIDNI <SignReg>, <RegL>
        IF1
            %OUT Error: (S64_FROMR32HL_SR32) RegL (&RegL) = SignReg (&SignReg)'
        ENDIF
        .ERR
        EXITM
    ENDIF

    __@@EMIT <xor  > RegL, SignReg
    __@@EMIT <xor  > RegH, SignReg
    __@@EMIT <sub  > RegL, SignReg
    __@@EMIT <sbb  > RegH, SignReg
ENDM

;
; BSXEAX:   80x86 family
;
;   Sign extend the 'ByteReg' register and put the result into _AX
;

BSXEAX macro ByteReg
%   __@@VALID_REG? <BSXEAX>, <ByteReg>, <al,ah,bl,bh,cl,ch,dl,dh>, <>

    IF i386
        __@@EMIT <movsx> eax, ByteReg
    ELSE
        IFDIFI <ByteReg>,<al>
            __@@EMIT <mov  > al, ByteReg
        ENDIF
        __@@EMIT <cbw  >
    ENDIF
ENDM

;
; WSXEAX:   80x86 family
;
;   Sign extend the 'WordReg' register and put the result into _AX
;

WSXEAX macro WordReg

    IF i386
%	__@@VALID_REG? <BSXEAX>, <WordReg>, <ax,bx,cx,dx,si,di,bp>, <>
        __@@EMIT <movsx> eax, WordReg
    ENDIF
ENDM

;
; BZXEAX:   80x86 family
;
;   Zero extend the 'ByteReg' register and put the result into _AX
;

BZXEAX  macro ByteReg
%   __@@VALID_REG? <BZXEAX>, <ByteReg>, <al,ah,bl,bh,cl,ch,dl,dh>, <>

    IF i386
        __@@EMIT <movzx> eax, ByteReg
    ELSE
        IFDIFI <ByteReg>,<al>
            __@@EMIT <mov  > al, ByteReg
        ENDIF
        __@@EMIT <xor  > ah, ah
    ENDIF
ENDM

;
; WZXEAX:   80x86 family
;
;   Zero extend the 'WordReg' register and put the result into _AX
;

WZXEAX macro WordReg

    IF i386
%	__@@VALID_REG? <WZXEAX>, <WordReg>, <ax,bx,cx,dx,si,di,bp>, <>
        __@@EMIT <movzx> eax, WordReg
    ENDIF
ENDM


;
; WSXE:   80x86 family
;
;   Sign extend the 'WordReg' 16-bit register and put the result back to the
;   extended register (only sign extended for i386 or later)
;

WSXE macro WordReg
%   __@@VALID_REG? <WSXE>, <WordReg>, <ax,bx,cx,dx,si,di,bp>, <>

    IF i386
        __@@EMIT <movsx> e&WordReg, WordReg
    ENDIF
ENDM

;
; WZXE:   80x86 family
;
;   Zero extend the 'WordReg' 16-bit register and put the result back to the
;   extended register (only sign extended for i386 or later)
;

WZXE macro WordReg
%   __@@VALID_REG? <WZXE>, <WordReg>, <ax,bx,cx,dx,si,di,bp>, <>

    IF i386
        __@@EMIT <movzx> e&WordReg, WordReg
    ENDIF
ENDM

;
; MOVZE_W:  80x86 family
;
;   Move 16-bit operand (Op16) and zero extended to the 'Reg'
;

MOVZX_W macro   Reg, Op16
%   __@@VALID_REG? <MOVZX_W>, Reg, <>, <AllCaseRegs>

    IF i386
        __@@EMIT <movzx> Reg, <Op16>
    ELSE
        __@@EMIT <mov  > Reg, <Op16>
    ENDIF
ENDM

;
; MOVSE_W:  80x86 family
;
;   Move 16-bit operand (Op16) and sign extended to the 'Reg'
;

MOVSX_W macro   Reg, Op16
%   __@@VALID_REG? <MOVSX_W>, <Reg>, <>, <AllCaseRegs>

    IF i386
        __@@EMIT <movsx> Reg, <Op16>
    ELSE
        __@@EMIT <mov  > Reg, <Op16>
    ENDIF
ENDM

;
; MOV_DW:   80x86 family
;
;   Move a 64-bit point by ds:si (esi) to es:di (edi)
;

MOV_DW  macro
    IF i386
        __@@EMIT <movsD>
    ELSE
        __@@EMIT <movsw>
        __@@EMIT <movsw>
    ENDIF
ENDM

;
; BSXE: 80x86 family
;
;   Sign extend the the low 8 bits register (ByteReg) to the full 16-bit
;   same register.
;
;   ByteReg:    can be al/ah/bl/bh/cl/ch/dl/dh
;
;   Example:    BSXE al ->  sign extend al to ax
;               BSXE ah ->  sign extend ah to ax
;

BSXE macro ByteReg

%   __@@VALID_REG? <BSXE>, <ByteReg>, <al,ah,bl,bh,cl,ch,dl,dh>, <>
    HighChar    SUBSTR <ByteReg>,1,1

    IF i386
        DWordReg  CATSTR  <e>,HighChar,<x>
        __@@EMIT <movsx> % DWordReg, ByteReg
    ELSE
        LowChar     SUBSTR <ByteReg>,2,1
        HighRegName CATSTR HighChar,<h>
        LowRegName  CATSTR HighChar,<l>
        WordRegName CATSTR HighChar,<x>

%       IFIDNI <LowChar>,<h>
            __@@EMIT <mov  > % LowRegName, % HighRegName
        ENDIF

%       IFDIFI <HighChar>,<a>
            __@@EMIT <xchg > % WordRegName, ax
            __@@EMIT <cbw  >
            __@@EMIT <xchg > % WordRegName, ax
        ELSE
            __@@EMIT <cbw  >
        ENDIF
    ENDIF
ENDM

;
; BZXE: 80x86 family
;
;   Zero extend the the low 8 bits register (ByteReg) to the full 16-bit
;   same register.
;
;   ByteReg:    can be al/ah/bl/bh/cl/ch/dl/dh
;
;   Example:    BZXE al ->  zero extend al to ax
;               BZXE ah ->  zero extend ah to ax
;


BZXE macro ByteReg

%   __@@VALID_REG? <BZXE>, <ByteReg>, <al,ah,bl,bh,cl,ch,dl,dh>, <>
    HighChar    SUBSTR <ByteReg>,1,1

    IF i386
        DWordReg  CATSTR  <e>,HighChar,<x>
        __@@EMIT <movzx> % DWordReg, ByteReg
    ELSE
        LowChar     SUBSTR <ByteReg>,2,1
        HighRegName CATSTR HighChar,<h>
        LowRegName  CATSTR HighChar,<l>

%       IFIDNI <LowChar>,<h>
            __@@EMIT <mov  > % LowRegName, % HighRegName
        ENDIF

        __@@EMIT <xor  > % HighRegName, % HighRegName
    ENDIF
ENDM

;
; The ROTSFTC causing masm386 to GP, the work around is take out all the
; IF/ELSE for now
;

ROTSFTC macro   OpCode, Reg, Count
    __@@EMIT <OpCode  > <Reg>, <Count>
ENDM

;
; ROTSHTC:  80x86 family
;
;   Rotate/Shift (OpCode=shl/shr/rol/ror/rcl/rcr) the 'Reg' by count of 'Count'
;   This macro will try to generate optimized version of the call.
;
;   NOTE:   Assumtion is that the Count is less then 8
;
;ROTSFTC macro   OpCode, Reg, Count
;
;    IF ((.TYPE Count) AND 0004h)                ;; must be a constant
;        __@@VALID_REG? <ROTSFTC>, <Reg>, % AllNoCaseRegs, % AllCaseRegs
;        IF i8086
;            REPT    Count
;                __@@EMIT <OpCode  > <Reg>, 1
;            ENDM
;        ELSE
;            __@@EMIT <OpCode  > <Reg>, <Count>
;        ENDIF
;    ELSE
;        IF1
;            %OUT Error: (ROTSFTC) rotate/shift count (=&Count) must be constant value
;        ENDIF
;        .ERR
;        EXITM
;    ENDIF
;ENDM
;



REGS_PUSHED     equ     <*>                     ;;
CUR_PROC_NAME   equ     <?>                     ;;
CUR_PARAM_SIZE  =       9999


;
; __@@PUSHREG:  INTERNAL MACRO
;
;   push a set of the registers onto stack
;

__@@PUSHREG macro r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12
    IRP Reg,<r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12>
        IFB <Reg>
            EXITM
        ELSE
            __@@EMIT <push > % Reg
            REGS_PUSHED CATSTR <Reg>,<,>,REGS_PUSHED        ;; make it reverse
        ENDIF
    ENDM
ENDM

;
; __@@POPREG:  INTERNAL MACRO
;
;   pop a set of the pushed registers from stack
;

__@@POPREG macro r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12
    % IRP Reg,<r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12>
        IFB <Reg>
            EXITM
        ELSE
            __@@EMIT <pop  > Reg
        ENDIF
    ENDM
ENDM


;
; __@@EMIT_PROC:    Internal Macro to output proc name
;

__@@EMIT_PROC   Macro Name, Key, ArgList

IFB <ArgList>
Name Key
ELSE
Name Key ArgList
ENDIF

ENDM


;
; @BEG_PROC:    x86 family, this macro will generate function (proc) header
;               to match C call or STD_CALL, the 'Name' is the proc name
;               and ParamsList must in following format
;
;               <ArgName:TYPE, ArgName:TYPE,....>
;
;               The Allowed TYPEs are DWORD, QWORD only
;

@BEG_PROC   Macro   Name, ParamsList

    CUR_PARAM_SIZE  = 0                         ;; assume no parameter

    IRP Arg, <ParamsList>
        ParamIndex  INSTR   <Arg>,<:>
        ParamType   SUBSTR  <Arg>, ParamIndex + 1

%       IFIDNI <ParamType>,<DWORD>
                CUR_PARAM_SIZE = CUR_PARAM_SIZE + 4
        ELSE
%           IFIDNI <ParamType>, <QWORD>
                    CUR_PARAM_SIZE = CUR_PARAM_SIZE + 8
            ELSE
                IF1
                   %OUT Error: Invalid Parameter Type (&ParamType) [DWORD/QWORD only]
                ENDIF
                .ERR
                EXITM
            ENDIF
        ENDIF
    ENDM

    IF DoStdCall
        CUR_PROC_NAME   CATSTR <Name>,<@>, % CUR_PARAM_SIZE
    ELSE
        CUR_PROC_NAME   CATSTR <Name>
    ENDIF

    __@@EMIT_PROC   <ALIGN>, <DWORD>
    __@@EMIT_PROC   <PUBLIC>, % CUR_PROC_NAME
    __@@EMIT_PROC   % CUR_PROC_NAME,<PROC NEAR>,<ParamsList>

ENDM


;
; @END_PROC:    x86 family, this macro used to end the function (proc) body
;


@END_PROC   Macro

%   IFIDNI <CUR_PROC_NAME>,<?>
        IF1
           %OUT Error: @BEG_PROC macro never called
        ENDIF
        .ERR
        EXITM
    ENDIF

    __@@EMIT_PROC   % CUR_PROC_NAME, < ENDP>

    CUR_PROC_NAME   CATSTR <?>
ENDM


;
; @ENTER:   80x86 family
;
;   This macro should only call once at entry point of each function, it save
;   a set of register used by the function and keep track the saved registers
;   at @EXIT macro call to properly restored the saved registers
;
;   Note:   1) This macro must call for each function even no registers need
;              to be saved, it provide compabilities cross different platform,
;              (for example, it automatically save 'ebx' register for i386
;              flat model even no saved registers are passed)
;           2) pushed registers for 8086/80286 are ds, si, di, bp and for i386
;              or later are esi, edi, ebp.
;           3) This macro automatically push 'ebx' for the i386 or later CPUs
;           4) This macro should only used conjunction with @EXIT macro, it
;              will flag error if @ENTER/@EXIT is not in pair.
;

@ENTER  macro   r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12

%   IFIDNI <CUR_PROC_NAME>,<?>
        IF1
           %OUT Error: @BEG_PROC macro never called
        ENDIF
        .ERR
        EXITM
    ENDIF

    NUM_INDEX   INSTR   REGS_PUSHED,<@>

    IF NUM_INDEX
        IF1
            %OUT Error: a @XCHG_SS_SP_BP called before @ENTER
        ENDIF
        .ERR
        EXITM
    ENDIF

    REGS_PUSHED CATSTR <#>, REGS_PUSHED             ;; use # as seperation

%   IFDIF <REGS_PUSHED>,<#*>
        IF1
            %OUT Error: No @EXIT for previous @ENTER
        ENDIF
        .ERR
        EXITM
    ENDIF

    __@@EMIT <cld  >                                ;; clear the direction

    IF i386                                         ;; for 80386 flat model
        __@@PUSHREG _BX                             ;; save EBX also
    ENDIF

    IRP Reg, <r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12>

        IFB <Reg>
            EXITM
        ENDIF

        RegNameOK = 0

        IRP OkReg, <_DS,_SI,_ES,_DI,_SS,_SP,_AX,_BX,_CX,_DX,_BP>
            IFIDN <Reg>,<OkReg>
                RegNameOK = 1
                EXITM
            ENDIF
        ENDM

        IFE RegNameOK
            IF1
                %OUT Error: Invalid @ENTER register '&Reg': (_DS,_SI,_ES,_DI,_SS,_SP,_AX,_BX,_CX,_DX,_BP)
            ENDIF
            .ERR
            EXITM
        ENDIF

        RegNameOk = 0

        IF i386
            IRP RegToPush, <_SI,_DI,_BP>            ;; allowed to specified
                IFIDN <RegToPush>,<Reg>
                    RegNameOk = 1
                    EXITM
                ENDIF
            ENDM
        ELSE
            IRP RegToPush, <_DS,_SI,_DI,_BP>        ;; allowed to specified
                IFIDN <RegToPush>,<Reg>
                    RegNameOk = 1
                    EXITM
                ENDIF
            ENDM
        ENDIF       ;; i386

        IF RegNameOk
            __@@PUSHREG Reg                         ;; save that register
        ENDIF
    ENDM
ENDM

;
; @EXIT:    80x86 family
;
;   This macro poped previously saved registers by @ENTER macro call, if
;   @EXIT is call without @ENTER then it will generate an error.
;
;   Note:   1) The @ENTER/@EXIT should call as pair within the function.
;           2) The @ENTER should used before any other macro calls in the
;              function.
;           3) The @EXIT should used right before the exit point in the
;              fucction.
;

@EXIT   macro

    NUM_INDEX   INSTR   REGS_PUSHED,<@>             ;; find XCHG_SS_SP

    IF NUM_INDEX
        IF NUM_INDEX NE 1
            IF1
                %OUT Error: __@@RESTORE_SS_SP called before @ENTER.
            ENDIF
            .ERR
            EXITM
        ELSE
            __@@RESTORE_SS_SP                          ;; restore ss:sp
        ENDIF
    ENDIF

    NUM_INDEX   INSTR   REGS_PUSHED,<#>

    IFE NUM_INDEX
        IF1
            %OUT Error: @EXIT without an @ENTER
        ENDIF
        .ERR
        EXITM
    ENDIF

    POP_REGS    SUBSTR  REGS_PUSHED,1,NUM_INDEX-1
    REGS_LEN    SIZESTR REGS_PUSHED

    IF REGS_LEN GT NUM_INDEX
        NUM_INDEX = NUM_INDEX + 1
    ENDIF

    REGS_PUSHED SUBSTR  REGS_PUSHED,NUM_INDEX           ;; remove the pops

    % IRP Reg, <POP_REGS>
        IFNB <Reg>
            __@@POPREG  Reg
        ENDIF
    ENDM

    IF DoStdCall
        IF CUR_PARAM_SIZE EQ 9999
            IF1
                %OUT Error: @EXIT without an @BEG_PROC
            ENDIF
            .ERR
            EXITM
        ELSE
            IF CUR_PARAM_SIZE
                __@@EMIT <Ret  > % CUR_PARAM_SIZE
            ELSE
                __@@EMIT <Ret  >
            ENDIF
        ENDIF

        CUR_PARAM_SIZE = 9999

    ELSE
        __@@EMIT <Ret  >
    ENDIF
ENDM

;
; MATCH_ENTER_EXIT?:    80x86 family
;
;   This macro check if @ENTER/@EXIT is match and balanced, this macro normally
;   placed at end of the assembly file.
;

MATCH_ENTER_EXIT? macro

%   IFDIF <REGS_PUSHED>, <*>
        IF1
            %OUT Error: Unmatch @ENTER/@EXIT pair(s)
        ENDIF
        .ERR
        EXITM
    ENDIF
ENDM

;
; @XCHG_SS_SP_BP:   80x86 fmaily
;
;   This macro set the new stack pointer to the content of variable 'pMapping'
;   the old stack pointer is put into SS:_BP/Old_SS:Old_SP registers for caller
;   references.
;
;   Note:   1) @ENTER macro must used first.
;           2) The _BP must saveed at @ENTER call else an error is generated.
;           3) the pMapping (New stack pointer TOP) must have at least 256
;              bytes of spaces before it, this macro assume 256 bytes has
;              preceed the pMapping.
;           4) After this macro is executed, the maximum pushs are 252 bytes
;              it is equal to 126 continous 16-bit pushs or 63 continous
;              32-bit pushs, if continous pushes are greater then these number
;              then crushed will be due.
;           5) Upon @EXIT macro the old SS:SP stack pointer will be
;              automatically restored.
;

@XCHG_SS_SP_BP macro  pMapping, Old_SS, Old_SP

    IFB <pMapping>
        IF1
            %OUT Error: @XCHG_SS_SP_BP missing pMapping in parameter 1.
        ENDIF
        .ERR
        EXITM
    ENDIF

    IFB <Old_SS>
        IF1
            %OUT Error: @XCHG_SS_SP_BP missing (Old_SS) temp register in parameter 2.
        ENDIF
        .ERR
        EXITM
    ENDIF

    IFB <Old_SP>
        IF1
            %OUT Error: @XCHG_SS_SP_BP missing (Old_SP) temp register in parameter 3.
        ENDIF
        .ERR
        EXITM
    ENDIF

    IFIDN <Old_SS>, <Old_SP>
        IF1
            %OUT Error: XCHG_SS_SP same Old_SS/Old_SP (&Old_SS) register names
        ENDIF
        .ERR
        EXITM
    ENDIF

    NUM_INDEX   INSTR   REGS_PUSHED,<_BP>                   ;; see if _BP saved

    IFE NUM_INDEX
        IF1
            %OUT Error: (@XCHG_SS_SP_BP) _BP must saved at @ENTER called.
        ENDIF
        .ERR
        EXITM
    ENDIF

    OkRegs = 0

    IRP RegName, <_AX,_BX,_CX,_DX,_SI,_DI>
        IFIDN <RegName>,<Old_SS>
            OkRegs = 1
            EXITM
        ENDIF
    ENDM

    IRP RegName, <_AX,_BX,_CX,_DX,_SI,_DI>
        IFIDN <RegName>,<Old_SP>
            OkRegs = OkRegs + 1
            EXITM
        ENDIF
    ENDM

    IF OkRegs EQ 2

        REGS_PUSHED CATSTR <@>,REGS_PUSHED                  ;; mark XCHG_SS_SP

        IF i386
            __@@EMIT <xor  > % Old_SS, % Old_SS             ;; no ss, clear it
            __@@EMIT <mov  > ebp, <DWORD PTR pMapping>      ;; new ESP
            __@@EMIT <mov  > % Old_SP, esp                  ;; Old_SP=old esp
            __@@EMIT <mov  > esp, ebp                       ;; new ESP
            __@@EMIT <mov  > <DWORD PTR [ebp-256]>, % Old_SP;; save it
        ELSE
            ;;
            ;; Note when setting new SS:SP the SS must be set first and new
            ;; SP must immediate instruction follow it, loading new SS will
            ;; disable all interrupts until the next instruction is executed
            ;; ** This is not true for earliest version of 8088/8086, however
            ;; we do not care those earlier version of CPU
            ;;

            __@@EMIT <mov  > % Old_SP, <WORD PTR pMapping+2>;; Old_SP=new SS
            __@@EMIT <mov  > bp, <WORD PTR pMapping>        ;; bp=New SP
            __@@EMIT <mov  > % Old_SS, ss                   ;; save SS
            __@@EMIT <mov  > ss, % Old_SP                   ;; set new SS
            __@@EMIT <xchg > bp, sp                         ;; bp=Old SP
            __@@EMIT <mov  > % Old_SP, bp                   ;; Old_SP = old SP
            __@@EMIT <mov  > bp, sp                         ;; bp = New SP
            __@@EMIT <mov  > <WORD PTR [bp-254]>, % Old_SS  ;; save Old ss
            __@@EMIT <mov  > <WORD PTR [bp-256]>, % Old_SP  ;; save Old ss
        ENDIF
    ELSE
        IF1
            %OUT Error: @XCHG_SS_SP_BP invalid temp register(s) <&Old_SS/&Old_SP>
            %OUT *      only using (_AX, _BX, _CX, _DX, _SI, _DI) register names
        ENDIF
        .ERR
        EXITM
    ENDIF
ENDM

;
; __@@RESTORE_SS_SP: INTERNAL MACRO
;
;   This macro is called by @EXIT macro only if a @XCHG_SS_SP_BP macro is
;   called after the @ENTER macro call, it restored the SS:SP to the original
;   stack pointer which was altered by the @XCHG_SSP_SP_BP macro.
;


__@@RESTORE_SS_SP macro

    NUM_INDEX   INSTR   REGS_PUSHED,<@>                     ;; find XCHG_SS_SP

    IFE NUM_INDEX
        IF1
            %OUT Error: __@@RESTORE_SS_SP called without @XCHG_SS_SP_BP call first.
        ENDIF
        .ERR
        EXITM
    ENDIF

    IF NUM_INDEX NE 1
        IF1
            %OUT Error: __@@RESTORE_SS_SP called after @EXIT.
        ENDIF
        .ERR
        EXITM
    ENDIF

    REGS_PUSHED SUBSTR REGS_PUSHED,2                        ;; removed '@'

    ;;
    ;; Note: Because @XCHG_SS_SP_BP required a save of _BP register, we will
    ;;       certain at here, the _BP register is free to be used, we may not
    ;;       want to use _DX:_AX registers because it may be the return values.
    ;;

    IF i386
        __@@EMIT <mov  > ebp, esp                           ;; access to stack
        __@@EMIT <mov  > esp, <DWORD PTR [ebp-256]>         ;; set new ESP
    ELSE
        ;;
        ;; Note when setting new SS:SP the SS must be set first and new
        ;; SP must immediate instruction follow it, loading new SS will
        ;; disable all interrupts until the next instruction is executed
        ;; ** This is not true for earliest version of 8088/8086, however
        ;; we do not care those earlier version of CPU
        ;;

        __@@EMIT <mov  > bp, sp                             ;; access to stack
        __@@EMIT <mov  > bx, <WORD PTR [bp-254]>            ;; get Old ss
        __@@EMIT <mov  > cx, <WORD PTR [bp-256]>            ;; get Old sp
        __@@EMIT <mov  > ss, bx                             ;; set New SS
        __@@EMIT <mov  > sp, cx                             ;; set new SP
    ENDIF
ENDM


DBGSTOP macro
    IF DBG
        __@@EMIT <INT  >    3
    ENDIF
ENDM

;
; PUSH_ALL Save all registers
;

PUSH_ALL    macro
    IF ExtRegSet
        __@@EMIT <pushfd>
        __@@EMIT <pushad>
    ELSE
        __@@EMIT <pushf>
        __@@EMIT <pusha>
    ENDIF
ENDM

;
; POP_ALL Restore All Registers
;

POP_ALL    macro
    IF ExtRegSet
        __@@EMIT <popad>
        __@@EMIT <popfd>
    ELSE
        __@@EMIT <popa>
        __@@EMIT <popf>
    ENDIF
ENDM



ENDIF       ; IF1


; AVE_2B:   80x86 family
;
; The AVE_2BYTES(ByteReg, Byte1) take 'ByteReg' as a byte register, and 'Byte1'
; may be register or byte memory location, and do the following
;
;  ByteReg = (ByteReg + Byte1 + 1) / 2
;

AVE_2B macro    ByteReg, Byte1
    __@@EMIT <add  > ByteReg, <Byte1>
    __@@EMIT <rcr  > ByteReg, 1
    __@@EMIT <adc  > ByteReg, 0
ENDM


    .XALL
    .SFCOND

;*****************************************************************************
ELSE
;*****************************************************************************

IF1
    %OUT    * None of 80x86 assembly codes are compiled.
    %OUT    +-------------+--------------+-------------+
    %OUT    |  Symbol     |  Condition   |  Processor  |
    %OUT    |=============+==============+=============|
    %OUT    |  NO_ASM     |   defined    | No asm codes|
    %OUT    |=============+==============+=============|
    %OUT    |  i8086      |     1        |             |
    %OUT    |-------------+--------------| Intel 8086  |
    %OUT    |  _DOS_      |   defined    |             |
    %OUT    |=============+==============+=============|
    %OUT    |  i286       |     1        |             |
    %OUT    |-------------+--------------| Intel 80286 |
    %OUT    |  _OS2_      |   defined    |             |
    %OUT    |=============+==============+=============|
    %OUT    |  i386       |     1        |             |
    %OUT    |-------------+--------------| Intel 80386 |
    %OUT    |  _OS_20_    |   defined    |             |
    %OUT    +=============+==============+=============+

ENDIF

;*****************************************************************************
ENDIF   ; i8086/i286/i386
;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\i386\htp.inc ===
COMMENT `


Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htrbmp.asm


Abstract:

    This function is the equivelant codes in the htp.h


Author:
    05-Apr-1991 Fri 15:55:08 created  -by-  Daniel Chou (danielc)


[Environment:]

    Printer Driver.


[Notes:]


Revision History:

    28-Mar-1992 Sat 21:06:23 updated  -by-  Daniel Chou (danielc)
        Update for PRIMCOLOR/PRIMMONO data structure and other structures for
        VGA16 support, it also now support 6553500% stretchs.



`




PRIMMONO STRUC
    MonoPrim1       DB  ?
    MonoPrim2       DB  ?
PRIMMONO ENDS

PRIMMONO_COUNT STRUC
    PMC_Count       DW  ?
    PMC_Prim1       DB  ?
    PMC_Prim2       DB  ?
PRIMMONO_COUNT ENDS


PRIMCOLOR STRUC
    ClrPrim1        DB  ?
    ClrPrim2        DB  ?
    ClrPrim3        DB  ?
    ClrPrim4        DB  ?
    ClrPrim5        DB  ?
    ClrPrim6        DB  ?
PRIMCOLOR ENDS

PRIMCOLOR_COUNT STRUC
    PCC_Count       DW  ?
    PCC_Prim1       DB  ?
    PCC_Prim2       DB  ?
    PCC_Prim3       DB  ?
    PCC_Prim4       DB  ?
    PCC_Prim5       DB  ?
    PCC_Prim6       DB  ?
PRIMCOLOR_COUNT ENDS

SIZE_PMC                equ     4
SIZE_PCC                equ     8


RGB555LUTM  STRUC
    LUTM_rs0        DB  ?
    LUTM_rs1        DB  ?
    LUTM_rs2        DB  ?
    LUTM_rs3        DB  ?
    LUTM_wIdx0      DW  256 dup(?)
    LUTM_wIdx1      DW  256 dup(?)
    LUTM_wIdx2      DW  256 dup(?)
    LUTM_Map        DD  ?
RGB555LUTM  ENDS


RGB555LUTC  STRUC
    LUTC_rs0        DB  ?
    LUTC_rs1        DB  ?
    LUTC_rs2        DB  ?
    LUTC_rs3        DB  ?
    LUTC_wIdx0      DW  256 dup(?)
    LUTC_wIdx1      DW  256 dup(?)
    LUTC_wIdx2      DW  256 dup(?)
    LUTC_bIdx0      DB  256 dup(?)
    LUTC_bIdx1      DB  256 dup(?)
    LUTC_bIdx2      DB  256 dup(?)
    LUTC_Map        DD  ?
RGB555LUTC  ENDS

LUT_RS_SIZE             equ     4
LUT_WIDX0               equ     (LUT_RS_SIZE)
LUT_WIDX1               equ     (LUT_WIDX0 + (256 * 2))
LUT_WIDX2               equ     (LUT_WIDX1 + (256 * 2))
LUT_BIDX0               equ     (LUT_WIDX2 + (256 * 2))
LUT_BIDX1               equ     (LUT_BIDX0 + (256 * 1))
LUT_BIDX2               equ     (LUT_BIDX1 + (256 * 1))
LUT_MONOMAP             equ     LUT_BIDX0
LUT_COLORMAP            equ     (LUT_BIDX2 + (256 * 1))


VGA256_C_IDX_MAX        equ     5
VGA256_M_IDX_MAX        equ     20
VGA256_C_LEVELS         equ     (VGA256_C_IDX_MAX + 1)
VGA256_M_LEVELS         equ     (VGA256_M_IDX_MAX + 1)

VGA256_R_CUBE_INC       equ     1
VGA256_G_CUBE_INC       equ     VGA256_C_LEVELS
VGA256_B_CUBE_INC       equ     (VGA256_G_CUBE_INC * VGA256_G_CUBE_INC)

RGB555_C_LEVELS         equ     32
RGB555_B_CUBE_INC       equ     1
RGB555_G_CUBE_INC       equ     RGB555_C_LEVELS
RGB555_R_CUBE_INC       equ     (RGB555_G_CUBE_INC * RGB555_G_CUBE_INC)




BMF_1BPP_3PLANES        equ     0
BMF_1BPP                equ     1
BMF_4BPP                equ     2
BMF_8BPP                equ     3
BMF_16BPP               equ     4
BMF_24BPP               equ     5
BMF_32BPP               equ     6
BMF_4BPP_VGA16          equ     255
BMF_8BPP_VGA256         equ     254
BMF_16BPP_555           equ     253


HTBRUSHDATA STRUC
    Flags               DB  ?
    SurfaceFormat       DB  ?
    ScanLinePadBytes    DW  ?
    cxHTCell            DB  ?
    cyHTCell            DB  ?
    SizePerPlane        DW  ?
HTBRUSHDATA ENDS


CAOTBAINFO  STRUC
    CAOTBA_BytesCount   DW  ?
    CAOTBA_Flags        DW  ?
CAOTBAINFO  ENDS


CAOTBAF_INVERT          equ     01h
CAOTBAF_COPY            equ     02h



;
; SRCMASKINFO
;
;  This data structure is passed to the source mask preparation function.
;
;  CompressLines       - Total lines need to be merge for the source mask.
;
;  FirstSrcMaskSkips   - The total bits in the first source mask byte to be
;                        skipped.
;
;  SourceMask          - The starting source mask's offset mask's shift to the
;                        left by 1
;
;  SourcOffsetMask     - The starting source offset's mask, not left shift 1.
;
;                        HR.XStretch.StretchRatio.StretchSize.
;  OffsetCount         - Location of the .COUNT in the PRIMMONO_COUNT or
;                        PRIMCOLOR_COUNT data structure, if this field is
;                        0xff, then evey PRIMxxxx_COUNT count is 1, that is
;                        the source is not compressed.
;
;  OffsetPrim1         - Location of the .Prim1 in the PRIMMONO_COUNT or
;                        PRIMCOLOR_COUNT data structure, the Prim2/Prim3/Prim4
;                        must followed in that order if they exist.
;
;  ColorInfoIncrement  - The PRIM_COLOR/PRIM_MONO incrementments, it may be
;                        negative.
;
;  StretchSize         - Total Stretch need to be masked
;
;
;
;

SMIF_XCOUNT_IS_ONE          equ 01h

SRCMASKINFO STRUC
    SMI_Flags               DB  ?
    SMI_FirstSrcMaskSkips   DB  ?
    SMI_OffsetCount         DB  ?
    SMI_CountTocSkip        DB  ?
    SMI_ColorInfoIncrement  DW  ?
    SMI_StretchSize         DW  ?
SRCMASKINFO ENDS



IFIF_GET_FIRST_BYTE     equ     01h
IFIF_INIT_SRC_READ      equ     02h
IFIF_XCOUNT_IS_ONE      equ     04h
IFIF_HAS_SRC_MASK       equ     08h

INFUNCINFO  STRUC
    IFI_ColorInfoIncrement  DW  ?
    IFI_BMF1BPP1stShift     DB  ?
    IFI_Flags               DB  ?
INFUNCINFO  ENDS


OUTFUNCINFO STRUC
    OFI_pXlate8BPP      DD  ?
    OFI_pPrimMap        DD  ?
    OFI_p555Pat         DD  ?
    OFI_cx555Pat        DW  ?
    OFI_OrgX555Pat      DW  ?
    OFI_PatWidthBytes   DW  ?
    OFI_PatOrgX         DW  ?
    OFI_pPatA           DD  ?
    OFI_pPatB           DD  ?
    OFI_pPatC           DD  ?
OUTFUNCINFO ENDS


PRIM_COUNT_SPECIAL      equ      8000h
PRIM_COUNT_CHECK_SKIP   equ      8000h
PRIM_COUNT_END_SCAN     equ     0ffffh


MAX_HTPATTERN_WIDTH     equ     32
LOCAL_PATTERN_DWSIZE    =       ((MAX_HTPATTERN_WIDTH + (16 + 3)) / 4)


VGA256_COLORCUBE_COUNT  equ     216

IF DBG

extrn   DbgPrintf:PROC

ENDIF


IF1


DBG_FILENAME    macro  FileName

IF DBG
    .DATA
    DbgFileName     db  '&FileName.asm',0
ENDIF

ENDM



__@@ASSERT_OPCODE equ <>
__@@ASSERT_OP1    equ <>
__@@ASSERT_OP2    equ <>
__@@C_PushCount     = 0


__@@AssertOpCode    macro   OpCode,Op1,Op2
    __@@ASSERT_OPCODE   CATSTR  <&OpCode>,<      >
    __@@ASSERT_OPCODE   SUBSTR  __@@ASSERT_OPCODE, 1, 5
    __@@ASSERT_OP1      CATSTR  <&Op1>
    __@@ASSERT_OP2      CATSTR  <&Op2>
ENDM


__@@DoPush  MACRO   Param
    IFNB <Param>

%       IF ((.TYPE Param) AND 00004h)                   ;; if constant value
            IF i8086
                __@@EMIT <mov  >    _AX, <Param>
                __@@EMIT <push >    _AX
            ELSE
                __@@EMIT <push >    <Param>
            ENDIF
        ELSE
            IF i8086 or i286
                SegName CATSTR <ds,es,ss,cs>
            ELSE
                SegName CATSTR <>
            ENDIF

            __@@VALID_REG? <__@@DoPush>, <Param>,SegName,<_AX,_BX,_CX,_DX,_SI,_DI,_BP,_SP>
%           __@@EMIT <push >    <Param>
        ENDIF

        __@@C_PushCount = __@@C_PushCount + 1
    ENDIF
ENDM


;
; __@@C_PARAMS_PUSH     push a register or a constant number
;

__@@C_PARAMS_PUSH  MACRO   IsPointer, Name
    IFNB <Name>
        IF IsPointer
            IF i8086 or i286
                __@@DoPush  <SEG    Name>
            ENDIF

            __@@DoPush  <OFFSET Name>
        ELSE
            __@@DoPush  <Name>
        ENDIF
    ENDIF
ENDM


;
; __@@C_PARAMS_POP      restore the stack of count after C call.
;


__@@C_PARAMS_POP   Macro   PopCount
    IF PopCount LT 3
        REPT    PopCount
            __@@EMIT <pop  >    %_CX
        ENDM
ELSE
        __@@EMIT <add  >    %_SP, %(PopCount * REG_MAX_SIZE)
ENDIF

ENDM


;
; DBGP  debug output macro
;

DBGP_IF macro   Print, Msg, p1, p2, p3, p4, p5, p6, p7, p8
        LOCAL   LocalMsg


IF DBG AND Print

        .DATA

LocalMsg    db  '&Msg',0

        .CODE

        PUSH_ALL

        __@@C_PushCount = 0                     ;; reset

        __@@C_PARAMS_PUSH   0, <p8>
        __@@C_PARAMS_PUSH   0, <p7>
        __@@C_PARAMS_PUSH   0, <p6>
        __@@C_PARAMS_PUSH   0, <p5>
        __@@C_PARAMS_PUSH   0, <p4>
        __@@C_PARAMS_PUSH   0, <p3>
        __@@C_PARAMS_PUSH   0, <p2>
        __@@C_PARAMS_PUSH   0, <p1>
        __@@C_PARAMS_PUSH   1, <LocalMsg>

        __@@EMIT <call >    DbgPrintf

        __@@C_PARAMS_POP    __@@C_PushCount

        POP_ALL
ENDIF

ENDM

;
; ASSERT    Assert when Flag is not true, if NOT in debug mode, it will
;           load _AX with ErrNo and jump to the ExitLoc
;

ASSERT  macro   OpCode,Flag,Mode,ErrNo,ExitLoc,Msg,p1,p2,p3,p4,p5,p6,p7,p8
        LOCAL   AssertMsg, SkipNext


    IsDbgOnly = 0

    IFIDNI <Mode>,<DBG_ONLY>
        IsMode = 1
    ELSE
        IFIDNI <Mode>,<!ALWAYS!>
            IsMode = 0
        ELSE
            IF1
                %OUT Error: ASSERT(&Mode), Valid are <DBG_ONLY>, <!ALWAYS!>
            ENDIF
            .ERR
            EXITM
        ENDIF
    ENDIF


    __@@AssertOpCode    OpCode

    JTrueStr    CATSTR <J>,<&Flag>,<     >
    JTrueStr    SUBSTR JTrueStr,1,5


IF DBG

        .DATA
AssertMsg   db  13, 10, '!ERROR: (%d), failed in <%s>'
            db  13, 10, 'ASSERT: &Msg', 13, 10,0

        .CODE

%       __@@EMIT <__@@ASSERT_OPCODE>    <__@@ASSERT_OP1>, <__@@ASSERT_OP2>
%       __@@EMIT <JTrueStr>             <SHORT SkipNext>

        PUSH_ALL

        __@@C_PushCount = 0


        __@@C_PARAMS_PUSH   0, <p8>
        __@@C_PARAMS_PUSH   0, <p7>
        __@@C_PARAMS_PUSH   0, <p6>
        __@@C_PARAMS_PUSH   0, <p5>
        __@@C_PARAMS_PUSH   0, <p4>
        __@@C_PARAMS_PUSH   0, <p3>
        __@@C_PARAMS_PUSH   0, <p2>
        __@@C_PARAMS_PUSH   0, <p1>

        __@@C_PARAMS_PUSH   1, <DbgFileName>
        __@@C_PARAMS_PUSH   0, <ErrNo>
        __@@C_PARAMS_PUSH   1, <AssertMsg>

        __@@EMIT <call >    DbgPrintf

        __@@C_PARAMS_POP    __@@C_PushCount

        POP_ALL

        __@@EMIT <INT  >    3
        __@@EMIT <jmp  >    <ExitLoc>

ELSE
    IF IsDbgOnly
%      __@@EMIT <__@@ASSERT_OPCODE>     <__@@ASSERT_OP1>, <__@@ASSERT_OP2>
%      __@@EMIT <JTrueStr>              <SHORT SkipNext>

        __@@EMIT <mov  >    _AX, <ErrNo>
        __@@EMIT <jmp  >    <ExitLoc>
    ENDIF
ENDIF

SkipNext:

ENDM


ENDIF       ;; IF1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\i386\htrbmp.asm ===
PAGE 60, 132
    TITLE   Reading 1/4/8/16/24/32 bits per pel bitmap

COMMENT `


Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htrbmp.asm


Abstract:

    This module provided a set of functions which read the 1/4/8/16/24/32
    bits per pel bitmap and composed it into the PRIMMONO_COUNT or
    PRIMCOLOR_COUNT data structure array

    This function is the equivelant codes in the htgetbmp.c


Author:
    23-Apr-1992 Thu 20:51:24 updated  -by-  Daniel Chou (danielc)
        1. Remove IFIF_MASK_SHIFT_MASK and replaced it with BMF1BPP1stShift
        2. Delete IFI_StretchSize
        3. Change IFI_ColorInfoIncrement from 'CHAR' to 'SHORT'


    05-Apr-1991 Fri 15:55:08 created  -by-  Daniel Chou (danielc)


[Environment:]

    Printer Driver.


[Notes:]


Revision History:
        28-Mar-1992 Sat 21:07:45 updated  -by-  Daniel Chou (danielc)
            Rewrite all 1/4/8/16/24/32 to PrimMono/PrimColor input functions
            using macro so only one version of source need to be maintained.


        16-Jan-1992 Thu 21:29:34 updated  -by-  Daniel Chou (danielc)

            1) Fixed typo on macro PrimColor24_32BPP, it should be
               BPTR_ES[_DI] not BPTR_ES[DI]

            2) Fixed BMF1BPPToPrimColor's BSXEAX to BSXE cl

               VCInitSrcRead:  BSXEAX cl -> BSXE cl

            3) Fixed BMF4BPPToPrimColor's codes which destroy AL on second
               run.



`


        .XLIST
        INCLUDE i386\i80x86.inc
        .LIST


IF  HT_ASM_80x86


;------------------------------------------------------------------------------
        .XLIST
        INCLUDE i386\htp.inc
        .LIST
;------------------------------------------------------------------------------

        .CODE


SUBTTL  CopyAndOrTwoByteArray
PAGE

COMMENT `

Routine Description:

    This function take source/destination bytes array and apply Copy/Or/And
    functions to these byte arrays and store the result in the pDest byte
    array.

Arguments:

    pDest       - Pointer to the destination byte array

    pSource     - Pointer to the source byte array

    CAOTBAInfo  - CAOTBAINFO data structure which specified size and operation
                  for the source/destination

Return Value:

    No return value

Author:

    18-Mar-1991 Mon 13:48:51 created  -by-  Daniel Chou (danielc)


Revision History:

`

@BEG_PROC   CopyAndOrTwoByteArray   <pDest:DWORD,       \
                                     pSource:DWORD,     \
                                     CAOTBAInfo:DWORD>

                @ENTER  _DS _SI _DI             ; Save environment registers

                LDS_SI  pSource
                LES_DI  pDest

                mov     _DX, 2
                MOVZX_W _CX, CAOTBAInfo.CAOTBA_BytesCount
                mov     ax, CAOTBAInfo.CAOTBA_Flags
                test    ax, CAOTBAF_COPY
                jnz     short DoCopy

;============================================================================
; MERGE COPY:
;============================================================================

DoMergeCopy:    test    ax, CAOTBAF_INVERT      ; need invert?
                jz      short DoOrCopy

;==============================================================================
; NOT OR the source to the destination
;==============================================================================

DoNotOrCopy:    shr     _CX, 1                          ; has byte?
                jnc     short NotOrCopy1

                lodsb
                not     al
                or      BPTR_ES[_DI], al
                inc     _DI
                or      _CX, _CX

IFE ExtRegSet

NotOrCopy1:     jz      short AllDone

NotOrCopyLoop:  lodsw
                not     ax
                or      BPTR_ES[_DI], ax
                add     _DI, 2
                loop    NotOrCopyLoop
                jmp     short AllDone
ELSE

NotOrCopy1:     shr     _CX, 1
                jnc     short NotOrCopy2
                lodsw
                not     ax
                or      WPTR_ES[_DI], ax
                add     _DI, 2
                or      _CX, _CX

NotOrCopy2:     jz      short AllDone

NotOrCopyLoop:  lodsd
                not     _AX
                or      DPTR [_DI], _AX
                add     _DI, 4
                loop    NotOrCopyLoop
                jmp     short AllDone
ENDIF



;==============================================================================
; OR in the source to the destination
;==============================================================================

DoOrCopy:       shr     _CX, 1                          ; has byte?
                jnc     short OrCopy1

                lodsb
                or      BPTR_ES[_DI], al
                inc     _DI
                or      _CX, _CX

IFE ExtRegSet

OrCopy1:        jz      short AllDone

OrCopyLoop:     lodsw
                or      BPTR_ES[_DI], ax
                add     _DI, 2
                loop    OrCopyLoop
                jmp     short AllDone
ELSE

OrCopy1:        shr     _CX, 1
                jnc     short OrCopy2
                lodsw
                or      WPTR_ES[_DI], ax
                add     _DI, 2
                or      _CX, _CX

OrCopy2:        jz      short AllDone

OrCopyLoop:     lodsd
                or      DPTR [_DI], _AX
                add     _DI, 4
                loop    OrCopyLoop
                jmp     short AllDone
ENDIF



;============================================================================
; COPY:
;============================================================================

DoCopy:         test    ax, CAOTBAF_INVERT      ; need invert?
                jz      short PlaneCopy

InvertCopy:     shr     _CX, 1                          ; has byte?
                jnc     short InvertCopy1
                lodsb
                not     al
                stosb
                or      _CX, _CX                        ; still zero

IFE ExtRegSet

InvertCopy1:    jz      short AllDone

InvertCopyLoop: lodsw
                not     ax
                stosw
                loop    InvertCopyLoop
                jmp     short AllDone
ELSE

InvertCopy1:    shr     _CX, 1
                jnc     short InvertCopy2
                lodsw
                not     ax
                stosw
                or      _CX, _CX                        ; still zero

InvertCopy2:    jz      short AllDone

InvertCopyLoop: lodsd
                not     _AX
                stosd
                loop    InvertCopyLoop
                jmp     short AllDone
ENDIF

PlaneCopy:      MOVS_CB _CX, al                 ; al is not used now


AllDone:        @EXIT                       ; restore environment and return


@END_PROC


SUBTTL  SetSourceMaskToPrim1
PAGE

COMMENT `

Routine Description:

    This function set the source mask bits into the PRIMMONO/PRIMCOLOR's Prim1,
    if the source need to be skipped (not modified on the destination) then
    the Prim1 will be PRIM_INVALID_DENSITY, else 0

Arguments:

    pSource     - Pointer to the byte array which each pel corresponds to one
                  source mask pel.

    pColorInfo  - Pointer to either PRIMCOLOR_COUNT or PRIMMONO_COUNT data
                  structure array

    SrcMaskInfo - SRCMASKINFO data structure which specified the format and
                  size of pColorInfo and other mask information

Return Value:

    No Return value

Author:

    18-Mar-1991 Mon 13:48:51 created  -by-  Daniel Chou (danielc)


Revision History:

`


@BEG_PROC   SetSourceMaskToPrim1    <pSource:DWORD,     \
                                     pColorInfo:DWORD,  \
                                     SrcMaskInfo:QWORD>

;
; Register Usage:
;
;  al       = Source
;  ah       = Source remained bit count
;  bx       = Free register
;  dx       = Current Count
;  _CX      = ColorInfoIncrement
;  _BP      = StretchSize
;  _DI      = Count Location
;  _SI      = pSource
;
;

                @ENTER  _DS _SI _DI _BP         ; Save environment registers

                LDS_SI  pSource
                LES_DI  pColorInfo

                mov     cl, SrcMaskInfo.SMI_FirstSrcMaskSkips
                mov     ah, 8                           ; 8-bit load
                sub     ah, cl                          ; dh=remained bits
                lodsb
                not     al                              ; for easy compute
                shl     al, cl                          ; shift to aligned

SetPointer:     MOVZX_W _CX, SrcMaskInfo.SMI_OffsetCount
                add     _DI, _CX                        ; _DI=pPrim1
                MOVSX_W _CX, SrcMaskInfo.SMI_ColorInfoIncrement
                MOVZX_W _DX, SrcMaskInfo.SMI_StretchSize
                test    SrcMaskInfo.SMI_Flags, SMIF_XCOUNT_IS_ONE
                mov     _BP, _DX
                jnz     short OneXCount

;============================================================================
; We have variable count, one or more source mask bits per stretch, the source
; mask 1=Overwrite, 0=Leave alone, to make life easier we will flip the source byte
; when we loaded,
;
; a left shift will casue carry bit to be set, then we do a 'SBB  reg, reg'
; instructions, this will make
;
;   reg = 0xff if carry set     (original=0  :Leave alone)
;   ret = 0x00 if carry clear   (original=1  :overwrite)
;
; during the PrimCount compsitions, we will or in clear CH with AL source byte
; (we only care bit 7), later we can just do a left shift to get that merge
; bit.
;

VarCount:       mov     dx, WPTR_ES[_DI]                ; dx=Count
                and     dx, NOT PRIM_COUNT_SPECIAL
                xor     bh, bh                          ; clear ch for use
                jmp     short VC1

VCLoad:         lodsB
                not     al
                mov     ah, 8                           ; fall through
VC1:
                dec     ah
                jl      short VCLoad
                or      bh, al                          ; or in bit 7
                shl     al, 1
                dec     dx
                jnz     short VC1                       ; repeat PrimCount
                shl     bh, 1
                jnc     VC_And
VC_Or:                                                  ; bit 7 of ch=1/0
                or      WPTR_ES[_DI], PRIM_COUNT_SPECIAL
                add     _DI, _CX
                dec     _BP
                jnz     short VarCount                  ; repeat stretch
                jmp     short AllDone
VC_And:
                and     WPTR_ES[_DI], NOT PRIM_COUNT_SPECIAL
                add     _DI, _CX
                dec     _BP
                jnz     short VarCount                  ; repeat stretch
                jmp     short AllDone


;============================================================================
; We only have one count, 1 source mask bit per stretch, the source mask
; 1=Overwrite, 0=Leave alone, to make life easier we will flip the source byte
; when we loaded,
;
; a left shift will casue carry bit to be set, then we do a 'SBB  reg, reg'
; instructions, this will make
;
;   reg = 0xff if carry set     (original=0  :Leave alone)
;   ret = 0x00 if carry clear   (original=1  :overwrite)
;

OXCLoad:        lodsB
                not     al
                mov     ah, 8                           ; fall through

OneXCount:      dec     ah
                jl      short OXCLoad
                shl     al, 1
                jc      SHORT OneXCountOr
OneXCountAnd:
                and     WPTR_ES[_DI], NOT PRIM_COUNT_SPECIAL
                add     _DI, _CX                        ; increment pPrim1
                dec     _BP
                jnz     short OneXCount
                jmp     SHORT AllDone
OneXCountOr:
                or      WPTR_ES[_DI], PRIM_COUNT_SPECIAL
                add     _DI, _CX                        ; increment pPrim1
                dec     _BP
                jnz     short OneXCount

AllDone:        @EXIT                       ; restore environment and return


@END_PROC




;*****************************************************************************
; START LOCAL MACROS
;*****************************************************************************


.XLIST

_PMAPPING               equ <_DX>
_PMONOMAP               equ <_PMAPPING + LUT_MONOMAP>
_PCOLORMAP              equ <_PMAPPING + LUT_COLORMAP>
_PWIDX0                 equ <_PMAPPING + LUT_WIDX0>
_PWIDX1                 equ <_PMAPPING + LUT_WIDX1>
_PWIDX2                 equ <_PMAPPING + LUT_WIDX2>
_PBIDX0                 equ <_PMAPPING + LUT_BIDX0>
_PBIDX1                 equ <_PMAPPING + LUT_BIDX1>
_PBIDX2                 equ <_PMAPPING + LUT_BIDX2>

LUT_RS0                 equ <[_PMAPPING].LUTC_rs0>
LUT_RS1                 equ <[_PMAPPING].LUTC_rs1>
LUT_RS2                 equ <[_PMAPPING].LUTC_rs2>



;
; The following macros used only in this files, and it will make it easy to
; handle all xBPP->MONO/COLOR cases during the translation
;
;
;============================================================================
;
;  __@@MappingFromAX:
;
;   Monochrome mapping: pMonoMapping[_AX + OFFSET].MonoPrim1
;                       pMonoMapping[_AX + OFFSET].MonoPrim2
;
;   Color mapping:      pColorMapping[_AX + OFFSET].ClrPrim1
;                       pColorMapping[_AX + OFFSET].ClrPrim2
;                       pColorMapping[_AX + OFFSET].ClrPrim3
;                       pColorMapping[_AX + OFFSET].ClrPrim4
;                       pColorMapping[_AX + OFFSET].ClrPrim5
;                       pColorMapping[_AX + OFFSET].ClrPrim6
;


__@@MappingFromAX   MACRO   ColorName

    IFIDNI <ColorName>, <MONO>
%       __@@EMIT <mov  > ax, <WPTR [_PMAPPING + (_AX*2)].MonoPrim1>
%       __@@EMIT <mov  > <WPTR_ES[_DI].PMC_Prim1>, ax
    ELSE
%       __@@EMIT <mov  > <WPTR [_DI].PCC_Prim5>, ax
    ENDIF
ENDM

__@@MappingFromBX   MACRO   ColorName

    IFIDNI <ColorName>, <MONO>
%       __@@EMIT <mov  > bx, <WPTR [_PMAPPING + (_BX*2)].MonoPrim1>
%       __@@EMIT <mov  > <WPTR_ES[_DI].PMC_Prim1>, bx
    ELSE
%       __@@EMIT <mov  > <WPTR [_DI].PCC_Prim5>, bx
    ENDIF
ENDM

;
;============================================================================
;
; __@@4BP_IDX(Mode):  AL = AL >> 4   (Mode = 1st_Nibble)
;                     AL = AL & 0x0f (Mode = 2nd_Nibble)
;

__@@4BPP_IDX    MACRO   Index

    IFIDNI <Index>, <1ST_NIBBLE>
        __@@EMIT <mov  > ch, al
        __@@EMIT <or   > ch, 80h                        ;; ah=second nibble
        IF i8086
            __@@EMIT <shr  > al, 1
            __@@EMIT <shr  > al, 1
            __@@EMIT <shr  > al, 1
            __@@EMIT <shr  > al, 1
        ELSE
            __@@EMIT <shr  > al, 4
        ENDIF
    ELSE
        IFIDNI <Index>, <2ND_NIBBLE>
            __@@EMIT <mov  > al, ch
            __@@EMIT <and  > al, 0fh
            __@@EMIT <xor  > ch, ch
        ELSE
            IF1
                %OUT ERROR __@@4BPP_IDX: Valid parameter 1 are <1ST_NIBBLE>,<2ND_NIBBLE>
            ENDIF
            .ERR
            EXITM
            EXITM
        ENDIF
    ENDIF
ENDM




;
; __@@SKIP_1BPP(Count): Move _SI to the last pel of the skipped pels, and
;                       update the AH source mask to to the last skipped pels.
;

__@@SKIP_1BPP   MACRO   XCount
                LOCAL   SkipLoop, OverByte, DoneSkip

    IFIDNI <XCount>, <VAR>
SkipLoop:
        __@@EMIT <shl  > ax, 1                          ;; shift left by 1
        __@@EMIT <jc   > <SHORT OverByte>
        __@@EMIT <dec  > _BP
        __@@EMIT <jnz  > <SHORT SkipLoop>
        __@@EMIT <jmp  > <SHORT DoneSkip>
OverByte:
        ;;
        ;; 18-Feb-1998 Wed 20:43:19 updated  -by-  Daniel Chou (danielc)
        ;;  Bug Fix, we supposed to pre-shift the mask by 1 when we
        ;;  load the new byte
        ;;
        __@@EMIT <dec  > _BP                            ;; FIX!!!
        ;;
        __@@EMIT <xchg > _BP, _CX                       ;; save CX
        __@@EMIT <mov  > _BX, _CX
        __@@EMIT <shr  > _BX, 3
        __@@EMIT <add  > _SI, _BX
        __@@EMIT <and  > _CX, 7
        __@@EMIT <mov  > ah, 1
        __@@EMIT <lodsb>
        __@@EMIT <shl  > ax, cl
        __@@EMIT <mov  > _CX, _BP                       ;; restore CX
    ELSE
        __@@EMIT <shl  > ax, 1
        __@@EMIT <jnc  > <SHORT DoneSkip>
        __@@EMIT <lodsb>
        __@@EMIT <mov  > ah, 1
    ENDIF

DoneSkip:

ENDM



;
; __@@SKIP_4BPP(Count): Move _SI to the last pel of the skipped pels, and
;                       update the CH source mask to to the last skipped pels.
;
; __@@SKIP_4BPP: skip total BP count/1 pels for the 4bpp source, the source
;                byte is the current source, so we will never care about the
;                second nibble, since if we skip second nibble the next source
;                will cause a new byte to be loaded. if we skip up to the
;                first nibble then we have to load the new source and prepare
;                the second nibble because next pel will be on second nibble.
;

__@@SKIP_4BPP   MACRO XCount
                LOCAL   DoSkip1, DoSkip2, DoneSkip

    IFIDNI <XCount>, <VAR>
        __@@EMIT <or   > ch, ch                         ;; 0x80=has nibble2
        __@@EMIT <jns  > <SHORT DoSkip1>
        __@@EMIT <dec  > _BP                            ;;
DoSkip1:
        __@@EMIT <xor  > ch, ch                         ;; at byte boundary
        __@@EMIT <or   > _BP, _BP
        __@@EMIT <jz   > <SHORT DoneSkip>               ;; next auto load
        __@@EMIT <mov  > _BX, _BP
        __@@EMIT <shr  > _BP, 1
        __@@EMIT <add  > _SI, _BP
        __@@EMIT <test > bl, 1                          ;; need 2nd nibble?
        __@@EMIT <jz   > <SHORT DoneSkip>               ;; noop! next auto load
    ELSE
        __@@EMIT <xor  > ch, 80h                        ;; ch=0x80 = nibble2
        __@@EMIT <jns  > <SHORT DoneSkip>
    ENDIF

    __@@EMIT <lodsB>
    __@@4BPP_IDX    <1ST_NIBBLE>

DoneSkip:

ENDM


;
; __@@SKIP_8BPP(Count): _SI = _SI + (Count)
;

__@@SKIP_8BPP   MACRO   XCount
    IFIDNI <XCount>,<VAR>
%       __@@EMIT <add  > _SI, _BP                       ;; extended bit cleared
    ELSE
%       __@@EMIT <inc  > _SI
    ENDIF
ENDM



__@@SKIP_16BPP  MACRO   XCount, BitCount

    IFIDNI <XCount>,<VAR>
%       __@@EMIT <lea  > _SI, <[_SI+(_BP*2)]>
    ELSE
%       __@@EMIT <add  > _SI, 2
    ENDIF
ENDM


__@@SKIP_24BPP  MACRO   XCount, BitCount

    IFIDNI <XCount>,<VAR>
%       __@@EMIT <lea  > _BP, <[_BP+(_BP*2)]>
%       __@@EMIT <add  > _SI, _BP
    ELSE
%       __@@EMIT <add  > _SI, 3
    ENDIF
ENDM


__@@SKIP_32BPP  MACRO   XCount, BitCount

    IFIDNI <XCount>,<VAR>
%       __@@EMIT <lea  > _SI, <[_SI+(_BP*4)]>
    ELSE
%       __@@EMIT <add  > _SI, 4
    ENDIF
ENDM



;
; __@@PRIM_1BPP: MONO LOAD : BL = pMonoMapping[(Mask & Src) ? 1 : 0]
;                MONO AVE  : BL = AVE(BL, pMonoMapping[(Mask & Src) ? 1 : 0])
;
;                COLOR LOAD: BL = pColorMapping[(Mask & Src) ? 1 : 0]
;                            BH = pColorMapping[(Mask & Src) ? 1 : 0]
;                            DL = pColorMapping[(Mask & Src) ? 1 : 0]
;                COLOR AVE : BL = AVE(BL, pColorMapping[(Mask & Src) ? 1 : 0])
;                            BH = AVE(BH, pColorMapping[(Mask & Src) ? 1 : 0])
;                            DL = AVE(DL, pColorMapping[(Mask & Src) ? 1 : 0])
;

__@@PRIM_1BPP   MACRO ColorName

    ;;
    ;; If Bit 7 of EAX is 1 (0x80) then ebp=0xffffffff
    ;; If Bit 7 of EAX is 0 (0x00) then ebp=0x00000000
    ;;

    __@@EMIT <xor  > _BX, _BX
    __@@EMIT <bt   > _AX, 7
    __@@EMIT <adc  > _BX, 0

    __@@MappingFromBX <ColorName>

ENDM


;
; __@@PRIM_4BPP: MONO LOAD : BL = pMonoMapping[Nibble]
;                MONO AVE  : BL = AVE(BL, pMonoMapping[Nibble]
;
;                COLOR LOAD: BL = pColorMapping[Nibble]
;                            BH = pColorMapping[Nibble]
;                            DL = pColorMapping[Nibble]
;                COLOR AVE : BL = AVE(BL, pColorMapping[Nibble])
;                            BH = AVE(BH, pColorMapping[Nibble])
;                            DL = AVE(DH, pColorMapping[Nibble])
;

__@@PRIM_4BPP   MACRO ColorName

    BZXEAX  al

    __@@MappingFromAX   ColorName

ENDM



;
; __@@PRIM_8BPP:     MONO LOAD: BL = pMonoMapping[Src BYTE/WORD]
;
;                   COLOR LOAD: BL = pColorMapping[Src BYTE/WORD]
;                   ColorMapping[Src BYTE/WORD]
;                               DL = pColorMapping[Src BYTE/WORD]
;

__@@PRIM_8BPP   MACRO ColorName

    __@@EMIT <lodsB>
    BZXEAX  al

    __@@MappingFromAX   ColorName

ENDM


__@@PRIM_1632BPP    MACRO BitCount, ColorName

    IFIDNI <BitCount>, <16>
        __@@EMIT <lodsW>                                            ;;  5
    ELSE
        __@@EMIT <lodsD>                                            ;;  5
    ENDIF

    IFIDNI <ColorName>, <MONO>
        __@@EMIT <mov  > ebx, eax                                   ;;  3
        __@@EMIT <shr  > ebx, cl                                    ;;  3
        __@@EMIT <movzx> ebx, bl                                    ;;  3
%       __@@EMIT <mov  > bp, <WPTR [_PWIDX0 + (ebx*2)]>             ;;  4
        __@@EMIT <ror  > ecx, 8                                     ;;  3
        __@@EMIT <mov  > ebx, eax                                   ;;  3
        __@@EMIT <shr  > ebx, cl                                    ;;  3
        __@@EMIT <movzx> ebx, bl                                    ;;  3
%       __@@EMIT <add  > bp, <WPTR [_PWIDX1 + (ebx*2)]>             ;;  4
        __@@EMIT <ror  > ecx, 8                                     ;;  3
        __@@EMIT <shr  > eax, cl                                    ;;  3
        __@@EMIT <movzx> eax, al                                    ;;  3
%       __@@EMIT <add  > bp, <WPTR [_PWIDX2 + (eax*2)]>             ;;  4
        __@@EMIT <ror  > ecx, 16                                    ;;  3
%       __@@EMIT <mov  > ax, <WPTR [_PMONOMAP + (_BP * 2)].MonoPrim1>
%       __@@EMIT <mov  > <WPTR_ES[_DI].PMC_Prim1>, ax
    ELSE
        IFIDNI <ColorName>, <COLOR_GRAY>
            __@@EMIT <mov  > ebx, eax                               ;;  3
            __@@EMIT <shr  > ebx, cl                                ;;  3
            __@@EMIT <movzx> ebx, bl                                ;;  3
%           __@@EMIT <mov  > bp, <WPTR [_PWIDX0 + (ebx*2)]>         ;;  4
            __@@EMIT <ror  > ecx, 8                                 ;;  3
            __@@EMIT <mov  > ebx, eax                               ;;  3
            __@@EMIT <shr  > ebx, cl                                ;;  3
            __@@EMIT <movzx> ebx, bl                                ;;  3
%           __@@EMIT <add  > bp, <WPTR [_PWIDX1 + (ebx*2)]>         ;;  4
            __@@EMIT <ror  > ecx, 8                                 ;;  3
            __@@EMIT <shr  > eax, cl                                ;;  3
            __@@EMIT <movzx> eax, al                                ;;  3
%           __@@EMIT <add  > bp, <WPTR [_PWIDX2 + (eax*2)]>         ;;  4
%           __@@EMIT <mov  > <DPTR [_DI].PCC_Prim1>, 0
        ELSE
            __@@EMIT <mov  > ebx, eax                               ;;  3
            __@@EMIT <shr  > ebx, cl                                ;;  3
            __@@EMIT <movzx> ebx, bl                                ;;  3
%           __@@EMIT <mov  > bp, <WPTR [_PWIDX0 + (ebx*2)]>         ;;  4
%           __@@EMIT <mov  > bl, <BPTR [_PBIDX0 + ebx]>             ;;  4
%           __@@EMIT <mov  > <BPTR_ES[_DI].PCC_Prim1>, bl
            __@@EMIT <ror  > ecx, 8                                 ;;  3
            __@@EMIT <mov  > ebx, eax                               ;;  3
            __@@EMIT <shr  > ebx, cl                                ;;  3
            __@@EMIT <movzx> ebx, bl                                ;;  3
%           __@@EMIT <add  > bp, <WPTR [_PWIDX1 + (ebx*2)]>         ;;  4
%           __@@EMIT <mov  > bl, <BPTR [_PBIDX1 + ebx]>             ;;  4
            __@@EMIT <ror  > ecx, 8                                 ;;  3
            __@@EMIT <shr  > eax, cl                                ;;  3
            __@@EMIT <movzx> eax, al                                ;;  3
%           __@@EMIT <add  > bp, <WPTR [_PWIDX2 + (eax*2)]>         ;;  4
%           __@@EMIT <mov  > bh, <BPTR [_PBIDX2 + eax]>             ;;  4
%           __@@EMIT <mov  > <WPTR_ES[_DI].PCC_Prim2>, bx
        ENDIF

        __@@EMIT <ror  > ecx, 16                                    ;;  3
%       __@@EMIT <mov  > <WPTR_ES[_DI].PCC_Prim5>, bp
    ENDIF
ENDM


__@@PRIM_24BPP    MACRO ColorName

    __@@EMIT <lodsW>                                                ;;  5

    IFIDNI <ColorName>, <MONO>
        __@@EMIT <movzx> ebx, al                                    ;;  3
%       __@@EMIT <mov  > bp, <WPTR [_PWIDX0 + (ebx*2)]>             ;;  4
        __@@EMIT <movzx> ebx, ah                                    ;;  3
%       __@@EMIT <add  > bp, <WPTR [_PWIDX1 + (ebx*2)]>             ;;  4
        __@@EMIT <lodsB>
        __@@EMIT <movzx> eax, al                                    ;;  3
%       __@@EMIT <add  > bp, <WPTR [_PWIDX2 + (eax*2)]>             ;;  4
%       __@@EMIT <mov  > ax, <WPTR [_PMONOMAP + (_BP * 2)].MonoPrim1>
%       __@@EMIT <mov  > <WPTR_ES[_DI].PMC_Prim1>, ax
    ELSE
        IFIDNI <ColorName>, <COLOR_GRAY>
            __@@EMIT <movzx> ebx, al                                ;;  3
%           __@@EMIT <mov  > bp, <WPTR [_PWIDX0 + (ebx*2)]>         ;;  4
            __@@EMIT <movzx> ebx, ah                                ;;  3
%           __@@EMIT <add  > bp, <WPTR [_PWIDX1 + (ebx*2)]>         ;;  4
            __@@EMIT <lodsB>
            __@@EMIT <movzx> eax, al                                ;;  3
%           __@@EMIT <add  > bp, <WPTR [_PWIDX2 + (eax*2)]>         ;;  4
%           __@@EMIT <mov  > <DPTR [_DI].PCC_Prim1>, 0
        ELSE
            __@@EMIT <movzx> ebx, al                                ;;  3
%           __@@EMIT <mov  > bp, <WPTR [_PWIDX0 + (ebx*2)]>         ;;  4
%           __@@EMIT <mov  > bl, <BPTR [_PBIDX0 + ebx]>             ;;  4
%           __@@EMIT <mov  > <BPTR_ES[_DI].PCC_Prim1>, bl
            __@@EMIT <movzx> ebx, ah                                ;;  3
%           __@@EMIT <add  > bp, <WPTR [_PWIDX1 + (ebx*2)]>         ;;  4
%           __@@EMIT <mov  > bl, <BPTR [_PBIDX1 + ebx]>             ;;  4
            __@@EMIT <lodsB>
            __@@EMIT <movzx> eax, al                                ;;  3
%           __@@EMIT <add  > bp, <WPTR [_PWIDX2 + (eax*2)]>         ;;  4
%           __@@EMIT <mov  > bh, <BPTR [_PBIDX2 + eax]>             ;;  4
%           __@@EMIT <mov  > <WPTR_ES[_DI].PCC_Prim2>, bx
        ENDIF

%       __@@EMIT <mov  > <WPTR_ES[_DI].PCC_Prim5>, bp
    ENDIF
ENDM



__@@PRIM_24BPP_COPY MACRO

    __@@EMIT <lodsW>                                        ;;  5
    __@@EMIT <movzx> ebx, al                                ;;  3
    __@@EMIT <mov  > bp, <WPTR [_PWIDX0 + (ebx*2)]>         ;;  4
    __@@EMIT <mov  > <WPTR_ES[_DI].PCC_Prim1>, bp
    __@@EMIT <movzx> ebx, ah                                ;;  3
    __@@EMIT <mov  > bp, <WPTR [_PWIDX1 + (ebx*2)]>         ;;  4
    __@@EMIT <mov  > <WPTR_ES[_DI].PCC_Prim3>, bp
    __@@EMIT <lodsB>
    __@@EMIT <movzx> eax, al                                ;;  3
    __@@EMIT <mov  > bp, <WPTR [_PWIDX2 + (eax*2)]>         ;;  4
    __@@EMIT <mov  > <WPTR_ES[_DI].PCC_Prim5>, bp
ENDM


;
; Load next source (bits/byte) and translate/mapping it to the Prims
;
; 1BPP:
;    Mono: AH=Mask (carry = load)
;          AL=SourceByte (bit 7) -----> BL:BH/(AVE BL, BH=Destroyed)
;
;   Color: AH=Mask (carry = load)
;          AL=SourceByte (bit 7) -----> BL:BH:DH:DL/(AVE BL, BH=Destroyed)
;
; 4BPP:    AH=Mask (bit 7/0-3=nibble2)
;          AL=Current Nibble
;
;    Mono: AL=SrcByte, AH=CLEAR    ---> BL/(AVE BL, BH=Destroyed)
;
;   Color: AL=SrcByte, AH=CLEAR    ---> BL:BH:DH/(AVE BL:BH:DH)
;
; 8BPP:
;    Mono: BYTE DS:SI ----------------> DH/(AVE DH)
;
;   Color: BYTE DS:SI ----------------> BL:BH:DH/(AVE BL:BH:DH)
;
; 16BPP:
;    Mono: WORD DS:SI ----------------> DH/(AVE DH)
;
;   Color: WORD DS:SI ----------------> BL:BH:DH/(AVE BL:BH:DH)
;
; 24BPP:
;    Mono: DS:SI (3 bytes) -----------> DH/(AVE DH)
;
;   Color: DS:SI (3 bytes) -----------> BL:BH:DH/(AVE BL:BH:DH)
;
; 32BPP:
;    Mono: DS:SI (4 bytes) -----------> DH/(AVE DH)
;
;   Color: DS:SI (4 bytes) -----------> BL:BH:DH/(AVE BL:BH:DH)
;


;
; PRIM_SKIP?(Label):    Jmp to 'Label' if BL (Prim1) is PRIM_INVALID_DENSITY,
;                       this causing the source pel location to be skipped and
;                       destination to be preserved.
;
;   NOTE: The Label is consider a SHORT jmp label, if a full jump (32k) is
;         required then it should have another full jump label and have this
;         'label' jump to the full jump location then transfer to the final
;         desired location.
;

PRIM_SKIP?  MACRO XCount, JmpSkip

    IFB <JmpSkip>
        IF1
            %OUT Error: <PRIM_SKIP?> has no jmp label
        ENDIF
        .ERR
        EXITM
    ENDIF

%   __@@EMIT <cmp  > _BP, PRIM_COUNT_SPECIAL
%   __@@EMIT <jae  > <SHORT JmpSkip>

ENDM



;
; PRIM_END?(Label):     Jmp to 'Label' if BL/BH (Prim1/Prim2) both are
;                       PRIM_INVALID_DENSITY, this indicate the PrimCount is
;                       at end of the list, the 'Label' should specified the
;                       function EXIT location.
;
;   NOTE: The Label is consider a SHORT jmp label, if a full jump (32k) is
;         required then it should have another full jump label and have this
;         'label' jump to the full jump location then transfer to the final
;         desired location.
;

PRIM_END?   MACRO XCount, JmpEnd

    IFB <JmpEnd>
        IF1
            %OUT Error: <PRIM_END?> has no jmp label
        ENDIF
        .ERR
        EXITM
    ENDIF

%   __@@EMIT <cmp  > _BP, PRIM_COUNT_END_SCAN
%   __@@EMIT <jz   > <SHORT JmpEnd>

    IFIDNI <XCount>, <VAR>
        __@@EMIT <and  > _BP, <NOT PRIM_COUNT_SPECIAL>
    ENDIF
ENDM



;
; PRIM_NEXT(ColorName): Advance _DI by ColorInfoIncrement amount (dl or _DX),
;                       the increment may be negative.
;

PRIM_NEXT   MACRO
%   __@@EMIT <add  > _DI, [_SP]
ENDM


;
; PRIM_LOAD:    Load PrimCount to register
;

PRIM_LOAD   MACRO

%   __@@EMIT <movzx> _BP, <WPTR [_DI]>

ENDM



;
; LOAD_PROC(BitCount, JmpPrimLoad):  Defined a special source loading function,
;                                   The 'JmpPrimLoad' label is a SHORT label
;                                   and it must immediately follow coreesponse
;                                   LOAD_PROC?? macro.
;
;   This macro is used to defined a function to load next source byte for the
;   1BPP, 4BPP, since it has more than 1 source pel in a single byte, this may
;   save the source loading time, for the BPP, this macro generate no code
;

LOAD_PROC   MACRO   LabelName, BitCount, JmpPrimLoad

    IFB <LabelName>
        IF1
            %OUT Error: <LOAD_PROC> has no defined label
        ENDIF
        .ERR
        EXITM
    ENDIF

    IFB <JmpPrimLoad>
        IF1
            %OUT Error: <LOAD_PROC> has no 'jump load' label
        ENDIF
        .ERR
        EXITM
    ENDIF


    IFIDNI <BitCount>,<1>
&LabelName:
        __@@EMIT <lodsB>
        __@@EMIT <mov  > ah, 1                              ;; byte boundary
        __@@EMIT <jmp  > <SHORT JmpPrimLoad>
    ELSE
        IFIDNI <BitCount>,<4>
&LabelName:
            __@@EMIT <lodsB>                                ;; previous 1
            __@@4BPP_IDX    <1ST_NIBBLE>
            __@@EMIT <jmp  > <SHORT JmpPrimLoad>
        ENDIF
    ENDIF

ENDM



;
; LOAD_PROC??(BitCount, JmpLoadProc): Check if need to load 1BPP/4BPP source
;                                    byte, the 'JmpLoadProc' must defined and
;                                    corresponse to where this label is jump
;                                    from.  For other BPP it generate no code.
;

LOAD_PROC??  MACRO   BitCount, JmpLoadProc

    IFB <JmpLoadProc>
        IF1
            %OUT Error: <LOAD_PROC> has no JmpLoadProc label
        ENDIF
        .ERR
        EXITM
    ENDIF

    IFIDNI <BitCount>,<1>
        __@@EMIT <shl  > ax, 1
        __@@EMIT <jc   > <SHORT JmpLoadProc>
    ELSE
        IFIDNI <BitCount>,<4>
            __@@EMIT <or   > ch, ch
            __@@EMIT <jns  > <SHORT JmpLoadProc>            ;; bit before XOR
            __@@4BPP_IDX     <2ND_NIBBLE>                   ;; do 2nd nibble
        ENDIF
    ENDIF
ENDM


;
; TO_LAST_VAR_SRC(BitCount): Skip the source pels according to the xBPP, it will
;                           advance the source (_SI) to the last pels of the
;                           variable count and re-adjust its source mask (if
;                           one needed).
;

TO_LAST_VAR_SRC MACRO   BitCount
                LOCAL   DoneSkip

    ;;__@@VALID_PARAM? <SKIP_SRC>, 1, BitCount,<1,4,8,16,24,24COPY,32>

%   __@@EMIT <dec  > _BP

    IFIDNI <BitCount>, <1>
        __@@EMIT <jz   > <SHORT DoneSkip>
        __@@SKIP_1BPP    <VAR>
    ELSE
        IFIDNI <BitCount>, <4>
            __@@EMIT <jz   > <SHORT DoneSkip>
            __@@SKIP_4BPP    <VAR>
        ELSE
            IFIDNI <BitCount>, <8>
                __@@SKIP_8BPP   <VAR>
            ELSE
                IFIDNI <BitCount>, <16>
                    __@@SKIP_16BPP   <VAR>
                ELSE
                    IFIDNI <BitCount>, <32>
                        __@@SKIP_32BPP   <VAR>
                    ELSE
                        __@@SKIP_24BPP   <VAR>
                    ENDIF
                ENDIF
            ENDIF
        ENDIF
    ENDIF

DoneSkip:

ENDM



;
; SKIP_SRC(BitCount, XCount):    Skip the source pels according to the xBPP
;                               and (VAR/SINGLE) specified, it will advance the
;                               source (_SI) and re-adjust its source mask (if
;                               one needed).
;

SKIP_SRC    MACRO   BitCount, XCount

    ;;__@@VALID_PARAM? <SKIP_SRC>, 1, BitCount,<1,4,8,16,24,24COPY,32>
    ;;__@@VALID_PARAM? <SKIP_SRC>, 2, XCount, <SINGLE, VAR>

    IFIDNI <BitCount>, <1>
        __@@SKIP_1BPP   XCount
    ELSE
        IFIDNI <BitCount>, <4>
            __@@SKIP_4BPP   XCount
        ELSE
            IFIDNI <BitCount>, <8>
                __@@SKIP_8BPP   XCount
            ELSE
                IFIDNI <BitCount>, <16>
                    __@@SKIP_16BPP  XCount
                ELSE
                    IFIDNI <BitCount>, <32>
                        __@@SKIP_32BPP  XCount
                    ELSE
                        __@@SKIP_24BPP  XCount
                    ENDIF
                ENDIF
            ENDIF
        ENDIF
    ENDIF
ENDM

;
; SRC_TO_PRIMS(BitCount,Order, ColorName,GrayColor):
;       Load or blendign a source pels, it handle all BPP cases, and
;       MONO/COLOR/GRAY cases.
;

SRC_TO_PRIMS    MACRO   BitCount, ColorName

    __@@VALID_PARAM? <SRC_TO_PRIMS>, 1, BitCount,   <1,4,8,16,24,24COPY,32>
    __@@VALID_PARAM? <SRC_TO_PRIMS>, 2, ColorName,  <MONO,COLOR,COLOR_GRAY>


    IFIDNI <BitCount>, <1>
        __@@PRIM_1BPP   ColorName
    ELSE
        IFIDNI <BitCount>, <4>
            __@@PRIM_4BPP   ColorName
        ELSE
            IFIDNI <BitCount>, <8>
                __@@PRIM_8BPP   ColorName
            ELSE
                IFIDNI <BitCount>, <16>
                    __@@PRIM_1632BPP  <16>, ColorName
                ELSE
                    IFIDNI <BitCount>, <24COPY>
                        __@@PRIM_24BPP_COPY
                    ELSE
                        IFIDNI <BitCount>, <24>
                            __@@PRIM_24BPP  ColorName
                        ELSE
                            __@@PRIM_1632BPP    <32>, ColorName
                        ENDIF
                    ENDIF
                ENDIF
            ENDIF
        ENDIF
    ENDIF
ENDM



;
; BMFToPrimCount:   The Main function Macro, this macro setup all xBPP cases,
;                   and handle all MONO/COLOR cases, also it prepare special
;                   cased for 1BPP/4BPP, read/blending the source and terminate
;                   the function.
;

BMFToPrimCount  MACRO   BitCount, DoRS, ColorName

    __@@VALID_PARAM? <BMFToPrimCount>, 1, BitCount,   <1,4,8,16,24,24COPY,32>
    __@@VALID_PARAM? <BMFToPrimCount>, 2, DoRS,       <LOAD_RS,NO_RS>
    __@@VALID_PARAM? <BMFToPrimCount>, 3, ColorName,  <MONO,COLOR,COLOR_GRAY>

;===========================================================================
; Registers Usage:
;
; _SI       = pSource
; _DI       = pPrimCount
; _DX       = pMapping
; _AX       = Source Load register
;             (except 1BPP, AL=Current Source Byte, AH=Source Mask
;                     4BPP, AL=1st Nibble)          AH=0)
; bl:bh     = Prim1/2
;  ch       = for 4bpp CH=Source Load Mask
;  cl       = Free register
; [_SP]     = ColorInfoIncrement
; _BP       = VAR:  PrimCount.COUNT durning the skips, else FREE register
;===========================================================================
;===========================================================================
; 1BPP Special Setup:
;
;   AL=Current Source Byte, AH=Source Mask,
;
;   if the first loop does not cause a source byte to load (AH != 0x01) then
;   AL must preloaded with current source byte.
;
; 4BPP Special Setup:
;
;   CH=0x01 Load.  CH=0x00, data in AL, if CH=0x00 then AL must preloaded.
;
;===========================================================================



        @ENTER  _DS _SI _DI _BP      ; Save environment registers

        ;
        ; Except 1BPP --> MONO, we will swap a temporary stack so that ss:sp
        ; is point to the mapping area, and ss:sp is allowed for 256 bytes
        ; consecutive pushes.
        ;

%       MOVSX_W _AX, <WPTR InFuncInfo.IFI_ColorInfoIncrement>   ;; dx=Increment
%       __@@EMIT <push > _AX                                    ;; [_SP]=Inc.

        __@@EMIT <mov  > cl, InFuncInfo.IFI_BMF1BPP1stShift     ;; cl=1st shift
        __@@EMIT <mov  > ch, InFuncInfo.IFI_Flags               ;; ch=flags

        LDS_SI  pSource                                     ;; _SI=Source

        IFIDNI <ColorName>,<MONO>
            LES_DI  pPrimMonoCount                          ;; _DI=PrimCount
        ELSE
            LES_DI  pPrimColorCount
        ENDIF


        IFIDNI <ColorName>, <MONO>
%           __@@EMIT <mov  > _PMAPPING, <DWORD PTR pMonoMapping>
        ELSE
%           __@@EMIT <mov  > _PMAPPING, <DWORD PTR pColorMapping>
        ENDIF

        __@@EMIT <mov  > bl, ch                             ;; BL=flag

        IFIDNI <BitCount>,<1>                               ;; 1bpp special
            __@@EMIT <mov  > ah, 1                          ;; get mask siift
            __@@EMIT <test > bl, IFIF_GET_FIRST_BYTE        ;; need 1st byte
            __@@EMIT <jz   > <SHORT DoneLoad1BPP>
            __@@EMIT <lodsB>                                ;; get first byte
DoneLoad1BPP:
            __@@EMIT <shl  > ax, cl
        ELSE
            IFIDNI <BitCount>, <4>                          ;; 4 bpp special
                __@@EMIT <xor  > ch, ch                     ;; ready to carry
                __@@EMIT <test > bl, IFIF_GET_FIRST_BYTE    ;; need 1st byte?
                __@@EMIT <jz   > <SHORT DoneSpecial>
                __@@EMIT <lodsB>
                __@@EMIT <mov  > ch, al
                __@@EMIT <or   > ch, 80h
            ENDIF
        ENDIF

DoneSpecial:


        ;;
        ;; xx0 - cl=rs0/rs1/rs2
        ;; xyz - cl=rs0, ch=rs1-rs0, ecl=rs2-rs1
        ;; bgr - ecx = 0
        ;;

        IFIDNI <DoRS>, <LOAD_RS>                            ;; cl=rs0
            ;;
            ;; becase we will shift the source register (eax) for each of
            ;; the right shift, so we will shift the rs1/rs2 by differences
            ;;
%           __@@EMIT <movzx> ecx, <BPTR LUT_RS1>            ;;  cl=rs1
%           __@@EMIT <mov  > ch, <BPTR LUT_RS2>             ;;  ch=rs2
            __@@EMIT <shl  > ecx, 8                         ;; ecl=rs2-rs1
%           __@@EMIT <mov  > cl, <BPTR LUT_RS0>             ;;  ch=rs1,cl=rs0
        ENDIF

        WZXE    ax                                          ;; clear extended
        BZXE    bl                                          ;; clear extended
        WZXE    bp                                          ;; clear extended

        __@@EMIT <test > bl, IFIF_XCOUNT_IS_ONE             ;; single count?
        __@@EMIT <jnz  > <SHORT SCInit>
        __@@EMIT <jmp  > <VCInit>


;-----------------------------------------------------------------------------
; Case 2: Single Count Initial source read
;-----------------------------------------------------------------------------

JmpAllDone:
        jmp             AllDone

SCInitSkip:
        PRIM_END?       <SINGLE>, <JmpAllDone>
        SKIP_SRC        BitCount, <SINGLE>

SCInitNext:
        PRIM_NEXT

SCInit:
        PRIM_LOAD                                       ; initial load all
        PRIM_SKIP?      <SINGLE>, <SCInitSkip>

        LOAD_PROC??     BitCount, <SCInitLoad>          ; special load?

SCInitSrcRead:
        SRC_TO_PRIMS    BitCount,ColorName

        jmp             short SCInitNext

        LOAD_PROC       <SCInitLoad>,BitCount,<SCInitSrcRead>    ; must defined


;*****************************************************************************
;* EXIT AT HERE                                                              *
;*****************************************************************************

AllDone:
%       __@@EMIT <pop  > _DX                ; restore stack pointer

        @EXIT                               ; restore environment and return

;-----------------------------------------------------------------------------
; Case 4: Variable Count Initial source read
;-----------------------------------------------------------------------------


VCInitSkip:
        PRIM_END?       <VAR>, <AllDone>
        SKIP_SRC        BitCount, <VAR>                 ; skip current one
VCInitNext:
        PRIM_NEXT
VCInit:
        PRIM_LOAD
        PRIM_SKIP?      <VAR>, <VCInitSkip>             ;
        TO_LAST_VAR_SRC BitCount
        LOAD_PROC??     BitCount,<VCInitLoad>

VCInitSrcRead:
        SRC_TO_PRIMS    BitCount, ColorName

        jmp             short VCInitNext            ; check next

        LOAD_PROC       <VCInitLoad>,BitCount,<VCInitSrcRead>



ENDM



.LIST




;*****************************************************************************
; END LOCAL MACROS
;*****************************************************************************
;

@BEG_PROC   BMF1_ToPrimMono <pSource:DWORD,         \
                             pPrimMonoCount:DWORD,  \
                             pMonoMapping:DWORD,    \
                             InFuncInfo:DWORD>

            BMFToPrimCount  <1>, <NO_RS>, <MONO>
@END_PROC

;-----------------------------------------------------------------------------


@BEG_PROC   BMF4_ToPrimMono <pSource:DWORD,         \
                             pPrimMonoCount:DWORD,  \
                             pMonoMapping:DWORD,    \
                             InFuncInfo:DWORD>

            BMFToPrimCount  <4>, <NO_RS>, <MONO>
@END_PROC

;-----------------------------------------------------------------------------


@BEG_PROC   BMF8_ToPrimMono <pSource:DWORD,         \
                             pPrimMonoCount:DWORD,  \
                             pMonoMapping:DWORD,    \
                             InFuncInfo:DWORD>

            BMFToPrimCount  <8>, <NO_RS>, <MONO>
@END_PROC

;*****************************************************************************

@BEG_PROC   BMF1_ToPrimColor    <pSource:DWORD,         \
                                 pPrimColorCount:DWORD, \
                                 pColorMapping:DWORD,   \
                                 InFuncInfo:DWORD>

            BMFToPrimCount  <1>, <NO_RS>, <COLOR>
@END_PROC

;-----------------------------------------------------------------------------

@BEG_PROC   BMF4_ToPrimColor    <pSource:DWORD,         \
                                 pPrimColorCount:DWORD, \
                                 pColorMapping:DWORD,   \
                                 InFuncInfo:DWORD>

            BMFToPrimCount  <4>, <NO_RS>, <COLOR>
@END_PROC

;-----------------------------------------------------------------------------


@BEG_PROC   BMF8_ToPrimColor    <pSource:DWORD,         \
                                 pPrimColorCount:DWORD, \
                                 pColorMapping:DWORD,   \
                                 InFuncInfo:DWORD>

            BMFToPrimCount  <8>, <NO_RS>, <COLOR>
@END_PROC

;*****************************************************************************

@BEG_PROC   BMF16_ToPrimMono    <pSource:DWORD,        \
                                 pPrimMonoCount:DWORD, \
                                 pMonoMapping:DWORD,   \
                                 InFuncInfo:DWORD>

            BMFToPrimCount  <16>, <LOAD_RS>, <MONO>
@END_PROC

;-----------------------------------------------------------------------------

@BEG_PROC   BMF16_ToPrimColorGRAY   <pSource:DWORD,         \
                                     pPrimColorCount:DWORD, \
                                     pColorMapping:DWORD,   \
                                     InFuncInfo:DWORD>

            BMFToPrimCount  <16>, <LOAD_RS>, <COLOR_GRAY>
@END_PROC

;-----------------------------------------------------------------------------

@BEG_PROC   BMF16_ToPrimColor   <pSource:DWORD,         \
                                 pPrimColorCount:DWORD, \
                                 pColorMapping:DWORD,   \
                                 InFuncInfo:DWORD>

            BMFToPrimCount  <16>, <LOAD_RS>, <COLOR>
@END_PROC

;*****************************************************************************

@BEG_PROC   BMF24_ToPrimMono    <pSource:DWORD,        \
                                 pPrimMonoCount:DWORD, \
                                 pMonoMapping:DWORD,   \
                                 InFuncInfo:DWORD>

            BMFToPrimCount  <24>, <NO_RS>, <MONO>
@END_PROC

;-----------------------------------------------------------------------------

@BEG_PROC   BMF24_ToPrimColorGRAY   <pSource:DWORD,         \
                                     pPrimColorCount:DWORD, \
                                     pColorMapping:DWORD,   \
                                     InFuncInfo:DWORD>

            BMFToPrimCount  <24>, <NO_RS>, <COLOR_GRAY>
@END_PROC

;-----------------------------------------------------------------------------

@BEG_PROC   BMF24_ToPrimColor   <pSource:DWORD,         \
                                 pPrimColorCount:DWORD, \
                                 pColorMapping:DWORD,   \
                                 InFuncInfo:DWORD>

            BMFToPrimCount  <24>, <NO_RS>, <COLOR>
@END_PROC

;-----------------------------------------------------------------------------

@BEG_PROC   BMF24_ToPrimColor_COPY   <pSource:DWORD,         \
                                      pPrimColorCount:DWORD, \
                                      pColorMapping:DWORD,   \
                                      InFuncInfo:DWORD>

            BMFToPrimCount  <24COPY>, <NO_RS>, <COLOR>
@END_PROC

;*****************************************************************************

@BEG_PROC   BMF32_ToPrimMono    <pSource:DWORD,        \
                                 pPrimMonoCount:DWORD, \
                                 pMonoMapping:DWORD,   \
                                 InFuncInfo:DWORD>

            BMFToPrimCount  <32>, <LOAD_RS>, <MONO>
@END_PROC

;-----------------------------------------------------------------------------

@BEG_PROC   BMF32_ToPrimColorGRAY   <pSource:DWORD,         \
                                     pPrimColorCount:DWORD, \
                                     pColorMapping:DWORD,   \
                                     InFuncInfo:DWORD>

            BMFToPrimCount  <32>, <LOAD_RS>, <COLOR_GRAY>
@END_PROC

;-----------------------------------------------------------------------------

@BEG_PROC   BMF32_ToPrimColor   <pSource:DWORD,         \
                                 pPrimColorCount:DWORD, \
                                 pColorMapping:DWORD,   \
                                 InFuncInfo:DWORD>

            BMFToPrimCount  <32>, <LOAD_RS>, <COLOR>
@END_PROC


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


            MATCH_ENTER_EXIT?           ; Check if we missed anything



ENDIF       ; HT_ASM_80x86



END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\ht\i386\htwbmp.asm ===
PAGE 60, 132
    TITLE   Setting 1/4 bits per pel bitmap or 3 planes-1BPP bitmap


COMMENT `

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htwbmp.asm

Abstract:

    This module is used to provide set of functions to set the bits into the
    final destination bitmap, the input to these function are data structures
    (PRIMMONO_COUNT, PRIMCOLOR_COUNT and other pre-calculated data values).

    This function is the equivelant codes in the htsetbmp.c

Author:

    03-Apr-1991 Wed 10:28:50 created  -by-  Daniel Chou (danielc)


[Environment:]

    Printer Driver.


[Notes:]


Revision History:
    06-Nov-1992 Fri 16:04:18 updated  -by-  Daniel Chou (danielc)
        Fixed bug in VarCountOutputToVGA256 which clear 'ah' (xor _AX, _AX)
        while we still need to use it.


    28-Mar-1992 Sat 21:09:42 updated  -by-  Daniel Chou (danielc)
        Rewrite all output functions, add in VGA16 support.


`


        .XLIST
        INCLUDE i386\i80x86.inc
        .LIST

IF  0

IF  HT_ASM_80x86


;------------------------------------------------------------------------------
        .XLIST
        INCLUDE i386\htp.inc
        .LIST
;------------------------------------------------------------------------------

        DBG_FILENAME    i386\htwbmp


        .CODE

VGA16ColorIndex     db  000h, 077h, 077h, 088h, 088h, 0ffh  ; MONO

                    db  000h, 000h, 000h, 011h, 033h, 077h  ; RY     0
                    db  000h, 000h, 011h, 033h, 077h, 088h  ; RY     6
                    db  000h, 000h, 011h, 033h, 088h, 0ffh  ; RY    18

                    db  000h, 011h, 033h, 099h, 0bbh, 077h  ; RY    24
                    db  011h, 033h, 099h, 0bbh, 077h, 088h  ; RY    30
                    db  011h, 033h, 099h, 0bbh, 088h, 0ffh  ; RY    36

                    db  000h, 000h, 000h, 011h, 055h, 077h  ; RM    42
                    db  000h, 000h, 011h, 055h, 077h, 088h  ; RM    48
                    db  000h, 000h, 011h, 055h, 088h, 0ffh  ; RM    54

                    db  000h, 011h, 055h, 099h, 0ddh, 077h  ; RM    60
                    db  011h, 055h, 099h, 0ddh, 077h, 088h  ; RM    66
                    db  011h, 055h, 099h, 0ddh, 088h, 0ffh  ; RM    72

                    db  000h, 000h, 000h, 022h, 033h, 077h  ; GY    78
                    db  000h, 000h, 022h, 033h, 077h, 088h  ; GY    84
                    db  000h, 000h, 022h, 033h, 088h, 0ffh  ; GY    90

                    db  000h, 022h, 033h, 0aah, 0bbh, 077h  ; GY    96
                    db  022h, 033h, 0aah, 0bbh, 077h, 088h  ; GY   102
                    db  022h, 033h, 0aah, 0bbh, 088h, 0ffh  ; GY   108

                    db  000h, 000h, 000h, 022h, 066h, 077h  ; GC   114
                    db  000h, 000h, 022h, 066h, 077h, 088h  ; GC   120
                    db  000h, 000h, 022h, 066h, 088h, 0ffh  ; GC   126

                    db  000h, 022h, 066h, 0aah, 0eeh, 077h  ; GC   132
                    db  022h, 066h, 0aah, 0eeh, 077h, 088h  ; GC   138
                    db  022h, 066h, 0aah, 0eeh, 088h, 0ffh  ; GC   144

                    db  000h, 000h, 000h, 044h, 055h, 077h  ; BM   150
                    db  000h, 000h, 044h, 055h, 077h, 088h  ; BM   156
                    db  000h, 000h, 044h, 055h, 088h, 0ffh  ; BM

                    db  000h, 044h, 055h, 0cch, 0ddh, 077h  ; BM   162
                    db  044h, 055h, 0cch, 0ddh, 077h, 088h  ; BM   168
                    db  044h, 055h, 0cch, 0ddh, 088h, 0ffh  ; BM   174

                    db  000h, 000h, 000h, 044h, 066h, 077h  ; BC   180
                    db  000h, 000h, 044h, 066h, 077h, 088h  ; BC   186
                    db  000h, 000h, 044h, 066h, 088h, 0ffh  ; BC   192

                    db  000h, 044h, 066h, 0cch, 0eeh, 077h  ; BC   198
                    db  044h, 066h, 0cch, 0eeh, 077h, 088h  ; BC   204
                    db  044h, 066h, 0cch, 0eeh, 088h, 0ffh  ; BC   210



;******************************************************************************
; Following EQUATES and MACROS only used in this file
;******************************************************************************


VGA256_SSSP_XLAT_TABLE  equ     0
VGA256_XLATE_TABLE_SIZE equ     256


;                                87654321
;------------------------------------------
HTPAT_STK_MASK          equ     (0ffh)
HTPAT_NOT_STK_MASK      equ     (NOT HTPAT_STK_MASK)
HTPAT_STK_MASK_SIZE     equ     (HTPAT_STK_MASK + 1)

HTPAT_BP_SIZE           equ     (REG_MAX_SIZE * 1)
HTPAT_BP_OLDSTK         equ     (REG_MAX_SIZE * 2)
HTPAT_BP_DATA1          equ     (REG_MAX_SIZE * 3)

HTPAT_STK_SIZE_EXTRA    equ     (REG_MAX_SIZE * 3)

HTPAT_SP_SIZE           equ     (HTPAT_STK_SIZE_EXTRA - HTPAT_BP_SIZE)
HTPAT_SP_OLDSTK         equ     (HTPAT_STK_SIZE_EXTRA - HTPAT_BP_OLDSTK)
HTPAT_SP_DATA1          equ     (HTPAT_STK_SIZE_EXTRA - HTPAT_BP_DATA1)


.XLIST


@ENTER_PAT_TO_STK   MACRO   Format
                    LOCAL   StkSizeOk, DoneSetUp

    __@@VALID_PARAM? <PAT_TO_STK>, 1, Format, <1BPP, 3PLANES, 4BPP, VGA16, VGA256, 16BPP>


    @ENTER  _DS _SI _DI _BP                        ;; Save environment/registers

    __@@EMIT <xor  > _CX, _CX
    __@@EMIT <mov  > cx, <OutFuncInfo.OFI_PatWidthBytes>

    __@@EMIT <mov  > _AX, _SP                      ;; get stack location
    __@@EMIT <mov  > _DX, _AX                      ;; save it
    __@@EMIT <and  > _AX, <HTPAT_STK_MASK>         ;; how many bytes avai
    __@@EMIT <inc  > _AX                           ;; this many bytes
    __@@EMIT <cmp  > _AX, _CX                      ;; enough for pattern?
    __@@EMIT <jae  > <SHORT StkSizeOk>
    __@@EMIT <add  > _AX, <HTPAT_STK_MASK_SIZE>    ;; add this more
StkSizeOk:
    __@@EMIT <dec  > _AX                           ;; back one
    __@@EMIT <sub  > _SP, _AX                      ;; reduced it
    __@@EMIT <mov  > _DI, _SP                      ;; _DI point to the pPattern
    __@@EMIT <sub  > _SP, <HTPAT_STK_SIZE_EXTRA>   ;; reduced again
    __@@EMIT <mov  > <[_DI-HTPAT_BP_SIZE]>, _CX    ;; save the pattern size
    __@@EMIT <mov  > <[_DI-HTPAT_BP_OLDSTK]>, _DX  ;; save old stk pointer

    IFIDNI <Format>,<3PLANES>
        IFE ExtRegSet
            __@@EMIT <mov  > _AX, <WPTR OutFuncInfo.OFI_BytesPerPlane>
        ELSE
            __@@EMIT <mov  > _AX, OutFuncInfo.OFI_BytesPerPlane
        ENDIF

        __@@EMIT <mov  > <[_DI-HTPAT_BP_DATA1]>, _AX
    ENDIF

    ;
    ; now staring coping the pattern to stack
    ;

    MOV_SEG     es, ss, ax
    LDS_SI      pPattern
    MOVS_CB     _CX, dl                             ;; copy the pattern

    __@@EMIT <mov  > _BX, _DI                       ;; _BX point to the pattern start

    IFIDNI <Format>, <VGA256>
        IFE ExtRegSet
            __@@EMIT <mov  > _AX, <WPTR OutFuncInfo.OFI_BytesPerPlane + 2>
            or      _AX, _AX
            jz      SHORT DoneXlateTable
            mov     _CX, VGA256_XLATE_TABLE_SIZE
            sub     _SP, _CX
            mov     _DI, _SP
            LDS_SI  OutFuncInfo.OFI_BytesPerPlane
            MOVS_CB _CX, dl
        ELSE
            __@@EMIT <mov  > _AX, OutFuncInfo.OFI_BytesPerPlane
        ENDIF
    ENDIF

DoneXlateTable:

    IFIDNI <Format>, <1BPP>
        LDS_SI  pPrimMonoCount
    ELSE
        LDS_SI  pPrimColorCount                     ;; _SI=pPrimColorCount
    ENDIF

    LES_DI  pDest

    __@@EMIT <mov  > _BP, _BX                       ;; _BP=Pattern Start


ENDM


@EXIT_PAT_STK_RESTORE MACRO

    __@@EMIT <mov  > _BP, _SP
    __@@EMIT <mov  > _SP, <[_BP + HTPAT_SP_OLDSTK]>
    @EXIT

ENDM


WRAP_BP_PAT??   MACRO   EndWrapLoc
                Local   DoneWrap

    IFB <EndWrapLoc>
        __@@EMIT <test > bp, <HTPAT_STK_MASK>
        __@@EMIT <jnz  > <SHORT DoneWrap>
        __@@EMIT <add  > _BP, <[_BP-HTPAT_BP_SIZE]>    ;; add in pattern size
    ELSE
        __@@EMIT <test > bp, <HTPAT_STK_MASK>
        __@@EMIT <jnz  > <SHORT EndWrapLoc>
        __@@EMIT <add  > _BP, <[_BP-HTPAT_BP_SIZE]>    ;; add in pattern size
        __@@EMIT <jmp  > <SHORT EndWrapLoc>
    ENDIF

DoneWrap:

ENDM


SAVE_1BPP_DEST  MACRO

;
; Save Prim1 (DL) to Plane
;

    __@@EMIT <not  > dl                             ; invert bit
    __@@EMIT <mov  > <BPTR_ES[_DI]>, dl             ; Save Dest

ENDM


SAVE_1BPP_MASKDEST  MACRO

;
; Save Prim1 (DL) with Mask (DH, 1=Preserved, 0=Overwrite) to Dest
;

    __@@EMIT <and  > <BPTR_ES[_DI]>, dh             ; Mask overwrite bits
    __@@EMIT <not  > dx                             ; invert bit/mask
    __@@EMIT <and  > dl, dh
    __@@EMIT <or   > <BPTR_ES[_DI]>, dl             ; Save Plane1=Prim3

ENDM


SAVE_VGA16_DEST  MACRO

;
; Save Prim1/2/3 (DL) to Plane
;

    __@@EMIT <mov  > dh, dl
    __@@EMIT <add  > dh, 11h
    __@@EMIT <and  > dh, 88h
    __@@EMIT <or   > dl, dh
    __@@EMIT <not  > dl
    __@@EMIT <mov  > <BPTR_ES[_DI]>, dl             ; Save Dest

ENDM


SAVE_VGA16_DEST_HIGH MACRO

;
; Save Prim1 (DL) high nibble only, preserved low nibble
;


    __@@EMIT <and  > <BPTR_ES[_DI]>, 0fh            ; Mask overwrite bits
    __@@EMIT <mov  > dh, dl
    __@@EMIT <inc  > dh
    __@@EMIT <and  > dh, 08h
    __@@EMIT <or   > dl, dh
    __@@EMIT <not  > dl                             ; invert bit/mask
    __@@EMIT <shl  > dl, 4
    __@@EMIT <or   > <BPTR_ES[_DI]>, dl             ; Save Plane1=Prim3

ENDM


SAVE_VGA16_DEST_LOW  MACRO

;
; Save Prim1 (DL) low nibble only, preserved high nibble
;


    __@@EMIT <and  > <BPTR_ES[_DI]>, 0f0h           ; Mask overwrite bits
    __@@EMIT <mov  > dh, dl
    __@@EMIT <inc  > dh
    __@@EMIT <and  > dh, 08h
    __@@EMIT <or   > dl, dh
    __@@EMIT <xor  > dl, 0fh                        ; invert bit/mask
    __@@EMIT <or   > <BPTR_ES[_DI]>, dl             ; Save Plane1=Prim3

ENDM


SAVE_4BPP_DEST  MACRO

;
; Save Prim1/2/3 (DL) to Plane
;

    __@@EMIT <xor  > dl, 77h
    __@@EMIT <mov  > <BPTR_ES[_DI]>, dl             ; Save Dest

ENDM


SAVE_4BPP_DEST_HIGH MACRO
                    LOCAL   DoneVGA

;
; Save Prim1 (DL) high nibble only, preserved low nibble
;


    __@@EMIT <and  > <BPTR_ES[_DI]>, 0fh            ; Mask overwrite bits
    __@@EMIT <xor  > dl, 07h                        ; Invert bits
    __@@EMIT <shl  > dl, 4                          ; move to high nibble
    __@@EMIT <or   > <BPTR_ES[_DI]>, dl             ; Save Plane1=Prim3

ENDM


SAVE_4BPP_DEST_LOW  MACRO
                    LOCAL   DoneVGA
;
; Save Prim1 (DL) low nibble only, preserved high nibble
;


    __@@EMIT <and  > <BPTR_ES[_DI]>, 0f0h           ; Mask overwrite bits
    __@@EMIT <xor  > dl, 07h                        ; invert bit/mask
    __@@EMIT <or   > <BPTR_ES[_DI]>, dl             ; Save Plane1=Prim3

ENDM



SAVE_3PLANES_DEST  MACRO   UseAX

;
; Save Prim1/2/3 (CL:CH:DL) to Plane3/2/1
;

    IFB <UseAX>
        __@@EMIT <push > _BP                        ; save Prim1/2
    ELSE
        __@@EMIT <mov  > _AX, _BP                   ; save _BP
    ENDIF

    __@@EMIT <and  > _BP, <HTPAT_NOT_STK_MASK>      ; to HTPAT_BP_xxx
    __@@EMIT <mov  > _BP, <[_BP - HTPAT_BP_DATA1]>  ; size of plane

    __@@EMIT <not  > cx                             ; invert the bits
    __@@EMIT <not  > dl                             ; invert bit

    __@@EMIT <mov  > <BPTR_ES[      _DI]>, dl       ; Save Plane1=Prim3
    __@@EMIT <mov  > <BPTR_ES[_BP + _DI]>, ch       ; save Plane2=Prim2

    IFE ExtRegSet
        __@@EMIT <add  > _BP, _BP                   ; goto plane3
        __@@EMIT <mov  > <BPTR_ES[_BP+_DI]>, cl     ; save Plane3=Prim1
    ELSE
        __@@EMIT <mov  > <BPTR_ES[(_BP*2)+_DI]>, cl ; save Plane3=Prim1
    ENDIF

    IFB <UseAX>
        __@@EMIT <pop  > _BP                        ; restore _BP
    ELSE
        __@@EMIT <mov  > _BP, _AX                   ; restore _BP
    ENDIF

ENDM



SAVE_3PLANES_MASKDEST  MACRO   UseAX
;
; Save Prim1/2/3 (CL:CH:DL) with Mask (DH, 1=Preserved, 0=Overwrite) to
; Plane3/2/1
;

    IFB <UseAX>
        __@@EMIT <push > _BP                        ; save Prim1/2
    ELSE
        __@@EMIT <mov  > _AX, _BP                   ; save _BP
    ENDIF

    __@@EMIT <and  > _BP, <HTPAT_NOT_STK_MASK>      ; to HTPAT_BP_xxx
    __@@EMIT <mov  > _BP, <[_BP - HTPAT_BP_DATA1]>  ; size of plane

    __@@EMIT <not  > cx                             ; invert the bits
    __@@EMIT <not  > dx                             ; invert bit/mask
    __@@EMIT <and  > cl, dh                         ; mask preserved bits
    __@@EMIT <and  > ch, dh
    __@@EMIT <and  > dl, dh
    __@@EMIT <not  > dh                             ; for dest mask

    __@@EMIT <and  > <BPTR_ES[      _DI]>, dh       ; Mask overwrite bits
    __@@EMIT <or   > <BPTR_ES[      _DI]>, dl       ; Save Plane1=Prim3

    __@@EMIT <and  > <BPTR_ES[_BP + _DI]>, dh       ; Mask overwrite bits
    __@@EMIT <or   > <BPTR_ES[_BP + _DI]>, ch       ; save Plane2=Prim2

    IFE ExtRegSet
        __@@EMIT <add  > _BP, _BP                       ; goto plane3
        __@@EMIT <and  > <BPTR_ES[_BP + _DI]>, dh       ; Mask overwrite bits
        __@@EMIT <or   > <BPTR_ES[_BP + _DI]>, cl       ; save Plane3=Prim1
    ELSE
        __@@EMIT <and  > <BPTR_ES[(_BP*2) + _DI]>, dh   ; Mask overwrite bits
        __@@EMIT <or   > <BPTR_ES[(_BP*2) + _DI]>, cl   ; save Plane3=Prim1
    ENDIF

    IFB <UseAX>
        __@@EMIT <pop  > _BP                        ; restore _BP
    ELSE
        __@@EMIT <mov  > _BP, _AX                   ; restore _BP
    ENDIF
ENDM


.LIST



SUBTTL  SingleCountOutputTo1BPP
PAGE

COMMENT `


Routine Description:

    This function output to the BMF_1BPP destination surface from
    PRIMMONO_COUNT data structure array.

Arguments:

    pPrimMonoCount  - Pointer to the PRIMMONO_COUNT data structure array.

    pDest           - Pointer to first modified destination byte

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:


`


@BEG_PROC   SingleCountOutputTo1BPP <pPrimMonoCount:DWORD,  \
                                     pDest:DWORD,           \
                                     pPattern:DWORD,        \
                                     OutFuncInfo:QWORD>


;
; Register Usage:
;
; _SI           = pPrimMonoCount
; _DI           = pDestination
; _BP           = Self host pPattern
; al:ah         = Prim1/2
; dl            = DestByte
; dh            = DestMask


        @ENTER_PAT_TO_STK   <1BPP>      ; _BP=Pat location, fall throug to load

;=============================================================================
; the DH has two uses, it contains the mask bits (1 bit=Mask), and it also
; contains an extra bit to do a byte boundary test, every time we shift the
; mask left by one, the boundary bit get shift to left, when first time a
; carry is produced then we know we finished one byte. at here we set up the
; dh=FirstMask + Aligned boundary bit
;=============================================================================

        mov     _DX, 1ffh               ; dh=Mask (1=Mask, 0=Not Mask)
        MOVZX_W _CX, <WPTR [_SI]>       ; load extended
        sub     _BP, _CX                ; back the _BP
        shl     _DX, cl                 ; set first mask
        xor     dl, dl                  ; clear Prim1
        jmp     short LoadByte


;============================================================================
; EOF encountered, if Mask (DH) is equal to 0x01 then we just starting the new
; byte, which we just have exactly end at last byte boundary (no last byte
; mask), otherwise, shift all destination byte to left by count, then mask it
;============================================================================
; EOF encountered, if count is 0, then there is no last byte mask, so just
; exit, otherwise, shift all destination byte to left by count, then mask it
;============================================================================

EOFDest:
        cmp     dh, 1
        jz      short AllDone                   ; finished

EOFDestMask:
        mov     cx, WPTR [_SI]                  ; get LastByteSkips

        xor     ah, ah                          ; ax=0xffff now, clear ah
        shl     ax, cl                          ; ah=LastByteMask
        shl     dx, cl                          ; shift Mask+Prim1
        or      dh, ah                          ; add in dh=mask
        cmp     dh, 0ffh                        ; if dh=0xff then all masked
        jz      short AllDone

        SAVE_1BPP_MASKDEST                      ; save last byte

AllDone:
        @EXIT_PAT_STK_RESTORE


;==========================================================================
; An invalid density is encountered, (0xff to indicate the stretch must not
; update to the destination), if this is the last stretch then do 'EOFDest'
; otherwise set mask bits until the byte boundary is encountered then fall
; through to load next byte, if a byte boundary is before count are exausted
; then save that mask byte and it will automatically skip rest of the pels.
;==========================================================================

InvDensity:
        cmp     al, ah
        jz      short EOFDest                   ; EOF
        add     dx, dx
        inc     dh                              ; add in mask, 'C' not changed
        jc      short DoneOneByte               ; finished? if not fall through

LoadByte:
        add     _SI, SIZE_PMC                   ; sizeof(PRIMMONO_COUNT)
        mov     ax, WPTR [_SI+2]                ; al:ah=Prim 1/2
        dec     _BP                             ; ready to access pattern
        cmp     al, PRIM_INVALID_DENSITY
        jz      short InvDensity
        cmp     al, BPTR[_BP]                   ; check with pattern
        adc     dx, dx
        jnc     short LoadByte

DoneOneByte:
        or      dh, dh                          ; any mask?
        jnz     short HasDestMask

        SAVE_1BPP_DEST                          ; save it, no jmp

ReadyNextByte:
        inc     _DI
        mov     _DX, 0100h                      ; dh=0x01=Boundary test bit

        WRAP_BP_PAT??   <LoadByte>

HasDestMask:
        cmp     dh, 0ffh
        jz      short ReadyNextByte             ;

        SAVE_1BPP_MASKDEST                      ; save it with DH=mask

        jmp     short ReadyNextByte


@END_PROC



SUBTTL  VarCountOutputTo1BPP
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_1BPP destination surface from
    PRIMMONO_COUNT data structure array.

Arguments:

    pPrimMonoCount  - Pointer to the PRIMMONO_COUNT data structure array.

    pDest           - Pointer to first modified destination byte

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:


`


@BEG_PROC   VarCountOutputTo1BPP    <pPrimMonoCount:DWORD,  \
                                     pDest:DWORD,           \
                                     pPattern:DWORD,        \
                                     OutFuncInfo:QWORD>


;
; Register Usage:
;
; _SI           = pPrimMonoCount
; _DI           = pDestination
; _BP           = Self host pPattern
; cx            = PrimMonoCount.Count
; al:ah         = Prim1/2
; dl            = DestByte
; dh            = DestMask
;


        @ENTER_PAT_TO_STK   <1BPP>      ; _BP=Pat location

;=============================================================================
; the DH has two uses, it contains the mask bits (1 bit=Mask), and it also
; contains an extra bit to do a byte boundary test, every time we shift the
; mask left by one, the boundary bit get shift to left, when first time a
; carry is produced then we know we finished one byte. at here we set up the
; dh=FirstMask + Aligned boundary bit
;=============================================================================

        mov     _DX, 1ffh               ; dh=Mask (1=Mask, 0=Not Mask)
        MOVZX_W _CX, <WPTR [_SI]>       ; load extended
        sub     _BP, _CX                ; back the _BP
        shl     _DX, cl                 ; set first mask
        xor     dl, dl                  ; clear Prim1
        jmp     short LoadByte

;============================================================================
; EOF encountered, if Mask (DH) is equal to 0x01 then we just starting the new
; byte, which we just have exactly end at last byte boundary (no last byte
; mask), otherwise, shift all destination byte to left by count, then mask it
;============================================================================
; EOF encountered, if count is 0, then there is no last byte mask, so just
; exit, otherwise, shift all destination byte to left by count, then mask it
;============================================================================

EOFDest:
        jcxz    short AllDone                   ; if cx=0 then done

EOFDestMask:
        xor     ah, ah                          ; ax=0xffff now, clear ah
        shl     ax, cl                          ; ah=LastByteMask
        shl     dx, cl                          ; shift Mask+Prim1
        or      dh, ah                          ; add in dh=mask
        cmp     dh, 0ffh                        ; if dh=0xff then all masked
        jz      short AllDone

        SAVE_1BPP_MASKDEST                      ; save it with DH=mask

AllDone:
        @EXIT_PAT_STK_RESTORE                   ; restore original SP

;==========================================================================
; An invalid density is encountered, (0xff to indicate the stretch must not
; update to the destination), if this is the last stretch then do 'EOFDest'
; otherwise set mask bits until the byte boundary is encountered then fall
; through to load next byte, if a byte boundary is before count are exausted
; then save that mask byte and it will automatically skip rest of the pels.
;==========================================================================

InvDensity:
        cmp     al, ah
        jz      short EOFDest                   ; done
InvDensityLoop:
        dec     _BP
        add     dx, dx
        inc     dh                              ; add in mask, 'C' not changed
        jc      short DoneOneByte
        dec     cx
        jnz     short InvDensityLoop            ; !!! FALL THROUGH

LoadByte:
        add     _SI, SIZE_PMC                   ; sizeof(PRIMMONO_COUNT)
        mov     cx, WPTR [_SI]                  ; cx=Count
        mov     ax, WPTR [_SI+2]                ; al:ah=Prim1/2
        cmp     al, PRIM_INVALID_DENSITY        ; a skip?, if yes go do it
        jz      short InvDensity
        inc     cx                              ; make it no jump
MakeByte:
        dec     cx
        jz      short LoadByte
        dec     _BP                             ; ready to access pattern
        mov     ah, BPTR[_BP]                   ; get pattern
        cmp     al, ah
        adc     dx, dx
        jnc     short MakeByte                  ; if carry then byte boundary

DoneOneByte:
        or      dh, dh                          ; any mask?
        jnz     short HasDestMask               ; yes

        SAVE_1BPP_DEST                          ; save it

ReadyNextByte:
        inc     _DI                             ; ++pDest
        mov     _DX, 0100h                      ; dh=0x01, dl=0x00

        WRAP_BP_PAT??   <MakeByte>

;=============================================================================
; Mask the destination by DH mask, (1 bit=Mask), if whole destiantion byte is
; masked then just increment the pDest
;=============================================================================

HasDestMask:
        cmp     dh, 0ffh
        jz      short DoneDestMask

        SAVE_1BPP_MASKDEST                      ; save it with DH=mask

DoneDestMask:
        cmp     al, PRIM_INVALID_DENSITY        ; is last one a skip stretch?
        jnz     short ReadyNextByte
        cmp     cx, 1                           ; more than 0 count?
        jbe     short ReadyNextByte             ; no, continue

        ;
        ;*** FALL THROUGH
        ;

;============================================================================
; skip the 'cx-1' count of pels on the destination (SI is post decrement so
; we must only skip 'cxi-1' count), it will skip the 'pDest', set up next
; pDest mask, also it will aligned the destination pattern pointer (_BP)
;===========================================================================

SkipDestPels:
        inc     _DI                             ; update to current pDest

        dec     cx                              ; back one
        WZXE    cx                              ; zero extended
        mov     _AX, _CX                        ; _AX=_CX=Count
        and     cl, 7
        ;===============================================================
        mov     _DX, 1ffh                       ; ready to shift
        shl     _DX, cl                         ; Boundary Bit + MASK
        xor     dl, dl                          ; clear Prim1
        ;================================================================
        mov     _CX, _AX                        ; get count again
        shr     _CX, 3
        add     _DI, _CX                        ; pDest += (Count >> 3)
        mov     _CX, _BP                        ; align pattern now
        and     _CX, HTPAT_STK_MASK             ; how many pat avai.?
        xor     _BP, _CX                        ; clear _BP mask=pPattern
        sub     _CX, _AX                        ; see if > 0? (_AX=Count)
        jg      short DoneSkipDestPels          ; still not used up yet!
        mov     _AX, [_BP - HTPAT_BP_SIZE]      ; get pattern size
SkipDestPelsLoop:
        add     _CX, _AX
        jle     short SkipDestPelsLoop          ; do until > 0
DoneSkipDestPels:
        add     _BP, _CX                        ; _BP=pCurPat
        jmp     LoadByte



@END_PROC



SUBTTL  SingleCountOutputTo3Planes
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_1BPP_3PLANES destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination planes pointers.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:

    18-Jun-1991 Tue 12:00:35 updated  -by-  Daniel Chou (danielc)
        Fixed destination masking bugs, it should be 0xff/0x00 rather 0x77

`


@BEG_PROC   SingleCountOutputTo3Planes  <pPrimColorCount:DWORD, \
                                         pDest:DWORD,           \
                                         pPattern:DWORD,        \
                                         OutFuncInfo:QWORD>


;
; Register Usage:
;
; _SI       = pPrimMonoCount
; _BP       = Self host pPattern
; _SP       = Some saved environment (Old BP to get to the local variable)
; bl:bh:al  = Prim 1/2/3
; cl:ch:dl  = Current Destination Byte, 0x88 is the mask bit indicator
; dh        = Dest Mask
;
;   Prim1 -> pPlane3 <---- Highest bit
;   Prim2 -> pPlane2
;   Prim3 -> pPlane1 <---- Lowest bit
;
; Local Variable access from Old BP, BytesPerPlane
;


        @ENTER_PAT_TO_STK   <3PLANES>   ; _BP=Pat location, fall throug to load

;=============================================================================
; the DH has two uses, it contains the mask bits (1 bit=Mask), and it also
; contains an extra bit to do a byte boundary test, every time we shift the
; mask left by one, the boundary bit get shift to left, when first time a
; carry is produced then we know we finished one byte. at here we set up the
; dh=FirstMask + Aligned boundary bit
;=============================================================================

        mov     _DX, 1ffh               ; dh=Mask (1=Mask, 0=Not Mask)
        MOVZX_W _CX, <WPTR [_SI]>       ; load extended
        sub     _BP, _CX                ; back the _BP
        shl     _DX, cl                 ; set first mask
        xor     dl, dl
        xor     _CX, _CX                ; clear cx now
        jmp     short LoadByte


;============================================================================
; EOF encountered, if Mask (DH) is equal to 0x01 then we just starting the new
; byte, which we just have exactly end at last byte boundary (no last byte
; mask), otherwise, shift all destination byte to left by count, then mask it
;============================================================================
; EOF encountered, if count is 0, then there is no last byte mask, so just
; exit, otherwise, shift all destination byte to left by count, then mask it
;============================================================================

EOFDest:
        cmp     dh, 1
        jz      short AllDone                   ; finished

EOFDestMask:
        mov     ax, cx                          ; save Prim1/2=al:ah
        mov     cx, WPTR [_SI]                  ; get LastByteSkips

        xor     bh, bh                          ; bx=0xffff now, clear bh
        shl     bx, cl                          ; bh=LastByteMask
        shl     dx, cl                          ; shift Mask+Prim3
        or      dh, bh                          ; add in dh=mask
        cmp     dh, 0ffh                        ; if dh=0xff then all masked
        jz      short AllDone

        shl     ax, cl                          ; shift Prim1/2
        mov     cx, ax                          ; restore cl:ch=Prim1/2

        SAVE_3PLANES_MASKDEST <UseAX>           ; save last byte

AllDone:
        @EXIT_PAT_STK_RESTORE                   ; exit/restore env/stack


;==========================================================================
; An invalid density is encountered, (0xff to indicate the stretch must not
; update to the destination), if this is the last stretch then do 'EOFDest'
; otherwise set mask bits until the byte boundary is encountered then fall
; through to load next byte, if a byte boundary is before count are exausted
; then save that mask byte and it will automatically skip rest of the pels.
;==========================================================================

InvDensity:
        cmp     bl, bh
        jz      short EOFDest                   ; EOF
        add     cx, cx
        add     dx, dx
        inc     dh                              ; add in mask, 'C' not changed
        jc      short DoneOneByte               ; finished? if not fall through

LoadByte:
        add     _SI, SIZE_PCC                   ; sizeof(PRIMCOLOR_COUNT)
        mov     bx, WPTR [_SI+2]                ; bl:bh:al:ah=Prim 1/2/3/4
        mov     ax, WPTR [_SI+4]
        dec     _BP                             ; ready to access pattern
        cmp     bl, PRIM_INVALID_DENSITY
        jz      short InvDensity
        mov     ah, BPTR[_BP]                   ; get pattern
        cmp     bl, ah
        adc     cl, cl
        cmp     bh, ah
        adc     ch, ch
        cmp     al, ah
        adc     dx, dx
        jnc     short LoadByte

DoneOneByte:
        or      dh, dh                          ; any mask?
        jnz     short HasDestMask

        SAVE_3PLANES_DEST <UseAX>               ; save it, no jmp

ReadyNextByte:
        inc     _DI
        xor     _CX, _CX                        ; clear destination
        mov     _DX, 0100h                      ; dh=0x01=Boundary test bit

        WRAP_BP_PAT??   <LoadByte>

HasDestMask:
        cmp     dh, 0ffh
        jz      short ReadyNextByte             ;

        SAVE_3PLANES_MASKDEST <UseAX>           ; save it with DH=mask

        jmp     short ReadyNextByte


@END_PROC



SUBTTL  VarCountOutputTo3Planes
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_1BPP_3PLANES destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination planes pointers.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:

    18-Jun-1991 Tue 12:00:35 updated  -by-  Daniel Chou (danielc)
        Fixed destination masking bugs, it should be 0xff/0x00 rather 0x77


`



@BEG_PROC   VarCountOutputTo3Planes <pPrimColorCount:DWORD, \
                                     pDest:DWORD,           \
                                     pPattern:DWORD,        \
                                     OutFuncInfo:QWORD>


;
; Register Usage:
;
; _SI       = pPrimColorCount
; _BP       = Self host pPattern
; _SP       = Some saved environment (Old BP to get to the local variable)
; di        = pPlane1
; bl:bh:al  = Prim 1/2/3
; cl:ch:dl  = Current Destination Byte, 0x88 is the mask bit indicator
; dh        = Dest Mask
;
;   Prim1 -> pPlane3 <---- Highest bit
;   Prim2 -> pPlane2
;   Prim3 -> pPlane1 <---- Lowest bit
;
; Local Variable access from Old BP, BytesPerPlane
;


        @ENTER_PAT_TO_STK   <3PLANES>   ; _BP=Pat location

;=============================================================================
; the DH has two uses, it contains the mask bits (1 bit=Mask), and it also
; contains an extra bit to do a byte boundary test, every time we shift the
; mask left by one, the boundary bit get shift to left, when first time a
; carry is produced then we know we finished one byte. at here we set up the
; dh=FirstMask + Aligned boundary bit
;=============================================================================

        mov     _DX, 1ffh               ; dh=Mask (1=Mask, 0=Not Mask)
        MOVZX_W _CX, <WPTR [_SI]>       ; load extended
        sub     _BP, _CX                ; back the _BP
        shl     _DX, cl                 ; set first mask
        xor     dl, dl
        xor     _CX, _CX                ; clear cx now
        jmp     short FirstLoadByte

;============================================================================
; EOF encountered, if Mask (DH) is equal to 0x01 then we just starting the new
; byte, which we just have exactly end at last byte boundary (no last byte
; mask), otherwise, shift all destination byte to left by count, then mask it
;============================================================================
; EOF encountered, if count is 0, then there is no last byte mask, so just
; exit, otherwise, shift all destination byte to left by count, then mask it
;============================================================================

EOFDest:
        or      si, si
        jz      short AllDone

EOFDestMask:
        xchg    si, cx                          ; si=Prim1/2, cx=Last Skips

        xor     bh, bh                          ; bx=0xffff now, clear bh
        shl     bx, cl                          ; bh=LastByteMask
        shl     dx, cl                          ; shift Mask+Prim3
        or      dh, bh                          ; add in dh=mask
        cmp     dh, 0ffh                        ; if dh=0xff then all masked
        jz      short AllDone

        shl     si, cl                          ; shift Prim1/2
        mov     cx, si                          ; restore cl:ch=Prim1/2

        SAVE_3PLANES_MASKDEST                   ; save it with DH=mask

AllDone:
        pop     _SI                             ; pop the source pointer push
        @EXIT_PAT_STK_RESTORE                   ; restore original SP

;==========================================================================
; An invalid density is encountered, (0xff to indicate the stretch must not
; update to the destination), if this is the last stretch then do 'EOFDest'
; otherwise set mask bits until the byte boundary is encountered then fall
; through to load next byte, if a byte boundary is before count are exausted
; then save that mask byte and it will automatically skip rest of the pels.
;==========================================================================

InvDensity:
        cmp     bl, bh
        jz      short EOFDest                   ; done
InvDensityLoop:
        dec     _BP
        add     cx, cx
        add     dx, dx
        inc     dh                              ; add in mask, 'C' not changed
        jc      short DoneOneByte
        dec     si
        jnz     short InvDensityLoop            ; !!! FALL THROUGH

LoadByte:
        pop     _SI                             ; restore _SI
FirstLoadByte:
        add     _SI, SIZE_PCC                   ; sizeof(PRIMCOLOR_COUNT)
        push    _SI                             ; save _SI
        mov     bx, WPTR [_SI+2]                ; bl:bh=Prim1/2
        mov     ax, WPTR [_SI+4]                ; al:ah=Prim3/4
        mov     si, WPTR [_SI]                  ; si=Count
        cmp     bl, PRIM_INVALID_DENSITY        ; a skip?, if yes go do it
        jz      short InvDensity
        inc     si                              ; make it no jump
MakeByte:
        dec     si
        jz      short LoadByte
        dec     _BP                             ; ready to access pattern
        mov     ah, BPTR[_BP]                   ; get pattern
        cmp     bl, ah
        adc     cl, cl
        cmp     bh, ah
        adc     ch, ch
        cmp     al, ah
        adc     dx, dx
        jnc     short MakeByte                  ; if carry then byte boundary

DoneOneByte:
        or      dh, dh                          ; any mask?
        jnz     short HasDestMask               ; yes

        SAVE_3PLANES_DEST                       ; save it

ReadyNextByte:
        inc     _DI                             ; ++pDest
        xor     _CX, _CX                        ; clear destination
        mov     _DX, 0100h                      ; dh=0x01, dl=0x00

        WRAP_BP_PAT??   <MakeByte>

;=============================================================================
; Mask the destination by DH mask, (1 bit=Mask), if whole destiantion byte is
; masked then just increment the pDest
;=============================================================================

HasDestMask:
        cmp     dh, 0ffh
        jz      short DoneDestMask

        SAVE_3PLANES_MASKDEST                   ; save it with DH=mask

DoneDestMask:
        cmp     bl, PRIM_INVALID_DENSITY        ; is last one a skip stretch?
        jnz     short ReadyNextByte
        cmp     si, 1                           ; more than 0 count?
        jbe     short ReadyNextByte             ; no, continue

        ;
        ;*** FALL THROUGH
        ;

;============================================================================
; skip the 'si-1' count of pels on the destination (SI is post decrement so
; we must only skip 'si-1' count), it will skip the 'pDest', set up next
; pDest mask, also it will aligned the destination pattern pointer (_BP)
;===========================================================================

SkipDestPels:
        inc     _DI                             ; update to current pDest

        dec     si                              ; back one
        WZXE    si                              ; zero extended
        mov     cx, si
        and     cl, 7
        ;===============================================================
        mov     _DX, 1ffh                       ; ready to shift
        shl     _DX, cl
        xor     dl, dl                          ; clear Prim3
        xor     _CX, _CX                        ; clear Prim1/2
        ;================================================================
        mov     _BX, _SI
        shr     _BX, 3
        add     _DI, _BX
        mov     _BX, _BP
        and     _BX, HTPAT_STK_MASK             ; how many pat avai.?
        xor     _BP, _BX                        ; clear _BP mask=pPattern
        sub     _BX, _SI                        ; see if > 0?
        jg      short DoneSkipDestPels
        mov     _SI, [_BP - HTPAT_BP_SIZE]      ; get pattern size
SkipDestPelsLoop:
        add     _BX, _SI
        jle     short SkipDestPelsLoop          ; do until > 0
DoneSkipDestPels:
        add     _BP, _BX                        ; _BP=pCurPat
        jmp     LoadByte


@END_PROC




SUBTTL  SingleCountOutputTo4BPP
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_4BPP destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination planes pointers.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:


`

@BEG_PROC   SingleCountOutputTo4BPP <pPrimColorCount:DWORD, \
                                     pDest:DWORD,           \
                                     pPattern:DWORD,        \
                                     OutFuncInfo:QWORD>


;==========================================
; Register Usage:
;
; _SI           : pPrimColorCount
; _DI           : pDest
; _BP           : Current pPattern, self wrappable
; bl:bh:al:ah   : Prim 1/2/3/4          =====> Bit 2:1:0
; dl            : DestByte
; dh            : scratch register
; ch            : PRIM_INVALID_DENSITY
; cl            : PRIM_INVALID_DENSITY --> CX = PRIMCOUNT_EOF
;==========================================


        @ENTER_PAT_TO_STK   <4BPP>                  ; _BP=Pat location

;=============================================================================
; the DH has two uses, it contains the mask bits (1 bit=Mask), and it also
; contains an extra bit to do a byte boundary test, every time we shift the
; mask left by one, the boundary bit get shift to left, when first time a
; carry is produced then we know we finished one byte. at here we set up the
; dh=FirstMask + Aligned boundary bit
;=============================================================================

        mov     _CX, PRIMCOUNT_EOF
        xor     _DX, _DX                            ; clear mask/dest
        cmp     WPTR [_SI], dx                      ; check if begin with skip
        jnz     short InvDensityHStart              ; has first skip

LoadByteH:
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     bx, WPTR [_SI+2]                    ; bl:bh=Prim 1/2
        cmp     bl, ch                              ; invalid?
        jz      short InvDensityH
        mov     ax, WPTR [_SI+4]                    ; al:ah=Prim 3/4

MakeByteH:
        dec     _BP
        mov     dh, BPTR [_BP]
        cmp     bl, dh
        adc     dl, dl
        cmp     bh, dh
        adc     dl, dl
        cmp     al, dh
        adc     dl, dl

LoadByteL:
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     bx, WPTR [_SI+2]                    ; bl:bh=Prim 1/2
        cmp     bl, ch                              ; invalid?
        jz      short InvDensityL
        mov     ax, WPTR [_SI+4]                    ; al:ah=Prim 3/4

MakeByteL:
        add     dl, dl
        dec     _BP
        mov     dh, BPTR [_BP]
        cmp     bl, dh
        adc     dl, dl
        cmp     bh, dh
        adc     dl, dl
        cmp     al, dh
        adc     dl, dl

        SAVE_4BPP_DEST

ReadyNextByte:
        inc     _DI
        xor     _DX, _DX

        WRAP_BP_PAT?? <LoadByteH>

;=============================================================================
; The high nibble need to be skipped, (byte boundary now), if bl=bh=INVALID
; then we are done else set the mask=0xf0 (high nibble) and if count > 1 then
; continune load LOW nibble
;=============================================================================

InvDensityH:
        cmp     bl, bh                          ; end?
        jz      short AllDone                   ; exactly byte boundary
InvDensityHStart:
        dec     _BP                             ; update pCurPat
LoadByteL2:
        add     _SI, SIZE_PCC                   ; sizeof(PRIMCOLOR_COUNT)
        mov     bx, WPTR [_SI+2]                ; bl:bh=Prim 1/2
        cmp     bl, ch                          ; invalid?
        jz      short DoneDestMask
        mov     ax, WPTR [_SI+4]                ; al:ah=Prim 3/4

MakeByteL2:
        add     dl, dl                          ; skip high bit
        mov     dh, BPTR [_BP-1]                ; load next pattern
        cmp     bl, dh
        adc     dl, dl
        cmp     bh, dh
        adc     dl, dl
        cmp     al, dh
        adc     dl, dl

        SAVE_4BPP_DEST_LOW                      ; fall through

DoneDestMask:
        dec     _BP
        cmp     bx, cx                          ; done?
        jnz     short ReadyNextByte
        jmp     short AllDone

InvDensityL:
        SAVE_4BPP_DEST_HIGH
        dec     _BP
        cmp     bx, cx
        jnz     short ReadyNextByte

AllDone:
        @EXIT_PAT_STK_RESTORE


@END_PROC




SUBTTL  VarCountOutputTo4BPP
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_4BPP destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination plane.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:

`

@BEG_PROC   VarCountOutputTo4BPP    <pPrimColorCount:DWORD, \
                                     pDest:DWORD,           \
                                     pPattern:DWORD,        \
                                     OutFuncInfo:QWORD>

;==========================================
; Register Usage:
;
; _SI           : pPrimColorCount
; _DI           : pDest
; _BP           : Current pPattern, self wrappable
; cx            : PrimColorCount.Count
; bl:bh:al:ah   : Prim 1/2/3/4         =====> Bit 2:1:0
; dl            : DestByte
; dh            : Scratch Register
;==========================================


        @ENTER_PAT_TO_STK   <4BPP>          ; _BP=Pat location

;=============================================================================
; the DH has two uses, it contains the mask bits (1 bit=Mask), and it also
; contains an extra bit to do a byte boundary test, every time we shift the
; mask left by one, the boundary bit get shift to left, when first time a
; carry is produced then we know we finished one byte. at here we set up the
; dh=FirstMask + Aligned boundary bit
;=============================================================================

        xor     _DX, _DX                            ; clear mask/dest
        mov     cx, WPTR [_SI]
        or      cx, cx
        jnz     short InvDensityHStart              ; has first skip

LoadByteH:
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     cx, WPTR [_SI]                      ; cx=count
        mov     bx, WPTR [_SI+2]                    ; bl:bh=Prim 1/2
        cmp     bl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short InvDensityH
        mov     ax, WPTR [_SI+4]                    ; al:ah=Prim 3/4
        inc     cx

LoadByteH1:
        dec     cx
        jz      short LoadByteH

MakeByteH:
        dec     _BP
        mov     dh, BPTR [_BP]
        cmp     bl, dh
        adc     dl, dl
        cmp     bh, dh
        adc     dl, dl
        cmp     al, dh
        adc     dl, dl

        dec     cx                                  ;
        jz      short LoadByteL

MakeByteL:
        add     dl, dl                              ; skip high bit
        dec     _BP
        mov     dh, BPTR [_BP]
        cmp     bl, dh
        adc     dl, dl
        cmp     bh, dh
        adc     dl, dl
        cmp     al, dh
        adc     dl, dl

        SAVE_4BPP_DEST

ReadyNextByte:
        inc     _DI
        xor     _DX, _DX

        WRAP_BP_PAT?? <LoadByteH1>


;=============================================================================
; The high nibble need to be skipped, (byte boundary now), if bl=bh=INVALID
; then we are done else set the mask=0xf0 (high nibble) and if count > 1 then
; continune load LOW nibble
;=============================================================================

LoadByteL:
        add     _SI, SIZE_PCC                   ; sizeof(PRIMCOLOR_COUNT)
        mov     cx, WPTR [_SI]                  ; cx=count
        mov     bx, WPTR [_SI+2]                ; bl:bh=Prim 1/2
        mov     ax, WPTR [_SI+4]                ; al:ah=Prim 3/4
        cmp     bl, PRIM_INVALID_DENSITY        ; invalid?
        jnz     short MakeByteL

        SAVE_4BPP_DEST_HIGH                     ; save only high nibble

        jmp     short DoneDestMask

InvDensityH:
        cmp     bl, bh                          ; end?
        jz      short AllDone                   ; exactly byte boundary

InvDensityHStart:
        dec     _BP                             ; update pCurPat
        dec     cx
        jnz     short DoneDestMask

LoadByteL2:
        add     _SI, SIZE_PCC                   ; sizeof(PRIMCOLOR_COUNT)
        mov     cx, WPTR [_SI]                  ; cx=count
        mov     bx, WPTR [_SI+2]                ; bl:bh=Prim 1/2
        cmp     bl, PRIM_INVALID_DENSITY        ; invalid?
        jz      short DoneDestMask
        mov     ax, WPTR [_SI+4]                ; al:ah=Prim 3/4

MakeByteL2:
        add     dl, dl                          ; skip high bit
        mov     dh, BPTR [_BP-1]                ; load next pattern
        cmp     bl, dh
        adc     dl, dl
        cmp     bh, dh
        adc     dl, dl
        cmp     al, dh
        adc     dl, dl

        SAVE_4BPP_DEST_LOW                      ; fall through

DoneDestMask:
        dec     _BP
        cmp     bl, PRIM_INVALID_DENSITY        ; is last one a skip stretch?
        jnz     short ReadyNextByte
        cmp     bl, bh                          ; end?
        jz      short AllDone
        cmp     cx, 1
        jbe     short ReadyNextByte

;============================================================================
; skip the 'cx-1' count of pels on the destination (SI is post decrement so
; we must only skip 'cx-1' count), it will skip the 'pDest', set up next
; pDest mask, also it will aligned the destination pattern pointer (_BP)
;===========================================================================

SkipDestPels:
        inc     _DI                             ; update to current pDest
        xor     _DX, _DX                        ;

        dec     cx
        WZXE    cx                              ; zero extended
        mov     _AX, _CX
        shr     _CX, 1                          ; see if carry
        sbb     dh, dh                          ; -1=skip high nibble
        add     _DI, _CX                        ; 2 pels per byte
        mov     _CX, _BP                        ; align pattern now
        and     _CX, HTPAT_STK_MASK             ; how many pat avai.?
        xor     _BP, _CX                        ; clear _BP mask=pPattern
        sub     _CX, _AX                        ; see if > 0? (_AX=Count)
        jg      short DoneSkipDestPels          ; still not used up yet!
        mov     _AX, [_BP - HTPAT_BP_SIZE]      ; get pattern size
SkipDestPelsLoop:
        add     _CX, _AX
        jle     short SkipDestPelsLoop          ; do until > 0
DoneSkipDestPels:
        add     _BP, _CX                        ; _BP=pCurPat
        or      dh, dh
        jnz     short LoadByteL2
        jmp     LoadByteH

AllDone:
        @EXIT_PAT_STK_RESTORE


@END_PROC




SUBTTL  SingleCountOutputToVGA16
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_VGA16 destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination planes pointers.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:


`

@BEG_PROC   SingleCountOutputToVGA16    <pPrimColorCount:DWORD, \
                                         pDest:DWORD,           \
                                         pPattern:DWORD,        \
                                         OutFuncInfo:QWORD>

;
; VGA 16 Standard table
;
;   0,   0,   0,    0000    0   Black
;   0,  ,0,   0x80  0001    1   Dark Red
;   0,   0x80,0,    0010    2   Dark Green
;   0,  ,0x80,0x80  0011    3   Dark Yellow
;   0x80 0,   0,    0100    4   Dark Blue
;   0x80,0,   0x80  0101    5   Dark Magenta
;   0x80 0x80,0,    0110    6   Dark Cyan
;   0x80,0x80,0x80  0111    7   Gray 50%
;
;   0xC0,0xC0,0xC0  1000    8   Gray 75%
;   0,  ,0,   0xFF  1001    9   Red
;   0,   0xFF,0,    1010    10  Green
;   0,  ,0xFF,0xFF  1011    11  Yellow
;   0xFF 0,   0,    1100    12  Blue
;   0xFF,0,   0xFF  1101    13  Magenta
;   0xFF 0xFF,0,    1110    14  Cyan
;   0xFF,0xFF,0xFF  1111    15  White
;
;==========================================
; Register Usage:
;
; _SI               : pPrimColorCount
; _DI               : pDest
; _BP               : Current pPattern, self wrappable
; bl:bh:dl:dh       : Prim 1/2/5/6  Prim6 is Index for VGA16ColorIndex[]
; cl                : PRIM_INVALID_DENSITY
; ch                : ZERO (0)
; al                : Pattern/Low Nibble
; ah                : High nibble
;
; Prim1 = Initial VGA16ColorIndex[]
; Prim2 = Color Thresholds for VGA16ColorIndex[Prim1]
; Prim3 = Color Thresholds for VGA16ColorIndex[Prim1-1]
; Prim4 = Color Thresholds for VGA16ColorIndex[Prim1-2]
; Prim5 = Color Thresholds for VGA16ColorIndex[Prim1-3]
; Prim6 = Color Thresholds for VGA16ColorIndex[Prim1-4]
; ELSE                         VGA16ColorIndex[Prim1-5]
;=========================================================================
;


        @ENTER_PAT_TO_STK   <VGA16>                 ; _BP=Pat location

;=============================================================================
; the DH has two uses, it contains the mask bits (1 bit=Mask), and it also
; contains an extra bit to do a byte boundary test, every time we shift the
; mask left by one, the boundary bit get shift to left, when first time a
; carry is produced then we know we finished one byte. at here we set up the
; dh=FirstMask + Aligned boundary bit
;=============================================================================

        xor     _BX, _BX                        ; clear high word
        sub     _SI, SIZE_PCC
        cmp     WPTR [_SI + SIZE_PCC], bx       ; check if begin with skip
        mov     cl, PRIM_INVALID_DENSITY
        jz      SHORT DoHNibble
        add     _SI, SIZE_PCC
        jmp     SHORT SkipPelsH_2               ; skip from the first pel

AllDone:
        @EXIT_PAT_STK_RESTORE


SkipPelsH:
        add     _SI, (SIZE_PCC * 2)
        mov     bx, WPTR [_SI+2]
        cmp     bl, PRIM_INVALID_DENSITY
        jnz     SHORT LoadHNibble

SkipPelsH_1:
        cmp     bl, bh
        jz      SHORT AllDone

SkipPelsH_2:
        sub     _BP, 2

SkipPelsL:
        mov     bx, WPTR [_SI+SIZE_PCC+2]
        cmp     bl, PRIM_INVALID_DENSITY
        jz      SHORT SkipPelsL_1

        mov     ah, BPTR_ES[_DI]                ; start from Low nibble so
        mov     cl, BPTR [_BP]                  ; get pattern
        jmp     SHORT LoadLNibble               ; we must load current dest

SaveLNibbleAndSkip:
        and     BPTR_ES[_DI], 0fh               ; clear high nibble
        and     ah, 0f0h                        ; clear low nibble
        or      BPTR_ES[_DI], ah                ; save it in

SkipPelsL_1:
        cmp     bl, bh
        jz      SHORT AllDone
        inc     _DI                             ; skip the destination

        WRAP_BP_PAT?? <SkipPelsH>               ; repeat until no more skips



DoHNibble:
        add     _SI, (SIZE_PCC * 2)
        mov     bx, WPTR [_SI+2]                ; bl:bh=Prim 1/2
        cmp     bl, PRIM_INVALID_DENSITY
        jz      SHORT SkipPelsH_1

LoadHNibble:
        sub     _BP, 2
        mov     cx, WPTR [_BP]

;
;===================================================================
        ;  2    4     6
        ; +-+ +--+  +--+
        ;  1  2  3  4  5
        ; bh:cl:ch:dl:dh
        ;--------------------------

IFE ExtRegSet
        mov     dx, WPTR [_SI+4]                ; Color 2/3
        cmp     dh, ch                          ; first split in the middle
        jae     SHORT GetH1                     ; [ie. binary search/compare]
        mov     dx, WPTR [_SI+6]                ; now check if Prim4/5
ELSE
        mov     _DX, DPTR [_SI+4]
        cmp     dh, ch                          ; first split in the middle
        jae     SHORT GetH1                     ; [ie. binary search/compare]
        shr     _DX, 16
ENDIF

        cmp     dl, ch
        sbb     bl, 3                           ; one of  -3/-4/-5
        cmp     dh, ch
        jmp     SHORT GetH2

GetH1:  cmp     bh, ch                          ; it is white
        jae     SHORT GetHNibble
        dec     bl
        cmp     dl, ch

GetH2:  sbb     bl, 0

;
;===================================================================
;

GetHNibble:
        xor     bh, bh
        mov     ah, BPTR cs:VGA16ColorIndex[_BX]


DoLNibble:
        mov     bx, WPTR [_SI+SIZE_PCC+2]       ; bl:bh=Prim 1/2
        cmp     bl, PRIM_INVALID_DENSITY
        jz      SHORT SaveLNibbleAndSkip

LoadLNibble:

;
;===================================================================
        ;  2    4     6
        ; +-+ +--+  +--+
        ;  1  2  3  4  5
        ; bh:cl:ch:dl:dh
        ;--------------------------

IFE ExtRegSet
        mov     dx, WPTR [_SI+SIZE+PCC+4]       ; Color 2/3
        cmp     dh, cl                          ; first split in the middle
        jae     SHORT GetL1                     ; [ie. binary search/compare]
        mov     dx, WPTR [_SI+SIZE+PCC+6]       ; now check if Prim4/5
ELSE
        mov     _DX, DPTR [_SI+SIZE_PCC+4]
        cmp     dh, cl                          ; first split in the middle
        jae     SHORT GetL1                     ; [ie. binary search/compare]
        shr     _DX, 16
ENDIF

        cmp     dl, cl
        sbb     bl, 3                           ; one of  -3/-4/-5
        cmp     dh, cl
        jmp     SHORT GetL2

GetL1:  cmp     bh, cl                          ; it is white
        jae     SHORT GetLNibble
        dec     bl
        cmp     dl, cl

GetL2:  sbb     bl, 0

;
;===================================================================
;

GetLNibble:

        xor     bh, bh
        mov     al, BPTR cs:VGA16ColorIndex[_BX]
        and     ax, 0f00fh
        or      al, ah
        stosb

        WRAP_BP_PAT??   <DoHNibble>



@END_PROC





SUBTTL  VarCountOutputToVGA16
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_4BPP destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination plane.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:

`

@BEG_PROC   VarCountOutputToVGA16   <pPrimColorCount:DWORD, \
                                     pDest:DWORD,           \
                                     pPattern:DWORD,        \
                                     OutFuncInfo:QWORD>


;
; VGA 16 Standard table
;
;   0,   0,   0,    0000    0   Black
;   0,  ,0,   0x80  0001    1   Dark Red
;   0,   0x80,0,    0010    2   Dark Green
;   0,  ,0x80,0x80  0011    3   Dark Yellow
;   0x80 0,   0,    0100    4   Dark Blue
;   0x80,0,   0x80  0101    5   Dark Magenta
;   0x80 0x80,0,    0110    6   Dark Cyan
;   0x80,0x80,0x80  0111    7   Gray 50%
;
;   0xC0,0xC0,0xC0  1000    8   Gray 75%
;   0,  ,0,   0xFF  1001    9   Red
;   0,   0xFF,0,    1010    10  Green
;   0,  ,0xFF,0xFF  1011    11  Yellow
;   0xFF 0,   0,    1100    12  Blue
;   0xFF,0,   0xFF  1101    13  Magenta
;   0xFF 0xFF,0,    1110    14  Cyan
;   0xFF,0xFF,0xFF  1111    15  White
;
;==========================================
; Register Usage:
;
; _SI               : pPrimColorCount
; _DI               : pDest
; _BP               : Current pPattern, self wrappable
; ax                : PrimColorCount.Count
; bl:bh:cl:ch:dl:dh : Prim 1/2/3/4/5/6
;==========================================
; Prim1 = Initial VGA16ColorIndex[]
; Prim2 = Color Thresholds for VGA16ColorIndex[Prim1]
; Prim3 = Color Thresholds for VGA16ColorIndex[Prim1-1]
; Prim4 = Color Thresholds for VGA16ColorIndex[Prim1-2]
; Prim5 = Color Thresholds for VGA16ColorIndex[Prim1-3]
; Prim6 = Color Thresholds for VGA16ColorIndex[Prim1-4]
; ELSE                         VGA16ColorIndex[Prim1-5]
;=========================================================================
;


        @ENTER_PAT_TO_STK   <VGA16>             ; _BP=Pat location

;=============================================================================
; the DH has two uses, it contains the mask bits (1 bit=Mask), and it also
; contains an extra bit to do a byte boundary test, every time we shift the
; mask left by one, the boundary bit get shift to left, when first time a
; carry is produced then we know we finished one byte. at here we set up the
; dh=FirstMask + Aligned boundary bit
;=============================================================================

        xor     _BX, _BX
        cmp     WPTR [_SI], 0
        jnz     SHORT SkipPelsH_2

        JMP     LoadPrimH                       ; start the process

SkipPelsContinue:
        or      dh, dh
        jz      SHORT SkipPelsH

SkipPelsL:
        cmp     bl, bh
        jz      SHORT AllDone

        xor     dh, dh                          ; clear indicator

        dec     _BP
        WRAP_BP_PAT??

        inc     _DI
        MOVZX_W _BX, <WPTR [_SI]>               ; get skip count
        dec     _BX                             ; only one
        jz      SHORT TrySkipNext
        jmp     SHORT SkipBXPels

AllDone:
        @EXIT_PAT_STK_RESTORE

SkipPelsH:
        cmp     bl, bh                          ; end?
        jz      SHORT AllDone

SkipPelsH_2:
        MOVZX_W _BX, <WPTR [_SI]>               ; get skip count

SkipBXPels:
        mov     _CX, _BX
        shr     _CX, 1                          ; see if carry
        sbb     dh, dh                          ; -1=skip high nibble
        add     _DI, _CX                        ; 2 pels per byte
        mov     _CX, _BP                        ; align pattern now
        and     _CX, HTPAT_STK_MASK             ; how many pat avai.?
        xor     _BP, _CX                        ; clear _BP mask=pPattern
        sub     _CX, _BX                        ; see if > 0? (_BX=Count)
        jg      short DoneSkipDestPels          ; still not used up yet!
        mov     _BX, [_BP - HTPAT_BP_SIZE]      ; get pattern size
SkipDestPelsLoop:
        add     _CX, _BX
        jle     short SkipDestPelsLoop          ; do until > 0
DoneSkipDestPels:
        add     _BP, _CX                        ; _BP=pCurPat

TrySkipNext:
        add     _SI, SIZE_PCC
        mov     bx, WPTR [_SI+2]
        cmp     bl, PRIM_INVALID_DENSITY        ; still invalid ?
        jz      SHORT SkipPelsContinue

        or      dh, dh                          ; skip high nibble?
        jz      SHORT LoadPrimHStart            ; no

        mov     cx, WPTR [_SI+4]                ; cl:ch=Prim 3/4
        mov     dx, WPTR [_SI+6]                ; dl:dh=Prim 5/6
        push    _SI
        mov     si, WPTR [_SI]                  ; si=count
        and     BPTR_ES[_DI], 0f0h              ; clear low nibble first!!!
        jmp     SHORT DoLNibble


PopSI_LoadPrimH:
        pop     _SI

LoadPrimH:
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     bx, WPTR [_SI+2]                    ; bl:bh=Prim 1/2
        cmp     bl, PRIM_INVALID_DENSITY            ; invalid?
        jz      SHORT SkipPelsH

LoadPrimHStart:
        mov     cx, WPTR [_SI+4]                    ; dl:dh=Prim 3/4
        mov     dx, WPTR [_SI+6]                    ; al:ah=Prim 5/6

        push    _SI
        mov     si, WPTR [_SI]                      ; si=count
        inc     si

DoHNibble:
        dec     si
        jz      SHORT PopSI_LoadPrimH

        dec     _BP
        mov     ah, BPTR [_BP]
        mov     al, bl                              ; initial condition

        ;
        ;  1  2  3  4  5
        ; bh:cl:ch:dl:dh
        ;----------------------

        cmp     ch, ah
        jae     SHORT GetH1
        cmp     dl, ah
        sbb     al, 3
        cmp     dh, ah
        jmp     SHORT GetH2

GetH1:  cmp     bh, ah
        jae     SHORT GetHNibble
        dec     al
        cmp     cl, ah

GetH2:  sbb     al, 0

GetHNibble:
        BZXEAX  al
        mov     al, BPTR cs:VGA16ColorIndex[_AX]
        and     al, 0f0h

        dec     si
        jz      SHORT PopSI_LoadPrimL

SaveHNibbleL0:
        mov     BPTR_ES[_DI], al                    ; save high nibble

DoLNibble:
        dec     _BP
        mov     ah, BPTR [_BP]
        mov     al, bl                              ; initial condition

        ;
        ;  1  2  3  4  5
        ; bh:cl:ch:dl:dh
        ;----------------------

        cmp     ch, ah
        jae     SHORT GetL1
        cmp     dl, ah
        sbb     al, 3
        cmp     dh, ah
        jmp     SHORT GetL2

GetL1:  cmp     bh, ah
        jae     SHORT GetLNibble
        dec     al
        cmp     cl, ah

GetL2:  sbb     al, 0

GetLNibble:
        BZXEAX  al
        mov     al, BPTR cs:VGA16ColorIndex[_AX]
        and     al, 0fh
        or      BPTR_ES[_DI], al                    ; or in the low nibble
        inc     _DI

        WRAP_BP_PAT??   <DoHNibble>

PopSI_LoadPrimL:
        pop     _SI
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     bx, WPTR [_SI+2]                    ; bl:bh=Prim 1/2
        cmp     bl, PRIM_INVALID_DENSITY
        jz      SHORT SaveAH_SkipPelsL

        mov     cx, WPTR [_SI+4]                    ; dl:dh=Prim 3/4
        mov     dx, WPTR [_SI+6]                    ; al:ah=Prim 5/6
        push    _SI
        mov     si, WPTR [_SI]                      ; si=count
        jmp     SHORT SaveHNibbleL0

SaveAH_SkipPelsL:                                   ; need to save current AL
        and     BPTR_ES[_DI], 0fh                   ; clear high nibble
        or      BPTR_ES[_DI], al                    ; move high nibble in
        jmp     SkipPelsL


@END_PROC




SUBTTL  SingleCountOutputToVGA256
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_VGA256 destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination planes pointers.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:

    01-Jun-1992 Mon 15:32:00 updated  -by-  Daniel Chou (danielc)
        1. Fixed so that Prims match the device's BGR color table format rather
           than RGB format


`

@BEG_PROC   SingleCountOutputToVGA256   <pPrimColorCount:DWORD, \
                                         pDest:DWORD,           \
                                         pPattern:DWORD,        \
                                         OutFuncInfo:QWORD>


;==========================================
; Register Usage:
;
; _SI           : pPrimColorCount
; _DI           : pDest
; _BP           : Current pPattern, self wrappable
; cl:ch:dl:dh   : Prim 1/2/3/4 ====> R/G/B/IDX
; _BX           : Scratch register
; _AX           : Scratch register
;==========================================
;
        @ENTER_PAT_TO_STK   <VGA256>                ; _BP=Pat location

;============================================================================
; Since we are in byte boundary, we should never have an invalid density to
; start with
;
; The VGA256's color table is constructed as BGR and 6 steps for each primary
; color.
;
;   The BGR Mask = 0x24:0x06:0x01
;============================================================================

        cld                                         ; clear direction
        or      _AX, _AX
        jz      SHORT V256_NoXlate

V256_HasXlate:

IFE ExtRegSet
        mov     _BX, _SP                            ; the table on the stack
ELSE
        mov     _BX, _AX                            ; _AX point to xlate table
ENDIF

V256_XlateByteLoop:
        dec     _BP                                 ; do this one first

        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     cx, WPTR [_SI+2]                    ; bl:bh=Prim 1/2 B/G
        cmp     cl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short V256_XlateInvDensity

        mov     dh, BPTR [_BP]                      ; al=pattern
        dec     dh                                  ; make it cmp al, cl work

        cmp     dh, cl
        sbb     ah, ah                              ; al=0xff or 0
        cmp     dh, ch
        sbb     al, al
        and     ax, ((VGA256_B_CUBE_INC shl 8) or VGA256_G_CUBE_INC)                              ; dh:dl=36:6

        mov     cx, WPTR [_SI+4]                    ; cl:ch=Prim 3/4 R/I

        cmp     dh, cl
        adc     al, ah
        add     al, ch

        ;
        ; for extended register set _BX point to the translation table
        ; otherwise ss:bx point to the translation table
        ;

IFE ExtRegSet
        xlat    _SS:VGA256_SSSP_XLAT_TABLE
ELSE
        xlatb
ENDIF
        stosb

        WRAP_BP_PAT?? <V256_XlateByteLoop>

V256_XlateInvDensity:
        cmp     cl, ch
        jz      short V256_XlateAllDone

        inc     _DI
        WRAP_BP_PAT?? <V256_XlateByteLoop>

V256_XlateAllDone:

IFE ExtRegSet
        add     _SP, VGA256_XLATE_TABLE_SIZE
ENDIF

;===================================================================

AllDone:
        @EXIT_PAT_STK_RESTORE

;===================================================================


V256_NoXlate:

        mov     bx, ((VGA256_B_CUBE_INC shl 8) or VGA256_G_CUBE_INC)

V256_ByteLoop:
        dec     _BP                                 ; do this one first

        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     cx, WPTR [_SI+2]                    ; cl:ch=Prim 1/2 B/G
        cmp     cl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short V256_InvDensity

        mov     dh, BPTR [_BP]                      ; dh=pattern
        dec     dh                                  ; make it cmp dh, T work

        cmp     dh, cl
        sbb     ah, ah                              ; ah=0xff or 0
        cmp     dh, ch
        sbb     al, al                              ; al=0xff or 0x00
        and     ax, bx                              ; bh:bl=36:6

        mov     cx, WPTR [_SI+4]                    ; cl:ch=Prim 3/4 R/I

        cmp     dh, cl
        adc     al, ah
        add     al, ch
        stosb

        WRAP_BP_PAT?? <V256_ByteLoop>

V256_InvDensity:
        cmp     cl, ch
        jz      short AllDone

        inc     _DI
        WRAP_BP_PAT?? <V256_ByteLoop>


@END_PROC




SUBTTL  VarCountOutputToVGA256
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_4BPP destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination plane.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:

    01-Jun-1992 Mon 15:32:00 updated  -by-  Daniel Chou (danielc)
        1. Fixed so that Prims match the device's BGR color table format rather
           than RGB format

    19-Mar-1993 Fri 18:53:56 updated  -by-  Daniel Chou (danielc)
        1. When we push _SI and jmp to VGA256_InvDensity we fogot to that
           si now is run as count rather than _CX

`

@BEG_PROC   VarCountOutputToVGA256  <pPrimColorCount:DWORD, \
                                     pDest:DWORD,           \
                                     pPattern:DWORD,        \
                                     OutFuncInfo:QWORD>


;==========================================
; Register Usage:
;
; _SI           : pPrimColorCount
; _DI           : pDest
; _BP           : Current pPattern, self wrappable
; cx            : PrimColorCount.Count
; bl:bh:dl:dh   : Prim 1/2/3/4 ====> R/G/B/IDX
; al            : DestByte
; ah            : Scratch Register
;==========================================
;

        @ENTER_PAT_TO_STK   <VGA256>                ; _BP=Pat location

;============================================================================
; Since we are in byte boundary, we should never have an invalid density to
; start with
;
; The VGA256's color table is constructed as BGR and 6 steps for each primary
; color.
;============================================================================

        cld                                         ; clear direction

IFE ExtRegSet
        mov     _BX, _SP                            ; the table on the stack
ELSE
        mov     _BX, _AX                            ; _AX point to xlate table
ENDIF
        or      _AX, _AX
        jnz     SHORT V256_XlateStart
        jmp     V256_NoXlate


        ;======== THIS PORTION is for xlate table

V256_XlateByteLoop:
        pop     _SI                                 ; restore SI

V256_XlateStart:
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        push    _SI                                 ; save again

        mov     cx, WPTR [_SI+2]                    ; cl:ch=Prim 1/2  B/G
        cmp     cl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short V256_XlateInvDensity

        mov     dx, WPTR [_SI+4]                    ; dl:dh=Prim 3/4  R/I
        mov     si, WPTR [_SI]                      ; count
        inc     si

V256_XlateCountLoop:

        dec     si
        jz      short V256_XlateByteLoop

        dec     _BP
        mov     ah, BPTR [_BP]                      ; ah=Pattern
        dec     ah                                  ; make cmp ah, bl works

        cmp     ah, cl
        sbb     al, al
        and     al, VGA256_B_CUBE_INC               ; AL=0 or 36  Prim1

        cmp     ah, dl                              ; Do Prim 3 first
        adc     al, dh                              ; al=InitValue+Prim1+Prim3

        cmp     ah, ch                              ; do Prim 2 now
        sbb     ah, ah
        and     ah, VGA256_G_CUBE_INC
        add     al, ah

        ;
        ; for extended register set _BX point to the translation table
        ; otherwise ss:bx point to the translation table
        ;

IFE ExtRegSet
        xlat    _SS:VGA256_SSSP_XLAT_TABLE
ELSE
        xlatb
ENDIF

        stosb

V256_XlateReadyNextByte:

        WRAP_BP_PAT?? <V256_XlateCountLoop>


V256_XlateInvDensity:
        cmp     cl, ch                          ; all done?
        jz      SHORT V256_XlateAllDone
        dec     _BP
        inc     _DI

        MOVZX_W _CX, <WPTR [_SI]>
        mov     _SI, _CX                        ; we expect count in si
        cmp     _CX, 1
        jbe     short V256_XlateReadyNextByte

        ;=========

        dec     _CX
        mov     _AX, _CX
        add     _DI, _CX                        ; 1 pel per byte
        mov     _CX, _BP                        ; align pattern now
        and     _CX, HTPAT_STK_MASK             ; how many pat avai.?
        xor     _BP, _CX                        ; clear _BP mask=pPattern
        sub     _CX, _AX                        ; see if > 0? (_AX=Count)
        jg      short V256_XlateDoneSkipPels    ; still not used up yet!
        mov     _AX, [_BP - HTPAT_BP_SIZE]      ; get pattern size
V256_XlateSkipLoop:
        add     _CX, _AX
        jle     short V256_XlateSkipLoop        ; do until > 0
V256_XlateDoneSkipPels:
        add     _BP, _CX                        ; _BP=pCurPat
        jmp     V256_XlateByteLoop              ; repeat the process

V256_XlateAllDone:
        pop     _SI                             ; restore last _SI

IFE ExtRegSet
        add     _SP, VGA256_XLATE_TABLE_SIZE
ENDIF

;======================================================================

AllDone:
        @EXIT_PAT_STK_RESTORE

;======================================================================


V256_NoXlate:

V256_ByteLoop:
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     cx, WPTR [_SI]                      ; cx=count
        mov     bx, WPTR [_SI+2]                    ; bl:bh=Prim 1/2  B/G
        cmp     bl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short V256_InvDensity

        mov     dx, WPTR [_SI+4]                    ; dl:dh=Prim 3/4  R/I

        inc     cx

V256_CountLoop:

        dec     cx
        jz      short V256_ByteLoop

        dec     _BP
        mov     ah, BPTR [_BP]                      ; ah=Pattern
        dec     ah                                  ; make cmp ah, bl works

        cmp     ah, bl
        sbb     al, al
        and     al, VGA256_B_CUBE_INC               ; AL=0 or 36  Prim1

        cmp     ah, dl                              ; Do Prim 3 first
        adc     al, dh                              ; al=InitValue+Prim1+Prim3

        cmp     ah, bh                              ; do Prim 2 now
        sbb     ah, ah
        and     ah, VGA256_G_CUBE_INC
        add     al, ah
        stosb

ReadyNextByte:

        WRAP_BP_PAT?? <V256_CountLoop>


V256_InvDensity:
        cmp     bl, bh                          ; all done?
        jz      short AllDone
        dec     _BP
        inc     _DI
        cmp     cx, 1
        jbe     short ReadyNextByte

SkipDestPels:
        dec     cx
        WZXE    cx                              ; zero extended
        mov     _AX, _CX
        add     _DI, _CX                        ; 1 pel per byte
        mov     _CX, _BP                        ; align pattern now
        and     _CX, HTPAT_STK_MASK             ; how many pat avai.?
        xor     _BP, _CX                        ; clear _BP mask=pPattern
        sub     _CX, _AX                        ; see if > 0? (_AX=Count)
        jg      short DoneSkipDestPels          ; still not used up yet!
        mov     _AX, [_BP - HTPAT_BP_SIZE]      ; get pattern size
SkipDestPelsLoop:
        add     _CX, _AX
        jle     short SkipDestPelsLoop          ; do until > 0
DoneSkipDestPels:
        add     _BP, _CX                        ; _BP=pCurPat
        jmp     V256_ByteLoop                   ; repeat the process



@END_PROC



SUBTTL  SingleCountOutputTo16BPP_555
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_16BPP_555 destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination planes pointers.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:

    01-Jun-1992 Mon 15:32:00 updated  -by-  Daniel Chou (danielc)
        1. Fixed so that Prims match the device's BGR color table format rather
           than RGB format


`

@BEG_PROC   SingleCountOutputTo16BPP_555    <pPrimColorCount:DWORD, \
                                             pDest:DWORD,           \
                                             pPattern:DWORD,        \
                                             OutFuncInfo:QWORD>


;==========================================
; Register Usage:
;
; _SI           : pPrimColorCount
; _DI           : pDest
; _BP           : Current pPattern, self wrappable
; ax            : Initial RGB color range from 0-32k (15 bits as 5:5:5)
; dh            : pattern
; bl:bh:dl      : Prim1/2/3
; ch            : PRIM_INVALID_DENSITY
; cl            : PRIM_INVALID_DENSITY --> CX = PRIMCOUNT_EOF
;--------------------------------------------------------------------
;

        @ENTER_PAT_TO_STK   <16BPP>                ; _BP=Pat location

;============================================================================
; Since we are in WORD boundary, we should never have an invalid density to
; start with
;
; The 16BPP_555's color table is constructed as 32 steps for each primary color
;============================================================================

        cld                                         ; clear direction
        mov     cx, (RGB555_R_CUBE_INC or RGB555_G_CUBE_INC)

WordLoop:
        dec     _BP                                 ; do this one first

        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     bx, WPTR [_SI+2]                    ; bl:bh=Prim 1/2
        cmp     bl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short InvalidDensity

        mov     dh, BPTR [_BP]                      ; dh=pattern
        dec     dh                                  ; make 'cmp dh, bl' works

        cmp     dh, bl
        sbb     ah, ah                              ; ah=0x00 or 0x04
        cmp     dh, bh
        sbb     al, al                              ; al=0x00 or 0x20 ax=0x420
        and     ax, cx                              ; mask with cx= 0x0420

        cmp     dh, BPTR [_SI+4]
        adc     ax, WPTR [_SI+6]                    ; ax+carry+initial index

        stosw

        WRAP_BP_PAT?? <WordLoop>

InvalidDensity:
        cmp     bl, bh
        jz      short AllDone

        inc     _DI
        WRAP_BP_PAT?? <WordLoop>

AllDone:
        @EXIT_PAT_STK_RESTORE


@END_PROC




SUBTTL  VarCountOutputTo16BPP_555
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_4BPP destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination plane.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:

    01-Jun-1992 Mon 15:32:00 updated  -by-  Daniel Chou (danielc)
        1. Fixed so that Prims match the device's BGR color table format rather
           than RGB format


`

@BEG_PROC   VarCountOutputTo16BPP_555   <pPrimColorCount:DWORD, \
                                         pDest:DWORD,           \
                                         pPattern:DWORD,        \
                                         OutFuncInfo:QWORD>


;==========================================
; Register Usage:
;
; _SI           : pPrimColorCount, si=Temp Init Index
; _DI           : pDest
; _BP           : Current pPattern, self wrappable
; ax            : Initial RGB color range from 0-32k (15 bits as 5:5:5)
; dh            : pattern
; bl:bh:dl      : Prim1/2/3
; cx            : PrimColorCount.Count
;==========================================
;

        @ENTER_PAT_TO_STK   <16BPP>                 ; _BP=Pat location

;============================================================================
; Since we are in byte boundary, we should never have an invalid density to
; start with
;
; The 16BPP_555's color table is constructed as BGR and 6 steps for each
; primary color.
;============================================================================

        cld                                         ; clear direction
        jmp     short InitStart

WordLoop:
        pop     _SI                                 ; restore _SI
InitStart:
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        push    _SI                                 ; save _SI

        mov     cx, WPTR [_SI]                      ; cx=count
        mov     bx, WPTR [_SI+2]                    ; bx=Prim 1/2/3

        cmp     bl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short InvalidDensity

        mov     dx, WPTR [_SI+4]                    ; dl:dh=Prim 3/4
        mov     si, WPTR [_SI+6]                    ; si=initial index

        inc     cx                                  ; pre-enter

CountLoop:
        dec     cx
        jz      SHORT WordLoop

        dec     _BP
        mov     dh, BPTR [_BP]                      ; bl=pattern
        dec     dh                                  ; make cmp bl, dh works

        cmp     dh, bl
        sbb     ah, ah                              ; ah=0/0x40
        cmp     dh, bh
        sbb     al, al
        and     ax, (RGB555_R_CUBE_INC or RGB555_G_CUBE_INC)    ; mask=0x420
        cmp     dh, dl
        adc     ax, si                              ; carry+ax+initial index

        stosw

ReadyNextByte:

        WRAP_BP_PAT?? <CountLoop>

InvalidDensity:
        cmp     bl, bh                          ; all done?
        jz      short AllDone
        dec     _BP
        add     _DI, 2                          ; 16-bit per pel
        cmp     cx, 1
        jbe     SHORT ReadyNextByte

SkipDestPels:
        dec     cx
        WZXE    cx                              ; zero extended
        mov     _AX, _CX
        add     _DI, _CX                        ; 16-bit per pel
        add     _DI, _CX                        ;
        mov     _CX, _BP                        ; align pattern now
        and     _CX, HTPAT_STK_MASK             ; how many pat avai.?
        xor     _BP, _CX                        ; clear _BP mask=pPattern
        sub     _CX, _AX                        ; see if > 0? (_AX=Count)
        jg      short DoneSkipDestPels          ; still not used up yet!
        mov     _AX, [_BP - HTPAT_BP_SIZE]      ; get pattern size
SkipDestPelsLoop:
        add     _CX, _AX
        jle     short SkipDestPelsLoop          ; do until > 0
DoneSkipDestPels:
        add     _BP, _CX                        ; _BP=pCurPat
        jmp     WordLoop                        ; repeat the process,

AllDone:
        pop     _SI                             ; restore _SI
        @EXIT_PAT_STK_RESTORE


@END_PROC



ENDIF       ; HT_ASM_80x86

ENDIF       ; 0



END





VOID
HTENTRY
VarCountOutputToVGA256(
    PPRIMCOLOR_COUNT    pPrimColorCount,
    LPBYTE              pDest,
    LPBYTE              pPattern,
    OUTFUNCINFO         OutFuncInfo
    )

/*++

Routine Description:

    This function output to the BMF_4BPP destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    ppDest          - Pointer to the destination planes pointers.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:


--*/


{
    LPBYTE          pCurPatA;
    LPBYTE          pEndPatA;
    LPBYTE          pCurPatB;
    LPBYTE          pCurPatC;
    LPBYTE          pXlate;
    PRIMCOLOR_COUNT PCC;
    LPBYTE          pCur555Pat;
    LPBYTE          pEnd555Pat;
    BYTE            bTmp;
    WORD            Idx;
    PRIMCOLOR_COUNT PCCX;


    //
    // Since we are in byte boundary, we should never get the first one is
    // invalid
    //

    if (!(pXlate = (LPBYTE)OutFuncInfo.pXlate8BPP)) {

        pXlate = (LPBYTE)DefHTXlate8BPP;
    }

    SET_555PAT;

    if (pPattern) {

        LPBYTE  pRotPatA;
        BYTE    bPat;


        SET_ROTPAT;

        while (TRUE) {

            PCC = *(++pPrimColorCount);

            if (PCC.Count >= PRIM_COUNT_SPECIAL) {

                if (PCC.Count == PRIM_COUNT_END_SCAN) {

                    return;     // EOF
                }

                pDest += PCC.cSkip;         // advance destination

                SKIP_ROTPAT(PCC.cSkip);
                SKIP_555PAT(PCC.cSkip);

            } else {

                GET_555_COLOR_IDXPCC(PCCX);

                while (PCC.Count--) {

                    GET_555_COLOR(PCCX, FALSE);

                    *pDest++ = GET_VGA256_INDEX(PCCX,
                                                ROTPAT_A,
                                                ROTPAT_B,
                                                ROTPAT_C);

                    WRAP_ROTPAT;
                }
            }
        }

    } else {

        UINT    SkipCount;


        SET_PATABC(TRUE);

        while (TRUE) {

            PCC = *(++pPrimColorCount);

            if (PCC.Count >= PRIM_COUNT_SPECIAL) {

                if (PCC.Count == PRIM_COUNT_END_SCAN) {

                    return;     // EOF
                }

                pDest += PCC.cSkip;         // advance destination

                SKIP_PATABC(PCC.cSkip, SkipCount);
                SKIP_555PAT(PCC.cSkip);

            } else {

                GET_555_COLOR_IDXPCC(PCCX);

                while (PCC.Count--) {

                    GET_555_COLOR(PCCX, FALSE);

                    *pDest++ = GET_VGA256_INDEX(PCCX,
                                                *pCurPatA,
                                                *pCurPatB,
                                                *pCurPatC);

                    WRAP_PATABC;
                }
            }
        }
    }
}


VOID
HTENTRY
SingleCountOutputToVGA256(
    PPRIMCOLOR_COUNT    pPrimColorCount,
    LPBYTE              pDest,
    LPBYTE              pPattern,
    OUTFUNCINFO         OutFuncInfo
    )

/*++

Routine Description:

    This function output to the BMF_4BPP destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination planes pointers.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:

    01-Jun-1992 Mon 15:32:00 updated  -by-  Daniel Chou (danielc)
        1. Fixed the first 'Dest = Prim1234.b[4]' to 'Dest = Prim1234.b[3]'
           mistake.


--*/

{
    LPBYTE          pCurPatA;
    LPBYTE          pEndPatA;
    LPBYTE          pCurPatB;
    LPBYTE          pCurPatC;
    LPBYTE          pXlate;
    PRIMCOLOR_COUNT PCC;
    LPBYTE          pCur555Pat;
    LPBYTE          pEnd555Pat;
    BYTE            bTmp;
    WORD            Idx;
    PRIMCOLOR_COUNT PCCX;


    //
    // Since we are in byte boundary, we should never get the first one is
    // invalid
    //

    if (!(pXlate = (LPBYTE)OutFuncInfo.pXlate8BPP)) {

        pXlate = (LPBYTE)DefHTXlate8BPP;
    }

    SET_555PAT;

    if (pPattern) {

        LPBYTE  pRotPatA;
        BYTE    bPat;


        SET_ROTPAT;

        while (TRUE) {

            PCC = *(++pPrimColorCount);

            if (PCC.Count >= PRIM_COUNT_SPECIAL) {

                if (PCC.Count == PRIM_COUNT_END_SCAN) {

                    return;     // EOF
                }

            } else {

                GET_555_COLOR(PCCX, TRUE);

                *pDest = GET_VGA256_INDEX(PCCX,
                                          ROTPAT_A,
                                          ROTPAT_B,
                                          ROTPAT_C);
            }

            ++pDest;

            WRAP_ROTPAT;
        }

    } else {

        SET_PATABC(TRUE);

        while (TRUE) {

            PCC = *(++pPrimColorCount);

            if (PCC.Count >= PRIM_COUNT_SPECIAL) {

                if (PCC.Count == PRIM_COUNT_END_SCAN) {

                    return;     // EOF
                }

            } else {

                GET_555_COLOR(PCCX, TRUE);

                *pDest = GET_VGA256_INDEX(PCCX,
                                          *pCurPatA,
                                          *pCurPatB,
                                          *pCurPatC);
            }

            ++pDest;

            WRAP_PATABC;
        }
    }
}


@BEG_PROC   SingleCountOutputToVGA256   <pPrimColorCount:DWORD, \
                                         pDest:DWORD,           \
                                         pPattern:DWORD,        \
                                         OutFuncInfo:QWORD>

OUTFUNCINFO STRUC
    OFI_pXlate8BPP      DD  ?
    OFI_pPrimMap        DD  ?
    OFI_p555Pat         DD  ?
    OFI_PatWidthBytes   DW  ?
    OFI_PatOrgX         DW  ?
    OFI_pPatA           DD  ?
    OFI_pPatB           DD  ?
    OFI_pPatC           DD  ?
OUTFUNCINFO ENDS


#define ROTPAT_A    (pCurPatA[bPat = *pRotPatA])
#define ROTPAT_B    (pCurPatB[bPat])
#define ROTPAT_C    (pCurPatC[bPat])



SET_ROTPAT MACRO

    __@@EMIT <mov  > _AX, pPattern
    __@@EMIT <mov  > _BP, _AX
    __@@EMIT <movzx> _BX, OutFuncInfo.PatWidthBytes
    __@@EMIT <add  > _AX, _BX
    __@@EMIT <mov  > pEndPatA, _AX
    __@@EMIT <movzx> _AX, OutFuncInfo.PatOrgX
    __@@EMIT <add > _BP, _AX
ENDM


SKIP_ROTPAT MACRO   Count
                    Local   DoneSkip

    __@@EMIT <xor  > _DX, _DX,
    __@@EMIT <movzx> _AX, WPTR Count
    __@@EMIT <div  > OutFuncInfo.PatWidthBytes
    __@@EMIT <add  > _BP, _DX
    __@@EMIT <cmp  > _BP, pEndPatA
    __@@EMIT <jb   > <SHORT DoneWrap>
    __@@EMIT <sub > _BP, OutFuncInfo.PatWidthBytes
DoneSkip:

ENDM

WRAP_ROTPAT MACRO   EndWrapLoc
                    Local   DoneWrap

    IFB <EndWrapLoc>
        __@@EMIT <inc  > _BP
        __@@EMIT <cmp  > _BP, pEndPatA
        __@@EMIT <jb   > <SHORT DoneWrap>
        __@@EMIT <sub  > _BP, OutFuncInfo.PatWidthBytes
    ELSE
        __@@EMIT <inc  > _BP
        __@@EMIT <cmp  > _BP, pEndPatA
        __@@EMIT <jb   > <SHORT EndWrapLoc>
        __@@EMIT <sub  > _BP, OutFuncInfo.PatWidthBytes
        __@@EMIT <jmp  > <SHORT EndWrapLoc>
    ENDIF

DoneWrap:

ENDM

#define GET_555_COLOR(pc, GetPCCIdx)                                        \
{                                                                           \
    if (OutFuncInfo.cx555Pat) {                                             \
                                                                            \
        if (PCC.Color.Prim1 > (bTmp = *pCur555Pat)) {                       \
                                                                            \
            Idx = PCC.Color.w2b.wPrim + HT_RGB_B_INC;                       \
                                                                            \
        } else {                                                            \
                                                                            \
            Idx = PCC.Color.w2b.wPrim;                                      \
        }                                                                   \
                                                                            \
        if (PCC.Color.Prim2 > bTmp) {                                       \
                                                                            \
            Idx += HT_RGB_G_INC;                                            \
        }                                                                   \
                                                                            \
        if (PCC.Color.Prim3 > bTmp) {                                       \
                                                                            \
            Idx += HT_RGB_R_INC;                                            \
        }                                                                   \
                                                                            \
        if (++pCur555Pat >= pEnd555Pat) {                                   \
                                                                            \
            pCur555Pat -= OutFuncInfo.cx555Pat;                             \
        }                                                                   \
                                                                            \
        if (Idx >= HT_RGB_CUBE_COUNT) {                                     \
                                                                            \
            DBGP("Idx = %04x, wPrim=%04x (%u:%u:%u) [%u]"                   \
                ARGU(Idx) ARGU(PCC.Color.w2b.wPrim)                         \
                ARGU(PCC.Color.Prim1)                                       \
                ARGU(PCC.Color.Prim2)                                       \
                ARGU(PCC.Color.Prim3)                                       \
                ARGU(bTmp));                                                \
                                                                            \
            Idx = HT_RGB_CUBE_COUNT;                                        \
        }                                                                   \
                                                                            \
        pc.Color = *((PPRIMCOLOR)OutFuncInfo.pPrimMap + Idx);               \
                                                                            \
    } else if (GetPCCIdx) {                                                 \
                                                                            \
        pc.Color = *((PPRIMCOLOR)OutFuncInfo.pPrimMap+PCC.Color.w2b.wPrim); \
    }                                                                       \
}

;==========================================
; Register Usage:
;
; _SI           : pPrimColorCount
; _DI           : pDest
; _BP           : Current pPattern, self wrappable
; ecx, edx      ; color and count
; _BX           ; 555 pattern, self wrap able
; _AX           : Scratch register
;==========================================
cl   = Prim1
ch   = Prim2
ecl  = Prim3
ech  = Flags


GET_V256_IDX    MACRO
    __@@EMIT <movzx> eax, BPTR [_BP]

    __@@EMIT <cmp  > al, cl
    __@@EMIT <sbb  > bh, bh                              ; al=0xff or 0
    __@@EMIT <cmp  > al, ch
    __@@EMIT <sbb  > bl, bl
    __@@EMIT <and  > bx, ((VGA256_B_CUBE_INC shl 8) or VGA256_G_CUBE_INC)                              ; dh:dl=36:6
    __@@EMIT <cmp  > al, ecl
    __@@EMIT <adc  > bl, bh

    __@@EMIT <add  > al, ch

    __@@EMIT <rol  > ecx, 16
    __@@EMIT <rcr  > _BX, 5
    __@@EMIT <cmp  > al, ch
    __@@EMIT <rcr  > _BX, 5
    __@@EMIT <cmp  > al, cl
    __@@EMIT <rcr  > _BX, 6
    __@@EMIT <add  > _BX, _DX
    __@@EMIT <add  > _BX, _DX
    __@@EMIT <shl  > _BX, 1



ENDM

GET_555_COLOR   MACRO   <IsGetIdx>

    __@@EMIT <or   > _BX, _BX
    __@@EMIT <jnc  > GetIndex
    __@@EMIT <mov  > al, BPTR [_BX]
    __@@EMIT <ror  > ecx, 16
    __@@EMIT <cmp  > al, cl
    __@@EMIT <rcr  > _BX, 5
    __@@EMIT <rol  > ecx, 16
    __@@EMIT <cmp  > al, ch
    __@@EMIT <rcr  > _BX, 5
    __@@EMIT <cmp  > al, cl
    __@@EMIT <rcr  > _BX, 6
    __@@EMIT <movzx) _AX, dx
    __@@EMIT <add  > _BX, _AX
    __@@EMIT <shl  > _BX, 1
    __@@EMIT <mov  > DPTR [_BX + (_BX * 2)]







ENDM

        GET_555_COLOR   <TRUE>


;==========================================
; Register Usage:
;
; _SI           : pPrimColorCount
; _DI           : pDest
; _BP           : Current pPattern, self wrappable
; cl:ch:dl:dh   : Prim 1/2/3/4 ====> R/G/B/IDX
; _BX           : Scratch register
; _AX           : Scratch register
;==========================================
;
        @ENTER_PAT_TO_STK   <VGA256>                ; _BP=Pat location

;============================================================================
; Since we are in byte boundary, we should never have an invalid density to
; start with
;
; The VGA256's color table is constructed as BGR and 6 steps for each primary
; color.
;
;   The BGR Mask = 0x24:0x06:0x01
;============================================================================

        cld                                         ; clear direction

        LDS_SI  pPrimColorCount                     ;; _SI=pPrimColorCount
        LES_DI  pDest


        or      _AX, _AX
        jz      SHORT V256_NoXlate

V256_XlateByteLoop:
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     ecx, DPTR [SI]
        cmp     cx, PRIM_COUNT_SPECIAL
        jae     V256_Skip

        GET_555_COLOR   <TRUE>

        GET_V256_IDX

        xlatb

        WRAP_ROTPAT <V256_XlateByteLoop>

V256_Skip:
        cmp     cx, PRIM_COUNT_END_SCAN
        jz      short V256_XlateAllDone
        inc     _DI

        WRAP_ROTPAT     <V256_XlateByteLoop>

V256_XlateAllDone:





























IFE ExtRegSet
        mov     _BX, _SP                            ; the table on the stack
ELSE
        mov     _BX, _AX                            ; _AX point to xlate table
ENDIF

V256_XlateByteLoop:
        dec     _BP                                 ; do this one first

        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     cx, WPTR [_SI+2]                    ; bl:bh=Prim 1/2 B/G
        cmp     cl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short V256_XlateInvDensity

        mov     dh, BPTR [_BP]                      ; al=pattern
        dec     dh                                  ; make it cmp al, cl work

        cmp     dh, cl
        sbb     ah, ah                              ; al=0xff or 0
        cmp     dh, ch
        sbb     al, al
        and     ax, ((VGA256_B_CUBE_INC shl 8) or VGA256_G_CUBE_INC)                              ; dh:dl=36:6

        mov     cx, WPTR [_SI+4]                    ; cl:ch=Prim 3/4 R/I

        cmp     dh, cl
        adc     al, ah
        add     al, ch

        ;
        ; for extended register set _BX point to the translation table
        ; otherwise ss:bx point to the translation table
        ;

IFE ExtRegSet
        xlat    _SS:VGA256_SSSP_XLAT_TABLE
ELSE
        xlatb
ENDIF
        stosb

        WRAP_BP_PAT?? <V256_XlateByteLoop>

V256_XlateInvDensity:
        cmp     cl, ch
        jz      short V256_XlateAllDone

        inc     _DI
        WRAP_BP_PAT?? <V256_XlateByteLoop>

V256_XlateAllDone:

IFE ExtRegSet
        add     _SP, VGA256_XLATE_TABLE_SIZE
ENDIF

;===================================================================

AllDone:
        @EXIT_PAT_STK_RESTORE

;===================================================================


V256_NoXlate:

        mov     bx, ((VGA256_B_CUBE_INC shl 8) or VGA256_G_CUBE_INC)

V256_ByteLoop:
        dec     _BP                                 ; do this one first

        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     cx, WPTR [_SI+2]                    ; cl:ch=Prim 1/2 B/G
        cmp     cl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short V256_InvDensity

        mov     dh, BPTR [_BP]                      ; dh=pattern
        dec     dh                                  ; make it cmp dh, T work

        cmp     dh, cl
        sbb     ah, ah                              ; ah=0xff or 0
        cmp     dh, ch
        sbb     al, al                              ; al=0xff or 0x00
        and     ax, bx                              ; bh:bl=36:6

        mov     cx, WPTR [_SI+4]                    ; cl:ch=Prim 3/4 R/I

        cmp     dh, cl
        adc     al, ah
        add     al, ch
        stosb

        WRAP_BP_PAT?? <V256_ByteLoop>

V256_InvDensity:
        cmp     cl, ch
        jz      short AllDone

        inc     _DI
        WRAP_BP_PAT?? <V256_ByteLoop>


@END_PROC




SUBTTL  VarCountOutputToVGA256
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_4BPP destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination plane.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:

    01-Jun-1992 Mon 15:32:00 updated  -by-  Daniel Chou (danielc)
        1. Fixed so that Prims match the device's BGR color table format rather
           than RGB format

    19-Mar-1993 Fri 18:53:56 updated  -by-  Daniel Chou (danielc)
        1. When we push _SI and jmp to VGA256_InvDensity we fogot to that
           si now is run as count rather than _CX

`

@BEG_PROC   VarCountOutputToVGA256  <pPrimColorCount:DWORD, \
                                     pDest:DWORD,           \
                                     pPattern:DWORD,        \
                                     OutFuncInfo:QWORD>


;==========================================
; Register Usage:
;
; _SI           : pPrimColorCount
; _DI           : pDest
; _BP           : Current pPattern, self wrappable
; cx            : PrimColorCount.Count
; bl:bh:dl:dh   : Prim 1/2/3/4 ====> R/G/B/IDX
; al            : DestByte
; ah            : Scratch Register
;==========================================
;

        @ENTER_PAT_TO_STK   <VGA256>                ; _BP=Pat location

;============================================================================
; Since we are in byte boundary, we should never have an invalid density to
; start with
;
; The VGA256's color table is constructed as BGR and 6 steps for each primary
; color.
;============================================================================

        cld                                         ; clear direction

IFE ExtRegSet
        mov     _BX, _SP                            ; the table on the stack
ELSE
        mov     _BX, _AX                            ; _AX point to xlate table
ENDIF
        or      _AX, _AX
        jnz     SHORT V256_XlateStart
        jmp     V256_NoXlate


        ;======== THIS PORTION is for xlate table

V256_XlateByteLoop:
        pop     _SI                                 ; restore SI

V256_XlateStart:
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        push    _SI                                 ; save again

        mov     cx, WPTR [_SI+2]                    ; cl:ch=Prim 1/2  B/G
        cmp     cl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short V256_XlateInvDensity

        mov     dx, WPTR [_SI+4]                    ; dl:dh=Prim 3/4  R/I
        mov     si, WPTR [_SI]                      ; count
        inc     si

V256_XlateCountLoop:

        dec     si
        jz      short V256_XlateByteLoop

        dec     _BP
        mov     ah, BPTR [_BP]                      ; ah=Pattern
        dec     ah                                  ; make cmp ah, bl works

        cmp     ah, cl
        sbb     al, al
        and     al, VGA256_B_CUBE_INC               ; AL=0 or 36  Prim1

        cmp     ah, dl                              ; Do Prim 3 first
        adc     al, dh                              ; al=InitValue+Prim1+Prim3

        cmp     ah, ch                              ; do Prim 2 now
        sbb     ah, ah
        and     ah, VGA256_G_CUBE_INC
        add     al, ah

        ;
        ; for extended register set _BX point to the translation table
        ; otherwise ss:bx point to the translation table
        ;

IFE ExtRegSet
        xlat    _SS:VGA256_SSSP_XLAT_TABLE
ELSE
        xlatb
ENDIF

        stosb

V256_XlateReadyNextByte:

        WRAP_BP_PAT?? <V256_XlateCountLoop>


V256_XlateInvDensity:
        cmp     cl, ch                          ; all done?
        jz      SHORT V256_XlateAllDone
        dec     _BP
        inc     _DI

        MOVZX_W _CX, <WPTR [_SI]>
        mov     _SI, _CX                        ; we expect count in si
        cmp     _CX, 1
        jbe     short V256_XlateReadyNextByte

        ;=========

        dec     _CX
        mov     _AX, _CX
        add     _DI, _CX                        ; 1 pel per byte
        mov     _CX, _BP                        ; align pattern now
        and     _CX, HTPAT_STK_MASK             ; how many pat avai.?
        xor     _BP, _CX                        ; clear _BP mask=pPattern
        sub     _CX, _AX                        ; see if > 0? (_AX=Count)
        jg      short V256_XlateDoneSkipPels    ; still not used up yet!
        mov     _AX, [_BP - HTPAT_BP_SIZE]      ; get pattern size
V256_XlateSkipLoop:
        add     _CX, _AX
        jle     short V256_XlateSkipLoop        ; do until > 0
V256_XlateDoneSkipPels:
        add     _BP, _CX                        ; _BP=pCurPat
        jmp     V256_XlateByteLoop              ; repeat the process

V256_XlateAllDone:
        pop     _SI                             ; restore last _SI

IFE ExtRegSet
        add     _SP, VGA256_XLATE_TABLE_SIZE
ENDIF

;======================================================================

AllDone:
        @EXIT_PAT_STK_RESTORE

;======================================================================


V256_NoXlate:

V256_ByteLoop:
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     cx, WPTR [_SI]                      ; cx=count
        mov     bx, WPTR [_SI+2]                    ; bl:bh=Prim 1/2  B/G
        cmp     bl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short V256_InvDensity

        mov     dx, WPTR [_SI+4]                    ; dl:dh=Prim 3/4  R/I

        inc     cx

V256_CountLoop:

        dec     cx
        jz      short V256_ByteLoop

        dec     _BP
        mov     ah, BPTR [_BP]                      ; ah=Pattern
        dec     ah                                  ; make cmp ah, bl works

        cmp     ah, bl
        sbb     al, al
        and     al, VGA256_B_CUBE_INC               ; AL=0 or 36  Prim1

        cmp     ah, dl                              ; Do Prim 3 first
        adc     al, dh                              ; al=InitValue+Prim1+Prim3

        cmp     ah, bh                              ; do Prim 2 now
        sbb     ah, ah
        and     ah, VGA256_G_CUBE_INC
        add     al, ah
        stosb

ReadyNextByte:

        WRAP_BP_PAT?? <V256_CountLoop>


V256_InvDensity:
        cmp     bl, bh                          ; all done?
        jz      short AllDone
        dec     _BP
        inc     _DI
        cmp     cx, 1
        jbe     short ReadyNextByte

SkipDestPels:
        dec     cx
        WZXE    cx                              ; zero extended
        mov     _AX, _CX
        add     _DI, _CX                        ; 1 pel per byte
        mov     _CX, _BP                        ; align pattern now
        and     _CX, HTPAT_STK_MASK             ; how many pat avai.?
        xor     _BP, _CX                        ; clear _BP mask=pPattern
        sub     _CX, _AX                        ; see if > 0? (_AX=Count)
        jg      short DoneSkipDestPels          ; still not used up yet!
        mov     _AX, [_BP - HTPAT_BP_SIZE]      ; get pattern size
SkipDestPelsLoop:
        add     _CX, _AX
        jle     short SkipDestPelsLoop          ; do until > 0
DoneSkipDestPels:
        add     _BP, _CX                        ; _BP=pCurPat
        jmp     V256_ByteLoop                   ; repeat the process



@END_PROC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\htui\htuiapi.c ===
/*++

Copyright (c) 1990-1992  Microsoft Corporation


Module Name:

    htuiapi.c


Abstract:

    This module contains the API entry point for the halftone user interface


Author:

    21-Apr-1992 Tue 11:44:06 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:

    02-Feb-1994 Wed 18:09:28 updated  -by-  Daniel Chou (danielc)
        DLL Entry points is always WINAPI not FAR


--*/

#define _HTUI_APIS_


#include <stddef.h>

#include <windows.h>

#include <ht.h>
#include "htuidlg.h"
#include "htuimain.h"


HMODULE hHTUIModule = (HMODULE)NULL;
WCHAR   BmpExt[16];
WCHAR   FileOpenExtFilter[128];
WCHAR   FileSaveExtFilter[128];



DWORD
APIENTRY
HalftoneUI_DLLInit(
    HMODULE hModule,
    ULONG   Reason,
    LPVOID  Reserved
    )

/*++

Routine Description:

    This function is DLL main entry point, at here we will save the module
    handle, in the future we will need to do other initialization stuff.

Arguments:

    hModule     - Handle to this moudle when get loaded.

    Reason      - may be DLL_PROCESS_ATTACH

    Reserved    - reserved

Return Value:

    Always return 1L


Author:

    20-Feb-1991 Wed 18:42:11 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{

    UNREFERENCED_PARAMETER(Reserved);

    if (Reason == DLL_PROCESS_ATTACH) {

        hHTUIModule = hModule;

        LoadString(hHTUIModule, IDS_BMPEXT, BmpExt, COUNT_ARRAY(BmpExt));

        LoadString(hHTUIModule,
                   IDS_FILEOPENEXTFILTER,
                   FileOpenExtFilter,
                   COUNT_ARRAY(FileOpenExtFilter));

        LoadString(hHTUIModule,
                   IDS_FILESAVEEXTFILTER,
                   FileSaveExtFilter,
                   COUNT_ARRAY(FileSaveExtFilter));
    }

    return(1L);

}




LONG
APIENTRY
HTUI_ColorAdjustmentW(
    LPWSTR              pCallerTitle,
    HANDLE              hDefDIB,
    LPWSTR              pDefDIBTitle,
    PCOLORADJUSTMENT    pColorAdjustment,
    BOOL                ShowMonochromeOnly,
    BOOL                UpdatePermission
    )

/*++

Routine Description:

    This is the API entry for the halftone color adjustment, this function
    only allowed adjust the input colors

Arguments:

    pCallerTitle        - Pointer to the caller's title, it can be application
                          name, device name... which will be display in the
                          dialog box 'modify for:' line, if this field is NULL
                          then no title name is displayed on that line.

    hDefDIB             - If it is not NULL then this function will try to use
                          this DIB as default picture to adjustment testing.

    pDefDIBTitle        - Pointer to a string which indified the test DIB
                          content.

    pColorAdjusment     - Pointer to the COLORADJUSMENT data strcuture, this
                          data structure will updated upon exit.

    ShowMonochromeOnly  - Only display mono version of the bitmap

    UpdatePermission    - TRUE if ok for user to change the COLORADJUSTMENT
                          setting


Return Value:

    LONG value

    > 0     - If user choose 'OK' which the new data are updated into
              pColorAdjustment.

    = 0     - If user choose 'CANCEL' which the operation is canceled

    < 0     - An error occurred, it identified a predefined error code


Author:

    24-Apr-1992 Fri 07:45:19 created  -by-  Daniel Chou (danielc)

    26-Apr-1994 Tue 18:08:30 updated  -by-  Daniel Chou (danielc)
        Updated for the UNICODE version

    03-Jun-1994 Fri 20:52:05 updated  -by-  Daniel Chou (danielc)
        Get decimal character from current user

Revision History:


--*/

{
    HWND            hWndActive = GetActiveWindow();
    FARPROC         pfnDlgCallBack;
    PHTCLRADJPARAM  pHTClrAdjParam;
    LONG            Result;


    if (!pColorAdjustment)  {

        return(-1);
    }

    Result = GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, NULL, 0) *
             sizeof(WCHAR);

    if (!(pHTClrAdjParam = (PHTCLRADJPARAM)
                LocalAlloc(LPTR, (UINT)(sizeof(HTCLRADJPARAM) + Result)))) {

        return(-2);
    }

    GetLocaleInfoW(LOCALE_USER_DEFAULT,
                   LOCALE_SDECIMAL,
                   pHTClrAdjParam->pwDecimal = (LPWSTR)(pHTClrAdjParam + 1),
                   Result);

    pHTClrAdjParam->hWndApp          = hWndActive;
    pHTClrAdjParam->pCallerTitle     = pCallerTitle;
    pHTClrAdjParam->hDefDIB          = hDefDIB;
    pHTClrAdjParam->pDefDIBTitle     = pDefDIBTitle;
    pHTClrAdjParam->pCallerHTClrAdj  = pColorAdjustment;
    pHTClrAdjParam->ViewMode         = VIEW_MODE_REFCOLORS;
    pHTClrAdjParam->BmpNeedUpdate    = 1;

    if (ShowMonochromeOnly) {

        pHTClrAdjParam->Flags |= HTCAPF_SHOW_MONO;
    }

    if (UpdatePermission) {

        pHTClrAdjParam->Flags |= HTCAPF_CAN_UPDATE;
    }

#ifdef HTUI_STATIC_HALFTONE
    pHTClrAdjParam->RedGamma        =
    pHTClrAdjParam->GreenGamma      =
    pHTClrAdjParam->BlueGamma       = 20000;
#endif

    pfnDlgCallBack = (FARPROC)MakeProcInstance(HTClrAdjDlgProc,
                                               hHTUIModule);

    pHTClrAdjParam->HelpID = (DWORD)HLP_HT_CLR_ADJ_DLG;

    Result = (LONG)DialogBoxParam(hHTUIModule,
                                  MAKEINTRESOURCE(HTCLRADJDLG),
                                  hWndActive,
                                  (DLGPROC)pfnDlgCallBack,
                                  (LPARAM)pHTClrAdjParam);


    FreeProcInstance(pfnDlgCallBack);
    LocalFree(pHTClrAdjParam);

#if DBG
#if 0
    DbgPrint("\nHTUI_ColorAdjustment()=%ld", Result);
#endif
#endif

    return(Result);
}




LONG
APIENTRY
HTUI_ColorAdjustmentA(
    LPSTR               pCallerTitle,
    HANDLE              hDefDIB,
    LPSTR               pDefDIBTitle,
    PCOLORADJUSTMENT    pColorAdjustment,
    BOOL                ShowMonochromeOnly,
    BOOL                UpdatePermission
    )

/*++

Routine Description:

    This is the API entry for the halftone color adjustment, this function
    only allowed adjust the input colors

Arguments:

    hWndCaller          - a HWND to the parent of color adjustment dialog box.

    pCallerTitle        - Pointer to the caller's title, it can be application
                          name, device name... which will be display in the
                          dialog box 'modify for:' line, if this field is NULL
                          then no title name is displayed on that line.

    hDefDIB             - If it is not NULL then this function will try to use
                          this DIB as default picture to adjustment testing.

    pDefDIBTitle        - Pointer to a string which indified the test DIB
                          content.

    pColorAdjusment     - Pointer to the COLORADJUSMENT data strcuture, this
                          data structure will updated upon exit.

    ShowMonochromeOnly  - Only display mono version of the bitmap

    UpdatePermission    - TRUE if ok for user to change the COLORADJUSTMENT
                          setting


Return Value:

    LONG value

    > 0     - If user choose 'OK' which the new data are updated into
              pColorAdjustment.

    = 0     - If user choose 'CANCEL' which the operation is canceled

    < 0     - An error occurred, it identified a predefined error code


Author:

    24-Apr-1992 Fri 07:45:19 created  -by-  Daniel Chou (danielc)

    26-Apr-1994 Tue 18:08:30 updated  -by-  Daniel Chou (danielc)
        Updated for the UNICODE version

Revision History:


--*/

{
    LPWSTR  pwAlloc;
    LONG    cTitle;
    LONG    cDIB;
    LONG    Result;


    cTitle = (LONG)((pCallerTitle) ? strlen(pCallerTitle) + 1 : 0);
    cDIB   = (LONG)((pDefDIBTitle) ? strlen(pDefDIBTitle) + 1 : 0);

    if ((cTitle) || (cDIB)) {

        if (!(pwAlloc = (LPWSTR)LocalAlloc(LPTR,
                                           (cTitle + cDIB) * sizeof(WCHAR)))) {

            return(-2);
        }

        if (pCallerTitle) {

            MultiByteToWideChar(CP_ACP,
                                0,
                                pCallerTitle,
                                cTitle,
                                pwAlloc,
                                cTitle);

            pCallerTitle = (LPSTR)pwAlloc;
        }

        if (pDefDIBTitle) {

            MultiByteToWideChar(CP_ACP,
                                0,
                                pDefDIBTitle,
                                cDIB,
                                pwAlloc + cTitle,
                                cDIB);

            pDefDIBTitle = (LPSTR)(pwAlloc + cTitle);
        }

    } else {

        pwAlloc = (LPWSTR)NULL;
    }

    Result = HTUI_ColorAdjustmentW((LPWSTR)pCallerTitle,
                                   hDefDIB,
                                   (LPWSTR)pDefDIBTitle,
                                   pColorAdjustment,
                                   ShowMonochromeOnly,
                                   UpdatePermission);

    if (pwAlloc) {

        LocalFree(pwAlloc);
    }

    return(Result);
}





LONG
APIENTRY
HTUI_ColorAdjustment(
    LPSTR               pCallerTitle,
    HANDLE              hDefDIB,
    LPSTR               pDefDIBTitle,
    PCOLORADJUSTMENT    pColorAdjustment,
    BOOL                ShowMonochromeOnly,
    BOOL                UpdatePermission
    )

/*++

Routine Description:

    This is the API entry for the halftone color adjustment, this function
    only allowed adjust the input colors

Arguments:

    hWndCaller          - a HWND to the parent of color adjustment dialog box.

    pCallerTitle        - Pointer to the caller's title, it can be application
                          name, device name... which will be display in the
                          dialog box 'modify for:' line, if this field is NULL
                          then no title name is displayed on that line.

    hDefDIB             - If it is not NULL then this function will try to use
                          this DIB as default picture to adjustment testing.

    pDefDIBTitle        - Pointer to a string which indified the test DIB
                          content.

    pColorAdjusment     - Pointer to the COLORADJUSMENT data strcuture, this
                          data structure will updated upon exit.

    ShowMonochromeOnly  - Only display mono version of the bitmap

    UpdatePermission    - TRUE if ok for user to change the COLORADJUSTMENT
                          setting

Return Value:

    LONG value

    > 0     - If user choose 'OK' which the new data are updated into
              pColorAdjustment.

    = 0     - If user choose 'CANCEL' which the operation is canceled

    < 0     - An error occurred, it identified a predefined error code


Author:

    24-Apr-1992 Fri 07:45:19 created  -by-  Daniel Chou (danielc)

    26-Apr-1994 Tue 18:08:30 updated  -by-  Daniel Chou (danielc)
        Updated for the UNICODE version

Revision History:


--*/

{

    //
    // Compatible for ealier version of HTUI.DLL
    //

    return(HTUI_ColorAdjustmentA(pCallerTitle,
                                 hDefDIB,
                                 pDefDIBTitle,
                                 pColorAdjustment,
                                 ShowMonochromeOnly,
                                 UpdatePermission));

}





LONG
APIENTRY
HTUI_DeviceColorAdjustmentW(
    LPWSTR          pDeviceName,
    PDEVHTADJDATA   pDevHTAdjData
    )

/*++

Routine Description:

    This is the API entry for the halftone color adjustment, this function
    only allowed adjust the input colors

Arguments:

    pDeviceName     - Pointer to the device name to be displayed

    pDevHTAdjData   - Pointer to the DEVHTADJDATA

Return Value:

    LONG value

    > 0     - If user choose 'OK' which the new data are updated into
              pColorAdjustment if it is not NULL, and update content of
              pDevHTAdjData if it is not NULL

    = 0     - If user choose 'CANCEL' which the operation is canceled

    < 0     - An error occurred, it identified a predefined error code


Author:

    24-Apr-1992 Fri 07:45:19 created  -by-  Daniel Chou (danielc)

    03-Jun-1994 Fri 20:52:05 updated  -by-  Daniel Chou (danielc)
        Get decimal character from current user


Revision History:


--*/

{
    HWND            hWndActive = GetActiveWindow();
    FARPROC         pfnDlgCallBack;
    PHTDEVADJPARAM  pHTDevAdjParam;
    UINT            IntRes;
    LONG            Result;


    if ((!pDevHTAdjData) ||
        (!pDevHTAdjData->pDefHTInfo)) {

        return(-1);
    }

    Result = GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, NULL, 0) *
             sizeof(WCHAR);

    if (!(pHTDevAdjParam = (PHTDEVADJPARAM)
                LocalAlloc(LPTR, (UINT)(sizeof(HTDEVADJPARAM) + Result)))) {

        return(-2);
    }

    GetLocaleInfoW(LOCALE_USER_DEFAULT,
                   LOCALE_SDECIMAL,
                   pHTDevAdjParam->pwDecimal= (LPWSTR)(pHTDevAdjParam + 1),
                   Result);

    pHTDevAdjParam->pDeviceName  = pDeviceName;
    pHTDevAdjParam->DevHTAdjData = *pDevHTAdjData;

    if ((pDevHTAdjData->pAdjHTInfo == NULL) ||
        (pDevHTAdjData->pAdjHTInfo == pDevHTAdjData->pDefHTInfo)) {

        pHTDevAdjParam->DevHTAdjData.pAdjHTInfo = pDevHTAdjData->pDefHTInfo;
        pHTDevAdjParam->UpdatePermission        = 0;

    } else {

        pHTDevAdjParam->UpdatePermission = 1;
    }

    pfnDlgCallBack = (FARPROC)MakeProcInstance(HTDevAdjDlgProc,
                                               hHTUIModule);

    if (pDevHTAdjData->DeviceFlags & DEVHTADJF_ADDITIVE_DEVICE) {

        if (pDevHTAdjData->DeviceFlags & DEVHTADJF_COLOR_DEVICE) {

            IntRes = HTDEV_DLG_ADD;
            Result = HLP_HTDEV_DLG_ADD;

        } else {

            IntRes = HTDEV_DLG_ADD_MONO;
            Result = HLP_HTDEV_DLG_ADD_MONO;
        }


        IntRes = (pDevHTAdjData->DeviceFlags & DEVHTADJF_COLOR_DEVICE) ?
                                    HTDEV_DLG_ADD : HTDEV_DLG_ADD_MONO;

    } else {

        if (pDevHTAdjData->DeviceFlags & DEVHTADJF_COLOR_DEVICE) {

            IntRes = HTDEV_DLG_SUB;
            Result = HLP_HTDEV_DLG_SUB;

        } else {

            IntRes = HTDEV_DLG_SUB_MONO;
            Result = HLP_HTDEV_DLG_SUB_MONO;
        }
    }

    pHTDevAdjParam->HelpID = (DWORD)Result;

    Result = (LONG)DialogBoxParam(hHTUIModule,
                                  MAKEINTRESOURCE(IntRes),
                                  hWndActive,
                                  (DLGPROC)pfnDlgCallBack,
                                  (LPARAM)pHTDevAdjParam);

    FreeProcInstance(pfnDlgCallBack);
    LocalFree(pHTDevAdjParam);

    return(Result);
}



LONG
APIENTRY
HTUI_DeviceColorAdjustmentA(
    LPSTR           pDeviceName,
    PDEVHTADJDATA   pDevHTAdjData
    )
/*++

Routine Description:

    This is the API entry for the halftone color adjustment, this function
    only allowed adjust the input colors

Arguments:

    pDeviceName     - Pointer to the device name to be displayed

    pDevHTAdjData   - Pointer to the DEVHTADJDATA

Return Value:

    LONG value

    > 0     - If user choose 'OK' which the new data are updated into
              pColorAdjustment if it is not NULL, and update content of
              pDevHTAdjData if it is not NULL

    = 0     - If user choose 'CANCEL' which the operation is canceled

    < 0     - An error occurred, it identified a predefined error code


Author:

    24-Apr-1992 Fri 07:45:19 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPWSTR  pwAlloc;
    LONG    Result;


    if (pDeviceName) {

        Result = strlen(pDeviceName) + 1;

        if (!(pwAlloc = (LPWSTR)LocalAlloc(LPTR, Result * sizeof(WCHAR)))) {

            return(-2);
        }

        MultiByteToWideChar(CP_ACP, 0, pDeviceName, Result, pwAlloc, Result);
        pDeviceName = (LPSTR)pwAlloc;

    } else {

        pwAlloc = (LPWSTR)NULL;
    }

    Result = HTUI_DeviceColorAdjustmentW((LPWSTR)pDeviceName, pDevHTAdjData);

    if (pwAlloc) {

        LocalFree(pwAlloc);
    }

    return(Result);
}



LONG
APIENTRY
HTUI_DeviceColorAdjustment(
    LPSTR           pDeviceName,
    PDEVHTADJDATA   pDevHTAdjData
    )
/*++

Routine Description:

    This is the API entry for the halftone color adjustment, this function
    only allowed adjust the input colors

Arguments:

    pDeviceName     - Pointer to the device name to be displayed

    pDevHTAdjData   - Pointer to the DEVHTADJDATA

Return Value:

    LONG value

    > 0     - If user choose 'OK' which the new data are updated into
              pColorAdjustment if it is not NULL, and update content of
              pDevHTAdjData if it is not NULL

    = 0     - If user choose 'CANCEL' which the operation is canceled

    < 0     - An error occurred, it identified a predefined error code


Author:

    24-Apr-1992 Fri 07:45:19 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    //
    // Compatible for ealier version of HTUI.DLL
    //

    return(HTUI_DeviceColorAdjustmentA(pDeviceName, pDevHTAdjData));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\htui\htuidlg.h ===
#define HTCLRADJDLG                 100

#define HTDEV_DLG_SUB               24000
#define HTDEV_DLG_SUB_MONO          24500
#define HTDEV_DLG_ADD               25000
#define HTDEV_DLG_ADD_MONO          25500


#define IDS_HELP_FILENAME           25700
#define IDS_HELP_FILE_NOT_FOUND     25701
#define IDS_BMPEXT                  25702
#define IDS_FILEOPENEXTFILTER       25703
#define IDS_FILESAVEEXTFILTER       25704


#define HLP_HT_CLR_ADJ_DLG          25800
#define HLP_HTDEV_DLG_SUB           25900
#define HLP_HTDEV_DLG_SUB_MONO      26000
#define HLP_HTDEV_DLG_ADD           26100
#define HLP_HTDEV_DLG_ADD_MONO      26200


#define IDD_HT_RESET                500
#define IDD_HT_DEFAULT              501
#define IDD_HT_BMP_TEST             502
#define IDD_HT_STATIC_DEVICE_NAME   504
#define IDD_HT_BMP_DLG              505
#define IDD_HT_EXT_DLG              506
#define IDD_HT_HELP                 507


#define IDD_HT_PIC_NAME             700
#define IDD_HT_MOVE_WITH_DLG        701
#define IDD_HT_BRING_TO_TOP         702
#define IDD_HT_ASPECT_RATIO         703
#define IDD_HT_PALETTE              704
#define IDD_HT_SHOW_COMBO           705
#define IDD_HT_DIB_TO_CLIPBOARD     706
#define IDD_HT_LAST_DIB             707
#define IDD_HT_OPEN                 708
#define IDD_HT_DIB_FROM_CLIPBOARD   709
#define IDD_HT_DEFAULT_DIB          710
#define IDD_HT_HALFTONE             711
#define IDD_HT_ICON                 712

#define IDD_HT_SAVE_AS              715
#define IDD_HT_ZOOM                 716
#define IDD_HT_HALFTONE_TITLE       717
#define IDD_HT_HALFTONE_DESC        718
#define IDD_HT_MIRROR               719
#define IDD_HT_NEGATIVE             720
#define IDD_HT_COPY_USE_DIB         721
#define IDD_HT_BMP_POSITION         722
#define IDD_HT_LINEAR_GAMMA         723
#define IDD_HT_BMP_TITLE            724
#define IDD_HT_ILLUMINANT_TITLE     725
#define IDD_HT_COLOR_TITLE          726
#define IDD_HT_TINT_TITLE           727
#define IDD_HT_GAMMA_TITLE          728
#define IDD_HT_CONTRAST_TITLE       729
#define IDD_HT_UPSIDEDOWN           730
#define IDD_HT_BRIGHTNESS_TITLE     731
#define IDD_HT_REF_BLACK_TITLE      732
#define IDD_HT_REF_WHITE_TITLE      733


#define IDD_HT_INPUT_REF_BOX        800

#define IDD_HT_LOG_FILTER           1000
#define IDD_HT_ILLUMINANT_COMBO     1100

#define IDD_HT_CONTRAST_SCROLL      3000
#define IDD_HT_BRIGHTNESS_SCROLL    3001
#define IDD_HT_COLORFULNESS_SCROLL  3002
#define IDD_HT_RG_TINT_SCROLL       3003
#define IDD_HT_REF_BLACK_SCROLL     3004
#define IDD_HT_REF_WHITE_SCROLL     3005
#define IDD_HT_R_GAMMA_SCROLL       3006
#define IDD_HT_G_GAMMA_SCROLL       3007
#define IDD_HT_B_GAMMA_SCROLL       3008

#define IDD_HT_CONTRAST_INT         3100
#define IDD_HT_BRIGHTNESS_INT       3101
#define IDD_HT_COLORFULNESS_INT     3102
#define IDD_HT_RG_TINT_INT          3103
#define IDD_HT_REF_BLACK_INT        3104
#define IDD_HT_REF_WHITE_INT        3105
#define IDD_HT_R_GAMMA_INT          3106
#define IDD_HT_G_GAMMA_INT          3107
#define IDD_HT_B_GAMMA_INT          3108

#define IDD_HT_SYNC_R               3200
#define IDD_HT_SYNC_G               3201
#define IDD_HT_SYNC_B               3202


#define IDD_HT_FIRST_SCROLL         IDD_HT_CONTRAST_SCROLL
#define IDD_HT_LAST_SCROLL          IDD_HT_B_GAMMA_SCROLL
#define TOTAL_HTCLRADJ_SCROLL       (IDD_HT_LAST_SCROLL-IDD_HT_FIRST_SCROLL+1)
#define IDD_HT_SCROLL_INT_ADD       (IDD_HT_CONTRAST_INT-IDD_HT_CONTRAST_SCROLL)




#define IDS_HTPAT_SIZE_2x2          18500
#define IDS_HTPAT_SIZE_2x2_M        18501
#define IDS_HTPAT_SIZE_4x4          18502
#define IDS_HTPAT_SIZE_4x4_M        18503
#define IDS_HTPAT_SIZE_6x6          18504
#define IDS_HTPAT_SIZE_6x6_M        18505
#define IDS_HTPAT_SIZE_8x8          18506
#define IDS_HTPAT_SIZE_8x8_M        18507
#define IDS_HTPAT_SIZE_10x10        18508
#define IDS_HTPAT_SIZE_10x10_M      18509
#define IDS_HTPAT_SIZE_12x12        18510
#define IDS_HTPAT_SIZE_12x12_M      18511
#define IDS_HTPAT_SIZE_14x14        18512
#define IDS_HTPAT_SIZE_14x14_M      18513
#define IDS_HTPAT_SIZE_16x16        18514
#define IDS_HTPAT_SIZE_16x16_M      18515
#define IDS_HTPAT_SIZE_SUPERCELL    18516
#define IDS_HTPAT_SIZE_SUPERCELL_M  18517
#define IDS_HTPAT_SIZE_USER         18518

#define IDS_HTPAT_SIZE_MIN          IDS_HTPAT_SIZE_2x2
#define IDS_HTPAT_SIZE_MAX          IDS_HTPAT_SIZE_USER

#define IDS_PEL_SIZE_AS_DEVICE      18600

#define IDS_FILEDLGTITLE            20000
#define IDS_CALLER_TITLE_PREFIX     20001
#define IDS_UNKNOWN                 20002
#define IDS_CLIPBOARD_NAME          20003
#define IDS_DEFAULT_DIB             20004
#define IDS_SAVE_AS_DLGTITLE        20005

#define IDS_INI_KEY_BITMAP          20100
#define IDS_INI_KEY_DLGBOX_ORG      20101
#define IDS_INI_KEY_VIEW_RECT       20102
#define IDS_INI_KEY_OPTIONS         20103

#define IDS_ILLUMINANT              20300
#define IDS_TEST_MODE               20400

#define HTCLRADJDLG_ICON            20500

#define FILL_MODE_REFCOLORS         (0)
#define FILL_MODE_RGB               (1)
#define FILL_MODE_NTSC_BAR          (2)
#define FILL_MODE_MAX               FILL_MODE_NTSC_BAR

#define IDS_TEST_MODE_TABLE         (IDS_TEST_MODE + FILL_MODE_TABLE)
#define IDS_TEST_MODE_REFCOLORS     (IDS_TEST_MODE + FILL_MODE_REFCOLORS)
#define IDS_TEST_MODE_RGB           (IDS_TEST_MODE + FILL_MODE_RGB)
#define IDS_TEST_MODE_NTSC_BAR      (IDS_TEST_MODE + FILL_MODE_NTSC_BAR)

#define IDS_TEST_MODE_START         IDS_TEST_MODE_REFCOLORS
#define IDS_TEST_MODE_END           IDS_TEST_MODE_NTSC_BAR


#define IDD_HTDEV_DEVICE_NAME       22010
#define IDD_HTDEV_DEVICE_TITLE      22020

#define IDD_HTDEV_HTPAT_COMBO       22100
#define IDD_HTDEV_HTPAT_TITLE       22110

#define IDD_HTDEV_PIXEL_TEXT        22200
#define IDD_HTDEV_PIXEL_TITLE       22210
#define IDD_HTDEV_PIXEL_SCROLL      22250

#define IDD_HTDEV_R_GAMMA_TEXT      22300
#define IDD_HTDEV_G_GAMMA_TEXT      22301
#define IDD_HTDEV_B_GAMMA_TEXT      22302

#define IDD_HTDEV_DEV_GAMMA_TITLE   22310

#define IDD_HTDEV_R_GAMMA_SCROLL    22350
#define IDD_HTDEV_G_GAMMA_SCROLL    22351
#define IDD_HTDEV_B_GAMMA_SCROLL    22352

#define IDD_HTDEV_R_CIE_TITLE       22380
#define IDD_HTDEV_G_CIE_TITLE       22381
#define IDD_HTDEV_B_CIE_TITLE       22382
#define IDD_HTDEV_C_CIE_TITLE       22383
#define IDD_HTDEV_M_CIE_TITLE       22384
#define IDD_HTDEV_Y_CIE_TITLE       22385
#define IDD_HTDEV_W_CIE_TITLE       22386
#define IDD_HTDEV_CIE_GROUPBOX      22390

#define IDD_HTDEV_R_CIE_x_TEXT      22400
#define IDD_HTDEV_G_CIE_x_TEXT      22401
#define IDD_HTDEV_B_CIE_x_TEXT      22402
#define IDD_HTDEV_C_CIE_x_TEXT      22403
#define IDD_HTDEV_M_CIE_x_TEXT      22404
#define IDD_HTDEV_Y_CIE_x_TEXT      22405
#define IDD_HTDEV_W_CIE_x_TEXT      22406

#define IDD_HTDEV_R_CIE_x_SCROLL    22450
#define IDD_HTDEV_G_CIE_x_SCROLL    22451
#define IDD_HTDEV_B_CIE_x_SCROLL    22452
#define IDD_HTDEV_C_CIE_x_SCROLL    22453
#define IDD_HTDEV_M_CIE_x_SCROLL    22454
#define IDD_HTDEV_Y_CIE_x_SCROLL    22455
#define IDD_HTDEV_W_CIE_x_SCROLL    22456

#define IDD_HTDEV_R_CIE_x_NAME      22470
#define IDD_HTDEV_G_CIE_x_NAME      22471
#define IDD_HTDEV_B_CIE_x_NAME      22472
#define IDD_HTDEV_C_CIE_x_NAME      22473
#define IDD_HTDEV_M_CIE_x_NAME      22474
#define IDD_HTDEV_Y_CIE_x_NAME      22475
#define IDD_HTDEV_W_CIE_x_NAME      22476

#define IDD_HTDEV_R_CIE_y_TEXT      22500
#define IDD_HTDEV_G_CIE_y_TEXT      22501
#define IDD_HTDEV_B_CIE_y_TEXT      22502
#define IDD_HTDEV_C_CIE_y_TEXT      22503
#define IDD_HTDEV_M_CIE_y_TEXT      22504
#define IDD_HTDEV_Y_CIE_y_TEXT      22505
#define IDD_HTDEV_W_CIE_y_TEXT      22506

#define IDD_HTDEV_R_CIE_y_SCROLL    22550
#define IDD_HTDEV_G_CIE_y_SCROLL    22551
#define IDD_HTDEV_B_CIE_y_SCROLL    22552
#define IDD_HTDEV_C_CIE_y_SCROLL    22553
#define IDD_HTDEV_M_CIE_y_SCROLL    22554
#define IDD_HTDEV_Y_CIE_y_SCROLL    22555
#define IDD_HTDEV_W_CIE_y_SCROLL    22556

#define IDD_HTDEV_R_CIE_y_NAME      22570
#define IDD_HTDEV_G_CIE_y_NAME      22571
#define IDD_HTDEV_B_CIE_y_NAME      22572
#define IDD_HTDEV_C_CIE_y_NAME      22573
#define IDD_HTDEV_M_CIE_y_NAME      22574
#define IDD_HTDEV_Y_CIE_y_NAME      22575
#define IDD_HTDEV_W_CIE_y_NAME      22576

#define IDD_HTDEV_W_CIE_L_TEXT      22600
#define IDD_HTDEV_W_CIE_L_NAME      22610
#define IDD_HTDEV_W_CIE_L_GROUPBOX  22620
#define IDD_HTDEV_W_CIE_L_SCROLL    22650

#define IDD_HTDEV_DYE_GROUPBOX      22670

#define IDD_HTDEV_M_IN_C_TEXT       22700
#define IDD_HTDEV_Y_IN_C_TEXT       22701
#define IDD_HTDEV_C_IN_M_TEXT       22702
#define IDD_HTDEV_Y_IN_M_TEXT       22703
#define IDD_HTDEV_C_IN_Y_TEXT       22704
#define IDD_HTDEV_M_IN_Y_TEXT       22705

#define IDD_HTDEV_M_IN_C_SCROLL     22750
#define IDD_HTDEV_Y_IN_C_SCROLL     22751
#define IDD_HTDEV_C_IN_M_SCROLL     22752
#define IDD_HTDEV_Y_IN_M_SCROLL     22753
#define IDD_HTDEV_C_IN_Y_SCROLL     22754
#define IDD_HTDEV_M_IN_Y_SCROLL     22755

#define IDD_HTDEV_CYAN_NAME         22800
#define IDD_HTDEV_CYAN_M_EQAUL      22801
#define IDD_HTDEV_CYAN_M_PERCENT    22802
#define IDD_HTDEV_CYAN_Y_EQUAL      22803
#define IDD_HTDEV_CYAN_Y_PERCENT    22804

#define IDD_HTDEV_MAGENTA_NAME      22810
#define IDD_HTDEV_MAGENTA_C_EQAUL   22811
#define IDD_HTDEV_MAGENTA_C_PERCENT 22812
#define IDD_HTDEV_MAGENTA_Y_EQUAL   22813
#define IDD_HTDEV_MAGENTA_Y_PERCENT 22814

#define IDD_HTDEV_YELLOW_NAME       22820
#define IDD_HTDEV_YELLOW_C_EQAUL    22821
#define IDD_HTDEV_YELLOW_C_PERCENT  22822
#define IDD_HTDEV_YELLOW_M_EQUAL    22823
#define IDD_HTDEV_YELLOW_M_PERCENT  22824

#define IDD_HTDEV_DEFAULT           23000
#define IDD_HTDEV_COPY_CLIPBOARD    23010
#define IDD_HTDEV_COLOR_ADJ         23020
#define IDD_HTDEV_REVERT            23030

#define IDD_HTDEV_R_GAMMA_NAME      23100
#define IDD_HTDEV_G_GAMMA_NAME      23101
#define IDD_HTDEV_B_GAMMA_NAME      23102
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\htui\htuimain.c ===
/*++

Copyright (c) 1990-1992  Microsoft Corporation


Module Name:

    htuimain.c


Abstract:

    This module contains all the halftone user interface's dialog box
    procedures


Author:

    21-Apr-1992 Tue 11:48:33 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:


--*/

#define _HTUI_APIS_

#include <stddef.h>
#include <windows.h>
// #include <winddi.h>

#include <commdlg.h>
#include <dlgs.h>

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <ht.h>

#include "htuidlg.h"
#include "htuimain.h"
#include "htuigif.h"
#include "htuidlg.h"


#define INCLUDE_DEF_CIEINFO
#define _HTUI_CIEINFO_ONLY_
#include "..\\ht\\htapi.h"


extern
HANDLE
ReadGIFFile(
    HANDLE  hFile
    );


#if DBG

#define SCREEN_BLT          0

#if 0
INT MyXOrg = 0;
INT MyYOrg = 0;
#endif

#define HTUI_ASSERT(Msg, exp) if (!(exp)) {                                      \
    DbgPrint("\n%s failed: %s line %d (%s)", Msg, __FILE__, __LINE__, #exp); }
#else

#define SCREEN_BLT          0
#define HTUI_ASSERT(Msg, exp)
#endif


#define ABSL(n)             (((n) < 0) ? -(n) : (n))

#define PBIH_HDR_SIZE(pbih) (UINT)(((pbih)->biSize) +                         \
                                   (((pbih)->biCompression == BI_BITFIELDS) ? \
                                    12 : (pbih)->biClrUsed * sizeof(RGBQUAD)))
#define BIH_HDR_SIZE(bih)   (UINT)(((bih).biSize) +                           \
                                   (((bih).biCompression == BI_BITFIELDS) ?   \
                                    12 : (bih).biClrUsed * sizeof(RGBQUAD)))


extern HMODULE  hHTUIModule;


HANDLE
GetNewDIBFromFile(
    PHTCLRADJPARAM  pHTClrAdjParam,
    BOOL            Default
    );


//***************************************************************************
// Following are locally used #defines and structures
//***************************************************************************


#define VSRC_PIC_DEF_DIB        0
#define VSRC_PIC_LOADED         1
#define VSRC_REFCOLORS          2
#define VSRC_RGB                3
#define VSRC_NTSC_BAR           4
#define VSRC_MAX                4

#define VSRC_TEST_COUNT         (FILL_MODE_MAX + 1)
#define VSRC_TEST_START         VSRC_REFCOLORS
#define DEFAULT_VSRC            VSRC_RGB

#define VSRC_LB_ID_START        L'A'
#define VSRC_LB_ID_SEPARATOR    L'.'


#define ADJ_CA(a,min,max)           if (a < min) { a = min; } else  \
                                    if (a > max) { a = max; }



#define XCHG(a,b,c)             (c)=(a); (a)=(b); (b)=(c)


#define TDI_REFCOLORS           0
#define TDI_RGBTEST             1
#define TDI_NTSC                2
#define TDI_CLRPAL              3
#define TDI_MAX_INDEX           3
#define TDI_DEFAULT             (DEFAULT_VSRC - VSRC_TEST_START)

typedef struct _TESTDIBINFO {
    HANDLE  hDIB;                       // if non null then is a DIB handle
    WORD    cx;                         // cx Size of the bitmap
    WORD    cy;                         // cy Size of the bitmap
    WORD    ClrUsed;                    // num of clolor used
    BYTE    bpp;                        // BitsPerPel
    BYTE    yStrips;                    // total bitmap vertical strips
    LPWORD  pRatioY;                    // ratio for each y strip
    LPBYTE  pPalette;                   // pointer to the palette R/G/B/R/G/B
    LPBYTE  pBmp;                       // pointer to the bitmap strips
    } TESTDIBINFO, FAR *PTESTDIBINFO;


HWND    hWndUITop    = (HWND)NULL;
HWND    hWndUIDlg    = (HWND)NULL;
WNDPROC WndProcUITop = (WNDPROC)NULL;


typedef struct _HTBLT {
    HDC         hDCMem;
    HBITMAP     hMemBmp;
    HPALETTE    hBmpPal;
    RECT        rcMemBmp;
    } HTBLT, FAR *PHTBLT;


#define CREATE_PHTBLT(pHTCAP)   pHTCAP->pCallerTitle =                      \
                                    (LPWSTR)LocalAlloc(LPTR, sizeof(HTBLT))
#define DELETE_PHTBLT(pHTCAP)   if (pHTCAP->pCallerTitle) {                 \
    pHTCAP->pCallerTitle = (LPWSTR)LocalFree((HLOCAL)pHTCAP->pCallerTitle);  \
    HTUI_ASSERT("DELETE_PHTBLT", pHTCAP->pCallerTitle == NULL); }
#define GET_PHTBLT(pHTCAP)      (PHTBLT)(pHTCAP->pCallerTitle)



BYTE    NTSCRGB[] = {

            191, 191,191,               //  0:GY    Gray
            191, 191,  0,               //  1:Y     Yellow
              0, 191,191,               //  2:C     Cyan
              0, 191,  0,               //  3:G     Green
            191,   0,191,               //  4:M     Magenta
            191,   0,  0,               //  5:R     Red
              0,   0,191,               //  6:B     Blue
              0,  76,127,               //  7:I     I in YIQ
            255, 255,255,               //  8:W     White
             75,   0,139,               //  9:Q     Q in YIQ
              0,   0,  0,               // 10:BK    Black
              3,   3,  3,               // 11:BK+1  1% Gray
              5,   5,  5,               // 12:BK+2  2% Gray
              8,   8,  8,               // 13:BK+3  3% Gray
             11,  11, 11,               // 14:BK+4  4% Gray
             13,  13, 13                // 15:BK+5  5% Gray
        };

WORD    NTSCRatioY[] = { 6700, 800, 2500 };
BYTE    NTSCBmp[] = {

        0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,
        0x66,0x66,0xaa,0xaa,0x44,0x44,0xaa,0xaa,0x22,0x22,0xaa,0xaa,0x00,0x00,
        0x77,0x77,0x78,0x88,0x88,0x99,0x99,0x9a,0xaa,0xaa,0xbb,0xcc,0xdd,0xee

        };

BYTE    RefClrRGB[] = {

             30,  18,  12,          // A. dark skin
            127,  86,  64,          // B. light skin
             36,  46,  82,          // C. blue sky
             25,  36,  13,          // D. foliage
             61,  53, 112,          // E. blue flowers
             69, 143, 113,          // F. bluish green
            141,  61,  11,          // G. orange
             20,  19,  81,          // H. purplish blue
            101,  25,  33,          // I. moderate red
             16,   5,  23,          // J. purple
            106, 148,  20,          // K. yellow green
            173, 109,  15,          // L. orange yellow
              6,   4,  42,          // M. blue
             33,  81,  19,          // N. green
             68,   7,  11,          // O. red
            203, 173,  15,          // P. yellow
             96,  20,  75,          // Q. magenta
             16,  57,  93,          // R. cyan
            255, 255, 255,          // S. white
            164, 164, 165,          // T. neutral 8
             97,  97,  97,          // U. neutral 6.5
             49,  49,  49,          // V. neutral 5
             18,  17,  17,          // W. neutral 3.5
              0,   0,   0           // X. black
        };


WORD    RefClrRatioY[] = { 2500, 2500, 2500, 2500 };
BYTE    RefClrBmp[] = {

            0,  1,  2,  3,  4,  5,
            6,  7,  8,  9, 10, 11,
           12, 13, 14, 15, 16, 17,
           18, 19, 20, 21, 22, 23
        };

BYTE    RGBTestRGB[] = {

     26,  0,  0, 77,  0,  0,128,  0,  0,179,  0,  0,230,  0,  0,    // R 216
    255, 26, 26,255, 77, 77,255,128,128,255,179,179,255,230,230,    //   221

      0, 26,  0,  0, 77,  0,  0,128,  0,  0,179,  0,  0,230,  0,    // G 226
     26,255, 26, 77,255, 77,128,255,128,179,255,179,230,255,230,    //   231

      0,  0, 26,  0,  0, 77,  0,  0,128,  0,  0,179,  0,  0,230,    // B 236
     26, 26,255, 77, 77,255,128,128,255,179,179,255,230,230,255,    //   241

     18, 18, 18, 36, 36, 36, 69, 69, 69, 87, 87, 87,120,120,120,    // W 246
    138,138,138,171,171,171,189,189,189,227,227,227,240,240,240     //   251
    };

WORD    RGBTestRatioY[] = {

             900,  900,  900,  900,  900,  900,
            1200, 1600,  600,  600,  600
        };

BYTE    RGBTestBmp[] = {

    // 6:6:6 Color Cube

     0,  1,  2,  3,  4,  5,  36, 37, 38, 39, 40, 41,  72, 73, 74, 75, 76, 77,
   108,109,110,111,112,113, 144,145,146,147,148,149, 180,181,182,183,184,185,

     6,  7,  8,  9, 10, 11,  42, 43, 44, 45, 46, 47,  78, 79, 80, 81, 82, 83,
   114,115,116,117,118,119, 150,151,152,153,154,155, 186,187,188,189,190,191,

    12, 13, 14, 15, 16, 17,  48, 49, 50, 51, 52, 53,  84, 85, 86, 87, 88, 89,
   120,121,122,123,124,125, 156,157,158,159,160,161, 192,193,194,195,196,197,

    18, 19, 20, 21, 22, 23,  54, 55, 56, 57, 58, 59,  90, 91, 92, 93, 94, 95,
   126,127,128,129,130,131, 162,163,164,165,166,167, 198,199,200,201,202,203,

    24, 25, 26, 27, 28, 29,  60, 61, 62, 63, 64, 65,  96, 97, 98, 99,100,101,
   132,133,134,135,136,137, 168,169,170,171,172,173, 204,205,206,207,208,209,

    30, 31, 32, 33, 34, 35,  66, 67, 68, 69, 70, 71, 102,103,104,105,106,107,
   138,139,140,141,142,143, 174,175,176,177,178,179, 210,211,212,213,214,215,

    // Gray Scale

     0,  0, 0,  0, 246,246, 247,247, 43, 43,248,248, 249,249, 86, 86,250,250,
   251,251,129,129,252,252, 253,253,172,172,254,254, 255,255,215,215,215,215,

    // Hue

   180,186,192,198,204,210, 174,138,102, 66, 30, 31,  32, 33, 34, 35, 29, 23,
    17, 11,  5, 41, 77,113, 149,185,184,183,182,181, 180,186,192,198,204,210,

    // Red Dark/Lightness

   216, 36, 36,217,217, 72,  72,218,218,108,108,219, 219,144,144,220,220,180,
   180,221,221,187,187,222, 222,194,194,223,223,201, 201,224,224,208,208,225,

    // Green Dark/Lightness

   226,  6,  6,227,227, 12,  12,228,228, 18, 18,229, 229, 24, 24,230,230, 30,
    30,231,231, 67, 67,232, 232,104,104,233,233,141, 141,234,234,178,178,235,

    // Blue Dark/Lightness

   236,  1,  1,237,237,  2,   2,238,238,  3,  3,239, 239,  4,  4,240,240,  5,
     5,241,241, 47, 47,242, 242, 89, 89,243,243,131, 131,244,244,173,173,245
};


TESTDIBINFO TestDIBInfo[TDI_MAX_INDEX + 1] = {

        { NULL,  6,  4,  24, 8, 4, RefClrRatioY,    RefClrRGB,  RefClrBmp   },
        { NULL, 36, 30, 256, 8,11, RGBTestRatioY,   RGBTestRGB, RGBTestBmp  },
        { NULL, 28, 21,  16, 4, 3, NTSCRatioY,      NTSCRGB,    NTSCBmp     },
        { NULL, 16, 16, 256, 8, 0, NULL,            NULL,       NULL        }
    };


//***************************************************************************
// Above are locally used #defines and structures
//***************************************************************************


WCHAR           HTClrAdjSectionName[80];
extern WCHAR    BmpExt[];
extern WCHAR    FileOpenExtFilter[];
extern WCHAR    FileSaveExtFilter[];

#if 0

WCHAR   BmpExt[]            = L"BMP";
WCHAR   FileOpenExtFilter[] = L"*.bmp;*.dib;*.gif\0*.bmp;*.dib;*.gif\0*.bmp\0*.bmp\0*.dib\0*.dib\0*.gif\0*.gif\0All files (*.*)\0*.*\0\0";
WCHAR   FileSaveExtFilter[] = L"*.bmp;*.dib\0*.bmp;*.dib\0\0";

#endif

WORD    IDDMonoGroup[] = {

            IDD_HT_COLOR_TITLE,
            IDD_HT_COLORFULNESS_SCROLL,
            IDD_HT_COLORFULNESS_INT,

            IDD_HT_TINT_TITLE,
            IDD_HT_RG_TINT_SCROLL,
            IDD_HT_RG_TINT_INT,

            IDD_HT_ILLUMINANT_TITLE,
            IDD_HT_ILLUMINANT_COMBO,

            0
        };

WORD    IDDGammaGroup[] = {

            IDD_HT_R_GAMMA_SCROLL,
            IDD_HT_G_GAMMA_SCROLL,
            IDD_HT_B_GAMMA_SCROLL,

            0
        };


WORD    IDDBmpTestGroup[] = {

            IDD_HT_SHOW_COMBO,
            IDD_HT_ZOOM,
            IDD_HT_PALETTE,
            IDD_HT_ASPECT_RATIO,
            IDD_HT_MIRROR,
            IDD_HT_UPSIDEDOWN,
            IDD_HT_OPEN,
            IDD_HT_SAVE_AS,
            IDD_HT_PIC_NAME,
            IDD_HT_HALFTONE_DESC,

            0
        };



typedef struct _DECICONVERT {
    WCHAR   FormatStr[12];
    WORD    Divider;
    } DECICONVERT;


typedef struct _HTDEVADJSCROLL {
    WORD    Min;
    WORD    Max;
    WORD    IDDText;
    WORD    IDDScroll;
    BYTE    DeciSize;
    BYTE    Step;
    WORD    Offset;
    } HTDEVADJSCROLL, FAR *PHTDEVADJSCROLL;



#define OFF_DEVHTINFO(a)    FIELD_OFFSET(DEVHTINFO, a)
#define OFF_COLORINFO(a)    OFF_DEVHTINFO(ColorInfo) +  \
                            FIELD_OFFSET(COLORINFO, a)
#define OFF_CIEINFO(a,i)    OFF_COLORINFO(a) + FIELD_OFFSET(CIECHROMA, i)
#define OFF_DYEINFO(a)      OFF_COLORINFO(a)


DECICONVERT DeciConvert[] = {

    { L"%u",        1       },
    { L"%u%ls%01u", 10      },
    { L"%u%ls%02u", 100     },
    { L"%u%ls%03u", 1000    },
    { L"%u%ls%04u", 10000   }
};

WCHAR   PelAsDevice[64];


UDECI4  CIEcyNTSC[] = { 6280, 2460,     // Red
                        2680, 5880,     // Green
                        1500,  700,     // Blue
                        2090, 3290,     // Cyan
                        3890, 2080,     // Magenta
                        4480, 4670,     // Yellow
                        3127, 3290  };  // White (D65)


#define NTSC_CIE_R_x_IDX        0
#define NTSC_CIE_R_y_IDX        1
#define NTSC_CIE_G_x_IDX        2
#define NTSC_CIE_G_y_IDX        3
#define NTSC_CIE_B_x_IDX        4
#define NTSC_CIE_B_y_IDX        5
#define NTSC_CIE_C_x_IDX        6
#define NTSC_CIE_C_y_IDX        7
#define NTSC_CIE_M_x_IDX        8
#define NTSC_CIE_M_y_IDX        9
#define NTSC_CIE_Y_x_IDX        10
#define NTSC_CIE_Y_y_IDX        11
#define NTSC_CIE_W_x_IDX        12
#define NTSC_CIE_W_y_IDX        13

#define NTSC_CIE_W_x            CIEcyNTSC[NTSC_CIE_W_x_IDX]
#define NTSC_CIE_W_y            CIEcyNTSC[NTSC_CIE_W_y_IDX]

#define MIN_ALIGNMENT_WHITE     2500
#define MAX_ALIGNMENT_WHITE     40000
#define STD_ALIGNMENT_WHITE     10000

#define MIN_DYE_MIX             0
#define MAX_DYE_MIX             9000

#define MIN_DEVPEL              15
#define MAX_DEVPEL              30000

#define INCH_TO_MM(dpi)     (WORD)((254000L+(DWORD)((dpi)>>1))/(DWORD)(dpi))
#define MM_TO_INCH(mm)      (WORD)((254000L+(DWORD)((mm)>>1))/(DWORD)(mm))

#define PERCENT_FROM_SCROLL(p)  (LONG)(p)=-(LONG)(p)-1+MIN_RES_PERCENT
#define PEL_FROM_SCROLL(p,min)  (LONG)(p)=(LONG)(p)-1+(min)
#define PERCENT_TO_SCROLL(p)    (LONG)(p)=-(LONG)((p)-MIN_RES_PERCENT+1)
#define PEL_TO_SCROLL(p,min)    (LONG)(p)=(LONG)(p)-(min)+1



HTDEVADJSCROLL  HTDevAdjScroll[] = {

    {   MIN_DEVPEL,  MAX_DEVPEL,
        IDD_HTDEV_PIXEL_TEXT, IDD_HTDEV_PIXEL_SCROLL,
        4,  10,     OFF_DEVHTINFO(DevPelsDPI)   },

    {   MIN_RGB_GAMMA, MAX_RGB_GAMMA,
        IDD_HTDEV_R_GAMMA_TEXT, IDD_HTDEV_R_GAMMA_SCROLL,
        4,  100,    OFF_COLORINFO(RedGamma)    },

    {   MIN_RGB_GAMMA, MAX_RGB_GAMMA,
        IDD_HTDEV_G_GAMMA_TEXT, IDD_HTDEV_G_GAMMA_SCROLL,
        4,  100,    OFF_COLORINFO(GreenGamma)  },

    {   MIN_RGB_GAMMA, MAX_RGB_GAMMA,
        IDD_HTDEV_B_GAMMA_TEXT, IDD_HTDEV_B_GAMMA_SCROLL,
        4,  100,    OFF_COLORINFO(BlueGamma)   },

    {   CIE_x_MIN, CIE_x_MAX,
        IDD_HTDEV_R_CIE_x_TEXT, IDD_HTDEV_R_CIE_x_SCROLL,
        4,  100,    OFF_CIEINFO(Red, x)             },

    {   CIE_y_MIN, CIE_y_MAX,
        IDD_HTDEV_R_CIE_y_TEXT, IDD_HTDEV_R_CIE_y_SCROLL,
        4,  100,    OFF_CIEINFO(Red, y)             },

    {   CIE_x_MIN, CIE_x_MAX,
        IDD_HTDEV_G_CIE_x_TEXT, IDD_HTDEV_G_CIE_x_SCROLL,
        4,  100,    OFF_CIEINFO(Green, x)           },

    {   CIE_y_MIN, CIE_y_MAX,
        IDD_HTDEV_G_CIE_y_TEXT, IDD_HTDEV_G_CIE_y_SCROLL,
        4,  100,    OFF_CIEINFO(Green, y)           },

    {   CIE_x_MIN, CIE_x_MAX,
        IDD_HTDEV_B_CIE_x_TEXT, IDD_HTDEV_B_CIE_x_SCROLL,
        4,  100,    OFF_CIEINFO(Blue, x)            },

    {   CIE_y_MIN, CIE_y_MAX,
        IDD_HTDEV_B_CIE_y_TEXT, IDD_HTDEV_B_CIE_y_SCROLL,
        4,  100,    OFF_CIEINFO(Blue, y)            },

    {   CIE_x_MIN, CIE_x_MAX,
        IDD_HTDEV_C_CIE_x_TEXT, IDD_HTDEV_C_CIE_x_SCROLL,
        4,  100,    OFF_CIEINFO(Cyan, x)            },

    {   CIE_y_MIN, CIE_y_MAX,
        IDD_HTDEV_C_CIE_y_TEXT, IDD_HTDEV_C_CIE_y_SCROLL,
        4,  100,    OFF_CIEINFO(Cyan, y)            },

    {   CIE_x_MIN, CIE_x_MAX,
        IDD_HTDEV_M_CIE_x_TEXT, IDD_HTDEV_M_CIE_x_SCROLL,
        4,  100,    OFF_CIEINFO(Magenta, x)         },

    {   CIE_y_MIN, CIE_y_MAX,
        IDD_HTDEV_M_CIE_y_TEXT, IDD_HTDEV_M_CIE_y_SCROLL,
        4,  100,    OFF_CIEINFO(Magenta, y)         },

    {   CIE_x_MIN, CIE_x_MAX,
        IDD_HTDEV_Y_CIE_x_TEXT, IDD_HTDEV_Y_CIE_x_SCROLL,
        4,  100,    OFF_CIEINFO(Yellow, x)          },

    {   CIE_y_MIN, CIE_y_MAX,
        IDD_HTDEV_Y_CIE_y_TEXT, IDD_HTDEV_Y_CIE_y_SCROLL,
        4,  100,    OFF_CIEINFO(Yellow, y)          },

    {   CIE_x_MIN, CIE_x_MAX,
        IDD_HTDEV_W_CIE_x_TEXT, IDD_HTDEV_W_CIE_x_SCROLL,
        4,  100,    OFF_CIEINFO(AlignmentWhite, x)  },

    {   CIE_y_MIN, CIE_y_MAX,
        IDD_HTDEV_W_CIE_y_TEXT, IDD_HTDEV_W_CIE_y_SCROLL,
        4,  100,    OFF_CIEINFO(AlignmentWhite, y)  },

    {   MIN_ALIGNMENT_WHITE, MAX_ALIGNMENT_WHITE,
        IDD_HTDEV_W_CIE_L_TEXT, IDD_HTDEV_W_CIE_L_SCROLL,
        2,  100,    OFF_CIEINFO(AlignmentWhite, Y)  },

    {   MIN_DYE_MIX, MAX_DYE_MIX,
        IDD_HTDEV_M_IN_C_TEXT,  IDD_HTDEV_M_IN_C_SCROLL,
        2,  100,    OFF_DYEINFO(MagentaInCyanDye)   },

    {   MIN_DYE_MIX, MAX_DYE_MIX,
        IDD_HTDEV_Y_IN_C_TEXT,  IDD_HTDEV_Y_IN_C_SCROLL,
        2,  100,    OFF_DYEINFO(YellowInCyanDye)    },

    {   MIN_DYE_MIX, MAX_DYE_MIX,
        IDD_HTDEV_C_IN_M_TEXT,  IDD_HTDEV_C_IN_M_SCROLL,
        2,  100,    OFF_DYEINFO(CyanInMagentaDye)   },

    {   MIN_DYE_MIX, MAX_DYE_MIX,
        IDD_HTDEV_Y_IN_M_TEXT,  IDD_HTDEV_Y_IN_M_SCROLL,
        2,  100,    OFF_DYEINFO(YellowInMagentaDye) },

    {   MIN_DYE_MIX, MAX_DYE_MIX,
        IDD_HTDEV_C_IN_Y_TEXT,  IDD_HTDEV_C_IN_Y_SCROLL,
        2,  100,    OFF_DYEINFO(CyanInYellowDye)    },

    {   MIN_DYE_MIX, MAX_DYE_MIX,
        IDD_HTDEV_M_IN_Y_TEXT,  IDD_HTDEV_M_IN_Y_SCROLL,
        2,  100,    OFF_DYEINFO(MagentaInYellowDye) }
};


#define COUNT_HTDEVADJSCROLL    COUNT_ARRAY(HTDevAdjScroll)



//
// The following BITMAPINFO (16) is used to SetDIBitsToDevice() for
// halftoned BMF_4BPP_VGA16 format
//

#define HTCLRADJ_BK_BRUSH               LTGRAY_BRUSH
#define HTCLRADJ_DEST_PRIM_ORDER        PRIMARY_ORDER_BGR

//
// This is used for scroll control in the dialog box.
//

#define HTCAS_SHORT     0x01
#define HTCAS_SYNC_RGB  0x02

typedef struct _HTCLRADJSCROLL {
    SHORT   Min;
    SHORT   Max;
    BYTE    Mul;
    BYTE    Step;
    BYTE    Offset;
    BYTE    Flags;
    } HTCLRADJSCROLL;


#define OFF_HTCLRADJ(x)     FIELD_OFFSET(COLORADJUSTMENT,x)


#define HTCLRADJSCROLL_R_GAMMA  HTClrAdjScroll[6]
#define HTCLRADJSCROLL_G_GAMMA  HTClrAdjScroll[7]
#define HTCLRADJSCROLL_B_GAMMA  HTClrAdjScroll[8]


#define CAS_MIN_GAMMA   ((MIN_RGB_GAMMA + 9) / 10)
#define CAS_MAX_GAMMA   ((MAX_RGB_GAMMA + 9) / 10)
#define RGB_GAMMA_CAS   CAS_MIN_GAMMA,CAS_MAX_GAMMA,10,25


HTCLRADJSCROLL  HTClrAdjScroll[TOTAL_HTCLRADJ_SCROLL] = {

    { -100, 100, 1, 2, OFF_HTCLRADJ(caContrast),       HTCAS_SHORT },
    { -100, 100, 1, 2, OFF_HTCLRADJ(caBrightness),     HTCAS_SHORT },
    { -100, 100, 1, 2, OFF_HTCLRADJ(caColorfulness),   HTCAS_SHORT },
    { -100, 100, 1, 2, OFF_HTCLRADJ(caRedGreenTint),   HTCAS_SHORT },
    {    0, 400,10,10, OFF_HTCLRADJ(caReferenceBlack),           0 },
    {  600,1000,10,10, OFF_HTCLRADJ(caReferenceWhite),           0 },
    {  RGB_GAMMA_CAS,  OFF_HTCLRADJ(caRedGamma),                 0 },
    {  RGB_GAMMA_CAS,  OFF_HTCLRADJ(caGreenGamma),               0 },
    {  RGB_GAMMA_CAS,  OFF_HTCLRADJ(caBlueGamma),                0 }
};


#define IS_BMP_AT_TOP(f)    ((f & (HT_BMP_AT_TOP | HT_BMP_ZOOM)) == \
                                            (HT_BMP_AT_TOP | HT_BMP_ZOOM))


#ifdef HTUIX_STATIC_HALFTONE

#define PBEG_IMAGE(p)           (LPBYTE)(p) + PBIH_HDR_SIZE(p)
#define GET_SCANLINEDELTA(p)    -(LONG)ALIGNED_32((p)->biWidth,(p)->biBitCount)
#define GET_SCAN0_OFFSET(y,d)   ((y - 1) * -(d))
#define GET_PPLANE(p,d)         PBEG_IMAGE(p)+GET_SCAN0_OFFSET((p)->biHeight,d)


typedef struct _HTLOGPAL16 {
    WORD            Version;
    WORD            Count;
    PALETTEENTRY    PalEntry[16];
} HTLOGPAL16;



typedef struct _HTUI_DIBINFO {
    BITMAPINFOHEADER    bi;
    RGBQUAD             rgb[256];
    } HTUI_DIBINFO, *PHTUI_DIBINFO;



DWORD                   HTUI_HTSurf  = BMF_4BPP_VGA16;
DWORD                   HTUI_DIBMode = DIB_RGB_COLORS;
HPALETTE                HTUI_hHTPal  = NULL;
PDEVICEHALFTONEINFO     HTUI_pDHI    = NULL;
LPBYTE                  HTUI_pHTBits = NULL;
HTUI_DIBINFO            HTUI_DIBInfo;

HTLOGPAL16  LogPalVGA16 = {

        0x300,
        16,

        {

            { 0,   0,   0,   0 },       // 0    Black
            { 0x80,0,   0,   0 },       // 1    Dark Red
            { 0,   0x80,0,   0 },       // 2    Dark Green
            { 0x80,0x80,0,   0 },       // 3    Dark Yellow
            { 0,   0,   0x80,0 },       // 4    Dark Blue
            { 0x80,0,   0x80,0 },       // 5    Dark Magenta
            { 0,   0x80,0x80,0 },       // 6    Dark Cyan
            { 0x80,0x80,0x80,0 },       // 7    Gray 50%

            { 0xC0,0xC0,0xC0,0 },       // 8    Gray 75%
            { 0xFF,0,   0,   0 },       // 9    Red
            { 0,   0xFF,0,   0 },       // 10   Green
            { 0xFF,0xFF,0,   0 },       // 11   Yellow
            { 0,   0,   0xFF,0 },       // 12   Blue
            { 0xFF,0,   0xFF,0 },       // 13   Magenta
            { 0,   0xFF,0xFF,0 },       // 14   Cyan
            { 0xFF,0xFF,0xFF,0 }        // 15   White
        }
    };



LONG
TestDevHTInfo(
    HWND            hWndOwner,
    PHTDEVADJPARAM  pHTDevAdjParam
    )
{
    FARPROC         pfnDlgCallBack;
    PDEVHTINFO      pDevHTInfo;
    PCOLORINFO      pColorInfo;
    HTCLRADJPARAM   HTClrAdjParam;
    CIEINFO         CIEInfo;
    SOLIDDYESINFO   DyesInfo;
    HTINITINFO      HTInitInfo;
    DWORD           DevPelsDPI;
    LONG            Result;


    ZeroMemory(&HTClrAdjParam,   sizeof(HTCLRADJPARAM));
    ZeroMemory(&HTInitInfo,      sizeof(HTINITINFO));

    pDevHTInfo = &(pHTDevAdjParam->CurHTInfo);
    pColorInfo = &(pHTDevAdjParam->CurHTInfo.ColorInfo);

    CIEInfo.Red.x            = (UDECI4)pColorInfo->Red.x;
    CIEInfo.Red.y            = (UDECI4)pColorInfo->Red.y;
    CIEInfo.Red.Y            = (UDECI4)pColorInfo->Red.Y;
    CIEInfo.Green.x          = (UDECI4)pColorInfo->Green.x;
    CIEInfo.Green.y          = (UDECI4)pColorInfo->Green.y;
    CIEInfo.Green.Y          = (UDECI4)pColorInfo->Green.Y;
    CIEInfo.Blue.x           = (UDECI4)pColorInfo->Blue.x;
    CIEInfo.Blue.y           = (UDECI4)pColorInfo->Blue.y;
    CIEInfo.Blue.Y           = (UDECI4)pColorInfo->Blue.Y;
    CIEInfo.Cyan.x           = (UDECI4)pColorInfo->Cyan.x;
    CIEInfo.Cyan.y           = (UDECI4)pColorInfo->Cyan.y;
    CIEInfo.Cyan.Y           = (UDECI4)pColorInfo->Cyan.Y;
    CIEInfo.Magenta.x        = (UDECI4)pColorInfo->Magenta.x;
    CIEInfo.Magenta.y        = (UDECI4)pColorInfo->Magenta.y;
    CIEInfo.Magenta.Y        = (UDECI4)pColorInfo->Magenta.Y;
    CIEInfo.Yellow.x         = (UDECI4)pColorInfo->Yellow.x;
    CIEInfo.Yellow.y         = (UDECI4)pColorInfo->Yellow.y;
    CIEInfo.Yellow.Y         = (UDECI4)pColorInfo->Yellow.Y;
    CIEInfo.AlignmentWhite.x = (UDECI4)pColorInfo->AlignmentWhite.x;
    CIEInfo.AlignmentWhite.y = (UDECI4)pColorInfo->AlignmentWhite.y;
    CIEInfo.AlignmentWhite.Y = (UDECI4)pColorInfo->AlignmentWhite.Y;

    DyesInfo.MagentaInCyanDye   = (UDECI4)pColorInfo->MagentaInCyanDye;
    DyesInfo.YellowInCyanDye    = (UDECI4)pColorInfo->YellowInCyanDye;
    DyesInfo.CyanInMagentaDye   = (UDECI4)pColorInfo->CyanInMagentaDye;
    DyesInfo.YellowInMagentaDye = (UDECI4)pColorInfo->YellowInMagentaDye;
    DyesInfo.CyanInYellowDye    = (UDECI4)pColorInfo->CyanInYellowDye;
    DyesInfo.MagentaInYellowDye = (UDECI4)pColorInfo->MagentaInYellowDye;

    HTInitInfo.Version              = HTINITINFO_VERSION;
    HTInitInfo.Flags                = (WORD)pDevHTInfo->HTFlags;
    HTInitInfo.HTPatternIndex       = (WORD)pDevHTInfo->HTPatternSize;
    HTInitInfo.HTCallBackFunction   = NULL;
    HTInitInfo.pHalftonePattern     = NULL;
    HTInitInfo.pInputRGBInfo        = NULL;
    HTInitInfo.pDeviceCIEInfo       = &CIEInfo;
    HTInitInfo.pDeviceSolidDyesInfo = &DyesInfo;
    HTInitInfo.DevicePowerGamma     = (UDECI4)pDevHTInfo->ColorInfo.RedGamma;

    DevPelsDPI = (DWORD)(pHTDevAdjParam->CurHTInfo.DevPelsDPI);

    HTInitInfo.DeviceResXDPI = (WORD)pHTDevAdjParam->DevHTAdjData.DeviceXDPI;
    HTInitInfo.DeviceResYDPI = (WORD)pHTDevAdjParam->DevHTAdjData.DeviceXDPI;
    HTInitInfo.DevicePelsDPI = (WORD)((DevPelsDPI <= HTDevAdjScroll0].Min) ?
                                                            ? 0 : DevPelsDPI);

    HTInitInfo.DefHTColorAdjustment = DefaultCA;

    HTClrAdjParam.pCallerTitle    = pHTDevAdjParam->pDeviceName;
    HTClrAdjParam.pHTInitInfo     = &HTInitInfo;
    HTClrAdjParam.RedGamma        = (UDECI4)pDevHTInfo->ColorInfo.RedGamma;
    HTClrAdjParam.GreenGamma      = (UDECI4)pDevHTInfo->ColorInfo.GreenGamma;
    HTClrAdjParam.BlueGamma       = (UDECI4)pDevHTInfo->ColorInfo.BlueGamma;
    HTClrAdjParam.ViewMode        = VIEW_MODE_REFCOLORS;
    HTClrAdjParam.BmpNeedUpdate   = 1;

    if (!(pHTDevAdjParam->DevHTAdjData.DeviceFlags & DEVHTADJF_COLOR_DEVICE)) {

        HTClrAdjParam.Flags |= HTCAPF_SHOW_MONO;
    }

    pfnDlgCallBack = (FARPROC)MakeProcInstance(HTClrAdjDlgProc,
                                               hHTUIModule);

    Result = (LONG)DialogBoxParam(hHTUIModule,
                                  MAKEINTRESOURCE(HTCLRADJDLG),
                                  hWndOwner,
                                  (DLGPROC)pfnDlgCallBack,
                                  (LONG)&HTClrAdjParam);


    FreeProcInstance(pfnDlgCallBack);

    return(Result);
}






HPALETTE
HTUI_CreateHalftonePalette(
    PHTCLRADJPARAM  pHTClrAdjParam
    )
{
    HDC         hDC;
    HTINITINFO  HTInitInfo;
    INT         cPal;

    hDC = pHTClrAdjParam->hDCDlg;

    if (!HTUI_pDHI) {

        HTUI_DIBInfo.bi.biSize          = sizeof(BITMAPINFOHEADER);
        HTUI_DIBInfo.bi.biWidth         = 0;
        HTUI_DIBInfo.bi.biHeight        = 0;
        HTUI_DIBInfo.bi.biPlanes        = 1;
        HTUI_DIBInfo.bi.biBitCount      = 4;
        HTUI_DIBInfo.bi.biCompression   = BI_RGB;
        HTUI_DIBInfo.bi.biSizeImage     = 0;
        HTUI_DIBInfo.bi.biXPelsPerMeter = 0;
        HTUI_DIBInfo.bi.biYPelsPerMeter = 0;
        HTUI_DIBInfo.bi.biClrUsed       = 0;
        HTUI_DIBInfo.bi.biClrImportant  = 0;


        cPal = (INT)GetDeviceCaps(hDC, SIZEPALETTE);

        if (cPal >= 32768) {

            HTInitInfo.HTPatternIndex       = HTPAT_SIZE_2x2_M;
            HTUI_DIBInfo.bi.biBitCount      = 16;
            HTUI_DIBInfo.bi.biClrUsed       = 0;
            HTUI_DIBInfo.bi.biCompression   = BI_BITFIELDS;
            HTUI_HTSurf                     = BMF_16BPP_555;
            HTUI_DIBMode                    = DIB_PAL_INDICES;

        } else if (cPal >= 256) {

            HTInitInfo.HTPatternIndex   = HTPAT_SIZE_4x4_M;
            HTUI_DIBInfo.bi.biBitCount  = 8;
            HTUI_DIBInfo.bi.biClrUsed   = 256;
            HTUI_HTSurf                 = BMF_8BPP_VGA256;

        } else {

            HTInitInfo.HTPatternIndex   = HTPAT_SIZE_4x4_M;
            HTUI_DIBInfo.bi.biBitCount  = 4;
            HTUI_DIBInfo.bi.biClrUsed   = 16;
            HTUI_HTSurf                 = BMF_4BPP_VGA16;
        }

        if (pHTClrAdjParam->pHTInitInfo) {

            HTInitInfo = *(pHTClrAdjParam->pHTInitInfo);

        } else {

            HTInitInfo.Version              = HTINITINFO_VERSION;
            HTInitInfo.Flags                = HIF_ADDITIVE_PRIMS;
            HTInitInfo.DevicePowerGamma     = UDECI4_1;
            HTInitInfo.HTCallBackFunction   = NULL;
            HTInitInfo.pHalftonePattern     = NULL;
            HTInitInfo.pInputRGBInfo        = NULL;
            HTInitInfo.pDeviceCIEInfo       = NULL;
            HTInitInfo.pDeviceSolidDyesInfo = NULL;
            HTInitInfo.DeviceResXDPI        = (WORD)GetDeviceCaps(hDC, LOGPIXELSX);
            HTInitInfo.DeviceResYDPI        = (WORD)GetDeviceCaps(hDC, LOGPIXELSY);
            HTInitInfo.DevicePelsDPI        = 0;
        }

        if (HT_CreateDeviceHalftoneInfo(&HTInitInfo, &HTUI_pDHI) < 0) {

            return(NULL);
        }

        if (HTUI_HTSurf == BMF_8BPP_VGA256) {

            LPLOGPALETTE    pPal;
            DWORD           Size;

            cPal = (INT)HT_Get8BPPFormatPalette(NULL, 0, 0, 0);

            Size = (DWORD)(sizeof(LOGPALETTE) +
                   (DWORD)((DWORD)cPal * sizeof(PALETTEENTRY)));

            if (pPal = (LPLOGPALETTE)LocalAlloc(LPTR, Size)) {

                HT_Get8BPPFormatPalette(&(pPal->palPalEntry[0]),
                                        pHTClrAdjParam->RedGamma,
                                        pHTClrAdjParam->GreenGamma,
                                        pHTClrAdjParam->BlueGamma);

                pPal->palVersion    = 0x300;
                pPal->palNumEntries = (WORD)cPal;
                HTUI_hHTPal = CreatePalette(pPal);
                LocalFree((HLOCAL)pPal);
            }

        } else {

            cPal        = (INT)LogPalVGA16.Count;
            HTUI_hHTPal = CreatePalette((LPLOGPALETTE)&LogPalVGA16);
        }

        if ((HTUI_hHTPal) && (HTUI_DIBInfo.bi.biCompression == BI_RGB)) {

            PALETTEENTRY    Pal;
            INT             i;

            HTUI_DIBInfo.bi.biClrImportant = (DWORD)cPal;

            for (i = 0; i < cPal; i++) {

                GetPaletteEntries(HTUI_hHTPal, (INT)i, 1, &Pal);

                HTUI_DIBInfo.rgb[i].rgbRed      = Pal.peRed;
                HTUI_DIBInfo.rgb[i].rgbGreen    = Pal.peGreen;
                HTUI_DIBInfo.rgb[i].rgbBlue     = Pal.peBlue;
                HTUI_DIBInfo.rgb[i].rgbReserved = 0;

#if 0
                DbgPrint("\nHTPAL %3u: = %3u:%3u:%3u",
                                (UINT)i,
                                (UINT)Pal.peRed,
                                (UINT)Pal.peGreen,
                                (UINT)Pal.peBlue);
#endif
            }

        } else {

            LPDWORD pMask = (LPDWORD)&(HTUI_DIBInfo.rgb[0]);

            *pMask++ = 0x7c00;
            *pMask++ = 0x03e0;
            *pMask++ = 0x001f;
        }
    }

    return(HTUI_hHTPal);
}


LONG
HTUI_StretchDIBits(
    HDC             hMemDC,
    LONG            DestX,
    LONG            DestY,
    LONG            DestCX,
    LONG            DestCY,
    LONG            SrcX,
    LONG            SrcY,
    LONG            SrcCX,
    LONG            SrcCY,
    LPBYTE          pBits,
    LPBITMAPINFO    pbi,
    DWORD           Mode,
    DWORD           Rop
    )
{
    LPBITMAPINFOHEADER  pSrcbih;
    HTSURFACEINFO       SrcSI;
    HTSURFACEINFO       DestSI;
    BITBLTPARAMS        BBP;
    COLORTRIAD          ColorTriad;
    COLORADJUSTMENT     ColorAdjustment;
    LONG                Width;
    LONG                Height;
    LONG                Result;



    if (!HTUI_pDHI) {

        return(0);
    }

    if ((Width = DestCX) < 0) {

        Width = -Width;
    }

    if ((Height = DestCY) < 0) {

        Height = -Height;
    }

    if ((Width != HTUI_DIBInfo.bi.biWidth) ||
        (Height != HTUI_DIBInfo.bi.biHeight)) {

        if (HTUI_pHTBits) {

            LocalFree((HLOCAL)HTUI_pHTBits);

            HTUI_DIBInfo.bi.biWidth  =
            HTUI_DIBInfo.bi.biHeight = 0;

            HTUI_pHTBits = NULL;
        }
    }

    if (!HTUI_pHTBits) {

        DWORD   SizeImage;


        SizeImage = (DWORD)ALIGN_BPP_DW(Width, HTUI_DIBInfo.bi.biBitCount) *
                    (DWORD)Height;

#if 0
        DbgPrint("\nHTBits Size: %ld x %ld= %ld\n",
                        (LONG)Width, (LONG)Height,  SizeImage);
#endif

        if (!(HTUI_pHTBits = (LPBYTE)LocalAlloc(LPTR, SizeImage))) {

            return(0);
        }

        HTUI_DIBInfo.bi.biSizeImage = SizeImage;
        HTUI_DIBInfo.bi.biWidth     = Width;
        HTUI_DIBInfo.bi.biHeight    = Height;
    }

    pSrcbih = (LPBITMAPINFOHEADER)pbi;

    ColorTriad.Type              = COLOR_TYPE_RGB;
    ColorTriad.BytesPerPrimary   = sizeof(BYTE);
    ColorTriad.BytesPerEntry     = sizeof(RGBQUAD);
    ColorTriad.PrimaryOrder      = PRIMARY_ORDER_BGR;
    ColorTriad.PrimaryValueMax   = (LONG)BYTE_MAX;
    ColorTriad.ColorTableEntries = pSrcbih->biClrUsed;
    ColorTriad.pColorTable       = (LPBYTE)&(pbi->bmiColors[0]);

    switch(pSrcbih->biBitCount) {

    case 1:

        SrcSI.SurfaceFormat = BMF_1BPP;
        break;

    case 4:

        SrcSI.SurfaceFormat = BMF_4BPP;
        break;

    case 8:

        SrcSI.SurfaceFormat = BMF_8BPP;
        break;

    case 16:

        //
        // 16BPP/32BPP bit fields type of input the parameter of
        // COLORTRIAD must
        //
        //  Type                = COLOR_TYPE_RGB
        //  BytesPerPrimary     = 0
        //  BytesPerEntry       = (16BPP=2, 32BPP=4)
        //  PrimaryOrder        = *Ignored*
        //  PrimaryValueMax     = *Ignored*
        //  ColorTableEntries   = 3
        //  pColorTable         = Point to 3 DWORD RGB bit masks
        //

        ColorTriad.BytesPerPrimary   = 0;
        ColorTriad.BytesPerEntry     = 2;
        ColorTriad.ColorTableEntries = 3;
        SrcSI.SurfaceFormat          = BMF_16BPP;
        break;

    case 32:

        ColorTriad.BytesPerPrimary   = 0;
        ColorTriad.BytesPerEntry     = 4;
        ColorTriad.ColorTableEntries = 3;
        SrcSI.SurfaceFormat          = BMF_32BPP;
        break;

    case 24:
    default:

        //
        // 24BPP must has COLORTRIAD as
        //
        //  Type                = COLOR_TYPE_xxxx
        //  BytesPerPrimary     = 1
        //  BytesPerEntry       = 3;
        //  PrimaryOrder        = PRIMARY_ORDER_xxxx
        //  PrimaryValueMax     = 255
        //  ColorTableEntries   = 0
        //  pColorTable         = *Ignored*
        //

        ColorTriad.BytesPerEntry     = sizeof(RGBTRIPLE);
        ColorTriad.ColorTableEntries = 0;
        SrcSI.SurfaceFormat          = BMF_24BPP;
        break;
    }

    SrcSI.hSurface               = (ULONG_PTR)hMemDC;
    SrcSI.Flags                  = 0;
    SrcSI.ScanLineAlignBytes     = BMF_ALIGN_DWORD;
    SrcSI.Width                  = pSrcbih->biWidth;
    SrcSI.Height                 = pSrcbih->biHeight;
    SrcSI.ScanLineDelta          = GET_SCANLINEDELTA(pSrcbih);
    SrcSI.pPlane                 = GET_PPLANE(pSrcbih, SrcSI.ScanLineDelta);
    SrcSI.pColorTriad            = &ColorTriad;

    DestSI.hSurface              = (ULONG_PTR)'HTUI';
    DestSI.Flags                 = 0;
    DestSI.SurfaceFormat         = (BYTE)HTUI_HTSurf;
    DestSI.Width                 = Width;
    DestSI.Height                = Height;
    DestSI.ScanLineAlignBytes    = BMF_ALIGN_DWORD;
    DestSI.ScanLineDelta         = GET_SCANLINEDELTA(&HTUI_DIBInfo.bi);
    DestSI.pPlane                = HTUI_pHTBits +
                                   GET_SCAN0_OFFSET(&HTUI_DIBInfo.bi,
                                                    SrcSI.ScanLineDelta);
    DestSI.pColorTriad           = NULL;


    BBP.Flags            = BBPF_USE_ADDITIVE_PRIMS;
    BBP.DestPrimaryOrder = PRIMARY_ORDER_BGR;

    BBP.rclSrc.left      =
    BBP.rclSrc.top       = 0;
    BBP.rclSrc.right     = (LONG)ABSL(SrcSI.Width);
    BBP.rclSrc.bottom    = (LONG)ABSL(SrcSI.Height);

    BBP.rclDest.left     = DestX;
    BBP.rclDest.top      = DestY;
    BBP.rclDest.right    = DestX + DestCX;
    BBP.rclDest.bottom   = DestY + DestCY;

    BBP.pAbort        = NULL;
    BBP.ptlBrushOrg.x =
    BBP.ptlBrushOrg.y = 0;

    GetColorAdjustment(hMemDC, &ColorAdjustment);

    Result = HT_HalftoneBitmap(HTUI_pDHI,
                               &ColorAdjustment,
                               &SrcSI,
                               NULL,
                               &DestSI,
                               &BBP);

    SetDIBitsToDevice(hMemDC,
                      0,
                      0,                                // Dest X, Y
                      Width,                            // DIB cx
                      Height,                           // DIB cy
                      0,
                      0,                                // DIB origin
                      0,
                      Height,                           // total Scan
                      HTUI_pHTBits,                     // lpBits
                      (LPBITMAPINFO)&HTUI_DIBInfo,
                      HTUI_DIBMode);

    return(Result);

}

#endif



LRESULT
APIENTRY
TopWndHookProc(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{

    if (Msg == WM_PALETTECHANGED) {

        PostMessage(hWndUIDlg, WM_PALETTECHANGED, wParam, lParam);
    }

    return(CallWindowProc(WndProcUITop, hWnd, Msg, wParam, lParam));
}


//
//************************ START HELP STUFF *****************************
//


HTHELPID    HTSetupHelpID[] = {

        { IDD_HTDEV_DEVICE_NAME         ,IDH_HTDEV_DEVICE_NAME      },
        { IDD_HTDEV_DEVICE_TITLE        ,IDH_HTDEV_DEVICE_NAME      },
        { IDD_HTDEV_HTPAT_COMBO         ,IDH_HTDEV_HTPAT            },
        { IDD_HTDEV_HTPAT_TITLE         ,IDH_HTDEV_HTPAT            },
        { IDD_HTDEV_PIXEL_TEXT          ,IDH_HTDEV_PIXEL_DIAMETER   },
        { IDD_HTDEV_PIXEL_TITLE         ,IDH_HTDEV_PIXEL_DIAMETER   },
        { IDD_HTDEV_PIXEL_SCROLL        ,IDH_HTDEV_PIXEL_DIAMETER   },
        { IDD_HTDEV_R_GAMMA_TEXT        ,IDH_HTDEV_DEV_RED_GAMMA    },
        { IDD_HTDEV_G_GAMMA_TEXT        ,IDH_HTDEV_DEV_GREEN_GAMMA  },
        { IDD_HTDEV_B_GAMMA_TEXT        ,IDH_HTDEV_DEV_BLUE_GAMMA   },
        { IDD_HTDEV_DEV_GAMMA_TITLE     ,IDH_HTDEV_DEV_GAMMA        },
        { IDD_HTDEV_R_GAMMA_NAME        ,IDH_HTDEV_DEV_RED_GAMMA    },
        { IDD_HTDEV_G_GAMMA_NAME        ,IDH_HTDEV_DEV_GREEN_GAMMA  },
        { IDD_HTDEV_B_GAMMA_NAME        ,IDH_HTDEV_DEV_BLUE_GAMMA   },
        { IDD_HTDEV_R_GAMMA_SCROLL      ,IDH_HTDEV_DEV_RED_GAMMA    },
        { IDD_HTDEV_G_GAMMA_SCROLL      ,IDH_HTDEV_DEV_GREEN_GAMMA  },
        { IDD_HTDEV_B_GAMMA_SCROLL      ,IDH_HTDEV_DEV_BLUE_GAMMA   },
        { IDD_HTDEV_R_CIE_TITLE         ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_G_CIE_TITLE         ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_B_CIE_TITLE         ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_C_CIE_TITLE         ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_M_CIE_TITLE         ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_Y_CIE_TITLE         ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_W_CIE_TITLE         ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_CIE_GROUPBOX        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_R_CIE_x_TEXT        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_G_CIE_x_TEXT        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_B_CIE_x_TEXT        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_C_CIE_x_TEXT        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_M_CIE_x_TEXT        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_Y_CIE_x_TEXT        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_W_CIE_x_TEXT        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_R_CIE_x_SCROLL      ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_G_CIE_x_SCROLL      ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_B_CIE_x_SCROLL      ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_C_CIE_x_SCROLL      ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_M_CIE_x_SCROLL      ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_Y_CIE_x_SCROLL      ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_W_CIE_x_SCROLL      ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_R_CIE_x_NAME        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_G_CIE_x_NAME        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_B_CIE_x_NAME        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_C_CIE_x_NAME        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_M_CIE_x_NAME        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_Y_CIE_x_NAME        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_W_CIE_x_NAME        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_R_CIE_y_TEXT        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_G_CIE_y_TEXT        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_B_CIE_y_TEXT        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_C_CIE_y_TEXT        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_M_CIE_y_TEXT        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_Y_CIE_y_TEXT        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_W_CIE_y_TEXT        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_R_CIE_y_SCROLL      ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_G_CIE_y_SCROLL      ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_B_CIE_y_SCROLL      ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_C_CIE_y_SCROLL      ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_M_CIE_y_SCROLL      ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_Y_CIE_y_SCROLL      ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_W_CIE_y_SCROLL      ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_R_CIE_y_NAME        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_G_CIE_y_NAME        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_B_CIE_y_NAME        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_C_CIE_y_NAME        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_M_CIE_y_NAME        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_Y_CIE_y_NAME        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_W_CIE_y_NAME        ,IDH_HTDEV_RGBW_CIE_XY      },
        { IDD_HTDEV_W_CIE_L_GROUPBOX    ,IDH_HTDEV_ALIGNMENT_WHITE  },
        { IDD_HTDEV_W_CIE_L_TEXT        ,IDH_HTDEV_ALIGNMENT_WHITE  },
        { IDD_HTDEV_W_CIE_L_NAME        ,IDH_HTDEV_ALIGNMENT_WHITE  },
        { IDD_HTDEV_W_CIE_L_SCROLL      ,IDH_HTDEV_ALIGNMENT_WHITE  },
        { IDD_HTDEV_DYE_GROUPBOX        ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_M_IN_C_TEXT         ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_Y_IN_C_TEXT         ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_C_IN_M_TEXT         ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_Y_IN_M_TEXT         ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_C_IN_Y_TEXT         ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_M_IN_Y_TEXT         ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_M_IN_C_SCROLL       ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_Y_IN_C_SCROLL       ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_C_IN_M_SCROLL       ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_Y_IN_M_SCROLL       ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_C_IN_Y_SCROLL       ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_M_IN_Y_SCROLL       ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_CYAN_NAME           ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_CYAN_M_EQAUL        ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_CYAN_M_PERCENT      ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_CYAN_Y_EQUAL        ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_CYAN_Y_PERCENT      ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_MAGENTA_NAME        ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_MAGENTA_C_EQAUL     ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_MAGENTA_C_PERCENT   ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_MAGENTA_Y_EQUAL     ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_MAGENTA_Y_PERCENT   ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_YELLOW_NAME         ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_YELLOW_C_EQAUL      ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_YELLOW_C_PERCENT    ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_YELLOW_M_EQUAL      ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_YELLOW_M_PERCENT    ,IDH_HTDEV_CMY_DYE_PERCENT  },
        { IDD_HTDEV_DEFAULT             ,IDH_HTDEV_DEFAULT          },
        { IDD_HTDEV_REVERT              ,IDH_HTDEV_REVERT           },
        { IDOK                          ,IDH_HTDEV_OK               },
        { IDCANCEL                      ,IDH_HTDEV_CANCEL           }
    };


HTHELPID    HTClrHelpID[] = {

        { IDD_HT_CONTRAST_TITLE,        IDH_HTCLR_CONTRAST          },
        { IDD_HT_CONTRAST_INT,          IDH_HTCLR_CONTRAST          },
        { IDD_HT_CONTRAST_SCROLL,       IDH_HTCLR_CONTRAST          },
        { IDD_HT_BRIGHTNESS_TITLE,      IDH_HTCLR_BRIGHTNESS        },
        { IDD_HT_BRIGHTNESS_INT,        IDH_HTCLR_BRIGHTNESS        },
        { IDD_HT_BRIGHTNESS_SCROLL,     IDH_HTCLR_BRIGHTNESS        },
        { IDD_HT_COLOR_TITLE,           IDH_HTCLR_COLOR             },
        { IDD_HT_COLORFULNESS_INT,      IDH_HTCLR_COLOR             },
        { IDD_HT_COLORFULNESS_SCROLL,   IDH_HTCLR_COLOR             },
        { IDD_HT_TINT_TITLE,            IDH_HTCLR_TINT              },
        { IDD_HT_RG_TINT_INT,           IDH_HTCLR_TINT              },
        { IDD_HT_RG_TINT_SCROLL,        IDH_HTCLR_TINT              },
        { IDD_HT_LOG_FILTER,            IDH_HTCLR_DARK_PIC          },
        { IDD_HT_NEGATIVE,              IDH_HTCLR_NEGATIVE          },
        { IDD_HT_ILLUMINANT_TITLE,      IDH_HTCLR_ILLUMINANT        },
        { IDD_HT_ILLUMINANT_COMBO,      IDH_HTCLR_ILLUMINANT        },
        { IDD_HT_LINEAR_GAMMA,          IDH_HTCLR_LINEAR_GAMMA      },
        { IDD_HT_SYNC_R,                IDH_HTCLR_SYNC_R_CHKBOX     },
        { IDD_HT_R_GAMMA_INT,           IDH_HTCLR_RED_GAMMA         },
        { IDD_HT_R_GAMMA_SCROLL,        IDH_HTCLR_RED_GAMMA         },
        { IDD_HT_SYNC_G,                IDH_HTCLR_SYNC_G_CHKBOX     },
        { IDD_HT_G_GAMMA_INT,           IDH_HTCLR_GREEN_GAMMA       },
        { IDD_HT_G_GAMMA_SCROLL,        IDH_HTCLR_GREEN_GAMMA       },
        { IDD_HT_SYNC_B,                IDH_HTCLR_SYNC_B_CHKBOX     },
        { IDD_HT_B_GAMMA_INT,           IDH_HTCLR_BLUE_GAMMA        },
        { IDD_HT_B_GAMMA_SCROLL,        IDH_HTCLR_BLUE_GAMMA        },
        { IDD_HT_REF_BLACK_TITLE,       IDH_HTCLR_BLACK_REF         },
        { IDD_HT_REF_BLACK_INT,         IDH_HTCLR_BLACK_REF         },
        { IDD_HT_REF_BLACK_SCROLL,      IDH_HTCLR_BLACK_REF         },
        { IDD_HT_REF_WHITE_TITLE,       IDH_HTCLR_WHITE_REF         },
        { IDD_HT_REF_WHITE_INT,         IDH_HTCLR_WHITE_REF         },
        { IDD_HT_REF_WHITE_SCROLL,      IDH_HTCLR_WHITE_REF         },
        { IDD_HT_BMP_TITLE,             IDH_HTCLR_PICTURE_NAME      },
        { IDD_HT_SHOW_COMBO,            IDH_HTCLR_PICTURE_NAME      },
        { IDD_HT_PIC_NAME,              IDH_HTCLR_PICTURE_DESC      },
        { IDD_HT_HALFTONE_DESC,         IDH_HTCLR_PICTURE_DESC      },
        { IDD_HT_BMP_TEST,              IDH_HTCLR_VIEW              },
        { IDD_HT_ZOOM,                  IDH_HTCLR_MAXIMIZE          },
        { IDD_HT_PALETTE,               IDH_HTCLR_PALETTE           },
        { IDD_HT_ASPECT_RATIO,          IDH_HTCLR_SCALE             },
        { IDD_HT_MIRROR,                IDH_HTCLR_FLIP_X            },
        { IDD_HT_UPSIDEDOWN,            IDH_HTCLR_FLIP_Y            },
        { IDOK,                         IDH_HTCLR_OK                },
        { IDCANCEL,                     IDH_HTCLR_CANCEL            },
        { IDD_HT_DEFAULT,               IDH_HTCLR_DEFAULT           },
        { IDD_HT_RESET,                 IDH_HTCLR_REVERT            },
        { IDD_HT_OPEN,                  IDH_HTCLR_OPEN              },
        { IDD_HT_SAVE_AS,               IDH_HTCLR_SAVE_AS           }
    };




VOID
DoHalftoneHelp(
    HWND    hDlg,
    HWND    hWndHelp,
    UINT    HelpType,
    UINT    HelpCmd,
    DWORD   MousePos
    )

/*++

Routine Description:

    This fucntion take current help window where user clik the right mouse
    button and do a context help


Arguments:

    hDlg        - Handle to the dialog box

    hWndHelp    - The control window which user clik the right mouse button or
                  drag the help button to it.

    HelpType    - HELP_TYPE_xxx, it either halftone color adjustment help or
                  halftone setup help

    HelpCmd     - How to help, it either a right click or help cursor button

    MousePos    - The mouse position for the right click or help cursor drag.


Return Value:

    VOID


Author:

    05-Mar-1996 Tue 15:56:27 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND            hWndTmp;
    PHTHELPID       pHTHelpID;
    UINT            cHTHelpID;
    POINT           pt;
    DWORD           HelpID[4];
    ULONG_PTR       dwData;
    WORD            DlgID;
    WCHAR           HelpFile[MAX_PATH];

    //
    // Convert the mouse position from screen to the client window
    //

    pt.x = LOWORD(MousePos);
    pt.y = HIWORD(MousePos);

    ScreenToClient(hDlg, &pt);

    //
    // If the help is from the dialog, then find the control window in that
    // mouse position
    //

    if (hDlg == hWndHelp) {

        hWndHelp = ChildWindowFromPointEx(hDlg, pt, CWP_SKIPTRANSPARENT);
    }

    //
    // If cursor is not on any control window or the control window is frame
    // type (ie. no window ID for it) then exit now
    //

    if ((!hWndHelp) ||
        ((DlgID = (WORD)GetDlgCtrlID(hWndHelp)) == 0xFFFF)) {

        return;
    }

#if 0
    DbgPrint("\nhDlg=%08lx, hWndHelp=%08lx (%ld)", hDlg, hWndHelp, DlgID);
#endif

    switch (HelpType) {

    case HELP_TYPE_HTCLRADJ:

        cHTHelpID = (UINT)COUNT_ARRAY(HTClrHelpID);
        pHTHelpID = HTClrHelpID;
        break;

    case HELP_TYPE_HTSETUP:

        cHTHelpID = (UINT)COUNT_ARRAY(HTSetupHelpID);
        pHTHelpID = HTSetupHelpID;
        break;

    default:

        return;
    }

    //
    // Find the help ID based on the control window ID
    //

    HelpID[1] = 0;

    while (cHTHelpID--) {

        if (pHTHelpID->DlgID == DlgID) {

            HelpID[1] = (DWORD)pHTHelpID->HelpID;
#if 0
            DbgPrint("\nFind HelpID=%ld, HelpID's DlgID=%ld",
                        pHTHelpID->HelpID, pHTHelpID->DlgID);
#endif
            break;
        }

        pHTHelpID++;
    }

    //
    // If we cannot find the help ID for the control window then NO HELP
    //

    if (!HelpID[1]) {

        return;
    }

    //
    // We need to do this, since the substractive device (printer alike) only
    // has one gamma setting, (using only the RED GAMMA), opposit to the
    // additive devices which has red, green and blue gamma adjustment
    //

    if ((HelpID[1] == IDH_HTDEV_DEV_RED_GAMMA)  &&
        (!GetDlgItem(hDlg, IDD_HTDEV_B_GAMMA_SCROLL))) {

        HelpID[1] = IDH_HTDEV_DEV_GAMMA;
#if 0
        DbgPrint("\nIDH_HTDEV_DEV_RED_GAMMA: No BLUE scroll, use IDH_HTDEV_DEV_GAMMA");
#endif
    }

    //
    // load the help file form the resource, if failed then use static one
    //

    if (!LoadString(hHTUIModule,
                    IDS_HELP_FILENAME,
                    HelpFile,
                    COUNT_ARRAY(HelpFile) - 1)) {

        lstrcpy(HelpFile, L"Halftone.Hlp");
    }

    //
    // Try to pop-up help on the right click position, where we will create
    // a temp button window and do the help, this way we can do context
    // sensitive help on any type of window (static, icon) and even it is
    // disabled.  We need to destroy this temp window before we exit from
    // this fucntion
    //

    if (hWndTmp = CreateWindowEx(WS_EX_NOPARENTNOTIFY | WS_EX_CONTEXTHELP,
                                 L"button",
                                 L"",
                                 WS_CHILD | BS_CHECKBOX,
                                 pt.x,
                                 pt.y,
                                 1,
                                 1,
                                 hDlg,
                                 (HMENU)TMP_HELP_WND_ID,
                                 hHTUIModule,
                                 0)) {

        hWndHelp = hWndTmp;
    }

    HelpID[0] = GetWindowLong(hWndHelp, GWL_ID);
    HelpID[2] =
    HelpID[3] = 0;

    switch (HelpCmd) {

    case HELP_WM_HELP:

        if ((!HelpID[0]) || (!HelpID[1])) {

            HelpCmd  = HELP_CONTENTS;
            hWndHelp = hDlg;
            dwData   = 0;
            break;
        }

    case HELP_CONTEXTMENU:

        SetWindowContextHelpId(hWndHelp, HelpID[1]);
        dwData = (ULONG_PTR)&HelpID[0];
        break;

    case HELP_CONTEXT:
    case HELP_CONTEXTPOPUP:

        dwData = HelpID[1];
        break;

    default:

        dwData = 0;
        break;
    }

    //
    // Try Winhelp now
    //

    WinHelp(hWndHelp, HelpFile, HelpCmd, dwData);

    //
    // If we do create a temp. button window, we need to destroy it
    //

    if (hWndTmp) {

        DestroyWindow(hWndTmp);
    }
}

//
//************************ END HELP STUFF ********************************
//



UINT
GetSaveDefDIBFileName(
    HWND    hDlg,
    LPWSTR  pFileName,
    UINT    SizeFileName
    )
{
    LPWSTR  pName;
    WCHAR   KeyName[64];
    WCHAR   ch;


    if (hDlg) {

        LoadString(hHTUIModule,
                   IDS_INI_KEY_BITMAP,
                   KeyName,
                   COUNT_ARRAY(KeyName));

        if (SizeFileName) {

            GetProfileString(HTClrAdjSectionName,
                             KeyName,
                             L"",
                             pFileName,
                             SizeFileName);

        } else {

            WriteProfileString(HTClrAdjSectionName, KeyName, pFileName);
        }
    }

    if (pFileName) {

        if (SizeFileName = wcslen(pFileName)) {

            pName = pFileName + SizeFileName;

            while ((pName > pFileName)              &&
                   ((ch = *(pName - 1)) != L'\\')   &&
                   (ch != L'/')                     &&
                   (ch != L':')) {

                --pName;
            }

            SizeFileName = (UINT)(pName - pFileName);
        }

        return(SizeFileName);

    } else {

        return(0);
    }
}


//
// Load current setting from win.ini
//


VOID
LoadHTCLRADJPARAMToWININI(
    HWND            hDlg,
    PHTCLRADJPARAM  pHTClrAdjParam
    )
{
    LPWSTR  pStop;
    SIZEL   DlgSize;
    SIZEL   MinVisible;
    SIZEL   Scr;
    RECT    rcBmp;
    RECT    rcDlg;
    WCHAR   KeyName[64];
    WCHAR   Buf[130];


    GetWindowText(hDlg, HTClrAdjSectionName, COUNT_ARRAY(HTClrAdjSectionName));
    GetWindowRect(hDlg, &rcDlg);

    //
    // Default always, and the last DIB is not loaded yet
    //

    if (pHTClrAdjParam->pCallerTitle) {

        wsprintf(Buf, L"%s: %s", HTClrAdjSectionName,
                                 pHTClrAdjParam->pCallerTitle);
        SetWindowText(hDlg, Buf);
    }

    DlgSize.cx = rcDlg.right - rcDlg.left;
    DlgSize.cy = rcDlg.bottom - rcDlg.top;

    LoadString(hHTUIModule,
               IDS_INI_KEY_OPTIONS,
               KeyName,
               COUNT_ARRAY(KeyName));

    if (GetProfileString(HTClrAdjSectionName,
                         KeyName,
                         L"\0",
                         Buf,
                         COUNT_ARRAY(Buf))) {

        pHTClrAdjParam->BmpFlags = (WORD)wcstol(Buf, &pStop, 16) &
                                   (WORD)(HT_BMP_PALETTE         |
                                          HT_BMP_SCALE           |
                                          HT_BMP_AUTO_MOVE       |
                                          HT_BMP_AT_TOP          |
                                          HT_BMP_MIRROR          |
                                          HT_BMP_UPSIDEDOWN      |
                                          HT_BMP_ENABLE          |
                                          HT_BMP_ZOOM            |
                                          HT_BMP_SYNC_R          |
                                          HT_BMP_SYNC_G          |
                                          HT_BMP_SYNC_B);

    } else {

        pHTClrAdjParam->BmpFlags = (WORD)(HT_BMP_SYNC_R     |
                                          HT_BMP_SYNC_G     |
                                          HT_BMP_SYNC_B     |
                                          HT_BMP_SCALE      |
                                          HT_BMP_AUTO_MOVE  |
                                          HT_BMP_ENABLE);
    }

    pHTClrAdjParam->BmpFlags |= HT_BMP_AUTO_MOVE;

    Scr.cx  = (LONG)GetSystemMetrics(SM_CXSCREEN);
    Scr.cy  = (LONG)GetSystemMetrics(SM_CYSCREEN);

    //
    // Assume that dialog box must be center
    //

    rcDlg.left   = (LONG)((Scr.cx - DlgSize.cx) / 2);
    rcDlg.top    = (LONG)((Scr.cy - DlgSize.cy) / 2);

    LoadString(hHTUIModule,
               IDS_INI_KEY_DLGBOX_ORG,
               KeyName,
               COUNT_ARRAY(KeyName));

    if (GetProfileString(HTClrAdjSectionName,
                         KeyName,
                         L"\0",
                         Buf,
                         COUNT_ARRAY(Buf))) {

        rcDlg.left = wcstol(Buf,   &pStop, 10);
        rcDlg.top  = wcstol(pStop, &pStop, 10);
    }

    MinVisible.cx = (LONG)(DlgSize.cx >> 1);
    MinVisible.cy  = (LONG)(GetSystemMetrics(SM_CYDLGFRAME) +
                            GetSystemMetrics(SM_CYCAPTION));

    if (rcDlg.left < -(DlgSize.cx - MinVisible.cx)) {

        rcDlg.left = -(DlgSize.cx - MinVisible.cx);

    } else if (rcDlg.left > (Scr.cx - MinVisible.cx)) {

        rcDlg.left = Scr.cx - MinVisible.cx;
    }

    if (rcDlg.top < 0) {

        rcDlg.top = 0;

    } else if (rcDlg.top > (Scr.cy - MinVisible.cy)) {

        rcDlg.top = Scr.cy - MinVisible.cy;
    }

    LoadString(hHTUIModule,
               IDS_INI_KEY_VIEW_RECT,
               KeyName,
               COUNT_ARRAY(KeyName));

    rcBmp.left = rcBmp.top = rcBmp.right = rcBmp.bottom = 0;

    if (GetProfileString(HTClrAdjSectionName,
                         KeyName,
                         L"\0",
                         Buf,
                         COUNT_ARRAY(Buf))) {

        rcBmp.left   = wcstol(Buf,   &pStop, 10);
        rcBmp.top    = wcstol(pStop, &pStop, 10);
        rcBmp.right  = wcstol(pStop, &pStop, 10);
        rcBmp.bottom = wcstol(pStop, &pStop, 10);

        switch(pHTClrAdjParam->ViewMode = (BYTE)wcstol(pStop, &pStop, 10)) {

        case VSRC_PIC_LOADED:
        case VSRC_REFCOLORS:
        case VSRC_RGB:
        case VSRC_NTSC_BAR:

            break;

        default:

            pHTClrAdjParam->ViewMode = DEFAULT_VSRC;
            break;
        }
    }

    MinVisible.cx = rcBmp.right  - rcBmp.left;
    MinVisible.cy = rcBmp.bottom - rcBmp.top;

    if ((MinVisible.cx < GetSystemMetrics(SM_CXMIN)) ||
        (MinVisible.cy < GetSystemMetrics(SM_CYMIN))) {

        //
        // Making default bitmap size, make sure that dialog box and bitmap
        // both are within the screen limit
        //

        LONG    cyBmp;


        cyBmp = (LONG)((DlgSize.cx * Scr.cy) / Scr.cx);

        if ((cyBmp + DlgSize.cy) > Scr.cy) {

            //
            // cannot fit that on the screen, so reduced the bitmap Y size
            //

            cyBmp = Scr.cy - DlgSize.cy;
        }

        rcBmp.top    = (LONG)((Scr.cy - DlgSize.cy - cyBmp) / 2);
        rcBmp.bottom = rcBmp.top + cyBmp;
        rcBmp.left   = rcDlg.left;
        rcBmp.right  = rcBmp.left + DlgSize.cx;

        //
        // Move dialog box down
        //

        rcDlg.top = rcBmp.bottom;

    } else {

        if (MinVisible.cx > Scr.cx) {

            rcBmp.left    = 0;
            rcBmp.right   =
            MinVisible.cx = Scr.cx;
        }

        if (MinVisible.cy > Scr.cy) {

            rcBmp.top     = 0;
            rcBmp.bottom  =
            MinVisible.cy = Scr.cy;
        }
    }

    if ((MinVisible.cx == Scr.cx) &&
        (MinVisible.cy == Scr.cy)) {

        pHTClrAdjParam->BmpFlags |= HT_BMP_ZOOM;
    }

    rcDlg.right  = rcDlg.left + DlgSize.cx;
    rcDlg.bottom = rcDlg.top  + DlgSize.cy;

    pHTClrAdjParam->rcDlg = rcDlg;
    pHTClrAdjParam->rcBmp = rcBmp;
}




VOID
UpdateHTCLRADJPARAMToWININI(
    HWND            hDlg,
    PHTCLRADJPARAM  pHTClrAdjParam
    )
{
    WORD    ViewSrc;
    WCHAR   KeyName[64];
    WCHAR   Buf[64];



    LoadString(hHTUIModule,
               IDS_INI_KEY_DLGBOX_ORG,
               KeyName,
               COUNT_ARRAY(KeyName));
    wsprintf(Buf, L"%ld %ld", (LONG)pHTClrAdjParam->rcDlg.left,
                              (LONG)pHTClrAdjParam->rcDlg.top);
    WriteProfileString(HTClrAdjSectionName, KeyName, Buf);

    switch(ViewSrc = (WORD)pHTClrAdjParam->ViewMode) {

    case VSRC_PIC_LOADED:
    case VSRC_REFCOLORS:
    case VSRC_RGB:
    case VSRC_NTSC_BAR:

        break;

    default:

        ViewSrc = DEFAULT_VSRC;
        break;
    }

    LoadString(hHTUIModule,
               IDS_INI_KEY_VIEW_RECT,
               KeyName,
               COUNT_ARRAY(KeyName));
    wsprintf(Buf, L"%ld %ld  %ld %ld  %u",
             pHTClrAdjParam->rcBmp.left,    pHTClrAdjParam->rcBmp.top,
             pHTClrAdjParam->rcBmp.right,   pHTClrAdjParam->rcBmp.bottom,
             (INT)ViewSrc);

    WriteProfileString(HTClrAdjSectionName, KeyName, Buf);

    LoadString(hHTUIModule,
               IDS_INI_KEY_OPTIONS,
               KeyName,
               COUNT_ARRAY(KeyName));
    wsprintf(Buf, L"0x%04x", (UINT)pHTClrAdjParam->BmpFlags);
    WriteProfileString(HTClrAdjSectionName, KeyName, Buf);
}





HANDLE
MakeTestDIB(
    UINT    TestDIBIndex
    )

/*++

Routine Description:

    This function take TESTDIBINFO data structure and use that information
    to make up a DIB

Arguments:

    pTestDIBInfo


Return Value:


    HANDLE to the DIB if ok, NULL if failed, this function will only make
    one dib per TESTDIBINFO.


Author:

    02-Sep-1992 Wed 10:04:41 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HANDLE          hDIB;
    LPBITMAPINFO    pbi;
    LPBYTE          pbSrc;
    LPBYTE          pbDest;
    LPWORD          pRatioY;
    RGBQUAD FAR     *pRGBQ;
    TESTDIBINFO     TDInfo;
    DWORD           SizeI;
    DWORD           Size;
    DWORD           cxBytes;
    WORD            cy;
    WORD            RatioY[64];
    UINT            i;
    UINT            yLoop;



    if (TestDIBIndex > TDI_MAX_INDEX) {

        TestDIBIndex = TDI_RGBTEST;
    }

    TDInfo = TestDIBInfo[TestDIBIndex];


    if (hDIB = TDInfo.hDIB) {

        return(hDIB);                       // already make up
    }

    pRatioY = TDInfo.pRatioY;

    if (TDInfo.yStrips > 64) {

        TDInfo.yStrips = 64;
    }

    for (i = 0, cy = 0; i < (UINT)TDInfo.yStrips; i++) {

        RatioY[i] = (WORD)((((DWORD)TDInfo.cy * (DWORD)(*pRatioY++)) +
                            5000)/10000);
        cy      += RatioY[i];
    }

    if (!cy) {

        cy = TDInfo.cy;
    }

    cxBytes = (DWORD)ALIGN_BPP_DW(TDInfo.cx, TDInfo.bpp);
    SizeI   = (DWORD)cy * cxBytes;
    Size    = (DWORD)sizeof(BITMAPINFOHEADER) +
              (DWORD)(TDInfo.ClrUsed * sizeof(RGBQUAD)) + SizeI;

    if (hDIB = GlobalAlloc(GMEM_MOVEABLE, Size)) {

        pbi = (LPBITMAPINFO)GlobalLock(hDIB);

        //
        // make header
        //

        pbi->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
        pbi->bmiHeader.biWidth         = (LONG)TDInfo.cx;
        pbi->bmiHeader.biHeight        = (LONG)cy;
        pbi->bmiHeader.biPlanes        = 1;
        pbi->bmiHeader.biBitCount      = (WORD)TDInfo.bpp;
        pbi->bmiHeader.biCompression   = BI_RGB;
        pbi->bmiHeader.biSizeImage     = SizeI;
        pbi->bmiHeader.biXPelsPerMeter = 0;
        pbi->bmiHeader.biYPelsPerMeter = 0;
        pbi->bmiHeader.biClrUsed       =
        pbi->bmiHeader.biClrImportant  = TDInfo.ClrUsed;

        //
        // Compute and make up the color table
        //

        pRGBQ = (RGBQUAD FAR *)(pbi->bmiColors);

        if (TestDIBIndex == TDI_RGBTEST) {

            RGBQUAD rgbQ;

            rgbQ.rgbRed      =
            rgbQ.rgbGreen    =
            rgbQ.rgbBlue     = 255;
            rgbQ.rgbReserved = 0;

            //
            // Make up for first 6:6:6 (216) table
            //

            for (i = 0; i <= 215; i++) {

                if (rgbQ.rgbBlue == 255) {

                    rgbQ.rgbBlue = 0;

                    if (rgbQ.rgbGreen == 255) {

                        rgbQ.rgbGreen = 0;

                        if (rgbQ.rgbRed == 255) {

                            rgbQ.rgbRed = 0;

                        } else {

                            rgbQ.rgbRed += 51;
                        }

                    } else {

                        rgbQ.rgbGreen += 51;
                    }

                } else {

                     rgbQ.rgbBlue += 51;
                }

                *pRGBQ++ = rgbQ;
            }

            TDInfo.ClrUsed -= 216;
        }

        if (pbSrc = TDInfo.pPalette) {

            for (i = 0; i < (UINT)TDInfo.ClrUsed; i++) {

                pRGBQ->rgbRed      = *pbSrc++;
                pRGBQ->rgbGreen    = *pbSrc++;
                pRGBQ->rgbBlue     = *pbSrc++;
                pRGBQ->rgbReserved = 0;

                ++pRGBQ;
            }

        } else {

            pRGBQ += (UINT)TDInfo.ClrUsed;
        }

        //
        // Now make up the image
        //

        pbDest = (LPBYTE)pRGBQ;

        if (TDInfo.pBmp) {

            switch(TDInfo.bpp) {

            case 1:

                SizeI = (DWORD)((TDInfo.cx + 7) / 8);
                break;

            case 4:

                SizeI = (DWORD)((TDInfo.cx + 1) / 2);
                break;

            case 8:

                SizeI = (DWORD)TDInfo.cx;
                break;

            case 16:

                SizeI = (DWORD)TDInfo.cx * 2;
                break;
            }

            //
            // Since DIB is up-side down then we will go to end of the DIB
            //

            i       = (UINT)TDInfo.yStrips;
            pbSrc   = TDInfo.pBmp + (SizeI * (DWORD)(i - 1));

            while (i--) {

                yLoop = RatioY[i];

                while (yLoop--) {

                    CopyMemory(pbDest, pbSrc, SizeI);
                    pbDest += cxBytes;
                }

                pbSrc -= SizeI;
            }

        } else {

            pbi->bmiHeader.biClrUsed = 0;
        }

        TestDIBInfo[TestDIBIndex].hDIB = hDIB;

        GlobalUnlock(hDIB);
    }

    return(hDIB);
}


#if 0


HPALETTE
CreatePaletteFromDIB(
    PHTCLRADJPARAM  pHTClrAdjParam
    )

/*++

Routine Description:

    This function create a Palette from a handle to the DIB, it will check if
    the palette is realizable, if not then system palette is used.


Arguments:

    hDIB    - handle to the dib, if hDIB = NULL then it create the palette
              same as the one used by halftone VGA256 mode.

Return Value:

    HPALETTE    - NULL if failed


Author:

    03-Jun-1992 Wed 15:09:41 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HANDLE  hDIB;


    if (hDIB = pHTClrAdjParam->hCurDIB) {

        PHTBLT          pHTBlt;
        HDC             hDCScr;
        LPBITMAPINFO    pbi;
        LPLOGPALETTE    pPal;
        DWORD           Size;
        WORD            Colors;
        INT             BitsPerPel;


        pHTBlt     = GET_PHTBLT(pHTClrAdjParam);
        hDCScr     = GetDC(NULL);
        BitsPerPel = GetDeviceCaps(hDCScr, BITSPIXEL);
        ReleaseDC(NULL, hDCScr);

        if (BitsPerPel <= 4) {

            //
            // Assume no palette change be changed on system
            //

            pHTBlt->hBmpPal = NULL;

        } else {

            if (pHTBlt->hBmpPal) {

                pHTBlt->hBmpPal = (HANDLE)DeleteObject(pHTBlt->hBmpPal);

                HTUI_ASSERT("DeleteObject(hOldBmpPal)", pHTBlt->hBmpPal);

                pHTBlt->hBmpPal = NULL;
            }

            pbi = (LPBITMAPINFO)GlobalLock(hDIB);

            if (Colors = (WORD)pbi->bmiHeader.biClrUsed) {

                Size = (DWORD)(sizeof(LOGPALETTE) +
                       (DWORD)(Colors * sizeof(PALETTEENTRY)));

                if (pPal = (LPLOGPALETTE)LocalAlloc(LPTR, Size)) {

                    LPPALETTEENTRY  pPalEntry;
                    RGBQUAD FAR     *prgb;
                    RGBQUAD         rgb;


                    pPal->palVersion    = 0x300;
                    pPal->palNumEntries = Colors;
                    pPalEntry           = &(pPal->palPalEntry[0]);
                    prgb                = pbi->bmiColors;

                    while (Colors--) {

                        rgb = *prgb++;

                        pPalEntry->peRed   = rgb.rgbRed;
                        pPalEntry->peGreen = rgb.rgbGreen;
                        pPalEntry->peBlue  = rgb.rgbBlue;
                        pPalEntry->peFlags = 0;

                        ++pPalEntry;
                    }

                    pHTBlt->hBmpPal = CreatePalette(pPal);
                    pPal = (LPLOGPALETTE)LocalFree((HLOCAL)pPal);

                    HTUI_ASSERT("LocalFree(pLogPal)", pPal == NULL);
                }
            }

            GlobalUnlock(hDIB);
        }

        return(pHTBlt->hBmpPal);

    } else {

        return(NULL);
    }
}

#endif



HBITMAP
CopyMemBmp(
    PHTCLRADJPARAM  pHTClrAdjParam
    )

/*++

Routine Description:

    This function duplicate the memory bitmap and return a handle to the
    newly copied bitmap

Arguments:

    pHTClrAdjParam


Return Value:

    HBITMAP


Author:

    01-Sep-1992 Tue 11:50:54 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PHTBLT  pHTBlt;
    HDC     hDCScr;
    HDC     hDCMem;
    HBITMAP hMemBmp;
    BITMAP  Bmp;


    pHTBlt = GET_PHTBLT(pHTClrAdjParam);

    GetObject(pHTBlt->hMemBmp, sizeof(BITMAP), &Bmp);

    if (!(hDCScr = GetDC(NULL))) {

        return (NULL);
    }
    
    if (!(hDCMem  = CreateCompatibleDC(hDCScr))) {

        ReleaseDC(NULL, hDCScr);
        return (NULL);
    }

    if (!(hMemBmp = CreateCompatibleBitmap(hDCScr, Bmp.bmWidth, Bmp.bmHeight))) {

        DeleteDC(hDCMem);
        ReleaseDC(NULL, hDCScr);
        return (NULL);
    }

    ReleaseDC(NULL, hDCScr);

    //
    // Select the newly create bitmap in the compatible memory dc
    //

    hMemBmp = SelectObject(hDCMem, hMemBmp);

    BitBlt(hDCMem,         0, 0, Bmp.bmWidth, Bmp.bmHeight,
           pHTBlt->hDCMem, 0, 0,
           SRCCOPY);

    //
    // Select the old one back, and delete that DC, return the blt'd bitmap
    //

    hMemBmp = SelectObject(hDCMem, hMemBmp);

    DeleteDC(hDCMem);

    return(hMemBmp);
}



HANDLE
BMPToDIB(
    HPALETTE    hBmpPal,
    HBITMAP     hBitmap
    )
{
    HANDLE          hDIB = NULL;
    LPBITMAPINFO    pbi;
    HDC             hDC;
    BITMAP          Bmp;
    DWORD           BIMode;
    DWORD           Colors;
    DWORD           SizeH;
    DWORD           SizeI;


    GetObject(hBitmap, sizeof(BITMAP), &Bmp);

    if (Bmp.bmPlanes == 1) {

        switch(Bmp.bmBitsPixel) {

        case 1:
        case 4:
        case 8:

            BIMode = BI_RGB;
            Colors = (DWORD)(1L << Bmp.bmBitsPixel);
            break;

        case 16:

            BIMode = BI_BITFIELDS;
            Colors = 3;
            break;

        case 24:

            BIMode = BI_RGB;
            Colors = 0;
            break;

        default:

            return(NULL);
        }

        SizeH  = (DWORD)sizeof(BITMAPINFOHEADER) +
                 (DWORD)(Colors * sizeof(RGBQUAD));
        SizeI  = (DWORD)ALIGN_BPP_DW(Bmp.bmWidth, Bmp.bmBitsPixel) *
                 (DWORD)Bmp.bmHeight;

        if (hDIB = GlobalAlloc(GHND, (SizeH + SizeI))) {

            hDC = GetDC(NULL);
            if (!hDC) {

                GlobalFree(hDIB);
                return NULL;
            }

            pbi = GlobalLock(hDIB);

            pbi->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
            pbi->bmiHeader.biWidth         = Bmp.bmWidth;
            pbi->bmiHeader.biHeight        = Bmp.bmHeight;
            pbi->bmiHeader.biPlanes        = 1;
            pbi->bmiHeader.biBitCount      = Bmp.bmBitsPixel;
            pbi->bmiHeader.biCompression   = BIMode;
            pbi->bmiHeader.biSizeImage     = SizeI;
            pbi->bmiHeader.biXPelsPerMeter = 0;
            pbi->bmiHeader.biYPelsPerMeter = 0;

            SelectPalette(hDC, hBmpPal, FALSE);
            RealizePalette(hDC);

            GetDIBits(hDC,
                      hBitmap,
                      0,
                      Bmp.bmHeight,
                      (LPBYTE)pbi + SizeH,
                      pbi,
                      DIB_RGB_COLORS);

            pbi->bmiHeader.biClrUsed       =
            pbi->bmiHeader.biClrImportant  = Colors;

            GlobalUnlock(hDIB);
            ReleaseDC(NULL, hDC);
        }
    }

    return(hDIB);

}






HANDLE
ReadDIBFile(
    HANDLE  hFile
    )

/*++

Routine Description:

    This function read the file in DIB format and return a global HANDLE
    to it's BITMAPINFO and it also fill the BITMAPINFOHEADER at return.

    This function will work with both "old" (BITMAPCOREHEADER) and "new"
    (BITMAPINFOHEADER) bitmap formats, but will always return a
    "new" BITMAPINFO

Arguments:

    hFile       - Handle to the opened DIB file


Return Value:

    A handle to the BITMAPINFO of the DIB in the file if sucessful and it
    return NULL if failed.


Author:

    14-Nov-1991 Thu 18:22:08 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HANDLE              hDIB;
    LPBYTE              pDIB;
    RGBQUAD             FAR *pRGBQUAD;
    RGBTRIPLE           FAR *pRGBTRIPLE;
    BITMAPINFOHEADER    bi;
    BITMAPCOREHEADER    bc;
    DWORD               cx;
    DWORD               cy;
    DWORD               OffBits;
    DWORD               cbRead;
    DWORD               PalCount;
    DWORD               PalSize;
    WORD                BmpType;
    BYTE                Buf[sizeof(DWORD) + sizeof(WORD) * 2];
    BOOL                bcType = FALSE;
    BOOL                Ok = TRUE;


    SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

    //
    // typedef struct tagBITMAPFILEHEADER {
    //         WORD    bfType;
    //         DWORD   bfSize;
    //         WORD    bfReserved1;
    //         WORD    bfReserved2;
    //         DWORD   bfOffBits;
    // } BITMAPFILEHEADER, FAR *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;
    //
    // Since the BITMAPFILEHEADER is not dword aligned, we must make sure
    // it read in correct data, so we will read the data in fields
    //

    if ((!ReadFile(hFile, &BmpType, sizeof(WORD), &cbRead, NULL))   ||
        (cbRead != sizeof(WORD))                                    ||
        (!ISDIB(BmpType))                                           ||
        (!ReadFile(hFile, Buf, sizeof(Buf), &cbRead, NULL))             ||
        (cbRead != sizeof(Buf))                                         ||
        (!ReadFile(hFile, &OffBits, sizeof(OffBits), &cbRead, NULL))    ||
        (cbRead != sizeof(OffBits))                                     ||
        (!ReadFile(hFile, &bi, sizeof(bi), &cbRead, NULL))              ||
        (cbRead != sizeof(bi))) {

        return(NULL);
    }

    //
    // Check the nature (BITMAPINFO or BITMAPCORE) of the info. block
    // and extract the field information accordingly. If a BITMAPCOREHEADER,
    // transfer it's field information to a BITMAPINFOHEADER-style block
    //

    if (bi.biSize == sizeof(BITMAPCOREHEADER)) {

        bcType              = TRUE;
        bc                  = *(BITMAPCOREHEADER*)&bi;

        bi.biSize           = sizeof(BITMAPINFOHEADER);
        bi.biWidth          = (LONG)bc.bcWidth;
        bi.biHeight         = (LONG)bc.bcHeight;
        bi.biPlanes         = (WORD)bc.bcPlanes;
        bi.biBitCount       = (WORD)bc.bcBitCount;
        bi.biCompression    = (DWORD)BI_RGB;
        bi.biXPelsPerMeter  = 0;
        bi.biYPelsPerMeter  = 0;
        bi.biClrUsed        = (DWORD)(1L << bi.biBitCount);

        SetFilePointer(hFile,
                       (LONG)(sizeof(BITMAPCOREHEADER)-sizeof(BITMAPINFOHEADER)),
                       NULL,
                       FILE_CURRENT);

    } else if (bi.biSize != sizeof(BITMAPINFOHEADER)) {

        return(NULL);                       // unknown format
    }

    if ((bi.biPlanes != 1) ||
        (bi.biCompression == BI_RLE4) ||
        (bi.biCompression == BI_RLE8)) {

        return(NULL);                       // do not know how to do this
    }

    switch(bi.biBitCount) {

    case 1:
    case 4:
    case 8:

        PalCount = (DWORD)(1L << bi.biBitCount);

        if ((!bi.biClrUsed) ||
            (bi.biClrUsed > PalCount)) {

            bi.biClrUsed = PalCount;

        } else {

            PalCount = bi.biClrUsed;
        }

        break;

    case 16:
    case 32:

        if (bi.biCompression != BI_BITFIELDS) {

            return(NULL);
        }

        PalCount     = 3;
        bi.biClrUsed = 0;           // 3 DWORDs

        break;

    case 24:

        PalCount     =
        bi.biClrUsed = 0;

        break;

    default:

        return(NULL);
    }

    cx                = (DWORD)ABSL(bi.biWidth);
    cy                = (DWORD)ABSL(bi.biHeight);

    bi.biClrImportant = bi.biClrUsed;
    bi.biSizeImage    = (DWORD)ALIGN_BPP_DW(cx, bi.biBitCount) * cy;
    PalSize           = PalCount * sizeof(RGBQUAD);

    //
    // Allocate the header+palette
    //

    if (!(hDIB = GlobalAlloc(GHND, bi.biSize + PalSize + bi.biSizeImage))) {

        return(NULL);
    }

    pDIB = (LPBYTE)GlobalLock(hDIB);
    *(LPBITMAPINFOHEADER)pDIB = bi;

    if (PalCount) {

        pRGBQUAD = (RGBQUAD FAR *)(pDIB + bi.biSize);

        if (bcType) {

            //
            // Convert a old color table (3 byte RGBTRIPLEs) to a new color
            // table (4 byte RGBQUADs)
            //

            pRGBTRIPLE = (RGBTRIPLE FAR *)
                                (pDIB + bi.biSize +
                                 ((sizeof(RGBQUAD) -
                                   sizeof(RGBTRIPLE)) * PalCount));

            if ((!ReadFile(hFile,
                           pRGBTRIPLE,
                           sizeof(RGBTRIPLE) * PalCount,
                           &cbRead,
                           NULL)) ||
                (cbRead != sizeof(RGBTRIPLE) * PalCount)) {

                Ok = FALSE;

            } else {

                cbRead = PalCount;

                while (cbRead--) {

                    pRGBQUAD->rgbRed      = pRGBTRIPLE->rgbtRed;
                    pRGBQUAD->rgbGreen    = pRGBTRIPLE->rgbtGreen;
                    pRGBQUAD->rgbBlue     = pRGBTRIPLE->rgbtBlue;
                    pRGBQUAD->rgbReserved = 0;

                    ++pRGBQUAD;
                    ++pRGBTRIPLE;
                }
            }

        } else {

            Ok = ((ReadFile(hFile, pRGBQUAD, PalSize, &cbRead, NULL)) &&
                  (cbRead == PalSize));
        }
    }

    //
    // set it to the begining of the bitmap if it said so.
    //

    if ((Ok) && (OffBits)) {

        SetFilePointer(hFile, OffBits, NULL, FILE_BEGIN);
    }

    //
    // Read in the bitmap
    //

    if ((!Ok)                                   ||
        (!ReadFile(hFile,
                   pDIB + bi.biSize + PalSize,
                   bi.biSizeImage,
                   &cbRead,
                   NULL))                       ||
        (cbRead != bi.biSizeImage)) {

        Ok = FALSE;
    }

    GlobalUnlock(hDIB);

    if (!Ok) {

        GlobalFree(hDIB);
        hDIB = NULL;
    }

    return(hDIB);
}




HANDLE
CreateDIBFromFile(
    LPWSTR  pFile
    )

/*++

Routine Description:

    This function open a DIB file and create a MEMORY DIB, the memory handle
    contains BITMAPINFO/palette data and bits, this function will also read
    os/2 style bitmap. This functions also read GIF file

Arguments:

    pFile   - The DIB file name


Return Value:

    Return the handle to the created memory DIB if sucessful, NULL if
    failed.

Author:

    14-Nov-1991 Thu 18:13:21 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HCURSOR hCursorOld;
    HANDLE  hFile;
    HANDLE  hDIB;

    //
    // Open the file and read the DIB information
    //

    hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));


    hFile = CreateFile(pFile,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE) {

        hDIB = NULL;

    } else {

        if (!(hDIB = ReadDIBFile(hFile))) {

            hDIB = ReadGIFFile(hFile);       // try again with GIF file
        }

        CloseHandle(hFile);
    }

    SetCursor(hCursorOld);

    return(hDIB);
}




VOID
AdjustDlgZorder(
    PHTCLRADJPARAM  pHTClrAdjParam
    )
{
    HDWP    hDWP;
    HWND    hWndTop;
    HWND    hWndBot;
    HWND    hWndBmp;
    UINT    SWPMode;


    if ((hWndBmp = pHTClrAdjParam->hWndBmp) &&
        (IsWindowEnabled(hWndBmp))) {

        if (IS_BMP_AT_TOP(pHTClrAdjParam->BmpFlags)) {

            hWndBot = pHTClrAdjParam->hDlg;
            hWndTop = hWndBmp;
            SWPMode = SWP_NOMOVE        |
                      SWP_NOSIZE        |
                      SWP_NOOWNERZORDER;

        } else {

            hWndBot = hWndBmp;
            hWndTop = pHTClrAdjParam->hDlg;
            SWPMode = SWP_NOMOVE        |
                      SWP_NOSIZE        |
                      SWP_NOACTIVATE    |
                      SWP_NOOWNERZORDER;
        }

        hDWP = BeginDeferWindowPos(2);
        if (!hDWP) {
            return;
        }

        hDWP = DeferWindowPos(hDWP,
                              hWndTop, NULL,
                              0, 0, 0, 0, SWPMode ^ SWP_NOACTIVATE);
        if (!hDWP) {
            return;
        }


        hDWP = DeferWindowPos(hDWP,
                              hWndBot, hWndTop,
                              0, 0, 0, 0, SWPMode);
        if (!hDWP) {
            return;
        }

        EndDeferWindowPos(hDWP);
    }
}





VOID
SetBmpDescription(
    HWND                hDlg,
    LPBITMAPINFOHEADER  pbih,
    DWORD               cx,
    DWORD               cy,
    INT                 DlgID
    )

/*++

Routine Description:

    Set current dialog box title

Arguments:

    hDIB    - The DIB to set the description

Return Value:

    VOID

Author:

    02-Apr-1992 Thu 18:13:58 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPWSTR  pStr;
    WCHAR   Buf[82];


    Buf[0] = L'\0';

    if (cx) {

        if (DlgID == IDD_HT_HALFTONE_DESC) {

            Buf[0] =
            Buf[1] = L'-';
            Buf[2] = L'>';

            pStr = (LPWSTR)&Buf[3];

        } else {

            pStr = (LPWSTR)Buf;
        }

        pStr += wsprintf(pStr, L" %ldx%ld", cx, cy);

        if ((DlgID != IDD_HT_HALFTONE_DESC) && (pbih)) {

            if (pbih->biBitCount >= 16) {

                wsprintf(pStr, L", %ld bpp", pbih->biBitCount);

            } else {

                wsprintf(pStr, L", %ld @%ld",
                            pbih->biClrUsed, pbih->biBitCount);
            }
        }
    }

    SetDlgItemText(hDlg, DlgID, Buf);
}




BOOL
ReSizeBmpWindow(
    PHTCLRADJPARAM  pHTClrAdjParam
    )

/*++

Routine Description:

    This functions resize the bitmap window and hBitmap selected in the
    memory DC

Arguments:


    pHTClrAdjParam


Return Value:

    BOOL, true if final size changed


Author:

    31-Aug-1992 Mon 14:38:45 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hWnd;
    HDC     hDCWnd;
    BOOL    SizeChanged = FALSE;


    if (hWnd = pHTClrAdjParam->hWndBmp) {

        PHTBLT  pHTBlt;
        HDC     hDCMem;
        BITMAP  bmp;
        HBITMAP hBmpOld, hMemBmp;
        RECT    rcWnd;
        LONG    xSize;
        LONG    ySize;
        DWORD   biWidth;
        DWORD   biHeight;


        pHTBlt = GET_PHTBLT(pHTClrAdjParam);

        //
        // Only if we ever create this window
        //

        if (!(hDCMem = pHTBlt->hDCMem)) {

            hDCWnd          = GetDC(NULL);
            if (!hDCWnd) {

                return FALSE;
            }
            hDCMem          =
            pHTBlt->hDCMem  = CreateCompatibleDC(hDCWnd);
            if (!pHTBlt->hDCMem) {

                ReleaseDC(NULL, hDCWnd);
                return FALSE;
            }

            pHTBlt->hMemBmp = CreateCompatibleBitmap(hDCWnd, 1, 1);
            ReleaseDC(NULL, hDCWnd);

            if (!pHTBlt->hMemBmp) {

                DeleteDC(pHTBlt->hDCMem);
                pHTBlt->hDCMem = NULL;
                return FALSE;
            }
        }

        //
        // Find out the current size, left,top always 0 at here, this imply
        // that bottom, right is the size
        //

        GetClientRect(hWnd, &rcWnd);

        xSize = (LONG)rcWnd.right;
        ySize = (LONG)rcWnd.bottom;

        if ((pHTClrAdjParam->BmpFlags & HT_BMP_SCALE) &&
            (pHTClrAdjParam->hCurDIB)) {

            LPBITMAPINFOHEADER  pbih;
            LONG                xRatio;
            LONG                yRatio;

            pbih     = (LPBITMAPINFOHEADER)GlobalLock(pHTClrAdjParam->hCurDIB);
            biWidth  = ABSL(pbih->biWidth);
            biHeight = ABSL(pbih->biHeight);


            xRatio = (LONG)((xSize * 1000L) / biWidth);
            yRatio = (LONG)((ySize * 1000L) / biHeight);

            //
            // Using xRatio as final minimum ratio
            //

            if (xRatio <= yRatio) {

                //
                // Width size does not chagned, but height must scale
                //

                if ((ySize = (LONG)(((biHeight * xRatio) + 500L) /
                                                1000L)) > (LONG)rcWnd.bottom) {

                    ySize = (LONG)rcWnd.bottom;
                }

                rcWnd.top    = ((LONG)rcWnd.bottom - ySize) / 2;
                rcWnd.bottom = rcWnd.top + ySize;

            } else {

                //
                // Height size does not chagned, but width must scale
                //

                if ((xSize = (LONG)(((biWidth * yRatio) + 500L) /
                                                1000L)) > (LONG)rcWnd.right) {

                    xSize = (LONG)rcWnd.right;
                }

                rcWnd.left  = ((LONG)rcWnd.right - xSize) / 2;
                rcWnd.right = rcWnd.left + xSize;
            }

            GlobalUnlock(pHTClrAdjParam->hCurDIB);
        }

        if (!GetObject(pHTBlt->hMemBmp, sizeof(BITMAP), &bmp)) {

            return FALSE;
        }

        if ((xSize != bmp.bmWidth) || (ySize != bmp.bmHeight)) {

            //
            // Size of the final bitmap has changed
            //

            hDCWnd          = GetDC(NULL);
            if (!hDCWnd) {
                
                return FALSE;
            }
            
            hMemBmp = CreateCompatibleBitmap(hDCWnd, xSize, ySize);
            ReleaseDC(NULL, hDCWnd);
            if (!hMemBmp) {

                return FALSE;
            }

            hBmpOld = SelectObject(hDCMem, hMemBmp);
            if (!hBmpOld) {

                DeleteObject(hMemBmp);
                return FALSE;
            }

            pHTBlt->hMemBmp = hMemBmp;
            DeleteObject(hBmpOld);

            SetBmpDescription(pHTClrAdjParam->hDlg,
                              NULL,
                              xSize,
                              ySize,
                              IDD_HT_HALFTONE_DESC);

            SizeChanged = TRUE;
        }

        pHTBlt->rcMemBmp = rcWnd;
    }

    return(SizeChanged);
}




INT
FindViewSource(
    HWND    hDlg,
    LPWSTR  pNewString,
    WORD    ViewSrc,
    BOOL    Delete
    )

/*++

Routine Description:

    This functions return the zero based index number for a list box item
    which has CB_ITEMDATA set to the ItemData.

Arguments:

    hDlg        - Handle to the dialog box to search for.

    ViewSrc     - The view mode which was set to the ITEMDATA

    pNewString  - If not NULL then it will replace found index's string

    Select      - TRUE if this is the new selection

Return Value:

    it return a zero based index, if it can not find the ItemData passed it
    return 0

Author:

    22-Apr-1992 Wed 10:20:36 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    INT     Index = 0;
    INT     Count;
    BYTE    Buf[80];


    Count = (INT)SendDlgItemMessage(hDlg,
                                    IDD_HT_SHOW_COMBO,
                                    CB_GETCOUNT,
                                    (WPARAM)NULL,
                                    (LPARAM)NULL);

    while (Index < Count) {

        if ((WORD)SendDlgItemMessage(hDlg,
                                     IDD_HT_SHOW_COMBO,
                                     CB_GETITEMDATA,
                                     (WPARAM)Index,
                                     (LPARAM)NULL) == ViewSrc) {

            break;
        }

        ++Index;
    }

    if (pNewString) {

        if (Index >= Count) {

            Index       = (INT)(Count - VSRC_TEST_COUNT);
            *pNewString = (WCHAR)(Index + VSRC_LB_ID_START);
            ++Count;                                    // insert one more

        } else {

            SendDlgItemMessage(hDlg,
                               IDD_HT_SHOW_COMBO,
                               CB_GETLBTEXT,
                               (WPARAM)Index,
                               (LPARAM)Buf);

            *pNewString = Buf[0];

            SendDlgItemMessage(hDlg,
                               IDD_HT_SHOW_COMBO,
                               CB_DELETESTRING,
                               (WPARAM)Index,
                               (LPARAM)NULL);
        }

        Index = (INT)SendDlgItemMessage(hDlg,
                                        IDD_HT_SHOW_COMBO,
                                        CB_INSERTSTRING,
                                        (WPARAM)Index,
                                        (LPARAM)pNewString);

        SendDlgItemMessage(hDlg,
                           IDD_HT_SHOW_COMBO,
                           CB_SETITEMDATA,
                           (WPARAM)Index,
                           (LPARAM)ViewSrc);
        Delete = FALSE;
    }

    if (Index < Count) {

        SendDlgItemMessage(hDlg,
                           IDD_HT_SHOW_COMBO,
                           (Delete) ? CB_DELETESTRING : CB_SETCURSEL,
                           (WPARAM)Index,
                           (LPARAM)NULL);
        return(Index);

    } else {

        return(-1);
    }
}




BOOL
ChangeViewSource(
    HWND            hDlg,
    PHTCLRADJPARAM  pHTClrAdjParam,
    WORD            ViewSrc
    )
/*++

Routine Description:

    This function will pop up the file selection dialog box and let user to
    select a test bitmap (ie. either a DIB or GIF), then create the memory
    DIB based on the opened bitmap file.

Arguments:

    pHTClrAdjParam  - Pointer to the HTCLRADJPARAM


Return Value:

    BOOLEAN indicate if the DIB was created, if created the new DIB handle will
    be set in the pHTClrAdjParam->hCurDIB, otherwise nothing is modified.


Author:

    02-Apr-1992 Thu 18:13:58 created  -by-  Daniel Chou (danielc)


Revision History:

    02-Jun-1992 Tue 21:53:09 updated  -by-  Daniel Chou (danielc)
        1. Aligned FileName[] start at WORD boundary so the comdlg32.dll will
           not GP. (it will be a bug raised against comdlg32.dll)


--*/

{
    HANDLE              hDIB = NULL;
    LPBITMAPINFOHEADER  pbih;


    switch(ViewSrc) {

    case VSRC_PIC_DEF_DIB:

        hDIB = pHTClrAdjParam->hDefDIB;
        break;

    case VSRC_PIC_LOADED:

        if (!(hDIB = pHTClrAdjParam->hSrcDIB)) {

            //
            // The hSrcDIB is not loaded, go load the last time loaded picture
            //

            if (!(hDIB = GetNewDIBFromFile(pHTClrAdjParam, TRUE))) {

                //
                // The default picture (bitmap) file does not exist, we will
                // delete list box entry for default picture and switch to
                // default View MODE
                //

                FindViewSource(hDlg, NULL, VSRC_PIC_LOADED, TRUE);
                GetSaveDefDIBFileName(hDlg, NULL, 0);
            }
        }

        break;

    case VSRC_RGB:

        hDIB = MakeTestDIB(TDI_RGBTEST);
        break;

    case VSRC_REFCOLORS:

        hDIB = MakeTestDIB(TDI_REFCOLORS);
        break;

    case VSRC_NTSC_BAR:

        hDIB = MakeTestDIB(TDI_NTSC);
        break;

    }

    if (!hDIB) {

        hDIB = MakeTestDIB(TDI_DEFAULT);
        if (!hDIB) {

            return FALSE;
        }

        pHTClrAdjParam->ViewMode = 0xff;
        ViewSrc                  = DEFAULT_VSRC;
    }

    if (pHTClrAdjParam->ViewMode != (BYTE)ViewSrc) {

        FindViewSource(hDlg,
                       NULL,
                       pHTClrAdjParam->ViewMode = (BYTE)ViewSrc,
                       FALSE);
    }

    pbih = (LPBITMAPINFOHEADER)GlobalLock(pHTClrAdjParam->hCurDIB = hDIB);

    SetBmpDescription(hDlg,
                      pbih,
                      pbih->biWidth,
                      pbih->biHeight,
                      IDD_HT_PIC_NAME);

    GlobalUnlock(hDIB);

#if 0
    CreatePaletteFromDIB(pHTClrAdjParam);
#endif

    ReSizeBmpWindow(pHTClrAdjParam);

    pHTClrAdjParam->BmpNeedUpdate = 1;

    if (hDIB = TestDIBInfo[TDI_CLRPAL].hDIB) {

        pbih = (LPBITMAPINFOHEADER)GlobalLock(hDIB);
        pbih->biClrUsed = 0;
        GlobalUnlock(hDIB);
    }

    return(TRUE);
}




HANDLE
GetNewDIBFromFile(
    PHTCLRADJPARAM  pHTClrAdjParam,
    BOOL            Default
    )

/*++

Routine Description:

    This functions pop-up dialog box and ask a new dib, if file exist and
    user select ok then it create a new dib from the file.


Arguments:

    pHTClrAdjParam



Return Value:


    HANDLE to the DIB, NULL if not sucessful


Author:

    02-Sep-1992 Wed 12:53:21 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND            hDlg = pHTClrAdjParam->hDlg;
    HANDLE          hDIB;
    OPENFILENAME    ofn;
    BOOL            Ok;
    UINT            Index;
    WCHAR           ch;
    WCHAR           FileDlgTitle[96];
    WCHAR           FileName[84 + 164];



    FileName[0] = L'\0';
    FileName[1] = L'?';
    FileName[2] = VSRC_LB_ID_SEPARATOR;
    FileName[3] = L' ';

    if (Default) {

        Ok = TRUE;
        GetSaveDefDIBFileName(hDlg,
                              &FileName[4],
                              COUNT_ARRAY(FileName)-4);

    } else {

        LoadString(hHTUIModule,
                   IDS_FILEDLGTITLE,
                   FileDlgTitle,
                   COUNT_ARRAY(FileDlgTitle));

        Index = (UINT)(GetSaveDefDIBFileName(hDlg,
                                             &FileName[84],
                                             COUNT_ARRAY(FileName) - 84) + 84);

        wcscpy(&FileName[4], &FileName[Index]);     // copy filename over
        FileName[Index] = L'\0';                    // leave only path

        if (Index > 84) {

            switch (FileName[--Index]) {

            case L':':

                FileName[Index] = L'\0';
                break;

            case L'\\':
            case L'/':

                if (Index > 84) {

                    if (((ch = FileName[Index-1]) != L'\\') &&
                        (ch != L'/')                        &&
                        (ch != L'.')                        &&
                        (ch != L':')) {

                        FileName[Index] = L'\0';
                    }
                }

                break;

            default:

                break;
            }
        }

        ofn.lStructSize       = sizeof(OPENFILENAME);
        ofn.hwndOwner         = hDlg;
        ofn.hInstance         = hHTUIModule;
        ofn.lpstrFilter       = FileOpenExtFilter;
        ofn.lpstrCustomFilter = NULL;
        ofn.nMaxCustFilter    = 0;
        ofn.nFilterIndex      = 1;
        ofn.lpstrFile         = &FileName[4];
        ofn.nMaxFile          = COUNT_ARRAY(FileName) - 4;
        ofn.lpstrFileTitle    = NULL;
        ofn.lpstrInitialDir   = &FileName[84];
        ofn.lpstrTitle        = FileDlgTitle;
        ofn.Flags             = OFN_PATHMUSTEXIST   |
                                OFN_FILEMUSTEXIST   |
                                OFN_HIDEREADONLY;
        ofn.nFileOffset       = 0;
        ofn.nFileExtension    = 0;
        ofn.lpstrDefExt       = BmpExt;
        ofn.lCustData         = 0;
        ofn.lpfnHook          = NULL;
        ofn.lpTemplateName    = NULL;

        EnableWindow(pHTClrAdjParam->hWndBmp, FALSE);
        Ok = GetOpenFileName(&ofn);
        EnableWindow(pHTClrAdjParam->hWndBmp, TRUE);
    }

    //
    // Fall through
    //


    if ((!Ok) || (!(hDIB = CreateDIBFromFile(&FileName[4])))) {

        return(NULL);
    }

    Index = GetSaveDefDIBFileName(hDlg, &FileName[4], 0);
    wcscpy(&FileName[4], &FileName[Index + 4]);

    if (pHTClrAdjParam->hSrcDIB) {

        pHTClrAdjParam->hSrcDIB = GlobalFree(pHTClrAdjParam->hSrcDIB);

        HTUI_ASSERT("GlobalFree(hOldSrcDIB)", pHTClrAdjParam->hSrcDIB == NULL);
    }

    pHTClrAdjParam->hSrcDIB = hDIB;

    FindViewSource(hDlg, &FileName[1], VSRC_PIC_LOADED, FALSE);
    ChangeViewSource(pHTClrAdjParam->hDlg, pHTClrAdjParam, VSRC_PIC_LOADED);

    return(hDIB);
}





LRESULT
APIENTRY
HTClrAdjBmpWndProc(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PHTBLT              pHTBlt;
    HPALETTE            hCurPal;
    HPALETTE            hPalDlg;
    HPALETTE            hPalMem;
    HPALETTE            hPalDC;
    HWND                hDlg;
    HDC                 hDCMem;
    HDC                 hDC;
    PHTCLRADJPARAM      pHTClrAdjParam;
    PAINTSTRUCT         ps;
    SHORT               Colorfulness;
    SHORT               RedGreenTint;
    RECT                Rect;
    RECT                rcMemBmp;
    WORD                BmpFlags;
    WORD                Zoomed;


    pHTClrAdjParam = (PHTCLRADJPARAM)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    if ((!pHTClrAdjParam) ||
        (!IsWindowVisible(hWnd))) {

        //
        // nothing to do really
        //

        return(DefWindowProc(hWnd, Msg, wParam, lParam));
    }

    hDlg     = pHTClrAdjParam->hDlg;
    pHTBlt   = GET_PHTBLT(pHTClrAdjParam);
    BmpFlags = pHTClrAdjParam->BmpFlags;

    switch(Msg) {

    case WM_NCLBUTTONDOWN:

        lParam = DefWindowProc(hWnd, Msg, wParam, lParam);
        SetActiveWindow(hDlg);
        return(lParam);

    case WM_LBUTTONDOWN:

        if ((pHTClrAdjParam->Flags & HTCAPF_CAN_UPDATE) &&
            (!(BmpFlags & HT_BMP_ZOOM))) {

            POINT   pt;

            pt.x = (LONG)LOWORD(lParam);
            pt.y = (LONG)HIWORD(lParam);

            ClientToScreen(hWnd, &pt);

            SendMessage(hWnd,
                        WM_NCLBUTTONDOWN,
                        HTCAPTION,
                        MAKELPARAM(pt.x, pt.y));
        }

        break;

    case WM_NCRBUTTONDOWN:
    case WM_RBUTTONDOWN:

        if ((pHTClrAdjParam->Flags & HTCAPF_CAN_UPDATE) &&
            (BmpFlags & HT_BMP_ZOOM)) {

            pHTClrAdjParam->BmpFlags ^= HT_BMP_AT_TOP;
            AdjustDlgZorder(pHTClrAdjParam);
            SendMessage(hDlg, WM_COMMAND, (WPARAM)IDD_HT_BRING_TO_TOP, 0L);
        }

        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDD_HT_BRING_TO_TOP:

            AdjustDlgZorder(pHTClrAdjParam);
        }

        break;

    case WM_SIZE:

        if (ReSizeBmpWindow(pHTClrAdjParam)) {

            pHTClrAdjParam->BmpNeedUpdate = 1;
        }

    case WM_MOVE:

        if (!(BmpFlags & HT_BMP_ZOOM)) {

            GetWindowRect(hWnd, &(pHTClrAdjParam->rcBmp));
        }

        break;

    case WM_LBUTTONDBLCLK:

        pHTClrAdjParam->BmpFlags &= ~HT_BMP_AT_TOP;
        pHTClrAdjParam->BmpFlags ^= HT_BMP_ZOOM;

        BmpFlags = pHTClrAdjParam->BmpFlags;
        Zoomed   = (WORD)((BmpFlags & HT_BMP_ZOOM) ? 1 : 0);

        CheckDlgButton(hDlg, IDD_HT_ZOOM, Zoomed);

        SetClassLongPtr(hWnd,
                        GCLP_HCURSOR,
                        (LONG_PTR)LoadCursor(NULL, (Zoomed) ? IDC_NO : IDC_SIZEALL));

        if (Zoomed) {

            Rect.left   = -(LONG)GetSystemMetrics(SM_CXFRAME);
            Rect.top    = -(LONG)GetSystemMetrics(SM_CYFRAME);
            Rect.right  = (LONG)GetSystemMetrics(SM_CXSCREEN) - Rect.left;
            Rect.bottom = (LONG)GetSystemMetrics(SM_CYSCREEN) - Rect.top;

        } else {

            Rect = pHTClrAdjParam->rcBmp;
        }

        SetWindowPos(hWnd,
                     IS_BMP_AT_TOP(BmpFlags) ? NULL : hDlg,
                     Rect.left,
                     Rect.top,
                     Rect.right - Rect.left,
                     Rect.bottom - Rect.top,
                     SWP_DRAWFRAME | SWP_NOACTIVATE);
        break;

    case WM_PAINT:

        if (!(hDCMem = pHTBlt->hDCMem)) {

            ReSizeBmpWindow(pHTClrAdjParam);
            hDCMem = pHTBlt->hDCMem;
            if (!hDCMem) {

                return 0;
            }
        }

        GetClientRect(hWnd, &Rect);

        hDC      = BeginPaint(hWnd, &ps);
        rcMemBmp = pHTBlt->rcMemBmp;

        if (BmpFlags & HT_BMP_SCALE) {

            INT     SaveID = SaveDC(hDC);

            ExcludeClipRect(hDC,
                            rcMemBmp.left,
                            rcMemBmp.top,
                            rcMemBmp.right,
                            rcMemBmp.bottom);

            FillRect(hDC, &Rect, GetStockObject(HTCLRADJ_BK_BRUSH));

            RestoreDC(hDC, SaveID);
        }

#if 0
        hCurPal = (BmpFlags & HT_BMP_HALFTONE) ? pHTClrAdjParam->hHTPal :
                                                 pHTBlt->hBmpPal;
#else
        hCurPal = pHTClrAdjParam->hHTPal;
#endif

        if (hCurPal) {

            hPalDlg = SelectPalette(pHTClrAdjParam->hDCDlg, hCurPal, FALSE);
            RealizePalette(pHTClrAdjParam->hDCDlg);

            hPalMem = SelectPalette(pHTBlt->hDCMem, hCurPal, FALSE);
            RealizePalette(pHTBlt->hDCMem);

            hPalDC = SelectPalette(hDC, hCurPal, FALSE);
            RealizePalette(hDC);
        }

#if SCREEN_BLT
        pHTClrAdjParam->BmpNeedUpdate = 1;
#endif

        if (pHTClrAdjParam->BmpNeedUpdate) {

            HCURSOR             hCursorOld;
            HANDLE              hDIB;
            LPBITMAPINFOHEADER  pbih;
            DWORD               Rop;
            LONG                Tmp;
            INT                 StretchMode;


            hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));


            Rect.left   =
            Rect.top    = 0;
            Rect.right  = rcMemBmp.right - rcMemBmp.left;
            Rect.bottom = rcMemBmp.bottom - rcMemBmp.top;

#if SCREEN_BLT
            Rect   = rcMemBmp;
            hDCMem = hDC;
#endif

            //
            // 03-Feb-1999 Wed 01:30:03 updated  -by-  Daniel Chou (danielc)
            //  Fix Flip X, Y that we need to make right inclusive and left
            //  exclusive
            //

            if (BmpFlags & HT_BMP_MIRROR) {

                XCHG(Rect.left, Rect.right, Tmp);

                --Rect.left;
                --Rect.right;
            }

            if (BmpFlags & HT_BMP_UPSIDEDOWN) {

                XCHG(Rect.top, Rect.bottom, Tmp);

                --Rect.top;
                --Rect.bottom;
            }

            //
            // Check out the fill mode, default by using sources
            //

            Rop  = SRCCOPY;
            hDIB = pHTClrAdjParam->hCurDIB;
            pbih = (LPBITMAPINFOHEADER)GlobalLock(hDIB);

            if (BmpFlags & HT_BMP_PALETTE) {

                if (pbih->biBitCount >= 16) {

                    GlobalUnlock(hDIB);

                    hDIB = MakeTestDIB(TDI_RGBTEST);
                    pbih = (LPBITMAPINFOHEADER)GlobalLock(hDIB);

                } else {

                    HANDLE              hPalDIB;
                    LPBITMAPINFOHEADER  pbihPal;
                    LPBYTE              pBits;
                    UINT                cx;
                    UINT                cy;
                    UINT                SizeI;
                    UINT                xLoop;
                    DWORD               Colors;
                    BYTE                Data;


                    Colors  = pbih->biClrUsed;
                    hPalDIB = MakeTestDIB(TDI_CLRPAL);
                    pbihPal = GlobalLock(hPalDIB);

                    if (!pbihPal) {

                        goto CleanupWM_PAINT;
                    }

                    if (!pbihPal->biClrUsed) {

                        if (Colors <= 16) {

                            cx    =
                            cy    = 4;
                            SizeI = 16;

                        } else {

                            cx    =
                            cy    = 16;
                            SizeI = 256;
                        }

                        pbihPal->biWidth        = (LONG)cx;
                        pbihPal->biHeight       = (LONG)cy;
                        pbihPal->biSizeImage    = (DWORD)SizeI;
                        pbihPal->biClrUsed      =
                        pbihPal->biClrImportant = Colors;

                        CopyMemory((LPBYTE)pbihPal+sizeof(BITMAPINFOHEADER),
                                   (LPBYTE)pbih + sizeof(BITMAPINFOHEADER),
                                   Colors *= sizeof(RGBQUAD));

                        Data  = 0;
                        pBits = (LPBYTE)pbihPal +
                                sizeof(BITMAPINFOHEADER) +
                                Colors + (DWORD)SizeI - (DWORD)cx;
                        SizeI = cx + cx;

                        while (cy--) {

                            xLoop = cx;

                            while (xLoop--) {

                                *pBits++ = Data++;
                            }

                            pBits -= SizeI;
                        }
                    }

                    GlobalUnlock(hDIB);

                    hDIB = hPalDIB;
                    pbih = pbihPal;
                }
            }

#if 0
            if (BmpFlags & HT_BMP_HALFTONE) {

                StretchMode = HALFTONE;

            } else {

                StretchMode = COLORONCOLOR;

                if (pHTClrAdjParam->CurHTClrAdj.caFlags & CLRADJF_NEGATIVE) {

                    //
                    // It just cannot do negative, and we will just use this
                    //

                    Rop = NOTSRCCOPY;
                }
            }

            SetStretchBltMode(hDCMem, StretchMode);
#else
            SetStretchBltMode(hDCMem, StretchMode = HALFTONE);
#endif

            //
            // If adjust for monochrome device then make it so tempopary.
            //

            if (pHTClrAdjParam->Flags & HTCAPF_SHOW_MONO) {

                Colorfulness = pHTClrAdjParam->CurHTClrAdj.caColorfulness;
                RedGreenTint = pHTClrAdjParam->CurHTClrAdj.caRedGreenTint;

                pHTClrAdjParam->CurHTClrAdj.caColorfulness = COLOR_ADJ_MIN;
                pHTClrAdjParam->CurHTClrAdj.caRedGreenTint = 0;

                SetColorAdjustment(hDCMem, &(pHTClrAdjParam->CurHTClrAdj));

                pHTClrAdjParam->CurHTClrAdj.caColorfulness = Colorfulness;
                pHTClrAdjParam->CurHTClrAdj.caRedGreenTint = RedGreenTint;

            } else {

                SetColorAdjustment(hDCMem, &(pHTClrAdjParam->CurHTClrAdj));
            }

#ifdef HTUIX_STATIC_HALFTONE

            if (StretchMode == HALFTONE) {

                HTUI_StretchDIBits(hDCMem,
                                   Rect.left,
                                   Rect.top,
                                   Rect.right - Rect.left,
                                   Rect.bottom - Rect.top,
                                   0,
                                   0,
                                   pbih->biWidth,
                                   pbih->biHeight,
                                   (LPBYTE)pbih + PBIH_HDR_SIZE(pbih),
                                   (LPBITMAPINFO)pbih,
                                   DIB_RGB_COLORS,
                                   Rop);

            } else {

                StretchDIBits(hDCMem,
                              Rect.left,
                              Rect.top,
                              Rect.right - Rect.left,
                              Rect.bottom - Rect.top,
                              0,
                              0,
                              pbih->biWidth,
                              pbih->biHeight,
                              (LPBYTE)pbih + PBIH_HDR_SIZE(pbih),
                              (LPBITMAPINFO)pbih,
                              DIB_RGB_COLORS,
                              Rop);
            }

#else

#if 0
            if (!SetBrushOrgEx(hDCMem, MyXOrg, MyYOrg, NULL)) {

                DbgPrint("\nSetBrushOrgEx(%d, %d) failed", MyXOrg, MyYOrg);
            }
#endif
            StretchDIBits(hDCMem,
                          Rect.left,
                          Rect.top,
                          Rect.right - Rect.left,
                          Rect.bottom - Rect.top,
                          0,
                          0,
                          pbih->biWidth,
                          pbih->biHeight,
                          (LPBYTE)pbih + PBIH_HDR_SIZE(pbih),
                          (LPBITMAPINFO)pbih,
                          DIB_RGB_COLORS,
                          Rop);

            // DbgPrint("\nStretchDIBits()=%ld", GetLastError());
#endif

            pHTClrAdjParam->BmpNeedUpdate = 0;

            GlobalUnlock(hDIB);

            SetCursor(hCursorOld);
        }

        //
        // Now blt the result to the screen
        //

#if (SCREEN_BLT == 0)
        SetStretchBltMode(hDC, COLORONCOLOR);

        BitBlt(hDC,
               rcMemBmp.left,
               rcMemBmp.top,
               rcMemBmp.right - rcMemBmp.left,
               rcMemBmp.bottom - rcMemBmp.top,
               hDCMem,
               0,
               0,
               SRCCOPY);
#endif

    CleanupWM_PAINT:
        if (hCurPal) {

            SelectPalette(pHTClrAdjParam->hDCDlg,   hPalDlg, FALSE);
            SelectPalette(pHTBlt->hDCMem,           hPalMem, FALSE);
            SelectPalette(hDC,                      hPalDC,  FALSE);
        }

        EndPaint(hWnd, &ps);
        return(0);

    case WM_ERASEBKGND:

        return(1);

    default:

        return(DefWindowProc(hWnd, Msg, wParam, lParam));
    }

    SetActiveWindow(hDlg);
    return(0);
}




BOOL
SaveHalftonedDIB(
    HWND            hDlg,
    PHTCLRADJPARAM  pHTClrAdjParam
    )
/*++

Routine Description:

    This function will pop up the file selection dialog box and let user to
    select a test bitmap (ie. either a DIB or GIF), then create the memory
    DIB based on the opened bitmap file.

Arguments:

    pHTClrAdjParam  - Pointer to the HTCLRADJPARAM

Return Value:

    BOOLEAN indicate if the DIB was created, if created the new DIB handle will
    be set in the pHTClrAdjParam->hCurDIB, otherwise nothing is modified.


Author:

    02-Apr-1992 Thu 18:13:58 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PHTBLT              pHTBlt;
    HANDLE              hDIB;
    HANDLE              hFile;
    HCURSOR             hCursorOld;
    BITMAPFILEHEADER    bfh;
    WCHAR               Title[80];
    WCHAR               Buf[160];
    OPENFILENAME        ofn;
    DWORD               cbWritten;
    BOOL                Ok = FALSE;


    LoadString(hHTUIModule, IDS_SAVE_AS_DLGTITLE, Title, COUNT_ARRAY(Title));

    Buf[0]                = L'\0';

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hDlg;
    ofn.hInstance         = hHTUIModule;
    ofn.lpstrFilter       = FileSaveExtFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = Buf;
    ofn.nMaxFile          = COUNT_ARRAY(Buf);
    ofn.lpstrFileTitle    = NULL;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = Title,
    ofn.Flags             = OFN_CREATEPROMPT    |
                            OFN_OVERWRITEPROMPT |
                            OFN_HIDEREADONLY;
    ofn.nFileOffset       = 0;
    ofn.nFileExtension    = 0;
    ofn.lpstrDefExt       = BmpExt;
    ofn.lCustData         = 0;
    ofn.lpfnHook          = NULL;
    ofn.lpTemplateName    = NULL;

    EnableWindow(pHTClrAdjParam->hWndBmp, FALSE);

    if (GetSaveFileName(&ofn)) {

        hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
        pHTBlt     = GET_PHTBLT(pHTClrAdjParam);

        if ((hDIB = BMPToDIB(pHTClrAdjParam->hHTPal, pHTBlt->hMemBmp)) &&
            ((hFile = CreateFile(Buf,
                                 GENERIC_WRITE,
                                 0,
                                 NULL,
                                 CREATE_ALWAYS,
                                 FILE_FLAG_WRITE_THROUGH,
                                 NULL)) != INVALID_HANDLE_VALUE)) {

            LPBITMAPINFOHEADER  pbih;
            DWORD               HeaderSize;


            pbih       = (LPBITMAPINFOHEADER)GlobalLock(hDIB);
            HeaderSize = PBIH_HDR_SIZE(pbih);

            bfh.bfType      = (WORD)BFT_BITMAP;
            bfh.bfOffBits   = (DWORD)sizeof(bfh) + HeaderSize;
            bfh.bfSize      = bfh.bfOffBits + pbih->biSizeImage;
            bfh.bfReserved1 =
            bfh.bfReserved2 = (WORD)0;

            WriteFile(hFile,
                      &bfh,
                      sizeof(bfh),
                      &cbWritten,
                      NULL);

            WriteFile(hFile,
                      pbih,
                      pbih->biSizeImage + HeaderSize,
                      &cbWritten,
                      NULL);

            CloseHandle(hFile);

            GlobalUnlock(hDIB);
            Ok = TRUE;
        }

        if (hDIB) {

            hDIB = GlobalFree(hDIB);

            HTUI_ASSERT("GlobalFree(hSaveDIB)", hDIB == NULL);
        }

        SetCursor(hCursorOld);
    }

    EnableWindow(pHTClrAdjParam->hWndBmp, TRUE);

    return(Ok);
}




BOOL
CreateBmpWindow(
    PHTCLRADJPARAM  pHTClrAdjParam
    )
{
    HWND        hDlg;
    HWND        hWndBmp;
    WNDCLASS    WndClass;
    DWORD       WndStyle;
    RECT        rcBmp;


    if (pHTClrAdjParam->hWndBmp) {

        return(TRUE);
    }

    //
    // Firstable creat the class if one does not exist
    //

    pHTClrAdjParam->BmpNeedUpdate = 1;

    //
    // If we do not have permission then we will not allowed the user to
    // adjust the size of the viewing bitmap or moving the bitmap window
    //

    if (pHTClrAdjParam->Flags & HTCAPF_CAN_UPDATE) {

        WndClass.lpszClassName = L"HTClrAdjBmp";
        WndStyle               = WS_POPUP           |
                                    WS_BORDER       |
                                    WS_CLIPSIBLINGS |
                                    WS_THICKFRAME;
        WndClass.style         = CS_DBLCLKS     |
                                    CS_NOCLOSE  |
                                    CS_HREDRAW  |
                                    CS_VREDRAW;
        WndClass.hCursor       = LoadCursor(NULL, IDC_SIZEALL);

    } else {

        WndClass.lpszClassName = L"HTClrNoAdjBmp";
        WndStyle               = WS_POPUP | WS_BORDER | WS_CLIPSIBLINGS;
        WndClass.style         = CS_NOCLOSE | CS_HREDRAW | CS_VREDRAW;
        WndClass.hCursor       = LoadCursor(NULL, IDC_NO);
    }

    WndClass.lpfnWndProc   = HTClrAdjBmpWndProc;
    WndClass.cbClsExtra    = 0;
    WndClass.cbWndExtra    = 0;
    WndClass.hInstance     = hHTUIModule;
    WndClass.hIcon         = NULL;
    WndClass.hbrBackground = NULL;
    WndClass.lpszMenuName  = NULL;

    RegisterClass(&WndClass);

    hDlg  = pHTClrAdjParam->hDlg;
    rcBmp = pHTClrAdjParam->rcBmp;

    if (hWndBmp = CreateWindow(WndClass.lpszClassName,
                               L"",
                               WndStyle,
                               rcBmp.left,
                               rcBmp.top,
                               rcBmp.right  - rcBmp.left,
                               rcBmp.bottom - rcBmp.top,
                               GetParent(hDlg),
                               (HMENU)NULL,
                               hHTUIModule,
                               NULL)) {

        SetWindowLongPtr(pHTClrAdjParam->hWndBmp = hWndBmp,
                         GWLP_USERDATA,
                         (LONG_PTR)pHTClrAdjParam);

        pHTClrAdjParam->BmpFlags |= HT_BMP_ENABLE;

        ShowWindow(pHTClrAdjParam->hWndBmp, SW_SHOWNOACTIVATE);

        if (pHTClrAdjParam->BmpFlags & HT_BMP_ZOOM) {

            pHTClrAdjParam->BmpFlags &= (WORD)~HT_BMP_ZOOM;
            PostMessage(hWndBmp, WM_LBUTTONDBLCLK, 0, 0);
        }
    }

    return((hWndBmp) ? TRUE : FALSE);
}


BOOL
CALLBACK
DisableDlgUpdate(
    HWND    hWnd,
    LPARAM  lParam
    )
{
    UINT    DlgID;

    UNREFERENCED_PARAMETER(lParam);

    DlgID  = (UINT)GetDlgCtrlID(hWnd);

    EnableWindow(hWnd, (DlgID == IDOK) || (DlgID == IDCANCEL));
    return(TRUE);

}


VOID
EnableDlgGroup(
    HWND    hDlg,
    LPWORD  pwGroup,
    BOOL    Enabled
    )
{
    WORD    DlgID;


    while (DlgID = *pwGroup++) {

        EnableWindow(GetDlgItem(hDlg, DlgID), Enabled);
    }
}


#if DBG

UINT    DbgShowPal = 0x00;


INT
__cdecl
PalCompare(
    const void  *pA,
    const void  *pB
    )
{
    return((INT)((*(PLONG)pA & 0xFFFFFF) - (*(PLONG)pB & 0xFFFFFF)));
}



VOID
ShowDCPal(
    PHTCLRADJPARAM  pHTClrAdjParam,
    HPALETTE        hPal
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    02-Feb-1999 Tue 21:08:25 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    BOOL HasPal = (hPal != (HPALETTE)0);

    if (DbgShowPal & 0x01) {

        UINT            i;
        UINT            j;
        UINT            k;
        BYTE            bInv;
        PALETTEENTRY    Pal[256];
        PALETTEENTRY    Dif;


        if (!HasPal) {

            hPal = SelectPalette(pHTClrAdjParam->hDCDlg,
                                 pHTClrAdjParam->hHTPal, FALSE);
        }

        GetPaletteEntries(hPal, 0, 256, Pal);

        for (i = 0; i < 256; i++) {

            Pal[i].peFlags = (BYTE)i;
        }

        if (DbgShowPal & 0x80) {

            qsort((LPVOID)Pal, 256, sizeof(PALETTEENTRY), PalCompare);
        }

        for (i = 0; i < 256; i++) {

            bInv = 255 - Pal[i].peFlags;
            j    = 0;

            while ((j < 256) && (Pal[j].peFlags != bInv)) {

                ++j;
            }

            Dif.peRed   = 0xFF - Pal[i].peRed   - Pal[j].peRed;
            Dif.peGreen = 0xFF - Pal[i].peGreen - Pal[j].peGreen;
            Dif.peBlue  = 0xFF - Pal[i].peBlue  - Pal[j].peBlue;

            k = j;

            if ((Dif.peRed) || (Dif.peGreen) || (Dif.peBlue)) {

                k = 0;

                while (k < 256) {

                    if (((Pal[k].peRed   + Pal[i].peRed)   == 0xFF) &&
                        ((Pal[k].peGreen + Pal[i].peGreen) == 0xFF) &&
                        ((Pal[k].peBlue  + Pal[i].peBlue)  == 0xFF)) {

                        break;

                    } else {

                        ++k;
                    }
                }
            }

            if (k > 255) {

                k = 0;
            }

            DbgPrint("\nPal(%3ld/%02lx)=%3ld:%3ld:%3ld, Inv(%3ld/%02lx)=%3ld:%3ld:%3ld, Real(%3ld/%02lx)=%3ld:%3ld:%3ld [%hs], Dif=%02lx:%02lx:%02lx",
                    i, i, Pal[i].peRed, Pal[i].peGreen, Pal[i].peBlue,
                    j, j, Pal[j].peRed, Pal[j].peGreen, Pal[j].peBlue,
                    k, k, Pal[k].peRed, Pal[k].peGreen, Pal[k].peBlue,
                    (k == j) ? "-----" : "Error",
                    Dif.peRed, Dif.peGreen, Dif.peBlue);
        }

        if (!HasPal) {

            SelectPalette(pHTClrAdjParam->hDCDlg, hPal, FALSE);
        }
    }
}

#endif



LONG
InitHTClrAdjDlg(
    HWND            hDlg,
    PHTCLRADJPARAM  pHTClrAdjParam
    )
/*++

Routine Description:

    This function will intialized the pop up halftone color adjustment dialog
    box, it also tempopary create a display device halftone info for halftone
    incoming DIB, it will also allocate the memory for necessary halftoned
    result to be displayed.

Arguments:

    hDlg            - The handle to the owner dialog box

    pHTClrAdjParam  - Pointer to the HTCLRADJPARAM


Return Value:

    VOID


Author:

    02-Apr-1992 Thu 18:13:58 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hWndCur;
    LPWSTR  pName;
    WORD    BmpFlags;
    BYTE    ViewSrc;
    BYTE    ViewIdx;
    WCHAR   Buf[128];
    UINT    ViewID;
    UINT    Loop;
    UINT    Idx;


    //
    // Initialize the color table dib to be used later
    //

    LoadHTCLRADJPARAMToWININI(hDlg, pHTClrAdjParam);

    BmpFlags                 = pHTClrAdjParam->BmpFlags;
    pHTClrAdjParam->ViewMode =
    ViewSrc                  =
    ViewIdx                  = 0xff;

    //
    // Get the string from static control and put it into combo boxes
    //

    Loop = IDS_ILLUMINANT;

    while (LoadString(hHTUIModule, Loop++, Buf, COUNT_ARRAY(Buf))) {

        SendDlgItemMessage(hDlg,
                           IDD_HT_ILLUMINANT_COMBO,
                           CB_ADDSTRING,
                           (WPARAM)NULL,
                           (LPARAM)Buf);
    }


    Buf[0] = VSRC_LB_ID_START;
    Buf[1] = VSRC_LB_ID_SEPARATOR;
    Buf[2] = L' ';
    Buf[3] = L'\0';

    //
    // Starting by the default DIB passed from the caller
    //

    if (pHTClrAdjParam->hDefDIB) {

        if (pName = pHTClrAdjParam->pDefDIBTitle) {

            pName += GetSaveDefDIBFileName(NULL, pName, 0);
            wcscpy(&Buf[3], pName);

        } else {

            LoadString(hHTUIModule,IDS_DEFAULT_DIB,&Buf[3],COUNT_ARRAY(Buf)-3);
        }

        Idx = (UINT)SendDlgItemMessage(hDlg,
                                       IDD_HT_SHOW_COMBO,
                                       CB_ADDSTRING,
                                       (WPARAM)NULL,
                                       (LPARAM)Buf);
        SendDlgItemMessage(hDlg,
                           IDD_HT_SHOW_COMBO,
                           CB_SETITEMDATA,
                           (WPARAM)Idx,
                           (LPARAM)VSRC_PIC_DEF_DIB);


        ++Buf[0];           // Increment by 1 from 'A' to 'B'

        ViewSrc = (BYTE)VSRC_PIC_DEF_DIB;
        ViewIdx = (BYTE)Idx;
    }

    //
    // Secondary Add the last time saved bitmap file name
    //

    Idx = GetSaveDefDIBFileName(hDlg, &Buf[3], COUNT_ARRAY(Buf) - 3);

    if (Buf[3]) {

        wcscpy(&Buf[3], &Buf[Idx + 3]);

        Idx = (UINT)SendDlgItemMessage(hDlg,
                                       IDD_HT_SHOW_COMBO,
                                       CB_ADDSTRING,
                                       (WPARAM)NULL,
                                       (LPARAM)Buf);
        SendDlgItemMessage(hDlg,
                           IDD_HT_SHOW_COMBO,
                           CB_SETITEMDATA,
                           (WPARAM)Idx,
                           (LPARAM)VSRC_PIC_LOADED);

        if (ViewSrc == 0xff) {

            ViewSrc = VSRC_PIC_LOADED;
            ViewIdx = (BYTE)Idx;
        }
    }

    Loop   = IDS_TEST_MODE_START;
    ViewID = VSRC_TEST_START;

    while (Loop <= IDS_TEST_MODE_END) {

        LoadString(hHTUIModule, Loop, Buf, COUNT_ARRAY(Buf));

        Idx = (UINT)SendDlgItemMessage(hDlg,
                                       IDD_HT_SHOW_COMBO,
                                       CB_ADDSTRING,
                                       (WPARAM)NULL,
                                       (LPARAM)Buf);
        SendDlgItemMessage(hDlg,
                           IDD_HT_SHOW_COMBO,
                           CB_SETITEMDATA,
                           (WPARAM)Idx,
                           (LPARAM)ViewID);

        if ((ViewSrc == 0xff) &&
            (ViewID == DEFAULT_VSRC)) {

            ViewSrc = (BYTE)ViewID;
            ViewIdx = (BYTE)Idx;
        }

        ++ViewID;
        ++Loop;
    }

    SendDlgItemMessage(hDlg, IDD_HT_ILLUMINANT_COMBO, CB_SETEXTENDEDUI,
                       (WPARAM)TRUE, (LPARAM)NULL);

    SendDlgItemMessage(hDlg, IDD_HT_SHOW_COMBO, CB_SETEXTENDEDUI,
                       (WPARAM)TRUE, (LPARAM)NULL);

    for (Loop = 0; Loop < TOTAL_HTCLRADJ_SCROLL; Loop++) {

        SetScrollRange(GetDlgItem(hDlg, IDD_HT_FIRST_SCROLL + Loop),
                       SB_CTL,
                       0,
                       HTClrAdjScroll[Loop].Max - HTClrAdjScroll[Loop].Min,
                       FALSE);
    }

    if (!(CREATE_PHTBLT(pHTClrAdjParam))) {

        return(-2);
    }


#ifdef HTUIX_STATIC_HALFTONE
    pHTClrAdjParam->hHTPal = HTUI_CreateHalftonePalette(pHTClrAdjParam);
#else
    pHTClrAdjParam->hHTPal = CreateHalftonePalette(pHTClrAdjParam->hDCDlg);
#endif

#if DBG
    ShowDCPal(pHTClrAdjParam, pHTClrAdjParam->hHTPal);
#endif

    hWndUIDlg =
    hWndUITop = hDlg;

    while (hWndCur = GetWindow(hWndUITop, GW_OWNER)) {

        hWndUITop = hWndCur;
    }

    if (hWndUITop == hDlg) {

        hWndUITop = (HWND)NULL;

    } else {

        WndProcUITop = (WNDPROC)SetWindowLongPtr(hWndUITop,
                                                 GWLP_WNDPROC,
                                                 (LONG_PTR)TopWndHookProc);
    }


    //***********************************************************************
    // FOLLOWING must in that order
    //***********************************************************************

    //
    // 2. Check various button from default/setting
    //

    CheckDlgButton(hDlg, IDD_HT_LOG_FILTER,
                   (pHTClrAdjParam->CurHTClrAdj.caFlags & CLRADJF_LOG_FILTER) ?
                                                                    1 : 0);
    CheckDlgButton(hDlg,
                   IDD_HT_NEGATIVE,
                   (pHTClrAdjParam->CurHTClrAdj.caFlags & CLRADJF_NEGATIVE) ?
                                                                    1 : 0);
    CheckDlgButton(hDlg,
                   IDD_HT_ASPECT_RATIO,
                   (UINT)((BmpFlags & HT_BMP_SCALE) ? 1 : 0));
    CheckDlgButton(hDlg,
                   IDD_HT_PALETTE,
                   (UINT)((BmpFlags & HT_BMP_PALETTE) ? 1 : 0));
    CheckDlgButton(hDlg,
                   IDD_HT_MIRROR,
                   (UINT)((BmpFlags & HT_BMP_MIRROR) ? 1 : 0));
    CheckDlgButton(hDlg,
                   IDD_HT_UPSIDEDOWN,
                   (UINT)((BmpFlags & HT_BMP_UPSIDEDOWN) ? 1 : 0));
    CheckDlgButton(hDlg,
                   IDD_HT_BMP_TEST,
                   (UINT)((BmpFlags & HT_BMP_ENABLE) ? 1 : 0));
    CheckDlgButton(hDlg,
                   IDD_HT_ZOOM,
                   (UINT)((BmpFlags & HT_BMP_ZOOM) ? 1 : 0));

    CheckDlgButton(hDlg,
                   IDD_HT_SYNC_R,
                   (UINT)((BmpFlags & HT_BMP_SYNC_R) ? 1 : 0));
    CheckDlgButton(hDlg,
                   IDD_HT_SYNC_G,
                   (UINT)((BmpFlags & HT_BMP_SYNC_G) ? 1 : 0));
    CheckDlgButton(hDlg,
                   IDD_HT_SYNC_B,
                   (UINT)((BmpFlags & HT_BMP_SYNC_B) ? 1 : 0));


    if (BmpFlags & HT_BMP_SYNC_R) {

        HTCLRADJSCROLL_R_GAMMA.Flags = HTCAS_SYNC_RGB;

    } else {

        HTCLRADJSCROLL_R_GAMMA.Flags = 0;
    }

    if (BmpFlags & HT_BMP_SYNC_G) {

        HTCLRADJSCROLL_G_GAMMA.Flags = HTCAS_SYNC_RGB;

    } else {

        HTCLRADJSCROLL_G_GAMMA.Flags = 0;
    }

    if (BmpFlags & HT_BMP_SYNC_B) {

        HTCLRADJSCROLL_B_GAMMA.Flags = HTCAS_SYNC_RGB;

    } else {

        HTCLRADJSCROLL_B_GAMMA.Flags = 0;
    }


    //
    // If the caller (device driver/application) has default bitmap to
    // be adjusted then display that one first, otherwise try to display
    // the last loaded bitmap, else it will just display the reference
    // colors, since we calling to load the last DIB so we will make the
    // current selection as the other DIB.
    //

    ChangeViewSource(hDlg, pHTClrAdjParam, ViewSrc);

    //
    // 3. Now adjust the dialog box position from the win.ini or default,
    //    remember must in this order
    //

    SetWindowPos(hDlg, NULL,
                 pHTClrAdjParam->rcDlg.left,
                 pHTClrAdjParam->rcDlg.top,
                 0, 0, SWP_NOSIZE | SWP_NOZORDER);

    return(1);
}




BOOL
UpdateAppHTBitmap(
    PHTCLRADJPARAM  pHTClrAdjParam
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    01-Feb-1997 Sat 17:44:58 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HPALETTE    hPal;

    if (hPal = (HPALETTE)SendMessage(pHTClrAdjParam->hWndApp,
                                     WM_HALFTONE_UI,
                                     HTUI_MSG_GETPAL,
                                     0)) {

        SelectPalette(pHTClrAdjParam->hDCDlg, hPal, FALSE);
        RealizePalette(pHTClrAdjParam->hDCDlg);
#if DBG
        ShowDCPal(pHTClrAdjParam, NULL);
#endif
        PostMessage(pHTClrAdjParam->hWndApp,
                    WM_HALFTONE_UI,
                    (WPARAM)HTUI_MSG_CLRADJ_CHANGED,
                    (LPARAM)&(pHTClrAdjParam->CurHTClrAdj));

        return(TRUE);
    }

    return(FALSE);
}





LONG
APIENTRY
HTClrAdjDlgProc(
    HWND    hDlg,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
/*++

Routine Description:

    This is the halftone color adjustments main DlgProc().

Arguments:

    hDlg            - The handle to the owner dialog box

    Msg             - message from window

    wParam          - First parameter

    lParam          - Second parameter.


Return Value:

    a non-zero if process message, 0 otherwise.

    This function assume is called from a DialogBoxParam() call, and expected
    the WM_INITDIALOG message will have lParam equ to initialized
    pHTClrAdjParam


Author:

    06-Dec-1993 Mon 20:58:58 updated  -by-  Daniel Chou (danielc)
        Allowed F1=Help even permission flag is not set

    02-Apr-1992 Thu 18:13:58 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND                hWndBmp;
    HWND                hCtrl;
    LPWSTR              pwBuf;
    LPBYTE              pCurScroll;
    PHTBLT              pHTBlt;
    PHTCLRADJPARAM      pHTClrAdjParam;
    COLORADJUSTMENT     CurHTClrAdj;
    HTCLRADJSCROLL      ScrollControl;
    RECT                Rect;
    LONG                ScrollOld;
    LONG                ScrollCur;
    LONG                Result;
    INT                 i;
    UINT                IDScroll;
    UINT                IDScrollEnd;
    UINT                ScrollIndex;
    WORD                DoComboBox = 0;
    WORD                DlgID;
    WORD                Mask;
    BOOL                Changed = FALSE;
    BOOL                Enabled;
    WCHAR               Buf[16];


    if (Msg == WM_INITDIALOG) {

        pHTClrAdjParam = (PHTCLRADJPARAM)lParam;

        SetWindowLongPtr(pHTClrAdjParam->hDlg = hDlg, GWLP_USERDATA, lParam);
        pHTClrAdjParam->hDCDlg = GetWindowDC(hDlg);

        if ((pHTClrAdjParam->pCallerHTClrAdj)                               &&
            (pHTClrAdjParam->pCallerHTClrAdj->caSize ==
                                                sizeof(COLORADJUSTMENT))    &&
            (!(pHTClrAdjParam->pCallerHTClrAdj->caFlags &
                                                (~CLRADJF_FLAGS_MASK)))) {

            pHTClrAdjParam->CurHTClrAdj  = *(pHTClrAdjParam->pCallerHTClrAdj);

        } else {

            pHTClrAdjParam->Flags       |= HTCAPF_FORCE_OK;
            pHTClrAdjParam->CurHTClrAdj  = DefaultCA;
        }

        //
        // Setup halftone UI extended help style
        //

        pHTClrAdjParam->CallerHTClrAdj = pHTClrAdjParam->CurHTClrAdj;

        SetWindowLong(hDlg,
                      GWL_EXSTYLE,
                      GetWindowLong(hDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

    } else if (!(pHTClrAdjParam =
                        (PHTCLRADJPARAM)GetWindowLongPtr(hDlg, GWLP_USERDATA))) {

        return(FALSE);
    }

    IDScroll     = 1;
    IDScrollEnd  = 0;
    CurHTClrAdj  = pHTClrAdjParam->CurHTClrAdj;
    hWndBmp      = pHTClrAdjParam->hWndBmp;
    pHTBlt       = GET_PHTBLT(pHTClrAdjParam);


    switch(Msg) {

    case WM_INITDIALOG:     // set the previouse one equal to current setting

        CurHTClrAdj.caSize   = sizeof(COLORADJUSTMENT);
        CurHTClrAdj.caFlags &= CLRADJF_FLAGS_MASK;

        if (CurHTClrAdj.caIlluminantIndex > ILLUMINANT_MAX_INDEX) {

            CurHTClrAdj.caIlluminantIndex = DefaultCA.caIlluminantIndex;
        }

        ADJ_CA(CurHTClrAdj.caRedGamma,   MIN_RGB_GAMMA, MAX_RGB_GAMMA);
        ADJ_CA(CurHTClrAdj.caGreenGamma, MIN_RGB_GAMMA, MAX_RGB_GAMMA);
        ADJ_CA(CurHTClrAdj.caBlueGamma,  MIN_RGB_GAMMA, MAX_RGB_GAMMA);
        ADJ_CA(CurHTClrAdj.caReferenceBlack, 0, REFERENCE_BLACK_MAX);
        ADJ_CA(CurHTClrAdj.caReferenceWhite, REFERENCE_WHITE_MIN, 10000);
        ADJ_CA(CurHTClrAdj.caContrast,     MIN_COLOR_ADJ, MAX_COLOR_ADJ);
        ADJ_CA(CurHTClrAdj.caBrightness,   MIN_COLOR_ADJ, MAX_COLOR_ADJ);
        ADJ_CA(CurHTClrAdj.caColorfulness, MIN_COLOR_ADJ, MAX_COLOR_ADJ);
        ADJ_CA(CurHTClrAdj.caRedGreenTint, MIN_COLOR_ADJ, MAX_COLOR_ADJ);

        pHTClrAdjParam->CurHTClrAdj  =
        pHTClrAdjParam->LastHTClrAdj = CurHTClrAdj;
        DoComboBox                   = 0x3;
        IDScroll                     = (INT)IDD_HT_FIRST_SCROLL;
        IDScrollEnd                  = (INT)IDD_HT_LAST_SCROLL;

        if ((Result = InitHTClrAdjDlg(hDlg, pHTClrAdjParam)) < 0) {

            EndDialog(hDlg, Result);
            return(TRUE);
        }

        if (pHTClrAdjParam->Flags & HTCAPF_SHOW_MONO) {

            EnableDlgGroup(hDlg, IDDMonoGroup, FALSE);
        }

        if (CurHTClrAdj.caColorfulness == COLOR_ADJ_MIN) {

            EnableDlgGroup(hDlg, &IDDMonoGroup[3], FALSE);
        }

        if (!IsDlgButtonChecked(hDlg, IDD_HT_BMP_TEST)) {

            EnableDlgGroup(hDlg, IDDBmpTestGroup, FALSE);
        }

        Changed = TRUE;

        break;

    case WM_NCRBUTTONDOWN:
    case WM_RBUTTONDOWN:

        if (pHTClrAdjParam->BmpFlags & HT_BMP_ZOOM) {

            pHTClrAdjParam->BmpFlags ^= HT_BMP_AT_TOP;
            AdjustDlgZorder(pHTClrAdjParam);

            if (hWndBmp) {

                SendMessage(hWndBmp,
                            WM_COMMAND,
                            (WPARAM)IDD_HT_BRING_TO_TOP,
                            (LPARAM)NULL);
            }
        }

        break;

    case WM_SIZE:
    case WM_MOVE:

        Rect = pHTClrAdjParam->rcDlg;

        GetWindowRect(hDlg, &(pHTClrAdjParam->rcDlg));

        if (pHTClrAdjParam->BmpFlags & HT_BMP_AUTO_MOVE) {

            RECT    rcBmp = pHTClrAdjParam->rcBmp;

            rcBmp.left   += (Result = pHTClrAdjParam->rcDlg.left - Rect.left);
            rcBmp.right  += Result;
            rcBmp.top    += (Result = pHTClrAdjParam->rcDlg.top - Rect.top);
            rcBmp.bottom += Result;

            if ((hWndBmp) &&
                (!(pHTClrAdjParam->BmpFlags & HT_BMP_ZOOM))) {

                SetWindowPos(hWndBmp,
                             IS_BMP_AT_TOP(pHTClrAdjParam->BmpFlags) ? NULL :
                                                                       hDlg,
                             rcBmp.left,
                             rcBmp.top,
                             rcBmp.right - rcBmp.left,
                             rcBmp.bottom - rcBmp.top,
                             SWP_DRAWFRAME | SWP_NOACTIVATE);
            }

            pHTClrAdjParam->rcBmp = rcBmp;
        }

        return(FALSE);

    case WM_DESTROY:

        if (hWndUITop) {

            SetWindowLongPtr(hWndUITop, GWLP_WNDPROC, (LONG_PTR)WndProcUITop);
            hWndUITop = NULL;
        }

        hWndUIDlg     = NULL;
        WndProcUITop  = (WNDPROC)NULL;


        if (pHTClrAdjParam->hWndBmp) {

            DestroyWindow(pHTClrAdjParam->hWndBmp);
            pHTClrAdjParam->hWndBmp = NULL;
        }

        if (pHTClrAdjParam->hDCDlg) {

            ReleaseDC(hDlg, pHTClrAdjParam->hDCDlg);
            pHTClrAdjParam->hDCDlg = NULL;
        }

        if (pHTBlt) {

            if (pHTBlt->hDCMem) {

                Result = (LONG)DeleteDC(pHTBlt->hDCMem);

                HTUI_ASSERT("DeleteDC(hDCMem)", Result);
            }

            if (pHTBlt->hMemBmp) {

                Result = (LONG)DeleteObject(pHTBlt->hMemBmp);

                HTUI_ASSERT("DeleteObject(hMemBmp)", Result);
            }

            if (pHTBlt->hBmpPal) {

                Result = (LONG)DeleteObject(pHTBlt->hBmpPal);

                HTUI_ASSERT("DeleteObject(hBmpPal)", Result);
            }

            DELETE_PHTBLT(pHTClrAdjParam);
        }

        if (pHTClrAdjParam->hHTPal) {

            Result = (LONG)DeleteObject(pHTClrAdjParam->hHTPal);

            HTUI_ASSERT("DeleteObject(hHTPal)", Result);

            pHTClrAdjParam->hHTPal = NULL;
        }

        if (pHTClrAdjParam->hSrcDIB) {

            pHTClrAdjParam->hSrcDIB = GlobalFree(pHTClrAdjParam->hSrcDIB);

            HTUI_ASSERT("GlobalFree(hSrcDIB)", pHTClrAdjParam->hSrcDIB == NULL);
        }

        for (ScrollIndex = 0; ScrollIndex <= TDI_MAX_INDEX; ScrollIndex++) {

            if (TestDIBInfo[ScrollIndex].hDIB) {

                TestDIBInfo[ScrollIndex].hDIB =
                            GlobalFree(TestDIBInfo[ScrollIndex].hDIB);

                HTUI_ASSERT("GlobalFree(TestDIBInfo[].hDIB)",
                        TestDIBInfo[ScrollIndex].hDIB == NULL);

            }
        }

#ifdef HTUIX_STATIC_HALFTONE

        if (HTUI_pDHI) {

            HT_DestroyDeviceHalftoneInfo(HTUI_pDHI);
            HTUI_pDHI = NULL;
        }

        if ((HTUI_hHTPal) && (HTUI_DIBInfo.bi.biBitCount == 8)) {

            DeleteObject(HTUI_hHTPal);
            HTUI_hHTPal = NULL;
        }

        if (HTUI_pHTBits) {

            LocalFree((HLOCAL)HTUI_pHTBits);
            HTUI_pHTBits = NULL;
        }
#endif

        return(TRUE);

    case WM_SETFOCUS:

        AdjustDlgZorder(pHTClrAdjParam);
        return(0);

    case WM_ACTIVATE:

        if (LOWORD(wParam)) {

            AdjustDlgZorder(pHTClrAdjParam);
            SetFocus(hDlg);
            wParam = (WPARAM)NULL;

        } else {

            return(0);
        }

        //
        // Fall through
        //

    case WM_PALETTECHANGED:

        if (wParam == (WPARAM)hDlg) {

            break;
        }

    case WM_QUERYNEWPALETTE:

        if ((hWndBmp)   &&
            (pHTClrAdjParam->BmpFlags & HT_BMP_ENABLE)  &&
            (pHTClrAdjParam->hDCDlg)                    &&
            (pHTClrAdjParam->hHTPal)) {

            SelectPalette(pHTClrAdjParam->hDCDlg,
                          pHTClrAdjParam->hHTPal,
                          FALSE);

            if (i = RealizePalette(pHTClrAdjParam->hDCDlg)) {

                InvalidateRect(hWndBmp, NULL, FALSE);
            }

            return(i);
        }

        break;

    case WM_HELP:

        wParam = (WPARAM)((LPHELPINFO)lParam)->hItemHandle;
        lParam = (LPARAM)MAKELONG(((LPHELPINFO)lParam)->MousePos.x,
                                  ((LPHELPINFO)lParam)->MousePos.y);

    case WM_CONTEXTMENU:

        DoHalftoneHelp(hDlg,
                       (HWND)wParam,
                       HELP_TYPE_HTCLRADJ,
                       (Msg == WM_HELP) ? HELP_WM_HELP : HELP_CONTEXTMENU,
                       (DWORD)lParam);

        break;

    case WM_COMMAND:

        switch (DlgID = LOWORD(wParam)) {

        case IDD_HT_BMP_TEST:

            if (Changed = (BOOL)IsDlgButtonChecked(hDlg, IDD_HT_BMP_TEST)) {

                if (!hWndBmp) {

                    if (!CreateBmpWindow(pHTClrAdjParam)) {

                        return(TRUE);
                    }

                    hWndBmp = pHTClrAdjParam->hWndBmp;
                }

                pHTClrAdjParam->BmpFlags |= HT_BMP_ENABLE;

            } else {

                pHTClrAdjParam->BmpFlags &= (WORD)~HT_BMP_ENABLE;
            }

            if (hWndBmp) {

                ShowWindow(hWndBmp, (Changed) ? SW_SHOW : SW_HIDE);
                EnableWindow(hWndBmp, Changed);
            }

            EnableDlgGroup(hDlg, IDDBmpTestGroup, (BOOL)Changed);

            Changed = TRUE;

            //
            // FALL THROUH if we need to show the bitmap window
            //

        case IDD_HT_BRING_TO_TOP:

            AdjustDlgZorder(pHTClrAdjParam);
            break;

        case IDD_HT_SAVE_AS:

            SaveHalftonedDIB(hDlg, pHTClrAdjParam);
            return(TRUE);

        case IDD_HT_ZOOM:

            if ((hWndBmp) && (pHTClrAdjParam->BmpFlags & HT_BMP_ENABLE)) {

                SendMessage(hWndBmp, WM_LBUTTONDBLCLK, 0, 0);
            }

            return(TRUE);


        case IDD_HT_LOG_FILTER:

            if (IsDlgButtonChecked(hDlg, IDD_HT_LOG_FILTER)) {

                CurHTClrAdj.caFlags |= CLRADJF_LOG_FILTER;

            } else {

                CurHTClrAdj.caFlags &= ~CLRADJF_LOG_FILTER;
            }

            break;

        case IDD_HT_NEGATIVE:

            if (IsDlgButtonChecked(hDlg, IDD_HT_NEGATIVE)) {

                CurHTClrAdj.caFlags |= CLRADJF_NEGATIVE;

            } else {

                CurHTClrAdj.caFlags &= ~CLRADJF_NEGATIVE;
            }

            break;

        case IDD_HT_SYNC_R:

            if (IsDlgButtonChecked(hDlg, IDD_HT_SYNC_R)) {

                pHTClrAdjParam->BmpFlags     |= HT_BMP_SYNC_R;
                HTCLRADJSCROLL_R_GAMMA.Flags |= HTCAS_SYNC_RGB;

            } else {

                pHTClrAdjParam->BmpFlags     &= ~HT_BMP_SYNC_R;
                HTCLRADJSCROLL_R_GAMMA.Flags &= ~HTCAS_SYNC_RGB;
            }

            return(TRUE);

        case IDD_HT_SYNC_G:

            if (IsDlgButtonChecked(hDlg, IDD_HT_SYNC_G)) {

                pHTClrAdjParam->BmpFlags     |= HT_BMP_SYNC_G;
                HTCLRADJSCROLL_G_GAMMA.Flags |= HTCAS_SYNC_RGB;

            } else {

                pHTClrAdjParam->BmpFlags     &= ~HT_BMP_SYNC_G;
                HTCLRADJSCROLL_G_GAMMA.Flags &= ~HTCAS_SYNC_RGB;
            }

            return(TRUE);

        case IDD_HT_SYNC_B:

            if (IsDlgButtonChecked(hDlg, IDD_HT_SYNC_B)) {

                pHTClrAdjParam->BmpFlags     |= HT_BMP_SYNC_B;
                HTCLRADJSCROLL_B_GAMMA.Flags |= HTCAS_SYNC_RGB;

            } else {

                pHTClrAdjParam->BmpFlags     &= ~HT_BMP_SYNC_B;
                HTCLRADJSCROLL_B_GAMMA.Flags &= ~HTCAS_SYNC_RGB;
            }

            return(TRUE);


        case IDD_HT_ASPECT_RATIO:
        case IDD_HT_PALETTE:
        case IDD_HT_MIRROR:
        case IDD_HT_UPSIDEDOWN:
        case IDD_HT_COPY_USE_DIB:

            switch(DlgID) {

            case IDD_HT_ASPECT_RATIO:

                Mask = HT_BMP_SCALE;
                break;

            case IDD_HT_PALETTE:

                Mask = HT_BMP_PALETTE;
                break;

            case IDD_HT_UPSIDEDOWN:

                Mask = HT_BMP_UPSIDEDOWN;
                break;

            case IDD_HT_MIRROR:

                Mask = HT_BMP_MIRROR;
                break;
            }

            if (Enabled = (BOOL)IsDlgButtonChecked(hDlg, DlgID)) {

                pHTClrAdjParam->BmpFlags |= Mask;

            } else {

                pHTClrAdjParam->BmpFlags &= (WORD)~Mask;
            }

            if (DlgID == IDD_HT_ASPECT_RATIO) {

                if (!ReSizeBmpWindow(pHTClrAdjParam)) {

                    return(TRUE);
                }
            }

            Changed = TRUE;
            break;

        case IDD_HT_SHOW_COMBO:

            if (HIWORD(wParam) == CBN_SELCHANGE) {

                if (hWndBmp) {

                    InvalidateRect(hWndBmp, NULL, FALSE);
                }

                Mask = (WORD)SendDlgItemMessage(hDlg,
                                                IDD_HT_SHOW_COMBO,
                                                CB_GETCURSEL,
                                                (WPARAM)NULL,
                                                (LPARAM)NULL);

                if (ChangeViewSource(hDlg,
                                     pHTClrAdjParam,
                                     (WORD)SendDlgItemMessage(hDlg,
                                                              IDD_HT_SHOW_COMBO,
                                                              CB_GETITEMDATA,
                                                              (WPARAM)Mask,
                                                              (LPARAM)NULL))) {

                    Changed = TRUE;
                }

                break;
            }

            return(TRUE);

        case IDD_HT_OPEN:

            if (GetNewDIBFromFile(pHTClrAdjParam, FALSE)) {

                Changed = TRUE;
                break;
            }

            return(TRUE);

        case IDD_HT_LINEAR_GAMMA:

            if (Enabled = (BOOL)IsDlgButtonChecked(hDlg, IDD_HT_LINEAR_GAMMA)) {

                pHTClrAdjParam->RedGamma   = CurHTClrAdj.caRedGamma;
                pHTClrAdjParam->GreenGamma = CurHTClrAdj.caGreenGamma;
                pHTClrAdjParam->BlueGamma  = CurHTClrAdj.caBlueGamma;

                CurHTClrAdj.caRedGamma     =
                CurHTClrAdj.caGreenGamma   =
                CurHTClrAdj.caBlueGamma    = 10000;

            } else {

                CurHTClrAdj.caRedGamma     = pHTClrAdjParam->RedGamma;
                CurHTClrAdj.caGreenGamma   = pHTClrAdjParam->GreenGamma;
                CurHTClrAdj.caBlueGamma    = pHTClrAdjParam->BlueGamma;
            }

            EnableDlgGroup(hDlg, IDDGammaGroup, !Enabled);

            IDScroll    = (INT)IDD_HT_R_GAMMA_SCROLL;
            IDScrollEnd = (INT)IDD_HT_B_GAMMA_SCROLL;
            Changed     = TRUE;

            break;


        case IDD_HT_RESET:     // Reset to original setting before this dialog
        case IDD_HT_DEFAULT:

            if (DlgID == IDD_HT_RESET) {

                CurHTClrAdj = pHTClrAdjParam->LastHTClrAdj;

            } else {

                CurHTClrAdj = DefaultCA;
            }

            if (IsDlgButtonChecked(hDlg, IDD_HT_LINEAR_GAMMA)) {

                CheckDlgButton(hDlg, IDD_HT_LINEAR_GAMMA, 0);
                EnableDlgGroup(hDlg, IDDGammaGroup, TRUE);
            }

            if (!(pHTClrAdjParam->Flags & HTCAPF_SHOW_MONO)) {

                EnableDlgGroup(hDlg,
                               &IDDMonoGroup[3],
                               (CurHTClrAdj.caColorfulness != COLOR_ADJ_MIN));
            }

            if (Changed = (BOOL)memcmp(&CurHTClrAdj,
                                       &(pHTClrAdjParam->CurHTClrAdj),
                                       sizeof(COLORADJUSTMENT))) {

                IDScroll    = (INT)IDD_HT_FIRST_SCROLL;
                IDScrollEnd = (INT)IDD_HT_LAST_SCROLL;

                CheckDlgButton(hDlg, IDD_HT_LOG_FILTER,
                               (CurHTClrAdj.caFlags & CLRADJF_LOG_FILTER) ? 1 :
                                                                            0);
                CheckDlgButton(hDlg, IDD_HT_NEGATIVE,
                               (CurHTClrAdj.caFlags & CLRADJF_NEGATIVE) ? 1 :
                                                                          0);
            }

            break;


        case IDCANCEL:

            if (!(pHTClrAdjParam->Flags & HTCAPF_FORCE_OK)) {

                UpdateHTCLRADJPARAMToWININI(hDlg, pHTClrAdjParam);

                if ((pHTClrAdjParam->pCallerHTClrAdj)   &&
                    (memcmp(&CurHTClrAdj,
                            &(pHTClrAdjParam->CallerHTClrAdj),
                            sizeof(COLORADJUSTMENT)))) {

                    *(pHTClrAdjParam->pCallerHTClrAdj) =
                                            pHTClrAdjParam->CallerHTClrAdj;

                    Changed = TRUE;

                } else {

                    Changed = FALSE;
                }

                EndDialog(hDlg, (Changed) ? 1 : 0);
                return(TRUE);
            }
#if DBG
            DbgPrint("\nHAS INVALID DATA: Simulate a OK");
#endif
            //
            // We have invalid data, simulate a OK
            //

        case IDOK:

            if ((pHTClrAdjParam->Flags & HTCAPF_CAN_UPDATE) &&
                (pHTClrAdjParam->pCallerHTClrAdj)) {

                if (Changed = (BOOL)memcmp(&CurHTClrAdj,
                                           &(pHTClrAdjParam->CallerHTClrAdj),
                                           sizeof(COLORADJUSTMENT))) {

                    *(pHTClrAdjParam->pCallerHTClrAdj) = CurHTClrAdj;
                }
            }

            UpdateHTCLRADJPARAMToWININI(hDlg, pHTClrAdjParam);
            EndDialog(hDlg, (Changed) ? 1 : 0);
            return(TRUE);

        case IDD_HT_ILLUMINANT_COMBO:

            if (HIWORD(wParam) == CBN_SELCHANGE) {

                ScrollCur = (LONG)SendDlgItemMessage(hDlg,
                                                     DlgID,
                                                     CB_GETCURSEL,
                                                     (WPARAM)NULL,
                                                     (LPARAM)NULL);

                DoComboBox = 0x02;
                CurHTClrAdj.caIlluminantIndex = (BYTE)ScrollCur;

                break;

            } else {

                return(FALSE);
            }

        default:

            return(FALSE);
        }

        break;

    case WM_HSCROLL:

        IDScroll      =
        IDScrollEnd   = (INT)GetDlgCtrlID((HWND)lParam);

        ScrollIndex   = IDScroll - IDD_HT_FIRST_SCROLL;
        ScrollControl = HTClrAdjScroll[ScrollIndex];
        pCurScroll    = (LPBYTE)&CurHTClrAdj + (UINT)ScrollControl.Offset;

        ScrollOld     =
        ScrollCur     = (LONG)((ScrollControl.Flags & HTCAS_SHORT) ?
                                    *(LPSHORT)pCurScroll : *(LPWORD)pCurScroll);

        if (ScrollControl.Mul != 1) {

            ScrollCur /= (LONG)ScrollControl.Mul;
        }

        switch (LOWORD(wParam)) {

        case SB_TOP:

            ScrollCur = (LONG)ScrollControl.Min;
            break;

        case SB_BOTTOM:

            ScrollCur = (LONG)ScrollControl.Max;
            break;

        case SB_PAGEUP:

            ScrollCur -= (LONG)ScrollControl.Step;
            break;

        case SB_PAGEDOWN:

            ScrollCur += (LONG)ScrollControl.Step;
            break;

        case SB_LINEUP:

            --ScrollCur;
            break;

        case SB_LINEDOWN:

            ++ScrollCur;
            break;

        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:

            ScrollCur = (LONG)HIWORD(wParam) + (LONG)ScrollControl.Min;
            break;

        default:

            return(FALSE);
        }

        if (ScrollCur < (LONG)ScrollControl.Min) {

            ScrollCur = (LONG)ScrollControl.Min;

        } else if (ScrollCur > (LONG)ScrollControl.Max) {

            ScrollCur = (LONG)ScrollControl.Max;
        }

        if (ScrollControl.Mul != 1) {

            ScrollCur *= (LONG)ScrollControl.Mul;
        }

        if (ScrollControl.Flags & HTCAS_SHORT) {

            *(LPSHORT)pCurScroll = (SHORT)ScrollCur;

        } else {

            *(LPWORD)pCurScroll = (WORD)ScrollCur;
        }


        switch(IDScroll) {

        case IDD_HT_COLORFULNESS_SCROLL:

            i = -1;

            if (ScrollOld == ScrollControl.Min) {

                if (ScrollCur > ScrollControl.Min) {

                    i = 1;
                }

            } else {

                if (ScrollCur == ScrollControl.Min) {

                    i = 0;
                }
            }

            if (i >= 0) {

                EnableDlgGroup(hDlg, &IDDMonoGroup[3], (BOOL)i);
            }

            break;

        case IDD_HT_R_GAMMA_SCROLL:
        case IDD_HT_G_GAMMA_SCROLL:
        case IDD_HT_B_GAMMA_SCROLL:

            if (ScrollControl.Flags & HTCAS_SYNC_RGB) {

                if (HTCLRADJSCROLL_R_GAMMA.Flags &= HTCAS_SYNC_RGB) {

                    CurHTClrAdj.caRedGamma = (WORD)ScrollCur;
                }

                if (HTCLRADJSCROLL_G_GAMMA.Flags &= HTCAS_SYNC_RGB) {

                    CurHTClrAdj.caGreenGamma = (WORD)ScrollCur;
                }

                if (HTCLRADJSCROLL_B_GAMMA.Flags &= HTCAS_SYNC_RGB) {

                    CurHTClrAdj.caBlueGamma = (WORD)ScrollCur;
                }

                IDScroll    = IDD_HT_R_GAMMA_SCROLL;
                IDScrollEnd = IDD_HT_B_GAMMA_SCROLL;
            }

            break;
        }

        break;

    default:

        return(FALSE);
    }

    //
    // Update the dialog box control if any of them got changed
    //

    if ((DoComboBox & 0x02) ||
        (CurHTClrAdj.caIlluminantIndex !=
                        pHTClrAdjParam->CurHTClrAdj.caIlluminantIndex)) {

        SendDlgItemMessage(hDlg,
                           IDD_HT_ILLUMINANT_COMBO,
                           CB_SETCURSEL,
                           (WPARAM)(CurHTClrAdj.caIlluminantIndex),
                           (LPARAM)NULL);
    }

    while (IDScroll <= IDScrollEnd) {

        if (hCtrl = GetDlgItem(hDlg, IDScroll)) {

            ScrollIndex   = IDScroll - IDD_HT_FIRST_SCROLL;
            ScrollControl = HTClrAdjScroll[ScrollIndex];
            pCurScroll    = (LPBYTE)&CurHTClrAdj + (UINT)ScrollControl.Offset;

            ScrollCur = (LONG)((ScrollControl.Flags & HTCAS_SHORT) ?
                                *(LPSHORT)pCurScroll : *(LPWORD)pCurScroll);

            if (ScrollControl.Mul != 1) {

                ScrollCur /= (LONG)ScrollControl.Mul;
            }

            if (IsWindowEnabled(hCtrl)) {

                SetScrollPos(hCtrl,
                             SB_CTL,
                             (INT)(ScrollCur - (LONG)ScrollControl.Min),
                             TRUE);
            }

            pwBuf = Buf;

            if (ScrollControl.Min < 0) {

                if (ScrollCur < 0) {

                    *pwBuf++  = L'-';
                    ScrollCur = -ScrollCur;

                } else if (ScrollCur > 0) {

                    *pwBuf++ = L'+';

                } else {

                    *pwBuf++ = L' ';
                }
            }

            if (ScrollControl.Flags & HTCAS_SHORT) {

                wsprintf(pwBuf, L"%d", (INT)ScrollCur);

            } else {

                wsprintf(pwBuf, L"%d%ls%03d", (INT)(ScrollCur / 1000),
                                              pHTClrAdjParam->pwDecimal,
                                              (INT)(ScrollCur % 1000));
            }

            SetDlgItemText(hDlg, IDScroll + IDD_HT_SCROLL_INT_ADD, Buf);
        }

        ++IDScroll;
    }

    if ((Changed) ||
        (memcmp(&CurHTClrAdj,
                &(pHTClrAdjParam->CurHTClrAdj),
                sizeof(HTCOLORADJUSTMENT)))) {

        pHTClrAdjParam->CurHTClrAdj   = CurHTClrAdj;
        pHTClrAdjParam->BmpNeedUpdate = 1;

        if ((hWndBmp)   &&
            (pHTClrAdjParam->BmpFlags & (WORD)HT_BMP_ENABLE)) {

            InvalidateRect(hWndBmp, NULL, FALSE);

        } else {

            UpdateAppHTBitmap(pHTClrAdjParam);
        }
    }

    if (Msg == WM_INITDIALOG) {

        if (pHTClrAdjParam->BmpFlags & HT_BMP_ENABLE) {

            PostMessage(hDlg,
                        WM_COMMAND,
                        (WPARAM)IDD_HT_BMP_TEST,
                        (LPARAM)NULL);
        }

        if (!(pHTClrAdjParam->Flags & HTCAPF_CAN_UPDATE)) {

            EnumChildWindows(hDlg, DisableDlgUpdate, 0);
            SetFocus(GetDlgItem(hDlg, IDCANCEL));

        } else {

            SetFocus(GetDlgItem(hDlg, IDD_HT_BRIGHTNESS_SCROLL));
            SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)TRUE, (LPARAM)FALSE);
        }

        return(0);

    } else {

        return(1);
    }
}


DWORD
PickDefaultHTPatSize(
    DWORD   xDPI,
    DWORD   yDPI,
    BOOL    Is8bppHalftone
    )
{
    DWORD   HTPatSize;

    //
    // use the smaller resolution as the pattern guide
    //

    if (xDPI >= 2400) {

        HTPatSize = HTPAT_SIZE_16x16_M;

    } else if (xDPI >= 1800) {

        HTPatSize = HTPAT_SIZE_14x14_M;

    } else if (xDPI >= 1200) {

        HTPatSize = HTPAT_SIZE_12x12_M;

    } else if (xDPI >= 900) {

        HTPatSize = HTPAT_SIZE_10x10_M;

    } else if (xDPI >= 400) {

        HTPatSize = HTPAT_SIZE_8x8_M;

    } else if (xDPI >= 180) {

        HTPatSize = HTPAT_SIZE_6x6_M;

    } else {

        HTPatSize = HTPAT_SIZE_4x4_M;
    }

    if (Is8bppHalftone) {

        HTPatSize -= 2;
    }

    return(HTPatSize);
}




VOID
ValidateDevHTInfo(
    PHTDEVADJPARAM  pHTDevAdjParam
    )
{
    DEVHTADJDATA    DevHTAdjData;
    DWORD           HTFlags;
    INT             DevLoop;
    INT             Loop;


    DevHTAdjData = pHTDevAdjParam->DevHTAdjData;

    if (DevHTAdjData.DeviceFlags & DEVHTADJF_ADDITIVE_DEVICE) {

        HTFlags = (HIF_SQUARE_DEVICE_PEL | HIF_ADDITIVE_PRIMS);

    } else {

        HTFlags = (HIF_HAS_BLACK_DYE);
    }

    DevLoop = 2;

    while (DevLoop--) {

        PDEVHTINFO      pDevHTInfo;
        PCOLORINFO      pColorInfo;
        PUDECI4         pUDECI4;
        LDECI4    FAR   *pLDECI4;


        pDevHTInfo = (DevLoop) ? DevHTAdjData.pDefHTInfo :
                                 DevHTAdjData.pAdjHTInfo;

        pColorInfo = &(pDevHTInfo->ColorInfo);

        pDevHTInfo->HTFlags &= ~(HIF_SQUARE_DEVICE_PEL  |
                                 HIF_HAS_BLACK_DYE      |
                                 HIF_ADDITIVE_PRIMS);
        pDevHTInfo->HTFlags |= HTFlags;

        //
        // We want to check to see if this is a old data, if yes then update
        // the caller to NT3.51 default
        //

        if (pColorInfo->Cyan.Y != (LDECI4)VALID_YC) {

            pDevHTInfo->HTPatternSize    = HTPAT_SIZE_MAX_INDEX + 1;
            pDevHTInfo->DevPelsDPI       = 0;
            pColorInfo->AlignmentWhite.Y = (LDECI4)0;
            pColorInfo->MagentaInCyanDye = (LDECI4)10000;
            pColorInfo->RedGamma         = 0;
            pColorInfo->Cyan.Y           = (LDECI4)VALID_YC;
        }

        //
        // Validate pattern size
        //

        if (pDevHTInfo->HTPatternSize > HTPAT_SIZE_MAX_INDEX) {

            pDevHTInfo->HTPatternSize = HTPAT_SIZE_DEFAULT;
        }

        //
        // Check the CIE color infomation
        //

        if ((pColorInfo->Red.x < (LDECI4)CIE_x_MIN)                         ||
            (pColorInfo->Red.x > (LDECI4)CIE_x_MAX)                         ||
            (pColorInfo->Red.y < (LDECI4)CIE_y_MIN)                         ||
            (pColorInfo->Red.y > (LDECI4)CIE_y_MAX)                         ||
            (pColorInfo->Green.x < (LDECI4)CIE_x_MIN)                       ||
            (pColorInfo->Green.x > (LDECI4)CIE_x_MAX)                       ||
            (pColorInfo->Green.y < (LDECI4)CIE_y_MIN)                       ||
            (pColorInfo->Green.y > (LDECI4)CIE_y_MAX)                       ||
            (pColorInfo->Blue.x < (LDECI4)CIE_x_MIN)                        ||
            (pColorInfo->Blue.x > (LDECI4)CIE_x_MAX)                        ||
            (pColorInfo->Blue.y < (LDECI4)CIE_y_MIN)                        ||
            (pColorInfo->Blue.y > (LDECI4)CIE_y_MAX)                        ||
            (pColorInfo->AlignmentWhite.x < (LDECI4)CIE_x_MIN)              ||
            (pColorInfo->AlignmentWhite.x > (LDECI4)CIE_x_MAX)              ||
            (pColorInfo->AlignmentWhite.y < (LDECI4)CIE_y_MIN)              ||
            (pColorInfo->AlignmentWhite.y > (LDECI4)CIE_y_MAX)              ||
            (pColorInfo->AlignmentWhite.Y < (LDECI4)MIN_ALIGNMENT_WHITE)    ||
            (pColorInfo->AlignmentWhite.Y > (LDECI4)MAX_ALIGNMENT_WHITE)) {

            pLDECI4 = (LDECI4 FAR *)&(pColorInfo->Red.x);
            pUDECI4 = (UDECI4 *)&(HT_CIE_SRGB.Red.x);

            Loop = 21;

            while (Loop--) {

                *pLDECI4++ = (LDECI4)*pUDECI4++;
            }
        }

        //
        // Checking Gamma Information
        //

        if ((pColorInfo->RedGamma   < (LDECI4)MIN_RGB_GAMMA)    ||
            (pColorInfo->RedGamma   > (LDECI4)MAX_RGB_GAMMA)    ||
            (pColorInfo->GreenGamma < (LDECI4)MIN_RGB_GAMMA)    ||
            (pColorInfo->GreenGamma > (LDECI4)MAX_RGB_GAMMA)    ||
            (pColorInfo->BlueGamma  < (LDECI4)MIN_RGB_GAMMA)    ||
            (pColorInfo->BlueGamma  > (LDECI4)MAX_RGB_GAMMA)) {

            pColorInfo->RedGamma   = (LDECI4)
            pColorInfo->GreenGamma = (LDECI4)
            pColorInfo->BlueGamma  = (LDECI4)10000;
        }

        //
        // Validate Dye Mix
        //

        if ((pColorInfo->MagentaInCyanDye   > (LDECI4)9000) ||
            (pColorInfo->YellowInCyanDye    > (LDECI4)9000) ||
            (pColorInfo->CyanInMagentaDye   > (LDECI4)9000) ||
            (pColorInfo->YellowInMagentaDye > (LDECI4)9000) ||
            (pColorInfo->CyanInYellowDye    > (LDECI4)9000) ||
            (pColorInfo->MagentaInYellowDye > (LDECI4)9000)) {

            pLDECI4 = &(pColorInfo->MagentaInCyanDye);
            pUDECI4 = (UDECI4 *)&(DefaultSolidDyesInfo.MagentaInCyanDye);
            Loop    = 6;

            while (Loop--) {

                *pLDECI4++ = (LDECI4)*pUDECI4++;
            }
        }
    }
}




VOID
SetPelSizeRange(
    HWND            hDlg,
    PHTDEVADJPARAM  pHTDAP,
    BOOL            ResetFirst
    )

/*++

Routine Description:


    This function set the current scroll range for the pixel diameter


Arguments:

    hDlg        - Handle to the dialog box

    pHTDAP      - pointer to HTDEVADJPARAM

    ResetFirst  - TRUE if the DevPelsDPI is not in scroll bar format


Return Value:

    NONE


Author:

    30-Mar-1995 Thu 19:29:01 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hScroll;
    DWORD       MaxPercent;
    DWORD       MinPel;
    DWORD       MaxPel;
    DWORD       DeviceXDPI;
    LONG        DevPelsDPI;
    BOOL        UsePercent;
    extern BYTE IntHTPatSize[];


    //
    // pHTDAP->MinDevPels   Minimum pel size
    // pHTDAP->PelScrollMin Pixel Diameter scroll MAX
    // pHTDAP->PelScrollMax Pixel Diameter scroll MAX
    //

    hScroll    = GetDlgItem(hDlg, HTDevAdjScroll[0].IDDScroll);
    DevPelsDPI = (LONG)pHTDAP->CurHTInfo.DevPelsDPI;

    //
    // Convert it back from scroll format
    //

#if 0
    DbgPrint("\n*CUR* DevPelsDPI=%ld (%04lx), Scroll(%ld, %ld), MinDevPels=%ld",
            DevPelsDPI, DevPelsDPI,
            pHTDAP->PelScrollMin, pHTDAP->PelScrollMax,
            pHTDAP->MinDevPels);
#endif

    if ((ResetFirst)            ||
        (!pHTDAP->MinDevPels)   ||
        (!pHTDAP->PelScrollMin) && (!pHTDAP->PelScrollMax)) {

        //
        // If this is the first time call then we already has the number
        //

        UsePercent         = (BOOL)(DevPelsDPI & 0x8000);
        (DWORD)DevPelsDPI &= 0x7fff;

#if 0
        DbgPrint("\n*** FIRST TIME, UsePercent=%ld, DevPelsDPI=%ld",
                            UsePercent, DevPelsDPI);
#endif

    } else if (UsePercent = (DevPelsDPI < 0)) {

        DevPelsDPI = PERCENT_FROM_SCROLL(DevPelsDPI);

    } else if (DevPelsDPI > 0) {

        PEL_FROM_SCROLL(DevPelsDPI, pHTDAP->MinDevPels);
    }

    //
    // Compute the min/max PEL and PERCENTAGE for this device
    //

    if (DeviceXDPI = (DWORD)pHTDAP->DevHTAdjData.DeviceXDPI) {

        //
        // Has device resolution
        //

#if 0
        MinPel     = (LONG)((DeviceXDPI * 1675) / (1600 *
                        (DWORD)IntHTPatSize[pHTDAP->CurHTInfo.HTPatternSize]));
#endif
        MinPel     = DeviceXDPI / 6;
        MaxPel     = DeviceXDPI * 3;
        MaxPercent = (DeviceXDPI * 1000) / MinPel;

    } else {

        //
        // We do not allowed the DPI scroll
        //

        MinPel     = 0;
        MaxPel     = 0;
        MaxPercent = MAX_RES_PERCENT;

        //
        // Make the Resolution in percentage
        //

#if 0
        DbgPrint("HTUI: Warning: DevPelsDPI- Only allowed percentage changes");
#endif
        UsePercent = TRUE;
    }

#if 0
    DbgPrint("\n*Pel=%ld to %ld [%ld%%], UsePercent=%ld, DevPelsDPI=%ld",
            MinPel, MaxPel, MaxPercent, UsePercent, DevPelsDPI);
#endif
    pHTDAP->MinDevPels   = MinPel;
    pHTDAP->PelScrollMin = MaxPercent;
    pHTDAP->PelScrollMax = MaxPel;

    PERCENT_TO_SCROLL(pHTDAP->PelScrollMin);
    PEL_TO_SCROLL(pHTDAP->PelScrollMax, MinPel);

    if (DevPelsDPI) {

        if (UsePercent) {

            //
            // It specified percentage
            //

            if (DevPelsDPI < MIN_RES_PERCENT) {

                DevPelsDPI = MIN_RES_PERCENT;

            } else if (DevPelsDPI > (LONG)MaxPercent) {

                DevPelsDPI = (LONG)MaxPercent;
            }

            //
            // Convert to scroll range,
            //
#if 0
            DbgPrint("\n*DevPelsDPI=%ld PERCENT", DevPelsDPI);
#endif
            PERCENT_TO_SCROLL(DevPelsDPI);
#if 0
            DbgPrint("\n*Convert to SCROLL = DevPelsDPI=%ld PERCENT", DevPelsDPI);
#endif
        } else {

            //
            // If specified the resolution
            //

            if (DevPelsDPI < (LONG)MinPel) {

                DevPelsDPI = (LONG)MinPel;

            } else if (DevPelsDPI > (LONG)MaxPel) {

                DevPelsDPI = (LONG)MaxPel;
            }

            //
            // Convert to scroll range
            //
#if 0
            DbgPrint("\n*DevPelsDPI=%ld PEL", DevPelsDPI);
#endif
            PEL_TO_SCROLL(DevPelsDPI, MinPel);
#if 0
            DbgPrint("\n*Convert to SCROLL = DevPelsDPI=%ld PEL", DevPelsDPI);
#endif
        }
    }

    //
    // Save it back


    pHTDAP->CurHTInfo.DevPelsDPI = (DWORD)DevPelsDPI;

    //
    // Set the scroll range and position
    //
#if 0
    DbgPrint("\n*NEW* DevPelsDPI=%ld, Scroll(%ld, %ld), MinDevPels=%ld",
            DevPelsDPI, pHTDAP->PelScrollMin, pHTDAP->PelScrollMax,
            pHTDAP->MinDevPels);
#endif
    SetScrollRange(hScroll,
                   SB_CTL,
                   pHTDAP->PelScrollMin,
                   pHTDAP->PelScrollMax,
                   TRUE);

    SetScrollPos(hScroll, SB_CTL, (INT)DevPelsDPI, TRUE);

}




LONG
InitHTDevAdjDlg(
    HWND            hDlg,
    PHTDEVADJPARAM  pHTDevAdjParam
    )
/*++

Routine Description:

    This function will intialized the pop up halftone color adjustment dialog
    box, it also tempopary create a display device halftone info for halftone
    incoming DIB, it will also allocate the memory for necessary halftoned
    result to be displayed.

Arguments:

    hDlg            - The handle to the owner dialog box

    pHTDevAdjParam  - Pointer to the HTDEVRADJPARAM


Return Value:

    VOID


Author:

    02-Apr-1992 Thu 18:13:58 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND            hScroll;
    PHTDEVADJSCROLL pHTDevAdjScroll;
    INT             Loop;
    WCHAR           Buf[132];

    //
    // House keeping: Disable unused buttons, set to extended UI for combobox
    // and set the device name in the right place
    //

    SendDlgItemMessage(hDlg,
                       IDD_HTDEV_HTPAT_COMBO,
                       CB_SETEXTENDEDUI,
                       (WPARAM)TRUE,
                       (LPARAM)NULL);

    if (!(pHTDevAdjParam->pDeviceName)) {

        LoadString(hHTUIModule, IDS_UNKNOWN, Buf, COUNT_ARRAY(Buf));
        SetDlgItemText(hDlg, IDD_HTDEV_DEVICE_NAME, Buf);

    } else {

        SetDlgItemText(hDlg,
                       IDD_HTDEV_DEVICE_NAME,
                       pHTDevAdjParam->pDeviceName);
    }

    LoadString(hHTUIModule,
               IDS_PEL_SIZE_AS_DEVICE,
               PelAsDevice,
               COUNT_ARRAY(PelAsDevice));


    //
    // Validate the DEVHTINFO
    //

    ValidateDevHTInfo(pHTDevAdjParam);

    //
    // Copy current adjustment set over for user to adjust, remember we must
    // conver the PelsSize to MM now
    //

    pHTDevAdjParam->CurHTInfo = *(pHTDevAdjParam->DevHTAdjData.pAdjHTInfo);

    //
    // Fill the pattern size combo list box with all the selections
    //

    Loop = IDS_HTPAT_SIZE_MIN;

    while (Loop <= IDS_HTPAT_SIZE_MAX) {

        LoadString(hHTUIModule, Loop, Buf, COUNT_ARRAY(Buf));

        SendDlgItemMessage(hDlg,
                           IDD_HTDEV_HTPAT_COMBO,
                           CB_ADDSTRING,
                           (WPARAM)NULL,
                           (LPARAM)Buf);
        ++Loop;
    }

    //
    // Set scroll ranges, do not include the first one, the first one is the
    // Pixel size scroll which already been set ealier
    //

    for (Loop = 0, pHTDevAdjScroll = &(HTDevAdjScroll[0]);
         Loop < COUNT_HTDEVADJSCROLL;
         Loop++, pHTDevAdjScroll++ ) {

        if (hScroll = GetDlgItem(hDlg, pHTDevAdjScroll->IDDScroll)) {

            if (!Loop) {

                SetPelSizeRange(hDlg, pHTDevAdjParam, TRUE);

            } else {

                SetScrollRange(hScroll,
                               SB_CTL,
                               pHTDevAdjScroll->Min,
                               pHTDevAdjScroll->Max,
                               FALSE);
            }

            SetWindowLongPtr(hScroll, GWLP_USERDATA, Loop);
        }
    }

    return(1);
}





LONG
APIENTRY
HTDevAdjDlgProc(
    HWND    hDlg,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
/*++

Routine Description:

    This is the halftone color adjustments main DlgProc().

Arguments:

    hDlg            - The handle to the owner dialog box

    Msg             - message from window

    wParam          - First parameter

    lParam          - Second parameter.


Return Value:

    a non-zero if process message, 0 otherwise.

    This function assume is called from a DialogBoxParam() call, and expected
    the WM_INITDIALOG message will have lParam equ to initialized
    pHTDevAdjParam


Author:

    02-Apr-1992 Thu 18:13:58 created  -by-  Daniel Chou (danielc)

    06-Dec-1993 Mon 20:58:58 updated  -by-  Daniel Chou (danielc)
        Allowed F1=Help even permission flag is not set

    30-Mar-1995 Thu 10:12:24 updated  -by-  Daniel Chou (danielc)
        Dynamically change the Min/Max DevPel allowance, it also that
        if DeviceXDPI = 0 then the DevPel is in Percentage.


Revision History:


--*/

{
    HWND                hScroll;
    LPDWORD             pCurScroll;
    PHTDEVADJPARAM      pHTDevAdjParam;
    PDEVHTINFO          pCurHTInfo;
    PHTDEVADJSCROLL     pHTDevAdjScroll;
    LONG                ScrollMin;
    LONG                ScrollMax;
    LONG                ScrollCur;
    LONG                Result;
    INT                 IdxScroll;
    INT                 IdxScrollEnd;
    UINT                DeciMode;
    WORD                DlgID;
    BOOL                UpdateAll;
    WCHAR               Buf[32];



    if (Msg == WM_INITDIALOG) {

        pHTDevAdjParam = (PHTDEVADJPARAM)lParam;

        SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);

        //
        // Setup halftone UI extended help style
        //

        SetWindowLong(hDlg,
                      GWL_EXSTYLE,
                      GetWindowLong(hDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

    } else if (!(pHTDevAdjParam =
                    (PHTDEVADJPARAM)GetWindowLongPtr(hDlg, GWLP_USERDATA))) {

        return(FALSE);
    }

    IdxScroll    = 1;
    IdxScrollEnd = 0;
    UpdateAll    = FALSE;
    pCurHTInfo   = &(pHTDevAdjParam->CurHTInfo);

    switch(Msg) {

    case WM_INITDIALOG:     // set the previouse one equal to current setting

        IdxScroll    = 0;
        IdxScrollEnd = (UINT)(COUNT_HTDEVADJSCROLL - 1);
        UpdateAll    = TRUE;

        if ((Result = InitHTDevAdjDlg(hDlg, pHTDevAdjParam)) < 0) {

            EndDialog(hDlg, Result);
            return(TRUE);
        }

        break;

    case WM_DESTROY:

        return(TRUE);

    case WM_HELP:

        wParam = (WPARAM)((LPHELPINFO)lParam)->hItemHandle;
        lParam = (LPARAM)MAKELONG(((LPHELPINFO)lParam)->MousePos.x,
                                  ((LPHELPINFO)lParam)->MousePos.y);

    case WM_CONTEXTMENU:

        DoHalftoneHelp(hDlg,
                       (HWND)wParam,
                       HELP_TYPE_HTSETUP,
                       (Msg == WM_HELP) ? HELP_WM_HELP : HELP_CONTEXTMENU,
                       (DWORD)lParam);

        break;

    case WM_COMMAND:

        switch (DlgID = LOWORD(wParam)) {

        case IDD_HTDEV_HTPAT_COMBO:

            if (HIWORD(wParam) == CBN_SELCHANGE) {

                pCurHTInfo->HTPatternSize =
                                (DWORD)SendDlgItemMessage(hDlg,
                                                          DlgID,
                                                          CB_GETCURSEL,
                                                          (WPARAM)NULL,
                                                          (LPARAM)NULL);

                SetPelSizeRange(hDlg, pHTDevAdjParam, FALSE);

                IdxScroll    = 0;
                IdxScrollEnd = 1;

            } else {

                return(TRUE);
            }

            break;

        case IDOK:

            //
            // Convert the DevPelsDPI back to the halftone required format
            //

            if (!(LONG)pCurHTInfo->DevPelsDPI) {

                //
                // User want to use device standard, which compute
                // automatically by halftone
                //

                NULL;

            } else if ((LONG)pCurHTInfo->DevPelsDPI > 0) {

                //
                // User specified the pel size resolution directly
                //

                PEL_FROM_SCROLL(pCurHTInfo->DevPelsDPI,
                                pHTDevAdjParam->MinDevPels);

            } else {

                //
                // User specified the percentage
                //

                PERCENT_FROM_SCROLL(pCurHTInfo->DevPelsDPI);

                pCurHTInfo->DevPelsDPI |= 0x8000;
            }
#if 0
            DbgPrint("\nFinal DevPelsDPI=%08lx", pCurHTInfo->DevPelsDPI);
#endif
            if ((pHTDevAdjParam->UpdatePermission) &&
                (memcmp(pCurHTInfo,
                        &(pHTDevAdjParam->DevHTAdjData.pAdjHTInfo),
                        sizeof(DEVHTINFO)))) {

                if (!(pHTDevAdjParam->DevHTAdjData.DeviceFlags &
                                                    DEVHTADJF_COLOR_DEVICE)) {

                    pCurHTInfo->ColorInfo.GreenGamma =
                    pCurHTInfo->ColorInfo.BlueGamma  =
                                            pCurHTInfo->ColorInfo.RedGamma;
                }

                *(pHTDevAdjParam->DevHTAdjData.pAdjHTInfo) = *pCurHTInfo;

                EndDialog(hDlg, 1);
                return(TRUE);
            }

            //
            // Fall through to cancel it
            //

        case IDCANCEL:

            EndDialog(hDlg,  0);
            return(TRUE);

        case IDD_HTDEV_REVERT:
        case IDD_HTDEV_DEFAULT:

            *pCurHTInfo = (DlgID == IDD_HTDEV_DEFAULT) ?
                                *(pHTDevAdjParam->DevHTAdjData.pDefHTInfo) :
                                *(pHTDevAdjParam->DevHTAdjData.pAdjHTInfo);

            SetPelSizeRange(hDlg, pHTDevAdjParam, TRUE);

            IdxScroll    = 0;
            IdxScrollEnd = (INT)(COUNT_HTDEVADJSCROLL - 1);
            UpdateAll    = TRUE;

            break;

        default:

            return(FALSE);
        }

        break;

    case WM_HSCROLL:

        IdxScroll       =
        IdxScrollEnd    = (INT)GetWindowLongPtr((HWND)lParam, GWLP_USERDATA);
        pHTDevAdjScroll = &HTDevAdjScroll[IdxScroll];

        if (IdxScroll) {

            ScrollMin = (LONG)pHTDevAdjScroll->Min;
            ScrollMax = (LONG)pHTDevAdjScroll->Max;

        } else {

            ScrollMin = pHTDevAdjParam->PelScrollMin;
            ScrollMax = pHTDevAdjParam->PelScrollMax;
        }

        pCurScroll = (LPDWORD)((LPBYTE)pCurHTInfo + pHTDevAdjScroll->Offset);
        ScrollCur  = (LONG)*pCurScroll;

        switch (LOWORD(wParam)) {

        case SB_TOP:

            ScrollCur = ScrollMin;
            break;

        case SB_BOTTOM:

            ScrollCur = ScrollMax;
            break;

        case SB_PAGEUP:

            ScrollCur -= (LONG)pHTDevAdjScroll->Step;
            break;

        case SB_PAGEDOWN:

            ScrollCur += (LONG)pHTDevAdjScroll->Step;
            break;

        case SB_LINEUP:

            --ScrollCur;
            break;

        case SB_LINEDOWN:

            ++ScrollCur;
            break;

        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:

            //
            // Only for the device pixel diameter will use the negative values
            //

            ScrollCur = (LONG)((IdxScroll) ? (WORD)HIWORD(wParam) :
                                             (SHORT)HIWORD(wParam));

            break;

        default:

            return(FALSE);
        }

        if (ScrollCur < ScrollMin) {

            ScrollCur = ScrollMin;

        } else if (ScrollCur > ScrollMax) {

            ScrollCur = ScrollMax;
        }

        *pCurScroll = (DWORD)ScrollCur;

        break;

    default:

        return(FALSE);
    }


    if (UpdateAll) {

        SendDlgItemMessage(hDlg,
                           IDD_HTDEV_HTPAT_COMBO,
                           CB_SETCURSEL,
                           (WPARAM)pCurHTInfo->HTPatternSize,
                           (LPARAM)NULL);
    }

    while (IdxScroll <= IdxScrollEnd) {

        pHTDevAdjScroll = &HTDevAdjScroll[IdxScroll];

        if (hScroll = GetDlgItem(hDlg, pHTDevAdjScroll->IDDScroll)) {

            pCurScroll = (LPDWORD)((LPBYTE)pCurHTInfo +
                                   pHTDevAdjScroll->Offset);
            SetScrollPos(hScroll,
                         SB_CTL,
                         (INT)(ScrollCur = (LONG)*pCurScroll),
                         TRUE);

            if (IdxScroll) {

                DeciMode   = (UINT)pHTDevAdjScroll->DeciSize;
                wsprintf(Buf, DeciConvert[DeciMode].FormatStr,
                            (UINT)(ScrollCur / DeciConvert[DeciMode].Divider),
                            pHTDevAdjParam->pwDecimal,
                            (UINT)(ScrollCur % DeciConvert[DeciMode].Divider));

                SetDlgItemText(hDlg, pHTDevAdjScroll->IDDText, Buf);

            } else {

                if (ScrollCur == 0) {

                    SetDlgItemText(hDlg, IDD_HTDEV_PIXEL_TEXT, PelAsDevice);

                } else {

                    if (ScrollCur > 0) {

                        //
                        // Pel resolution, Cur-Max+Min-1 (0 base)
                        //

                        PEL_FROM_SCROLL(ScrollCur, pHTDevAdjParam->MinDevPels);

                        wsprintf(Buf, L"1/%ld\"", ScrollCur);

                    } else {

                        //
                        // Percentage
                        //

                        PERCENT_FROM_SCROLL(ScrollCur);

                        wsprintf(Buf, L"%ld.%ld%%", (LONG)(ScrollCur / 10),
                                                     (LONG)(ScrollCur % 10));
                    }

                    SetDlgItemText(hDlg, IDD_HTDEV_PIXEL_TEXT, Buf);
                }
            }
        }

        ++IdxScroll;
    }

    if (Msg == WM_INITDIALOG) {

        if (!pHTDevAdjParam->UpdatePermission) {

            EnumChildWindows(hDlg, DisableDlgUpdate, 0);
            DlgID = IDCANCEL;

        } else {

            DlgID = IDD_HTDEV_HTPAT_COMBO;
        }

        SetFocus(GetDlgItem(hDlg, DlgID));

        return(FALSE);

    } else {

        return(TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\htui\htuigif.h ===
HANDLE
DIBFromGIFFile(
    HFILE   hFileGIF
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\htui\htuigif.c ===
/*++

Copyright (c) 1990-1992  Microsoft Corporation


Module Name:

    htuigif.c


Abstract:

    This module contains GIF file decompression to generate a memory DIB type
    bitmap for the GIF

Author:

    21-Apr-1992 Tue 11:38:11 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:


--*/



#include <stddef.h>
#include <windows.h>

#include <stdlib.h>
#include <string.h>

#include <ht.h>

#include "htuidlg.h"
#include "htuimain.h"
#include "htuigif.h"

extern HMODULE  hHTUIModule;


//
// Following structures and #defines are only used in this C file
//


#pragma pack(1)
typedef struct _GIFRGB {           /* gifrgb */
    BYTE Red;
    BYTE Green;
    BYTE Blue;
} GIFRGB, FAR *PGIFRGB;
#pragma pack()

typedef struct _GIFMAP {
    SHORT   CurX;
    SHORT   CurY;
    SHORT   Width;
    SHORT   Height;
    } GIFMAP;

#pragma pack(1)
typedef struct _GIFHEADER {
    BYTE    Signature[3];           /* This is the 'GIF' signature          */
    BYTE    Version[3];             /* version number such as '89a'         */
    WORD    Width;                  /* Width of the picture in pels         */
    WORD    Height;                 /* Height of the picture in pels        */
    BYTE    Flags;                  /* GIFH_xxxx flags                      */
    BYTE    BColorIndex;            /* background color index               */
    BYTE    AspectRatio;            /* w/h ratio = (x + 15) / 64            */
    } GIFHEADER, *PGIFHEADER;
#pragma pack()

#define GIFH_GLOBAL_COLOR_TABLE 0x80
#define GIFH_PRIMARY_COLOR_BITS 0xe0
#define GIFH_SORTED_COLORS      0x08
#define GIFH_SIZE_COLOR_TABLE   0x07

#define GIFMAP_INTERLACE        0x40

typedef struct _GIF2DIBINFO {
    LPSHORT     pLineIncVec;
    LPBYTE      pDIBLine1;
    LPBYTE      pDIBCurLine;
    LPBYTE      pDIBNow;
    LPBYTE      pGIFBuf;
    DWORD       SizeGIFBuf;
    GIFMAP      Map;
    WORD        cx;
    WORD        cy;
    WORD        cxBytes;
    WORD        LinesDone;
    WORD        RemainXPels;
    WORD        PelMask;
    } GIF2DIBINFO, *PGIF2DIBINFO;


typedef VOID (*PFNOUTPUTPELS)(PGIF2DIBINFO pGIF2DIBInfo, UINT TotalPels);

#define SET_NEXT_DIB_PBUF                                                   \
    {                                                                       \
        SHORT   LineInc;                                                    \
                                                                            \
        GIF2DIBInfo.pDIBCurLine -=                                          \
                        (LONG)(LineInc = *(GIF2DIBInfo.pLineIncVec)) *      \
                        (LONG)GIF2DIBInfo.cxBytes;                          \
                                                                            \
        if ((GIF2DIBInfo.Map.CurY += LineInc) >= GIF2DIBInfo.Map.Height) {  \
                                                                            \
            GIF2DIBInfo.pLineIncVec++;                                      \
                                                                            \
            if (*(GIF2DIBInfo.pLineIncVec) >= 0) {                          \
                                                                            \
                GIF2DIBInfo.Map.CurY    = *(GIF2DIBInfo.pLineIncVec++);     \
                GIF2DIBInfo.pDIBCurLine = GIF2DIBInfo.pDIBLine1 -           \
                                          ((LONG)GIF2DIBInfo.Map.CurX *     \
                                           (LONG)GIF2DIBInfo.Map.CurY);     \
            }                                                               \
        }                                                                   \
                                                                            \
        ++GIF2DIBInfo.LinesDone;                                            \
                                                                            \
        GIF2DIBInfo.pDIBNow     = GIF2DIBInfo.pDIBCurLine;                  \
        GIF2DIBInfo.RemainXPels = GIF2DIBInfo.cx;                           \
        GIF2DIBInfo.PelMask     = 0;                                        \
    }                                                                       \



//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// LZW DeCompression                                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


#define MAXBITS                 12
#define SIZE_GIF_BUF            (60 * 1024)
#define SIZE_LZW_LASTCHAR       (1 << MAXBITS)
#define SIZE_LZW_RASTERBLOCK    256
#define SIZE_LZW_PREFIX         ((1 << MAXBITS) * 2)
#define SIZE_LZW_BUFS           (SIZE_LZW_LASTCHAR + SIZE_LZW_RASTERBLOCK + \
                                 SIZE_LZW_PREFIX)

typedef struct _LZWINFO {
    LPBYTE  pLastChar;
    LPBYTE  pRasterBlock;
    LPSHORT pPrefix;
    SHORT   EODCode;
    SHORT   CSMask;
    SHORT   CodeSize;
    SHORT   BitsLeft;
    DWORD   CodeBuf;
    SHORT   GetCodeRet;
    BYTE    RBIndex;
    BYTE    RBLen;
    } LZWINFO;



#define GET_GIF_CODE                                                        \
{                                                                           \
    BOOL    EODCodeBreak = FALSE;                                           \
                                                                            \
    while (LZWInfo.BitsLeft < LZWInfo.CodeSize) {                           \
                                                                            \
        if (LZWInfo.RBIndex >= LZWInfo.RBLen) {                             \
                                                                            \
            if ((!ReadFile(hFile, &LZWInfo.RBLen, 1, &cbRead, NULL))    ||  \
                (cbRead != 1)                                           ||  \
                (LZWInfo.RBLen < 1)                                     ||  \
                (!ReadFile(hFile, LZWInfo.pRasterBlock, LZWInfo.RBLen,      \
                           &cbRead, NULL))                              ||  \
                (cbRead != (DWORD)LZWInfo.RBLen)) {                         \
                                                                            \
                EODCodeBreak = TRUE;                                        \
                break;                                                      \
            }                                                               \
                                                                            \
            LZWInfo.RBIndex = 0;                                            \
        }                                                                   \
                                                                            \
        LZWInfo.CodeBuf |= (DWORD)*(LZWInfo.pRasterBlock +                  \
                                    LZWInfo.RBIndex++) << LZWInfo.BitsLeft; \
        LZWInfo.BitsLeft += 8;                                              \
    }                                                                       \
                                                                            \
    if (EODCodeBreak) {                                                     \
                                                                            \
        LZWInfo.GetCodeRet = LZWInfo.EODCode;                               \
                                                                            \
    } else {                                                                \
                                                                            \
        LZWInfo.GetCodeRet = (SHORT)(LZWInfo.CodeBuf &                      \
                                     (DWORD)LZWInfo.CSMask);                \
        LZWInfo.CodeBuf  >>= LZWInfo.CodeSize;                              \
        LZWInfo.BitsLeft  -= LZWInfo.CodeSize;                              \
    }                                                                       \
}                                                                           \


BOOL
DeCompressGIFFileToDIB(
    HANDLE          hFile,
    PGIF2DIBINFO    pGIF2DIBInfo,
    LPBYTE          pLZWBuf,
    PFNOUTPUTPELS   pfnOutputPels,
    WORD            BitCount
    )
{
    LPBYTE      pGIFBufBeg;
    LPBYTE      pGIFBufEnd;
    LPBYTE      pOutBufTail;
    LPBYTE      pOutBufHead;
    LZWINFO     LZWInfo;
    UINT        SizeGIFBuf;
    DWORD       cbRead;
    WORD        BytesMove;
    SHORT       FinalChar;
    SHORT       OldCode;
    SHORT       CurCode;
    SHORT       InitialCodeSize;
    SHORT       ClearCode;
    SHORT       MaxCode;
    SHORT       MaxCol;
    SHORT       NextCode;
    BYTE        bCh;


    //
    // First initialize all the local buffer
    //

    LZWInfo.pLastChar    = pLZWBuf;
    LZWInfo.pRasterBlock = pLZWBuf + SIZE_LZW_LASTCHAR;
    LZWInfo.pPrefix      = (LPSHORT)(LZWInfo.pRasterBlock +
                                     SIZE_LZW_RASTERBLOCK);
    LZWInfo.BitsLeft     = 0;
    LZWInfo.CodeBuf      = 0;
    LZWInfo.GetCodeRet   = 0;
    LZWInfo.RBIndex      =
    LZWInfo.RBLen        = 0;
    *(LZWInfo.pLastChar) = (BYTE)0;
    *(LZWInfo.pPrefix)   =
    FinalChar            =
    OldCode              = 0;

    if ((!ReadFile(hFile, &bCh, 1, &cbRead, NULL))  ||
        (cbRead != 1)) {

        return(FALSE);
    }

    pGIFBufBeg = pGIF2DIBInfo->pGIFBuf;
    SizeGIFBuf = (UINT)pGIF2DIBInfo->SizeGIFBuf;
    pGIFBufEnd = pGIFBufBeg + SizeGIFBuf;

    InitialCodeSize  = (SHORT)bCh;
    LZWInfo.CodeSize = ++InitialCodeSize;

    if (LZWInfo.CodeSize < 3 || LZWInfo.CodeSize > 9) {

        return(FALSE);
    }

    MaxCol          = (SHORT)((1 << BitCount) - 1);
    ClearCode       = (SHORT)(1 << (LZWInfo.CodeSize - 1));
    LZWInfo.EODCode = (SHORT)(ClearCode + 1);
    NextCode        = (SHORT)(ClearCode + 2);
    MaxCode         = (SHORT)(ClearCode << 1);
    LZWInfo.CSMask  = (SHORT)(MaxCode - 1);
    pOutBufHead     = pGIFBufBeg;


    while (TRUE) {

        //
        // GET_GIF_CODE will reeurn from this function if _ReadFile() failed,
        // otherwise it set the curretn read code into LZWInfo.GetCodeRet
        //

        GET_GIF_CODE;

        if (LZWInfo.GetCodeRet == LZWInfo.EODCode) {

            break;                                      // Done
        }

        //
        // Write out the color data if the buffer is full
        //

        if (pOutBufHead >= pGIFBufEnd) {

            pfnOutputPels(pGIF2DIBInfo, (UINT)SizeGIFBuf);
            pOutBufHead = pGIFBufBeg;
        }

        if (LZWInfo.GetCodeRet == ClearCode) {

            LZWInfo.CodeSize = InitialCodeSize;
            NextCode         = (SHORT)(ClearCode + (SHORT)2);
            MaxCode          = (SHORT)(1 << LZWInfo.CodeSize);
            LZWInfo.CSMask   = (SHORT)(MaxCode - 1);

            do {

                GET_GIF_CODE;

            } while (LZWInfo.GetCodeRet == ClearCode);


            if (LZWInfo.GetCodeRet == LZWInfo.EODCode) {

                break;

            } else if (LZWInfo.GetCodeRet >= NextCode) {

                LZWInfo.GetCodeRet = 0;
            }

            *pOutBufHead++ = (BYTE)(OldCode = FinalChar = LZWInfo.GetCodeRet);

        } else {

            CurCode = LZWInfo.GetCodeRet;

            //
            // At here, we guranteed that at least one byte in the buffer
            // is available
            //

            pOutBufTail = pGIFBufEnd;

            if (CurCode == NextCode) {

                *--pOutBufTail = (BYTE)FinalChar;
                CurCode        = OldCode;

            } else if (CurCode > NextCode) {

                return(FALSE);
            }

            while (CurCode > MaxCol) {

                if (pOutBufTail <= pOutBufHead) {

                    //
                    // Output some when buffer full
                    //

                    pfnOutputPels(pGIF2DIBInfo, (UINT)(pOutBufHead-pGIFBufBeg));
                    pOutBufHead = pGIFBufBeg;
                }

                *--pOutBufTail = *(LZWInfo.pLastChar + CurCode);
                CurCode        = *(LZWInfo.pPrefix + CurCode);
            }

            if (pOutBufTail <= pOutBufHead) {

                pfnOutputPels(pGIF2DIBInfo, (UINT)(pOutBufHead - pGIFBufBeg));
                pOutBufHead = pGIFBufBeg;
            }

            *--pOutBufTail = (BYTE)(FinalChar = CurCode);

            //
            // Need to move little bit, we guranteed that we minimum
            // has one byte generated in this ELSE()
            //

            if (pOutBufTail > pOutBufHead) {

                memmove(pOutBufHead,
                        pOutBufTail,
                        BytesMove = (WORD)(pGIFBufEnd - pOutBufTail));

                pOutBufHead += BytesMove;

            } else {

                //
                // We are exactly fill up the buffer, so do not need to
                // move but just advance the pointer
                //

                pOutBufHead = pGIFBufEnd;
            }

            if (NextCode < MaxCode) {

                *(LZWInfo.pPrefix + NextCode)   = OldCode;
                *(LZWInfo.pLastChar + NextCode) = (BYTE)(FinalChar = CurCode);
                OldCode                         = LZWInfo.GetCodeRet;
            }

            if ((++NextCode >= MaxCode) &&
                (LZWInfo.CodeSize < MAXBITS)) {

                ++LZWInfo.CodeSize;
                MaxCode        <<= 1;
                LZWInfo.CSMask   = (SHORT)(MaxCode - 1);
            }
        }
    }

    if (pOutBufHead > pGIFBufBeg) {

        pfnOutputPels(pGIF2DIBInfo, (UINT)(pOutBufHead - pGIFBufBeg));
        pOutBufHead = pGIFBufBeg;
    }

    return(TRUE);
}



VOID
Output8BPP(
    PGIF2DIBINFO    pGIF2DIBInfo,
    UINT            TotalPels
    )
{
    GIF2DIBINFO GIF2DIBInfo;
    LPBYTE      pGIFBuf;
    UINT        CopySize;


    GIF2DIBInfo = *pGIF2DIBInfo;
    pGIFBuf     = GIF2DIBInfo.pGIFBuf;

    while (TotalPels) {

        CopySize = (TotalPels > (UINT)GIF2DIBInfo.RemainXPels) ?
                                    (UINT)GIF2DIBInfo.RemainXPels : TotalPels;

        CopyMemory(GIF2DIBInfo.pDIBNow, pGIFBuf, CopySize);

        GIF2DIBInfo.pDIBNow += CopySize;
        pGIFBuf             += CopySize;
        TotalPels           -= CopySize;

        if (!(GIF2DIBInfo.RemainXPels -= (WORD)CopySize)) {

            SET_NEXT_DIB_PBUF;
        }
    }

    *pGIF2DIBInfo = GIF2DIBInfo;
}



VOID
Output4BPP(
    PGIF2DIBINFO    pGIF2DIBInfo,
    UINT            TotalPels
    )
{
    GIF2DIBINFO GIF2DIBInfo;
    LPBYTE      pGIFBuf;
    UINT        CopySize;


    GIF2DIBInfo = *pGIF2DIBInfo;
    pGIFBuf     = GIF2DIBInfo.pGIFBuf;


    while (TotalPels) {

        CopySize = (TotalPels > (UINT)GIF2DIBInfo.RemainXPels) ?
                                    (UINT)GIF2DIBInfo.RemainXPels : TotalPels;

        TotalPels               -= (WORD)CopySize;
        GIF2DIBInfo.RemainXPels -= (WORD)CopySize;

        while (CopySize--) {

            if (GIF2DIBInfo.PelMask ^= 0x01) {

                *GIF2DIBInfo.pDIBNow++ |= (BYTE)(*pGIFBuf++ & 0x0f);

            } else {

                *GIF2DIBInfo.pDIBNow = (BYTE)(*pGIFBuf++ << 4);
            }
        }

        if (!GIF2DIBInfo.RemainXPels) {

            SET_NEXT_DIB_PBUF;
        }
    }

    *pGIF2DIBInfo = GIF2DIBInfo;
}




VOID
Output1BPP(
    PGIF2DIBINFO    pGIF2DIBInfo,
    UINT            TotalPels
    )
{
    GIF2DIBINFO GIF2DIBInfo;
    LPBYTE      pGIFBuf;
    UINT        CopySize;
    BYTE        bPel;


    GIF2DIBInfo = *pGIF2DIBInfo;
    pGIFBuf     = GIF2DIBInfo.pGIFBuf;


    while (TotalPels) {

        CopySize = (TotalPels > (UINT)GIF2DIBInfo.RemainXPels) ?
                                    (UINT)GIF2DIBInfo.RemainXPels : TotalPels;

        TotalPels               -= CopySize;
        GIF2DIBInfo.RemainXPels -= (WORD)CopySize;

        bPel = (BYTE)((GIF2DIBInfo.PelMask) ? *GIF2DIBInfo.pDIBNow : 0);

        while (CopySize--) {

            bPel = (BYTE)((bPel << 1) | ((*pGIFBuf++) & 0x01));

            if (++GIF2DIBInfo.PelMask == 8) {

                *GIF2DIBInfo.pDIBNow++ = bPel;
                bPel                   = 0;
                GIF2DIBInfo.PelMask    = 0;

            }
        }

        if (GIF2DIBInfo.PelMask) {

            *(GIF2DIBInfo.pDIBNow) = bPel;
        }

        if (!GIF2DIBInfo.RemainXPels) {

            SET_NEXT_DIB_PBUF;
        }
    }

    *pGIF2DIBInfo = GIF2DIBInfo;
}



HANDLE
ReadGIFFile(
    HANDLE  hFile
    )
{
    static SHORT        NotInterleaved[] = { 0, 1, -1, -1};
    static SHORT        Interleaved[]    = { 0, 8, 4, 8, 2, 4, 1, 2, -1, -1};
    PFNOUTPUTPELS       pfnOutputPels;
    LPBYTE              pLZWBuf;
    LPBYTE              pDIB;
    HANDLE              hDIB;
    PGIFRGB             pGIFRGB;
    RGBQUAD             FAR *pRGBQUAD;
    GIFHEADER           GIFHeader;
    BITMAPINFOHEADER    biGIF;
    GIF2DIBINFO         GIF2DIBInfo;
    DWORD               cbRead;
    DWORD               GIFPalSize;
    WORD                BitCount;
    WORD                ColorCount;
    WORD                Loop;
    BOOL                Ok = TRUE;
    BYTE                Seperator;
    BYTE                iFlags;



    SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

    if ((!ReadFile(hFile, &GIFHeader, sizeof(GIFHEADER), &cbRead, NULL))    ||
        (cbRead != sizeof(GIFHEADER))                                       ||
        (strncmp(GIFHeader.Signature, "GIF", 3))) {

        return(NULL);                       // non-gif
    }

    biGIF.biSize          = sizeof(BITMAPINFOHEADER);
    biGIF.biWidth         = (DWORD)(GIF2DIBInfo.cx = (WORD)GIFHeader.Width);
    biGIF.biHeight        = (DWORD)(GIF2DIBInfo.cy = (WORD)GIFHeader.Height);
    biGIF.biPlanes        = 1;
    BitCount              =
    biGIF.biBitCount      = (WORD)((GIFHeader.Flags & 0x07) + 1);
    biGIF.biCompression   = (DWORD)BI_RGB;
    biGIF.biXPelsPerMeter = 0;
    biGIF.biYPelsPerMeter = 0;

    if (BitCount == 1) {

        pfnOutputPels = Output1BPP;

    } else if (BitCount <= 4) {

        pfnOutputPels = Output4BPP;
        biGIF.biBitCount = 4;

    } else if (BitCount <= 8) {

        pfnOutputPels    = Output8BPP;
        biGIF.biBitCount = 8;

    } else {

        return(NULL);
    }


    biGIF.biClrUsed       =
    biGIF.biClrImportant  = (DWORD)1 << biGIF.biBitCount;

    GIFPalSize            = (DWORD)sizeof(RGBQUAD) * (DWORD)biGIF.biClrUsed;
    GIF2DIBInfo.cxBytes   = (WORD)ALIGN_BPP_DW(GIF2DIBInfo.cx,
                                               biGIF.biBitCount);

    biGIF.biSizeImage = (DWORD)GIF2DIBInfo.cxBytes * (DWORD)GIF2DIBInfo.cy;

    if (!(hDIB = GlobalAlloc(GHND, (DWORD)sizeof(BITMAPINFOHEADER) +
                                   GIFPalSize + (DWORD)biGIF.biSizeImage))) {

        return(NULL);
    }

    GIF2DIBInfo.SizeGIFBuf = (DWORD)SIZE_GIF_BUF;

    if (!(GIF2DIBInfo.pGIFBuf = (LPBYTE)LocalAlloc(LPTR,
                                                   GIF2DIBInfo.SizeGIFBuf))) {

        GlobalFree(hDIB);
        return(NULL);                       // no memory for decompress
    }

    if (!(pLZWBuf = (LPBYTE)LocalAlloc(LPTR, SIZE_LZW_BUFS))) {

        GlobalFree(hDIB);
        LocalFree((HANDLE)GIF2DIBInfo.pGIFBuf);
        return(NULL);
    }

    pDIB                      = GlobalLock(hDIB);
    *(LPBITMAPINFOHEADER)pDIB = biGIF;

    if (GIFHeader.Flags & GIFH_GLOBAL_COLOR_TABLE) {

        ColorCount = (WORD)(1 << BitCount);

        pGIFRGB  = (PGIFRGB)(pDIB + sizeof(BITMAPINFOHEADER) +
                             ((sizeof(RGBQUAD) - sizeof(GIFRGB)) * ColorCount));

        pRGBQUAD = (RGBQUAD FAR *)(pDIB + sizeof(BITMAPINFOHEADER));

        if ((!ReadFile(hFile,
                       pGIFRGB,
                       sizeof(GIFRGB) * ColorCount,
                       &cbRead,
                       NULL))   ||
            (cbRead != sizeof(GIFRGB) * ColorCount)) {

            Ok = FALSE;

        } else {

            for (Loop = 0; Loop < ColorCount; Loop++) {

                pRGBQUAD->rgbRed      = pGIFRGB->Red;
                pRGBQUAD->rgbGreen    = pGIFRGB->Green;
                pRGBQUAD->rgbBlue     = pGIFRGB->Blue;
                pRGBQUAD->rgbReserved = 0;

                ++pRGBQUAD;
                ++pGIFRGB;
            }

            if (Loop = (WORD)(biGIF.biClrUsed - ColorCount)) {

                ZeroMemory((LPVOID)pRGBQUAD, Loop * sizeof(RGBQUAD));
            }
        }
    }

    if ((!Ok)                                                               ||
        (!ReadFile(hFile, &Seperator, sizeof(Seperator), &cbRead, NULL))    ||
        (cbRead != sizeof(Seperator))                                       ||
        (!ReadFile(hFile,
                   &(GIF2DIBInfo.Map),
                   sizeof(GIFMAP),
                   &cbRead,
                   NULL))                                                   ||
        (cbRead != sizeof(GIFMAP))                                          ||
        (!ReadFile(hFile, &iFlags, sizeof(iFlags), &cbRead, NULL))          ||
        (cbRead != sizeof(iFlags))) {

        Ok = FALSE;

    } else {

        GIF2DIBInfo.pLineIncVec = (LPSHORT)((iFlags & GIFMAP_INTERLACE) ?
                                                Interleaved : NotInterleaved);
        GIF2DIBInfo.Map.CurY    = *(GIF2DIBInfo.pLineIncVec++);
        GIF2DIBInfo.Map.CurX    = 0;
        GIF2DIBInfo.PelMask     =
        GIF2DIBInfo.LinesDone   = 0;
        GIF2DIBInfo.RemainXPels = GIF2DIBInfo.cx;
        GIF2DIBInfo.pDIBLine1   =
        GIF2DIBInfo.pDIBCurLine =
        GIF2DIBInfo.pDIBNow     = pDIB +
                                  (DWORD)sizeof(BITMAPINFOHEADER) +
                                  (DWORD)GIFPalSize +
                                  ((DWORD)(GIF2DIBInfo.cy - 1) *
                                   (DWORD)GIF2DIBInfo.cxBytes);

        Ok = DeCompressGIFFileToDIB(hFile,
                                    &GIF2DIBInfo,
                                    pLZWBuf,
                                    pfnOutputPels,
                                    BitCount);
    }

    LocalFree((HANDLE)GIF2DIBInfo.pGIFBuf);
    LocalFree((HANDLE)pLZWBuf);
    GlobalUnlock(hDIB);

    if (!Ok) {

        GlobalFree(hDIB);
        hDIB = NULL;
    }

    return(hDIB);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\htui\htuimain.h ===
#define BFT_ICON            0x4349   /* 'IC' */
#define BFT_BITMAP          0x4d42   /* 'BM' */
#define BFT_CURSOR          0x5450   /* 'PT' */

#define ISDIB(bft)          ((bft) == BFT_BITMAP)

#define WM_HALFTONE_UI              (WM_USER + 3000)
#define HTUI_MSG_GETPAL             0
#define HTUI_MSG_CLRADJ_CHANGED     1

#define ALIGN_BPP_DW(cx, bpp)   (((((DWORD)cx * (DWORD)bpp) + 31L) & ~31) >> 3)

#ifndef _WINDDI_

typedef LONG  LDECI4;

typedef struct _CIECHROMA
{
    LDECI4   x;
    LDECI4   y;
    LDECI4   Y;
}CIECHROMA;

typedef struct _COLORINFO
{
    CIECHROMA  Red;
    CIECHROMA  Green;
    CIECHROMA  Blue;
    CIECHROMA  Cyan;
    CIECHROMA  Magenta;
    CIECHROMA  Yellow;
    CIECHROMA  AlignmentWhite;

    LDECI4  RedGamma;
    LDECI4  GreenGamma;
    LDECI4  BlueGamma;

    LDECI4  MagentaInCyanDye;
    LDECI4  YellowInCyanDye;
    LDECI4  CyanInMagentaDye;
    LDECI4  YellowInMagentaDye;
    LDECI4  CyanInYellowDye;
    LDECI4  MagentaInYellowDye;
}COLORINFO, *PCOLORINFO;


typedef struct _DEVHTINFO {
    DWORD       HTFlags;
    DWORD       HTPatternSize;
    DWORD       DevPelsDPI;
    COLORINFO   ColorInfo;
    } DEVHTINFO, *PDEVHTINFO;

#define DEVHTADJF_COLOR_DEVICE      0x00000001
#define DEVHTADJF_ADDITIVE_DEVICE   0x00000002

typedef struct _DEVHTADJDATA {
    DWORD       DeviceFlags;
    DWORD       DeviceXDPI;
    DWORD       DeviceYDPI;
    PDEVHTINFO  pDefHTInfo;
    PDEVHTINFO  pAdjHTInfo;
    } DEVHTADJDATA, *PDEVHTADJDATA;

#endif

#ifdef _HTUI_APIS_


typedef struct _HTDEVADJPARAM {
    DWORD               HelpID;
    LPWSTR              pDeviceName;
    LPWSTR              pwDecimal;
    DEVHTADJDATA        DevHTAdjData;
    DEVHTINFO           CurHTInfo;
    LONG                PelScrollMin;
    LONG                PelScrollMax;
    DWORD               MinDevPels;
    BYTE                UpdatePermission;
    BYTE                NotUsed[3];
    } HTDEVADJPARAM, FAR *PHTDEVADJPARAM;


#define HTCAPF_SHOW_MONO        0x0001
#define HTCAPF_CAN_UPDATE       0x0002
#define HTCAPF_FORCE_OK         0x0004

typedef struct _HTCLRADJPARAM {
    DWORD               HelpID;
    LPWSTR              pCallerTitle;

#ifdef HTUI_STATIC_HALFTONE
    PHTINITINFO         pHTInitInfo;
#endif
    HWND                hDlg;
    HWND                hWndBmp;
    HWND                hWndApp;
    HDC                 hDCDlg;
    LPWSTR              pwDecimal;
    HANDLE              hDefDIB;                    // the DIB from resource
    HANDLE              hSrcDIB;
    HANDLE              hCurDIB;
    HANDLE              hHTDIB;
    LPWSTR              pDefDIBTitle;
    HPALETTE            hHTPal;
    HPALETTE            hPalApp;
    PCOLORADJUSTMENT    pCallerHTClrAdj;
    COLORADJUSTMENT     CallerHTClrAdj;
    COLORADJUSTMENT     LastHTClrAdj;
    COLORADJUSTMENT     CurHTClrAdj;
    RECT                rcBmp;
    RECT                rcDlg;
    WORD                BmpFlags;
    WORD                Flags;
    BYTE                ViewMode;
    BYTE                BmpNeedUpdate;
    WORD                RedGamma;
    WORD                GreenGamma;
    WORD                BlueGamma;
    } HTCLRADJPARAM, FAR *PHTCLRADJPARAM;

#define HT_BMP_PALETTE          0x0001
#define HT_BMP_SCALE            0x0002
#define HT_BMP_AUTO_MOVE        0x0004
#define HT_BMP_AT_TOP           0x0008
#define HT_BMP_MIRROR           0x0010
#define HT_BMP_NEGATIVE         0x0020
#define HT_BMP_UPSIDEDOWN       0x0040
#define HT_BMP_ENABLE           0x0080
#define HT_BMP_ZOOM             0x0100
#define HT_BMP_SYNC_R           0x0200
#define HT_BMP_SYNC_G           0x0400
#define HT_BMP_SYNC_B           0x0800

#define AVAI_HT_BMP_MASKS   (HT_BMP_PALETTE         |   \
                             HT_BMP_SCALE           |   \
                             HT_BMP_AUTO_MOVE       |   \
                             HT_BMP_AT_TOP          |   \
                             HT_BMP_MIRROR          |   \
                             HT_BMP_NEGATIVE        |   \
                             HT_BMP_UPSIDEDOWN      |   \
                             HT_BMP_ENABLE          |   \
                             HT_BMP_ZOOM            |   \
                             HT_BMP_SYNC_R          |   \
                             HT_BMP_SYNC_G          |   \
                             HT_BMP_SYNC_B)


#define VIEW_MODE_TABLE         FILL_MODE_TABLE
#define VIEW_MODE_REFCOLORS     FILL_MODE_REFCOLORS
#define VIEW_MODE_RGB           FILL_MODE_RGB
#define VIEW_MODE_NTSC_BAR      FILL_MODE_NTSC_BAR
#define VIEW_MODE_PIC_DEF_DIB   255
#define VIEW_MODE_PIC_LOADED    254

#define VIEW_MODE_PIC_START     VIEW_MODE_PIC_LOADED

//
// HELP
//

#define TMP_HELP_WND_ID         0x7fff

#define HELP_TYPE_HTCLRADJ      0
#define HELP_TYPE_HTSETUP       1


typedef struct _HTHELPID {
    WORD    DlgID;
    WORD    HelpID;
    } HTHELPID, *PHTHELPID;


//
// Help IDs
//

#define IDH_HTCLR_CONTRAST          26000
#define IDH_HTCLR_BRIGHTNESS        26010
#define IDH_HTCLR_COLOR             26020
#define IDH_HTCLR_TINT              26030
#define IDH_HTCLR_DARK_PIC          26040
#define IDH_HTCLR_NEGATIVE          26050
#define IDH_HTCLR_ILLUMINANT        26060
#define IDH_HTCLR_LINEAR_GAMMA      26070
#define IDH_HTCLR_SYNC_R_CHKBOX     26080
#define IDH_HTCLR_SYNC_G_CHKBOX     26090
#define IDH_HTCLR_SYNC_B_CHKBOX     26100
#define IDH_HTCLR_RED_GAMMA         26110
#define IDH_HTCLR_GREEN_GAMMA       26120
#define IDH_HTCLR_BLUE_GAMMA        26130
#define IDH_HTCLR_BLACK_REF         26140
#define IDH_HTCLR_WHITE_REF         26150
#define IDH_HTCLR_PICTURE_NAME      26160
#define IDH_HTCLR_PICTURE_DESC      26170
#define IDH_HTCLR_VIEW              26180
#define IDH_HTCLR_MAXIMIZE          26190
#define IDH_HTCLR_PALETTE           26200
#define IDH_HTCLR_SCALE             26210
#define IDH_HTCLR_FLIP_X            26220
#define IDH_HTCLR_FLIP_Y            26230
#define IDH_HTCLR_OK                26240
#define IDH_HTCLR_CANCEL            26250
#define IDH_HTCLR_DEFAULT           26260
#define IDH_HTCLR_REVERT            26270
#define IDH_HTCLR_OPEN              26280
#define IDH_HTCLR_SAVE_AS           26290



#define IDH_HTDEV_DEVICE_NAME       26500
#define IDH_HTDEV_HTPAT             26510
#define IDH_HTDEV_DEV_GAMMA         26520
#define IDH_HTDEV_PIXEL_DIAMETER    26530
#define IDH_HTDEV_RGBW_CIE_XY       26540
#define IDH_HTDEV_CMY_DYE_PERCENT   26550
#define IDH_HTDEV_DEV_RED_GAMMA     26560
#define IDH_HTDEV_DEV_GREEN_GAMMA   26570
#define IDH_HTDEV_DEV_BLUE_GAMMA    26580
#define IDH_HTDEV_OK                26590
#define IDH_HTDEV_CANCEL            26600
#define IDH_HTDEV_DEFAULT           26610
#define IDH_HTDEV_REVERT            26620
#define IDH_HTDEV_ALIGNMENT_WHITE   26630




//
// Exported Window procedure
//

LONG
APIENTRY
HTClrAdjDlgProc(
    HWND    hDlg,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    );

LONG
APIENTRY
HTDevAdjDlgProc(
    HWND    hDlg,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    );

#if DBG
void  DbgPrint( char *, ... );
#endif



#endif  // _HTUI_APIS_


LONG
APIENTRY
HTUI_ColorAdjustmentW(
    LPWSTR              pCallerTitle,
    HANDLE              hDefDIB,
    LPWSTR              pDefDIBTitle,
    PCOLORADJUSTMENT    pColorAdjustment,
    BOOL                ShowMonochromeOnly,
    BOOL                UpdatePermission
    );

LONG
APIENTRY
HTUI_ColorAdjustmentA(
    LPSTR               pCallerTitle,
    HANDLE              hDefDIB,
    LPSTR               pDefDIBTitle,
    PCOLORADJUSTMENT    pColorAdjustment,
    BOOL                ShowMonochromeOnly,
    BOOL                UpdatePermission
    );

LONG
APIENTRY
HTUI_ColorAdjustment(
    LPSTR               pCallerTitle,
    HANDLE              hDefDIB,
    LPSTR               pDefDIBTitle,
    PCOLORADJUSTMENT    pColorAdjustment,
    BOOL                ShowMonochromeOnly,
    BOOL                UpdatePermission
    );

LONG
APIENTRY
HTUI_DeviceColorAdjustmentW(
    LPWSTR          pDeviceName,
    PDEVHTADJDATA   pDevHTAdjData
    );

LONG
APIENTRY
HTUI_DeviceColorAdjustmentA(
    LPSTR           pDeviceName,
    PDEVHTADJDATA   pDevHTAdjData
    );

LONG
APIENTRY
HTUI_DeviceColorAdjustment(
    LPSTR           pDeviceName,
    PDEVHTADJDATA   pDevHTAdjData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\sample\hp970c\multicolor\compress.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  2000  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Enable.cpp
//    
//
//  PURPOSE:  Enable routines for User Mode COM Customization DLL.
//
//
//	Functions:
//
//		
//
//
//  PLATFORMS:	Windows NT/2000
//

#include "precomp.h"
#include <PRCOMOEM.H>
#include "debug.h"
#include "multicoloruni.h"


static const BYTE HPBegRaster[] = "\x1B*r1A\x1B*b2m";
static const BYTE HPEndRaster[] = "0M\x1B*rC";



DWORD
CompressToTIFF(
    LPBYTE  pbSrc,
    LPBYTE  pbDst,
    LPBYTE  pbDstEnd,
    DWORD   Size
    )

/*++

Routine Description:


    This function takes the source data and compresses it into the TIFF
    packbits format into the destination buffer pbDst.

    The TIFF packbits compression format consists of a CONTROL byte followed
    by the BYTE data. The CONTROL byte has the following range.

    -1 to -127  = The data byte followed by the control byte is repeated
                  ( -(Control Byte) + 1 ) times.

    0 to 127    = There are 1 to 128 literal bytes following the CONTROL byte.
                  The count is = (Control Byte + 1)

    -128        = NOP

Arguments:

    pbSrc   - The source data to be compressed

    pbDst   - The compressed TIFF packbits format data

    Size    - Count of the data in the source and destination

Return Value:

    >0  - Compress sucessful and return value is the total bytes in pbDst
    =0  - All bytes are zero nothing to be compressed.
    <0  - Compress data is larger than the source, compression failed and
          pbDst has copy of original source data

Author:

    18-Feb-1994 Fri 09:54:47 created  -by-  DC

    24-Feb-1994 Thu 10:43:01 updated  -by-  DC
        Changed the logic so when multiple MAX repeats count is sent and last
        repeat chunck is less than TIFF_MIN_REPEATS then we will treat that as
        literal to save more space

    09-Jun-2000 Fri 10:28:56 updated  -by-  Daniel Chou (danielc)
        Updated so that it will always return a number >= 0


Revision History:


--*/

{
    LPBYTE  pbSrcBeg;
    LPBYTE  pbSrcEnd;
    LPBYTE  pbDstBeg;
    LPBYTE  pbLastRepeat;
    LPBYTE  pbTmp;
    DWORD   RepeatCount;
    DWORD   LiteralCount;
    DWORD   CurSize;
    BYTE    LastSrc;


    pbSrcBeg     = pbSrc;
    pbSrcEnd     = pbSrc + Size;
    pbDstBeg     = pbDst;
    pbLastRepeat = pbSrc;

    while (pbSrcBeg < pbSrcEnd) {

        pbTmp   = pbSrcBeg;
        LastSrc = *pbTmp++;

        while ((pbTmp < pbSrcEnd) &&
               (*pbTmp == LastSrc)) {

            ++pbTmp;
        }

        if (((RepeatCount = (LONG)(pbTmp - pbSrcBeg)) >= TIFF_MIN_REPEATS) ||
            (pbTmp >= pbSrcEnd)) {

            //
            // Check to see if we are repeating ZERO's to the end of the
            // scan line, if such is the case. Simply mark the line as
            // autofill ZERO to the end, and exit.
            //

            LiteralCount = (DWORD)(pbSrcBeg - pbLastRepeat);

            if ((pbTmp >= pbSrcEnd) &&
                (RepeatCount)       &&
                (LastSrc == 0)) {

                if (RepeatCount == Size) {

                    return(0);
                }

                RepeatCount = 0;

            } else if (RepeatCount < TIFF_MIN_REPEATS) {

                //
                // If we have repeating data, but not enough to make it
                // worthwhile to encode, then treat the data as literal and
                // don't compress.

                LiteralCount += RepeatCount;
                RepeatCount   = 0;
            }

            //
            // Setting literal count
            //

            while (LiteralCount) {

                if ((CurSize = LiteralCount) > TIFF_MAX_LITERAL) {

                    CurSize = TIFF_MAX_LITERAL;
                }

                if ((DWORD)(pbDstEnd - pbDst) <= CurSize) {

                    //
                    // Compressed turn it into larger then we can, so return
                    // original source data
                    //

                    DbgPrint("Error: TIFF_MAX_LITERAL: Buffer Overrun");
                    return((DWORD)(pbDst - pbDstBeg));
                }

                //
                // Set literal control bytes from 0-127
                //

                *pbDst++ = (BYTE)(CurSize - 1);

                CopyMemory(pbDst, pbLastRepeat, CurSize);

                pbDst        += CurSize;
                pbLastRepeat += CurSize;
                LiteralCount -= CurSize;
            }

            //
            // Setting repeat count if any
            //

            while (RepeatCount) {

                if ((CurSize = RepeatCount) > TIFF_MAX_REPEATS) {

                    CurSize = TIFF_MAX_REPEATS;
                }

                if ((pbDstEnd - pbDst) < 2) {

                    //
                    // Compressed turn it into larger then we can, so return
                    // original source data
                    //

                    DbgPrint("TIFF_MAX_REPEAT: Buffer overrun");

                    return((DWORD)(pbDst - pbDstBeg));
                }

                //
                // Set Repeat Control bytes from -1 to -127
                //

                *pbDst++ = (BYTE)(1 - CurSize);
                *pbDst++ = (BYTE)LastSrc;

                //
                // If we have more than TIFF_MAX_REPEATS then we want to make
                // sure we used the most efficient method to send.  If we have
                // remaining repeated bytes less than TIFF_MIN_REPEATS then
                // we want to skip those bytes and use literal for the next run
                // since that is more efficient.
                //

                if ((RepeatCount -= CurSize) < TIFF_MIN_REPEATS) {

                    pbTmp       -= RepeatCount;
                    RepeatCount  = 0;
                }
            }

            pbLastRepeat = pbTmp;
        }

        pbSrcBeg = pbTmp;
    }

    return((DWORD)(pbDst - pbDstBeg));
}





HRESULT
EnterRTLScan(
    PMULTICOLORPDEV pMCPDev
    )

/*++

Routine Description:

    This function set the printer into the raster mode, look at HPBegRaster
    which put the printer also in the Compress TIFF mode,  notice that the
    end of the commands is lower case 'm' so that a continue "\x1b*" do not
    have to re-send during the image dump.

    This driver will dump the images from begining to the end, skip the blank
    scanlines using cBlankY counter.


Arguments:

    pMCPDEV


Return Value:




Author:

    09-Jun-2000 Fri 13:45:36 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HRESULT hResult = S_OK;
    DWORD   cbW;

    DbgPrint("\n***EnterRTLScan: RESET cBlandY, Send Begin Raster ***");

    pMCPDev->HPOutData.cBlankY      = 0;
    pMCPDev->HPOutData.CompressMode = COMPRESS_MODE_TIFF;

    WRITE_DATA(pMCPDev, HPBegRaster, sizeof(HPBegRaster) - 1);

    return(hResult);
}



HRESULT
ExitRTLScan(
    PMULTICOLORPDEV pMCPDev
    )

/*++

Routine Description:

    This function set the printer out of the raster mode, look at HPEndRaster
    which put the printer also in the Compress NONE mode,  notice that the
    begining of the commands is upper case 'M' to terminate "\x1b*" command
    prefix.

    The commands send also terminate the raster mode.  Notice that the
    COMPRESS_MODE_NONE is compared, this driver will only doing the bitmap
    dump. (full bitmap mode) so the compresss mode will always in TIFF mode
    after the EnterRTLScan(),  If any changes made to the compress mode change
    then this function must modified.


Arguments:




Return Value:




Author:

    09-Jun-2000 Fri 13:45:36 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HRESULT hResult = S_OK;
    DWORD   cbW;

    DbgPrint("\n***ExitRTLScan: Page=%ld", pMCPDev->iPage);

    if (pMCPDev->HPOutData.CompressMode != COMPRESS_MODE_NONE) {

        pMCPDev->HPOutData.cBlankY      = 0;
        pMCPDev->HPOutData.CompressMode = COMPRESS_MODE_TIFF;

        DbgPrint("\n*** Send End Raster Commands ***");

        WRITE_DATA(pMCPDev, HPEndRaster, sizeof(HPEndRaster) - 1);
    }

    return(hResult);
}




HRESULT
OutputRTLScan(
    PMULTICOLORPDEV pMCPDev
    )

/*++

Routine Description:

    This function will output one scan line of RTL data and compress it if
    it can.

Arguments:

    pRTLScans       - Pointer to the RTLSCANS data structure

Return Value:

    BOOLEAN


Author:

    18-Feb-1994 Fri 15:52:42 created  -by-  DC

    21-Feb-1994 Mon 13:20:00 updated  -by-  DC
        Make if output faster in scan line output

    16-Mar-1994 Wed 15:38:23 updated  -by-  DC
        Update so the source mask so it is restored after mask

Revision History:


--*/

{
    LPBYTE      pbCompress;
    LPBYTE      pbEndCompress;
    LPBYTE      pbBuf;
    HRESULT     hResult;
    PSCANINFO   pSI;
    UINT        cSI;
    DWORD       Count;
    DWORD       cbW;


    //
    // If we are at the last scan line, turn the flag off so we are forced to
    // exit.
    //

    hResult    = S_OK;
    pbCompress = pMCPDev->HPOutData.pbCompress;

    if (pMCPDev->HPOutData.cBlankY) {

        DbgPrint("\nOutput %ld Blank Lines", pMCPDev->HPOutData.cBlankY);

        Count = (DWORD)sprintf((LPSTR)pbCompress,
                               "%ldy",
                               pMCPDev->HPOutData.cBlankY);

        WRITE_DATA(pMCPDev, pbCompress, Count);

        //
        // Reset it back to zero for next run
        //

        pMCPDev->HPOutData.cBlankY = 0;
    }

    //
    // Move ahead so save the room for the buffer that we will used to
    // send the commands
    //

    pbCompress    += EXTRA_COMPRESS_BUF_SIZE;
    pbEndCompress = pMCPDev->HPOutData.pbEndCompress;
    pSI           = pMCPDev->HPOutData.ScanInfo;
    cSI           = pMCPDev->HPOutData.cScanInfo;

    while ((hResult == S_OK) && (cSI--)) {

        Count = CompressToTIFF(pSI->pb,
                               pbBuf = pbCompress,
                               pbEndCompress,
                               pSI->cb);

        ++pSI;

        //
        // We will send out the compression buffer as #m#v@@@
        // where @@@ is the compression buffer, #m is changed compress mode
        // and #v or #w is the buffer count
        //

        *(--pbBuf) = (cSI) ? 'v' : 'w';

#if defined(_X86_)

        _asm {
                mov     edi, pbBuf
                mov     eax, Count
                mov     ebx, 10
DivLoop:
                xor     edx, edx
                div     ebx
                add     dl, '0'
                dec     edi
                mov     BYTE PTR [edi], dl
                or      eax, eax
                jnz     DivLoop
                mov     pbBuf, edi
        }
#else
        {
            cbW = Count;

            do {

                *(--(pbBuf)) = (BYTE)(cbW % 10) + '0';

            } while (cbW /= 10);
        }
#endif
        //
        // Add in the extra data byte we added
        //

        Count += (DWORD)(pbCompress - pbBuf);

        WRITE_DATA(pMCPDev, pbBuf, Count);
    }

    return(hResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\sample\hp970c\multicolor\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows NT, Windows 2000
//
//
#ifndef _DEBUG_H
#define _DEBUG_H

#include "kmode.h"


// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif



/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP("Assertion Failed: \"" #cond "\"\n"); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);

#if DBG
    #define DbgPrint        DebugMessage
#else
    #define DbgPrint
#endif


// Some prototypes from writedib.c
HRESULT
Write8BppDibToFile(LPWSTR filename, LPBITMAPINFOHEADER pbih, LPBYTE pBits);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\sample\hp970c\multicolor\devmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Devmode.h
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for devmode functions.
//
//  PLATFORMS:
//
//    Windows NT / 2000
//
//
#ifndef _DEVMODE_H
#define _DEVMODE_H


////////////////////////////////////////////////////////
//      MultiColor Plugin Devmode Defines
////////////////////////////////////////////////////////




////////////////////////////////////////////////////////
//      MultiColor Plugin Devmode Type Definitions
////////////////////////////////////////////////////////

typedef struct tagMULTICOLORDEV
{
    OEM_DMEXTRAHEADER   dmOEMExtra;
    BOOL                dwDriverData;

} MULTICOLORDEV, *PMULTICOLORDEV;

typedef const MULTICOLORDEV *PCMULTICOLORDEV;



/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

HRESULT MultiColor_hrDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam);
BOOL MultiColor_ConvertDevmode(PCMULTICOLORDEV pMultiColorDevIn, PMULTICOLORDEV pMultiColorDevOut);
BOOL MultiColor_MakeDevmodeValid(PMULTICOLORDEV pMultiColorDevmode);
void MultiColor_DumpDevmode(PCMULTICOLORDEV pMultiColorDevIn);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\sample\hp970c\multicolor\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows NT, Windows 2000
//
//

#include "precomp.h"
#include "debug.h"
#include "kmode.h"


#define WARNING_MSG   

////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'



// Determine what level of debugging messages to eject. 
#if   defined(VERBOSE_MSG)
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif defined(TERSE_MSG)
    #define DEBUG_LEVEL     DBG_TERSE
#elif defined(WARNING_MSG)
    #define DEBUG_LEVEL     DBG_WARNING
#elif defined(ERROR_MSG)
    #define DEBUG_LEVEL     DBG_ERROR
#elif defined(RIP_MSG)
    #define DEBUG_LEVEL     DBG_RIP
#elif defined(NO_DBG_MSG)
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize = DEBUG_BUFFER_SIZE;
    LPSTR   lpszMsgBuf = NULL;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete[] lpszMsgBuf;
            dwSize *= 2;
        }
        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
            return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    } while (_vsnprintf(lpszMsgBuf, dwSize, lpszMessage, arglist) < 0);

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    LPWSTR     lpszMsgBuf;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    vswprintf(lpszMsgBuf, lpszMessage, arglist);

    // Dump string to debug output.
    OutputDebugStringW(lpszMsgBuf);

    // Clean up.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(__TEXT("pPublisherInfo:\r\n"));
    VERBOSE(__TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(__TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(__TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(__TEXT("pOemDMParam:\r\n"));
    VERBOSE(__TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(__TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(__TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(__TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(__TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(__TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(__TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(__TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(__TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}



PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\sample\hp970c\multicolor\devmode.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Devmode.cpp
//    
//
//  PURPOSE:  Implementation of Devmode functions shared with OEM UI and OEM rendering modules.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows NT
//
//

#include "precomp.h"
#include "multicoloruni.h"
#include "debug.h"
#include "devmode.h"
#include "kmode.h"



HRESULT MultiColor_hrDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam)
{
    PMULTICOLORDEV pMultiColorDevIn;
    PMULTICOLORDEV pMultiColorDevOut;


    // Verify parameters.
    if( (NULL == pOemDMParam)
        ||
        ( (OEMDM_SIZE != dwMode)
          &&
          (OEMDM_DEFAULT != dwMode)
          &&
          (OEMDM_CONVERT != dwMode)
          &&
          (OEMDM_MERGE != dwMode)
        )
      )
    {
        VERBOSE(ERRORTEXT("DevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOemDMParam = %#lx.\r\n"), dwMode, pOemDMParam);

        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Cast generic (i.e. PVOID) to OEM private devomode pointer type.
    pMultiColorDevIn = (PMULTICOLORDEV) pOemDMParam->pOEMDMIn;
    pMultiColorDevOut = (PMULTICOLORDEV) pOemDMParam->pOEMDMOut;

    switch(dwMode)
    {
        case OEMDM_SIZE:
            pOemDMParam->cbBufSize = sizeof(MULTICOLORDEV);
            break;

        case OEMDM_DEFAULT:
            VERBOSE(DLLTEXT("pMultiColorDevOut before setting default values:\r\n"));
            MultiColor_DumpDevmode(pMultiColorDevOut);
            pMultiColorDevOut->dmOEMExtra.dwSize       = sizeof(MULTICOLORDEV);
            pMultiColorDevOut->dmOEMExtra.dwSignature  = MULTICOLOR_SIGNATURE;
            pMultiColorDevOut->dmOEMExtra.dwVersion    = MULTICOLOR_VERSION;
            pMultiColorDevOut->dwDriverData            = 0;
            break;

        case OEMDM_CONVERT:
            MultiColor_ConvertDevmode(pMultiColorDevIn, pMultiColorDevOut);
            break;

        case OEMDM_MERGE:
            MultiColor_ConvertDevmode(pMultiColorDevIn, pMultiColorDevOut);
            MultiColor_MakeDevmodeValid(pMultiColorDevOut);
            break;
    }
    Dump(pOemDMParam);

    return S_OK;
}


BOOL MultiColor_ConvertDevmode(PCMULTICOLORDEV pMultiColorDevIn, PMULTICOLORDEV pMultiColorDevOut)
{
    if( (NULL == pMultiColorDevIn)
        ||
        (NULL == pMultiColorDevOut)
      )
    {
        VERBOSE(ERRORTEXT("MultiColor_ConvertDevmode() invalid parameters.\r\n"));
        return FALSE;
    }

    // Check OEM Signature, if it doesn't match ours,
    // then just assume DMIn is bad and use defaults.
    if(pMultiColorDevIn->dmOEMExtra.dwSignature == pMultiColorDevOut->dmOEMExtra.dwSignature)
    {
        VERBOSE(DLLTEXT("Converting private MultiColor Devmode.\r\n"));
        VERBOSE(DLLTEXT("pMultiColorDevIn:\r\n"));
        MultiColor_DumpDevmode(pMultiColorDevIn);

        // Set the devmode defaults so that anything the isn't copied over will
        // be set to the default value.
        pMultiColorDevOut->dwDriverData = 0;

        // Copy the old structure in to the new using which ever size is the smaller.
        // Devmode maybe from newer Devmode (not likely since there is only one), or
        // Devmode maybe a newer Devmode, in which case it maybe larger,
        // but the first part of the structure should be the same.

        // DESIGN ASSUMPTION: the private DEVMODE structure only gets added to;
        // the fields that are in the DEVMODE never change only new fields get added to the end.

        memcpy(pMultiColorDevOut, pMultiColorDevIn, __min(pMultiColorDevOut->dmOEMExtra.dwSize, pMultiColorDevIn->dmOEMExtra.dwSize));

        // Re-fill in the size and version fields to indicated 
        // that the DEVMODE is the current private DEVMODE version.
        pMultiColorDevOut->dmOEMExtra.dwSize       = sizeof(MULTICOLORDEV);
        pMultiColorDevOut->dmOEMExtra.dwVersion    = MULTICOLOR_VERSION;
    }
    else
    {
        VERBOSE(DLLTEXT("Unknown DEVMODE signature, pMultiColorDevIn ignored.\r\n"));

        // Don't know what the input DEVMODE is, so just use defaults.
        pMultiColorDevOut->dmOEMExtra.dwSize       = sizeof(MULTICOLORDEV);
        pMultiColorDevOut->dmOEMExtra.dwSignature  = MULTICOLOR_SIGNATURE;
        pMultiColorDevOut->dmOEMExtra.dwVersion    = MULTICOLOR_VERSION;
        pMultiColorDevOut->dwDriverData            = 0;
    }

    return TRUE;
}


BOOL MultiColor_MakeDevmodeValid(PMULTICOLORDEV pMultiColorDevmode)
{
    if(NULL == pMultiColorDevmode)
    {
        return FALSE;
    }

    // ASSUMPTION: pMultiColorDevmode is large enough to contain MULTICOLORDEV structure.

    // Make sure that dmOEMExtra indicates the current MULTICOLORDEV structure.
    pMultiColorDevmode->dmOEMExtra.dwSize       = sizeof(MULTICOLORDEV);
    pMultiColorDevmode->dmOEMExtra.dwSignature  = MULTICOLOR_SIGNATURE;
    pMultiColorDevmode->dmOEMExtra.dwVersion    = MULTICOLOR_VERSION;

    // Set driver data.
    pMultiColorDevmode->dwDriverData = 0;

    return TRUE;
}


void MultiColor_DumpDevmode(PCMULTICOLORDEV pMultiColorDevmode)
{
    return;
    if( (NULL != pMultiColorDevmode)
        &&
        (pMultiColorDevmode->dmOEMExtra.dwSize >= sizeof(MULTICOLORDEV))
        &&
        (MULTICOLOR_SIGNATURE == pMultiColorDevmode->dmOEMExtra.dwSignature)
      )
    {
        VERBOSE(__TEXT("\tdmOEMExtra.dwSize      = %d\r\n"), pMultiColorDevmode->dmOEMExtra.dwSize);
        VERBOSE(__TEXT("\tdmOEMExtra.dwSignature = %#x\r\n"), pMultiColorDevmode->dmOEMExtra.dwSignature);
        VERBOSE(__TEXT("\tdmOEMExtra.dwVersion   = %#x\r\n"), pMultiColorDevmode->dmOEMExtra.dwVersion);
        VERBOSE(__TEXT("\tdwDriverData           = %#x\r\n"), pMultiColorDevmode->dwDriverData);
    }
    else
    {
        VERBOSE(ERRORTEXT("MultiColor_DumpDevmode(PMULTICOLORDEV) unknown private OEM DEVMODE.\r\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\sample\hp970c\multicolor\dllentry.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  2000  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//
//
//  PLATFORMS:	Windows NT/2000
//
//

#include "precomp.h"
#include "multicoloruni.h"
#include "debug.h"
#include "kmode.h"


// Used in kernel mode implementation to declare a critical section.
// Need to similate InterlockedIncrement and InterlockedDecrement
// by using a semaphore, since these functions don't
// exist in kernel mode.
DECLARE_CRITICAL_SECTION;



// Need to export these functions as c declarations.
extern "C" {


///////////////////////////////////////////////////////////
//
// DLL entry point
//

// DllMain isn't called/used for kernel mode version.
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}


// DllInitialize isn't called/used for user mode version.
BOOL WINAPI DllInitialize(ULONG ulReason)
{
    BOOL    bRet = TRUE;

	switch(ulReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));

            // In kernel mode version, initializes semaphore.
            INIT_CRITICAL_SECTION();
            bRet = IS_VALID_CRITICAL_SECTION();
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));

            // In kernel mode version, deletes semaphore.
            DELETE_CRITICAL_SECTION();
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return bRet;
}



}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\sample\hp970c\multicolor\intrface.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Intrface.H
//    
//
//  PURPOSE:	Define COM interface for User Mode Printer Customization DLL.
//
//  PLATFORMS:
//
//    Windows NT/2000
//
//
#ifndef _INTERFACE_H
#define _INTERFACE_H




////////////////////////////////////////////////////////////////////////////////
//
//  IMultiColorUni
//
//  Interface for Unidrv OEM sample rendering module
//
class IMultiColorUni : public IPrintOemUni
{
public:
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get MultiColor dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // DriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // DevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // CommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // ImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // FilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // Compression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // Halftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // MemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // TTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // DownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // DownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // TTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // SendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // TextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    
    IMultiColorUni() { m_cRef = 1; m_pOEMHelp = NULL; };
    ~IMultiColorUni();

protected:
    LONG                m_cRef;
    IPrintOemDriverUni* m_pOEMHelp;
};


#endif /* _INTERFACE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\sample\hp970c\multicolor\enable.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  2000  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Enable.cpp
//    
//
//  PURPOSE:  Enable routines for User Mode COM Customization DLL.
//
//
//	Functions:
//
//		
//
//
//  PLATFORMS:	Windows NT/2000
//
//

#include "precomp.h"
#include "debug.h"
#include "multicoloruni.h"


////////////////////////////////////////////////////////
//      Internal Constants
////////////////////////////////////////////////////////



// We donot hook any functions as of now.
// If you want to hook DrvXX functions, then define HOOKFUNCS and then
// Put only the functions you want to hook in MultiColorHookFuncs[]

#ifdef HOOKFUNCS 

static const DRVFN MultiColorHookFuncs[] =
{
    { INDEX_DrvRealizeBrush,        (PFN) MultiColor_RealizeBrush        },
    { INDEX_DrvDitherColor,         (PFN) MultiColor_DitherColor         },
    { INDEX_DrvCopyBits,            (PFN) MultiColor_CopyBits            },
    { INDEX_DrvBitBlt,              (PFN) MultiColor_BitBlt              },
    { INDEX_DrvStretchBlt,          (PFN) MultiColor_StretchBlt          },
    { INDEX_DrvStretchBltROP,       (PFN) MultiColor_StretchBltROP       },
    { INDEX_DrvPlgBlt,              (PFN) MultiColor_PlgBlt              },
    { INDEX_DrvTransparentBlt,      (PFN) MultiColor_TransparentBlt      },
    { INDEX_DrvAlphaBlend,          (PFN) MultiColor_AlphaBlend          },
    { INDEX_DrvGradientFill,        (PFN) MultiColor_GradientFill        },
    { INDEX_DrvTextOut,             (PFN) MultiColor_TextOut             },
    { INDEX_DrvStrokePath,          (PFN) MultiColor_StrokePath          },
    { INDEX_DrvFillPath,            (PFN) MultiColor_FillPath            },
    { INDEX_DrvStrokeAndFillPath,   (PFN) MultiColor_StrokeAndFillPath   },
    { INDEX_DrvPaint,               (PFN) MultiColor_Paint               },
    { INDEX_DrvLineTo,              (PFN) MultiColor_LineTo              },
    { INDEX_DrvStartPage,           (PFN) MultiColor_StartPage           },
    { INDEX_DrvSendPage,            (PFN) MultiColor_SendPage            },
    { INDEX_DrvEscape,              (PFN) MultiColor_Escape              },
    { INDEX_DrvStartDoc,            (PFN) MultiColor_StartDoc            },
    { INDEX_DrvEndDoc,              (PFN) MultiColor_EndDoc              },
    { INDEX_DrvNextBand,            (PFN) MultiColor_NextBand            },
    { INDEX_DrvStartBanding,        (PFN) MultiColor_StartBanding        },
    { INDEX_DrvQueryFont,           (PFN) MultiColor_QueryFont           },
    { INDEX_DrvQueryFontTree,       (PFN) MultiColor_QueryFontTree       },
    { INDEX_DrvQueryFontData,       (PFN) MultiColor_QueryFontData       },
    { INDEX_DrvQueryAdvanceWidths,  (PFN) MultiColor_QueryAdvanceWidths  },
    { INDEX_DrvFontManagement,      (PFN) MultiColor_FontManagement      },
    { INDEX_DrvGetGlyphMode,        (PFN) MultiColor_GetGlyphMode        }
};

#endif /* HOOKFUNCS */

// 
// Collect all the Unidrv DrvXXX functions and put them in 
// MULTICOLORPDEV.pfnUnidrv[]
//
VOID
GetUnidrvHooks(PMULTICOLORPDEV pMultiColorPDEV, PDRVENABLEDATA pded)
{
    DWORD  j;
    PDRVFN pdrvfn;

    memset(pMultiColorPDEV->pfnUnidrv, 0, sizeof(pMultiColorPDEV->pfnUnidrv));

    ASSERT(pded->c <= INDEX_LAST);

    for (j = pded->c, pdrvfn = pded->pdrvfn; j > 0; j--, pdrvfn++) {

        ASSERT(pdrvfn->iFunc < INDEX_LAST);
        pMultiColorPDEV->pfnUnidrv[pdrvfn->iFunc] = pdrvfn->pfn;
    }
}



BOOL
GenerateInkLevels(
    PINKLEVELS  pInkLevels,     // Pointer to 256 INKLEVELS table
    BYTE        CMYMask,        // CMYMask mode
    BOOL        CMYInverted     // TRUE for CMY_INVERTED mode
    )
{
    PINKLEVELS  pILDup;
    PINKLEVELS  pILEnd;
    INKLEVELS   InkLevels;
    INT         Count;
    INT         IdxInc;
    INT         cC;
    INT         cM;
    INT         cY;
    INT         xC;
    INT         xM;
    INT         xY;
    INT         iC;
    INT         iM;
    INT         iY;
    INT         mC;
    INT         mM;


    switch (CMYMask) {

    case 0:

        cC =
        cM =
        xC =
        xM = 0;
        cY =
        xY = 255;
        break;

    case 1:
    case 2:

        cC =
        cM =
        cY =
        xC =
        xM =
        xY = 3 + (INT)CMYMask;
        break;

    default:

        cC = (INT)((CMYMask >> 5) & 0x07);
        cM = (INT)((CMYMask >> 2) & 0x07);
        cY = (INT)( CMYMask       & 0x03);
        xC = 7;
        xM = 7;
        xY = 3;
        break;
    }

    Count = (cC + 1) * (cM + 1) * (cY + 1);

    if ((Count < 1) || (Count > 256)) {

        return(FALSE);
    }

    InkLevels.Cyan      =
    InkLevels.Magenta   =
    InkLevels.Yellow    =
    InkLevels.CMY332Idx = 0;
    mC                  = (xM + 1) * (xY + 1);
    mM                  = xY + 1;
    pILDup              = NULL;

    if (CMYInverted) {

        //
        // Move the pInkLevels to the first entry which center around
        // 256 table entries, if we skip any then all entries skipped
        // will be white (CMY levels all zeros).  Because this is
        // CMY_INVERTED so entries start from back of the table and
        // moving backward to the begining of the table
        //

        pILEnd      = pInkLevels - 1;
        IdxInc      = ((256 - Count - (Count & 0x01)) / 2);
        pInkLevels += 255;

        while (IdxInc--) {

            *pInkLevels-- = InkLevels;
        }

        if (Count & 0x01) {

            //
            // If we have odd number of entries then we need to
            // duplicate the center one for correct XOR ROP to
            // operated correctly. The pILDup will always be index
            // 127, the duplication are indices 127, 128
            //

            pILDup = pInkLevels - (Count / 2) - 1;
        }

        //
        // We running from end of table to the begining, because
        // when in CMYInverted mode, the index 0 is black and index
        // 255 is white.  Since we only generate 'Count' of index
        // and place them at center, we will change xC, xM, xY max.
        // index to same as cC, cM and cY.
        //

        IdxInc = -1;
        xC     = cC;
        xM     = cM;
        xY     = cY;

    } else {

        IdxInc = 1;
        pILEnd = pInkLevels + 256;
    }

    //
    // At following, the composition of ink levels, index always
    // from 0 CMY Ink levels (WHITE) to maximum ink levels (BLACK),
    // the different with CMY_INVERTED mode is we compose it from
    // index 255 to index 0 rather than from index 0 to 255
    //

    if (CMYMask) {

        INT Idx332C;
        INT Idx332M;

        for (iC = 0, Idx332C = -mC; iC <= xC; iC++) {

            if (iC <= cC) {

                InkLevels.Cyan  = (BYTE)iC;
                Idx332C        += mC;
            }

            for (iM = 0, Idx332M = -mM; iM <= xM; iM++) {

                if (iM <= cM) {

                    InkLevels.Magenta  = (BYTE)iM;
                    Idx332M           += mM;
                }

                for (iY = 0; iY <= xY; iY++) {

                    if (iY <= cY) {

                        InkLevels.Yellow = (BYTE)iY;
                    }

                    InkLevels.CMY332Idx = (BYTE)(Idx332C + Idx332M) +
                                          InkLevels.Yellow;
                    *pInkLevels         = InkLevels;

                    if ((pInkLevels += IdxInc) == pILDup) {

                        *pInkLevels  = InkLevels;
                        pInkLevels  += IdxInc;
                    }
                }
            }
        }

        //
        // Now if we need to pack black at other end of the
        // translation table then do it here, Notice that InkLevels
        // are at cC, cM and cY here and the CMY332Idx is at BLACK
        //

        while (pInkLevels != pILEnd) {

            *pInkLevels  = InkLevels;
            pInkLevels  += IdxInc;
        }

    } else {

        //
        // Gray Scale case
        //

        for (iC = 0; iC < 256; iC++, pInkLevels += IdxInc) {

            pInkLevels->Cyan      =
            pInkLevels->Magenta   =
            pInkLevels->Yellow    =
            pInkLevels->CMY332Idx = (BYTE)iC;
        }
    }

    return(TRUE);
}



PDEVOEM
APIENTRY
MultiColor_EnablePDEV(
    PDEVOBJ             pDevObj,
    PWSTR               pPrinterName,
    ULONG               cPatterns,
    HSURF               *phsurfPatterns,
    ULONG               cjGdiInfo,
    GDIINFO             *pGdiInfo,
    ULONG               cjDevInfo,
    DEVINFO             *pDevInfo,
    DRVENABLEDATA       *pded,
    IPrintOemDriverUni  *pOEMHelp,
    ULONG               MultiColorMode
    )

/*++

Routine Description:

    This functions does all the configuration to put the GDI into MultiColor
    mode. This is basically done by setting HT_FLAG_USE_8BPP_BITMASK,
    HT_FLAG_INVERT_8BPP_BITMASK_IDX and MAKE_CMY332_MASK() in
    GDIINFO.flHTFlags

    MAKE_CMY332_MASK() takes the maximum values of Cyan, Magenta and Yellow
    the printer can accept. For the HP DeskJet 970, it is 3, 3 and 3. For more
    info please look at comments in the ht.h (DDK)

Arguments:

    See EnablePDEV

Return Value:

    PDEVOEM


Author:

    30-May-2000 Tue 19:22:22 updated  -by-  Daniel Chou (danielc)


Revision History:

    06-Jun-2000 Tue 19:22:54 updated  -by-  Daniel Chou (danielc)
        Update 600C600K mode

--*/

{
    PMULTICOLORPDEV pMultiColorPDEV;
    HPALETTE        hPal;
    INT             numEntries;
    LPPALETTEENTRY  pPalEntry;
    BOOL            bOk = TRUE;
    PULONG          pulColors;
    
    VERBOSE(DLLTEXT("MultiColor_EnablePDEV() entry.\r\n"));

    //
    // Allocate the MULTICOLORPDEV
    //

    if (!(pMultiColorPDEV = new MULTICOLORPDEV)) {

        return NULL;
    }

    ZeroMemory(pMultiColorPDEV, sizeof(MULTICOLORPDEV));

    GetUnidrvHooks(pMultiColorPDEV, pded);
    
    pMultiColorPDEV->pDevObj  = pDevObj;
    pMultiColorPDEV->pOEMHelp = pOEMHelp;

    //
    // The HT_PATSIZE_SUPERCELL and HT_PATSIZE_SUPERCELL_M produced little
    // different result, currently is used _M version of SuperCell
    //
    // pGdiInfo->ulHTPatternSize = HT_PATSIZE_SUPERCELL;
    //

    if ((pGdiInfo->ulHTPatternSize != HT_PATSIZE_SUPERCELL) ||
        (pGdiInfo->ulHTPatternSize != HT_PATSIZE_SUPERCELL_M)) {

        pGdiInfo->ulHTPatternSize = HT_PATSIZE_SUPERCELL_M;
    }

    DbgPrint("\n(%ldx%ld), Gamma=%ld:%ld:%ld, Pel=%ld.%ld%%, HTPat=%ld, Flags=%08lx\n",
                pGdiInfo->ulHorzRes,
                pGdiInfo->ulVertRes,
                pGdiInfo->ciDevice.RedGamma,
                pGdiInfo->ciDevice.GreenGamma,
                pGdiInfo->ciDevice.BlueGamma,
                (pGdiInfo->ulDevicePelsDPI & 0x7FFF) / 10,
                (pGdiInfo->ulDevicePelsDPI & 0x7FFF) % 10,
                pGdiInfo->ulHTPatternSize,
                pGdiInfo->flHTFlags);

    //====================================================================
    // 01-Jun-2000 Thu 14:09:21 updated  -by-  Daniel Chou (danielc)
    //  Thie Cyan.Y must be 0xFFFE for GDI to use Red, Green, Blue and
    //  AlignmentWhite CIECHROMA data structure.  If Cyan.Y is set to any
    //  values that other than 0xFFFE then GDI halftone will use default CIE
    //  endpoints values for the end points for rendering the halftone output
    //
    //  The available GDIINFO fields that affect GDI halftone output are
    //
    //      COLORINFO   ciDevice;
    //      ULONG       ulDevicePelsDPI;
    //      ULONG       ulPrimaryOrder;
    //      ULONG       ulHTPatternSize;
    //      ULONG       ulHTOutputFormat;
    //      ULONG       flHTFlags;
    //      ULONG       cxHTPat;             - cxHTPat must range from 4-256
    //      ULONG       cyHTPat;             - cyHTPat must range from 4-256
    //      LPBYTE      pHTPatA;             - for Primary Color Order A
    //      LPBYTE      pHTPatB;             - for Primary Color Order B
    //      LPBYTE      pHTPatC;             - for Primary Color Order C
    //====================================================================

    //
    // Set Cyan.Y = 0xFFFE so GDI halftone will take red/green/blue and
    // alignment white (x,y) endpoints plus alignment white lightness Y.
    //

    pGdiInfo->ciDevice.Cyan.Y           = (LDECI4)0xFFFE;

    //
    // Set to sRGB end points
    //

    pGdiInfo->ciDevice.Red.x            = (LDECI4)6400;
    pGdiInfo->ciDevice.Red.y            = (LDECI4)3300;
    pGdiInfo->ciDevice.Green.x          = (LDECI4)3000;
    pGdiInfo->ciDevice.Green.y          = (LDECI4)6000;
    pGdiInfo->ciDevice.Blue.x           = (LDECI4)1500;
    pGdiInfo->ciDevice.Blue.y           = (LDECI4)600;
    pGdiInfo->ciDevice.AlignmentWhite.x = (LDECI4)3127;
    pGdiInfo->ciDevice.AlignmentWhite.y = (LDECI4)3290;
    pGdiInfo->ciDevice.AlignmentWhite.Y = (LDECI4)10000;

    DbgPrint("\nR=(%ld, %ld), G=(%ld, %ld), B=(%ld, %ld), White=(%ld, %ld, %ld)\n",
                pGdiInfo->ciDevice.Red.x, pGdiInfo->ciDevice.Red.y,
                pGdiInfo->ciDevice.Green.x, pGdiInfo->ciDevice.Green.y,
                pGdiInfo->ciDevice.Blue.x, pGdiInfo->ciDevice.Blue.y,
                pGdiInfo->ciDevice.AlignmentWhite.x,
                pGdiInfo->ciDevice.AlignmentWhite.y,
                pGdiInfo->ciDevice.AlignmentWhite.Y);

    //=========================================================================
    //
    // 27-Sep-2000 Wed 15:18:56 updated  -by-  Daniel Chou (danielc)
    //  If a 8bpp Mask mode is used (HT_FLAG_USE_8BPP_BITMASK set) and the
    //  maximum of ink levels is less or equal to 6 (not include level 0) then
    //  it can also use ciDevice to specified each CMY ink densities and black
    //  ink replacement base ratio. for each density it use one byte to
    //  indicate the density percentage of the ink.  The density pecentage is
    //  calculated as (DensityByte + 1) / 256.  For example if byte number is
    //  127 then it will be (127+1)/256=50%, and if byte is 255 then the
    //  density will be (255+1)/256=100%.  The ink densities can be set in
    //  ~0.39% percent increment (1/256)
    //
    //  The black ink base replacement ratio is specified in Green.Y location.
    //  This is a LDECI4 number that used by GDI halftone to increase black
    //  ink in the shadow area to improve image contrast.  It has following
    //  range and meaning.
    //
    //               0: Default black ink replacement computation
    //      1  -  9999: Specified black ink replacement base ratio
    //        >= 10000: Turn OFF black ink replacement computation
    //
    //  Following are byte locations in the GDIInfo.ciDevice that spcecified
    //  ink level densities and black ink replacement base ratio, This feature
    //  is ONLY supported in Whistler or later version of Windows GDI (Windows
    //  2000 will ignored these settings and compute as linear level densities
    //  and default black repelacment ratio).  To have Windows GDI Halftone
    //  used ink densities and black ink replacement ratio, the
    //  "GDIInfo.ciDevice.Blue.Y" must set to hex number <0xFFFE> to indicate
    //  color densities and black ink replacment ratio are defined.  If
    //  GDIInfo.ciDevice.Blue.Y is equal to 0xFFFE then following are valid.
    //  Notice that Cyan ink levels 5, 6 densities are specified in
    //  ciDevice.Red.Y becuase Cyan.Y must set to 0xFFFE for GDI halftone to
    //  use ciDevice Red, Green and Blue structures' x, y fields
    //
    //  GDIInfo.ciDevice.Blue.Y = 0xFFFE;   // Set to 0xFFFE to have GDI use
    //                                      // Ink densities and black ink
    //                                      // replacement ratio settings in
    //                                      // 8bpp CMY mask mode
    //
    //  GDIInfo.ciDevice.Green.Y = Black ink Replacement base Ratio
    //
    //  HIBYTE(LOWORD(GDIInfo.ciDevice.Cyan.x)) = Cyan Ink Level 1
    //  LOBYTE(LOWORD(GDIInfo.ciDevice.Cyan.x)) = Cyan Ink Level 2
    //  HIBYTE(LOWORD(GDIInfo.ciDevice.Cyan.y)) = Cyan Ink Level 3
    //  LOBYTE(LOWORD(GDIInfo.ciDevice.Cyan.y)) = Cyan Ink Level 4
    //  HIBYTE(LOWORD(GDIInfo.ciDevice.Red.Y )) = Cyan Ink Level 5
    //  LOBYTE(LOWORD(GDIInfo.ciDevice.Red.Y )) = Cyan Ink Level 6
    //
    //  HIBYTE(LOWORD(GDIInfo.ciDevice.Magenta.x)) = Magenta Ink Level 1
    //  LOBYTE(LOWORD(GDIInfo.ciDevice.Magenta.x)) = Magenta Ink Level 2
    //  HIBYTE(LOWORD(GDIInfo.ciDevice.Magenta.y)) = Magenta Ink Level 3
    //  LOBYTE(LOWORD(GDIInfo.ciDevice.Magenta.y)) = Magenta Ink Level 4
    //  HIBYTE(LOWORD(GDIInfo.ciDevice.Magenta.Y)) = Magenta Ink Level 5
    //  LOBYTE(LOWORD(GDIInfo.ciDevice.Magenta.Y)) = Magenta Ink Level 6
    //
    //  HIBYTE(LOWORD(GDIInfo.ciDevice.Yellow.x)) = Yellow Ink Level 1
    //  LOBYTE(LOWORD(GDIInfo.ciDevice.Yellow.x)) = Yellow Ink Level 2
    //  HIBYTE(LOWORD(GDIInfo.ciDevice.Yellow.y)) = Yellow Ink Level 3
    //  LOBYTE(LOWORD(GDIInfo.ciDevice.Yellow.y)) = Yellow Ink Level 4
    //  HIBYTE(LOWORD(GDIInfo.ciDevice.Yellow.Y)) = Yellow Ink Level 5
    //  LOBYTE(LOWORD(GDIInfo.ciDevice.Yellow.Y)) = Yellow Ink Level 6
    //
    //  When specified ink densities for each ink, the last ink level is used
    //  to specified maximum density used for that ink, it is simillar to set
    //  the spot diameter for the ink nozzles but this can be use to control
    //  each individual ink.  For example if Cyan has 3 ink levels (not include
    //  level 0) and ink density is C1=25%, C2=55% and Maximum Cyan ink used
    //  will be 90% which is in effect equal to spot diameter for cyan ink is
    //  set to 100/90 = 111.11% , (Last level always assume at 100% relate to
    //  other ink level densities)   With this ink densities we will specified
    //  cyan ink densities as C1=25%, C2=55%, C3=90% and to set it into
    //  ciDevice as following
    //
    //  C1 = 25% = (0.25 x 256) - 1 = 63           = 0x3F
    //  C2 = 55% = (0.55 x 256) - 1 = 139.8 ~= 140 = 0x8C
    //  C3 = 90% = (0.90 x 256) - 1 = 229.4 ~= 229 = 0xE5 (Max. ink density)
    //
    //  GDIInfo.ciDevice.Blue.Y = 0xfffe;
    //
    //  GDIInfo.ciDevice.Cyan.x = 0x3F8C;
    //  GDIInfo.ciDevice.Cyan.y = 0xE500;
    //
    //  At above example, the maximum cyan ink used will be 90% for each ink
    //  level. This is have GDI halftone mapped 90% of final computed device
    //  cyan ink to each cyan ink level, so C1=25% x 0.9=22.5,
    //  C2=55% x 0.9=49.5% and C3=100% x 0.9=90%.  It is in effect use last
    //  ink level density setting to control where 100% of ink will map to,
    //  or just like use it to control spot diameter for that ink.
    //
    //  If maximum desntiy for cyan ink in above example is 100% which used
    //  all the ink without ask halftone to reduced it then it should set
    //
    //  GDIInfo.ciDevice.Cyan.y = 0xFF00;
    //
    //  For example following MultiColorMode in this sample code,  we can set
    //  densities mode to as follow to have same effects
    //
    //  Mode: MCM_600C600K (2 ink levels, 50%, 100%)
    //
    //  C1 =  50% = (0.50 x 256) - 1 = 127 = 0x7f
    //  C2 = 100% = (1.00 x 256) - 1 = 255 = 0xff
    //
    //      GDIInfo.ciDevice.Blue.Y    = 0xfffe;    // Use ink densities, black
    //                                              // ink replacement ratio
    //
    //      GDIInfo.ciDevice.Green.Y   = 0;         // Using GDI default black
    //                                              // ink repelacement ratio
    //      GDIInfo.ciDevice.Cyan.x    = 0x7fff;
    //      GDIInfo.ciDevice.Magenta.x = 0x7fff;
    //      GDIInfo.ciDevice.Yellow.x  = 0x7fff;
    //
    //  Mode: MCM_300C600K (3 ink levels, 33.3%, 66.7%, 100%)
    //
    //  C1 = 33.3% = (0.333 x 256) - 1 =  84.248 ~= 84  = 0x54
    //  C2 = 66.7% = (0.667 x 256) - 1 = 169.752 ~= 170 = 0xaa
    //  C3 =  100% = (1.000 x 256) - 1 = 255            = 0xff
    //
    //      GDIInfo.ciDevice.Blue.Y    = 0xfffe;    // Use ink densities, black
    //                                              // ink replacement ratio
    //
    //      GDIInfo.ciDevice.Green.Y   = 6000;      // Black ink replacement
    //                                              // base start at 0.6
    //      GDIInfo.ciDevice.Cyan.x    = 0x54aa;
    //      GDIInfo.ciDevice.Cyan.y    = 0xff00;
    //      GDIInfo.ciDevice.Magenta.x = 0x54aa;
    //      GDIInfo.ciDevice.Magenta.y = 0xff00;
    //      GDIInfo.ciDevice.Yellow.x  = 0x54aa;
    //      GDIInfo.ciDevice.Yellow.y  = 0xff00;
    //
    //=========================================================================

    //
    // 30-May-2000 Tue 19:24:34 updated  -by-  Daniel Chou (danielc)
    //  MAKE sure we use the right level of inks
    //

    if ((pMultiColorPDEV->ColorMode = (WORD)MultiColorMode) != MCM_NONE) {

        UINT    cC;
        UINT    cM;
        UINT    cY;
        BYTE    k0;
        BYTE    k1;
        BYTE    KData;
        BYTE    CMYPalMask;


        //
        // the CMYPalMask in GDI Halftone 8bpp mode supports up to
        //
        //      Cyan    = 7 leveles (not include 0)
        //      magenta = 7 leveles (not include 0)
        //      Yellow  = 3 leveles (not include 0)
        //
        // To use higher color levels for yellow, following are the special
        // CMYPalMask number
        //
        //  0   - Gray scale of 256 levels (0 - 255)
        //
        //  1   - Cyan, Magenta and Yellow are 4 levels (not include 0)
        //        which run from 0 to 5 of 5x5x5=125 color table entries
        //
        //  2   - Cyan, Magenta and Yellow are 5 levels (not include 0)
        //        which run from 0 to 6 of 6x6x6=216 color table entries
        //
        //

        switch (MultiColorMode) {

        case MCM_600C600K:

            cC                             =
            cM                             =
            cY                             = 2;
            k0                             = 0x01;
            k1                             =
            KData                          = 0x00;
            pMultiColorPDEV->xRes          =
            pMultiColorPDEV->yRes          = 600;
            pMultiColorPDEV->KMulX         =
            pMultiColorPDEV->KMulY         = 1;
            pMultiColorPDEV->WriteHPMCFunc = WriteHP600C600K;
            break;

        case MCM_300C600K:

            //
            // put out total of 3 pixel black 0x01, 0x03 and c1:m1:y1 for the
            // black pixel
            //

            cC                             =
            cM                             =
            cY                             = 3;
            k0                             = 0x01;
            k1                             = 0x03;
            KData                          = 0x25;
            pMultiColorPDEV->xRes          =
            pMultiColorPDEV->yRes          = 300;
            pMultiColorPDEV->KMulX         =
            pMultiColorPDEV->KMulY         = 2;
            pMultiColorPDEV->WriteHPMCFunc = WriteHP300C600K;
            break;

        default:

            delete pMultiColorPDEV;

            return(NULL);
        }

        CMYPalMask = MAKE_CMYMASK_BYTE(cC, cM, cY);

        //
        // 31-May-2000 Wed 19:05:02 updated  -by-  Daniel Chou (danielc)
        //  Call our function to generate the HPBlackGen[] and InkData[]
        //  for later generate more black for 600k600c and table for convert
        //  data to planner. (see writedib.cpp for more detail)
        //

        MakeHPCMYKInkData(MultiColorMode, k0, k1, KData, CMYPalMask);

        //
        // Set the flags so that Halftone (GDI) understands that the printer
        // is in the multicolor mode. (Look at ht.h (Windows 2000 source code)
        // and winddi.h (in DDK) for more details)
        //
        // If current version of GDI halftone supports CMY_INVERTED mode then
        // the a HT_FLAG_INVERT_8BPP_BITMASK_IDX flag must also set to have
        // gdi rendering all images using the inverted mode.  If current
        // version of GDI does not supported CMY_INVERTED mode then it will
        // ignored HT_FLAG_USE_8BPP_BITMASK and
        // HT_FLAG_INVERT_8BPP_BITMASK_IDX that set in the flHTFlags
        //

        pGdiInfo->flHTFlags &= ~HT_FLAG_ADDITIVE_PRIMS;
        pGdiInfo->flHTFlags |= (HT_FLAG_USE_8BPP_BITMASK            |
                                HT_FLAG_DO_DEVCLR_XFORM             |
                                HT_FLAG_NORMAL_INK_ABSORPTION);

        //
        // Maximum values of Cyan, Magenta and Yellow that the printer can accept.
        //  30-May-2000 Tue 19:26:38 updated  -by-  Daniel Chou (danielc)
        //  In the future we may want also adjust the HT_FLAG_INK_ABSORPTION
        //

        pGdiInfo->flHTFlags |= MAKE_CMY332_MASK(cC, cM, cY);

        DbgPrint("\nInk=%ld:%ld:%ld, Flags=%08lx\n",
                    cC, cM, cY, pGdiInfo->flHTFlags);

        //
        // 17-Aug-2000 Thu 13:30:03 updated  -by-  Daniel Chou (danielc)
        //  The fixes in Whistler make this 8bpp can be run in CMY_INVERTED
        //  mode in GDI to have all ROPs work more correctly, we just have to
        //  translate all indices byte when we do image processing
        //
        //  If the First entry of halftone palette is set to 'R','G','B','0'
        //  when running post windows 2000 GDI halftone, it will return a RGB
        //  composition palette from HT_Get8BPPMaskPalette() function call
        //  (from index 0=black to index 255=white) and GDI halftone will
        //  render to that palette.  we must check the return palette from
        //  HT_Get8BPPMaskPalette() to make sure this version of GDI halftone
        //  is support 8bpp RGB bitmask mode
        //
        //  If run under whistler then we can use winddi.h macro to set
        //
        //  #if version >= WHISTLER
        //      HT_SET_BITMASKPAL2RGB(pPalEntry);
        //  #else
        //      set to 'R','G','B','0'
        //  #endif
        //

        pPalEntry          = pMultiColorPDEV->HTPal;
        pPalEntry->peRed   = 'R';
        pPalEntry->peGreen = 'G';
        pPalEntry->peBlue  = 'B';
        pPalEntry->peFlags = '0';

        //
        // Mask mode will ignored gamma setting at here, set device gamma in
        // ciDevice
        //

        numEntries = HT_Get8BPPMaskPalette(pPalEntry,
                                           TRUE, 
                                           CMYPalMask,
                                           10000, 10000, 10000);

        ASSERT(numEntries <= 256);

        //
        // 17-Aug-2000 Thu 13:39:50 updated  -by-  Daniel Chou (danielc)
        //  Check if we have RGB palette,
        //
        //  If run under whistler then you can set it with winddi.h macro
        //
        //  #if version >= WHISTLER
        //      if (HT_IS_BITMASKPALRGB(pPalEntry)) {
        //  #else
        //      if (first entry is BLACK)
        //  #endif
        //          ...
        //      }
        //

        //
        // If we ask for RGB composition palette then the first palette
        // entry should be BLACK (K -> W).
        //

        if ((pPalEntry->peRed   == 0) &&
            (pPalEntry->peGreen == 0) &&
            (pPalEntry->peBlue  == 0)) {

            //
            // Yes, it is a RGB palette, so all 8bpp bitmap will be render by
            // GDI using CMY_INVERTED mode.  We need to generate a translate
            // table that has INKLEVELS and convert it back to CMY 332 format
            // Please see DDK for detail description.
            //
            // The HT_FLAG_INVERT_8BPP_BITMASK_IDX flag must set to have GDI
            // render this pDEV halftone images using CMY_INVERTED mode
            //

            pMultiColorPDEV->Flags |= MCPF_INVERT_BITMASK;
            pGdiInfo->flHTFlags    |= HT_FLAG_INVERT_8BPP_BITMASK_IDX;

            //
            // For purpose of this DDK sample, the InkLevlevel only can be
            // used to translate CMY 332 bits format, this sample does
            // not handle output CMY Mode 0, 1, 2 format.  This sample
            // translate all palette indices back to original Windows 2000's
            // CMY 332 bits format using CMY332Idx fields in InkLevels to
            // translate.
            //

            GenerateInkLevels(pMultiColorPDEV->InkLevels, CMYPalMask, TRUE);

        } else {

            DbgPrint("\nCurrent version of GDI Halftone does not support 8bpp CMY_INVERTED mask mode");
        }

        pMultiColorPDEV->cHTPal    = (WORD)numEntries;
        pMultiColorPDEV->cC        = (BYTE)cC;
        pMultiColorPDEV->cM        = (BYTE)cM;
        pMultiColorPDEV->cY        = (BYTE)cY;
        pMultiColorPDEV->BlackMask = (BYTE)CMYPalMask;
        pMultiColorPDEV->cx        = (DWORD)pGdiInfo->ulHorzRes;
        pMultiColorPDEV->cy        = (DWORD)pGdiInfo->ulVertRes;
        pMultiColorPDEV->iPage     =
        pMultiColorPDEV->iBand     = 0;

        // 
        // Now we create a palette and set it in GDIINFO so that GDI uses this 
        // to realize colors.
        //

        bOk = FALSE;

        if (pulColors = new ULONG[numEntries]) {

            for (INT i=0; i<numEntries; i++) {
#if 0
#if DBG
                DbgPrint("\n%3ld = %02lx:%02x:%02lx",
                            i,
                            pPalEntry[i].peRed,
                            pPalEntry[i].peGreen,
                            pPalEntry[i].peBlue);
#endif
#endif
                pulColors[i] = RGB(pPalEntry[i].peRed,
                                   pPalEntry[i].peGreen,
                                   pPalEntry[i].peBlue);
            }

            if (hPal = EngCreatePalette(PAL_INDEXED,
                                        numEntries,
                                        pulColors, 0, 0, 0)) {

                bOk                   = TRUE;
                pDevInfo->hpalDefault = hPal;
                pMultiColorPDEV->hPal = hPal;

            } else {

                WARNING(ERRORTEXT("EngCreatePalette failed.\r\n"));
            }

            delete[] pulColors;
        }
    }

    if (bOk) {

        return((PMULTICOLORPDEV)pMultiColorPDEV);

    } else if (pMultiColorPDEV) {

        delete pMultiColorPDEV;
    }

    return(NULL);
}


VOID APIENTRY MultiColor_DisablePDEV(
    PDEVOBJ pdevobj
    )
{
    VERBOSE(DLLTEXT("MultiColor_DisablePDEV() entry.\r\n"));

    PMULTICOLORPDEV pMultiColorPDEV;
    //
    // Free memory for MULTICOLORPDEV and any memory block that hangs off MULTICOLORPDEV.
    //
    ASSERT(NULL != pdevobj->pdevOEM);
    pMultiColorPDEV = (PMULTICOLORPDEV)(pdevobj->pdevOEM);

    if (pMultiColorPDEV->hPal) {
        EngDeletePalette(pMultiColorPDEV->hPal);
    }

    if (pMultiColorPDEV->HPOutData.pbAlloc) {

        DbgPrint("\n******* DisablePDEV: Total Page=%ld, Free the pbAlloc",
                    pMultiColorPDEV->iPage);

        delete pMultiColorPDEV->HPOutData.pbAlloc;
    }

    delete pdevobj->pdevOEM;
}


BOOL APIENTRY MultiColor_ResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew
    )
{
    VERBOSE(DLLTEXT("MultiColor_ResetPDEV() entry.\r\n"));


    //
    // If you want to carry over anything from old pdev to new pdev, do it here.
    //

    return TRUE;
}


VOID APIENTRY MultiColor_DisableDriver()
{
    VERBOSE(DLLTEXT("MultiColor_DisableDriver() entry.\r\n"));
}


BOOL APIENTRY MultiColor_EnableDriver(DWORD dwOEMintfVersion, DWORD dwSize, PDRVENABLEDATA pded)
{
    VERBOSE(DLLTEXT("MultiColor_EnableDriver() entry.\r\n"));

    // List DDI functions that are hooked.

    pded->iDriverVersion =  PRINTER_OEMINTF_VERSION;

#ifdef HOOKFUNCS
    pded->c = sizeof(MultiColorHookFuncs) / sizeof(DRVFN);
    pded->pdrvfn = (DRVFN *) MultiColorHookFuncs;
#else /* HOOKFUNCS */
    pded->c = 0;
    pded->pdrvfn = NULL;
#endif /* HOOKFUNCS */

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\sample\hp970c\multicolor\intrface.cpp ===
/  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Intrface.cpp
//    
//
//  PURPOSE:  Interface for User Mode COM Customization DLL.
//
//
//	Functions:
//
//		
//
//
//  PLATFORMS:	Windows NT/2000
//
//

#include "precomp.h"
#include <INITGUID.H>
#include <PRCOMOEM.H>

#include "multicoloruni.h"
#include "debug.h"
#include "intrface.h"
#include "name.h"
#include "kmode.h"


////////////////////////////////////////////////////////
//      Internal Globals
////////////////////////////////////////////////////////

static long g_cComponents = 0;     // Count of active components
static long g_cServerLocks = 0;    // Count of locks


////////////////////////////////////////////////////////////////////////////////
//
// IMultiColorUni body
//

// 
// Destructor. 
//
IMultiColorUni::~IMultiColorUni()
{
    // Make sure that helper interface is released.
    if(NULL != m_pOEMHelp)
    {
        m_pOEMHelp->Release();
        m_pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    ASSERT(0 == m_cRef);
}

//

// 
HRESULT __stdcall IMultiColorUni::QueryInterface(const IID& iid, void** ppv)
{    
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE(DLLTEXT("IMultiColorUni::QueryInterface IUnknown.\r\n")); 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this);
        VERBOSE(DLLTEXT("IMultiColorUni::QueryInterface IPrintOemUni.\r\n")); 
    }
    else
    {
        *ppv = NULL;
        WARNING(DLLTEXT("IMultiColorUni::QueryInterface NULL. Returning E_NOINTERFACE.\r\n")); 
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

ULONG __stdcall IMultiColorUni::AddRef()
{
    VERBOSE(DLLTEXT("IMultiColorUni::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IMultiColorUni::Release() 
{
    VERBOSE(DLLTEXT("IMultiColorUni::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}


HRESULT __stdcall IMultiColorUni::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE(DLLTEXT("IMultiColorUni::GetInfo(%d) entry.\r\n"), dwMode);

    // Validate parameters.
    if( (NULL == pcbNeeded)
        ||
        ( (OEMGI_GETSIGNATURE != dwMode)
          &&
          (OEMGI_GETVERSION != dwMode)
          &&
          (OEMGI_GETPUBLISHERINFO != dwMode)
        )
      )
    {
        WARNING(DLLTEXT("IMultiColorUni::GetInfo() exit pcbNeeded is NULL! ERROR_INVALID_PARAMETER.\r\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Set expected buffer size.
    if(OEMGI_GETPUBLISHERINFO != dwMode)
    {
        *pcbNeeded = sizeof(DWORD);
    }
    else
    {
        *pcbNeeded = sizeof(PUBLISHERINFO);
        return E_FAIL;
    }

    // Check buffer size is sufficient.
    if((cbSize < *pcbNeeded) || (NULL == pBuffer))
    {
        VERBOSE(DLLTEXT("IMultiColorUni::GetInfo() exit insufficient buffer!\r\n"));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        // OEM DLL Signature
        case OEMGI_GETSIGNATURE:
            *(PDWORD)pBuffer = MULTICOLOR_SIGNATURE;
            break;

        // OEM DLL version
        case OEMGI_GETVERSION:
            *(PDWORD)pBuffer = MULTICOLOR_VERSION;
            break;

        case OEMGI_GETPUBLISHERINFO:
            Dump((PPUBLISHERINFO)pBuffer);
            // Fall through to default case.

        // dwMode not supported.
        default:
            // Set written bytes to zero since nothing was written.
            WARNING(DLLTEXT("IMultiColorUni::GetInfo() exit mode not supported.\r\n"));
            *pcbNeeded = 0;
            SetLastError(ERROR_NOT_SUPPORTED);
            return E_FAIL;
    }

    VERBOSE(DLLTEXT("IMultiColorUni::GetInfo() exit S_OK, (*pBuffer is %#x).\r\n"), *(PDWORD)pBuffer);

    return S_OK;
}

HRESULT __stdcall IMultiColorUni::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(DLLTEXT("IMultiColorUni::PublishDriverInterface() entry.\r\n"));

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->m_pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** ) &(this->m_pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->m_pOEMHelp = NULL;

            return E_FAIL;
        }
    }

    return S_OK;
}


HRESULT __stdcall IMultiColorUni::EnableDriver(
    DWORD          dwDriverVersion,
    DWORD          cbSize,
    PDRVENABLEDATA pded)
{
    VERBOSE(DLLTEXT("IMultiColorUni::EnableDriver() entry.\r\n"));

    MultiColor_EnableDriver(dwDriverVersion, cbSize, pded);

    // Even if nothing is done, need to return S_OK so 
    // that DisableDriver() will be called, which releases
    // the reference to the Printer Driver's interface.
    return S_OK;
}

HRESULT __stdcall IMultiColorUni::DisableDriver(VOID)
{
    VERBOSE(DLLTEXT("IMultiColorUni::DisaleDriver() entry.\r\n"));

    MultiColor_DisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->m_pOEMHelp)
    {
        this->m_pOEMHelp->Release();
        this->m_pOEMHelp = NULL;
    }

    return S_OK;
}

HRESULT __stdcall IMultiColorUni::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    VERBOSE(DLLTEXT("IMultiColorUni::DisablePDEV() entry.\r\n"));

    MultiColor_DisablePDEV(pdevobj);

    return S_OK;
};

HRESULT __stdcall IMultiColorUni::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *ppDevOem)
{
    VERBOSE(DLLTEXT("IMultiColorUni::EnablePDEV() entry.\r\n"));

    CHAR    szOutput[256];
    DWORD   dwSizeNeeded;
    DWORD   dwNumOptions;
    LONG    MultiColorMode;

    if (this->m_pOEMHelp->DrvGetDriverSetting(pdevobj, "ColorMode", 
                                              szOutput, sizeof(szOutput), 
                                              &dwSizeNeeded, &dwNumOptions) != S_OK) {

        WARNING(ERRORTEXT("IPrintOemDriverUni::DrvGetDriverSetting failed.\r\n"));
        *ppDevOem = NULL;
        return E_FAIL;
    }

    ASSERT(dwNumOptions == 1);
    ASSERT(dwSizeNeeded <= 256);

    DbgPrint("\nThe ColorMode=%s\n", szOutput);

    // 
    // Check whether we are in the multicolor mode
    //

    if (!strcmp(szOutput, "MultiColor_600C600K")) {

        MultiColorMode = MCM_600C600K;

    } else if (!strcmp(szOutput, "MultiColor_300C600K")) {

        MultiColorMode = MCM_300C600K;

    } else {

        MultiColorMode = MCM_NONE;
    }

    *ppDevOem = MultiColor_EnablePDEV(pdevobj,
                                      pPrinterName,
                                      cPatterns,
                                      phsurfPatterns,
                                      cjGdiInfo,
                                      pGdiInfo,
                                      cjDevInfo,
                                      pDevInfo,
                                      pded,
                                      m_pOEMHelp,
                                      MultiColorMode);

    return (NULL != *ppDevOem ? S_OK : E_FAIL);
}


HRESULT __stdcall IMultiColorUni::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    BOOL    bResult;


    VERBOSE(DLLTEXT("IMultiColorUni::ResetPDEV() entry.\r\n"));


    bResult = MultiColor_ResetPDEV(pdevobjOld, pdevobjNew);

    return (bResult ? S_OK : E_FAIL);
}


HRESULT __stdcall IMultiColorUni::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam)
{   
    VERBOSE(DLLTEXT("IMultiColorUni:DevMode(%d, %#x) entry.\n"), dwMode, pOemDMParam); 

    return MultiColor_hrDevMode(dwMode, pOemDMParam);
}

HRESULT __stdcall IMultiColorUni::GetImplementedMethod(PSTR pMethodName)
{
    HRESULT Result = S_FALSE;

    VERBOSE(DLLTEXT("IMultiColorUni::GetImplementedMethod() entry.\r\n"));
    VERBOSE(DLLTEXT("        Function:%hs:"),pMethodName);

    switch (*pMethodName)
    {
        case 'D':
            if (!strcmp(NAME_DisableDriver, pMethodName))
            {
                Result = S_OK;
            }
            else if (!strcmp(NAME_DisablePDEV, pMethodName))
            {
                Result = S_OK;
            }
            else if (!strcmp(NAME_DevMode, pMethodName))
            {
                Result = S_FALSE;
            }
            break;

        case 'E':
            if (!strcmp(NAME_EnableDriver, pMethodName))
            {
                Result = S_OK;
            }
            else if (!strcmp(NAME_EnablePDEV, pMethodName))
            {
                Result = S_OK;
            }
            break;

        case 'G':
            if (!strcmp(NAME_GetInfo, pMethodName))
            {
                Result = S_FALSE;
            }
            break;

        case 'I':
            if (!strcmp(NAME_ImageProcessing, pMethodName))
            {
                Result = S_OK;
            }
            break;

        case 'M':
            if (!strcmp(NAME_MemoryUsage, pMethodName))
            {
                Result = S_FALSE;
            }
            break;

        case 'R':
            if (!strcmp(NAME_ResetPDEV, pMethodName))
            {
                Result = S_OK;
            }
            break;
    }

    VERBOSE( Result == S_OK ? TEXT("Supported\r\n") : TEXT("NOT supported\r\n"));

    return Result;
}

HRESULT __stdcall IMultiColorUni::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    VERBOSE(DLLTEXT("IMultiColorUni::CommandCallback() entry.\r\n"));
    VERBOSE(DLLTEXT("        dwCallbackID = %d\r\n"), dwCallbackID);
    VERBOSE(DLLTEXT("        dwCount      = %d\r\n"), dwCount);

    return E_NOTIMPL;
}

#define DIB_FILENAME    _TEXT("c:\\hp970c_p%02ldb%02ld.dib")



HRESULT
__stdcall
IMultiColorUni::ImageProcessing(
    PDEVOBJ             pDevObj,
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallBackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult
    )

/*++

Routine Description:

    This function will process each band of image data and convert it to the
    planner from the multiple ink levels (GDI Halftone 8bpp mask mode)

Arguments:

    See DDK


Return Value:

    HRESULT, S_OK if sucessful

Author:

    01-Jun-2000 Thu 19:25:56 created  -by-  Daniel Chou (danielc)


Revision History:

    06-Jun-2000 Tue 19:26:17 updated  -by-  Daniel Chou (danielc)
        Update the WriteDIB function

--*/

{
    PMULTICOLORPDEV pMultiColorPDEV;
    HRESULT         hResult = S_OK;


    VERBOSE(DLLTEXT("IMultiColorUni::ImageProcessing() entry.\r\n"));

    pMultiColorPDEV = (PMULTICOLORPDEV)(pDevObj->pdevOEM);

    ASSERT((DWORD)pMultiColorPDEV->ColorMode == dwCallBackID);

    //
    // The iPage is running from 1 and up, but the iBand is running from 0
    //

    if ((pIPParams->ptOffset.x == 0) && (pIPParams->ptOffset.y == 0)) {

        pMultiColorPDEV->iBand = 0xFFFFFFFF;
        pMultiColorPDEV->iPage++;
    }

    ++pMultiColorPDEV->iBand;

    if ((DWORD)(pIPParams->ptOffset.y + pBitmapInfoHeader->biHeight) ==
                                                    pMultiColorPDEV->cy) {

        pMultiColorPDEV->iBand |= LAST_BAND_MASK;
    }

    if ((!(pIPParams->bBlankBand))  &&
        (pMultiColorPDEV->Flags & MCPF_INVERT_BITMASK)) {

        //
        // This is a 8bpp CMY_INVERTED bitmask mode, since this mode is
        // intended to be process as CMY mode, so we will translate every
        // indices (byte) to get it back to original Windows 2000 style
        // CMY 332 bits mode indices which is NON CMY_INVERTED indices
        //

        PINKLEVELS  pInkLevels;
        LPBYTE      pbSrc;
        LPBYTE      pbSrcEnd;

        pbSrc      = (LPBYTE)pSrcBitmap;
        pbSrcEnd   = pbSrc + ((DWORD)ROUNDUP_DWORD(pBitmapInfoHeader->biWidth) *
                              (DWORD)pBitmapInfoHeader->biHeight);
        pInkLevels = pMultiColorPDEV->InkLevels;

        while (pbSrc < pbSrcEnd) {

            *pbSrc++ = pInkLevels[*pbSrc].CMY332Idx;
        }
    }
#if DBG
    DbgPrint("\n==== Page=%ld, %s%sBand=%ld (%ld, %ld)-(%ld, %ld)=%ldx%ld ===",
        pMultiColorPDEV->iPage,
        IS_FIRST_BAND(pMultiColorPDEV->iBand) ? "FIRST " :
            (IS_LAST_BAND(pMultiColorPDEV->iBand) ? "LAST " : ""),
        (pIPParams->bBlankBand) ? "BLANK " : "",
        // pMultiColorPDEV->cx, pMultiColorPDEV->cy,
        GET_BAND_NUMBER(pMultiColorPDEV->iBand),
        pIPParams->ptOffset.x, pIPParams->ptOffset.y,
        pIPParams->ptOffset.x + pBitmapInfoHeader->biWidth,
        pIPParams->ptOffset.y + pBitmapInfoHeader->biHeight,
        pBitmapInfoHeader->biWidth, pBitmapInfoHeader->biHeight);
#endif

#if DBG && defined(DBG_WRITEDIB)

    TCHAR szFileName[MAX_PATH];

    if (IS_FIRST_PAGE(pMultiColorPDEV->iPage) &&
        IS_FIRST_BAND(pMultiColorPDEV->iBand)) {

        UINT    i;
        UINT    j;

        //
        // Delete all the previouse document file, remeber the page and band
        // number started at 1
        //

        for (i = 1; ; i++) {

            for (j = 1; ; j++) {

                _stprintf(szFileName, DIB_FILENAME, i, j);

                if (!DeleteFile(szFileName)) {

                    break;

                } else {

                    DbgPrint("\nDelete File=%ws", szFileName);
                }
            }

            if (j == 1) {

                break;
            }
        }
    }

    //
    // Make both iPage, iBand indicate from 1 and up
    //

    _stprintf(szFileName, DIB_FILENAME,
                        pMultiColorPDEV->iPage,
                        GET_BAND_NUMBER(pMultiColorPDEV->iBand) + 1);

    DbgPrint("\nszFileName=%ws", szFileName);

    MultiColor_WriteFile(pDevObj,
                         szFileName,
                         pBitmapInfoHeader,
                         pSrcBitmap,
                         pIPParams,
                         pMultiColorPDEV->iPage,
                         pMultiColorPDEV->iBand);

#endif

    hResult = MultiColor_WriteBand(pMultiColorPDEV,
                                   pBitmapInfoHeader,
                                   pSrcBitmap,
                                   pIPParams,
                                   pMultiColorPDEV->iPage,
                                   pMultiColorPDEV->iBand);
#if DBG
    DbgPrint("\n-----ImageProcessing: Page=%ld, iBand=%ld, Ret=%ld-----\n",
        pMultiColorPDEV->iPage,
        GET_BAND_NUMBER(pMultiColorPDEV->iBand), hResult);
#endif
    *ppbResult = (LPBYTE)(INT_PTR)((hResult == S_OK) ? TRUE : FALSE);

    return(hResult);
}


HRESULT __stdcall IMultiColorUni::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    VERBOSE(DLLTEXT("IMultiColorUni::FilterGraphics() entry.\r\n"));
    return E_NOTIMPL;
}

HRESULT __stdcall IMultiColorUni::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE(DLLTEXT("IMultiColorUni::Compression() entry.\r\n"));
    return E_NOTIMPL;
}


HRESULT __stdcall IMultiColorUni::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE(DLLTEXT("IMultiColorUni::HalftonePattern() entry.\r\n"));
    return E_NOTIMPL;
}

HRESULT __stdcall IMultiColorUni::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE(DLLTEXT("IMultiColorUni::MemoryUsage() entry.\r\n"));
    return E_NOTIMPL;
}

HRESULT __stdcall IMultiColorUni::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE(DLLTEXT("IMultiColorUni::DownloadFontHeader() entry.\r\n"));
    return E_NOTIMPL;
}

HRESULT __stdcall IMultiColorUni::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE(DLLTEXT("IMultiColorUni::DownloadCharGlyph() entry.\r\n"));
    return E_NOTIMPL;
}

HRESULT __stdcall IMultiColorUni::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE(DLLTEXT("IMultiColorUni::TTDownloadMethod() entry.\r\n"));
    return E_NOTIMPL;
}

HRESULT __stdcall IMultiColorUni::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE(DLLTEXT("IMultiColorUni::OutputCharStr() entry.\r\n"));
    return E_NOTIMPL;
}

HRESULT __stdcall IMultiColorUni::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE(DLLTEXT("IMultiColorUni::SendFontCmd() entry.\r\n"));
    return E_NOTIMPL;
}

HRESULT __stdcall IMultiColorUni::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE(DLLTEXT("IMultiColorUni::DriverDMS() entry.\r\n"));
    return E_NOTIMPL;
}

HRESULT __stdcall IMultiColorUni::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *NAME_o,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE(DLLTEXT("IMultiColorUni::TextOutAsBitmap() entry.\r\n"));
    return E_NOTIMPL;
}

HRESULT __stdcall IMultiColorUni::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE(DLLTEXT("IMultiColorUni::TTYGetInfo() entry.\r\n"));
    return E_NOTIMPL;
}


////////////////////////////////////////////////////////////////////////////////
//
// MultiColor class factory
//
class IMultiColorCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);
   
    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IMultiColorCF(): m_cRef(1) { };
    ~IMultiColorCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IMultiColorCF::QueryInterface(const IID& iid, void** ppv)
{    
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IMultiColorCF*>(this); 
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

ULONG __stdcall IMultiColorCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IMultiColorCF::Release() 
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

// IClassFactory implementation
HRESULT __stdcall IMultiColorCF::CreateInstance(IUnknown* pUnknownOuter,
                                                const IID& iid,
                                                void** ppv) 
{
    //VERBOSE(DLLTEXT("Class factory:\t\tCreate component."));

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION;
    }

    // Create component.
    IMultiColorUni* pMultiColorCP = new IMultiColorUni;
    if (pMultiColorCP == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Get the requested interface.
    HRESULT hr = pMultiColorCP->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pMultiColorCP->Release();
    return hr;
}

// LockServer
HRESULT __stdcall IMultiColorCF::LockServer(BOOL bLock) 
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks); 
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK;
}


//
// Registration functions
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    VERBOSE(DLLTEXT("DllCanUnloadNow entered.\r\n"));

    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    VERBOSE(DLLTEXT("DllGetClassObject:\tCreate class factory.\r\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    // Create class factory.
    IMultiColorCF* pFontCF = new IMultiColorCF;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\sample\hp970c\multicolor\kmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:       KMode.h
//
//
//  PURPOSE:    Definitions and routines for compiling kernel mode instead of user mode.
//
//  PLATFORMS:
//    Windows NT
//
//

#ifndef _KMODE_H
#define _KMODE_H


// Define from ntdef.h in Win2K SDK.
// NT 4 may not have this defined
// in the public headers.
#ifndef NOP_FUNCTION
  #if (_MSC_VER >= 1210)
    #define NOP_FUNCTION __noop
  #else
    #define NOP_FUNCTION (void)0
  #endif
#endif



#ifdef USERMODE_DRIVER

//
// User mode difinitions to get rid of defines for kernel mode.
//

// Don't need critical section in user mode.

#define DECLARE_CRITICAL_SECTION    ;
#define INIT_CRITICAL_SECTION()     NOP_FUNCTION
#define DELETE_CRITICAL_SECTION()   NOP_FUNCTION
#define IS_VALID_CRITICAL_SECTION() (TRUE)


#else // !USERMODE_DRIVER


////////////////////////////////////////////////////////
//      Kernel Mode Defines
////////////////////////////////////////////////////////

extern HSEMAPHORE ghMultiColorSemaphore;

#define DECLARE_CRITICAL_SECTION    HSEMAPHORE ghMultiColorSemaphore = NULL;
#define INIT_CRITICAL_SECTION()     ghMultiColorSemaphore = EngCreateSemaphore()
#define ENTER_CRITICAL_SECTION()    EngAcquireSemaphore(ghMultiColorSemaphore)
#define LEAVE_CRITICAL_SECTION()    EngReleaseSemaphore(ghMultiColorSemaphore)
#define DELETE_CRITICAL_SECTION()   EngDeleteSemaphore(ghMultiColorSemaphore)
#define IS_VALID_CRITICAL_SECTION() (NULL != ghMultiColorSemaphore)
#define DebugBreak                  EngDebugBreak

// Pool tag marker for memory marking memory allocations.
#define DRV_MEM_POOL_TAG    'lcmD'

// Debug prefix that is outputted in the debug messages.
#define DEBUG_PREFIX        "MultiColorDll: "


// Remap user mode functions that don't have kernel mode
// equivalents to functions that we implement ourselves.

#define OutputDebugStringA(pszMsg)  (MyDebugPrint(DEBUG_PREFIX, "%hs", pszMsg))
#define OutputDebugStringW(pszMsg)  (MyDebugPrint(DEBUG_PREFIX, "%ls", pszMsg))

#if !defined(_M_ALPHA) && !defined(_M_IA64)
    #define InterlockedIncrement        DrvInterlockedIncrement
    #define InterlockedDecrement        DrvInterlockedDecrement
#endif


#define SetLastError                NOP_FUNCTION
#define GetLastError                NOP_FUNCTION



////////////////////////////////////////////////////////
//      Kernel Mode Functions
////////////////////////////////////////////////////////

//
// Implement inline functions to replace user mode 
// functions that don't have kernel mode equivalents.
//


inline int __cdecl _purecall (void)
{
#ifdef DEBUG
    EngDebugBreak();
#endif

    return E_FAIL;
}


inline LONG DrvInterlockedIncrement(PLONG pRef)
{
    ENTER_CRITICAL_SECTION();

        ++(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);
}


inline LONG DrvInterlockedDecrement(PLONG pRef)
{
    ENTER_CRITICAL_SECTION();

        --(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);
}


inline void* __cdecl operator new(size_t nSize)
{
    // return pointer to allocated memory
    return  EngAllocMem(0, nSize, DRV_MEM_POOL_TAG);
}


inline void __cdecl operator delete(void *pMem)
{
    if(pMem)
        EngFreeMem(pMem);
}


inline VOID MyDebugPrint(PCHAR pszPrefix, PCHAR pszFormat, ...)
{
    va_list VAList;

    va_start(VAList, pszFormat);
    EngDebugPrint(DEBUG_PREFIX, pszFormat, VAList);
    va_end(VAList);

    return;
}



#endif // USERMODE_DRIVER


#endif // _KMODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\sample\hp970c\multicolor\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Required header files that shouldn't change often.


#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
extern "C" 
{
    #include <WINDDI.H>
}
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRINTOEM.H>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\sample\hp970c\multicolor\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

    Abstract:

        This file specifies the target component being built and the list of
        sources files needed to build that component.  Also specifies optional
        compiler switches and libraries that are unique for the component being
        built.

!ENDIF

DLLBASE=0x70000000

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj


# To build version with debug output, add -D_DEBUG to C_DEFINES line below
#C_DEFINES=$(C_DEFINES) -DKERNEL_MODE -D_UNICODE -DUNICODE -DOEMCOM -D_DEBUG -DDEBUG

C_DEFINES=$(C_DEFINES) -DKERNEL_MODE -D_UNICODE -DUNICODE -DOEMCOM


TARGETLIBS=  $(SDK_LIB_PATH)\uuid.lib


INCLUDES=..;$(SDK_INC_PATH)\MFC42

SOURCES= ..\dllentry.cpp    \
         ..\intrface.cpp    \
         ..\debug.cpp       \
         ..\devmode.cpp     \
         ..\enable.cpp      \
         ..\WriteDib.cpp    \
         ..\Compress.cpp    \
         ..\MultiColorUni.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\sample\hp970c\multicolor\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MultiColorUni.rc
//

#define MULTICOLOR_600C600K_DISPLAY     1
#define MULTICOLOR_300C600K_DISPLAY     2
#define MULTICOLOR_300C300K_DISPLAY     3

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\sample\hp970c\multicolor\writedib.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  2000  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	WriteDib.cpp
//    
//
//  PURPOSE:  
//      
//      This includes funtions
//
//	Functions:
//
//		
//
//
//  PLATFORMS:  Windows NT/2000
//
//  31-May-2000 Wed 19:12:09 updated  -by-  Daniel Chou (danielc)
//      Major rewrite
//
//

#include "precomp.h"
#include <PRCOMOEM.H>
#include "debug.h"
#include "multicoloruni.h"


#define GET_SI_CB(pbEnd, Idx)                                               \
    pHPOutData->ScanInfo[Idx].cb=(DWORD)((pbEnd)-pHPOutData->ScanInfo[Idx].pb)


#define REMOVE_RIGHT_ZEROS(pbScan, cbScan)                                  \
{                                                                           \
    LPBYTE  pbCur;                                                          \
    BYTE    bSave;                                                          \
                                                                            \
    if (*(pbCur = pbScan + cbScan - 1) == 0) {                              \
                                                                            \
        bSave   = *pbScan;                                                  \
        *pbScan = (BYTE)0xFF;                                               \
                                                                            \
        while (*pbCur == 0) {                                               \
                                                                            \
            --pbCur;                                                        \
        }                                                                   \
                                                                            \
        if (((*pbScan = bSave) == 0) &&                                     \
            (pbCur == pbScan)) {                                            \
                                                                            \
            cbScan = 0;                                                     \
                                                                            \
        } else {                                                            \
                                                                            \
            cbScan = (DWORD)(pbCur - pbScan + 1);                           \
        }                                                                   \
    }                                                                       \
}


//==========================================================================
// Following are local structures that only used in this file
//==========================================================================

typedef union _DW4B {
    DWORD   dw;
    WORD    w[2];
    BYTE    b[4];
    } DW4B, *PDW4B;


//
// INKDATA structure that store CMYK planner data as following, each ink has
// two plane that can make up to 4 levels (0 to 3)
//
//  cm.b[0] - Plane 1 of cyan ink
//  cm.b[1] - Plane 2 of cyan ink       cm.w[0] -- Cyan Ink
//  cm.b[2] - Plane 1 of magenta ink
//  cm.b[3] - Plane 2 of magenta ink    cm.w[1] -- Magenta Ink
//  yk.b[0] - Plane 1 of yellow ink
//  yk.b[1] - Plane 2 of yellow ink     yk.w[0] -- Yellow Ink
//  yk.b[2] - Plane 1 of black ink
//  yk.b[3] - Plane 2 of black ink      yk.w[1] -- Black Ink
//

typedef struct _INKDATA {
    DW4B    cm;
    DW4B    yk;
    } INKDATA, *PINKDATA;


//===========================================================================
// Local used glbal data
//===========================================================================

static const BYTE cPlane[] = { 0, 1, 2, 2, 3, 3, 3, 3 };
static const BYTE HPBegRaster[] = "\x1B*r1A\x1B*b0m";  // "\x1B*r1A\x1B*b0M";
static const BYTE HPEndRaster[] = "0M\x1B*rC";

//
// HP 600C600K black gen data. it is generated by the MakeHPBlackGen()
//

BYTE     HPBlackGen[0x124 + 1] = { 0xFF };

//
// InkData is computed base on the mode, it is used to tranlate a multiple
// coloe 8bpp byte into the CMYK, planner format,

INKDATA  InkData[0x6f + 1];


#if DBG && defined(DBG_WRITEDIB)

#define BLANK_WIDTH     256



HRESULT
APIENTRY
MultiColor_WriteFileHeader(
    PMULTICOLORPDEV     pMultiColorPDEV,
    LPWSTR              pFileName,
    LPBITMAPINFOHEADER  pbih,
    BOOL                bBlanked
    )

/*++

Routine Description:

    This function write out the bitmap file header for the band, the color
    table is stored in the Our PDEV

Arguments:

    ...


Return Value:




Author:

    06-Jun-2000 Tue 19:51:17 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    FILE                *fp;
    BITMAPFILEHEADER    bfh;
    BITMAPINFOHEADER    bih;
    UINT                i;


    bih = *pbih;

    ASSERT(bih.biSize == sizeof(BITMAPINFOHEADER));
    ASSERT(bih.biPlanes == 1);
    ASSERT(bih.biBitCount == 8);
    ASSERT((DWORD)bih.biWidth == pMultiColorPDEV->cx);

    if (bBlanked) {

        bih.biWidth  = BLANK_WIDTH;
    }

    bih.biClrUsed      = 256;
    bih.biClrImportant = 0;
    bih.biSizeImage    = bih.biHeight * ROUNDUP_DWORD(bih.biWidth);

    bfh.bfType         = ((WORD)'M' << 8) | (WORD)'B';
    bfh.bfSize         = sizeof(BITMAPFILEHEADER) +
                               bih.biSize +
                               (sizeof(RGBQUAD) * bih.biClrUsed) +
                               bih.biSizeImage;
    bfh.bfReserved1    = 0;
    bfh.bfReserved2    = 0;
    bfh.bfOffBits      = sizeof(BITMAPFILEHEADER) +
                               bih.biSize +
                               (sizeof(RGBQUAD) * bih.biClrUsed);

    if (!(pMultiColorPDEV->fp = fp = _wfopen(pFileName, __TEXT("wb")))) {
#if DBG
        DbgPrint("\nOpen File=%ws FAILED", pFileName);
#endif
        return(E_FAIL);
    }

    fwrite(&bfh, sizeof(BITMAPFILEHEADER), 1, fp);
    fwrite(&bih, bih.biSize, 1, fp);

    for (i = 0; i < 256; i++) {

        RGBQUAD rgbQ;

        rgbQ.rgbRed      = pMultiColorPDEV->HTPal[i].peRed;
        rgbQ.rgbGreen    = pMultiColorPDEV->HTPal[i].peGreen;
        rgbQ.rgbBlue     = pMultiColorPDEV->HTPal[i].peBlue;
        rgbQ.rgbReserved = 0;

        fwrite(&rgbQ, sizeof(RGBQUAD), 1, fp);
    }

    return(S_OK);
}




HRESULT
APIENTRY
MultiColor_WriteFile(
    PDEVOBJ             pDevObj,
    LPWSTR              pFileName,
    LPBITMAPINFOHEADER  pbih,
    LPBYTE              pBits,
    PIPPARAMS           pIPParams,
    DWORD               iPage,
    DWORD               iBand
    )

/*++

Routine Description:

    This function writes out the bitmap image into a DIB file, this will
    write is out band by band and write it as up-side-down for the DIB

Arguments:

    ..


Return Value:

    HRESULT


Author:

    06-Jun-2000 Tue 19:49:05 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PMULTICOLORPDEV     pMultiColorPDEV;
    DWORD               cb;
    FILE                *fp;


    pMultiColorPDEV = (PMULTICOLORPDEV)(pDevObj->pdevOEM);

    if (MultiColor_WriteFileHeader(pMultiColorPDEV,
                                   pFileName,
                                   pbih,
                                   pIPParams->bBlankBand) != S_OK) {

        return(E_FAIL);
    }

    if (fp = pMultiColorPDEV->fp) {

        LPBYTE  pb;
        DWORD   cbScan;
        LONG    cxDelta;
        LONG    cy;

        //
        // Write it up-side-down for DIB
        //

        if (pIPParams->bBlankBand) {

            BYTE    Buf[BLANK_WIDTH + 4];

            ZeroMemory(Buf, sizeof(Buf));

            cbScan   = ROUNDUP_DWORD(BLANK_WIDTH);
            cy       = pbih->biHeight;

            while (cy--) {

                fwrite(Buf, cbScan, 1, fp);
            }

        } else {

            cbScan   = ROUNDUP_DWORD(pbih->biWidth);
            cxDelta  = -(LONG)cbScan;
            cy       = pbih->biHeight;
            pBits   += (cbScan * cy);

            while (cy--) {

                fwrite(pBits += cxDelta, cbScan, 1, fp);
            }
        }

        fclose(fp);
        pMultiColorPDEV->fp = NULL;

        return(S_OK);
    }

    return(E_FAIL);
}

#endif




VOID
MakeHPBlackGen(
    VOID
    )

/*++

Routine Description:

    This function will generate an array of byte table that will convert a
    combined two ink pixels to form a black with a color ink byte, this assume
    that each pixel of ink intensity will from 0 to 2.

    The format of the table indices are generated as following, each of color
    ink density is occupy three bits, the current pixel color ink is added to
    the next pixel color ink and forming this data indices.

        Index = (UINT)(CurPixel & 0x03) + (UINT)(NextPixel & 0x03) +
                (((UINT)(CurPixel & 0xfc) + (UINT)(NextPixel & 0xfc)) << 1);

             + +------b1-----+
             1 7 6 5 4 3 2 1 0
             +===+ +===+ +===+
               C     M     Y

    The maximum intensity of each ink is 0 to 2 (3 levels) and when adding
    current pixel with next pixel, it will have maximum of 0 - 4 (5 levels) to
    replace current pixel to a black ink (which has correct black rather than
    cyan, magenta and yellow mix.

        1. Each of inks levels (C, M, Y) must greater than one (1)
        2. there must at least two inks levels greater than two (2)

    If all above conditions are met then a black inks is used for current pixel
    and the next pixel will be a total inks levels from addition subtractive a
    black (2 levels of each cyan, magenta and yellow)

    the maximum size of table is based on the fact that maximum ink levels is
    two (2) and two pixel addtion make it maximum of 4 levels so the maximum
    from the above is

             + +------b1-----+
             1 7 6 5 4 3 2 1 0
             +===+ +===+ +===+
               C     M     Y
             |     |     |
             +     +     +
             1 0 0 1 0 0 1 0 0  = 0x124 plus index 0
             + +-----+ +-----+


    This table only used if the output format is MCM_600C600K which we want to
    replaced more ink mix with black then GDI Halftone provided because the
    HP inks mix just does not get black enough on the shadow area.

    You can run ICM on top this rendering to get a better matching profile.

Arguments:

    None


Return Value:

    None


Author:

    30-May-2000 Tue 15:18:48 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    //
    // Only do this if we haven't do it yet
    //

    if (HPBlackGen[0] == 0xFF) {

        BYTE    cC;
        BYTE    cM;
        BYTE    cY;
        BYTE    cZ;
        BYTE    bData;
        UINT    i;

        for (i = 0; i < sizeof(HPBlackGen); i++) {

            bData = 0;
            cC    = (BYTE)((i & 0x1c0) >> 6);
            cM    = (BYTE)((i & 0x038) >> 3);
            cY    = (BYTE)((i & 0x007) >> 0);

            if ((cC <= 4) && (cM <= 4) && (cY <= 4) &&
                (cC >= 2) && (cM >= 2) && (cY >= 2)) {

                cC -= 2;
                cM -= 2;
                cY -= 2;
                cZ   = (cC == 0) ? 1 : 0;

                if (cM == 0) {

                    ++cZ;
                }

                if (cY == 0) {

                    ++cZ;
                }

                if (cZ <= 1) {

                    bData = (cC << 5) | (cM << 2) | (cY);
#if DBG
                    DbgPrint("\n%3ld: CMY=%ld:%ld:%ld ---> %ld:%ld:%ld + K",
                            i, cC + 2, cM + 2, cY + 2, cC, cM, cY);
#endif
                }
            }

            HPBlackGen[i] = bData;
        }
    }
}



VOID
MakeHPCMYKInkData(
    ULONG   ColorMode,
    BYTE    k0,
    BYTE    k1,
    BYTE    KData,
    BYTE    BlackMask
    )

/*++

Routine Description:

    This function compose a cyan, magenta, yellow and black ink data array
    table that to be used to convert a 8bpp 3:3:2 pixel byte to a ink that
    can be used on cmyk planner format.

    This data make one step access to all CMYK planner data.  The maximum of
    table entries is based on the HP300K600C that has maximum of 3 levels
    each which is 0x6f from MAKE_CMYMASK_BYTE() pluse index 0

Arguments:

    ColorMode   - This can be one of the MCM_xxxx format, currently this
                  only support MCM_600C600K and MCM_300C600K

    k0          - The black plane 1 pixel data when ink is black

    k1          - The black plane 2 pixel data when ink is black

    kData       - The extra color plane data when ink is black

    BlackMask   - The black byte that form from MAKE_CMYMASK_BYTE() macro


Return Value:

    VOID


Author:

    31-May-2000 Wed 14:20:16 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    static ULONG    HPClrMode = 0xFFFF;

    DbgPrint("\nColorMode=%ld, k0=%02lx, k1=%02lx, KData=%02lx, Mask=%02lx",
                ColorMode, k0, k1, KData, BlackMask);

    if (HPClrMode != ColorMode) {

        PINKDATA    pInkData;
        BYTE        bData;
        BYTE        Idx;
        BYTE        k[2];

        HPClrMode = ColorMode;
        k[0]       =
        k[1]       = 0;

        //
        // Only generate black data for this mode
        //

        if (HPClrMode == MCM_600C600K) {

            MakeHPBlackGen();
        }

        for (Idx = 0, pInkData = &InkData[0];
             Idx <= BlackMask;
             Idx++, pInkData++) {

            if ((bData = Idx) == BlackMask) {

                bData = KData;
                k[0]  = k0;
                k[1]  = k1;
            }

            pInkData->cm.b[0] = ((bData >> 5) & 0x01);      // c0
            pInkData->cm.b[1] = ((bData >> 6) & 0x01);      // c1
            pInkData->cm.b[2] = ((bData >> 2) & 0x01);      // m0
            pInkData->cm.b[3] = ((bData >> 3) & 0x01);      // m1
            pInkData->yk.b[0] = ((bData >> 0) & 0x01);      // y0
            pInkData->yk.b[1] = ((bData >> 1) & 0x01);      // y1
            pInkData->yk.b[2] = k[0];
            pInkData->yk.b[3] = k[1];

            if (bData != Idx) {

                DbgPrint("\n%ld/%02lx: C=%ld/%ld, M=%ld/%ld, Y=%ld/%ld, K=%ld/%ld",
                            HPClrMode, Idx,
                            pInkData->cm.b[1], pInkData->cm.b[0],
                            pInkData->cm.b[3], pInkData->cm.b[2],
                            pInkData->yk.b[1], pInkData->yk.b[0],
                            pInkData->yk.b[3], pInkData->yk.b[2]);
            }
        }
    }
}



HRESULT
WriteHP600C600K(
    PMULTICOLORPDEV pMCPDev
    )

/*++

Routine Description:

    This function write a 600x600 DPI both color and black to the HP970c.
    The output is in 3 levels 0, 1, 2

Arguments:

    pHPOutData  - Pointer to the HPOUTDATA structure,
                  the InkData[] and HPBlackGen[] must already generated.


Return Value:

    TRUE if OK, FALSE if failed


Author:

    31-May-2000 Wed 15:22:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#define pk1     (HPOutData.ScanInfo[0].pb)
#define pc1     (HPOutData.ScanInfo[1].pb)
#define pc2     (HPOutData.ScanInfo[2].pb)
#define pm1     (HPOutData.ScanInfo[3].pb)
#define pm2     (HPOutData.ScanInfo[4].pb)
#define py1     (HPOutData.ScanInfo[5].pb)
#define py2     (HPOutData.ScanInfo[6].pb)


    PHPOUTDATA  pHPOutData;
    HPOUTDATA   HPOutData;
    HRESULT     hResult;
    DWORD       cx;
    DWORD       cy;
    UINT        Index;
    DW4B        cm;
    DW4B        yk;
    BYTE        bData;
    BYTE        bDataR;
    DWORD       cbW;


    hResult    = S_OK;
    pHPOutData = &pMCPDev->HPOutData;
    cy         = pHPOutData->cy;

    while ((hResult == S_OK) && (cy--)) {

        HPOutData         = *pHPOutData;
        pHPOutData->pbIn += HPOutData.cxDelta;
        cx                = HPOutData.cx;

        //
        // Do first (cx - 1) pixels
        //

        REMOVE_RIGHT_ZEROS(HPOutData.pbIn, cx);

        if (cx == 0) {

            pMCPDev->HPOutData.cBlankY++;

        } else {

            Index  = (UINT)HPOutData.c1stByte;
            cm.dw  =
            yk.dw  = 0;
            bData  = 0;
            bDataR = *HPOutData.pbIn++;

            while (--cx) {

                BYTE    b;

                bData  = bDataR;
                bDataR = *HPOutData.pbIn++;

                //
                // The HPBlackGen is in the format of 3 bits each of cyan,
                // magenta and yellow
                //

                if (b = HPBlackGen[((UINT)((bData & 0x03)+(bDataR & 0x03)))  +
                                   ((UINT)((bData & 0xfc)+(bDataR & 0xfc))<<1)]) {

                    bData  = HPOutData.bBlack;
                    bDataR = b;
                }

                yk.dw <<= 1;
                cm.dw <<= 1;

                if (bData) {

                    yk.dw |= InkData[bData].yk.dw;
                    cm.dw |= InkData[bData].cm.dw;
                }

                if (!(--Index)) {

                    *pc1++ = cm.b[0];
                    *pc2++ = cm.b[1];
                    *pm1++ = cm.b[2];
                    *pm2++ = cm.b[3];
                    *py1++ = yk.b[0];
                    *py2++ = yk.b[1];
                    *pk1++ = yk.b[2];
                    cm.dw  =
                    yk.dw  = 0;
                    Index  = 8;

                }
            }

            //
            // Do the last pixel, remember to shift last byte into the left most
            // bit
            //

            --Index;

            yk.dw  = ((yk.dw << 1) | InkData[bDataR].yk.dw) << Index;
            cm.dw  = ((cm.dw << 1) | InkData[bDataR].cm.dw) << Index;
            *pc1++ = cm.b[0];
            *pc2++ = cm.b[1];
            *pm1++ = cm.b[2];
            *pm2++ = cm.b[3];
            *py1++ = yk.b[0];
            *py2++ = yk.b[1];
            *pk1++ = yk.b[2];

            //
            // Now output the converted planner scan line using compression
            // we have save the cb back, since we remove the end of the
            // line blanks above, we need to pass the correct cb to the
            // TIFF compression
            //

            GET_SI_CB(pk1, 0);
            GET_SI_CB(pc1, 1);
            GET_SI_CB(pc2, 2);
            GET_SI_CB(pm1, 3);
            GET_SI_CB(pm2, 4);
            GET_SI_CB(py1, 5);
            GET_SI_CB(py2, 6);

            hResult = OutputRTLScan(pMCPDev);
        }
    }

    return(hResult);

#undef pk1
#undef pc1
#undef pc2
#undef pm1
#undef pm2
#undef py1
#undef py2
}




HRESULT
WriteHP300C600K(
    PMULTICOLORPDEV pMCPDev
    )

/*++

Routine Description:

    This function write a 300x300 DPI color and 600x600 DPI black to the
    HP970c. The output is in 4 levels 0, 1, 2, 3

    When we mapping the black it will map to 3K + one C1M1Y1. (see InkData)

Arguments:

    pHPOutData  - Pointer to the HPOUTDATA structure,
                  the InkData[] and HPBlackGen[] must already generated.



Return Value:


    TRUE if OK, FALSE if failed



Author:

    31-May-2000 Wed 15:22:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#define pk1     (HPOutData.ScanInfo[0].pb)
#define pk2     (HPOutData.ScanInfo[1].pb)
#define pc1     (HPOutData.ScanInfo[2].pb)
#define pc2     (HPOutData.ScanInfo[3].pb)
#define pm1     (HPOutData.ScanInfo[4].pb)
#define pm2     (HPOutData.ScanInfo[5].pb)
#define py1     (HPOutData.ScanInfo[6].pb)
#define py2     (HPOutData.ScanInfo[7].pb)


    PHPOUTDATA  pHPOutData;
    HPOUTDATA   HPOutData;
    HRESULT     hResult;
    DWORD       cx;
    DWORD       cy;
    UINT        Index;
    DW4B        cm;
    DW4B        yk;
    BYTE        bData;
    DWORD       cbW;
    UINT        pkAdd;


    //
    // If we have less then 5 pixel on the first byte then the black scan
    // must skip one byte, this is true because the black is moving 2 bits
    // at one time in this mode
    //

    hResult    = S_OK;
    pHPOutData = &pMCPDev->HPOutData;
    pkAdd      = (pHPOutData->c1stByte <= 4) ? 1 : 0;
    cy         = pHPOutData->cy;

    while ((hResult == S_OK) && (cy--)) {

        HPOutData         = *pHPOutData;
        pHPOutData->pbIn += HPOutData.cxDelta;
        cx                = HPOutData.cx;

        REMOVE_RIGHT_ZEROS(HPOutData.pbIn, cx);

        if (cx == 0) {

            pMCPDev->HPOutData.cBlankY++;

        } else {

            pk1   += pkAdd;
            pk2   += pkAdd;
            Index  = (UINT)HPOutData.c1stByte;
            cm.dw  =
            yk.dw  = 0;

            while (cx--) {

                bData     = *HPOutData.pbIn++;
                yk.w[0] <<= 1;
                yk.w[1] <<= 2;
                cm.dw   <<= 1;

                if (bData) {

                    cm.dw |= InkData[bData].cm.dw;
                    yk.dw |= InkData[bData].yk.dw;
                }

                if ((!(--Index)) || (!cx)) {

                    if (Index) {

                        //
                        // Shift the last byte data into the left most side, the
                        // index could range from 0 to 7, if Index is not zero then
                        // we face it when cx is zero (last pixel)
                        //

                        cm.dw   <<= Index;
                        yk.w[0] <<= Index;

                        if (Index >= 4) {

                            Index -= 4;
                        }

                        //
                        // The index should be 0 to 3 now, black move two (2) bits
                        // at a time to move all pixel to align at left side.
                        //

                        yk.w[1] <<= (Index << 1);
                    }

                    *pc1++ = cm.b[0];
                    *pc2++ = cm.b[1];
                    *pm1++ = cm.b[2];
                    *pm2++ = cm.b[3];
                    *py1++ = yk.b[0];
                    *py2++ = yk.b[1];
                    *pk1++ = yk.b[2];
                    *pk2++ = yk.b[3];
                    cm.dw  =
                    yk.dw  = 0;
                    Index  = 8;

                } else if (Index == 4) {

                    *pk1++  = yk.b[2];
                    *pk2++  = yk.b[3];
                    yk.w[1] = 0;
                }
            }

            //
            // Now output the converted planner scan line using compression
            // we have save the cb back, since we remove the end of the
            // line blanks above, we need to pass the correct cb to the
            // TIFF compression
            //

            GET_SI_CB(pk1, 0);
            GET_SI_CB(pk2, 1);
            GET_SI_CB(pc1, 2);
            GET_SI_CB(pc2, 3);
            GET_SI_CB(pm1, 4);
            GET_SI_CB(pm2, 5);
            GET_SI_CB(py1, 6);
            GET_SI_CB(py2, 7);

            hResult = OutputRTLScan(pMCPDev);
        }
    }

    return(hResult);

#undef pk1
#undef pk2
#undef pc1
#undef pc2
#undef pm1
#undef pm2
#undef py1
#undef py2

}



HRESULT
SetupBandData(
    PMULTICOLORPDEV pMCPDev,
    PPOINTL         pptlDst
    )

/*++

Routine Description:

    This function setup the HPOUTDATA that relevant to the current bitmap,
    the band bitmap pointer and size will not setup at here,

    the pptlDst is passed so that we can aligned the cursor, for this driver
    this will always 0,0.  But for 300C600K mode, the cursor have to move to
    a 300 DPI location so there must a compensation for the black by moving
    only at multiple of 4.


Arguments:

    pMCPDev - Pointer to our PDEV

    pptlDst - Pointer to the destination started


Return Value:




Author:

    08-Jun-2000 Thu 11:22:12 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPBYTE      pb;
    DWORD       AlignMask;
    DWORD       cxExtra;
    UINT        cbCMY;
    UINT        cbK;
    UINT        iCMY;
    UINT        i;
    DWORD       iScanInfo;
    DWORD       cbCompress;
    DWORD       cbTot;


    iCMY                             = (UINT)cPlane[pMCPDev->cC] +
                                       (UINT)cPlane[pMCPDev->cM] +
                                       (UINT)cPlane[pMCPDev->cY];
    pMCPDev->HPOutData.bBlack        = pMCPDev->BlackMask;
    AlignMask                        = (pMCPDev->KMulX > 1) ? 0x07 : 0x00;
    cxExtra                          = pptlDst->x & AlignMask;
    pMCPDev->HPOutData.c1stByte      = (BYTE)(8 - cxExtra);
    cxExtra                         += pMCPDev->cx;
    pptlDst->x                      &= ~AlignMask;

    //
    // Now, compute all the data count
    //

    cbCMY      = (DWORD)((cxExtra + 7) >> 3);
    cbK        = (DWORD)(((cxExtra * (DWORD)pMCPDev->KMulX) + 7) >> 3);
    cbCompress = (cbK + EXTRA_COMPRESS_BUF_SIZE +
                  (((cbK / TIFF_MAX_LITERAL) + 2) * 2));
    cbTot      = cbCompress + (cbK * (DWORD)pMCPDev->KMulY) + (cbCMY * iCMY);

    DbgPrint("\ncbK=%ld, cbCMY=%ld, iCMY=%ld, KMul=%ld/%ld, cbCompress=%ld, cbTot=%d",
            cbK, cbCMY, iCMY, pMCPDev->KMulX, pMCPDev->KMulY, cbCompress, cbTot);

    //
    // the sequence of the color to be send is K0, K1, C0, C1, M0, M1, Y0, Y1
    //

    if (!(pb = pMCPDev->HPOutData.pbAlloc = new BYTE[cbTot])) {

        return(E_FAIL);
    }

    ZeroMemory(pb, cbTot);

    //
    // Set up the scan info data
    //

    pMCPDev->HPOutData.pbCompress     = pb;
    pb                               += cbCompress;
    pMCPDev->HPOutData.pbEndCompress  = pb;

    for (i = 0, iScanInfo = 0;
         i < (UINT)pMCPDev->KMulY;
         i++, iScanInfo++, pb += cbK) {

        pMCPDev->HPOutData.ScanInfo[iScanInfo].pb = pb;
        pMCPDev->HPOutData.ScanInfo[iScanInfo].cb = cbK;
    }

    for (i = 0; i < iCMY; i++, iScanInfo++, pb += cbCMY) {

        pMCPDev->HPOutData.ScanInfo[iScanInfo].pb = pb;
        pMCPDev->HPOutData.ScanInfo[iScanInfo].cb = cbCMY;
    }

    pMCPDev->HPOutData.cScanInfo = (BYTE)iScanInfo;

    return(S_OK);
}




HRESULT
APIENTRY
MultiColor_WriteBand(
    PMULTICOLORPDEV     pMCPDev,
    PBITMAPINFOHEADER   pbih,
    PBYTE               pBits,
    PIPPARAMS           pIPParams,
    DWORD               iPage,
    DWORD               iBand
    )
/*++

Routine Description:

    This function will setup necessary parameter and find all bounding
    rectangle in the bitmap specified then output to the hp multiple color
    density printer

    This function writes out the bitmap image into a PCL printer. This function
    assumes that the printer is in a mode such that the Black dots is at twice
    the DPI of the color dots. eg. HP DeskJet 970 Printers) So every color
    pixel in the bitmap corresponds to 1 color dot of Cyan, Magenta and Yellow
    and four black dots.

    IPrintOemDriverUni::DrvWriteSpoolBuf is called to send data to the spooler
    which sends it to the PCL printer. Please refer to the PCL Reference Guide
    for detailed description of PCL commands.

Arguments:

    pMCPDev     - our PDEV

    pbih        - Pointer to the bitmap header

    pBits       - Pointer to the first scan line of bitmap

    pIPParams   - Pointer to the PIOPARAMS

    iPage       - Current Page number from 1

    iBand       - Current band number from 0

Return Value:




Author:

    12-Jun-1998 Fri 16:05:16 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HRESULT hResult = S_OK;
    DWORD   cbW;


    ASSERT((DWORD)pMCPDev->cx == (DWORD)pbih->biWidth);

    if (IS_FIRST_BAND(iBand)) {

        EnterRTLScan(pMCPDev);
    }

    if (pIPParams->bBlankBand) {

        //
        // This is a blank band and pBits is invalid. So we will simply adding
        // the blank lines that we have to skip
        //

        pMCPDev->HPOutData.cBlankY += pbih->biHeight;

    } else {

        //
        // setup current band bitmap information
        //

        pMCPDev->HPOutData.pbIn     = pBits;
        pMCPDev->HPOutData.cx       = pbih->biWidth;
        pMCPDev->HPOutData.cy       = pbih->biHeight;
        pMCPDev->HPOutData.cxDelta  = (LONG)ROUNDUP_DWORD(pbih->biWidth);

        DbgPrint("pbIn=%08lx, %ldx%ld, cxDelta=%ld",
                pBits,pbih->biWidth, pbih->biHeight, pMCPDev->HPOutData.cxDelta);

        //
        // If we never output anything for this page yet, then setup it up now
        // we will do this for every page, since we do not know when the page
        // will be end, at later we may want to do deleting at DisablePDEV
        //

        if (!pMCPDev->HPOutData.pbAlloc) {

            POINTL  ptlDst;

            //
            // Reset my cursor position so that first one will be output correctly
            //

            ptlDst.x =
            ptlDst.y = 0;

            if (hResult = SetupBandData(pMCPDev, &ptlDst) != S_OK) {

                return(E_FAIL);
            }
        }

        if (hResult == S_OK) {

            hResult = pMCPDev->WriteHPMCFunc(pMCPDev);
        }
    }

    if (IS_LAST_BAND(iBand)) {

        ExitRTLScan(pMCPDev);
    }

    return(hResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\sample\hp970c\multicolor\multicoloruni.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997, 1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	MULTICOLORUNI.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for the MultiColor Plugin.
//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _MULTICOLORUNI_H
#define _MULTICOLORUNI_H

#include "DEVMODE.H"
#include <PRCOMOEM.H>


////////////////////////////////////////////////////////
//      MULTICOLOR Plugin Defines
////////////////////////////////////////////////////////

#define MULTICOLOR_SIGNATURE   'MSFT'
#define MULTICOLOR_VERSION     0x00000001L

#define DLLTEXT(s)      __TEXT("MultiColorUni:  ") __TEXT(s)
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)

////////////////////////////////////////////////////////
//      MULTICOLOR Plugin Type Definitions
////////////////////////////////////////////////////////

#define ROUNDUP_DWORD(x)        (((x) + 3) & ~3)

#define COMPRESS_MODE_NONE      0xFF
#define COMPRESS_MODE_ROW       0
#define COMPRESS_MODE_RUNLENGTH 1
#define COMPRESS_MODE_TIFF      2
#define COMPRESS_MODE_DELTA     3
#define COMPRESS_MODE_BLOCK     4
#define COMPRESS_MODE_ADAPT     5

#define TIFF_MIN_REPEATS        3
#define TIFF_MAX_REPEATS        128
#define TIFF_MAX_LITERAL        128

//
// 10 bytes for the DWORD number, and 22 bytes for the extra commands
//

#define EXTRA_COMPRESS_BUF_SIZE 32


// Private information for the MultiColor DLL

#define BAND_MASK           0x7FFFFFFF
#define LAST_BAND_MASK      0x80000000

#define GET_BAND_NUMBER(x)  ((x) & BAND_MASK)
#define IS_FIRST_PAGE(p)    ((p) == 1)
#define IS_FIRST_BAND(x)    (!GET_BAND_NUMBER(x))
#define IS_LAST_BAND(x)     ((x) & LAST_BAND_MASK)

typedef struct _INKLEVELS {
     BYTE    Cyan;          // Cyan level from 0 to max
     BYTE    Magenta;       // Magenta level from 0 to max
     BYTE    Yellow;        // Yellow level from 0 to max
     BYTE    CMY332Idx;     // Original Windows 2000 Non-Inverted CMY332 Index
     } INKLEVELS, *PINKLEVELS;


typedef struct _SCANINFO {
    LPBYTE  pb;
    DWORD   cb;
    } SCANINFO, *PSCANINFO;

typedef struct _HPOUTDATA {
    LPBYTE              pbIn;           // first scan in the current band
    LPBYTE              pbAlloc;        // Alloc. memory pointer in HPOUTDATA
    LPBYTE              pbCompress;     // pointer to the compression buffer
    LPBYTE              pbEndCompress;  // end of compress buffer
    SCANINFO            ScanInfo[8];    // Scan line information
    DWORD               cx;             // width of the band
    DWORD               cy;             // height of the band
    LONG                cxDelta;        // delta to next scan line
    DWORD               cBlankY;        // current blank lines to skip
    BYTE                CompressMode;   // current compression mode
    BYTE                bBlack;         // from MAKE_CMYMASK_BYTE() macro
    BYTE                cScanInfo;      // Total ScanInfo[] used
    BYTE                c1stByte;       // first byte bit pixel count
    } HPOUTDATA, *PHPOUTDATA;

typedef HRESULT (*WRITEHPMULCOLORFUNC)(struct _MULTICOLORPDEV   *pMCPDev);

#define MCPF_INVERT_BITMASK             0x00000001

typedef struct _MULTICOLORPDEV {

    PDEVOBJ             pDevObj;        // pDevObj
    IPrintOemDriverUni  *pOEMHelp;      // Pointer to IPrintOemDriverUni Interface
    WRITEHPMULCOLORFUNC WriteHPMCFunc;  // Real output func
    HPOUTDATA           HPOutData;      // the HTOUTDATA data structure
    INKLEVELS           InkLevels[256]; // Ink Levels
    HPALETTE            hPal;           // Palette created using EngCreatePalette() in
                                        // EnablePDEV.
    PFN     pfnUnidrv[INDEX_LAST];      // This array contains all the DrvXXX calls Unidrv
                                        // implements. Can be useful if we hook any of those
                                        // calls in EnableDriver() and want to allow Unidrv
                                        // handle the call in some cases.
#if DBG
    FILE                *fp;
#endif

    DWORD               Flags;          // MCPF_xxx flags
    DWORD               iPage;          // Current Page counter
    DWORD               iBand;          // current band number
    BYTE                cC;             // Cyan Ink levels
    BYTE                cM;             // Magenta Ink levels
    BYTE                cY;             // Yellow Ink levels
    BYTE                BlackMask;      // Black Mask
    DWORD               cx;             // width of the surface
    DWORD               cy;             // height of the surface
    WORD                KMulX;          // Black multiple of color (X DPI)
    WORD                KMulY;          // Black multiple of color (Y DPI)
    WORD                xRes;           // X resolution
    WORD                yRes;           // Y resolution
    WORD                ColorMode;      // Current Color Mode
    WORD                cHTPal;         // Total Count of HTPal
    PALETTEENTRY        HTPal[256];     // Halftone Palette Entries

} MULTICOLORPDEV, *PMULTICOLORPDEV;


#define WRITE_DATA(p, pb, c)                                                \
{                                                                           \
    if (hResult == S_OK) {                                                  \
                                                                            \
        if (((p)->pOEMHelp->DrvWriteSpoolBuf((p)->pDevObj,                  \
                                             (LPSTR)(pb),                   \
                                             (c),                           \
                                             &cbW) != S_OK) ||              \
            (cbW != (c))) {                                                 \
                                                                            \
            hResult = E_FAIL;                                               \
        }                                                                   \
    }                                                                       \
}


/*************************************************************************************
 * Function prototype declarations from enable.c                                     *
 *************************************************************************************/

#define MCM_NONE            0
#define MCM_600C600K        1
#define MCM_300C600K        2

PDEVOEM APIENTRY 
MultiColor_EnablePDEV(PDEVOBJ               pdevobj,
                      PWSTR                 pPrinterName,
                      ULONG                 cPatterns,
                      HSURF                 *phsurfPatterns,
                      ULONG                 cjGdiInfo,
                      GDIINFO               *pGdiInfo,
                      ULONG                 cjDevInfo,
                      DEVINFO               *pDevInfo,
                      DRVENABLEDATA         *pded,
                      IPrintOemDriverUni    *pOEMHelp,
                      ULONG                 MultiColorMode);


VOID APIENTRY 
MultiColor_DisablePDEV(PDEVOBJ pdevobj);

BOOL APIENTRY 
MultiColor_ResetPDEV(PDEVOBJ pdevobjOld,
                     PDEVOBJ pdevobjNew);

VOID APIENTRY 
MultiColor_DisableDriver();

BOOL APIENTRY 
MultiColor_EnableDriver(DWORD dwOEMintfVersion, 
                        DWORD dwSize, 
                        PDRVENABLEDATA pded);


/*************************************************************************************
 * Function prototype declarations from WriteDib.c                                   *
 *************************************************************************************/

HRESULT
APIENTRY
MultiColor_WriteFile(PDEVOBJ            pDevObj,
                     LPWSTR             pFileName,
                     LPBITMAPINFOHEADER pbih,
                     LPBYTE             pBits,
                     PIPPARAMS          pIPParams,
                     DWORD              iPage,
                     DWORD              iBand
                     );

//
// The iBand is the band count within a page, if lower 31 bits equal to 0 then
// this is the first band, if a 0x80000000 bit is set then this is the last
// band
//

HRESULT
APIENTRY
MultiColor_WriteBand(PMULTICOLORPDEV    pMCPDev,
                    PBITMAPINFOHEADER   pbih,
                    PBYTE               pBits,
                    PIPPARAMS           pIPParams,
                    DWORD               iPage,
                    DWORD               iBand
                    );

HRESULT
WriteHP600C600K(
    PMULTICOLORPDEV pMCPDev
    );

HRESULT
WriteHP300C600K(
    PMULTICOLORPDEV pMCPDev
    );

VOID
MakeHPCMYKInkData(
    ULONG   ColorMode,
    BYTE    k0,
    BYTE    k1,
    BYTE    KData,
    BYTE    BlackMask
    );

HRESULT
EnterRTLScan(
    PMULTICOLORPDEV pMCPDev
    );

HRESULT
OutputRTLScan(
    PMULTICOLORPDEV pMCPDev
    );

HRESULT
ExitRTLScan(
    PMULTICOLORPDEV pMCPDev
    );


#endif /* _MULTICOLORUNI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmsrc.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

Common sources files shared by all icm directories

!ENDIF

!ifndef ANSI
C_DEFINES=-D_UNICODE -DUNICODE
!endif

MSC_WARNING_LEVEL=/W3 /WX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\halftone\sample\hp970c\multicolor\name.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Name.H
//    
//
//  PURPOSE:	Define string literals for interface funcion names.
//
//  PLATFORMS:
//
//    Windows NT
//
//
#ifndef _NAME_H
#define _NAME_H


/////////////////////////////////////////////////////////
//		String Leterals
/////////////////////////////////////////////////////////

CONST CHAR NAME_CommandCallback[]           = "CommandCallback";
CONST CHAR NAME_Compression[]               = "Compression";
CONST CHAR NAME_DevMode[]                   = "DevMode";
CONST CHAR NAME_DisableDriver[]             = "DiableDriver";
CONST CHAR NAME_DisablePDEV[]               = "DisablePDEV";
CONST CHAR NAME_DownloadCharGlyph[]         = "DownloadCharGlyph";
CONST CHAR NAME_DownloadFontHeader[]        = "DownloadFontHeader";
CONST CHAR NAME_DriverDMS[]                 = "DriverDMS";
CONST CHAR NAME_EnableDriver[]              = "EnableDriver";
CONST CHAR NAME_EnablePDEV[]                = "EnablePDEV";
CONST CHAR NAME_FilterGraphics[]            = "FilterGraphics";
CONST CHAR NAME_GetImplementedMethod[]      = "GetImplementedMethod";
CONST CHAR NAME_GetInfo[]                   = "GetInfo";
CONST CHAR NAME_HalftonePattern[]           = "HalftonePattern";
CONST CHAR NAME_ImageProcessing[]           = "ImageProcessing";
CONST CHAR NAME_MemoryUsage[]               = "MemoryUsage";
CONST CHAR NAME_OutputCharStr[]             = "OutputCharStr";
CONST CHAR NAME_PublishDriverInterface[]    = "PublishDriverInterface";
CONST CHAR NAME_SendFontCmd[]               = "SendFontCmd";
CONST CHAR NAME_ResetPDEV[]                 = "ResetPDEV";
CONST CHAR NAME_TextOutAsBitmap[]           = "TextOutAsBitmap";
CONST CHAR NAME_TTDownloadMethod[]          = "TTDownloadMethod";
CONST CHAR NAME_TTYGetInfo[]                = "TTYGetInfo";





#endif

/* 

CommandCallback
Compression
DevMode
DisableDriver
DisablePDEV
DownloadCharGlyph
DownloadFontHeader
DriverDMS
EnableDriver
EnablePDEV
FilterGraphics
GetImplementedMethod
GetInfo
HalftonePattern
ImageProcessing
MemoryUsage
OutputCharStr
PublishDriverInterface
QueryInterface
ResetPDEV
SendFontCmd
TextOutAsBitmap
TTDownloadMethod
TTYGetInfo

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\dll32\csprof.c ===
#include "generic.h"

#pragma code_seg(_ICM2SEG)
#pragma optimize("",off)

#define TempBfSize 128
#define LINELENG   128
#ifdef ICMDLL
#define ICM2SEG
#endif

static  char    ICM2SEG NewLine[]       = "\n" ;
static  char    ICM2SEG ASCII85DecodeBegine[] = "<~";
static  char    ICM2SEG ASCII85DecodeEnd[] = "~> cvx exec ";

//******************************************************************
//   Local functions to deal with output to the memory buffer

static  SINT    CPLastError;

BOOL    EXTERN     SetCPLastError(SINT LastError)
{
    CPLastError = LastError;
    return(TRUE);
}

SINT    EXTERN     GetCPLastError()
{
    return(CPLastError);
}

BOOL    EXTERN MemAlloc(SINT Size, HGLOBAL FAR *hMemory, LPMEMPTR lpMH)
{
    HGLOBAL hMem;
    LPVOID  lpMem;

    *hMemory = 0;
    if(lpMH == NULL )
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    hMem = GlobalAlloc(GHND, Size) ;
    if(hMem == 0 )
    {
        SetCPLastError(CP_MEMORY_ALLOC_ERR);
        return(FALSE);
    }

    lpMem = GlobalLock(hMem);
    if(lpMem == NULL )
    {
        GlobalFree(hMem);
        SetCPLastError(CP_MEMORY_ALLOC_ERR);
        return(FALSE);
    }
    *lpMH = (MEMPTR)lpMem ;
    *hMemory = hMem;
    return (TRUE);
}

BOOL    EXTERN MemFree(HGLOBAL hMem)
{
    if(hMem == NULL )
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    GlobalUnlock(hMem);
    GlobalFree(hMem) ;
    return(TRUE);
}

//******************************************************************
//      Low-level Profile functions - used for individual tag access
//******************************************************************
#ifndef ICMDLL
BOOL    EXTERN LoadCP(LPCSTR filename, HGLOBAL FAR *phMem, LPCHANDLE lpCP)
{
    icHeader    CPHeader;
    HFILE       hFile;
    SINT        Res, CPSize;
    MEMPTR      mpCP;

    *phMem = 0;
    if (lpCP == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    hFile = _lopen(filename, READ );
    if( hFile == HFILE_ERROR )
    {
        SetCPLastError(CP_FILE_OPEN_ERR);
        return(FALSE);
    }
 
    Res = _lread(hFile, (LPVOID) &CPHeader, sizeof(CPHeader));
    if( (Res == HFILE_ERROR) ||
        (Res != sizeof(CPHeader)) )
    {
        _lclose(hFile);
        SetCPLastError(CP_FILE_READ_ERR);
        return(FALSE);
    }

    // Make the initial check for validity of the profile
    if( SigtoCSIG(CPHeader.magic) != icMagicNumber )
    {
        _lclose(hFile);
        SetCPLastError(CP_FORMAT_ERR);
        return(FALSE);
    }

    CPSize = ui32toSINT(CPHeader.size);
    if( MemAlloc(CPSize, phMem, (LPMEMPTR) &mpCP) )
    {

        *lpCP = (CHANDLE) mpCP;  // Put the memory pointer as  handle
        // Read profile into  memory
         _lseek(hFile, 0L, SEEK_SET);

        while(CPSize)
        {
            Res = _lread(hFile, (LPVOID) mpCP, 4096);
            if (Res == HFILE_ERROR) 
            {
                _lclose(hFile);
                SetCPLastError(CP_FILE_READ_ERR);
                return(FALSE);
            }
            mpCP    += Res;
            CPSize  -= Res;
        }
    }else
    {
        *phMem = 0;
        _lclose(hFile);
        return(FALSE);
    }
    _lclose(hFile);
    return (TRUE);
}

#else
//******************************************************************
//      Low-level Profile functions - used for individual tag access
//******************************************************************
BOOL    EXTERN LoadCP32(LPCSTR filename, HGLOBAL *phMem, LPCHANDLE lpCP)
{
    icHeader    CPHeader;
    HANDLE      hFile;
    SINT        Res, CPSize;
    MEMPTR      mpCP;
    BOOL        Success;

    if (lpCP == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    hFile = CreateFile(filename, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if( hFile == INVALID_HANDLE_VALUE )
    {
        SetCPLastError(CP_FILE_OPEN_ERR);
        return(FALSE);
    }

    Success = ReadFile(hFile, (LPVOID) &CPHeader, sizeof(CPHeader), &Res, NULL);
    if( ( !Success ) || (Res != sizeof(CPHeader)) )
    {
        CloseHandle(hFile);
        SetCPLastError(CP_FILE_READ_ERR);
        return(FALSE);
    }

    // Make the initial check for validity of the profile
    if( SigtoCSIG(CPHeader.magic) != icMagicNumber )
    {
        CloseHandle(hFile);
        SetCPLastError(CP_FORMAT_ERR);
        return(FALSE);
    }

    CPSize = ui32toSINT(CPHeader.size);
    if( MemAlloc(CPSize, phMem, (LPMEMPTR) &mpCP) )
    {

        *lpCP = (CHANDLE) mpCP;  // Put the memory pointer as  handle
        // Read profile into  memory
        SetFilePointer(hFile, 0L, NULL, FILE_BEGIN);
        Success = ReadFile(hFile, (LPVOID) (LPVOID)mpCP, CPSize, &Res, NULL);
        if (!Success) 
        {
            CloseHandle(hFile);
            SetCPLastError(CP_FILE_READ_ERR);
            return(FALSE);
        }
    }else
    {
        CloseHandle(hFile);
        return(FALSE);
    }
    CloseHandle(hFile);
    return (TRUE);
}
#endif

BOOL    EXTERN FreeCP(HGLOBAL hMem)
{
    return( MemFree(hMem) );
}


BOOL    EXTERN GetCPElementCount(CHANDLE CP, LPSINT lpCount)
{
    lpcpTagList lpTL;
    if (lpCount == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    lpTL = (lpcpTagList) &(((lpcpProfile)CP)->count);
    *lpCount = ui32toSINT(lpTL->count);
    return(TRUE);
}


BOOL    EXTERN GetCPElementInfo(CHANDLE CP, SINT Index,
                                LPMEMPTR lpTagData, LPMEMPTR lpElemData)
{
    SINT    Count;
    lpcpTagList lpTL;

    if ( (lpTagData == NULL) || (lpElemData == NULL) )
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    lpTL = (lpcpTagList) &(((lpcpProfile)CP)->count);
    Count   = ui32toSINT(lpTL->count);
    if ( Count <= Index )
    {
        SetCPLastError(CP_OUT_OF_RANGE_ERR);
        return(FALSE);
    }
    *lpTagData      = ((MEMPTR) &(lpTL->tags[0])) + (Index * sizeof(icTag)) ;
    *lpElemData     = ((MEMPTR) CP) +
                                ui32toSINT( ((lpcpTag)*lpTagData)->offset);
    return(TRUE);
}


/* Checks if the profile has all required fields  for
    this specific type of the color profile             */
BOOL    EXTERN ValidateCP(CHANDLE CP)
{
    BOOL    Result;
    CSIG    ProfileClass;

    if(GetCPClass(CP, (LPCSIG) &ProfileClass) )
    {
        // All profiles must have a ProfileDescription and
        //  a Copyright  tags.

        if( !DoesCPTagExist(CP, icSigProfileDescriptionTag) || 
            !DoesCPTagExist(CP, icSigCopyrightTag ) )
        {
            SetCPLastError(CP_NOT_FOUND_ERR);
            return(FALSE);
        }

        // All profiles, except Device-link, must have a mediaWhitePoint Tag
        switch( ProfileClass )
        {
            case     icSigLinkClass :        /* 'link' */
                if( DoesCPTagExist(CP, icSigAToB0Tag) &&
                    DoesCPTagExist(CP, icSigProfileSequenceDescTag)
                  )
                {
                    Result = TRUE;
                }else
                {
                    Result = FALSE;
                }
                break;

            case     icSigInputClass:       /* 'scnr' */
                if( DoesCPTagExist(CP, icSigGrayTRCTag) ||
                    DoesCPTagExist(CP, icSigAToB0Tag)      )
                {
                    Result = TRUE;
                }else if( DoesCPTagExist(CP, icSigGreenColorantTag) )
                {
                    if( DoesCPTagExist(CP, icSigRedColorantTag) &&
                        DoesCPTagExist(CP, icSigBlueColorantTag) &&
                        DoesCPTagExist(CP, icSigRedTRCTag) &&
                        DoesCPTagExist(CP, icSigGreenTRCTag) &&
                        DoesCPTagExist(CP, icSigBlueTRCTag)
                      )
                    {
                        Result = TRUE;
                    }else
                    {
                        Result = FALSE;
                    }
                }else
                {
                    Result = FALSE;
                }
                Result  &= DoesCPTagExist(CP, icSigMediaWhitePointTag);
                break;

            case     icSigDisplayClass:     /* 'mntr' */
                if( DoesCPTagExist(CP, icSigGrayTRCTag) )
                {
                    Result = TRUE;
                }else if( DoesCPTagExist(CP, icSigGreenColorantTag) )
                {
                    if( DoesCPTagExist(CP, icSigRedColorantTag) &&
                        DoesCPTagExist(CP, icSigBlueColorantTag) &&
                        DoesCPTagExist(CP, icSigRedTRCTag) &&
                        DoesCPTagExist(CP, icSigGreenTRCTag) &&
                        DoesCPTagExist(CP, icSigBlueTRCTag)
                      )
                    {
                        Result = TRUE;
                    }else
                    {
                        Result = FALSE;
                    }
                }else
                {
                    Result = FALSE;
                }
                Result  &= DoesCPTagExist(CP, icSigMediaWhitePointTag);
                break;

            case     icSigOutputClass:      /* 'prtr' */
                if( DoesCPTagExist(CP, icSigGrayTRCTag) )
                {
                    Result = TRUE;
                }else if( DoesCPTagExist(CP, icSigAToB0Tag) &&
                          DoesCPTagExist(CP, icSigAToB1Tag) &&
                          DoesCPTagExist(CP, icSigAToB2Tag) &&
                          DoesCPTagExist(CP, icSigBToA0Tag) &&
                          DoesCPTagExist(CP, icSigBToA1Tag) &&
                          DoesCPTagExist(CP, icSigBToA2Tag) &&
                          DoesCPTagExist(CP, icSigGamutTag) 
                        )
                {
                    Result = TRUE;
                }else
                {
                    Result = FALSE;
                }
                Result  &= DoesCPTagExist(CP, icSigMediaWhitePointTag);
                break;

            case     icSigAbstractClass:    /* 'abst' */
                if( DoesCPTagExist(CP, icSigAToB0Tag) )
                {
                    Result = TRUE;
                }else
                {
                    Result = FALSE;
                }
                Result  &= DoesCPTagExist(CP, icSigMediaWhitePointTag);
                break;

            case     icSigColorSpaceClass:  /* 'spac' */
                if( DoesCPTagExist(CP, icSigAToB0Tag) &&
                    DoesCPTagExist(CP, icSigBToA0Tag)
                  )
                {
                    Result = TRUE;
                }else
                {
                    Result = FALSE;
                }
                Result  &= DoesCPTagExist(CP, icSigMediaWhitePointTag);
                break;

            default:
                Result = FALSE;
                break;
        }
    }else
    {
        return(FALSE);
    }
    if( Result == FALSE )
    {
        SetCPLastError(CP_NOT_FOUND_ERR);
    }
    return(Result);
}

BOOL    EXTERN DoesCPTagExist(CHANDLE CP, CSIG CPTag)
{
    SINT    Count;
    MEMPTR   Data;
    lpcpTagList lpTL;

    lpTL = (lpcpTagList) &(((lpcpProfile)CP)->count);
    Count   = ui32toSINT(lpTL->count);
    Data    = (MEMPTR)  &(lpTL->tags[0]) ; 
    while ( Count-- )
    {
        if(  SigtoCSIG( ((lpcpTag)Data)->sig) == CPTag )
        {
            return(TRUE);
        }else
        {
            Data    += sizeof(icTag);   // Bump pointer to the next tag
        }
    }
    return(FALSE);
}


BOOL    EXTERN GetCPTagIndex(CHANDLE CP, CSIG CPTag, LPSINT lpIndex)
{
    SINT    Count;
    MEMPTR   Data;
    SINT    i;
    lpcpTagList lpTL;

    if (lpIndex == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    lpTL = (lpcpTagList) &(((lpcpProfile)CP)->count);
    Count   = ui32toSINT(lpTL->count);
    Data    = (MEMPTR)  &(lpTL->tags[0]) ;

    for (i = 0; i < Count; i++ )
    {
        if(  SigtoCSIG( ((lpcpTag)Data)->sig) == CPTag )
        {
            *lpIndex = i;
            return(TRUE);
        }else
        {
            Data    += sizeof(icTag);   // Bump pointer to the next tag
        }
    }

    SetCPLastError(CP_NOT_FOUND_ERR);
    return(FALSE);
}



BOOL    EXTERN GetCPTagSig(CHANDLE CP, SINT Index, LPCSIG lpCPTag)
{
    MEMPTR   TagData, ElemData;
    if (lpCPTag == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    if ( GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        *lpCPTag    = SigtoCSIG( ((lpcpTag)TagData)->sig ) ;
    }else
    {
        return(FALSE);
    }
    return(TRUE);
}

//***************************************************************
//      Function applicable to the elements
//
//***************************************************************

BOOL    EXTERN GetCPElementType(CHANDLE CP, SINT Index, LPCSIG lpCSig)
{
    MEMPTR   TagData, ElemData;
    if ( GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        *lpCSig    = SigtoCSIG( ((lpcpTagBase)ElemData)->sig ) ;
    }else
    {
        return(FALSE);
    }
    return(TRUE);
}



BOOL    EXTERN GetCPElementSize(CHANDLE CP, SINT Index, LPSINT lpSize)
{
    MEMPTR   TagData, ElemData;
    if (lpSize == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    if ( GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        *lpSize     = ui32toSINT( ((lpcpTag)TagData)->size );
    }else
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL    EXTERN GetCPElementDataSize(CHANDLE CP, SINT Index, LPSINT lpSize)
{
    MEMPTR  TagData, ElemData;
    if (lpSize == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    if ( GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
//  Changed by jjia 8/24/95
//        *lpSize     = ui32toSINT( ((lpcpTag)TagData)->size ) -
//                                             sizeof(lpcpTagBase);
    *lpSize    = ui32toSINT( ((lpcpTag)TagData)->size) - 
                    sizeof(icTagBase) - sizeof(icUInt32Number);
    }else
    {
        return(FALSE);
    }

    return(TRUE);
}

//***************************************************************
//  The difference between GetCPElement and GetCPElementData
//  is that GetCPElement reads all fields of the element,
//  including the data tag, reserved fields and element data,
//  while GetCPElementData only reads the actual data.
//  Number of bytes that are required to hold the whole data element can be
//  obtained by calling the function GetCPElementSize().
//  The actulal number of data bytes is determined by
//  the call to GetCPElementDataSize().
//***************************************************************
BOOL    EXTERN GetCPElement(CHANDLE CP, SINT Index,
                               MEMPTR lpData, SINT Size)
{
    SINT        ElemSize;
    MEMPTR      TagData, ElemData;
    if (lpData == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    if ( !GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        return(FALSE);
    }
    ElemSize    = ui32toSINT( ((lpcpTag)TagData)->size);
    if(ElemSize > Size )
    {
        SetCPLastError(CP_NO_MEMORY_ERR);
        return(FALSE);
    }
    MemCopy(lpData, ElemData, ElemSize);
    return(TRUE);

}


BOOL    EXTERN GetCPElementData(CHANDLE CP, SINT Index,
                                MEMPTR lpData, SINT Size)
{
    SINT     ElemSize;
    MEMPTR   TagData, ElemData;
    if (lpData == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    if ( !GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        return(FALSE);
    }
//  Changed by jjia 8/24/95
//    ElemData    +=  sizeof(lpcpTagBase);
//    ElemSize    = ui32toSINT( ((lpcpTag)TagData)->size) - 
//                     sizeof(lpcpTagBase);
    ElemData    +=  sizeof(icTagBase) + sizeof(icUInt32Number);
    ElemSize    = ui32toSINT( ((lpcpTag)TagData)->size) - 
                    sizeof(icTagBase) - sizeof(icUInt32Number);

    if(ElemSize > Size )
    {
        SetCPLastError(CP_NO_MEMORY_ERR);
        return(FALSE);
    }

    MemCopy(lpData, ElemData, ElemSize);
    return(TRUE);
}

// Check the data format is binary or ascii    8/22/95  jjia

BOOL    EXTERN GetCPElementDataType(CHANDLE CP, SINT Index, long far *lpDataType)
{
    MEMPTR   TagData, ElemData;

    if (lpDataType == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    if ( !GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        return(FALSE);
    }
    ElemData    +=  sizeof(icTagBase);
    *lpDataType = ui32toSINT( ((icData __huge *)ElemData)->dataFlag);
    return (TRUE);
}

BOOL    EXTERN ValidateCPElement(CHANDLE CP, SINT Index)
{
    CSIG    TagSig, DataSig;
    BOOL    Result;
    if( GetCPTagSig(CP, Index, (LPCSIG) &TagSig) &&
        GetCPElementType(CP, Index, (LPCSIG) &DataSig) )
    {
        switch(TagSig)
        {
            case     icSigAToB0Tag:
            case     icSigAToB1Tag:
            case     icSigAToB2Tag:
            case     icSigBToA0Tag:
            case     icSigBToA1Tag:
            case     icSigBToA2Tag:
            case     icSigGamutTag:
            case     icSigPreview0Tag:
            case     icSigPreview1Tag:
            case     icSigPreview2Tag:
                Result = (DataSig == icSigLut16Type) ||
                         (DataSig == icSigLut8Type) ;
                break;

            case     icSigRedColorantTag: 
            case     icSigGreenColorantTag:
            case     icSigBlueColorantTag:
            case     icSigLuminanceTag:
            case     icSigMediaBlackPointTag:
            case     icSigMediaWhitePointTag:
                Result = (DataSig == icSigXYZType);
                break;

            case     icSigRedTRCTag:
            case     icSigGreenTRCTag:
            case     icSigBlueTRCTag:
            case     icSigGrayTRCTag:
                Result = (DataSig == icSigCurveType);
                break;

            case     icSigPs2CRD0Tag:
            case     icSigPs2CRD1Tag:
            case     icSigPs2CRD2Tag:
            case     icSigPs2CRD3Tag:
            case     icSigPs2CSATag:
            case     icSigPs2Intent0Tag:
            case     icSigPs2Intent1Tag:
            case     icSigPs2Intent2Tag:
            case     icSigPs2Intent3Tag:
                Result = (DataSig == icSigDataType);
                break;

            case     icSigCharTargetTag:
            case     icSigCopyrightTag:
                Result = (DataSig == icSigTextType);
                break;

            case     icSigCalibrationDateTimeTag:
                Result = (DataSig == icSigDateTimeType);
                break;

            case     icSigDeviceMfgDescTag:
            case     icSigDeviceModelDescTag:
            case     icSigProfileDescriptionTag:
            case     icSigScreeningDescTag:
            case     icSigViewingCondDescTag:
                Result = (DataSig == icSigTextDescriptionType);
                break;

            case     icSigMeasurementTag:
                Result = (DataSig == icSigMeasurementTag);
                break;

            case     icSigNamedColorTag:
                Result = (DataSig == icSigNamedColorTag);
                break;
        
            case      icSigProfileSequenceDescTag:
                Result = (DataSig == icSigProfileSequenceDescTag);
                break;

            case     icSigScreeningTag:
                Result = (DataSig == icSigScreeningTag);
                break;

            case     icSigTechnologyTag:
                Result = (DataSig == icSigSignatureType);
                break;

            case     icSigUcrBgTag:
                Result = (DataSig == icSigUcrBgTag);
                break;

            case     icSigViewingConditionsTag:
                Result = (DataSig == icSigViewingConditionsTag);
                break;

            default:
                Result = TRUE;
                break;
        }
    }else
    {
        Result = FALSE;
    }
    return(Result);
}

//******************************************************************
// Functions that get all information from the Color Profile Header
//******************************************************************
BOOL    EXTERN GetCPSize(CHANDLE CP, LPSINT lpSize)
{
    if (lpSize == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpSize    = ui32toSINT( ((lpcpHeader)CP)->size);
    return(TRUE);
}

BOOL    EXTERN GetCPCMMType(CHANDLE CP, LPCSIG lpType)
{
    if (lpType == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpType    = SigtoCSIG( ((lpcpHeader)CP)->cmmId);
    return(TRUE);
}

BOOL    EXTERN GetCPVersion(CHANDLE CP, LPSINT lpVers)
{
    if (lpVers == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpVers    = ui32toSINT( ((lpcpHeader)CP)->version);
    return(TRUE);
}

BOOL    EXTERN GetCPClass(CHANDLE CP, LPCSIG lpClass)
{
    if (lpClass == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpClass    = SigtoCSIG( ((lpcpHeader)CP)->deviceClass);
    return(TRUE);
}

BOOL    EXTERN GetCPDevSpace(CHANDLE CP, LPCSIG lpInSpace)
{
    if (lpInSpace == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpInSpace    = SigtoCSIG( ((lpcpHeader)CP)->colorSpace);
    return(TRUE);
}

BOOL    EXTERN GetCPConnSpace(CHANDLE CP, LPCSIG lpOutSpace)
{
    if (lpOutSpace == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpOutSpace    = SigtoCSIG( ((lpcpHeader)CP)->pcs);
    return(TRUE);
}

BOOL    EXTERN GetCPTarget(CHANDLE CP, LPCSIG lpTarget)
{
    if (lpTarget == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpTarget    = SigtoCSIG( ((lpcpHeader)CP)->platform);
    return(TRUE);
}

BOOL    EXTERN GetCPManufacturer(CHANDLE CP, LPCSIG lpManuf)
{
    if (lpManuf == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpManuf    = SigtoCSIG( ((lpcpHeader)CP)->manufacturer);
    return(TRUE);
}

BOOL    EXTERN GetCPModel(CHANDLE CP, LPCSIG lpModel)
{
    if (lpModel == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpModel    = SigtoCSIG( ((lpcpHeader)CP)->model);
    return(TRUE);
}

BOOL    EXTERN GetCPFlags(CHANDLE CP, LPSINT lpFlags)
{
    if (lpFlags == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpFlags    = ui32toSINT( ((lpcpHeader)CP)->flags);
    return(TRUE);
}

BOOL    EXTERN GetCPRenderIntent(CHANDLE CP, LPSINT lpIntent)
{
    if (lpIntent == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpIntent    = ui32toSINT( ((lpcpHeader)CP)->renderingIntent);
    return(TRUE);
}

BOOL    EXTERN GetCPWhitePoint(CHANDLE CP,  LPSFLOAT lpWP)
{
    if (lpWP == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    lpWP[0]    = (SFLOAT) si16f16toSFLOAT( ((lpcpHeader)CP)->illuminant.X);
    lpWP[1]    = (SFLOAT) si16f16toSFLOAT( ((lpcpHeader)CP)->illuminant.Y);
    lpWP[2]    = (SFLOAT) si16f16toSFLOAT( ((lpcpHeader)CP)->illuminant.Z);
    return(TRUE);
}

BOOL    EXTERN GetCPAttributes(CHANDLE CP, LPATTRIB lpAttributes)
{
    return(TRUE);
}

BOOL    EXTERN GetCPMediaWhitePoint(CHANDLE cp,  LPSFLOAT lpMediaWP)
{
    HGLOBAL   hTempMem;
    SINT      TempSize;
    MEMPTR    TempBuff;
    MEMPTR    lpTable;
    SINT      i, Index;

    if (DoesCPTagExist (cp, icSigMediaWhitePointTag) &&
        GetCPTagIndex (cp, icSigMediaWhitePointTag, (LPSINT) & Index) &&
        GetCPElementSize (cp, Index, (LPSINT) & TempSize) &&
        MemAlloc (TempSize, (HGLOBAL *) & hTempMem, (LPMEMPTR) & TempBuff) &&
        GetCPElement (cp, Index, TempBuff, TempSize))
    {
        lpTable = (MEMPTR) & (((lpcpXYZType) TempBuff)->data);
        for (i = 0; i < 3; i++)
        {
            lpMediaWP[i] = (SFLOAT) si16f16toSFLOAT (lpTable);
            lpTable += sizeof (icS15Fixed16Number);
        }
        MemFree (hTempMem);
        return (TRUE);
    }
    return (FALSE);
}

/***************************************************************************
*                               GetPS2ColorRenderingIntent
*  function:
*    this is the function which creates the Intent string 
*    from the data supplied in the Profile that can be used
*    in --findcolorrendering-- operator.
*  prototype:
*       BOOL EXTERN GetPS2ColorRenderingIntent(
*                          char         *FileName,
*                          DWORD        Intent, 
*                          MEMPTR       lpMem,
*                          LPDWORD      lpcbSize )
*  parameters:
*       FileName    --  Color Profile Filename
*       Intent      --  Intent 
*       lpMem       --  Pointer to the memory block
*       lpcbSize        --  Size of the memory block
*                       Returns number of bytes required/transferred
*  returns:
*       BOOL        --  TRUE   if the function was successful,
*                       FALSE  otherwise.
***************************************************************************/
BOOL EXTERN GetPS2ColorRenderingIntent(CHANDLE cp, DWORD Intent,
                                       MEMPTR lpMem, LPDWORD lpcbSize)
{
    SINT       Index;
    SINT       Size;
        
    if (!cp)
        return FALSE;

    Size = (SINT) *lpcbSize;
    if( ( lpMem == NULL ) || ( Size == 0 ) )
    {
        lpMem = NULL;
        Size = 0;
        *lpcbSize = 0;
    }
        
    switch(Intent)
    {
        case icPerceptual:
        if( DoesCPTagExist(cp, icSigPs2Intent0Tag) &&
            GetCPTagIndex(cp, icSigPs2Intent0Tag, (LPSINT) &Index) &&
            GetCPElementDataSize(cp, Index, (LPSINT) &Size) &&
            ( ( lpMem == NULL ) ||
                GetCPElementData(cp, Index, lpMem, Size) ) )
        {
        }
        break;
        
        case icRelativeColorimetric:
        if( DoesCPTagExist(cp, icSigPs2Intent1Tag) &&
            GetCPTagIndex(cp, icSigPs2Intent1Tag, (LPSINT) &Index) &&
            GetCPElementDataSize(cp, Index, (LPSINT) &Size) &&
            ( ( lpMem == NULL ) ||
                GetCPElementData(cp, Index, lpMem, Size) ) )
        {
        }
        break;
    
        case icSaturation:
        if( DoesCPTagExist(cp, icSigPs2Intent2Tag) &&
            GetCPTagIndex(cp, icSigPs2Intent2Tag, (LPSINT) &Index) &&
            GetCPElementDataSize(cp, Index, (LPSINT) &Size) &&
            ( ( lpMem == NULL ) ||
                GetCPElementData(cp, Index, lpMem, Size ) )
          )
        {
        }
        break;
        case icAbsoluteColorimetric:
        if( DoesCPTagExist(cp, icSigPs2Intent3Tag) &&
            GetCPTagIndex(cp, icSigPs2Intent3Tag, (LPSINT) &Index) &&
            GetCPElementDataSize(cp, Index, (LPSINT) &Size) &&
            ( ( lpMem == NULL ) ||
                GetCPElementData(cp, Index, lpMem, Size) ) )
        {
        }
        break;
        default:
            Size = 0 ;
        break;
    }
        
    if (Size != 0)
    {
        if (lpMem)
        {
            lpMem[Size] = '\0';
        }
        Size ++;
        *lpcbSize = (DWORD) Size;
        return (TRUE);
    }
    else
    {
        return(FALSE);
    }
}

/***************************************************************************
*
*  Function to check if color matching mathod and icc profile type is 
*       supported by driver.
*  parameters:
*
*  returns:
*       BOOL:   TRUE or FALSE.
*
***************************************************************************/

#ifndef ICMDLL
BOOL EXTERN ValidColorSpace(LPPDEVICE lppd, LPICMINFO lpICMI, LPCSIG lpDevCS )
{
    icHeader    CPHeader;
    HFILE       hFile;
    SINT        Res;
    CSIG        CPColorSpaceTag;

    if (NULL == lpICMI)
    {
        return(FALSE);
    }
    hFile = _lopen(lpICMI->lcsDestFilename, READ);
    if( hFile == HFILE_ERROR )
    {
        return(FALSE);
    }

    Res = _lread(hFile, (LPVOID) &CPHeader, sizeof(CPHeader));
    _lclose(hFile);
    if( (Res == HFILE_ERROR) || (Res != sizeof(CPHeader)) )
    {
        return(FALSE);
    }

    // Make the initial check for validity of the profile
    if( SigtoCSIG(CPHeader.magic) != icMagicNumber )
    {
        return(FALSE);
    }
    // Make sure the profile is 'prtr'
    // SRGB98
    // if( SigtoCSIG(CPHeader.deviceClass) != icSigOutputClass )
    // {
    //     return(FALSE);
    // }
    CPColorSpaceTag = SigtoCSIG(CPHeader.colorSpace);
    *lpDevCS = CPColorSpaceTag;             // 247974

    switch ( lppd->lpPSExtDevmode->dm.iColorMatchingMethod )
    {
        case COLOR_MATCHING_ON_HOST:
            if ((CPColorSpaceTag == icSigCmyData))
//                (CPColorSpaceTag == icSigRgbData))
//                (CPColorSpaceTag == icSigGrayData))
            {
                return(FALSE);
            }
            break;
            case COLOR_MATCHING_ON_PRINTER:
            if ((CPColorSpaceTag == icSigCmyData))
//                (CPColorSpaceTag == icSigGrayData))
            {
                return(FALSE);
            }
            break;
        case COLOR_MATCHING_PRINTER_CALIBRATION:
        default:
            break;
    }
    return (TRUE);
}
#endif

//***************************************************************************
//
//      Set of functions to output data into memory buffer
//
//***************************************************************************


/***************************************************************************
*
*   Function to put the chunk of memory as string of Hex
*
***************************************************************************/
SINT    WriteHexBuffer(MEMPTR lpMem, MEMPTR lpBuff, MEMPTR lpLineStart, DWORD dwBytes)
{
    SINT    Res;
    char    TempArray[TempBfSize];
    MEMPTR  lpOldPtr = lpMem;

    for ( ; dwBytes ; dwBytes-- )
    {
        Res = wsprintf( (MEMPTR)TempArray, (LPSTR) "%2.2x", *lpBuff );
        *lpMem++ = TempArray[0];
        *lpMem++ = TempArray[1];
        lpBuff++;
        if (((SINT)(lpMem - lpLineStart)) > MAX_LINELENG)
        {
            lpLineStart = lpMem;
            lpMem += WriteObject(lpMem,  NewLine);
        }
    }
    return( (SINT)(lpMem - lpOldPtr)); 
}

/***************************************************************************
*
*   Function to put the string into the buffer
*
***************************************************************************/
SINT    WriteNewLineObject(MEMPTR lpMem, MEMPTR Obj)
{
    SINT    Res1, Res2;

    Res1 = lstrlen(NewLine);
    MemCopy(lpMem, NewLine, Res1);

    lpMem += Res1;
    Res2 = lstrlen(Obj);
    MemCopy(lpMem, Obj, Res2);
    return( Res1 + Res2 );
}

SINT    WriteObject(MEMPTR lpMem, MEMPTR Obj)
{
    SINT    Res;

    Res = lstrlen(Obj);
    MemCopy(lpMem, Obj, Res);
    return( Res );
}

SINT    WriteObjectN(MEMPTR lpMem, MEMPTR Obj, SINT n)
{
    MemCopy(lpMem, Obj, n);
    return( n );
}
/***************************************************************************
*
*   Function to write the integer into the buffer
*
***************************************************************************/
SINT WriteInt(MEMPTR lpMem, SINT Number)
{
    SINT    Res;
    char    TempArray[TempBfSize];
    
    Res = wsprintf( (MEMPTR)TempArray, "%lu ", Number );
    MemCopy(lpMem, TempArray, lstrlen(TempArray));
    return( Res );
}

/***************************************************************************
*
*   Function to write the integer into the buffer as hex
*
***************************************************************************/
SINT WriteHex(MEMPTR lpMem, SINT Number)
{
    SINT    Res;
    char    TempArray[TempBfSize];

    Res = wsprintf( TempArray, "%2.2x", (int)(Number & 0x00FF) );
    MemCopy(lpMem, TempArray, lstrlen(TempArray));
    return( Res );
}

/***************************************************************************
*
*   Function to write the float into the buffer
*
***************************************************************************/

SINT WriteFloat(MEMPTR lpMem, double dFloat)
{
    char    cSign;
    double  dInt ;
    double  dFract ;
    LONG    lFloat ;
    SINT    Res;
    char    TempArray[TempBfSize];

    lFloat = (LONG) floor( dFloat * 10000.0 + 0.5);

    dFloat = lFloat  / 10000.0 ;

    dInt = floor(fabs(dFloat));
    dFract =  fabs(dFloat) - dInt ;

    cSign   = ' ' ;
    if ( dFloat < 0 )
    {
        cSign   = '-' ;
    }

    Res = wsprintf( (LPSTR) TempArray, (LPSTR) "%c%d.%0.4lu ",
       cSign, (WORD) dInt , (DWORD) (dFract *10000.0)  );
    MemCopy(lpMem, TempArray, lstrlen(TempArray));
    return ( Res );
}

/***************************************************************************
*
*   Function to write the string token into the buffer
*
***************************************************************************/

SINT    WriteStringToken(MEMPTR lpMem, BYTE Token, SINT sNum)
{
    *lpMem++ = Token;
    *lpMem++ = (BYTE)((sNum & 0xFF00) >> 8);
    *lpMem++ = (BYTE)(sNum & 0x00FF);
    return (3);
}

/***************************************************************************
*
*   Function to write the Homogeneous Number Array token into the buffer
*
***************************************************************************/

SINT    WriteHNAToken(MEMPTR lpMem, BYTE Token, SINT sNum)
{
    *lpMem++ = Token;
    *lpMem++ = 32;       // 16-bit fixed integer, high-order byte first
    *lpMem++ = (BYTE)((sNum & 0xFF00) >> 8);
    *lpMem++ = (BYTE)(sNum & 0x00FF);
    return (4);
}

/***************************************************************************
*
*   Function to convert 2-bytes unsigned integer to 2-bytes signed 
*   integer(-32768) and write them to the buffer. High byte first.
*
***************************************************************************/

SINT    WriteIntStringU2S(MEMPTR lpMem, MEMPTR lpBuff, SINT sNum)
{
    SINT    i;
    SINT    Temp;

    for (i = 0; i < sNum; i ++)
    {
        Temp = ui16toSINT( lpBuff) - 32768;
        *lpMem++ = (BYTE)((Temp & 0xFF00) >> 8);
        *lpMem++ = (BYTE)(Temp & 0x00FF);
        lpBuff += sizeof(icUInt16Number);
    }
    return(sNum * 2); 
}

/***************************************************************************
*
*   Function to convert 2-bytes unsigned integer to 2-bytes signed 
*   integer(-32768) and write them to the buffer. Low-order byte first.
*
***************************************************************************/

SINT    WriteIntStringU2S_L(MEMPTR lpMem, MEMPTR lpBuff, SINT sNum)
{
    SINT    i;
    SINT    Temp;

    for (i = 0; i < sNum; i ++)
    {
        Temp = (SINT)*((PUSHORT)lpBuff) - 32768;
        *lpMem++ = (BYTE)((Temp & 0xFF00) >> 8);
        *lpMem++ = (BYTE)(Temp & 0x00FF);
        lpBuff += sizeof(icUInt16Number);
    }
    return(sNum * 2); 
}

/***************************************************************************
*
*   Function to put the chunk of memory into buffer
*
***************************************************************************/
SINT    WriteByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes)
{
    SINT    i;

    for (i = 0; i < sBytes; i ++)
        *lpMem++ = *lpBuff++;
    
    return(sBytes); 
}

/***************************************************************************
*
*   Function to put the chunk of memory into buffer
*
***************************************************************************/
SINT    WriteInt2ByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes)
{
    SINT    i;

       for( i = 0; i < sBytes ; i++)
    {
        *lpMem++ = (BYTE)(ui16toSINT( lpBuff)/256) ;
        lpBuff += sizeof(icUInt16Number);
    }
    return(sBytes); 
}

/***************************************************************************
*
*  Function to control ascii85 encoding.
*  parameters:
*       lpDest      --  Pointer to the encording result buffer.
*       BufSize     --  Size of encording result buffer. 
*       lpSource    --  Pointer to the input buffer
*       DataSize    --  Size of the input buffer
*  returns:
*       SINT        --  Number of bytes actually outputed.
*
****************************************************************************/

SINT    WriteASCII85Cont(MEMPTR lpDest, SINT BufSize, MEMPTR lpSource, SINT DataSize)
{
   SINT     incount;
   MEMPTR   lpPtr, lpSave;
   SINT     rem;
   SINT     bcount;
   SINT     dex;
   unsigned long word;
   
   /* encode the initial 4-tuples */
   lpSave = lpDest;
   lpPtr  = lpSource;
   word   = 0UL;
   bcount = 0;

   for (incount = 0; incount < DataSize; incount ++)
   {
      if ( incount  && ((incount % LINELENG) == 0) )
      lpDest += WriteObject(lpDest,  NewLine);
      word = (word<<8);
      word |= (BYTE)*lpPtr++;
      if (bcount == 3)
      {
         lpDest += WriteAscii85(lpDest, word, 5);
         word = 0UL;
         bcount = 0;
      }
      else
      {
         bcount ++;
      }
   }
   
   /* now do the last partial 4-tuple -- if there is one */
   /* see the Red Book spec for the rules on how this is done */
   if (bcount > 0)
   {
      rem = 4 - bcount;  /* count the remaining bytes */
      for (dex = 0; dex < rem; dex ++) /* shift left for each of them */
      {
         word = (word<<8);      /* (equivalent to adding in ZERO's)*/
         word |= (BYTE)32;
      }
//      lpDest += WriteAscii85(lpDest, word, (bcount + 1));  /* output only meaningful
      lpDest += WriteAscii85(lpDest, word, 5);               /* output only meaningful bytes + 1 */
   }
   return (lpDest - lpSave);
}

/************************************************************************
*
*  Function to convert 4 bytes binary data to 5 bytes ascii85 encorded data.
*  parameters:
*       lpDest      --  Pointer to the encording result buffer.
*       inWord      --  Input word (4-bytes) 
*       nBytes      --  Number of bytes should be outputed.
*  returns:
*       SINT        --  Number of bytes actually outputed.
* 
*************************************************************************/

SINT    WriteAscii85(MEMPTR lpDest, unsigned long inWord, SINT nBytes)
{
    unsigned long divisor;
    int      bcount;
    BYTE     outchar;
    MEMPTR   lpSave = lpDest;

    if ((inWord == 0UL) && (nBytes == 5))
        *lpDest++ = 'z';
    else
    {
        divisor = 52200625UL;
        for (bcount = 0; bcount < nBytes; bcount ++)
        { 
            outchar = (BYTE)((int)(inWord/divisor) + (int)'!');
            *lpDest++ = outchar;
            if (bcount < 4)
            {
                inWord = (inWord % divisor);
                divisor =(divisor / 85);
            }
        }
    }
    return (SINT)(lpDest - lpSave);
}

/***************************************************************************
*
*  Function to convert binary data to ascii by performing ASCII85 encording
*  parameters:
*       lpMem       --  A pointer to the buffer. 
*                       as input: contains binary data; 
*                       as output: contains ascii data. 
*       DataSize    --  The size of input binary data. 
*       BufSize     --  The size of buffer pointed by lpMem.
*  returns:
*       SINT        --  Number of bytes actually outputed.
*
***************************************************************************/

SINT    ConvertBinaryData2Ascii(MEMPTR lpMem, SINT DataSize, SINT BufSize)
{
    MEMPTR      intrbuf, Temp;
    HANDLE      intrhandle;
    SINT        AsciiDataSize = 0;

    if (BufSize >= (SINT)(DataSize/4*5 + sizeof(ASCII85DecodeBegine)+sizeof(ASCII85DecodeEnd) + 2048))
    {
        if ((intrhandle = GlobalAlloc(GHND, BufSize)) != NULL)
        {
            if ((intrbuf = (MEMPTR) GlobalLock(intrhandle)) != NULL)
            {
                Temp = intrbuf;
                Temp += WriteObject(Temp,  NewLine);
                Temp += WriteObject(Temp,  ASCII85DecodeBegine);
                Temp += WriteObject(Temp,  NewLine);
                Temp += WriteASCII85Cont(Temp, BufSize, lpMem, DataSize);
                Temp += WriteObject(Temp,  ASCII85DecodeEnd);
                AsciiDataSize = (SINT)(Temp - intrbuf);
                lstrcpyn(lpMem, intrbuf, (WORD)AsciiDataSize); 
                GlobalUnlock(intrhandle);
            }
        }
        GlobalFree(intrhandle);
   }
   return (AsciiDataSize);
}

/***************************************************************************
*
*  Function to check if it is need to convert a CRD from binary to ascii
*  parameters:
*       CP          --  Handle of memory block which contains icm profile.
*       Index       --  Index of the element data of the profile.
*       lpData      --  A pointer to the buffer. 
*                       as input: contains binary data; 
*                       as output: contains ascii data. 
*       BufSize     --  The size of the buffer pointed by lpData.
*       DataSize    --  The size of input binary data.
*       AllowBinary --  Allow binary or not(1/0).
*  returns:
*       SINT        --  Number of bytes required/actually outputed.
*
***************************************************************************/

SINT    Convert2Ascii(CHANDLE CP, SINT Index,
                      MEMPTR lpData, SINT BufSize, 
                      SINT DataSize, BOOL AllowBinary)
{
    long    DataType;

    GetCPElementDataType(CP, Index, &DataType);
    if (BufSize == 0)
    {
        if (AllowBinary)
            return (DataSize);
        else if (DataType == 0)    // Ascii data in Profile 
            return (DataSize);
        else                       // Keep space for ascii85 encoding.
            return (DataSize / 4 * 5 + sizeof(ASCII85DecodeBegine)+sizeof(ASCII85DecodeEnd) + 2048);
    }
    else
    {
        if (AllowBinary)
            return (DataSize);
        else if(DataType == 0) 
            return (DataSize);
        else 
            return (ConvertBinaryData2Ascii(lpData, DataSize, BufSize) );
    }
}

#ifdef ICMDLL
SINT    MemCopy(MEMPTR Dest, MEMPTR Source, SINT Length)
{
    SINT    i;

    for (i = 0; i < Length; i++)
    {
        Dest[i] = Source[i];
    }
    return( Length );
}

// SRGB98
BOOL EXTERN InvertMatrix (double FAR * lpInMatrix,
                   double FAR * lpOutMatrix)
{
    double det;

    double FAR *a;
    double FAR *b;
    double FAR *c;
    if ((NULL == lpInMatrix) ||
        (NULL == lpOutMatrix))
    {
        return (FALSE);
    }
    a = (double FAR *) &(lpInMatrix[0]);
    b = (double FAR *) &(lpInMatrix[3]);
    c = (double FAR *) &(lpInMatrix[6]);

    det = a[0] * b[1] * c[2] + a[1] * b[2] * c[0] + a[2] * b[0] * c[1] -
        (a[2] * b[1] * c[0] + a[1] * b[0] * c[2] + a[0] * b[2] * c[1]);

    if (det == 0.0)                     // What to do?
    {
        lpOutMatrix[0] = 1.0;
        lpOutMatrix[1] = 0.0;
        lpOutMatrix[2] = 0.0;

        lpOutMatrix[3] = 0.0;
        lpOutMatrix[4] = 1.0;
        lpOutMatrix[5] = 0.0;

        lpOutMatrix[6] = 0.0;
        lpOutMatrix[7] = 0.0;
        lpOutMatrix[8] = 1.0;
        return (FALSE);
    } else
    {
        lpOutMatrix[0] = (b[1] * c[2] - b[2] * c[1]) / det;
        lpOutMatrix[3] = -(b[0] * c[2] - b[2] * c[0]) / det;
        lpOutMatrix[6] = (b[0] * c[1] - b[1] * c[0]) / det;

        lpOutMatrix[1] = -(a[1] * c[2] - a[2] * c[1]) / det;
        lpOutMatrix[4] = (a[0] * c[2] - a[2] * c[0]) / det;
        lpOutMatrix[7] = -(a[0] * c[1] - a[1] * c[0]) / det;

        lpOutMatrix[2] = (a[1] * b[2] - a[2] * b[1]) / det;
        lpOutMatrix[5] = -(a[0] * b[2] - a[2] * b[0]) / det;
        lpOutMatrix[8] = (a[0] * b[1] - a[1] * b[0]) / det;
        return (TRUE);
    }
}

/*
 *  Crc - 32 BIT ANSI X3.66 CRC checksum files
 *
 *
 * Copyright (C) 1986 Gary S. Brown.  You may use this program, or
 * code or tables extracted from it, as desired without restriction.
 */

static DWORD  crc_32_tab[] = { /* CRC polynomial 0xedb88320 */
0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

DWORD  FAR  PASCAL  crc32(MEMPTR buff, DWORD  length)
{
  DWORD  crc, charcnt;
  BYTE    c;


  crc = 0xFFFFFFFF;
  charcnt = 0;

  for (charcnt = 0 ; charcnt < length ; charcnt++)
  {
    c = buff[charcnt] ;
    crc = crc_32_tab[(crc ^ c) & 0xff] ^ (crc >> 8);
  }

  return crc;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\dll32\csprof.h ===
#ifndef SUPPORT_H
#define SUPPORT_H 
#include "windows.h"
#include "icc.h"
#include "icc_i386.h"

#ifdef  __cplusplus
extern "C"
{
#endif

#define  TYPE_CIEBASEDDEF   1
#define  TYPE_CIEBASEDDEFG  2
#define  TempBfSize         128 
#define  CIEXYZRange        1.99997
#define  MAX_LINELENG       240

/*------------------------------------------------------------------------*/
//               Foreword to the functions format.
//  All functions return TRUE if successful
//  and FALSE if not. Exact reason for the FALSE return can be determined
//  by calling GetLastCPError() function.
//  This allows us to use the "C" standard left-to-right evaluation order
//  for the logical expression and the requirement that logical AND
//  operation is performed until FALSE condition is met. That way we can use
//  expression like:
//        if( LoadCP() && ValidateCP() &&
//            DoesCPTagExist() && GetCPTagSig() &&
//            ValidateCPElement())
//        {   // Profile element is OK
//            Process CP Element........
//        }else
//        {     //Something is wrong
//            Err=GetLastCPError();
//        }

// Implementation-specific representation of the handle to the ColorProfile

typedef     MEMPTR      CHANDLE,        // For the convinience and speed
            __far       *LPCHANDLE;     // let's use the pointer to the
                                        // memory block of the profile
                                        // as the profile handle

BOOL    EXTERN LoadCP(LPCSTR filename, HGLOBAL FAR *phMem, LPCHANDLE lphCP);
BOOL    EXTERN LoadCP32(LPCSTR filename, HGLOBAL *phMem, LPCHANDLE lpCP);

BOOL    EXTERN FreeCP(HGLOBAL hMem);

/* Checks if the profile has all required fields  for
    this specific type of the color profile             */
BOOL    EXTERN ValidateCP(CHANDLE hCP);

BOOL    EXTERN DoesCPTagExist(CHANDLE hCP, CSIG CPTag);
BOOL    EXTERN GetCPTagIndex(CHANDLE hCP, CSIG CPTag, LPSINT lpIndex);

BOOL    EXTERN GetCPElementCount(CHANDLE hCP, LPSINT lpIndex);
BOOL    EXTERN ValidateCPElement(CHANDLE hCP, SINT Index);
BOOL    EXTERN GetCPTagSig(CHANDLE hCP, SINT Index, LPCSIG lpCPTag);
BOOL    EXTERN GetCPElementType(CHANDLE hCP, SINT Index, LPCSIG lpCSig);

BOOL    EXTERN GetCPElementSize(CHANDLE hCP, SINT Index, LPSINT lpSize);
BOOL    EXTERN GetCPElementDataSize(CHANDLE hCP, SINT Index, LPSINT lpSize);
BOOL    EXTERN GetCPElement(CHANDLE hCP, SINT Index, MEMPTR lpData, SINT Size);
BOOL    EXTERN GetCPElementData(CHANDLE hCP, SINT Index, MEMPTR lpData, SINT Size);
BOOL    EXTERN GetCPElementDataType(CHANDLE CP, SINT Index, long far *lpDataType);

// Functions that get all information from the Color Profile Header
BOOL    EXTERN GetCPSize(CHANDLE hCP, LPSINT lpSize);
BOOL    EXTERN GetCPCMMType(CHANDLE hCP, LPCSIG lpType);
BOOL    EXTERN GetCPVersion(CHANDLE hCP, LPSINT lpVers);
BOOL    EXTERN GetCPClass(CHANDLE hCP, LPCSIG lpClass);
BOOL    EXTERN GetCPDevSpace(CHANDLE hCP, LPCSIG lpDevSpace);
BOOL    EXTERN GetCPConnSpace(CHANDLE hCP, LPCSIG lpConnSpace);
BOOL    EXTERN GetCPTarget(CHANDLE hCP, LPCSIG lpTarget);
BOOL    EXTERN GetCPManufacturer(CHANDLE hCP, LPCSIG lpManuf);
BOOL    EXTERN GetCPModel(CHANDLE hCP, LPCSIG lpModel);
BOOL    EXTERN GetCPFlags(CHANDLE hCP, LPSINT lpFlags);
BOOL    EXTERN GetCPAttributes(CHANDLE hCP, LPATTRIB lpAttributes);
BOOL    EXTERN GetCPWhitePoint(CHANDLE CP,  LPSFLOAT lpWP);
BOOL    EXTERN GetCPMediaWhitePoint(CHANDLE CP,  LPSFLOAT lpMediaWP);
BOOL    EXTERN GetCPRenderIntent(CHANDLE CP, LPSINT lpIntent);
BOOL    EXTERN GetPS2ColorRenderingIntent(CHANDLE cp, DWORD Intent,
               MEMPTR lpMem, LPDWORD Size);

SINT    EXTERN GetCPLastCPError();
BOOL    EXTERN SetCPLastCPError(SINT cpError);
BOOL    EXTERN SetCPLastError(SINT LastError);
#ifndef ICMDLL
BOOL    EXTERN ValidColorSpace(LPPDEVICE lppd, LPICMINFO lpICMI, LPCSIG lpDevCS);
#endif

BOOL    EXTERN GetCPWhitePoint(CHANDLE CP,  LPSFLOAT lpWP);
SINT    WriteInt(MEMPTR lpMem, SINT Number);
SINT    WriteHex(MEMPTR lpMem, SINT Number);
SINT    WriteNewLineObject(MEMPTR lpMem, MEMPTR Obj);
SINT    WriteObject(MEMPTR lpMem, MEMPTR Obj);
SINT    WriteObjectN(MEMPTR lpMem, MEMPTR Obj, SINT n);
SINT    WriteHexBuffer(MEMPTR lpMem, MEMPTR lpBuff, MEMPTR lpLineStart, DWORD dwBytes);
SINT    WriteFloat(MEMPTR lpMem, double dFloat);
SINT    WriteStringToken(MEMPTR lpMem, BYTE Token, SINT sNum);
SINT    WriteByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes);
SINT    WriteInt2ByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes);
SINT    WriteIntStringU2S(MEMPTR lpMem, MEMPTR lpBuff, SINT sNum);
SINT    WriteIntStringU2S_L(MEMPTR lpMem, MEMPTR lpBuff, SINT sNum);
SINT    WriteHNAToken(MEMPTR lpMem, BYTE Token, SINT sNum);
SINT    WriteAscii85(MEMPTR lpDest, unsigned long inword, SINT nBytes);
SINT    ConvertBinaryData2Ascii(MEMPTR lpMem, SINT DataSize, SINT BufSize);
SINT    Convert2Ascii(CHANDLE CP, SINT Index,
		MEMPTR lpData, SINT BufSize, SINT DataSize, BOOL AllowBinary);
#ifdef ICMDLL
SINT    MemCopy(MEMPTR Dest, MEMPTR Source, SINT Length);
DWORD   FAR  PASCAL crc32(MEMPTR buff, DWORD  length);
#endif
//SRGB98
BOOL    EXTERN InvertMatrix (double FAR * lpInMatrix, double FAR * lpOutMatrix);
BOOL    EXTERN MemAlloc(SINT Size, HGLOBAL FAR *hMemory, LPMEMPTR lpMH);
BOOL    EXTERN MemFree(HGLOBAL hMem);
DWORD FIXED_2DOT30(float);
DWORD FIXED_16DOT16(float);
BOOL   DoesTRCAndColorantTagExist(CHANDLE cp);
BOOL   GetTRCElementSize(CHANDLE cp, CSIG icSigXTRCTag, LPSINT pIndex, LPSINT pTRCSize);
#ifdef  __cplusplus
}
#endif

#endif  //  __SUPPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\dll32\generic.h ===
/**************************************************************************/
/*                                                                        */
/* GENERIC.H -- global include file for pscript driver                    */
/*                                                                        */
/**************************************************************************/
#include <windows.h>
#include <stdlib.h>
#include <time.h>
#include <dos.h>
#include <io.h>
#include <direct.h>
#include <limits.h>
#include <math.h>
#include <memory.h>
#include <commctrl.h>
#include <winerror.h>

#include "icmdll.h"
#include "icc.h"
#include "icm.h"
#include "icc_i386.h"
#include "csprof.h"
#include "getcrd.h"
#include "getcsa.h"
#include "icmstr.h"
#include "profcrd.h"

#define _ICMSEG  ""
#define _ICM2SEG ""
#define  ICMSEG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\dll32\dllmain.c ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   dllmain.c
//
//  PURPOSE:  Contains the DLL's entry point function.
//
//  FUNCTIONS:
//    DLLMain   - The entry point function
//

#include <windows.h>


//
//  FUNCTION: DLLMain(HINSTANCE, DWORD, LPVOID)
//
//  PURPOSE:  Called when DLL is loaded by a process, and when new
//    threads are created by a process that has already loaded the
//    DLL.  Also called when threads of a process that has loaded the
//    DLL exit cleanly and when the process itself unloads the DLL.
//
//  PARAMETERS:
//    hDLLInst    - Instance handle of the DLL
//    fdwReason   - Process attach/detach or thread attach/detach
//    lpvReserved - Reserved and not used
//
//  RETURN VALUE:  (Used only when fdwReason == DLL_PROCESS_ATTACH)
//    TRUE  -  Used to signify that the DLL should remain loaded.
//    FALSE -  Used to signify that the DLL should be immediately unloaded.
//
//  COMMENTS:
//
//    If you want to use C runtime libraries, keep this function named
//    "DllMain" and you won't have to do anything special to initialize
//    the runtime libraries.
//
//    When fdwReason == DLL_PROCESS_ATTACH, the return value is used to
//    determine if the DLL should remain loaded, or should be immediately
//    unloaded depending upon whether the DLL could be initialized properly.
//    For all other values of fdwReason, the return value is ignored.
//

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            // The DLL is being loaded for the first time by a given process.
            // Perform per-process initialization here.  If the initialization
            // is successful, return TRUE; if unsuccessful, return FALSE.

            break;

        case DLL_PROCESS_DETACH:
            // The DLL is being unloaded by a given process.  Do any
            // per-process clean up here, such as undoing what was done in
            // DLL_PROCESS_ATTACH.  The return value is ignored.

            break;

        case DLL_THREAD_ATTACH:
            // A thread is being created in a process that has already loaded
            // this DLL.  Perform any per-thread initialization here.  The
            // return value is ignored.

            break;

        case DLL_THREAD_DETACH:
            // A thread is exiting cleanly in a process that has already
            // loaded this DLL.  Perform any per-thread clean up here.  The
            // return value is ignored.

            break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\dll32\getcrd.c ===
#include "generic.h"
#include "stdio.h"
#pragma code_seg(_ICMSEG)

char ICMSEG BeginString[]       = "<";
char ICMSEG EndString[]         = ">";
char ICMSEG BeginArray[]        = "[";
char ICMSEG EndArray[]          = "]";
char ICMSEG BeginFunction[]     = "{";
char ICMSEG EndFunction[]       = "}bind ";
char ICMSEG BeginDict[]         = "<<" ;
char ICMSEG EndDict[]           = ">>" ;
char ICMSEG BlackPoint[]        = "[0 0 0]" ;
char ICMSEG DictType[]          = "/ColorRenderingType 1 ";
char ICMSEG IntentType[]        = "/RenderingIntent ";
char ICMSEG IntentPer[]         = "/Perceptual";
char ICMSEG IntentSat[]         = "/Saturation";
char ICMSEG IntentACol[]        = "/AbsoluteColorimetric";
char ICMSEG IntentRCol[]        = "/RelativeColorimetric";

char ICMSEG WhitePointTag[]     = "/WhitePoint " ;
char ICMSEG BlackPointTag[]     = "/BlackPoint " ;
char ICMSEG RangePQRTag[]       = "/RangePQR " ;
char ICMSEG TransformPQRTag[]   = "/TransformPQR " ;
char ICMSEG MatrixPQRTag[]      = "/MatrixPQR " ;

char ICMSEG RangeABCTag[]       = "/RangeABC " ;
char ICMSEG MatrixATag[]        = "/MatrixA ";
char ICMSEG MatrixABCTag[]      = "/MatrixABC ";
char ICMSEG EncodeABCTag[]      = "/EncodeABC " ;
char ICMSEG RangeLMNTag[]       = "/RangeLMN " ;
char ICMSEG MatrixLMNTag[]      = "/MatrixLMN " ;
char ICMSEG EncodeLMNTag[]      = "/EncodeLMN " ;
char ICMSEG RenderTableTag[]    = "/RenderTable " ;
char ICMSEG CIEBasedATag[]      = "/CIEBasedA " ;
char ICMSEG CIEBasedABCTag[]    = "/CIEBasedABC " ;
char ICMSEG CIEBasedDEFGTag[]   = "/CIEBasedDEFG " ;
char ICMSEG CIEBasedDEFTag[]    = "/CIEBasedDEF " ;
char ICMSEG DecodeATag[]        = "/DecodeA " ;
char ICMSEG DecodeABCTag[]      = "/DecodeABC " ;
char ICMSEG DecodeLMNTag[]      = "/DecodeLMN " ;
char ICMSEG DeviceRGBTag[]      = "/DeviceRGB " ;
char ICMSEG DeviceCMYKTag[]     = "/DeviceCMYK " ;
char ICMSEG DeviceGrayTag[]     = "/DeviceGray " ;
char ICMSEG TableTag[]          = "/Table " ;
char ICMSEG DecodeDEFGTag[]     = "/DecodeDEFG " ;
char ICMSEG DecodeDEFTag[]      = "/DecodeDEF " ;

char ICMSEG NullOp[]            = "";
char ICMSEG DupOp[]             = "dup ";
char ICMSEG UserDictOp[]        = "userdict ";
char ICMSEG GlobalDictOp[]      = "globaldict ";
char ICMSEG CurrentGlobalOp[]   = "currentglobal ";
char ICMSEG SetGlobalOp[]       = "setglobal ";
char ICMSEG DefOp[]             = "def ";
char ICMSEG BeginOp[]           = "begin ";
char ICMSEG EndOp[]             = "end ";
char ICMSEG TrueOp[]            = "true ";
char ICMSEG FalseOp[]           = "false ";
char ICMSEG MulOp[]             = "mul ";
char ICMSEG DivOp[]             = "div ";

char ICMSEG NewLine[]           = "\n" ;
char ICMSEG Slash[]             = "/" ;
char ICMSEG Space[]             = " " ;
char ICMSEG CRDBegin[]          = "%** CRD Begin ";
char ICMSEG CRDEnd[]            = "%** CRD End ";
char ICMSEG CieBasedDEFGBegin[] = "%** CieBasedDEFG CSA Begin ";
char ICMSEG CieBasedDEFBegin[]  = "%** CieBasedDEF CSA Begin ";
char ICMSEG CieBasedABCBegin[]  = "%** CieBasedABC CSA Begin ";
char ICMSEG CieBasedABegin[]    = "%** CieBasedA CSA Begin ";
char ICMSEG CieBasedDEFGEnd[]   = "%** CieBasedDEFG CSA End ";
char ICMSEG CieBasedDEFEnd[]    = "%** CieBasedDEF CSA End ";
char ICMSEG CieBasedABCEnd[]    = "%** CieBasedABC CSA End ";
char ICMSEG CieBasedAEnd[]      = "%** CieBasedA CSA End ";
char ICMSEG RangeABC[]          = "[ 0 1 0 1 0 1 ] ";
char ICMSEG RangeLMN[]          = "[ 0 2 0 2 0 2 ] ";
char ICMSEG Identity[]          = "[1 0 0 0 1 0 0 0 1]";
char ICMSEG RangeABC_Lab[]      = "[0 100 -128 127 -128 127]";

/********** This PostScript code clips incoming value between 0.0 and 1.0
   Use:   x <clip>   --   <clipped x>                                   */
char ICMSEG Clip01[]            = "dup 1.0 ge{pop 1.0}{dup 0.0 lt{pop 0.0}if}ifelse " ;
char ICMSEG DecodeA3[]          = "256 div exp ";
char ICMSEG DecodeA3Rev[]       = "256 div 1.0 exch div exp ";
char ICMSEG DecodeABCArray[]    = "DecodeABC_";
char ICMSEG InputArray[]        = "Inp_";
char ICMSEG OutputArray[]       = "Out_";
char ICMSEG PreViewInArray[]    = "IPV_";
char ICMSEG PreViewOutArray[]   = "OPV_";

char ICMSEG AdobeCSA[] = "[ /CIEBasedABC << /DecodeLMN [\n\
{dup 0.03928 le {12.92321 div}{0.055 add 1.055 div 2.4 exp}ifelse} bind dup dup ]\n\
/MatrixLMN [0.412457 0.212673 0.019334 0.357576 0.715152 0.119192 0.180437 0.072175 0.950301]\n\
/WhitePoint [ 0.9505 1 1.0890 ] >> ]";

char ICMSEG AdobeCRD[] = " /RangePQR [ -0.5 2 -0.5 2 -0.5 2 ]\n\
/MatrixPQR [0.8951 -0.7502  0.0389 0.2664  1.7135 -0.0685 -0.1614  0.0367  1.0296]\n\
/TransformPQR [{exch pop exch 3 get mul exch pop exch 3 get div} bind\n\
{exch pop exch 4 get mul exch pop exch 4 get div} bind\n\
{exch pop exch 5 get mul exch pop exch 5 get div} bind]\n\
/MatrixLMN [3.240449 -0.969265  0.055643 -1.537136  1.876011 -0.204026 -0.498531  0.041556  1.057229]\n\
/EncodeABC [{dup 0.00304 le {12.92321 mul}{1 2.4 div exp 1.055 mul 0.055 sub}ifelse} bind dup dup]\n\
/WhitePoint[0.9505 1 1.0890] >>";

// This PostScript segment takes value in range from 0.0 to 1.0 and
//  interpolates the result using array supplied.
//   x [array]  -- <interpolated value>

char ICMSEG IndexArray16b[]     = \
" dup length 1 sub 3 -1 roll mul dup dup floor cvi \
exch ceiling cvi 3 index exch get 32768 add 4 -1 roll 3 -1 roll get 32768 add \
dup 3 1 roll sub 3 -1 roll dup floor cvi sub mul add ";

char ICMSEG IndexArray[]        = \
" dup length 1 sub 3 -1 roll mul dup dup floor cvi \
exch ceiling cvi 3 index exch get 4 -1 roll 3 -1 roll get \
dup 3 1 roll sub 3 -1 roll dup floor cvi sub mul add ";

char ICMSEG TestingDEFG[]       = \
"/SupportDEFG? {/CIEBasedDEFG /ColorSpaceFamily resourcestatus { pop pop languagelevel 3 ge}{false} ifelse} def";

char ICMSEG SupportDEFG_S[]     = "SupportDEFG? { ";
char ICMSEG NotSupportDEFG_S[]  = "SupportDEFG? not { ";
char ICMSEG SupportDEFG_E[]     = "}if ";

char ICMSEG StartClip[]         = "dup 1.0 le{dup 0.0 ge{" ;
char ICMSEG EndClip[]           = "}if}if " ;

char ICMSEG Scale8[]            = "255 div " ;
char ICMSEG Scale16[]           = "65535 div " ;
char ICMSEG Scale16XYZ[]        = "32768 div " ;
char ICMSEG TFunction8[]        = "exch 255 mul round cvi get 255 div " ;
char ICMSEG TFunction8XYZ[]     = "exch 255 mul round cvi get 128 div " ;
char ICMSEG MatrixABCLab[]      = "[1 1 1 1 0 0 0 0 -1]" ;
char ICMSEG DecodeABCLab1[]     = "[{16 add 116 div} bind {500 div} bind {200 div} bind]";
char ICMSEG DecodeALab[]        = " 50 mul 16 add 116 div ";
char ICMSEG DecodeLMNLab[]      = \
"dup 0.206897 ge{dup dup mul mul}{0.137931 sub 0.128419 mul} ifelse ";

char ICMSEG RangeLMNLab[]       = "[0 1 0 1 0 1]" ;
char ICMSEG EncodeLMNLab[]      = "\
dup 0.008856 le{7.787 mul 0.13793 add}{0.3333 exp}ifelse " ;

char ICMSEG MatrixABCLabCRD[]   = "[0 500 0 116 -500 200 0 0 -200]" ;
char ICMSEG MatrixABCXYZCRD[]   = "[0 1 0 1 0 0 0 0 1]" ;
char ICMSEG EncodeABCLab1[]     = "16 sub 100 div " ;
char ICMSEG EncodeABCLab2[]     = "128 add 255 div " ;

char ICMSEG   RangePQR[]          = "[ -0.07 2.2 -0.02 1.4 -0.2 4.8 ]";
char ICMSEG   MatrixPQR[]         = "[0.8951 -0.7502 0.0389 0.2664 1.7135 -0.0685 -0.1614 0.0367 1.0296]";

char *TransformPQR[3]             = {
"exch pop exch 3 get mul exch pop exch 3 get div ",
"exch pop exch 4 get mul exch pop exch 4 get div ",
"exch pop exch 5 get mul exch pop exch 5 get div " };

#define SRGBCRC 0x678175D2L

#pragma optimize("",off)

/***************************************************************************
*                               CreateLutCRD
*  function:
*    this is the function which creates the Color Rendering Dictionary (CRD)
*    from the data supplied in the ColorProfile's LUT8 or LUT16 tag.
*  prototype:
*       SINT EXTERN CreateLutCRD(
*                          CHANDLE      cp,
*                          SINT         Index,
*                          MEMPTR       lpMem,
*                          BOOL         AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       Index       --  Index of the tag
*       lpMem       --  Pointer to the memory block
*       AllowBinary --  1: binary CRD allowed,  0: only ascii CRD allowed.
*
*  returns:
*       SINT        --  !=0 if the function was successful,
*                         0 otherwise.
*                       Returns number of bytes required/transferred
***************************************************************************/

SINT EXTERN 
CreateLutCRD (CHANDLE cp, SINT Index, MEMPTR lpMem, DWORD InputIntent, BOOL AllowBinary)
{
    SINT nInputCh, nOutputCh, nGrids;
    SINT nInputTable, nOutputTable, nNumbers;
    CSIG Tag, PCS;
    CSIG IntentSig;

    SINT Ret;
    SINT i, j;
    MEMPTR lpTable;

    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];
    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem = lpMem;
    char PublicArrayName[TempBfSize];
    HGLOBAL hMem;
    MEMPTR lpLineStart;
 // Check if we can generate the CRD
    if (!GetCPTagSig (cp, Index, (LPCSIG) & IntentSig) ||
        !GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        ((Tag != icSigLut8Type) && (Tag != icSigLut16Type)) ||
        !GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) & Buff) ||
        !GetCPElement (cp, Index, Buff, MemSize))
    {
        if (NULL != Buff)
        {
            MemFree (hMem);
        }
        return (0);
    }
    GetCLUTinfo(Tag, Buff, &nInputCh, &nOutputCh, 
        &nGrids, &nInputTable, &nOutputTable, &i);
 // Level 2 printers support only tri-component CIEBasedABC input,
 // but can have either 3 or 4 output channels.
    if (((nOutputCh != 3) &&
         (nOutputCh != 4)) ||
        (nInputCh != 3))
    {
        SetCPLastError (CP_POSTSCRIPT_ERR);
        MemFree (hMem);
        return (0);
    }
    Ret = nInputCh * nInputTable * 6 +
        nOutputCh * nOutputTable * 6 +  // Number of INT bytes
        nOutputCh * nGrids * nGrids * nGrids * 2 +  // LUT HEX bytes
        nInputCh * (lstrlen (IndexArray) +
                    lstrlen (StartClip) +
                    lstrlen (EndClip)) +
        nOutputCh * (lstrlen (IndexArray) +
                     lstrlen (StartClip) +
                     lstrlen (EndClip)) +
        2048;                           // + other PS stuff

    if (lpMem == NULL)                  // This is a size request
    {
        MemFree (hMem);
        return (Ret);
    }
//  Get all necessary params from the header
//  GetCPRenderIntent (cp, (LPCSIG) & Intent);  // Get Intent
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant

 // Support absolute whitePoint
    if (InputIntent == icAbsoluteColorimetric)
    {
        if (!GetCPMediaWhitePoint (cp, (LPSFLOAT) & MediaWP)) // .. Media WhitePoint
        {
            MediaWP[0] = IlluminantWP[0];
            MediaWP[1] = IlluminantWP[1];
            MediaWP[2] = IlluminantWP[2];
        }
    }

//******** Define golbal array used in EncodeABC and RenderTaber
    GetPublicArrayName (cp, IntentSig, PublicArrayName);
    lpMem += WriteNewLineObject (lpMem, CRDBegin);

    lpMem += EnableGlobalDict(lpMem);
    lpMem += BeginGlobalDict(lpMem);

    lpMem += CreateInputArray (lpMem, nInputCh, nInputTable,
             (MEMPTR) PublicArrayName, Tag, Buff, AllowBinary, NULL);

    i = nInputTable * nInputCh +
        nGrids * nGrids * nGrids * nOutputCh;
    lpMem += CreateOutputArray (lpMem, nOutputCh, nOutputTable, i,
             (MEMPTR) PublicArrayName, Tag, Buff, AllowBinary, NULL);

    lpMem += EndGlobalDict(lpMem);

//************* Start writing  CRD  ****************************
    lpMem += WriteNewLineObject (lpMem, BeginDict);    // Begin dictionary
    lpMem += WriteObject (lpMem, DictType); // Dictionary type
    
    lpMem += WriteNewLineObject (lpMem, IntentType); // RenderingIntent
    switch (InputIntent)
    {
        case icPerceptual:
            lpMem += WriteObject (lpMem, IntentPer);
            break;

        case icSaturation:
            lpMem += WriteObject (lpMem, IntentSat);
            break;

        case icRelativeColorimetric:
            lpMem += WriteObject (lpMem, IntentRCol);
            break;

        case icAbsoluteColorimetric:
            lpMem += WriteObject (lpMem, IntentACol);
            break;
    }
    
 //********** Send Black/White Point.
    lpMem += SendCRDBWPoint(lpMem, IlluminantWP);

 //********** Send PQR - used for Absolute Colorimetric *****
    lpMem += SendCRDPQR(lpMem, InputIntent, IlluminantWP);

 //********** Send LMN - For Absolute Colorimetric use WhitePoint's XYZs
    lpMem += SendCRDLMN(lpMem, InputIntent, IlluminantWP, MediaWP, PCS);

 // ******** Create MatrixABC and  EncodeABC  stuff
    lpMem += SendCRDABC(lpMem, PublicArrayName, 
        PCS, nInputCh, Buff, NULL, Tag, AllowBinary);

 //********** /RenderTable
    lpMem += WriteNewLineObject (lpMem, RenderTableTag);
    lpMem += WriteObject (lpMem, BeginArray);

    lpMem += WriteInt (lpMem, nGrids);  // Send down Na
    lpMem += WriteInt (lpMem, nGrids);  // Send down Nb
    lpMem += WriteInt (lpMem, nGrids);  // Send down Nc

    lpLineStart = lpMem;
    lpMem += WriteNewLineObject (lpMem, BeginArray);
    nNumbers = nGrids * nGrids * nOutputCh;
    for (i = 0; i < nGrids; i++)        // Na strings should be sent
    {
        lpMem += WriteObject (lpMem, NewLine);
        lpLineStart = lpMem;
        if (Tag == icSigLut8Type)
        {
            lpTable = (MEMPTR) (((lpcpLut8Type) Buff)->lut.data) +
                nInputTable * nInputCh +
                nNumbers * i;
        } else
        {
            lpTable = (MEMPTR) (((lpcpLut16Type) Buff)->lut.data) +
                2 * nInputTable * nInputCh +
                2 * nNumbers * i;
        }
        if (!AllowBinary)               // Output ASCII CRD
        {
            lpMem += WriteObject (lpMem, BeginString);
            if (Tag == icSigLut8Type)
                lpMem += WriteHexBuffer (lpMem, lpTable, lpLineStart, nNumbers);
            else
            {
                for (j = 0; j < nNumbers; j++)
                {
                    lpMem += WriteHex (lpMem, ui16toSINT (lpTable) / 256);
                    lpTable += sizeof (icUInt16Number);
                    if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                    {
                        lpLineStart = lpMem;
                        lpMem += WriteObject (lpMem, NewLine);
                    }
                }
            }
            lpMem += WriteObject (lpMem, EndString);
        } else
        {                               // Output BINARY CRD
            lpMem += WriteStringToken (lpMem, 143, nNumbers);
            if (Tag == icSigLut8Type)
                lpMem += WriteByteString (lpMem, lpTable, nNumbers);
            else
                lpMem += WriteInt2ByteString (lpMem, lpTable, nNumbers);
        }
    }

    lpMem += WriteObject (lpMem, EndArray); // End array
    lpMem += WriteInt (lpMem, nOutputCh);   // Send down m

 //********** Send Output Table.
    lpMem += SendCRDOutputTable(lpMem, PublicArrayName, 
        nOutputCh, Tag, FALSE, AllowBinary);

    lpMem += WriteObject (lpMem, EndArray); // End array
    lpMem += WriteObject (lpMem, EndDict);  // End dictionary definition

    lpMem += WriteNewLineObject (lpMem, CRDEnd);

// Testing Convert binary to ascii
//    i = ConvertBinaryData2Ascii(lpOldMem, (SINT)(lpMem - lpOldMem), Ret);
//    lpMem = lpOldMem + i;
// Testing Convert binary to ascii

    MemFree (hMem);
    return ((SINT) ((unsigned long) (lpMem - lpOldMem)));
}
/***************************************************************************
*                               GetRevCurve
*  function:
*  prototype:
*       BOOL  GetRevCurve(
*                          MEMPTR       Buff,
*                          MEMPTR       lpRevCurve)
*  parameters:
*       Buff        --
*       lpRevCurve  --
*  returns:
*       BOOL        --  TRUE:  successful,
*                       FALSE: otherwise.
***************************************************************************/

BOOL
GetRevCurve (MEMPTR lpBuff, MEMPTR lpCurve, MEMPTR lpRevCurve)
{
    SINT i, j, nCount;
    MEMPTR lpTable;
    PUSHORT lpInput, lpOutput;
    SFLOAT fTemp;
    SINT iBegin, iEnd, iTemp;
    nCount = ui32toSINT (((lpcpCurveType) lpBuff)->curve.count);
    lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
    lpOutput = (PUSHORT) lpRevCurve;
    lpInput = (PUSHORT) lpCurve;

    for (i = 0; i < nCount; i++)
    {
        lpInput[i] = (USHORT) (ui16toSINT (lpTable));
        lpTable += sizeof (icUInt16Number);
    }

    j = nCount * REVCURVE_RATIO;
    for (i = 0; i < j; i++)
    {
        fTemp = (SFLOAT) i *65535 / (j - 1);
        lpOutput[i] = (fTemp < 65535) ? (USHORT) fTemp : (USHORT) 65535;
    }

    for (i = 0; i < j; i++)
    {
        iBegin = 0;
        iEnd = nCount - 1;
        for (;;)
        {
            if ((iEnd - iBegin) <= 1)
                break;
            iTemp = (iEnd + iBegin) / 2;
            if (lpOutput[i] < lpInput[iTemp])
                iEnd = iTemp;
            else
                iBegin = iTemp;
        }
        if (lpOutput[i] <= lpInput[iBegin])
            fTemp = (SFLOAT) iBegin;
        else if (lpOutput[i] >= lpInput[iEnd])
            fTemp = (SFLOAT) iEnd;
        else
        {
            fTemp = ((SFLOAT) (lpInput[iEnd] - lpOutput[i])) /
                (lpOutput[i] - lpInput[iBegin]);
            fTemp = (iBegin * fTemp + iEnd) / (fTemp + 1);
        }
        fTemp = (fTemp / (nCount - 1)) * 65535;
        lpOutput[i] = (fTemp < 65535) ? (USHORT) fTemp : (USHORT) 65535;
    }

    return TRUE;
}
/***************************************************************************
*                               CreateMonoCRD
*  function:
*    this is the function which creates the Color Rendering Dictionary (CRD)
*    from the data supplied in the GrayTRC tag.
*  prototype:
*       BOOL EXTERN CreateMonoCRD(
*                          CHANDLE      cp,
*                          SINT         Index,
*                          MEMPTR       lpMem)
*  parameters:
*       cp          --  Color Profile handle
*       Index       --  Index of the tag
*       lpMem       --  Pointer to the memory block
*  returns:
*       SINT        --  !=0 if the function was successful,
*                         0 otherwise.
*                       Returns number of bytes required/transferred
***************************************************************************/
//  According to the spec this tag-based function only converts from
//  Device to PCS, so we need to create an inverse function to perform
//  PCS->device conversion. By definition the CRD is only
//  for XYZ->DeviceRGB/CMYK conversion.
SINT EXTERN 
CreateMonoCRD (CHANDLE cp, SINT Index, MEMPTR lpMem, DWORD InputIntent)
{
    SINT nCount;
    CSIG Tag, PCS;

    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem = lpMem;
    MEMPTR lpCurve, lpRevCurve;
    HGLOBAL hRevCurve;
    SINT Ret = 0;
    HGLOBAL hMem;
    SINT i;
    MEMPTR lpTable;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];
    MEMPTR lpLineStart;
 // Check if we can generate the CRD
    if (!GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        (Tag != icSigCurveType) ||
        !GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) & Buff) ||
        !GetCPElement (cp, Index, Buff, MemSize))
    {
        if (NULL != Buff)
        {
            MemFree (hMem);
        }
        return (0);
    }
    nCount = ui32toSINT (((lpcpCurveType) Buff)->curve.count);

 // Estimate the memory size required to hold CRD
 // SRGB98
    Ret = nCount * 6 * REVCURVE_RATIO + // Number of INT elements
        2048;                           // + other PS stuff
    if (lpMem == NULL)                  // This is a size request
    {
        MemFree (hMem);
        return (Ret);
    }
    if (!MemAlloc (nCount * 2 * (REVCURVE_RATIO + 1),
                   (HGLOBAL FAR *) &hRevCurve, (LPMEMPTR) & lpRevCurve))
    {
        MemFree (hMem);
        return (FALSE);
    }
    lpCurve = lpRevCurve + 2 * REVCURVE_RATIO * nCount;
    GetRevCurve (Buff, lpCurve, lpRevCurve);

 //   GetCPCMMType (cp, (LPCSIG) & Intent);   // Get Intent
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant

 // Support absolute whitePoint
    if (InputIntent == icAbsoluteColorimetric)
    {
        if (!GetCPMediaWhitePoint (cp, (LPSFLOAT) & MediaWP)) // .. Media WhitePoint
        {
            MediaWP[0] = IlluminantWP[0];
            MediaWP[1] = IlluminantWP[1];
            MediaWP[2] = IlluminantWP[2];
        }
    }

//************* Start writing  CRD  ****************************
    lpMem += WriteNewLineObject (lpMem, BeginDict);    // Begin dictionary
    lpMem += WriteObject (lpMem, DictType); // Dictionary type

    lpMem += WriteNewLineObject (lpMem, IntentType); // RenderingIntent
    switch (InputIntent)
    {
        case icPerceptual:
            lpMem += WriteObject (lpMem, IntentPer);
            break;

        case icSaturation:
            lpMem += WriteObject (lpMem, IntentSat);
            break;
        
        case icRelativeColorimetric:
            lpMem += WriteObject (lpMem, IntentRCol);
            break;
        
        case icAbsoluteColorimetric:
            lpMem += WriteObject (lpMem, IntentACol);
            break;
    }
    
 //********** Send Black/White Point.
    lpMem += SendCRDBWPoint(lpMem, IlluminantWP);

 //********** /TransformPQR
    lpMem += SendCRDPQR(lpMem, InputIntent, IlluminantWP);

 //********** /MatrixLMN
    lpMem += SendCRDLMN(lpMem, InputIntent, IlluminantWP, MediaWP, PCS);

 //********** /MatrixABC
    if (PCS == icSigXYZData)
    {   // Switch ABC to BAC, since we want to output B which is converted from Y.
        lpMem += WriteNewLineObject (lpMem, MatrixABCTag);
        lpMem += WriteObject (lpMem, MatrixABCXYZCRD);
    }
    else if (PCS == icSigLabData)
    {
        lpMem += WriteNewLineObject (lpMem, MatrixABCTag);
        lpMem += WriteObject (lpMem, MatrixABCLabCRD);
    }
 //********** /EncodeABC
    if (nCount != 0)
    {
        lpMem += WriteObject (lpMem, NewLine);
        lpLineStart = lpMem;
        lpMem += WriteObject (lpMem, EncodeABCTag);
        lpMem += WriteObject (lpMem, BeginArray);
        lpMem += WriteObject (lpMem, BeginFunction);
        if (nCount == 1)                // Gamma supplied in ui16 format
        {
            lpTable = (MEMPTR) (((lpcpCurveType) Buff)->curve.data);
            lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
            lpMem += WriteObject (lpMem, DecodeA3Rev);
        } else
        {
            if (PCS == icSigLabData)
            {
                lpMem += WriteObject (lpMem, EncodeABCLab1);
            }
            lpMem += WriteObject (lpMem, StartClip);
            lpMem += WriteObject (lpMem, BeginArray);
            for (i = 0; i < nCount * REVCURVE_RATIO; i++)
            {
                lpMem += WriteInt (lpMem, (SINT) (*((PUSHORT) lpRevCurve)));
                lpRevCurve += sizeof (icUInt16Number);
                if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                {
                    lpLineStart = lpMem;
                    lpMem += WriteObject (lpMem, NewLine);
                }
            }
            lpMem += WriteObject (lpMem, EndArray);
            lpLineStart = lpMem;
            lpMem += WriteNewLineObject (lpMem, IndexArray);
            lpMem += WriteObject (lpMem, Scale16);
            lpMem += WriteObject (lpMem, EndClip);
        }
        lpMem += WriteObject (lpMem, EndFunction);
        lpMem += WriteObject (lpMem, DupOp);
        lpMem += WriteObject (lpMem, DupOp);
        lpMem += WriteObject (lpMem, EndArray);
    }
    lpMem += WriteObject (lpMem, EndDict);  // End dictionary definition

    MemFree (hRevCurve);
    MemFree (hMem);
    return ((SINT) ((unsigned long) (lpMem - lpOldMem)));
}

// SRGB98 start
BOOL
GetTRCElementSize(CHANDLE cp, CSIG icSigXTRCTag, LPSINT pIndex, LPSINT pTRCSize)
{
    CSIG Tag;

    if (!GetCPTagIndex (cp, icSigXTRCTag, (LPSINT) pIndex) ||
        !GetCPElementType (cp, *pIndex, (LPCSIG) & Tag) ||
        !(Tag == icSigCurveType) ||
        !GetCPElementSize (cp, *pIndex, (LPSINT) pTRCSize))
    {
        return FALSE;
    }
    return TRUE;
}

BOOL
DoesTRCAndColorantTagExist (CHANDLE cp)
{
    if (DoesCPTagExist (cp, icSigRedColorantTag) &&
        DoesCPTagExist (cp, icSigRedTRCTag ) &&
        DoesCPTagExist (cp, icSigGreenColorantTag) &&
        DoesCPTagExist (cp, icSigGreenTRCTag ) &&
        DoesCPTagExist (cp, icSigBlueColorantTag) &&
        DoesCPTagExist (cp, icSigBlueTRCTag ))
    {
        return TRUE;
    }

    return FALSE;
}

static SINT 
CreateRevArray (CHANDLE cp, MEMPTR lpMem, MEMPTR lpBuff, 
                MEMPTR lpRevCurve, CSIG CPTag, BOOL AllowBinary)
{
    SINT i, nCount;
    SINT MemSize = 0;
    MEMPTR lpOldMem, lpLineStart;
    MEMPTR lpCurve;

    lpOldMem = lpMem;

    lpLineStart = lpMem;
    nCount = ui32toSINT (((lpcpCurveType) lpBuff)->curve.count);
    if (nCount > 1)
    {
        lpMem += WriteNewLineObject (lpMem, Slash);
        lpMem += WriteObject (lpMem, InputArray);
        lpMem += WriteInt (lpMem, (SINT) CPTag);

        lpCurve = lpRevCurve + 2 * REVCURVE_RATIO * nCount;
        GetRevCurve (lpBuff, lpCurve, lpRevCurve);

        if (!AllowBinary)           // Output ASCII DATA
        {
            lpMem += WriteObject (lpMem, BeginArray);
            for (i = 0; i < nCount * REVCURVE_RATIO; i++)
            {
                lpMem += WriteInt (lpMem, (SINT) (*((PUSHORT) lpRevCurve)));
                lpRevCurve += sizeof (icUInt16Number);
                if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                {
                    lpLineStart = lpMem;
                    lpMem += WriteObject (lpMem, NewLine);
                }
            }
            lpMem += WriteObject (lpMem, EndArray);
        } else
        {                           // Output BINARY DATA
            lpMem += WriteHNAToken (lpMem, 149, nCount);
            lpMem += WriteIntStringU2S_L (lpMem, lpRevCurve, nCount);
        }
    }
    lpMem += WriteObject (lpMem, DefOp);
    return ((SINT) (lpMem - lpOldMem));
}

static SINT 
SendRevArray (CHANDLE cp, MEMPTR lpMem, MEMPTR lpBuff, 
              CSIG CPTag, BOOL AllowBinary)
{
    SINT nCount;
    MEMPTR lpOldMem;
    MEMPTR lpTable;

    lpOldMem = lpMem;
    lpMem += WriteObject (lpMem, BeginFunction);
    nCount = ui32toSINT (((lpcpCurveType) lpBuff)->curve.count);
    if (nCount != 0)
    {
        if (nCount == 1)            // Gamma supplied in ui16 format
        {
            lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
            lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
            lpMem += WriteObject (lpMem, DecodeA3Rev);
        } else
        {
            lpMem += WriteObject (lpMem, StartClip);
            lpMem += WriteObject (lpMem, InputArray);
            lpMem += WriteInt (lpMem, (SINT) CPTag);

            if (!AllowBinary)       // Output ASCII CS
            {
                lpMem += WriteObject (lpMem, IndexArray);
            } else
            {                       // Output BINARY CS
                lpMem += WriteObject (lpMem, IndexArray16b);
            }
            lpMem += WriteObject (lpMem, Scale16);
            lpMem += WriteObject (lpMem, EndClip);
        }
    }
    lpMem += WriteObject (lpMem, EndFunction);
    return ((SINT) (lpMem - lpOldMem));
}

SINT 
CreateColorantArray(CHANDLE cp, double FAR *lpArray, CSIG CPTag)
{
    SINT i, Index;
    MEMPTR lpTable;
    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    HGLOBAL hBuff;

    if (GetCPTagIndex (cp, CPTag, (LPSINT) & Index) &&
        GetCPElementSize (cp, Index, (LPSINT) & MemSize) &&
        MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & Buff) &&
        GetCPElement (cp, Index, Buff, MemSize))
    {
        lpTable = (MEMPTR) & (((lpcpXYZType) Buff)->data);
        for (i = 0; i < 3; i++)
        {
            *lpArray++ = (SFLOAT)si16f16toSFLOAT (lpTable);
            lpTable += sizeof (icS15Fixed16Number);
        }
        MemFree (hBuff);
    }
    return ( TRUE );
}  


/***************************************************************************
*                           IsSRGB
*  function: check if the profile is sRGB
*
*  parameters:
*       cp          --  Color Profile handle
*
*  returns:
*       BOOL        --  TRUE if the profile is sRGB
*                       FALSE otherwise.
***************************************************************************/
BOOL FAR IsSRGB (CHANDLE cp)
{   
    BOOL    match = FALSE;
    SINT    RedTRCIndex, GreenTRCIndex, BlueTRCIndex, RedCIndex, GreenCIndex, BlueCIndex;
    SINT    MemSize;
    SINT    RedTRCSize=0, GreenTRCSize=0, BlueTRCSize=0, RedCSize=0, GreenCSize=0, BlueCSize=0;
    HGLOBAL hMem;
    MEMPTR  lpRed = NULL,lpGreen, lpBlue, lpRedC, lpGreenC, lpBlueC;
    DWORD   crc;

    if (GetCPTagIndex (cp, icSigRedTRCTag, &RedTRCIndex) &&
        GetCPElementSize (cp, RedTRCIndex, &RedTRCSize)  &&
            
        GetCPTagIndex (cp, icSigGreenTRCTag, &GreenTRCIndex) &&
        GetCPElementSize (cp, GreenTRCIndex, &GreenTRCSize)  &&
            
        GetCPTagIndex (cp, icSigBlueTRCTag, &BlueTRCIndex) &&
        GetCPElementSize (cp, BlueTRCIndex, &BlueTRCSize) && 
            
        GetCPTagIndex (cp, icSigRedColorantTag, &RedCIndex) &&
        GetCPElementSize (cp, RedCIndex, &RedCSize)  &&
            
        GetCPTagIndex (cp, icSigGreenColorantTag, &GreenCIndex) &&
        GetCPElementSize (cp, GreenCIndex, &GreenCSize)  &&
            
        GetCPTagIndex (cp, icSigBlueColorantTag, &BlueCIndex) &&
        GetCPElementSize (cp, BlueCIndex, &BlueCSize) )
    {
        MemSize = RedTRCSize + GreenTRCSize + BlueTRCSize + RedCSize + GreenCSize + BlueCSize;

        if ( (MemSize == 6240) && // #bytes in sRGBColorTags
             MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR)&lpRed) )
        {
            lpGreen = lpRed + RedTRCSize;
            lpBlue = lpGreen + GreenTRCSize;
            lpRedC = lpBlue + BlueTRCSize;
            lpGreenC = lpRedC + RedCSize;
            lpBlueC = lpGreenC + GreenCSize;
            
            if (GetCPElement (cp, RedTRCIndex, lpRed, RedTRCSize) &&
                GetCPElement (cp, GreenTRCIndex, lpGreen, GreenTRCSize ) &&
                GetCPElement (cp, BlueTRCIndex, lpBlue, BlueTRCSize ) &&
                GetCPElement (cp, RedCIndex, lpRedC, RedCSize) &&
                GetCPElement (cp, GreenCIndex, lpGreenC, GreenCSize ) &&
                GetCPElement (cp, BlueCIndex, lpBlueC, BlueCSize ))
            {   
                crc = crc32( lpRed, 6240 );    
                match = (crc == SRGBCRC);
            }
            MemFree(hMem);
        }    
    }            
    return (match);
}

/***************************************************************************
*                           CreateMatrixCRD
*  function:
*    this is the function which creates the Color Rendering Dictionary (CRD)
*    from the data supplied in the redTRC, greenTRC, blueTRA, redColorant,
*    greenColorant and BlueColorant tags
*  prototype:
*       BOOL EXTERN CreateMatrixCRD(
*                          CHANDLE      cp,
*                          MEMPTR       lpMem,
*                          BOOL         AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block
*       AllowBinary --
*  returns:
*       SINT        --  !=0 if the function was successful,
*                         0 otherwise.
*                       Returns number of bytes required/transferred
***************************************************************************/
// With matrix/TRC model, only the CIEXYZ encoding of the PCS can be used.
// So, we don't need to worry about CIELAB.
SINT EXTERN 
CreateMatrixCRD (CHANDLE cp, MEMPTR lpMem, DWORD InputIntent, BOOL AllowBinary)
{
    SINT RedTRCIndex, GreenTRCIndex, BlueTRCIndex;
    SINT i, MemSize;
    SINT nRedCount, nGreenCount, nBlueCount;
    MEMPTR lpRed = NULL,lpGreen, lpBlue;
    SINT RedTRCSize = 0, GreenTRCSize = 0, BlueTRCSize = 0;
    MEMPTR lpOldMem = lpMem;
    MEMPTR lpRevCurve;
    HGLOBAL hRevCurve;
    SINT Ret = 0;
    HGLOBAL hMem;
    SFLOAT IlluminantWP[3];
    double Colorant[9];
    double RevColorant[9];
 
 // Check if we can generate the CRD
    if (!GetTRCElementSize(cp, icSigRedTRCTag, &RedTRCIndex, &RedTRCSize) ||
        !GetTRCElementSize(cp, icSigGreenTRCTag, &GreenTRCIndex, &GreenTRCSize) ||
        !GetTRCElementSize(cp, icSigBlueTRCTag, &BlueTRCIndex, &BlueTRCSize))
    {
        return 0;
    }
    MemSize = RedTRCSize + GreenTRCSize + BlueTRCSize;
    if (!MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) & lpRed))
        return 0;

    lpGreen = lpRed + RedTRCSize;
    lpBlue = lpGreen + GreenTRCSize;
    if (!GetCPElement (cp, RedTRCIndex, lpRed, RedTRCSize) ||
        !GetCPElement (cp, GreenTRCIndex, lpGreen, GreenTRCSize ) ||
        !GetCPElement (cp, BlueTRCIndex, lpBlue, BlueTRCSize ))
    {
        MemFree (hMem);
        return (0);
    }
    nRedCount = ui32toSINT (((lpcpCurveType) lpRed)->curve.count);
    nGreenCount = ui32toSINT (((lpcpCurveType) lpGreen)->curve.count);
    nBlueCount = ui32toSINT (((lpcpCurveType) lpBlue)->curve.count);

 // Estimate the memory size required to hold CRD
    Ret = (nRedCount + nGreenCount + nBlueCount) * 6 * REVCURVE_RATIO + 
        2048;                // Number of INT elements + other PS stuff
    if (lpMem == NULL)       // This is a size request
    {
        MemFree (hMem);
        return (Ret);
    }

    if (!MemAlloc (nRedCount * 2 * (REVCURVE_RATIO + 1),
                  (HGLOBAL FAR *) &hRevCurve, (LPMEMPTR) & lpRevCurve))
    {
        MemFree (hMem);
        return (0);
    }

    if (IsSRGB(cp))
    {
       lpMem += WriteNewLineObject (lpMem, CRDBegin);
       lpMem += WriteNewLineObject (lpMem, BeginDict);    // Begin dictionary
       lpMem += WriteObject (lpMem, DictType); // Dictionary type
       lpMem += WriteNewLineObject (lpMem, IntentType); // RenderingIntent
       switch (InputIntent)
       {
           case icPerceptual:
               lpMem += WriteObject (lpMem, IntentPer);
               break;

           case icSaturation:
               lpMem += WriteObject (lpMem, IntentSat);
               break;
        
           case icRelativeColorimetric:
               lpMem += WriteObject (lpMem, IntentRCol);
               break;
        
           case icAbsoluteColorimetric:
               lpMem += WriteObject (lpMem, IntentACol);
               break;
       }
       lpMem += WriteNewLineObject (lpMem, AdobeCRD);
       lpMem += WriteNewLineObject (lpMem, CRDEnd);
    }
    else
    {
       lpMem += EnableGlobalDict(lpMem);
       lpMem += BeginGlobalDict(lpMem);
       
       lpMem += CreateRevArray (cp, lpMem, lpRed, lpRevCurve, icSigRedTRCTag, AllowBinary);
       lpMem += CreateRevArray (cp, lpMem, lpGreen, lpRevCurve, icSigGreenTRCTag, AllowBinary);
       lpMem += CreateRevArray (cp, lpMem, lpBlue, lpRevCurve, icSigBlueTRCTag, AllowBinary);
   
       lpMem += EndGlobalDict(lpMem);
   
    //   GetCPCMMType (cp, (LPCSIG) & Intent);   // Get Intent
       GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant
   
    //************* Start writing  CRD  ****************************
       lpMem += WriteNewLineObject (lpMem, CRDBegin);
   
       lpMem += WriteNewLineObject (lpMem, BeginDict);    // Begin dictionary
       lpMem += WriteObject (lpMem, DictType); // Dictionary type
                            
       lpMem += WriteNewLineObject (lpMem, IntentType); // RenderingIntent
       switch (InputIntent)
       {
           case icPerceptual:
               lpMem += WriteObject (lpMem, IntentPer);
               break;

           case icSaturation:
               lpMem += WriteObject (lpMem, IntentSat);
               break;
        
           case icRelativeColorimetric:
               lpMem += WriteObject (lpMem, IntentRCol);
               break;
        
           case icAbsoluteColorimetric:
               lpMem += WriteObject (lpMem, IntentACol);
               break;
       }
                     
    //********** Send Black/White Point.
       lpMem += SendCRDBWPoint(lpMem, IlluminantWP);
   
    //********** /TransformPQR
       lpMem += SendCRDPQR(lpMem, InputIntent, IlluminantWP);
   
    //********** /MatrixLMN
       CreateColorantArray(cp, &Colorant[0], icSigRedColorantTag);
       CreateColorantArray(cp, &Colorant[3], icSigGreenColorantTag);
       CreateColorantArray(cp, &Colorant[6], icSigBlueColorantTag);
       InvertMatrix (Colorant, RevColorant);
   
       lpMem += WriteNewLineObject (lpMem, MatrixLMNTag);
   
       lpMem += WriteObject (lpMem, BeginArray);
       for (i = 0; i < 9; i++)
       {
           lpMem += WriteFloat (lpMem, (SFLOAT)RevColorant[i]);
       }
       lpMem += WriteObject (lpMem, EndArray);
   
    //********** /EncodeABC
       lpMem += WriteNewLineObject (lpMem, EncodeABCTag);
       lpMem += WriteObject (lpMem, BeginArray);
   
       lpMem += WriteObject (lpMem, NewLine);
       lpMem += SendRevArray (cp, lpMem, lpRed, icSigRedTRCTag, AllowBinary);
       lpMem += WriteObject (lpMem, NewLine);
       lpMem += SendRevArray (cp, lpMem, lpGreen, icSigGreenTRCTag, AllowBinary);
       lpMem += WriteObject (lpMem, NewLine);
       lpMem += SendRevArray (cp, lpMem, lpBlue, icSigBlueTRCTag, AllowBinary);
       lpMem += WriteNewLineObject (lpMem, EndArray);
   
       lpMem += WriteObject (lpMem, EndDict);  // End dictionary definition
   
       lpMem += WriteNewLineObject (lpMem, CRDEnd);
    }
    MemFree (hRevCurve);
    MemFree (hMem);
    return ((SINT) ((unsigned long) (lpMem - lpOldMem)));
}
// SRGB98 End

BOOL EXTERN
GetPS2ColorRenderingDictionary (
                                CHANDLE cp,
                                DWORD Intent,
                                MEMPTR lpMem,
                                LPDWORD lpcbSize,
                                BOOL AllowBinary)
{
    SINT Index;
    SINT Ret, Size;
    CSIG icSigPs2CRDx, icSigBToAx;

    if (!cp)
        return FALSE;

    if ((lpMem == NULL) || (*lpcbSize == 0))
    {
        lpMem = NULL;
        *lpcbSize = 0;
    }
    Ret = 0;
    Size = (SINT) * lpcbSize;

    switch (Intent)
    {
        case icPerceptual:
            icSigPs2CRDx = icSigPs2CRD0Tag;
            icSigBToAx = icSigBToA0Tag;
            break;

        case icRelativeColorimetric:
            icSigPs2CRDx = icSigPs2CRD1Tag;
            icSigBToAx = icSigBToA1Tag;
            break;

        case icSaturation:
            icSigPs2CRDx = icSigPs2CRD2Tag;
            icSigBToAx = icSigBToA2Tag;
            break;

        case icAbsoluteColorimetric:
            icSigPs2CRDx = icSigPs2CRD3Tag;
            icSigBToAx = icSigBToA1Tag;
            break;

        default:
            *lpcbSize = (DWORD) Ret;
            return (Ret > 0);
    }

    if (
        (DoesCPTagExist (cp, icSigPs2CRDx) &&
         GetCPTagIndex (cp, icSigPs2CRDx, (LPSINT) & Index) &&
         GetCPElementDataSize (cp, Index, (LPSINT) & Ret) &&
         ((Size == 0) ||
          GetCPElementData (cp, Index, lpMem, Size)) &&
         (Ret = Convert2Ascii (cp, Index, lpMem, Size, Ret, AllowBinary))
        ) ||
        (DoesCPTagExist (cp, icSigBToAx) &&
         GetCPTagIndex (cp, icSigBToAx, (LPSINT) & Index) &&
         (Ret = CreateLutCRD (cp, Index, lpMem, Intent, AllowBinary))
        ) || 
        // SRGB98 Support Windows 98 sRGB icc profile.
        // Create CRD from TRC and Colorant Tags.
        (DoesTRCAndColorantTagExist (cp) &&
         (Ret = CreateMatrixCRD (cp, lpMem, Intent, AllowBinary))
        ) ||
        (DoesCPTagExist (cp, icSigGrayTRCTag) &&
         GetCPTagIndex (cp, icSigGrayTRCTag, (LPSINT) & Index) &&
         (Ret = CreateMonoCRD (cp, Index, lpMem, Intent))
        )
       )
    {
    }

    *lpcbSize = (DWORD) Ret;
    return (Ret > 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\dll32\getcrd.h ===
#ifndef GETCRD_H
#define GETCRD_H
BOOL EXTERN  GetPS2ColorRenderingDictionary(
    CHANDLE     cp,
    DWORD       Intent, 
    MEMPTR      lpMem, 
    LPDWORD     lpcbSize,
    BOOL        AllowBinary);
SINT SendCRDLMN(MEMPTR lpMem, CSIG Intent, 
    LPSFLOAT whitePoint, LPSFLOAT mediaWP, CSIG pcs);
SINT SendCRDPQR(MEMPTR lpMem, CSIG Intent, LPSFLOAT whitePoint);
SINT SendCRDABC(MEMPTR lpMem, MEMPTR PublicArrayName, CSIG pcs, SINT nInputCh,
    MEMPTR Buff, LPSFLOAT e, CSIG LutTag, BOOL bAllowBinary);
SINT SendCRDBWPoint(MEMPTR lpMem, LPSFLOAT whitePoint);
SINT SendCRDOutputTable(MEMPTR lpMem, MEMPTR PublicArrayName, 
    SINT nOutputCh, CSIG LutTag, BOOL bHost, BOOL bAllowBinary);
BOOL GetRevCurve (MEMPTR lpBuff, MEMPTR lpCurve, MEMPTR lpRevCurve);
SINT CreateColorantArray(CHANDLE cp, double FAR *lpArray, CSIG CPTag);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\dll32\getcsa.c ===
#include "generic.h"
#include "icmstr.h"

#pragma code_seg(_ICMSEG)

static char  *DecodeABCLab[] = {"50 mul 16 add 116 div ", 
                               "128 mul 128 sub 500 div", 
                               "128 mul 128 sub 200 div"};

#pragma optimize("",off)

BOOL IsSRGB( CHANDLE cp );

/**************************************************************************/

SINT CreateColSpArray (CHANDLE cp, MEMPTR lpMem, CSIG CPTag, BOOL AllowBinary);
SINT CreateColSpProc (CHANDLE cp, MEMPTR lpMem, CSIG CPTag, BOOL AllowBinary);
SINT CreateFloatString (CHANDLE cp, MEMPTR lpMem, CSIG CPTag);
static SINT SendCSABWPoint(MEMPTR lpMem, CSIG Intent, 
    LPSFLOAT IlluminantWP, LPSFLOAT MediaWP);
static void GetMediaWP(CHANDLE cp, CSIG InputIntent, 
    LPSFLOAT IlluminantWP, LPSFLOAT MediaWP);

/***************************************************************************
*                           GetDevideRGB
*  function:
*    this is the function which creates the DeviceRGB ColorSpace (CS)
*  prototype:
*       BOOL EXTERN GetDeviceRGB(
*                          MEMPTR       lpMem,
*                          BOOL         AllowBinary)
*  parameters:
*       lpMem       --  Pointer to the memory block
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
static BOOL
GetDeviceRGB (
              MEMPTR lpMem,
              LPDWORD lpcbSize,
              DWORD InpDrvClrSp,
              BOOL  BackupCSA)
{
    MEMPTR lpOldMem = lpMem;
    if ((InpDrvClrSp != icSigRgbData) &&
        (InpDrvClrSp != icSigDefData) &&
        (InpDrvClrSp != 0))
        return FALSE;

    if (lpMem == NULL)
    {
        *lpcbSize = lstrlen (DeviceRGBTag) + 8;
        return (TRUE);
    }

    if (BackupCSA)
    {
        lpMem += WriteNewLineObject (lpMem, NotSupportDEFG_S);
    }

    lpMem += WriteNewLineObject (lpMem, DeviceRGBTag);

    if (BackupCSA)
    {
        lpMem += WriteNewLineObject (lpMem, SupportDEFG_E);
    }

    *lpcbSize = (DWORD) (lpMem - lpOldMem);
    return (TRUE);
}
/***************************************************************************
*                           GetDevideCMYK
*  function:
*    this is the function which creates the DeviceCMYK ColorSpace (CS)
*  prototype:
*       BOOL EXTERN GetDeviceCMYK(
*                          MEMPTR       lpMem,
*                          BOOL         AllowBinary)
*  parameters:
*       lpMem       --  Pointer to the memory block
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

static BOOL
GetDeviceCMYK (
               MEMPTR lpMem,
               LPDWORD lpcbSize,
               DWORD InpDrvClrSp)
{
    MEMPTR lpOldMem = lpMem;
    if ((InpDrvClrSp != icSigCmykData) &&
        (InpDrvClrSp != 0))
        return FALSE;
    if (lpMem == NULL)
    {
        *lpcbSize = lstrlen (DeviceCMYKTag) + 8;
        return (TRUE);
    }
    lpMem += WriteNewLineObject (lpMem, DeviceCMYKTag);

    *lpcbSize = (DWORD) (lpMem - lpOldMem);
    return (TRUE);

}
/***************************************************************************
*                           GetDeviceGray
***************************************************************************/

static BOOL
GetDeviceGray (
               MEMPTR lpMem,
               LPDWORD lpcbSize,
               DWORD InpDrvClrSp)
{
    MEMPTR lpOldMem = lpMem;
    if ((InpDrvClrSp == icSigRgbData) ||
        (InpDrvClrSp == icSigDefData) ||
        (InpDrvClrSp == 0))
    {
        if (lpMem == NULL)
        {
            *lpcbSize = lstrlen (DeviceRGBTag) + 8;
            return (TRUE);
        }
        lpMem += WriteNewLineObject (lpMem, DeviceRGBTag);

        *lpcbSize = (DWORD) (lpMem - lpOldMem);
        return (TRUE);
    } else if (InpDrvClrSp == icSigGrayData)
    {
        if (lpMem == NULL)
        {
            *lpcbSize = lstrlen (DeviceGrayTag) + 8;
            return (TRUE);
        }
        lpMem += WriteNewLineObject (lpMem, DeviceGrayTag);

        *lpcbSize = (DWORD) (lpMem - lpOldMem);
        return (TRUE);
    }
}
/***************************************************************************
*                           GetPublicArrayName
***************************************************************************/

SINT
GetPublicArrayName (CHANDLE cp, CSIG IntentSig, MEMPTR PublicArrayName)
{
    MEMPTR OldPtr;
    OldPtr = PublicArrayName;
    PublicArrayName[0] = 0;
    MemCopy (PublicArrayName, (MEMPTR) & IntentSig, sizeof (CSIG));
    PublicArrayName += sizeof (CSIG);
    PublicArrayName[0] = 0;
    return (PublicArrayName - OldPtr);
}

static SINT SendCSABWPoint(MEMPTR lpMem, CSIG Intent, 
                    LPSFLOAT IlluminantWP, LPSFLOAT MediaWP)
{
    SINT   i;
    MEMPTR lpOldMem = lpMem;

 //********** /BlackPoint
    lpMem += WriteNewLineObject (lpMem, BlackPointTag);
    lpMem += WriteObject (lpMem, BlackPoint);

 //********** /WhitePoint
    lpMem += WriteNewLineObject (lpMem, WhitePointTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i++)
    {
        if (Intent == icAbsoluteColorimetric)
        {
            lpMem += WriteFloat (lpMem, (double) MediaWP[i]);
        }
        else
        {
            lpMem += WriteFloat (lpMem, (double) IlluminantWP[i]);
        }
    }
    lpMem += WriteObject (lpMem, EndArray);
    return (SINT)(lpMem - lpOldMem);
}

static void GetMediaWP(CHANDLE cp, CSIG InputIntent, 
                       LPSFLOAT IlluminantWP, LPSFLOAT MediaWP)
{
    if (InputIntent == icAbsoluteColorimetric)
    {
        if (!GetCPMediaWhitePoint (cp, (LPSFLOAT) & MediaWP)) // .. Media WhitePoint
        {
            MediaWP[0] = IlluminantWP[0];
            MediaWP[1] = IlluminantWP[1];
            MediaWP[2] = IlluminantWP[2];
        }
    }
}

SINT  BeginGlobalDict(MEMPTR lpMem)
{
    MEMPTR lpOldMem = lpMem;

    lpMem += WriteNewLineObject (lpMem, GlobalDictOp);
    lpMem += WriteObject (lpMem, BeginOp);

    return (lpMem - lpOldMem);
}

SINT  EndGlobalDict(MEMPTR lpMem)
{
    MEMPTR lpOldMem = lpMem;

    lpMem += WriteNewLineObject (lpMem, EndOp);
    lpMem += WriteObject (lpMem, SetGlobalOp);

    return (lpMem - lpOldMem);
}

SINT  EnableGlobalDict(MEMPTR lpMem)
{
    MEMPTR lpOldMem = lpMem;

    lpMem += WriteNewLineObject (lpMem, CurrentGlobalOp);
    lpMem += WriteObject (lpMem, TrueOp);
    lpMem += WriteObject (lpMem, SetGlobalOp);
    return (lpMem - lpOldMem);
}

/***************************************************************************
*                           GetPS2CSA_DEFG
*  function:
*    this is the function which creates the CIEBasedDEF(G) ColorSpace (CS)
*    from the data supplied in the RGB or CMYK Input Profile.
*  prototype:
*       GetPS2CSA_DEFG(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       int         Type
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       Type        --  CieBasedDEF or CieBasedDEFG.
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
static BOOL
GetPS2CSA_DEFG (
                CHANDLE cp,
                MEMPTR lpMem,
                LPDWORD lpcbSize,
                CSIG InputIntent,
                SINT Index,
                int Type,
                BOOL AllowBinary)
{
    CSIG PCS, LutTag;
    CSIG IntentSig;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];
    SINT nInputCh, nOutputCh, nGrids, SecondGrids;
    SINT nInputTable, nOutputTable, nNumbers;
    SINT i, j, k;
    MEMPTR lpTable;
    MEMPTR lpOldMem = lpMem;
    MEMPTR lpLut = NULL;
    MEMPTR lpLineStart;
    HGLOBAL hLut = 0;
    SINT LutSize;
    char PublicArrayName[TempBfSize];
 // Check if we can generate the CS.
 // Required  tags are: red, green and blue Colorants.
 // As for TRC tags - we are quite flexible here - if we cannot find the
 // required tag - we assume the linear responce
    if (!GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        (PCS != icSigLabData) && (PCS != icSigXYZData) ||
        !GetCPTagSig (cp, Index, (LPCSIG) & IntentSig))
    {
        return (FALSE);
    }
    if (!GetCPElementType (cp, Index, (LPCSIG) & LutTag) ||
        ((LutTag != icSigLut8Type) && (LutTag != icSigLut16Type)) ||
        !GetCPElementSize (cp, Index, (LPSINT) & LutSize) ||
        !MemAlloc (LutSize, (HGLOBAL FAR *) &hLut, (LPMEMPTR) & lpLut) ||
        !GetCPElement (cp, Index, lpLut, LutSize))
    {
        if (0 != hLut)
        {
            MemFree (hLut);
        }
        return (FALSE);
    }
 // Estimate the memory size required to hold CS

    GetCLUTinfo(LutTag, lpLut, &nInputCh, &nOutputCh, 
        &nGrids, &nInputTable, &nOutputTable, &i);

 // Level 2 printers support only tri-component CIEBasedABC input,
 // but can have either 3 or 4 output channels.
    if (!(nOutputCh == 3) ||
        !((nInputCh == 3) && (Type == TYPE_CIEBASEDDEF)) &&
        !((nInputCh == 4) && (Type == TYPE_CIEBASEDDEFG)))
    {
        SetCPLastError (CP_POSTSCRIPT_ERR);
        MemFree (hLut);
        return (FALSE);
    }
    if (lpMem == NULL)                  // This is a size request
    {
        if (Type == TYPE_CIEBASEDDEFG)
            *lpcbSize = nOutputCh * nGrids * nGrids * nGrids * nGrids * 2;  // LUT HEX bytes
        else
            *lpcbSize = nOutputCh * nGrids * nGrids * nGrids * 2;   // LUT HEX bytes

        *lpcbSize = *lpcbSize +
            nInputCh * nInputTable * 6 +
            nOutputCh * nOutputTable * 6 +  // Number of INT bytes
            nInputCh * (lstrlen (IndexArray) +
                        lstrlen (StartClip) +
                        lstrlen (EndClip)) +
            nOutputCh * (lstrlen (IndexArray) +
                         lstrlen (StartClip) +
                         lstrlen (EndClip)) +
            4096;                       // + other PS stuff


        return (TRUE);
    }
 // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant

 // Support absolute whitePoint
    GetMediaWP(cp, InputIntent, IlluminantWP, MediaWP);

 //*********** Testing CieBasedDEFG support
    lpMem += WriteNewLineObject (lpMem, TestingDEFG);

 //*********** Creating global data
    GetPublicArrayName (cp, IntentSig, PublicArrayName);
    if (Type == TYPE_CIEBASEDDEFG)
        lpMem += WriteNewLineObject (lpMem, CieBasedDEFGBegin);
    else
        lpMem += WriteNewLineObject (lpMem, CieBasedDEFBegin);

    lpMem += EnableGlobalDict(lpMem);
    lpMem += WriteNewLineObject (lpMem, SupportDEFG_S);
    lpMem += BeginGlobalDict(lpMem);

    lpMem += CreateInputArray (lpMem, nInputCh, nInputTable,
             (MEMPTR) PublicArrayName, LutTag, lpLut, AllowBinary, NULL);

    if (Type == TYPE_CIEBASEDDEFG)
    {
        i = nInputTable * nInputCh +
            nGrids * nGrids * nGrids * nGrids * nOutputCh;
    } else
    {
        i = nInputTable * nInputCh +
            nGrids * nGrids * nGrids * nOutputCh;
    }
    lpMem += CreateOutputArray (lpMem, nOutputCh, nOutputTable, i,
             (MEMPTR) PublicArrayName, LutTag, lpLut, AllowBinary, NULL);

    lpMem += WriteNewLineObject (lpMem, EndOp);
    lpMem += WriteNewLineObject (lpMem, SupportDEFG_E);
    lpMem += WriteNewLineObject (lpMem, SetGlobalOp);
    lpMem += WriteNewLineObject (lpMem, SupportDEFG_S);

 //*********** Start creating the ColorSpace
    lpMem += WriteNewLineObject (lpMem, BeginArray);   // Begin array

 //********** /CIEBasedDEF(G)
    if (Type == TYPE_CIEBASEDDEFG)
        lpMem += WriteObject (lpMem, CIEBasedDEFGTag);
    else
        lpMem += WriteObject (lpMem, CIEBasedDEFTag);
    lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary

 //********** Black/White Point
    lpMem += SendCSABWPoint(lpMem, InputIntent, IlluminantWP, MediaWP);

 //********** /DecodeDEF(G)
    lpLineStart = lpMem;
    if (Type == TYPE_CIEBASEDDEFG)
        lpMem += WriteNewLineObject (lpMem, DecodeDEFGTag);
    else
        lpMem += WriteNewLineObject (lpMem, DecodeDEFTag);

    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < nInputCh; i++)
    {
        lpLineStart = lpMem;

        lpMem += WriteNewLineObject (lpMem, BeginFunction);
#if 0
        if (PCS == icSigLabData)
        {
            lpMem += WriteObject (lpMem,
                                  (0 == i) ? EncodeABCLab1 : EncodeABCLab2);
        }
#endif
        lpMem += WriteObject (lpMem, StartClip);
        lpMem += WriteObject (lpMem, InputArray);
        lpMem += WriteObjectN (lpMem, (MEMPTR) PublicArrayName, lstrlen (PublicArrayName));
        lpMem += WriteInt (lpMem, i);

        if (!AllowBinary)               // Output ASCII
        {
            lpMem += WriteObject (lpMem, IndexArray);
        } else
        {                               // Output BINARY
            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, IndexArray);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray16b);
            }
        }
        lpMem += WriteObject (lpMem, (LutTag == icSigLut8Type) ? Scale8 : Scale16);
        lpMem += WriteObject (lpMem, EndClip);
        lpMem += WriteObject (lpMem, EndFunction);
    }
    lpMem += WriteObject (lpMem, EndArray);

 //********** /Table
    lpMem += WriteNewLineObject (lpMem, TableTag);
    lpMem += WriteObject (lpMem, BeginArray);

    lpMem += WriteInt (lpMem, nGrids);  // Send down Nh
    lpMem += WriteInt (lpMem, nGrids);  // Send down Ni
    lpMem += WriteInt (lpMem, nGrids);  // Send down Nj
    nNumbers = nGrids * nGrids * nOutputCh;
    SecondGrids = 1;
    if (Type == TYPE_CIEBASEDDEFG)
    {
        lpMem += WriteInt (lpMem, nGrids);  // Send down Nk
//       nNumbers = nGrids * nGrids * nGrids * nOutputCh ;
        SecondGrids = nGrids;
    }
    lpMem += WriteNewLineObject (lpMem, BeginArray);
    for (i = 0; i < nGrids; i++)        // Nh strings should be sent
    {
        if (Type == TYPE_CIEBASEDDEFG)
        {
            lpMem += WriteNewLineObject (lpMem, BeginArray);
        }
        for (k = 0; k < SecondGrids; k++)
        {
            lpLineStart = lpMem;
            lpMem += WriteObject (lpMem, NewLine);
            if (LutTag == icSigLut8Type)
            {
                lpTable = (MEMPTR) (((lpcpLut8Type) lpLut)->lut.data) +
                    nInputTable * nInputCh +
                    nNumbers * (i * SecondGrids + k);
            } else
            {
                lpTable = (MEMPTR) (((lpcpLut16Type) lpLut)->lut.data) +
                    2 * nInputTable * nInputCh +
                    2 * nNumbers * (i * SecondGrids + k);
            }

            if (!AllowBinary)           // Output ASCII
            {
                lpMem += WriteObject (lpMem, BeginString);
                if (LutTag == icSigLut8Type)
                    lpMem += WriteHexBuffer (lpMem, lpTable, lpLineStart, nNumbers);
                else
                {
                    for (j = 0; j < nNumbers; j++)
                    {
                        lpMem += WriteHex (lpMem, ui16toSINT (lpTable) / 256);
                        lpTable += sizeof (icUInt16Number);
                        if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                        {
                            lpLineStart = lpMem;
                            lpMem += WriteObject (lpMem, NewLine);
                        }
                    }
                }
                lpMem += WriteObject (lpMem, EndString);
            } else
            {                           // Output BINARY
                lpMem += WriteStringToken (lpMem, 143, nNumbers);
                if (LutTag == icSigLut8Type)
                    lpMem += WriteByteString (lpMem, lpTable, nNumbers);
                else
                    lpMem += WriteInt2ByteString (lpMem, lpTable, nNumbers);
            }
            lpMem += WriteObject (lpMem, NewLine);
        }
        if (Type == TYPE_CIEBASEDDEFG)
        {
            lpMem += WriteObject (lpMem, EndArray);
        }
    }
    lpMem += WriteObject (lpMem, EndArray);
    lpMem += WriteObject (lpMem, EndArray); // End array

 //********** /DecodeABC
    lpLineStart = lpMem;
    lpMem += WriteNewLineObject (lpMem, DecodeABCTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < nOutputCh; i++)
    {
        lpLineStart = lpMem;
        lpMem += WriteNewLineObject (lpMem, BeginFunction);
        lpMem += WriteObject (lpMem, Clip01);
        lpMem += WriteObject (lpMem, OutputArray);
        lpMem += WriteObjectN (lpMem, (MEMPTR) PublicArrayName, lstrlen (PublicArrayName));
        lpMem += WriteInt (lpMem, i);

        if (!AllowBinary)               // Output ASCII CRD
        {
            lpMem += WriteObject (lpMem, NewLine);

            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, TFunction8XYZ);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray);
                lpMem += WriteObject (lpMem, Scale16XYZ);
            }
        } else
        {                               // Output BINARY CRD
            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, TFunction8XYZ);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray16b);
                lpMem += WriteObject (lpMem, Scale16XYZ);
            }
        }

 // Now, We get CieBasedXYZ output. Output range 0 --> 1.99997
 // If the connection space is absolute XYZ, We need to convert 
 // from relative XYZ to absolute XYZ.
        if ((PCS == icSigXYZData) &&
            (InputIntent == icAbsoluteColorimetric))
        {
            lpMem += WriteFloat (lpMem, (double)MediaWP[i]/IlluminantWP[i]);
            lpMem += WriteObject (lpMem, MulOp); 
        }
 // If the connection space is Lab, We need to convert XYZ to Lab.
        else if (PCS == icSigLabData)
            lpMem += WriteObject (lpMem, DecodeABCLab[i]);
        lpMem += WriteObject (lpMem, EndFunction);
    }
    lpMem += WriteObject (lpMem, EndArray);

    if (PCS == icSigLabData)
    {
 //********** /MatrixABC
        lpMem += WriteNewLineObject (lpMem, MatrixABCTag);
        lpMem += WriteObject (lpMem, MatrixABCLab);

 //********** /DecodeLMN
        lpLineStart = lpMem;
        lpMem += WriteNewLineObject (lpMem, DecodeLMNTag);
        lpMem += WriteObject (lpMem, BeginArray);
        for (i = 0; i < 3; i++)
        {
            lpLineStart = lpMem;
            lpMem += WriteNewLineObject (lpMem, BeginFunction);
            lpMem += WriteObject (lpMem, DecodeLMNLab);
            if (InputIntent == icAbsoluteColorimetric)
                lpMem += WriteFloat (lpMem, (double) MediaWP[i]);
            else 
                lpMem += WriteFloat (lpMem, (double) IlluminantWP[i]);
            lpMem += WriteObject (lpMem, MulOp);
            lpMem += WriteObject (lpMem, EndFunction);
        }
        lpMem += WriteObject (lpMem, EndArray);
    } else
    {
 //********** /RangeLMN
        lpMem += WriteNewLineObject (lpMem, RangeLMNTag);
        lpMem += WriteObject (lpMem, RangeLMN);
    }

 //********** End dictionary definition
    lpMem += WriteNewLineObject (lpMem, EndDict);
    lpMem += WriteObject (lpMem, EndArray);

    if (Type == TYPE_CIEBASEDDEFG)
        lpMem += WriteNewLineObject (lpMem, CieBasedDEFGEnd);
    else
        lpMem += WriteNewLineObject (lpMem, CieBasedDEFEnd);

    lpMem += WriteNewLineObject (lpMem, SupportDEFG_E);

    *lpcbSize = (DWORD) (lpMem - lpOldMem);

    MemFree (hLut);
    return (TRUE);
}

/***************************************************************************
*                           GetPS2CSA_ABC
*  function:
*    this is the function which creates the CIEBasedABC ColorSpace (CS)
*    from the data supplied in the RGB Input Profile.
*  prototype:
*       GetPS2CSA_ABC(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       InputIntent --
*       InpDrvClrSp --
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*       BackupCSA   --  1: A CIEBasedDEF has been created, this CSA is a backup 
*                          in case some old printer can not support CIEBasedDEF.
*                       0: No CIEBasedDEF. This is the only CSA.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

BOOL
GetPS2CSA_ABC (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize,
               CSIG InputIntent, DWORD InpDrvClrSp, 
               BOOL AllowBinary, BOOL BackupCSA)
{
    CSIG PCS, Dev;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];

    SINT i;
    MEMPTR lpOldMem = lpMem;
    SINT Ret = 0; 
    
 // Check if we can generate the CS.
 // Required  tags are: red, green and blue Colorants.
 // As for TRC tags - we are quite flexible here - if we cannot find the
 // required tag - we assume the linear responce
    if (!GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPDevSpace (cp, (LPCSIG) & Dev) ||
        (Dev != icSigRgbData) ||
        !DoesTRCAndColorantTagExist(cp))
    {
        return (FALSE);
    }
    if ((InpDrvClrSp != icSigRgbData) &&
        (InpDrvClrSp != icSigDefData) &&
        (InpDrvClrSp != 0))
    {
        return (FALSE);
    }
 // Estimate the memory size required to hold CS

    if (lpMem == NULL)                  // This is a size request
    {
        *lpcbSize = 65530;
        return (TRUE);
    }

 // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);     // .. Illuminant
                                                            
 // Support absolute whitePoint
    GetMediaWP(cp, InputIntent, IlluminantWP, MediaWP);

 //*********** Creating global data

    lpMem += WriteNewLineObject (lpMem, CieBasedABCBegin);

    if (IsSRGB(cp))
    {
       lpMem += WriteNewLineObject (lpMem, AdobeCSA);
    }
    else
    {
       lpMem += EnableGlobalDict(lpMem);
       
       if (BackupCSA)
       {
           lpMem += WriteNewLineObject (lpMem, NotSupportDEFG_S);
       }
   
       lpMem += BeginGlobalDict(lpMem);
   
       lpMem += CreateColSpArray (cp, lpMem, icSigRedTRCTag, AllowBinary);
       lpMem += CreateColSpArray (cp, lpMem, icSigGreenTRCTag, AllowBinary);
       lpMem += CreateColSpArray (cp, lpMem, icSigBlueTRCTag, AllowBinary);
   
       lpMem += WriteNewLineObject (lpMem, EndOp);
   
       if (BackupCSA)
       {
           lpMem += WriteNewLineObject (lpMem, SupportDEFG_E);
       }
       lpMem += WriteNewLineObject (lpMem, SetGlobalOp);
   
       if (BackupCSA)
       {
           lpMem += WriteNewLineObject (lpMem, NotSupportDEFG_S);
       }
   
    //*********** Start creating the ColorSpace
       lpMem += WriteNewLineObject (lpMem, BeginArray);   // Begin array
    //********** /CIEBasedABC
       lpMem += WriteObject (lpMem, CIEBasedABCTag);   // Create entry
       lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary
   
    //********** Black/White Point
       lpMem += SendCSABWPoint(lpMem, InputIntent, IlluminantWP, MediaWP);
   
    //********** /DecodeABC
       lpMem += WriteNewLineObject (lpMem, DecodeABCTag);
       lpMem += WriteObject (lpMem, BeginArray);
   
       lpMem += WriteObject (lpMem, NewLine);
       lpMem += CreateColSpProc (cp, lpMem, icSigRedTRCTag, AllowBinary);
       lpMem += WriteObject (lpMem, NewLine);
       lpMem += CreateColSpProc (cp, lpMem, icSigGreenTRCTag, AllowBinary);
       lpMem += WriteObject (lpMem, NewLine);
       lpMem += CreateColSpProc (cp, lpMem, icSigBlueTRCTag, AllowBinary);
       lpMem += WriteObject (lpMem, EndArray);
   
    //********** /MatrixABC
       lpMem += WriteNewLineObject (lpMem, MatrixABCTag);
       lpMem += WriteObject (lpMem, BeginArray);
   
       lpMem += CreateFloatString (cp, lpMem, icSigRedColorantTag);
       lpMem += CreateFloatString (cp, lpMem, icSigGreenColorantTag);
       lpMem += CreateFloatString (cp, lpMem, icSigBlueColorantTag);
   
       lpMem += WriteObject (lpMem, EndArray);
   
    //********** /RangeLMN
       lpMem += WriteNewLineObject (lpMem, RangeLMNTag);
       lpMem += WriteObject (lpMem, RangeLMN);
   
    //********** /DecodeLMN
       if (InputIntent == icAbsoluteColorimetric)
       {
           // Support absolute whitePoint
           lpMem += WriteNewLineObject (lpMem, DecodeLMNTag);
           lpMem += WriteObject (lpMem, BeginArray);
           for (i = 0; i < 3; i ++)
           {
               lpMem += WriteObject (lpMem, BeginFunction);
               lpMem += WriteFloat (lpMem, (double)MediaWP[i]/IlluminantWP[i]);
               lpMem += WriteObject (lpMem, MulOp); 
               lpMem += WriteObject (lpMem, EndFunction);
           }
           lpMem += WriteObject (lpMem, EndArray);
       }
   
    //********** End dictionary definition
       lpMem += WriteNewLineObject (lpMem, EndDict);
       lpMem += WriteObject (lpMem, EndArray);
   
       if (BackupCSA)
       {
           lpMem += WriteNewLineObject (lpMem, SupportDEFG_E);
       }
   
    }
    lpMem += WriteNewLineObject (lpMem, CieBasedABCEnd);
    *lpcbSize = (DWORD) ((lpMem - lpOldMem));
    return (TRUE);
}

/***************************************************************************
*                           GetPS2CSA_ABC_LAB
*  function:
*    this is the function which creates the CIEBasedABC ColorSpace (CS)
*    from the data supplied in the LAB Input Profile.
*  prototype:
*       GetPS2CSA_ABC(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       InputIntent --
*       InpDrvClrSp --
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

BOOL
GetPS2CSA_ABC_LAB (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize,
               CSIG InputIntent, DWORD InpDrvClrSp, BOOL AllowBinary)
{
    CSIG PCS, Dev;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];

    SINT i;
    MEMPTR lpOldMem = lpMem;
    SINT Ret = 0;
 // Check if we can generate the CS.
 // Required  tags are: red, green and blue Colorants.
 // As for TRC tags - we are quite flexible here - if we cannot find the
 // required tag - we assume the linear responce
    if (!GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPDevSpace (cp, (LPCSIG) & Dev) ||
        (Dev != icSigLabData))
    {
        return (FALSE);
    }
    if ((InpDrvClrSp != icSigLabData) &&
        (InpDrvClrSp != icSigDefData) &&
        (InpDrvClrSp != 0))
    {
        return (FALSE);
    }
 // Estimate the memory size required to hold CS

    if (lpMem == NULL)                  // This is a size request
    {
        *lpcbSize = 65530;
        return (TRUE);
    }
 // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);     // .. Illuminant
                                                         
 // Support absolute whitePoint
    GetMediaWP(cp, InputIntent, IlluminantWP, MediaWP);

 //*********** Start creating the ColorSpace
    lpMem += WriteNewLineObject (lpMem, BeginArray);   // Begin array

 //********** /CIEBasedABC
    lpMem += WriteObject (lpMem, CIEBasedABCTag);   // Create entry
    lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary

 //********** Black/White Point
    lpMem += SendCSABWPoint(lpMem, InputIntent, IlluminantWP, MediaWP);

 //********** /RangeABC
    lpMem += WriteNewLineObject (lpMem, RangeABCTag);
    lpMem += WriteObject (lpMem, RangeABC_Lab);

 //********** /DecodeABC
    lpMem += WriteNewLineObject (lpMem, DecodeABCTag);
    lpMem += WriteObject (lpMem, DecodeABCLab1);

 //********** /MatrixABC
    lpMem += WriteNewLineObject (lpMem, MatrixABCTag);
    lpMem += WriteObject (lpMem, MatrixABCLab);

 //********** /DecodeLMN
    lpMem += WriteNewLineObject (lpMem, DecodeLMNTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i ++)
    {
        lpMem += WriteObject (lpMem, BeginFunction);
        lpMem += WriteObject (lpMem, DecodeLMNLab);
        if (InputIntent == icAbsoluteColorimetric)
        {
            lpMem += WriteFloat (lpMem, (double) MediaWP[i]);
        }
        else
        {
            lpMem += WriteFloat (lpMem, (double) IlluminantWP[i]);
        }
        lpMem += WriteObject (lpMem, MulOp); 
        lpMem += WriteObject (lpMem, EndFunction);
        lpMem += WriteObject (lpMem, NewLine);
    }
    lpMem += WriteObject (lpMem, EndArray);


 //********** End dictionary definition
    lpMem += WriteNewLineObject (lpMem, EndDict);
    lpMem += WriteObject (lpMem, EndArray);

    lpMem += WriteNewLineObject (lpMem, CieBasedABCEnd);
    *lpcbSize = (DWORD) ((lpMem - lpOldMem));
    return (TRUE);
}

/***************************************************************************
*                           GetPS2CSA_MONO_ABC
*  function:
*    this is the function which creates the CIEBasedABC ColorSpace (CS)
*    from the data supplied in the GRAY Input Profile.
*  prototype:
*       GetPS2CSA_MONO_ABC(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

static BOOL
GetPS2CSA_MONO_ABC (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
                    CSIG InputIntent, BOOL AllowBinary)
{
    SINT nCount;
    CSIG Tag, PCS;
    SINT i, j, Index;
    MEMPTR lpTable;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];
    MEMPTR lpBuff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem = lpMem;
    HGLOBAL hBuff;
    MEMPTR lpLineStart;
 // Check if we can generate the CS
    if (!DoesCPTagExist (cp, icSigGrayTRCTag) ||
        !GetCPTagIndex (cp, icSigGrayTRCTag, &Index) ||
        !GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        (Tag != icSigCurveType) ||
        !GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & lpBuff) ||
        !GetCPElement (cp, Index, lpBuff, MemSize))
    {
        if (NULL != lpBuff)
        {
            MemFree (hBuff);
        }
        return (FALSE);
    }
    nCount = ui32toSINT (((lpcpCurveType) lpBuff)->curve.count);

 // Estimate the memory size required to hold CS
    *lpcbSize = nCount * 6 +            // Number of INT elements
        3 * (lstrlen (IndexArray) +
             lstrlen (StartClip) +
             lstrlen (EndClip)) +
        2048;                           // + other PS stuff
    if (lpMem == NULL)                  // This is a size request
    {
        MemFree (hBuff);
        return (TRUE);
    }
 // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant

 // Support absolute whitePoint
    GetMediaWP(cp, InputIntent, IlluminantWP, MediaWP);

 //*********** Start creating the ColorSpace
    lpMem += WriteNewLineObject (lpMem, CieBasedABCBegin);

    lpMem += WriteNewLineObject (lpMem, BeginArray);   // Begin array
 //********** /CIEBasedABC
    lpMem += WriteObject (lpMem, CIEBasedABCTag);   // Create entry
    lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary

 //********** Black/White Point
    lpMem += SendCSABWPoint(lpMem, InputIntent, IlluminantWP, MediaWP);

 //********** /DecodeABC
    lpMem += WriteObject (lpMem, NewLine);
    lpLineStart = lpMem;

    if (nCount != 0)
    {
        lpMem += WriteObject (lpMem, DecodeABCTag);
        lpMem += WriteObject (lpMem, BeginArray);

        lpMem += WriteObject (lpMem, BeginFunction);
        if (nCount == 1)                // Gamma supplied in ui16 format
        {
            lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
            lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
            lpMem += WriteObject (lpMem, DecodeA3);
        } else
        {
            lpMem += WriteObject (lpMem, StartClip);
            lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
            lpMem += WriteObject (lpMem, BeginArray);
            for (i = 0; i < nCount; i++)
            {
                lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                lpTable += sizeof (icUInt16Number);
                if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                {
                    lpLineStart = lpMem;
                    lpMem += WriteObject (lpMem, NewLine);
                }
            }
            lpMem += WriteObject (lpMem, EndArray);
            lpLineStart = lpMem;
            lpMem += WriteObject (lpMem, NewLine);

            lpMem += WriteObject (lpMem, IndexArray);
            lpMem += WriteObject (lpMem, Scale16);
            lpMem += WriteObject (lpMem, EndClip);
        }
        lpMem += WriteObject (lpMem, EndFunction);
        lpMem += WriteObject (lpMem, DupOp);
        lpMem += WriteObject (lpMem, DupOp);
        lpMem += WriteObject (lpMem, EndArray);
    }
 //********** /MatrixABC
    lpMem += WriteNewLineObject (lpMem, MatrixABCTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i ++)
    {
        for (j = 0; j < 3; j++)
        {
            if (i != j)
                lpMem += WriteFloat (lpMem, (double)0);
            else
            {
                if (InputIntent == icAbsoluteColorimetric)
                    lpMem += WriteFloat (lpMem, (double)MediaWP[i]);
                else
                    lpMem += WriteFloat (lpMem, (double)IlluminantWP[i]);
            }
        }
    }
    lpMem += WriteObject (lpMem, EndArray);

 //********** /RangeLMN
    lpMem += WriteNewLineObject (lpMem, RangeLMNTag);
    lpMem += WriteObject (lpMem, RangeLMN);


    lpMem += WriteObject (lpMem, EndDict);  // End dictionary definition
    lpMem += WriteObject (lpMem, EndArray);

    MemFree (hBuff);

    lpMem += WriteNewLineObject (lpMem, CieBasedABCEnd);
    *lpcbSize = (DWORD) (lpMem - lpOldMem);
    return (TRUE);
}
/***************************************************************************
*                           GetPS2CSA_MONO_A
*  function:
*    this is the function which creates the CIEBasedA ColorSpace (CS)
*    from the data supplied in the GRAY Input Profile.
*  prototype:
*       GetPS2CSA_MONO_A(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

static BOOL
GetPS2CSA_MONO_A (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
                  CSIG InputIntent, BOOL AllowBinary)
{
    SINT nCount;
    CSIG Tag, PCS;
    SINT i, Index;
    MEMPTR lpTable;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];
    MEMPTR lpBuff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem = lpMem;
    HGLOBAL hBuff;
    MEMPTR lpLineStart;
 // Check if we can generate the CS
    if (!DoesCPTagExist (cp, icSigGrayTRCTag) ||
        !GetCPTagIndex (cp, icSigGrayTRCTag, &Index) ||
        !GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        (Tag != icSigCurveType) ||
        !GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & lpBuff) ||
        !GetCPElement (cp, Index, lpBuff, MemSize))
    {
        if (NULL != lpBuff)
        {
            MemFree (hBuff);
        }
        return (FALSE);
    }
    nCount = ui32toSINT (((lpcpCurveType) lpBuff)->curve.count);

 // Estimate the memory size required to hold CS
    *lpcbSize = nCount * 6 +            // Number of INT elements
        3 * (lstrlen (IndexArray) +
             lstrlen (StartClip) +
             lstrlen (EndClip)) +
        2048;                           // + other PS stuff
    if (lpMem == NULL)                  // This is a size request
    {
        MemFree (hBuff);
        return (TRUE);
    }
 // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant

 // Support absolute whitePoint
    GetMediaWP(cp, InputIntent, IlluminantWP, MediaWP);

 //*********** Start creating the ColorSpace
    lpMem += WriteNewLineObject (lpMem, CieBasedABegin);

    lpMem += WriteNewLineObject (lpMem, BeginArray);   // Begin array
 //********** /CIEBasedA
    lpMem += WriteObject (lpMem, CIEBasedATag); // Create entry
    lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary

 //********** Black/White Point
    lpMem += SendCSABWPoint(lpMem, InputIntent, IlluminantWP, MediaWP);

 //********** /DecodeA
    lpMem += WriteObject (lpMem, NewLine);
    lpLineStart = lpMem;

    if (nCount != 0)
    {
        lpMem += WriteObject (lpMem, DecodeATag);

        lpMem += WriteObject (lpMem, BeginFunction);
        if (nCount == 1)                // Gamma supplied in ui16 format
        {
            lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
            lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
            lpMem += WriteObject (lpMem, DecodeA3);
    // If the PCS is Lab, we need to convert Lab to XYZ
    // Now, the range is from 0 --> 0.99997.
    // Actually, the conversion from Lab to XYZ is not needed.
            if (PCS == icSigLabData)
            {
                lpMem += WriteObject (lpMem, DecodeALab);
                lpMem += WriteObject (lpMem, DecodeLMNLab);
            }
        } else
        {
            lpMem += WriteObject (lpMem, StartClip);
            lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
            lpMem += WriteObject (lpMem, BeginArray);
            for (i = 0; i < nCount; i++)
            {
                lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                lpTable += sizeof (icUInt16Number);
                if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                {
                    lpLineStart = lpMem;
                    lpMem += WriteObject (lpMem, NewLine);
                }
            }
            lpMem += WriteObject (lpMem, EndArray);
            lpLineStart = lpMem;
            lpMem += WriteObject (lpMem, NewLine);

            lpMem += WriteObject (lpMem, IndexArray);
            lpMem += WriteObject (lpMem, Scale16);
    // If the PCS is Lab, we need to convert Lab to XYZ
    // Now, the range is from 0 --> .99997.
    // Actually, the conversion from Lab to XYZ is not needed.
            if (PCS == icSigLabData)
            {
                lpMem += WriteObject (lpMem, DecodeALab);
                lpMem += WriteObject (lpMem, DecodeLMNLab);
            }
            lpMem += WriteObject (lpMem, EndClip);
        }
        lpMem += WriteObject (lpMem, EndFunction);
    }

 //********** /MatrixA
    lpMem += WriteNewLineObject (lpMem, MatrixATag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i++)
    {
        if (InputIntent == icAbsoluteColorimetric)
            lpMem += WriteFloat (lpMem, (double) MediaWP[i]);
        else
            lpMem += WriteFloat (lpMem, (double) IlluminantWP[i]);
    }
    lpMem += WriteObject (lpMem, EndArray);

 //********** /RangeLMN
    lpMem += WriteNewLineObject (lpMem, RangeLMNTag);
    lpMem += WriteObject (lpMem, RangeLMN);

 //********** /End dictionary
    lpMem += WriteObject (lpMem, EndDict);  // End dictionary definition
    lpMem += WriteObject (lpMem, EndArray);

    MemFree (hBuff);

    lpMem += WriteNewLineObject (lpMem, CieBasedAEnd);
    *lpcbSize = (DWORD) (lpMem - lpOldMem);
    return (TRUE);
}
/***************************************************************************
*                           GetPS2CSA_MONO
*  function:
*    this is the function which creates the MONO ColorSpace (CS)
*    from the data supplied in the GRAY Input Profile.
*  prototype:
*       GetPS2CSA_MONO(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       WORD        InpDrvClrSp
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       InpDrvClrSp --  Device color type (RGB or GRAY).
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
static BOOL
GetPS2CSA_MONO (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize,
                DWORD InpDrvClrSp, CSIG InputIntent, BOOL AllowBinary)
{
    BOOL Success = FALSE;
#if 0
    if ((InpDrvClrSp == icSigRgbData) ||
        (InpDrvClrSp == icSigDefData) ||
        (InpDrvClrSp == 0))
    {
        Success = GetPS2CSA_MONO_ABC (cp, lpMem, lpcbSize, InputIntent, AllowBinary);
    } else if (InpDrvClrSp == icSigGrayData)
    {
        Success = GetPS2CSA_MONO_A (cp, lpMem, lpcbSize, InputIntent, AllowBinary);
    }
#else
    if ((InpDrvClrSp == icSigGrayData) ||
        (InpDrvClrSp == 0))
    {
        Success = GetPS2CSA_MONO_A (cp, lpMem, lpcbSize, InputIntent, AllowBinary);
    }
    else
    {
        Success = FALSE;
    }
#endif
    return Success;
}
/***************************************************************************
*
*   Function to create a procedure for Color space.
*
***************************************************************************/

SINT 
CreateColSpProc (CHANDLE cp, MEMPTR lpMem, CSIG CPTag, BOOL AllowBinary)
{
    SINT nCount, Index;
    MEMPTR lpTable;
    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem;
    HGLOBAL hBuff;
    lpOldMem = lpMem;
    lpMem += WriteObject (lpMem, BeginFunction);
    if (DoesCPTagExist (cp, CPTag) &&
        GetCPTagIndex (cp, CPTag, (LPSINT) & Index) &&
        GetCPElementSize (cp, Index, (LPSINT) & MemSize) &&
        MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & Buff) &&
        GetCPElement (cp, Index, Buff, MemSize))
    {
        nCount = ui32toSINT (((lpcpCurveType) Buff)->curve.count);
        if (nCount != 0)
        {
            if (nCount == 1)            // Gamma supplied in ui16 format
            {
                lpTable = (MEMPTR) (((lpcpCurveType) Buff)->curve.data);
                lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                lpMem += WriteObject (lpMem, DecodeA3);
            } else
            {
                lpMem += WriteObject (lpMem, StartClip);
                lpTable = (MEMPTR) (((lpcpCurveType) Buff)->curve.data);
                lpMem += WriteObject (lpMem, DecodeABCArray);
                lpMem += WriteInt (lpMem, (SINT) CPTag);

                if (!AllowBinary)       // Output ASCII CS
                {
                    lpMem += WriteObject (lpMem, IndexArray);
                } else
                {                       // Output BINARY CS
                    lpMem += WriteObject (lpMem, IndexArray16b);
                }
                lpMem += WriteObject (lpMem, Scale16);
                lpMem += WriteObject (lpMem, EndClip);
            }
        }
        MemFree (hBuff);
    }
    lpMem += WriteObject (lpMem, EndFunction);
    return ((SINT) (lpMem - lpOldMem));
}
/***************************************************************************
*
*   Function to create a procedure for Color space.
*
***************************************************************************/

SINT 
CreateFloatString (CHANDLE cp, MEMPTR lpMem, CSIG CPTag)
{
    SINT i, Index;
    MEMPTR lpTable;
    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem;
    HGLOBAL hBuff;
    lpOldMem = lpMem;
    if (GetCPTagIndex (cp, CPTag, (LPSINT) & Index) &&
        GetCPElementSize (cp, Index, (LPSINT) & MemSize) &&
        MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & Buff) &&
        GetCPElement (cp, Index, Buff, MemSize))
    {
        lpTable = (MEMPTR) & (((lpcpXYZType) Buff)->data);
        for (i = 0; i < 3; i++)
        {
            lpMem += WriteFloat (lpMem, si16f16toSFLOAT (lpTable));
            lpTable += sizeof (icS15Fixed16Number);
        }
        MemFree (hBuff);
    }
    return ((SINT) (lpMem - lpOldMem));
}
/***************************************************************************
*
*   Function to create a array later to be used in ColorSpace's DecodeABC.
*
***************************************************************************/

SINT 
CreateColSpArray (CHANDLE cp, MEMPTR lpMem, CSIG CPTag, BOOL AllowBinary)
{
    SINT i, nCount, Index;
    MEMPTR lpTable;
    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem, lpLineStart;
    HGLOBAL hBuff;
    lpOldMem = lpMem;

    lpLineStart = lpMem;

    if (DoesCPTagExist (cp, CPTag) &&
        GetCPTagIndex (cp, CPTag, (LPSINT) & Index) &&
        GetCPElementSize (cp, Index, (LPSINT) & MemSize) &&
        MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & Buff) &&
        GetCPElement (cp, Index, Buff, MemSize))
    {
        nCount = ui32toSINT (((lpcpCurveType) Buff)->curve.count);
        if (nCount > 1)
        {
            lpMem += WriteNewLineObject (lpMem, Slash);
            lpMem += WriteObject (lpMem, DecodeABCArray);
            lpMem += WriteInt (lpMem, (SINT) CPTag);

            lpTable = (MEMPTR) (((lpcpCurveType) Buff)->curve.data);
            if (!AllowBinary)           // Output ASCII CS
            {
                lpMem += WriteObject (lpMem, BeginArray);
                for (i = 0; i < nCount; i++)
                {
                    lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                    lpTable += sizeof (icUInt16Number);
                    if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                    {
                        lpLineStart = lpMem;
                        lpMem += WriteObject (lpMem, NewLine);
                    }
                }
                lpMem += WriteObject (lpMem, EndArray);
            } else
            {                           // Output BINARY CS
                lpMem += WriteHNAToken (lpMem, 149, nCount);
                lpMem += WriteIntStringU2S (lpMem, lpTable, nCount);
            }
            lpMem += WriteObject (lpMem, DefOp);
        }
        MemFree (hBuff);
    }
    return ((SINT) (lpMem - lpOldMem));
}
/***************************************************************************
*                               GetCSAFromProfile
*  function:
*    this is the function which gets the ColorSpace dictionary array
*    from the the Profile.
*  prototype:
*       static BOOL GetCSAFromProfile(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       WORD        InpDrvClrSp,
*                       CSIG        DrvColorSpace,
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpBuffer    --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       InpDrvClrSp --  Input device color space.
*       DrvColorSpace --  Profile device color space.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

static BOOL
GetCSAFromProfile (
                   CHANDLE cp,
                   MEMPTR lpMem,
                   LPDWORD lpcbSize,
                   DWORD InpDrvClrSp,
                   CSIG DrvColorSpace,
                   BOOL AllowBinary)
{
    SINT Index;
    SINT Size;
    if ((DrvColorSpace == icSigGrayData) && (InpDrvClrSp != icSigGrayData))
        return FALSE;

    if (DoesCPTagExist (cp, icSigPs2CSATag) &&
        GetCPTagIndex (cp, icSigPs2CSATag, (LPSINT) & Index) &&
        GetCPElementDataSize (cp, Index, (LP