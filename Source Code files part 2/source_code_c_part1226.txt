ace into the engine, we don't want the driver to
    // get called with it again.  Otherwise we could get into a situation
    // where both the source and dest SURFOBJs for a blt were marked as DIBs.

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    0xbadf00d,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    (VOID*) 0xbadf00d);

    if ((hsurf == 0)                                                  ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, 0)) ||
        (!(ppdev->psoPunt = EngLockSurface(hsurf))))
    {
        DISPDBG((DBGLVL, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
    }

    // We need another for doing DrvBitBlt and DrvCopyBits when both
    // surfaces are off-screen bitmaps:

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    0xbadf00d,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    (VOID*) 0xbadf00d);

    if ((hsurf == 0)                                                  ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, 0)) ||
        (!(ppdev->psoPunt2 = EngLockSurface(hsurf))))
    {
        DISPDBG((DBGLVL, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
    }

    DISPDBG((DBGLVL, "Passed bEnableOffscreenHeap"));

    // enable off-screen bitmaps by if configured
    if (ppdev->flStatus & ENABLE_DEV_BITMAPS)
    {
        ppdev->flStatus |= STAT_DEV_BITMAPS;
    }

    if (poh != NULL)
    {
        return(TRUE);
    }

ReturnFalse:

    DISPDBG((DBGLVL, "Failed bEnableOffscreenHeap"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL vDisable2DOffscreenMemory
*
* 3D apps want to use the offscreen memory. Prevent 2D from using it.
\**************************************************************************/

BOOL bDisable2DOffscreenMemory(PDEV* ppdev)
{
    GLINT_DECL;
    
    if (ppdev->Disable2DCount++ > 0)
    {
        return(TRUE);
    }

    if (ppdev->flStatus & STAT_DEV_BITMAPS)
    {
        if (!bMoveAllDfbsFromOffscreenToDibs(ppdev))
        {
            DISPDBG((DBGLVL, "bDisable2DOffscreenMemory failed"));
            return FALSE;
        }
        ppdev->flStatus &= ~STAT_DEV_BITMAPS;
    }
    
    return TRUE;
}

/******************************Public*Routine******************************\
* VOID vEnable2DOffscreenMemory
*
* 3D apps no longer need offscreen memory. Use it for 2D instead.
\**************************************************************************/

VOID vEnable2DOffscreenMemory(PDEV *ppdev)
{
    GLINT_DECL;

    if (--ppdev->Disable2DCount > 0)
    {
        return;
    }

    if (ppdev->flStatus & ENABLE_DEV_BITMAPS)
    {
        ppdev->flStatus |= STAT_DEV_BITMAPS;
    }
}

#if !defined(_WIN64) && WNT_DDRAW

/******************************Public*Routine******************************\
* VOID vSurfUsed
*
* Notify the heap manager that this surface is touched and it should be
* moved to the end of DdFreeDriverMemory's priority queue 
\**************************************************************************/
VOID vSurfUsed(SURFOBJ *psoSurf)
{
    DSURF* pSurf;
    OH* pohSurf;
    OH* pohHead;
 
    // When psoSurf is the original source surface, it can be NULL
    if (! psoSurf) 
    {
        return;
    }

    // Cast the dhsurf back to the Perm3 GDI surface pointer
    pSurf = (DSURF *)psoSurf->dhsurf;

    // If the surface is a DIB managed by the driver, it shoulf be ignored
    if ((! pSurf) || (pSurf->dt & (DT_DIB | DT_DIRECTDRAW)))
    {
        return;
    }

    // Get the heap node pointer for the surface
    pohSurf = pSurf->poh;

    // Only surface in the discardable chain should be considered
    if ((! pSurf->bOffScreen) || (pohSurf->ohState != OH_DISCARDABLE))
    {
        return;
    }

    // Get the head of the discardable surface chain
    pohHead = &pSurf->ppdev->heap.ohDiscardable;

    // It is quite possible that the surface is already at the end of the queue
    if (pohSurf->pohNext == pohHead)
    {
        return;
    }

    // Remove the surf the priority queue
    pohSurf->pohPrev->pohNext = pohSurf->pohNext;    
    pohSurf->pohNext->pohPrev = pohSurf->pohPrev;

    // Link the surf into the priority queue at the end
    pohSurf->pohPrev = pohHead->pohPrev;
    pohSurf->pohNext = pohHead;

    pohSurf->pohPrev->pohNext = pohSurf;
    pohHead->pohPrev = pohSurf;
}


/******************************Callback*Routine****************************\
* DWORD DdFreeDriverMemory
*
* This function called by DirectDraw when it's running low on memory in
* our heap.  You only need to implement this function if you use the
* DirectDraw 'HeapVidMemAllocAligned' function in your driver, and you
* can boot those allocations out of memory to make room for DirectDraw.
*
* We implement this function in the P3 driver because we have DirectDraw
* entirely manage our off-screen heap, and we use HeapVidMemAllocAligned
* to put GDI device-bitmaps in off-screen memory.  DirectDraw applications
* have a higher priority for getting stuff into video memory, though, and
* so this function is used to boot those GDI surfaces out of memory in
* order to make room for DirectDraw.
*
\**************************************************************************/
DWORD CALLBACK
DdFreeDriverMemory(PDD_FREEDRIVERMEMORYDATA lpFreeDriverMemory)
{
    PPDEV ppdev;
    OH* pohSurf;

    DISPDBG((DBGLVL, "DdFreeDriverMemory is called"));
    
    // Set the return value in case no VM is available
    lpFreeDriverMemory->ddRVal = DDERR_OUTOFMEMORY;

    // Get the head of discardable surface queue
    ppdev = (PPDEV)lpFreeDriverMemory->lpDD->dhpdev;
    pohSurf = ppdev->heap.ohDiscardable.pohNext;

    while (pohSurf != &ppdev->heap.ohDiscardable)
    {
        if (! pohSurf->bDXManaged)
        {
            pohSurf = pohSurf->pohNext;
            continue;
        }

        // Try to demote this VM bitmap to SM
        if (pohMoveOffscreenDfbToDib(ppdev, pohSurf))
        {
            lpFreeDriverMemory->ddRVal = DD_OK;
        }

        break;
    }

    return (DDHAL_DRIVER_HANDLED);
}


/******************************Callback*Routine****************************\
* DdSetExclusiveMode
*
* This function is called by DirectDraw when we switch from the GDI surface,
* to DirectDraw exclusive mode, e.g. to run a game in fullcreen mode.
* You only need to implement this function when you are using the
* 'HeapVidMemAllocAligned' function and allocate memory for Device Bitmaps
* and DirectDraw surfaces from the same heap.
*
* We use this call to disable GDI DeviceBitMaps when we are running in
* DirectDraw exclusive mode. Otherwise a DD app gets confused if both GDI and
* DirectDraw allocate memory from the same heap.
*
*
\**************************************************************************/
DWORD CALLBACK
DdSetExclusiveMode(PDD_SETEXCLUSIVEMODEDATA lpSetExclusiveMode)
{
    DISPDBG((DBGLVL, "DdSetExclusiveMode is called"));

    if (lpSetExclusiveMode->dwEnterExcl)
    {
        // Remove all GDI device bitmaps from video memory here
        // and make sure they will not be promoted to videomemory
        // until we leave exclusive mode.

        bMoveAllDfbsFromOffscreenToDibs(
            (PDEV*)lpSetExclusiveMode->lpDD->dhpdev);
    }

    lpSetExclusiveMode->ddRVal = DD_OK;

    return (DDHAL_DRIVER_HANDLED);
}


/******************************Callback*Routine****************************\
* DWORD DdFlipToGDISurface
*
* This function is called by DirectDraw when it flips to the surface on which
* GDI can write to.
\**************************************************************************/

#if DX7_STEREO
#define __VIDEO_STEREOENABLE    0x800
#endif

DWORD CALLBACK
DdFlipToGDISurface(PDD_FLIPTOGDISURFACEDATA lpFlipToGDISurface)
{
    PDEV* ppdev = (PDEV *)lpFlipToGDISurface->lpDD->dhpdev;
    GLINT_DECL;
    
    DISPDBG((DBGLVL, "DdFlipToGDISurface is called"));

    lpFlipToGDISurface->ddRVal = DD_OK;

#if DX7_STEREO
    READ_GLINT_CTRL_REG(VideoControl, dwVideoControl);
    WRITE_GLINT_CTRL_REG(VideoControl, 
                         (dwVideoControl & (~__VIDEO_STEREOENABLE)));
#endif

    //
    //  Return NOTHANDLED, so that the ddraw runtime takes
    //  care that we flip back to the primary...
    //

    return (DDHAL_DRIVER_NOTHANDLED);
}

#endif

/*****************************Public*Routine*******************************\
*
* HBITMAP DrvDeriveSurface
*
* This function derives and creates a GDI surface from the specified
* DirectDraw surface.
*
* Parameters
*  pDirectDraw-----Points to a DD_DIRECTDRAW_GLOBAL structure that describes
*                  the DirectDraw object. 
*  pSurface--------Points to a DD_SURFACE_LOCAL structure that describes the
*                  DirectDraw surface around which to wrap a GDI surface.
*
* Return Value
*  DrvDeriveSurface returns a handle to the created GDI surface upon success.
*  It returns NULL if the call fails or if the driver cannot accelerate GDI
*  drawing to the specified DirectDraw surface.
*
* Comments
*  DrvDeriveSurface allows the driver to create a GDI surface around a
*  DirectDraw video memory or AGP surface object in order to allow accelerated
*  GDI drawing to the surface. If the driver does not hook this call, all GDI
*  drawing to DirectDraw surfaces is done in software using the DIB engine.
*
*  GDI calls DrvDeriveSurface with RGB surfaces only.
*
*  The driver should call DrvCreateDeviceBitmap to create a GDI surface of the
*  same size and format as that of the DirectDraw surface. Space for the
*  actual pixels need not be allocated since it already exists.
*
\**************************************************************************/

HBITMAP
DrvDeriveSurface(DD_DIRECTDRAW_GLOBAL*  pDirectDraw,
                 DD_SURFACE_LOCAL*      pSurface)
{
    PDEV*               ppdev;
    DSURF*              pdsurf;
    HBITMAP             hbmDevice;
    DD_SURFACE_GLOBAL*  pSurfaceGlobal;
    SIZEL               sizl;

    ppdev = (PDEV*)pDirectDraw->dhpdev;
    pSurfaceGlobal = pSurface->lpGbl;

    // Only accel. primary surface.

    if (pSurface->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
    {
        pdsurf = (DSURF*)ENGALLOCMEM(FL_ZERO_MEMORY, sizeof(DSURF), ALLOC_TAG_GDI(E));

        if (pdsurf != NULL)
        {
            sizl.cx = pSurfaceGlobal->wWidth;
            sizl.cy = pSurfaceGlobal->wHeight;

            hbmDevice = EngCreateDeviceBitmap((DHSURF)pdsurf,
                                               sizl,
                                               ppdev->iBitmapFormat);

            if ((hbmDevice != NULL) &&
                (EngAssociateSurface((HSURF)hbmDevice, ppdev->hdevEng, ppdev->flHooks)))
            {    
                PVOID   pvScan0 = ppdev->pjScreen + pSurfaceGlobal->fpVidMem;

                HBITMAP hbmDib = EngCreateBitmap(
                                     sizl,
                                     (ULONG) pSurfaceGlobal->lPitch,
                                     (ULONG)(ppdev->iBitmapFormat),
                                     (FLONG)(((pSurfaceGlobal->lPitch > 0) ? BMF_TOPDOWN : 0)),
                                     (PVOID) pvScan0);

                if ((hbmDib != NULL) &&
                    (EngAssociateSurface((HSURF)hbmDib, ppdev->hdevEng, HOOK_SYNCHRONIZE)))
                {
                    pdsurf->dt    = DT_SCREEN | DT_DIRECTDRAW;
                    pdsurf->bOffScreen = FALSE;
                    pdsurf->poh   = ppdev->pohScreen;
                    pdsurf->sizl  = sizl;
                    pdsurf->ppdev = ppdev;

                    if (pdsurf->pso = EngLockSurface((HSURF)hbmDib)) 
                    {
                        return (hbmDevice);
                    }
                }

                if (hbmDib)
                {
                    EngDeleteSurface((HSURF)hbmDib);
                }
            }

            if (hbmDevice)
            {
                EngDeleteSurface((HSURF)hbmDevice);
            }

            ENGFREEMEM(pdsurf);
        }
    }

    return(0);

} // DrvDeriveSurface()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\lines.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: Lines.c
*
* Content:
*
* Contains the code for drawing short fractional endpoint lines and
* longer lines with strips.  There is also a separate x86 Asm version
* of this code.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"

///////////////////////////////////////////////////////////////////////

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// Int32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//      two 32-bit LONGs to produce a 64-bit LONGLONG result.
//
// UInt64By32To32 is our own macro to divide a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// UInt64Mod32To32 is our own macro to modulus a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// 64 bit divides are usually very expensive.  Since it's very rare
// that we'll get lines where the upper 32 bits of the 64 bit result
// are used, we can almost always use 32-bit ULONG divides.  We still
// must correctly handle the larger cases:

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define UInt64Mod32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) % (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) % (ULONG)(b)))

#define SWAPL(x,y,t)        {t = x; x = y; y = t;}
#define ABS(a)              ((a) < 0 ? -(a) : (a))

FLONG gaflRound[] = {
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // no flips
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_V
    FL_V_ROUND_DOWN,                   // FL_FLIP_V | FL_FLIP_D
    FL_V_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE
    0xbaadf00d,                        // FL_FLIP_SLOPE_ONE | FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE | FL_FLIP_V
    0xbaadf00d                         // FL_FLIP_SLOPE_ONE | FL_FLIP_V | FL_FLIP_D
};

BOOL bIntegerLine(PDEV*, ULONG, ULONG, ULONG, ULONG);
BOOL bHardwareLine(PDEV*, POINTFIX*, POINTFIX*);

/******************************Public*Routine******************************\
* BOOL bLines(ppdev, pptfxFirst, pptfxBuf, cptfx, pls,
*                   prclClip, apfn[], flStart)
*
* Computes the DDA for the line and gets ready to draw it.  Puts the
* pixel data into an array of strips, and calls a strip routine to
* do the actual drawing.
*
* Doing Lines Right
* -----------------
*
* In NT, all lines are given to the device driver in fractional
* coordinates, in a 28.4 fixed point format.  The lower 4 bits are
* fractional for sub-pixel positioning.
*
* Note that you CANNOT! just round the coordinates to integers
* and pass the results to your favorite integer Bresenham routine!!
* (Unless, of course, you have such a high resolution device that
* nobody will notice -- not likely for a display device.)  The
* fractions give a more accurate rendering of the line -- this is
* important for things like our Bezier curves, which would have 'kinks'
* if the points in its polyline approximation were rounded to integers.
*
* Unfortunately, for fractional lines there is more setup work to do
* a DDA than for integer lines.  However, the main loop is exactly
* the same (and can be done entirely with 32 bit math).
*
* If You've Got Hardware That Does Bresenham
* ------------------------------------------
*
* A lot of hardware limits DDA error terms to 'n' bits.  With fractional
* coordinates, 4 bits are given to the fractional part, letting
* you draw in hardware only those lines that lie entirely in a 2^(n-4)
* by 2^(n-4) pixel space.
*
* And you still have to correctly draw those lines with coordinates
* outside that space!  Remember that the screen is only a viewport
* onto a 28.4 by 28.4 space -- if any part of the line is visible
* you MUST render it precisely, regardless of where the end points lie.
* So even if you do it in software, somewhere you'll have to have a
* 32 bit DDA routine.
*
* Our Implementation
* ------------------
*
* We employ a run length slice algorithm: our DDA calculates the
* number of pixels that are in each row (or 'strip') of pixels.
*
* We've separated the running of the DDA and the drawing of pixels:
* we run the DDA for several iterations and store the results in
* a 'strip' buffer (which are the lengths of consecutive pixel rows of
* the line), then we crank up a 'strip drawer' that will draw all the
* strips in the buffer.
*
* We also employ a 'half-flip' to reduce the number of strip
* iterations we need to do in the DDA and strip drawing loops: when a
* (normalized) line's slope is more than 1/2, we do a final flip
* about the line y = (1/2)x.  So now, instead of each strip being
* consecutive horizontal or vertical pixel rows, each strip is composed
* of those pixels aligned in 45 degree rows.  So a line like (0, 0) to
* (128, 128) would generate only one strip.
*
* We also always draw only left-to-right.
*
* Style lines may have arbitrary style patterns.  We specially
* optimize the default patterns (and call them 'masked' styles).
*
* The DDA Derivation
* ------------------
*
* Here is how I like to think of the DDA calculation.
*
* We employ Knuth's "diamond rule": rendering a one-pixel-wide line
* can be thought of as dragging a one-pixel-wide by one-pixel-high
* diamond along the true line.  Pixel centers lie on the integer
* coordinates, and so we light any pixel whose center gets covered
* by the "drag" region (John D. Hobby, Journal of the Association
* for Computing Machinery, Vol. 36, No. 2, April 1989, pp. 209-229).
*
* We must define which pixel gets lit when the true line falls
* exactly half-way between two pixels.  In this case, we follow
* the rule: when two pels are equidistant, the upper or left pel
* is illuminated, unless the slope is exactly one, in which case
* the upper or right pel is illuminated.  (So we make the edges
* of the diamond exclusive, except for the top and left vertices,
* which are inclusive, unless we have slope one.)
*
* This metric decides what pixels should be on any line BEFORE it is
* flipped around for our calculation.  Having a consistent metric
* this way will let our lines blend nicely with our curves.  The
* metric also dictates that we will never have one pixel turned on
* directly above another that's turned on.  We will also never have
* a gap; i.e., there will be exactly one pixel turned on for each
* column between the start and end points.  All that remains to be
* done is to decide how many pixels should be turned on for each row.
*
* So lines we draw will consist of varying numbers of pixels on
* successive rows, for example:
*
*       ******
*             *****
*                  ******
*                        *****
*
* We'll call each set of pixels on a row a "strip".
*
* (Please remember that our coordinate space has the origin as the
* upper left pixel on the screen; postive y is down and positive x
* is right.)
*
* Device coordinates are specified as fixed point 28.4 numbers,
* where the first 28 bits are the integer coordinate, and the last
* 4 bits are the fraction.  So coordinates may be thought of as
* having the form (x, y) = (M/F, N/F) where F is the constant scaling
* factor F = 2^4 = 16, and M and N are 32 bit integers.
*
* Consider the line from (M0/F, N0/F) to (M1/F, N1/F) which runs
* left-to-right and whose slope is in the first octant, and let
* dM = M1 - M0 and dN = N1 - N0.  Then dM >= 0, dN >= 0 and dM >= dN.
*
* Since the slope of the line is less than 1, the edges of the
* drag region are created by the top and bottom vertices of the
* diamond.  At any given pixel row y of the line, we light those
* pixels whose centers are between the left and right edges.
*
* Let mL(n) denote the line representing the left edge of the drag
* region.  On pixel row j, the column of the first pixel to be
* lit is
*
*       iL(j) = ceiling( mL(j * F) / F)
*
* Since the line's slope is less than one:
*
*       iL(j) = ceiling( mL([j + 1/2] F) / F )
*
* Recall the formula for our line:
*
*       n(m) = (dN / dM) (m - M0) + N0
*
*       m(n) = (dM / dN) (n - N0) + M0
*
* Since the line's slope is less than one, the line representing
* the left edge of the drag region is the original line offset
* by 1/2 pixel in the y direction:
*
*       mL(n) = (dM / dN) (n - F/2 - N0) + M0
*
* From this we can figure out the column of the first pixel that
* will be lit on row j, being careful of rounding (if the left
* edge lands exactly on an integer point, the pixel at that
* point is not lit because of our rounding convention):
*
*       iL(j) = floor( mL(j F) / F ) + 1
*
*             = floor( ((dM / dN) (j F - F/2 - N0) + M0) / F ) + 1
*
*             = floor( F dM j - F/2 dM - N0 dM + dN M0) / F dN ) + 1
*
*                      F dM j - [ dM (N0 + F/2) - dN M0 ]
*             = floor( ---------------------------------- ) + 1
*                                   F dN
*
*                      dM j - [ dM (N0 + F/2) - dN M0 ] / F
*             = floor( ------------------------------------ ) + 1       (1)
*                                     dN
*
*             = floor( (dM j + alpha) / dN ) + 1
*
* where
*
*       alpha = - [ dM (N0 + F/2) - dN M0 ] / F
*
* We use equation (1) to calculate the DDA: there are iL(j+1) - iL(j)
* pixels in row j.  Because we are always calculating iL(j) for
* integer quantities of j, we note that the only fractional term
* is constant, and so we can 'throw away' the fractional bits of
* alpha:
*
*       beta = floor( - [ dM (N0 + F/2) - dN M0 ] / F )                 (2)
*
* so
*
*       iL(j) = floor( (dM j + beta) / dN ) + 1                         (3)
*
* for integers j.
*
* Note if iR(j) is the line's rightmost pixel on row j, that
* iR(j) = iL(j + 1) - 1.
*
* Similarly, rewriting equation (1) as a function of column i,
* we can determine, given column i, on which pixel row j is the line
* lit:
*
*                       dN i + [ dM (N0 + F/2) - dN M0 ] / F
*       j(i) = ceiling( ------------------------------------ ) - 1
*                                       dM
*
* Floors are easier to compute, so we can rewrite this:
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F
*       j(i) = floor( ----------------------------------------------- ) - 1
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F - dM
*            = floor( ---------------------------------------------------- )
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 - 1 ] / F
*            = floor( ---------------------------------------- )
*                                       dM
*
* We can once again wave our hands and throw away the fractional bits
* of the remainder term:
*
*       j(i) = floor( (dN i + gamma) / dM )                             (4)
*
* where
*
*       gamma = floor( [ dM (N0 + F/2) - dN M0 - 1 ] / F )              (5)
*
* We now note that
*
*       beta = -gamma - 1 = ~gamma                                      (6)
*
* To draw the pixels of the line, we could evaluate (3) on every scan
* line to determine where the strip starts.  Of course, we don't want
* to do that because that would involve a multiply and divide for every
* scan.  So we do everything incrementally.
*
* We would like to easily compute c , the number of pixels on scan j:
*                                  j
*
*    c  = iL(j + 1) - iL(j)
*     j
*
*       = floor((dM (j + 1) + beta) / dN) - floor((dM j + beta) / dN)   (7)
*
* This may be rewritten as
*
*    c  = floor(i    + r    / dN) - floor(i  + r  / dN)                 (8)
*     j          j+1    j+1                j    j
*
* where i , i    are integers and r  < dN, r    < dN.
*        j   j+1                   j        j+1
*
* Rewriting (7) again:
*
*    c  = floor(i  + r  / dN + dM / dN) - floor(i  + r  / dN)
*     j          j    j                          j    j
*
*
*       = floor((r  + dM) / dN) - floor(r  / dN)
*                 j                      j
*
* This may be rewritten as
*
*    c  = dI + floor((r  + dR) / dN) - floor(r  / dN)
*     j                j                      j
*
* where dI + dR / dN = dM / dN, dI is an integer and dR < dN.
*
* r  is the remainder (or "error") term in the DDA loop: r  / dN
*  j                                                      j
* is the exact fraction of a pixel at which the strip ends.  To go
* on to the next scan and compute c    we need to know r   .
*                                  j+1                  j+1
*
* So in the main loop of the DDA:
*
*    c  = dI + floor((r  + dR) / dN) and r    = (r  + dR) % dN
*     j                j                  j+1     j
*
* and we know r  < dN, r    < dN, and dR < dN.
*              j        j+1
*
* We have derived the DDA only for lines in the first octant; to
* handle other octants we do the common trick of flipping the line
* to the first octant by first making the line left-to-right by
* exchanging the end-points, then flipping about the lines y = 0 and
* y = x, as necessary.  We must record the transformation so we can
* undo them later.
*
* We must also be careful of how the flips affect our rounding.  If
* to get the line to the first octant we flipped about x = 0, we now
* have to be careful to round a y value of 1/2 up instead of down as
* we would for a line originally in the first octant (recall that
* "In the case where two pels are equidistant, the upper or left
* pel is illuminated...").
*
* To account for this rounding when running the DDA, we shift the line
* (or not) in the y direction by the smallest amount possible.  That
* takes care of rounding for the DDA, but we still have to be careful
* about the rounding when determining the first and last pixels to be
* lit in the line.
*
* Determining The First And Last Pixels In The Line
* -------------------------------------------------
*
* Fractional coordinates also make it harder to determine which pixels
* will be the first and last ones in the line.  We've already taken
* the fractional coordinates into account in calculating the DDA, but
* the DDA cannot tell us which are the end pixels because it is quite
* happy to calculate pixels on the line from minus infinity to positive
* infinity.
*
* The diamond rule determines the start and end pixels.  (Recall that
* the sides are exclusive except for the left and top vertices.)
* This convention can be thought of in another way: there are diamonds
* around the pixels, and wherever the true line crosses a diamond,
* that pel is illuminated.
*
* Consider a line where we've done the flips to the first octant, and the
* floor of the start coordinates is the origin:
*
*        +-----------------------> +x
*        |
*        | 0                     1
*        |     0123456789abcdef
*        |
*        |   0 00000000?1111111
*        |   1 00000000 1111111
*        |   2 0000000   111111
*        |   3 000000     11111
*        |   4 00000    ** 1111
*        |   5 0000       ****1
*        |   6 000           1***
*        |   7 00             1  ****
*        |   8 ?                     ***
*        |   9 22             3         ****
*        |   a 222           33             ***
*        |   b 2222         333                ****
*        |   c 22222       3333                    **
*        |   d 222222     33333
*        |   e 2222222   333333
*        |   f 22222222 3333333
*        |
*        | 2                     3
*        v
*        +y
*
* If the start of the line lands on the diamond around pixel 0 (shown by
* the '0' region here), pixel 0 is the first pel in the line.  The same
* is true for the other pels.
*
* A little more work has to be done if the line starts in the
* 'nether-land' between the diamonds (as illustrated by the '*' line):
* the first pel lit is the first diamond crossed by the line (pixel 1 in
* our example).  This calculation is determined by the DDA or slope of
* the line.
*
* If the line starts exactly half way between two adjacent pixels
* (denoted here by the '?' spots), the first pixel is determined by our
* round-down convention (and is dependent on the flips done to
* normalize the line).
*
* Last Pel Exclusive
* ------------------
*
* To eliminate repeatedly lit pels between continuous connected lines,
* we employ a last-pel exclusive convention: if the line ends exactly on
* the diamond around a pel, that pel is not lit.  (This eliminates the
* checks we had in the old code to see if we were re-lighting pels.)
*
* The Half Flip
* -------------
*
* To make our run length algorithm more efficient, we employ a "half
* flip".  If after normalizing to the first octant, the slope is more
* than 1/2, we subtract the y coordinate from the x coordinate.  This
* has the effect of reflecting the coordinates through the line of slope
* 1/2.  Note that the diagonal gets mapped into the x-axis after a half
* flip.
*
* How Many Bits Do We Need, Anyway?
* ---------------------------------
*
* Note that if the line is visible on your screen, you must light up
* exactly the correct pixels, no matter where in the 28.4 x 28.4 device
* space the end points of the line lie (meaning you must handle 32 bit
* DDAs, you can certainly have optimized cases for lesser DDAs).
*
* We move the origin to (floor(M0 / F), floor(N0 / F)), so when we
* calculate gamma from (5), we know that 0 <= M0, N0 < F.  And we
* are in the first octant, so dM >= dN.  Then we know that gamma can
* be in the range [(-1/2)dM, (3/2)dM].  The DDI guarantees us that
* valid lines will have dM and dN values at most 31 bits (unsigned)
* of significance.  So gamma requires 33 bits of significance (we store
* this as a 64 bit number for convenience).
*
* When running through the DDA loop, r  + dR can have a value in the
*                                     j
* range 0 <= r  < 2 dN; thus the result must be a 32 bit unsigned value.
*             j
*
* Testing Lines
* -------------
*
* To be NT compliant, a display driver must exactly adhere to GIQ,
* which means that for any given line, the driver must light exactly
* the same pels as does GDI.  This can be tested using the Guiman tool
* provided elsewhere in the DDK, and 'ZTest', which draws random lines
* on the screen and to a bitmap, and compares the results.
*
* If You've Got Line Hardware
* ---------------------------
*
* If your hardware already adheres to GIQ, you're all set.  Otherwise
* you'll want to look at the S3 sample code and read the following:
*
* 1) You'll want to special case integer-only lines, since they require
*    less processing time and are more common (CAD programs will probably
*    only ever give integer lines).  GDI does not provide a flag saying
*    that all lines in a path are integer lines; consequently, you will
*    have to explicitly check every line.
*
* 2) You are required to correctly draw any line in the 28.4 device
*    space that intersects the viewport.  If you have less than 32 bits
*    of significance in the hardware for the Bresenham terms, extremely
*    long lines would overflow the hardware.  For such (rare) cases, you
*    can fall back to strip-drawing code, of which there is a C version in
*    the S3's lines.cxx (or if your display is a frame buffer, fall back
*    to the engine).
*
* 3) If you can explicitly set the Bresenham terms in your hardware, you
*    can draw non-integer lines using the hardware.  If your hardware has
*    'n' bits of precision, you can draw GIQ lines that are up to 2^(n-5)
*    pels long (4 bits are required for the fractional part, and one bit is
*    used as a sign bit).  Note that integer lines don't require the 4
*    fractional bits, so if you special case them as in 1), you can do
*    integer lines that are up to 2^(n - 1) pels long.  See the S3's
*    fastline.asm for an example.
*
\**************************************************************************/

BOOL bLines(
PDEV*       ppdev,
POINTFIX*  pptfxFirst,  // Start of first line
POINTFIX*  pptfxBuf,    // Pointer to buffer of all remaining lines
RUN*       prun,        // Pointer to runs if doing complex clipping
ULONG      cptfx,       // Number of points in pptfxBuf or number of runs
                        // in prun
LINESTATE* pls,         // Colour and style info
RECTL*     prclClip,    // Pointer to clip rectangle if doing simple clipping
PFNSTRIP   apfn[],      // Array of strip functions
FLONG      flStart)     // Flags for each line
{

    ULONG     M0;
    ULONG     dM;
    ULONG     N0;
    ULONG     dN;
    ULONG     dN_Original;
    FLONG     fl;
    LONG      x;
    LONG      y;

    LONGLONG  llBeta;
    LONGLONG  llGamma;
    LONGLONG  dl;
    LONGLONG  ll;

    ULONG     ulDelta;

    ULONG     x0;
    ULONG     y0;
    ULONG     x1;
    ULONG     cStylePels;    // Major length of line in pixels for styling
    ULONG     xStart;
    POINTL    ptlStart;
    STRIP     strip;
    PFNSTRIP  pfn;
    LONG      cPels;
    LONG*     plStrip;
    LONG*     plStripEnd;
    LONG      cStripsInNextRun;

    POINTFIX* pptfxBufEnd = pptfxBuf + cptfx - 1; // Last point in path record
    STYLEPOS  spThis;                             // Style pos for this line

    LONG xmask  = 0xffff800f;
    LONG ymask  = 0xffff800f;
    LONG xmask1 = 0xffff8000;
    LONG ymask1 = 0xffff8000;
    GLINT_DECL;

    do {

/***********************************************************************\
* Start the DDA calculations.                                           *
\***********************************************************************/

        M0 = (LONG) pptfxFirst->x;
        dM = (LONG) pptfxBuf->x;

        N0 = (LONG) pptfxFirst->y;
        dN = (LONG) pptfxBuf->y;

        fl = flStart;

        // Check for non-complex-clipped, non-styled integer endpoint lines - ECR
        // Essentially, we allow rendering of any line which 'looks' like an
        // unclipped solid line. Initialization will have set up GLINT appropriatly
        // to produce correct results
        if ((fl & (FL_COMPLEX_CLIP | FL_STYLED))  == 0 ) {

            LONG orx = (LONG) (M0 | dM);
            LONG ory = (LONG) (N0 | dN);

            if (orx < 0) {
                // At least one point was negative. Recompute or using abs points.
                orx = ABS((LONG)M0) | ABS((LONG)dM);
            }
            if (ory < 0) {
                // At least one point was negative. Recompute or using abs points.
                ory = ABS((LONG)N0) | ABS((LONG)dN);
            }

            DISPDBG((7, "Lines: Trying Fast Integer %x %x %x %x", M0, N0, dM, dN));
            // Call fast integer line routines if possible
            if (((orx & xmask) == 0) && ((ory & ymask) == 0))
            {
                if (ppdev->pgfnIntegerLine(ppdev, M0, N0, dM, dN)) {

                    if (fl & FL_READ) {
                        // If we have a logical op which requires reading from the
                        // frame buffer, we cannot guarantee ContinueNewLine's
                        // behaviour when overwriting pixels. Also, avoid
                        // ContinueNewLine on an MX.
                        pptfxFirst = pptfxBuf;
                        pptfxBuf++;
                        continue;
                    }
                    else {
                        // This is an optimisation to use continue new line
                         // to draw any subequent integer lines.    The loop is
                        // essentially the same as the outer loop, however, we
                        // dont need to check for a lot of things that we already
                        // know. We need to be able to fall out to the standard
                        // outer loop if we cant handle a line though.

                        while(TRUE) 
                        {
                            // Have we reached the end of the list of points.
                            if (pptfxBuf == pptfxBufEnd)
                                return(TRUE);
                    
                            pptfxFirst = pptfxBuf;
                            pptfxBuf++;

                            M0 = dM;
                            N0 = dN;
                             dM = (LONG) pptfxBuf->x;
                            dN = (LONG) pptfxBuf->y;

                            // We know M0 and N0 satisfy our criteria for a continue new line
                            // Therefore, we just have to check the new coordinates
                            orx = (LONG) dM;
                            ory = (LONG) dN;

                            if (orx < 0) {
                                // At least one point was negative. Recompute or using abs.
                                orx = ABS((LONG)dM);
                            }
                            if (ory < 0) {
                                // At least one point was negative. Recompute or using abs.
                                ory = ABS((LONG)dN);
                            }

                            // We need to call the routine to continue the line now.
                            // If the line is not a fast integer line, then we need to break
                            // out and try non integer lines. In this case, or will still
                            // be valid, because we know M0, N0 are integer coords that
                            // GLINT can handle.
                            DISPDBG((7, "Lines: Trying Continue Integer %x %x %x %x", M0, N0, dM, dN));
                            if (((orx & xmask) != 0) ||
                                ((ory & ymask) != 0) ||
                                  (!ppdev->pgfnContinueLine(ppdev, M0, N0, dM, dN)))
                                // Either we cant draw the line or the strip drawer failed.
                                    break;
                        }
                    }
                  }
            }

            // Call fast non integer line routines.
            if (((orx & xmask1) == 0) && ((ory & ymask1) == 0))
            {
                if (ppdev->pgfnDrawLine(ppdev, M0, N0, dM, dN)) {
                    // This line done, do next line.
                    pptfxFirst = pptfxBuf;
                    pptfxBuf++;
                    continue;
                  }
            }
           }

        DISPDBG((7, "Lines: Slow Lines %x %x %x %x", M0, N0, dM, dN));
    
        if ((LONG) M0 > (LONG) dM)
        {
        // Ensure that we run left-to-right:

            register ULONG ulTmp;
            SWAPL(M0, dM, ulTmp);
            SWAPL(N0, dN, ulTmp);
            fl |= FL_FLIP_H;
        }

    // Compute the delta dx.  The DDI says we can never have a valid delta
    // with a magnitude more than 2^31 - 1, but GDI never actually checks
    // its transforms.  So we have to check for this case to avoid overflow:

        dM -= M0;
        if ((LONG) dM < 0)      // We can skip any lines with delta > 2^31 - 1
        {
            goto Next_Line;
        }

        if ((LONG) dN < (LONG) N0)
        {
        // Line runs from bottom to top, so flip across y = 0:

            N0 = -(LONG) N0;
            dN = -(LONG) dN;
            fl |= FL_FLIP_V;
        }

        dN -= N0;
        if ((LONG) dN < 0)      // We can skip any lines with delta > 2^31 - 1
        {
            goto Next_Line;
        }

    // We now have a line running left-to-right, top-to-bottom from (M0, N0)
    // to (M0 + dM, N0 + dN):

        if (dN >= dM)
        {
            if (dN == dM)
            {
            // Have to special case slopes of one:

                fl |= FL_FLIP_SLOPE_ONE;
            }
            else
            {
            // Since line has slope greater than 1, flip across x = y:

                register ULONG ulTmp;
                SWAPL(dM, dN, ulTmp);
                SWAPL(M0, N0, ulTmp);
                fl |= FL_FLIP_D;
            }
        }

        fl |= gaflRound[(fl & FL_ROUND_MASK) >> FL_ROUND_SHIFT];

        x = LFLOOR((LONG) M0);
        y = LFLOOR((LONG) N0);

        M0 = FXFRAC(M0);
        N0 = FXFRAC(N0);

    // Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ]:

        llGamma = Int32x32To64(dM, N0 + F/2) - Int32x32To64(M0, dN);
        if (fl & FL_V_ROUND_DOWN)   // Adjust so y = 1/2 rounds down
        {
            llGamma--;
        }

        llGamma >>= FLOG2;
        llBeta = ~llGamma;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.                  *
\***********************************************************************/

    // The toughest part of GIQ is determining the start and end pels.
    //
    // Our approach here is to calculate x0 and x1 (the inclusive start
    // and end columns of the line respectively, relative to our normalized
    // origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
    // start point is easily calculated by plugging x0 into our line equation
    // (which takes care of whether y = 1/2 rounds up or down in value)
    // getting y0, and then undoing the normalizing flips to get back
    // into device space.
    //
    // We look at the fractional parts of the coordinates of the start and
    // end points, and call them (M0, N0) and (M1, N1) respectively, where
    // 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
    // to determine x0:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 ........?xxxxxxx
    //   |   1 ..........xxxxxx
    //   |   2 ...........xxxxx
    //   |   3 ............xxxx
    //   |   4 .............xxx
    //   |   5 ..............xx
    //   |   6 ...............x
    //   |   7 ................
    //   |   8 ................
    //   |   9 ......**........
    //   |   a ........****...x
    //   |   b ............****
    //   |   c .............xxx****
    //   |   d ............xxxx    ****
    //   |   e ...........xxxxx        ****
    //   |   f ..........xxxxxx
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one require a special case for both the start
    // and end.  For example, if the line ends such that (M1, N1) is (9, 1),
    // the line has gone exactly through (8, 0) -- which may be considered
    // to be part of 'x' because of rounding!  So slopes of exactly slope
    // one going through (8, 0) must also be considered as belonging in 'x'.
    //
    // For lines that go left-to-right, we have the following grid:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 xxxxxxxx?.......
    //   |   1 xxxxxxx.........
    //   |   2 xxxxxx..........
    //   |   3 xxxxx...........
    //   |   4 xxxx............
    //   |   5 xxx.............
    //   |   6 xx..............
    //   |   7 x...............
    //   |   8 x...............
    //   |   9 x.....**........
    //   |   a xx......****....
    //   |   b xxx.........****
    //   |   c xxxx............****
    //   |   d xxxxx...........    ****
    //   |   e xxxxxx..........        ****
    //   |   f xxxxxxx.........
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 0.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) - 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one must be handled similarly to the right-to-
    // left case.

        {

        // Calculate x0, x1

            ULONG N1 = FXFRAC(N0 + dN);
        ULONG M1 = FXFRAC(M0 + dM);

        x1 = LFLOOR(M0 + dM);

            if (fl & FL_FLIP_H)
            {
            // ---------------------------------------------------------------
            // Line runs right-to-left:  <----

            // Compute x1:

                if (N1 == 0)
                {
                    if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                    {
                        x1++;
                    }
                }
                else if (ABS((LONG) (N1 - F/2)) + M1 > F)
                {
                    x1++;
                }

                if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                       == (FL_FLIP_SLOPE_ONE))
                {
                // Have to special-case diagonal lines going through our
                // the point exactly equidistant between two horizontal
                // pixels, if we're supposed to round x=1/2 down:

                    if ((N1 > 0) && (M1 == N1 + 8))
                        x1++;

                // Don't you love special cases?  Is this a rhetorical question?

                    if ((N0 > 0) && (M0 == N0 + 8))
                    {
                        x0      = 2;
                        ulDelta = dN;
                        goto right_to_left_compute_y0;
                    }
                }

            // Compute x0:

                x0      = 1;
                ulDelta = 0;
                if (N0 == 0)
                {
                    if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                    {
                        x0      = 2;
                        ulDelta = dN;
                    }
                }
                else if (ABS((LONG) (N0 - F/2)) + M0 > F)
                {
                    x0      = 2;
                    ulDelta = dN;
                }

            // Compute y0:

            right_to_left_compute_y0:

                y0 = 0;
                ll = llGamma + (LONGLONG) ulDelta;

                if (ll >= (LONGLONG) (2 * dM - dN))
                    y0 = 2;
                else if (ll >= (LONGLONG) (dM - dN))
                    y0 = 1;
            }
            else
            {
            // ---------------------------------------------------------------
            // Line runs left-to-right:  ---->

            // Compute x1:

                x1--;

                if (M1 > 0)
                {
                    if (N1 == 0)
                    {
                        if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                            x1++;
                    }
                    else if (ABS((LONG) (N1 - F/2)) <= (LONG) M1)
                    {
                        x1++;
                    }
                }

                if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                       == (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                {
                // Have to special-case diagonal lines going through our
                // the point exactly equidistant between two horizontal
                // pixels, if we're supposed to round x=1/2 down:

                    if ((M1 > 0) && (N1 == M1 + 8))
                        x1--;

                    if ((M0 > 0) && (N0 == M0 + 8))
                    {
                        x0 = 0;
                        goto left_to_right_compute_y0;
                    }
                }

            // Compute x0:

                x0 = 0;
                if (M0 > 0)
                {
                    if (N0 == 0)
                    {
                        if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                            x0 = 1;
                    }
                    else if (ABS((LONG) (N0 - F/2)) <= (LONG) M0)
                    {
                        x0 = 1;
                    }
                }

            // Compute y0:

            left_to_right_compute_y0:

                y0 = 0;
                if (llGamma >= (LONGLONG) (dM - (dN & (-(LONG) x0))))
                {
                    y0 = 1;
                }
            }
        }

        cStylePels = x1 - x0 + 1;
        if ((LONG) cStylePels <= 0)
            goto Next_Line;

        xStart = x0;

/***********************************************************************\
* Complex clipping.                                                     *
\***********************************************************************/

        if (fl & FL_COMPLEX_CLIP)
        {
            dN_Original = dN;

        Continue_Complex_Clipping:

            if (fl & FL_FLIP_H)
            {
            // Line runs right-to-left <-----

                x0 = xStart + cStylePels - prun->iStop - 1;
                x1 = xStart + cStylePels - prun->iStart - 1;
            }
            else
            {
            // Line runs left-to-right ----->

                x0 = xStart + prun->iStart;
                x1 = xStart + prun->iStop;
            }

            prun++;

        // Reset some variables we'll nuke a little later:

            dN          = dN_Original;
            pls->spNext = pls->spComplex;

        // No overflow since large integer math is used.  Both values
        // will be positive:

            dl = Int32x32To64(x0, dN) + llGamma;

        // y0 = dl / dM:

            y0 = UInt64Div32To32(dl, dM);

            ASSERTDD((LONG) y0 >= 0, "y0 weird: Goofed up end pel calc?");
        }

/***********************************************************************\
* Simple rectangular clipping.                                          *
\***********************************************************************/

        if (fl & FL_SIMPLE_CLIP)
        {
            ULONG y1;
            LONG  xRight;
            LONG  xLeft;
            LONG  yBottom;
            LONG  yTop;

        // Note that y0 and y1 are actually the lower and upper bounds,
        // respectively, of the y coordinates of the line (the line may
        // have actually shrunk due to first/last pel clipping).
        //
        // Also note that x0, y0 are not necessarily zero.

            RECTL* prcl = &prclClip[(fl & FL_RECTLCLIP_MASK) >>
                                    FL_RECTLCLIP_SHIFT];

        // Normalize to the same point we've normalized for the DDA
        // calculations:

            xRight  = prcl->right  - x;
            xLeft   = prcl->left   - x;
            yBottom = prcl->bottom - y;
            yTop    = prcl->top    - y;

            if (yBottom <= (LONG) y0 ||
                xRight  <= (LONG) x0 ||
                xLeft   >  (LONG) x1)
            {
            Totally_Clipped:

                if (fl & FL_STYLED)
                {
                    pls->spNext += cStylePels;
                    if (pls->spNext >= pls->spTotal2)
                        pls->spNext %= pls->spTotal2;
                }

                goto Next_Line;
            }

            if ((LONG) x1 >= xRight)
                x1 = xRight - 1;

        // We have to know the correct y1, which we haven't bothered to
        // calculate up until now.  This multiply and divide is quite
        // expensive; we could replace it with code similar to that which
        // we used for computing y0.
        //
        // The reason why we need the actual value, and not an upper
        // bounds guess like y1 = LFLOOR(dM) + 2 is that we have to be
        // careful when calculating x(y) that y0 <= y <= y1, otherwise
        // we can overflow on the divide (which, needless to say, is very
        // bad).

            dl = Int32x32To64(x1, dN) + llGamma;

        // y1 = dl / dM:

            y1 = UInt64Div32To32(dl, dM);

            if (yTop > (LONG) y1)
                goto Totally_Clipped;

            if (yBottom <= (LONG) y1)
            {
                y1 = yBottom;
                dl = Int32x32To64(y1, dM) + llBeta;

            // x1 = dl / dN:

                x1 = UInt64Div32To32(dl, dN);
            }

        // At this point, we've taken care of calculating the intercepts
        // with the right and bottom edges.  Now we work on the left and
        // top edges:

            if (xLeft > (LONG) x0)
            {
                x0 = xLeft;
                dl = Int32x32To64(x0, dN) + llGamma;

            // y0 = dl / dM;

                y0 = UInt64Div32To32(dl, dM);

                if (yBottom <= (LONG) y0)
                    goto Totally_Clipped;
            }

            if (yTop > (LONG) y0)
            {
                y0 = yTop;
                dl = Int32x32To64(y0, dM) + llBeta;

            // x0 = dl / dN + 1;

                x0 = UInt64Div32To32(dl, dN) + 1;

                if (xRight <= (LONG) x0)
                    goto Totally_Clipped;
            }

            ASSERTDD(x0 <= x1, "Improper rectangle clip");
        }

/***********************************************************************\
* Done clipping.  Unflip if necessary.                                 *
\***********************************************************************/

        ptlStart.x = x + x0;
        ptlStart.y = y + y0;

        if (fl & FL_FLIP_D)
        {
            register LONG lTmp;
            SWAPL(ptlStart.x, ptlStart.y, lTmp);
        }


        if (fl & FL_FLIP_V)
        {
            ptlStart.y = -ptlStart.y;
        }

        cPels = x1 - x0 + 1;

/***********************************************************************\
* Style calculations.                                                   *
\***********************************************************************/

        if (fl & FL_STYLED)
        {
            STYLEPOS sp;

            spThis       = pls->spNext;
            pls->spNext += cStylePels;

            {
                if (pls->spNext >= pls->spTotal2)
                    pls->spNext %= pls->spTotal2;

                if (fl & FL_FLIP_H)
                    sp = pls->spNext - x0 + xStart;
                else
                    sp = spThis + x0 - xStart;

                ASSERTDD(fl & FL_ARBITRARYSTYLED, "Oops");

            // Normalize our target style position:

                if ((sp < 0) || (sp >= pls->spTotal2))
                {
                    sp %= pls->spTotal2;

                // The modulus of a negative number is not well-defined
                // in C -- if it's negative we'll adjust it so that it's
                // back in the range [0, spTotal2):

                    if (sp < 0)
                        sp += pls->spTotal2;
                }

            // Since we always draw the line left-to-right, but styling is
            // always done in the direction of the original line, we have
            // to figure out where we are in the style array for the left
            // edge of this line.

                if (fl & FL_FLIP_H)
                {
                // Line originally ran right-to-left:

                    sp = -sp;
                    if (sp < 0)
                        sp += pls->spTotal2;

                    pls->ulStyleMask = ~pls->ulStartMask;
                    pls->pspStart    = &pls->aspRtoL[0];
                    pls->pspEnd      = &pls->aspRtoL[pls->cStyle - 1];
                }
                else
                {
                // Line originally ran left-to-right:

                    pls->ulStyleMask = pls->ulStartMask;
                    pls->pspStart    = &pls->aspLtoR[0];
                    pls->pspEnd      = &pls->aspLtoR[pls->cStyle - 1];
                }

                if (sp >= pls->spTotal)
                {
                    sp -= pls->spTotal;
                    if (pls->cStyle & 1)
                        pls->ulStyleMask = ~pls->ulStyleMask;
                }

                pls->psp = pls->pspStart;
                while (sp >= *pls->psp)
                    sp -= *pls->psp++;

                ASSERTDD(pls->psp <= pls->pspEnd,
                        "Flew off into NeverNeverLand");

                pls->spRemaining = *pls->psp - sp;
                if ((pls->psp - pls->pspStart) & 1)
                    pls->ulStyleMask = ~pls->ulStyleMask;
            }
        }

        plStrip    = &strip.alStrips[0];
        plStripEnd = &strip.alStrips[STRIP_MAX];    // Is exclusive
        cStripsInNextRun   = 0x7fffffff;

    strip.ptlStart = ptlStart;

        if (2 * dN > dM &&
            !(fl & FL_STYLED) &&
            !(fl & FL_DONT_DO_HALF_FLIP))
        {
        // Do a half flip!  Remember that we may doing this on the
        // same line multiple times for complex clipping (meaning the
        // affected variables should be reset for every clip run):

            fl |= FL_FLIP_HALF;

            llBeta  = llGamma - (LONGLONG) ((LONG) dM);
            dN = dM - dN;
            y0 = x0 - y0;       // Note this may overflow, but that's okay
        }

    // Now, run the DDA starting at (ptlStart.x, ptlStart.y)!

        strip.flFlips = fl;
        pfn           = apfn[(fl & FL_STRIP_MASK) >> FL_STRIP_SHIFT];

    // Now calculate the DDA variables needed to figure out how many pixels
    // go in the very first strip:

        {
            register LONG  i;
            register ULONG dI;
            register ULONG dR;
                     ULONG r;

            if (dN == 0)
                i = 0x7fffffff;
            else
            {
                dl = Int32x32To64(y0 + 1, dM) + llBeta;

                ASSERTDD(dl >= 0, "Oops!");

            // i = (dl / dN) - x0 + 1;
            // r = (dl % dN);

                i = UInt64Div32To32(dl, dN);
                r = UInt64Mod32To32(dl, dN);
                i = i - x0 + 1;

                dI = dM / dN;
                dR = dM % dN;               // 0 <= dR < dN

                ASSERTDD(dI > 0, "Weird dI");
            }

            ASSERTDD(i > 0 && i <= 0x7fffffff, "Weird initial strip length");
            ASSERTDD(cPels > 0, "Zero pel line");

/***********************************************************************\
* Run the DDA!                                                          *
\***********************************************************************/

            while(TRUE)
            {
                cPels -= i;
                if (cPels <= 0)
                    break;

                *plStrip++ = i;

                if (plStrip == plStripEnd)
                {
                    strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
                    (*pfn)(ppdev, &strip, pls);
                    plStrip = &strip.alStrips[0];
                }

                i = dI;
                r += dR;

                if (r >= dN)
                {
                    r -= dN;
                    i++;
                }
            }

            *plStrip++ = cPels + i;

            strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
            (*pfn)(ppdev, &strip, pls);


        }

    Next_Line:

        if (fl & FL_COMPLEX_CLIP)
        {
            cptfx--;
            if (cptfx != 0)
                goto Continue_Complex_Clipping;

            break;
        }
        else
        {
            pptfxFirst = pptfxBuf;
            pptfxBuf++;
        }

    } while (pptfxBuf <= pptfxBufEnd);

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\glntinit.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: glntinit.c
*
* Content: Initialisation for the GLINT chip.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "pxrx.h"

#define  FOUR_MB     (4*1024*1024)

#define  AGP_LONG_READ_DISABLE       (1<<3)    

/******************************Public*Routine******************************\
* VOID vInitCoreRegisters
*
\**************************************************************************/
VOID vInitCoreRegisters(PPDEV ppdev)
{
    ULONG f, b;
    GLINT_DECL;

    if (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE)
    {
        f = (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_FRONT) ? 1 : 0;
        b = (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_BACK ) ? 1 : 0;
    }
    else
    {
        f = b = (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_FRONT) ? 1 : 0;
    }

    glintInfo->foregroundColour = 0x33BADBAD;
    glintInfo->backgroundColour = 0x33BAAAAD;
    glintInfo->config2D = 0;
    glintInfo->backBufferXY = MAKEDWORD_XY(0, ppdev->cyScreen);        // This is set properly in bInitializeGlint
    glintInfo->frontRightBufferXY = MAKEDWORD_XY(0, ppdev->cyScreen);
    glintInfo->backRightBufferXY = MAKEDWORD_XY(0, ppdev->cyScreen);
    glintInfo->fbDestMode = (1 << 8) | (1 << 1) | (f << 12) | (b << 14);
    if (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE)
    {
        glintInfo->fbDestMode |= (b << 16) | (f << 18);
    }
    glintInfo->fbDestAddr[0] = 0x00000000;
    glintInfo->fbDestAddr[1] = 0x00000000;
    glintInfo->fbDestAddr[2] = 0x00000000;
    glintInfo->fbDestAddr[3] = 0x00000000;
    glintInfo->fbDestWidth[0] = ppdev->cxMemory;
    glintInfo->fbDestWidth[1] = ppdev->cxMemory;
    glintInfo->fbDestWidth[2] = ppdev->cxMemory;
    glintInfo->fbDestWidth[3] = ppdev->cxMemory;
    glintInfo->fbDestOffset[0] = 0;
    glintInfo->fbDestOffset[1] = 0;
    glintInfo->fbDestOffset[2] = 0;
    glintInfo->fbDestOffset[3] = 0;
    glintInfo->fbWriteAddr[0] = 0x00000000;
    glintInfo->fbWriteAddr[1] = 0x00000000;
    glintInfo->fbWriteAddr[2] = 0x00000000;
    glintInfo->fbWriteAddr[3] = 0x00000000;
    glintInfo->fbWriteWidth[0] = ppdev->cxMemory;
    glintInfo->fbWriteWidth[1] = ppdev->cxMemory;
    glintInfo->fbWriteWidth[2] = ppdev->cxMemory;
    glintInfo->fbWriteWidth[3] = ppdev->cxMemory;
    glintInfo->fbWriteOffset[0] = 0;
    glintInfo->fbWriteOffset[1] = 0;
    glintInfo->fbWriteOffset[2] = 0;
    glintInfo->fbWriteOffset[3] = 0;
    glintInfo->fbSourceAddr = 0x00000000;
    glintInfo->fbSourceWidth = ppdev->cxMemory;
    glintInfo->fbSourceOffset = 0;
    glintInfo->lutMode = 0;
    glintInfo->lastLine = 0;
    glintInfo->render2Dpatching = 0;

    pxrxSetupDualWrites_Patching(ppdev);
    pxrxRestore2DContext(ppdev, TRUE);

    // Set the cache flag to say that there is no cache info
    ppdev->cFlags = 0;
    
} // vInitCoreRegisters

/******************************Public*Routine******************************\
* BOOL bAllocateGlintInfo
*
* Allocate ppdev->glintInfo and initialise the board info. We need to do
* this as early as possible because we're getting to the point where we
* need to know the board type very early.
\**************************************************************************/

BOOL bAllocateGlintInfo(PPDEV ppdev)
{
    GlintDataPtr glintInfo;
    ULONG        Length; 

    // Allocate and initialize ppdev->glintInfo. 
    // We store GLINT specific stuff in this structure.

    glintInfo = (PVOID)ENGALLOCMEM(FL_ZERO_MEMORY, 
                                   sizeof(GlintDataRec), 
                                   ALLOC_TAG_GDI(A));
    if (glintInfo == NULL)
    {
        DISPDBG((ERRLVL, "cannot allocate memory for glintInfo struct"));
        return(FALSE);
    }
    
    glintInfo->bGlintCoreBusy = TRUE;
    ppdev->glintInfo = (PVOID)glintInfo;

    // retrieve the PCI configuration information and local buffer size
    Length = sizeof(Glint_Device_Info);

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_DEVICE_INFO,
                         NULL,
                         0,
                         (PVOID)&(glintInfo->deviceInfo),
                         Length,
                         &Length))
    {
        DISPDBG((ERRLVL, "QUERY_DEVICE_INFO failed."));
        return(FALSE);
    }

    return(TRUE);
    
} // bAllocateGlintInfo

/******************************Public*Routine******************************\
* BOOL bInitializeGlint
*
* Called to load the initial values into the chip. We assume the hardware
* has been mapped. All the relevant stuff should be hanging off ppdev. We
* also sort out all the GLINT capabilities etc.
\**************************************************************************/

BOOL bInitializeGlint(PPDEV ppdev)
{
    pGlintControlRegMap pCtrlRegs;
    pGlintControlRegMap pCtrlRegsVTG;
    pGlintControlRegMap pCtrlRegsOdd;
    pGlintCoreRegMap    pCoreRegs;
    pGlintCoreRegMap    pCoreRegsRd;
    pGlintCoreRegMap    pCoreRegsOdd;
    DSURF*  pdsurf;
    OH      *poh = NULL;
    LONG    cPelSize;
    LONG    cx, cy;
    LONG    i, j;
    ULONG   width;
    ULONG   ulValue;
    BOOL    bExists;
    BOOL    bCreateBackBuffer;
    BOOL    bCreateStereoBuffers;
    ULONG   Length;
    LONG    FinalTag;
    GLINT_DECL;

    DISPDBG((DBGLVL, "bInitializeGlint: fbsize: 0x%x", ppdev->FrameBufferLength));

    glintInfo->ddCtxtId = -1; // initialize to no context
    glintInfo->LineDMABuffer.virtAddr = 0;    // Initialise these values
    glintInfo->LineDMABuffer.size = 0;
    glintInfo->PXRXDMABuffer.virtAddr = 0;
    glintInfo->PXRXDMABuffer.size = 0;
    ppdev->DMABuffer.pphysStart.HighPart = 0;
    ppdev->DMABuffer.pphysStart.LowPart = 0;
    ppdev->DMABuffer.cb = 0;
    ppdev->DMABuffer.pulStart = NULL;
    ppdev->DMABuffer.pulCurrent = NULL;
    ppdev->DMABuffer.pulEnd = NULL;

    Length = sizeof(GENERAL_DMA_BUFFER);
    ulValue = 1;
    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_GENERAL_DMA_BUFFER,
                         &ulValue,
                         sizeof(ulValue),
                         (PVOID)&(glintInfo->LineDMABuffer),
                         Length,
                         &Length))
    {
        DISPDBG((ERRLVL, "QUERY_LINE_DMA_BUFFER failed."));
        DISPDBG((ERRLVL, "FATAL ERROR: DRIVER REQUIRES DMA BUFFER FOR 2D"
                         " - UNLOADING DRIVER"));
        return(FALSE);
    }

    bExists = bGlintQueryRegistryValueUlong( ppdev, L"PXRX.DisableDMA", &i );

    if ((bExists && !i) || !bExists)
    {
        Length = sizeof(GENERAL_DMA_BUFFER);
        ulValue = 2;
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_QUERY_GENERAL_DMA_BUFFER,
                               &ulValue,
                               sizeof(ulValue),
                               (PVOID) &glintInfo->PXRXDMABuffer,
                               Length,
                               &Length))
        {
            DISPDBG((DBGLVL, "QUERY_DMA_BUFFER failed for the PXRX buffer."));
            return FALSE;
        }

        DISPDBG((DBGLVL, "QUERY_DMA_BUFFER(PxRx): P:0x%X:%08X, V:0x%08X, S:%dKb, %s",
                 glintInfo->PXRXDMABuffer.physAddr.HighPart, glintInfo->PXRXDMABuffer.physAddr.LowPart,
                 glintInfo->PXRXDMABuffer.virtAddr, glintInfo->PXRXDMABuffer.size / 1024,
                 glintInfo->PXRXDMABuffer.cacheEnabled ? "Cached" : "Uncached"));
    }
#if DBG
    else
    {
        GENERAL_DMA_BUFFER  dmaBuff;

        Length = sizeof(GENERAL_DMA_BUFFER);
        ulValue = 2;
        if( EngDeviceIoControl(ppdev->hDriver, IOCTL_VIDEO_QUERY_GENERAL_DMA_BUFFER,
                               &ulValue, sizeof(ulValue), (PVOID) &dmaBuff,
                               Length, &Length) ) {
            DISPDBG((ERRLVL, "QUERY_DMA_BUFFER failed for the PXRX buffer."));
            return FALSE;
        }

        DISPDBG((DBGLVL, "QUERY_DMA_BUFFER(???): P:0x%X:%08X, V:0x%08X, S:%dKb, %s",
                 dmaBuff.physAddr.HighPart, dmaBuff.physAddr.LowPart, dmaBuff.virtAddr, dmaBuff.size / 1024,
                 dmaBuff.cacheEnabled ? "Cached" : "Uncached"));
    }
#endif

//@@BEGIN_DDKSPLIT
    // TMM: Temporary until we fix s/w cursors. Disable s/w cursor.
    ppdev->flStatus &= ~ENABLE_POINTER_CACHE;
//@@END_DDKSPLIT

    // Clear the patching flags to begin with
    glintInfo->pxrxFlags &= ~(PXRX_FLAGS_PATCHING_FRONT | PXRX_FLAGS_PATCHING_BACK);

    // the 2D driver can use the line buffer for other things as well, such as for text rendering
    ppdev->DMABuffer.pphysStart = glintInfo->LineDMABuffer.physAddr;
    ppdev->DMABuffer.cb = glintInfo->LineDMABuffer.size;
    ppdev->DMABuffer.pulStart = glintInfo->LineDMABuffer.virtAddr;
    ppdev->DMABuffer.pulCurrent = glintInfo->LineDMABuffer.virtAddr;
    ppdev->DMABuffer.pulEnd = ppdev->DMABuffer.pulStart + glintInfo->LineDMABuffer.size - 1;

    // set-up the DMA board status - we'll program the registers later
    ppdev->g_GlintBoardStatus = GLINT_DMA_COMPLETE;

    // Init whether or not GDI is allowed to access framebuffer.
    // This must be a variable as it is affected by overlays.

    glintInfo->GdiCantAccessFramebuffer = ((ppdev->flCaps & CAPS_SPARSE_SPACE) == CAPS_SPARSE_SPACE);

    DISPDBG((WRNLVL, "deviceInfo: GdiCantAccessFramebuffer %d", glintInfo->GdiCantAccessFramebuffer)); 

    DISPDBG((WRNLVL, "deviceInfo: VendorId: 0x%x, DevId 0x%x, GammaId 0x%x, RevId %d, SubId %d, SubVId %d, lbuf len 0x%x, lbuf width %d", 
                    glintInfo->deviceInfo.VendorId,
                    glintInfo->deviceInfo.DeviceId,
                    glintInfo->deviceInfo.GammaRevId,
                    glintInfo->deviceInfo.RevisionId,
                    glintInfo->deviceInfo.SubsystemId,
                    glintInfo->deviceInfo.SubsystemVendorId,
                    glintInfo->deviceInfo.LocalbufferLength,
                    glintInfo->deviceInfo.LocalbufferWidth));

    // collect flags as we initialize so zero it here
    glintInfo->flags = 0;


//@@BEGIN_DDKSPLIT
#if 0
    // Try to establish color space double buffering. The actual method
    // depends on the RAMDAC so call the appropriate routine depending on
    // the one we support.
    //
    bExists = ppdev->pgfnPointerCheckCSBuffering(ppdev);
    if (bExists)
    {
        glintInfo->flags |= GLICAP_COLOR_SPACE_DBL_BUF;
    }
#endif
//@@END_DDKSPLIT

    // optional DrvCopyBits acceleration for downloads
    ppdev->pgfnCopyXferImage    = NULL;
    ppdev->pgfnCopyXfer24bpp    = NULL;
    ppdev->pgfnCopyXfer16bpp    = NULL;
    ppdev->pgfnCopyXfer8bppLge  = NULL;
    ppdev->pgfnCopyXfer8bpp     = NULL;
    ppdev->pgfnCopyXfer4bpp     = NULL;

    // optional NT5 acceleration functions
#if(_WIN32_WINNT >= 0x500)
    ppdev->pgfnGradientFillRect = NULL;
    ppdev->pgfnTransparentBlt = NULL;
    ppdev->pgfnAlphaBlend = NULL;
#endif

//@@BEGIN_DDKSPLIT
    // if we're simulating from boot-up then it's OK to use our preferred text method
    // HIDEYUKN, temporary disable host memory cache, until figure out more detail.
    // ppdev->PreferredGlyphRenderingMethod = GLYPH_HOSTMEM_CACHE;
//@@END_DDKSPLIT

    glintInfo->usePXRXdma = USE_PXRX_DMA_FIFO;
    pxrxSetupFunctionPointers( ppdev );

    // Do the translates for all the GLINT registers we use. For dual-TX
    // pCoreRegs points at core registers through Delta
    // pCtrlRegs points at Delta
    // pCtrlRegsVTG points at the TX with the RAMDAC
    // pCtrlRegsOdd points at the non-VTG TX (odd owned scanlines for 3D)
    //
    pCtrlRegs    =
    pCtrlRegsVTG = (pGlintControlRegMap)ppdev->pulCtrlBase[0];
    pCtrlRegsOdd = (pGlintControlRegMap)ppdev->pulCtrlBase[1];
    pCoreRegs    = &(pCtrlRegs->coreRegs);
    pCoreRegsOdd = &(pCtrlRegsOdd->coreRegs);
    pCoreRegsRd  = &(pCtrlRegsVTG->coreRegs);
    glintInfo->BroadcastMask2D = DELTA_BROADCAST_TO_CHIP(0);
    glintInfo->BroadcastMask3D = DELTA_BROADCAST_TO_BOTH_CHIPS;

    if (ppdev->flCaps & CAPS_SPLIT_FRAMEBUFFER)
    {
        glintInfo->BroadcastMask2D = DELTA_BROADCAST_TO_BOTH_CHIPS;
        pCtrlRegsVTG = (pGlintControlRegMap)ppdev->pulCtrlBase[1];
    }

    ppdev->pulRamdacBase = (PVOID)&(pCtrlRegsVTG->ExternalVideo);

    // FIFO registers. Translate all possible tags
    FinalTag = __MaximumGlintTagValue;

    // record the maximum number if free FIFO entries

    if( GLINT_GAMMA_PRESENT ) {
        glintInfo->MaxInFifoEntries = MAX_GAMMA_FIFO_ENTRIES;
    } else {
        glintInfo->MaxInFifoEntries = MAX_P3_FIFO_ENTRIES;
    }

    // Chip tags may be read/written from different address spaces
    for (i = 0; i < __DeltaTagV0Fixed0; ++i)
    {
        glintInfo->regs.tagwr[i] =
                    TRANSLATE_ADDR(&(pCoreRegs->tag[i]));
        glintInfo->regs.tagrd[i] =
                    TRANSLATE_ADDR(&(pCoreRegsRd->tag[i]));
    }
    // Delta tags are read/written from the same address space
    for (i = __DeltaTagV0Fixed0; i <= FinalTag; ++i)
    {
        glintInfo->regs.tagwr[i] =
                    TRANSLATE_ADDR(&(pCoreRegs->tag[i]));
        glintInfo->regs.tagrd[i] =
                    TRANSLATE_ADDR(&(pCoreRegs->tag[i]));
    }

    // non-FIFO control registers
    
    glintInfo->regs.LBMemoryCtl =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->LBMemoryCtl));
    glintInfo->regs.LBMemoryEDO =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->LBMemoryEDO));
    glintInfo->regs.FBMemoryCtl =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->FBMemoryCtl));
    glintInfo->regs.FBModeSel =
                    TRANSLATE_ADDR(&(pCtrlRegs->FBModeSel));
    glintInfo->regs.FBModeSelOdd =
                    TRANSLATE_ADDR(&(pCtrlRegsOdd->FBModeSel));
    glintInfo->regs.VTGHLimit =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGHLimit));
    glintInfo->regs.VTGHSyncStart =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGHSyncStart));
    glintInfo->regs.VTGHSyncEnd =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGHSyncEnd));
    glintInfo->regs.VTGHBlankEnd =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGHBlankEnd));
    glintInfo->regs.VTGHGateStart =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGHGateStart));
    glintInfo->regs.VTGHGateEnd =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGHGateEnd));
    glintInfo->regs.VTGVLimit =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGVLimit));
    glintInfo->regs.VTGVSyncStart =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGVSyncStart));
    glintInfo->regs.VTGVSyncEnd =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGVSyncEnd));
    glintInfo->regs.VTGVBlankEnd =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGVBlankEnd));
    glintInfo->regs.VTGVGateStart =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGVGateStart));
    glintInfo->regs.VTGVGateEnd =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGVGateEnd));
    glintInfo->regs.VTGPolarity =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGPolarity));
    glintInfo->regs.VTGVLineNumber =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGVLineNumber));
    glintInfo->regs.VTGFrameRowAddr =
                    TRANSLATE_ADDR(&(pCtrlRegs->VTGFrameRowAddr));
    glintInfo->regs.VTGFrameRowAddrOdd =
                    TRANSLATE_ADDR(&(pCtrlRegsOdd->VTGFrameRowAddr));
    glintInfo->regs.InFIFOSpace =
                    TRANSLATE_ADDR(&(pCtrlRegs->InFIFOSpace));
    glintInfo->regs.OutFIFOWords =
                    TRANSLATE_ADDR(&(pCtrlRegs->OutFIFOWords));
    glintInfo->regs.OutFIFOWordsOdd =
                    TRANSLATE_ADDR(&(pCtrlRegsOdd->OutFIFOWords));
    glintInfo->regs.DMAAddress =
                    TRANSLATE_ADDR(&(pCtrlRegs->DMAAddress));
    glintInfo->regs.DMACount =
                    TRANSLATE_ADDR(&(pCtrlRegs->DMACount));
    glintInfo->regs.InFIFOInterface =
                    TRANSLATE_ADDR(&(pCtrlRegs->FIFOInterface));
    glintInfo->regs.OutFIFOInterface =
                    TRANSLATE_ADDR(&(pCtrlRegs->FIFOInterface));
    glintInfo->regs.OutFIFOInterfaceOdd =
                    TRANSLATE_ADDR(&(pCtrlRegsOdd->FIFOInterface));
    glintInfo->regs.IntFlags =
                    TRANSLATE_ADDR(&(pCtrlRegs->IntFlags));
    glintInfo->regs.IntEnable =
                    TRANSLATE_ADDR(&(pCtrlRegs->IntEnable));
    glintInfo->regs.ResetStatus =
                    TRANSLATE_ADDR(&(pCtrlRegs->ResetStatus));
    glintInfo->regs.ErrorFlags =
                    TRANSLATE_ADDR(&(pCtrlRegs->ErrorFlags));        
    glintInfo->regs.DeltaIntFlags =
                    TRANSLATE_ADDR(&(pCtrlRegs->DeltaIntFlags));
    glintInfo->regs.DeltaIntEnable =
                    TRANSLATE_ADDR(&(pCtrlRegs->DeltaIntEnable));
    glintInfo->regs.DeltaErrorFlags =
                    TRANSLATE_ADDR(&(pCtrlRegs->DeltaErrorFlags));        
    glintInfo->regs.ScreenBase =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->ScreenBase));
    glintInfo->regs.ScreenBaseRight =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->ScreenBaseRight));
    glintInfo->regs.LineCount =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->LineCount));
    glintInfo->regs.VbEnd =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VbEnd));
    glintInfo->regs.VideoControl =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VideoControl));
    glintInfo->regs.MemControl =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->MemControl));
    glintInfo->regs.VTGSerialClk =
                    TRANSLATE_ADDR(&(pCtrlRegs->VTGSerialClk));
    glintInfo->regs.VTGSerialClkOdd =
                    TRANSLATE_ADDR(&(pCtrlRegsOdd->VTGSerialClk));
    glintInfo->regs.VClkCtl =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VClkCtl));
    glintInfo->regs.RacerDoubleWrite =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->RacerDoubleWrite));
    glintInfo->regs.RacerBankSelect =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->RacerBankSelect));
//@@BEGIN_DDKSPLIT
    // TMM: Add support for Omnicomp 3Demon Pro16
//@@END_DDKSPLIT
    glintInfo->regs.DemonProDWAndStatus =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->DemonProDWAndStatus));
    glintInfo->regs.DemonProUBufB =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->DemonProUBufB));
    glintInfo->regs.DisconnectControl =
                    TRANSLATE_ADDR(&(pCtrlRegs->DisconnectControl));

    // The following regs are P2 only - but it should be safe to calculate them for
    // any chipset
    glintInfo->regs.OutDMAAddress =
                    TRANSLATE_ADDR(&(pCtrlRegs->OutDMAAddress));
    glintInfo->regs.OutDMACount =
                    TRANSLATE_ADDR(&(pCtrlRegs->OutDMACount));
    glintInfo->regs.DMAControl =
                    TRANSLATE_ADDR(&(pCtrlRegs->DMAControl));
    glintInfo->regs.AGPControl =
                    TRANSLATE_ADDR(&(pCtrlRegs->AGPControl));
    glintInfo->regs.ByDMAAddress =
                    TRANSLATE_ADDR(&(pCtrlRegs->ByDMAAddress));
    glintInfo->regs.ByDMAStride =
                    TRANSLATE_ADDR(&(pCtrlRegs->ByDMAStride));
    glintInfo->regs.ByDMAMemAddr =
                    TRANSLATE_ADDR(&(pCtrlRegs->ByDMAMemAddr));
    glintInfo->regs.ByDMASize =
                    TRANSLATE_ADDR(&(pCtrlRegs->ByDMASize));
    glintInfo->regs.ByDMAByteMask =
                    TRANSLATE_ADDR(&(pCtrlRegs->ByDMAByteMask));
    glintInfo->regs.ByDMAControl =
                    TRANSLATE_ADDR(&(pCtrlRegs->ByDMAControl));
    glintInfo->regs.ByDMAComplete =
                    TRANSLATE_ADDR(&(pCtrlRegs->ByDMAComplete));
    glintInfo->regs.VSConfiguration =
                    TRANSLATE_ADDR(&(pCtrlRegs->VSConfiguration));
    glintInfo->regs.TextureDownloadControl =
                    TRANSLATE_ADDR(&(pCtrlRegs->TextureDownloadControl));
    glintInfo->regs.LocalMemCaps =
                    TRANSLATE_ADDR(&(pCtrlRegs->LocalMemCaps));
    glintInfo->regs.MemScratch =
                    TRANSLATE_ADDR(&(pCtrlRegs->MemScratch));

    // The following regs are Gamma only - but it should be safe to calculate them for
    // any chipset
    glintInfo->regs.GammaCommandMode =
                    TRANSLATE_ADDR(&(pCtrlRegs->GammaCommandMode));
    glintInfo->regs.GammaCommandIntEnable =
                    TRANSLATE_ADDR(&(pCtrlRegs->GammaCommandIntEnable));
    glintInfo->regs.GammaCommandIntFlags =
                    TRANSLATE_ADDR(&(pCtrlRegs->GammaCommandIntFlags));
    glintInfo->regs.GammaCommandErrorFlags =
                    TRANSLATE_ADDR(&(pCtrlRegs->GammaCommandErrorFlags));
    glintInfo->regs.GammaCommandStatus =
                    TRANSLATE_ADDR(&(pCtrlRegs->GammaCommandStatus));
    glintInfo->regs.GammaFeedbackSelectCount =
                    TRANSLATE_ADDR(&(pCtrlRegs->GammaFeedbackSelectCount));
    glintInfo->regs.GammaProcessorMode =
                    TRANSLATE_ADDR(&(pCtrlRegs->GammaProcessorMode));
    glintInfo->regs.GammaChipConfig =
                    TRANSLATE_ADDR(&(pCtrlRegs->GammaChipConfig));
    glintInfo->regs.GammaMultiGLINTAperture =
                    TRANSLATE_ADDR(&(pCtrlRegs->GammaMultiGLINTAperture));

    // PXRX only bypass stuff:
    glintInfo->regs.PXRXByAperture1Mode = TRANSLATE_ADDR( &(pCtrlRegs->PXRXByAperture1Mode) );
    glintInfo->regs.PXRXByAperture1Stride = TRANSLATE_ADDR( &(pCtrlRegs->PXRXByAperture1Stride) );
    //glintInfo->regs.PXRXByAperture1YStart
    //glintInfo->regs.PXRXByAperture1UStart
    //glintInfo->regs.PXRXByAperture1VStart
    glintInfo->regs.PXRXByAperture2Mode = TRANSLATE_ADDR( &(pCtrlRegs->PXRXByAperture2Mode) );
    glintInfo->regs.PXRXByAperture2Stride = TRANSLATE_ADDR( &(pCtrlRegs->PXRXByAperture2Stride) );
    //glintInfo->regs.PXRXByAperture2YStart
    //glintInfo->regs.PXRXByAperture2UStart
    //glintInfo->regs.PXRXByAperture2VStart
    glintInfo->regs.PXRXByDMAReadMode = TRANSLATE_ADDR( &(pCtrlRegs->PXRXByDMAReadMode) );
    glintInfo->regs.PXRXByDMAReadStride = TRANSLATE_ADDR( &(pCtrlRegs->PXRXByDMAReadStride) );
    //glintInfo->regs.PXRXByDMAReadYStart
    //glintInfo->regs.PXRXByDMAReadUStart
    //glintInfo->regs.PXRXByDMAReadVStart
    glintInfo->regs.PXRXByDMAReadCommandBase = TRANSLATE_ADDR( &(pCtrlRegs->PXRXByDMAReadCommandBase) );
    glintInfo->regs.PXRXByDMAReadCommandCount = TRANSLATE_ADDR( &(pCtrlRegs->PXRXByDMAReadCommandCount) );
    //glintInfo->regs.PXRXByDMAWriteMode
    //glintInfo->regs.PXRXByDMAWriteStride
    //glintInfo->regs.PXRXByDMAWriteYStart
    //glintInfo->regs.PXRXByDMAWriteUStart
    //glintInfo->regs.PXRXByDMAWriteVStart
    //glintInfo->regs.PXRXByDMAWriteCommandBase
    //glintInfo->regs.PXRXByDMAWriteCommandCount

    // Debug/profile registers on a P3.
    glintInfo->regs.TestOutputRdy           = TRANSLATE_ADDR( &(pCtrlRegs->TestOutputRdy) );
    glintInfo->regs.TestInputRdy            = TRANSLATE_ADDR( &(pCtrlRegs->TestInputRdy) );
    glintInfo->regs.LocalMemProfileMask0    = TRANSLATE_ADDR( &(pCtrlRegs->LocalMemProfileMask0) );
    glintInfo->regs.LocalMemProfileMask1    = TRANSLATE_ADDR( &(pCtrlRegs->LocalMemProfileMask1) );
    glintInfo->regs.LocalMemProfileCount0   = TRANSLATE_ADDR( &(pCtrlRegs->LocalMemProfileCount0) );
    glintInfo->regs.LocalMemProfileCount1   = TRANSLATE_ADDR( &(pCtrlRegs->BootAddress) );

    // initialize the overlay to be disabled
    glintInfo->OverlayMode = GLINT_DISABLE_OVERLAY;
    glintInfo->WriteMask = 0xffffffff;
    glintInfo->DefaultWriteMask = 0xffffffff;

//@@BEGIN_DDKSPLIT
    // TMM: On ELSA Gloria Gamma boards with 640 RAMDACs at 15BPP, bit 15 is used
    // by the RAMDAC to select a different LUT. So we have to mask
    // the top bit out when writing to the framebuffer.
//@@END_DDKSPLIT
    if (glintInfo->deviceInfo.ActualDacId == RGB640_RAMDAC &&
        ppdev->cPelSize == GLINTDEPTH16)
    {
        glintInfo->DefaultWriteMask = 0x7FFF7FFF;
        glintInfo->WriteMask = 0x7FFF7FFF;
    }

    // Initialise current FIFO count
    glintInfo->FifoCnt = 0;

//@@BEGIN_DDKSPLIT
#if 0 // HIDEYUKN
    //
    // If we have a gamma ramp saved in the registry then use that. Otherwise,
    // initialize the LUT with a gamma of 1.0
    //
    if (!bGlintRegistryRetrieveGammaLUT(ppdev, &glintInfo->gammaLUT) ||
        !bInstallGammaLUT(ppdev, &glintInfo->gammaLUT, FALSE))
    {
        vSetNewGammaValue(ppdev, 0x10000, FALSE);
    }
#endif
//@@END_DDKSPLIT

    //
    // initialize our DMA buffers if any are configured
    // 
    vGlintInitializeDMA(ppdev);

    // fill in the glintInfo capability flags and block fill size.
    //
    glintInfo->flags |= GLICAP_NT_CONFORMANT_LINES;
    glintInfo->fastFillSupport = 0;
    glintInfo->renderFastFill = 0;
    glintInfo->fastFillBlockSz = 0;

    {
        ULONG DMAMemoryControl = 0;

        DMAMemoryControl |= 1 << 2;                    // align host-in DMA to 64 bit boundaries
        DMAMemoryControl |= (0 & 0x1f) << 24;        // burst size n == (1 << 7+n)? Spec indicates n * 128
        DMAMemoryControl |= 1 << 31;                // align host-out DMA to 64 bit boundaries

        if( ppdev->flCaps & CAPS_USE_AGP_DMA ) 
            DMAMemoryControl |= 1 << 0;                // host-in DMA uses AGP

        WAIT_GLINT_FIFO(1);
        LD_GLINT_FIFO(__GlintTagDMAMemoryControl, DMAMemoryControl);
    }

    {
        ULONG   *dmaVirt = glintInfo->PXRXDMABuffer.virtAddr;
        ULONG   dmaPhys = (ULONG) glintInfo->PXRXDMABuffer.physAddr.LowPart;
        ULONG   size = (glintInfo->PXRXDMABuffer.size) / sizeof(ULONG);

        DISPDBG((DBGLVL, "PXRX_DMA: allocated: 0x%08X + 0x%08X @ 0x%08X",
                 glintInfo->PXRXDMABuffer.virtAddr, glintInfo->PXRXDMABuffer.size, glintInfo->PXRXDMABuffer.physAddr));

        if ((glintInfo->PXRXDMABuffer.virtAddr == 0) ||
            (glintInfo->PXRXDMABuffer.size == 0 ) ||
            (glintInfo->PXRXDMABuffer.physAddr.LowPart == 0))
        {

            DISPDBG((DBGLVL, "PXRX_DMA: Physical buffer allocation has failed, using a virtual buffer..."));

            size = 256 * 1024;
            dmaVirt = (ULONG *) ENGALLOCMEM(FL_ZERO_MEMORY, 
                                            size * sizeof(ULONG), 
                                            ALLOC_TAG_GDI(B));
            if (NULL == dmaVirt)
            {
                DISPDBG((-1, "FATAL ERROR: DRIVER REQUIRES DMA BUFFER FOR 2D - UNLOADING DRIVER"));
                return(FALSE);
            }

            glintInfo->PXRXDMABuffer.size = size;
            glintInfo->PXRXDMABuffer.virtAddr = dmaVirt;
            glintInfo->PXRXDMABuffer.physAddr.LowPart = 0;
            glintInfo->PXRXDMABuffer.physAddr.HighPart = 0;
            glintInfo->usePXRXdma = USE_PXRX_DMA_FIFO;
            pxrxSetupFunctionPointers( ppdev );
        }

        ASSERTDD( glintInfo->PXRXDMABuffer.virtAddr != 0, "PXRX_DMA: The buffer has no virtual address!" );
        ASSERTDD( glintInfo->PXRXDMABuffer.size != 0,     "PXRX_DMA: The buffer has a zero size!" );

#       if PXRX_DMA_BUFFER_CHECK
        {
            ULONG   protSize = PXRX_DMA_BUFFER_CHECK_SIZE;
            ULONG   buffSize = (size - (protSize * 3)) / 2;
            ULONG   *ptr;
            /*
                  0k -  16k = 16k = protection zone 0
                 16k -  56k = (size - (16 * 3)) / 2 = buffer 0
                 56k -  72k = 16k = protection zone 1
                 72k - 112k = (size - (16 * 3)) / 2 = buffer 1
                112k - 128k = 16k = protection zone 2
            */
            glintInfo->pxrxDMA_bufferBase = dmaVirt;
            glintInfo->pxrxDMA_bufferTop  = &dmaVirt[size];

            gi_pxrxDMA.DMAaddrL[0]        = &dmaVirt[protSize];
            gi_pxrxDMA.DMAaddrEndL[0]    = gi_pxrxDMA.DMAaddrL[0]    + buffSize;
            gi_pxrxDMA.DMAaddrL[1]        = gi_pxrxDMA.DMAaddrEndL[0] + protSize;
            gi_pxrxDMA.DMAaddrEndL[1]    = gi_pxrxDMA.DMAaddrL[1]    + buffSize;

            for( ptr = dmaVirt; ptr < glintInfo->pxrxDMA_bufferTop; ptr++ )
                *ptr = (ULONG)(((ULONG_PTR) ptr) & 0x0FFFFFF0);

            DISPDBG((DBGLVL, "PXRX_DMA: prot 0   = 0x%08X -> 0x%08X", glintInfo->pxrxDMA_bufferBase, gi_pxrxDMA.DMAaddrL[0]));
            DISPDBG((DBGLVL, "PXRX_DMA: buffer 0 = 0x%08X -> 0x%08X", gi_pxrxDMA.DMAaddrL[0],     gi_pxrxDMA.DMAaddrEndL[0]));
            DISPDBG((DBGLVL, "PXRX_DMA: prot 1   = 0x%08X -> 0x%08X", gi_pxrxDMA.DMAaddrEndL[0],  gi_pxrxDMA.DMAaddrL[1]));
            DISPDBG((DBGLVL, "PXRX_DMA: buffer 1 = 0x%08X -> 0x%08X", gi_pxrxDMA.DMAaddrL[1],     gi_pxrxDMA.DMAaddrEndL[1]));
            DISPDBG((DBGLVL, "PXRX_DMA: prot 2   = 0x%08X -> 0x%08X", gi_pxrxDMA.DMAaddrEndL[1],  glintInfo->pxrxDMA_bufferTop));
        }
#       else    // PXRX_DMA_BUFFER_CHECK
            gi_pxrxDMA.DMAaddrL[0]      =  dmaVirt;
            gi_pxrxDMA.DMAaddrL[1]      = &dmaVirt[ size / 2 ];
            gi_pxrxDMA.DMAaddrEndL[0] = &dmaVirt[(size / 2) - 1];
            gi_pxrxDMA.DMAaddrEndL[1] = &dmaVirt[ size      - 1];
#       endif   // PXRX_DMA_BUFFER_CHECK

        gi_pxrxDMA.NTbuff   = 0;
        gi_pxrxDMA.NTptr    = gi_pxrxDMA.DMAaddrL[gi_pxrxDMA.NTbuff];
        gi_pxrxDMA.NTdone   = gi_pxrxDMA.NTptr;
        gi_pxrxDMA.P3at     = gi_pxrxDMA.NTptr;
#if PXRX_DMA_BUFFER_CHECK
        glintInfo->NTwait   = gi_pxrxDMA.NTptr;
#endif

        gi_pxrxDMA.DMAaddrP[0]      = dmaPhys + (DWORD)((UINT_PTR) gi_pxrxDMA.DMAaddrL[0]    - (UINT_PTR) dmaVirt);
        gi_pxrxDMA.DMAaddrP[1]      = dmaPhys + (DWORD)((UINT_PTR) gi_pxrxDMA.DMAaddrL[1]    - (UINT_PTR) dmaVirt);
        gi_pxrxDMA.DMAaddrEndP[0] = dmaPhys + (DWORD)((UINT_PTR) gi_pxrxDMA.DMAaddrEndL[0] - (UINT_PTR) dmaVirt);
        gi_pxrxDMA.DMAaddrEndP[1] = dmaPhys + (DWORD)((UINT_PTR) gi_pxrxDMA.DMAaddrEndL[1] - (UINT_PTR) dmaVirt);

        DISPDBG((DBGLVL, "PXRX_DMA: buffer 0 = 0x%08X -> 0x%08X", gi_pxrxDMA.DMAaddrL[0], gi_pxrxDMA.DMAaddrEndL[0]));
        DISPDBG((DBGLVL, "PXRX_DMA: buffer 1 = 0x%08X -> 0x%08X", gi_pxrxDMA.DMAaddrL[1], gi_pxrxDMA.DMAaddrEndL[1]));

#if PXRX_DMA_BUFFER_CHECK
        {
            extern ULONG inPxRxContextSwitch;
            inPxRxContextSwitch = TRUE;
            CHECK_PXRX_DMA_VALIDITY( CHECK_SWITCH, 0 );
            inPxRxContextSwitch = FALSE;
        }
#endif
    }

    // Allocate a GLINT context for this PDEV. Save the current context
    // if any and make us the current one but do this by hand since our
    // software copy will be junk if this is the very first PDEV.
    //
    DISPDBG((DBGLVL, "allocating new context"));

    // Create the 2D context:
    glintInfo->ddCtxtId = GlintAllocateNewContext(ppdev,
                                                  (ULONG *) pxrxRestore2DContext,
                                                  0, 0, NULL, ContextType_Fixed);

    if (glintInfo->ddCtxtId < 0)
    {
        DISPDBG((ERRLVL, "failed to allocate GLINT context for display driver"));
        return(FALSE);
    }

    DISPDBG((DBGLVL, "got context id 0x%x", glintInfo->ddCtxtId));

    GLINT_VALIDATE_CONTEXT(-1);
    ppdev->currentCtxt = glintInfo->ddCtxtId;

    DISPDBG((DBGLVL, "context id 0x%x is now current", glintInfo->ddCtxtId));

    if (ppdev->flCaps & CAPS_QUEUED_DMA)
    {
        DISPDBG((DBGLVL, "Enabling queued DMA for Gamma - initializing control regs"));

        READ_GLINT_CTRL_REG(GammaCommandMode, ulValue);
        ulValue |= GAMMA_COMMAND_MODE_QUEUED_DMA;
        WRITE_GLINT_CTRL_REG(GammaCommandMode, ulValue);
    }

    if( GLINT_GAMMA_PRESENT ) 
    {
        //
        // The disconnect should be setup correctly in the miniport. 
        // 

        glintInfo->PCIDiscEnabled = FALSE;

    } else {
 
        // Configure PCI disconnect
        //
        if (ppdev->cPelSize == GLINTDEPTH32)
        {
            glintInfo->PCIDiscEnabled = FALSE;
        }
        else
        {
            glintInfo->PCIDiscEnabled = USE_PCI_DISC_PERM;
        }

        // Enable/Disable PCI disconnect as required
        WRITE_GLINT_CTRL_REG(DisconnectControl, 
                             (glintInfo->PCIDiscEnabled ? DISCONNECT_INPUT_FIFO_ENABLE : 
                                                      DISCONNECT_INOUT_DISABLE));
    }

    // We only want to check the FIFO if disconnect is disabled.
    glintInfo->CheckFIFO = !glintInfo->PCIDiscEnabled;

    // Setup DMA control on GMX or PXRX
    {
        ULONG DMAControl = DMA_CONTROL_USE_PCI;

        if (!(ppdev->flCaps & CAPS_USE_AGP_DMA))
        {
            DMAControl = DMA_CONTROL_USE_PCI;                // AGP not enabled use PCI master DMA
        }
        else
        {
            DMAControl = 2;                                    // PXRX: use AGP master DMA
            // When using AGP SideBandAddressing, the following tweak should be a performance gain
            WRITE_GLINT_CTRL_REG (AGPControl, AGP_LONG_READ_DISABLE );
        }
        // Write DMA control
        WRITE_GLINT_CTRL_REG (DMAControl, DMAControl);
    }

    // there are many mode registers we never use so we must disable them.
    //
    vInitCoreRegisters(ppdev);

    ulValue = 32;

    DISPDBG((DBGLVL, "Using block fill of width %d pixels", ulValue));
    glintInfo->fastFillBlockSz = ulValue;
    glintInfo->fastFillSupport = __RENDER_FAST_FILL_INC(ulValue);
    glintInfo->renderFastFill  = __RENDER_FAST_FILL_ENABLE |
                                 __RENDER_FAST_FILL_INC(ulValue);

    // On a Geo Twin we disable the pointer cache and brush cache.
    // and on a delta-based Geo Twin we disable off-screen bitmaps too, 
    // because they slow things down.

    if (ppdev->flCaps & CAPS_SPLIT_FRAMEBUFFER)
    {
        // Gamma boards can have off-screen bitmaps, because Gamma has 
        // something called the multi-glint aperture.
        if (GLINT_DELTA_PRESENT)
            ppdev->flStatus &= ~(STAT_DEV_BITMAPS | ENABLE_DEV_BITMAPS);

//@@BEGIN_DDKSPLIT
    //  ppdev->flStatus &= ~(ENABLE_POINTER_CACHE);
    //  ppdev->flStatus &= ~(ENABLE_BRUSH_CACHE);
    //  ppdev->flStatus &= ~(ENABLE_GLYPH_CACHE);
//@@END_DDKSPLIT
    }

    // initially assume that we do not have an off-screen buffer for
    // bitblt and full screen double buffering. So set all buffer offsets
    // to zero. This may get overriden when we init the off-screen heap.
    //
    for (i = 0; i < GLINT_NUM_SCREEN_BUFFERS; ++i)
    {
        glintInfo->bufferOffset[i] = 0;
        glintInfo->bufferRow[i]    = 0;
    }

    // Initialise back-buffer POH
    glintInfo->backBufferPoh = NULL;
    glintInfo->GMX2KLastLine = 0;

    // Work out our double buffering requirements. First read the registry to
    // find out if we need an off-screen buffer. If not then we have nothing
    // to do. We want an off-screen buffer if the string exists and the
    // buffer count is >= 2. For the moment values > 2 mean use two buffers.
    // i.e. we don't support triple or quad buffering etc.
    // Note, for GLINT we assume that the extra buffer always lives
    // below the visible buffer (i.e. not to the right).
    // If the variable doesn't exist, assume 2 buffers.
    //
    bCreateBackBuffer = FALSE;
    bCreateStereoBuffers = FALSE;
    bExists = bGlintQueryRegistryValueUlong(ppdev,
                                     REG_NUMBER_OF_SCREEN_BUFFERS,
                                     &ulValue);
    if (!bExists)
    {
        ulValue = 2;
    }
    if ((ulValue >= 2) && (ppdev->cyMemory >= (ppdev->cyScreen << 1)))
    {
//@@BEGIN_DDKSPLIT

        //ULONG   ulValue;
        LONG    leftOffset;
        LONG    byteTotal;
        LONG    lTotal;
        ULONG   rowSz;

//      if (GLINT_PXRX)        // ???   
        if (1)
        {
#if 0
            // if we have enough SGRAM then we can support both BLT and
            // full screen double buffering.

            glintInfo->flags |= GLICAP_BITBLT_DBL_BUF |
                                GLICAP_FULL_SCREEN_DBL_BUF;
            cx = ppdev->cxMemory;
            cy = ppdev->cyScreen;
            lTotal = cx * cy;
            rowSz = 1;
            leftOffset = 0;
#else
//@@END_DDKSPLIT
            bCreateBackBuffer = TRUE;
//@@BEGIN_DDKSPLIT
            goto ConfigurePermediaBuffers;
#endif
        }
        else
        {
            // we have enough VRAM so we at least support BLT double buffering
            glintInfo->flags |= GLICAP_BITBLT_DBL_BUF;

            // read FBModeSel to get the interleave etc. We're only interested in
            // whether we are up to 2-way or 4-way, so the left shift is adequate.
            // i.e. I don't care that (0 << 1) is "zero-way" rather than 1-way.
            //
            cx = ppdev->cxMemory;
            cy = ppdev->cyScreen;
            lTotal = cx * cy;

//@@BEGIN_DDKSPLIT
// AZN This code was originally not being used
#if 0
            if (ppdev->flCaps & CAPS_SPLIT_FRAMEBUFFER)
            {
                OH  *pohTmp;
                ULONG NumpadLines;
                LONG halfWay = ppdev->FrameBufferLength >> 1;        // TMM: This was FOUR_MB
          
                NumpadLines = ((halfWay / ppdev->lDelta) - ppdev->cyScreen; & ~1;
                DISPDBG((DBGLVL, "Allocating padding bitmap of size %d x %d", 
                                 cx, NumpadLines));
                pohTmp = pohAllocate(ppdev, NULL, cx, NumpadLines, 0);
                ASSERTDD(pohTmp != NULL, "pad buffer could not be allocated");

                // now allocate the actual back buffer
                cy = ((((halfWay + ppdev->lDelta - 1) / ppdev->lDelta) - NumpadLines) + 1) & ~1;
                DISPDBG((DBGLVL, "Allocating Racer back buffer of size %d x %d", cx, cy));
                poh = pohAllocate(ppdev, NULL, cx, cy, FLOH_MAKE_PERMANENT);
                ASSERTDD((poh != NULL) && (poh->x == 0) && (poh->y == (halfWay / ppdev->lDelta)),
                            "Racer off-screen buffer allocated in incorrect position");
                DISPDBG((DBGLVL, "Racer back buffer at %d, %d", poh->x, poh->y));

                // as far as the 3D ext is concerned, the buffer lives at the
                // pixel address of the half-way boundary, but the VTGFrameRowAddr
                // is zero. We will examine the (GLICAP_RACER_BANK_SELECT |
                // GLICAP_ENHANCED_TX_BANK_SELECT) bits at swap time to see which
                // register we should load.
                //
                glintInfo->bufferOffset[1] = halfWay >> ppdev->cPelSize;
                glintInfo->bufferRow[1] = 0;
                DISPDBG((DBGLVL, "Racer offscreen buffer at offset 0x%x", GLINT_BUFFER_OFFSET(1)));

                // release the temporary buffer. We can use this as off-screen
                // memory.
                pohFree(ppdev, pohTmp);
            }
#endif
//@@END_DDKSPLIT

            // now see if we can handle full screen double buffering. This has
            // a slightly more stringent requirement because the second buffer
            // must start on a VRAM RAS line. OK, here's the equation for the
            // number of pixels per RAS line:
            //  512 * interleave_size * width_in_dwords * pixels_per_dword
            // The only dodgy number here is 512 but I am assured that all
            // the VRAMs that GLINT supports have this shift register size.
            //
            READ_GLINT_CTRL_REG (FBModeSel, ulValue);
            DISPDBG((DBGLVL, "FBModeSel = 0x%x", ulValue));
            rowSz = 512 << ((ulValue & 1)        +    // width in dwords
                            ((ulValue >> 8) & 3) +    // interleave value
                            (2 - ppdev->cPelSize));   // pixels per dword
            DISPDBG((DBGLVL, "got FrameRow of size 0x%x pixels", rowSz));

            // we have the RAS line size, so we must ensure that the second
            // buffer starts at a multiple of this many pixels from the
            // origin. This may not be zero in x since the screen stride may
            // not be a multiple of this number. So we calculate the number
            // of extra scanlines we need to span a full buffer that starts
            // on a RAS line boundary. Note, we know that rowSz is a
            // power of 2 so we can subtract 1 to get a mod mask.
            //
            leftOffset = (ULONG)(-lTotal) & (rowSz - 1);
            cy += (leftOffset + (cx-1)) / cx;

            // cx and cy are now the dimensions of the off-screen buffer we
            // want, including the extra scanlines needed to align the full
            // screen buffer. Since cy may have increased, again check we
            // have enough VRAM. If not then the full-screen alignment will
            // have caused us to run over the end. In this case we can position
            // the off-screen buffer immediately after the screen but we can't
            // offset into it the number of pixels required to align a
            // full-screen double buffer.
            //
            if ((ppdev->cyScreen + cy) <= ppdev->cyMemory)
            {
                // We can use VTGRowAddress if:
                //   we don't cross a 4MB boundary or
                //   (we have an interleave factor of 4 and we don't have an Omnicomp 3Demon Pro16)
                // else we can use Racer bank select if we have a Racer board.
                //
                if ((glintInfo->deviceInfo.BoardId == GLINT_RACER) ||
                    (glintInfo->deviceInfo.BoardId == GLINT_RACER_PRO) ||
                    (glintInfo->deviceInfo.BoardId == OMNICOMP_3DEMONPRO) ||
                    (glintInfo->deviceInfo.BoardId == GEO_TWIN_BOARD) ||
                    (glintInfo->deviceInfo.BoardId == ACCELPRO_BOARD) ||
                    (glintInfo->deviceInfo.BoardId == ELSA_GLORIA_XL) ||
                    (glintInfo->deviceInfo.BoardId == ELSA_GLORIA))
                {
                    glintInfo->flags |= GLICAP_FULL_SCREEN_DBL_BUF |
                                        GLICAP_RACER_DOUBLE_WRITE;

                    // The 3Demon Pro16 board does not support, enhanced
                    // mode bank-switching.
                    if ((ppdev->flCaps & CAPS_ENHANCED_TX) && 
                        (!IS_RACER_VARIANT_PRO16(ppdev)))
                    {
                        DISPDBG((DBGLVL, "Enhanced TX full-screen buffering"));
                        glintInfo->flags |= GLICAP_ENHANCED_TX_BANK_SELECT;
                    }
                    else
                    {
                        DISPDBG((DBGLVL, "Racer bank select full-screen buffering"));
                        glintInfo->flags |= GLICAP_RACER_BANK_SELECT;
                    }
                }
                else if (((ppdev->cyScreen + cy) * ppdev->lDelta <= FOUR_MB) ||
                         ((!IS_RACER_VARIANT_PRO16(ppdev))))
                {
                    DISPDBG((DBGLVL, "VTGFrameRowAddress full-screen buffering"));
                    glintInfo->flags |= GLICAP_FULL_SCREEN_DBL_BUF;
                }
            }
            else
                cy = ppdev->cyScreen;
        }

        if (glintInfo->flags & (GLICAP_RACER_BANK_SELECT |
                                GLICAP_ENHANCED_TX_BANK_SELECT))
        {
            // The second buffer must start in the second half of the frame
            // buffer (i.e. at 4MB for an 8MB card and 8MB for a 16MB card) so
            // allocate enough off-screen heap to pad up to the scanline
            // before this boundary. Then we allocate enough lines so that
            // we can move the buffer start to 4MB.
            //
            OH  *pohTmp;
            ULONG padLines;
            LONG halfWay = ppdev->FrameBufferLength >> 1;  // This was FOUR_MB
            LONG lScreenDelta;

            lScreenDelta = ppdev->lDelta;
         
            padLines = (halfWay / lScreenDelta) - ppdev->cyScreen;
            if (ppdev->flCaps & CAPS_SPLIT_FRAMEBUFFER)
                padLines &= ~1; // make number of pad lines even
            DISPDBG((DBGLVL, "Allocating padding bitmap of size %d x %d", ppdev->cxScreen, padLines));
            pohTmp = pohAllocate(ppdev, NULL, ppdev->cxScreen, padLines, 0);
            ASSERTDD(pohTmp != NULL, "pad buffer could not be allocated");
            DISPDBG((DBGLVL, "Racer padding bitmap at %d, %d", pohTmp->x, pohTmp->y));

            // now allocate the actual back buffer
            cy = ((halfWay + lScreenDelta - 1) / lScreenDelta) - padLines;
            if (ppdev->flCaps & CAPS_SPLIT_FRAMEBUFFER)
                cy = (cy + 1) & ~1; // round up to make even
            DISPDBG((DBGLVL, "Allocating Racer back buffer of size %d x %d", ppdev->cxScreen, cy));
            poh = pohAllocate(ppdev, NULL, ppdev->cxScreen, cy, FLOH_MAKE_PERMANENT);
            if (ppdev->flCaps & CAPS_SPLIT_FRAMEBUFFER) {
                ASSERTDD((poh != NULL) && (poh->x == 0) && (poh->y <= (halfWay / lScreenDelta)) && (poh->y >= ((halfWay / lScreenDelta) - 1)),
                        "Racer back buffer allocated in incorrect position");
            } else {
                ASSERTDD((poh != NULL) && (poh->x == 0) && (poh->y == (halfWay / lScreenDelta)),
                        "Racer back buffer allocated in incorrect position");
            }
            DISPDBG((DBGLVL, "Racer back buffer at %d, %d", poh->x, poh->y));

            // as far as the 3D ext is concerned, the buffer lives at the
            // pixel address of the half-way boundary, but the VTGFrameRowAddr
            // is zero. We will examine the (GLICAP_RACER_BANK_SELECT |
            // GLICAP_ENHANCED_TX_BANK_SELECT) bits at swap time to see which
            // register we should load.
            //
            glintInfo->bufferOffset[1] = halfWay >> ppdev->cPelSize;
            if (ppdev->flCaps & CAPS_SPLIT_FRAMEBUFFER)
                glintInfo->bufferOffset[1] >>= 1;
            glintInfo->bufferRow[1] = 0;
            DISPDBG((DBGLVL, "Racer offscreen buffer at offset 0x%x", GLINT_BUFFER_OFFSET(1)));

            // Save the back-buffer POH
            glintInfo->backBufferPoh = poh;

            // release the temporary buffer. We can use this as off-screen
            // memory.
            pohFree(ppdev, pohTmp);
 
            if (cy > ppdev->cyScreen)
            {
                POINTL ptl;
                OH * pohtmptmp;
                LONG lpadLines;
                
                // Calculate padding, ensuring on a Geo we always allocate an
                // even number
                lpadLines = (cy - ppdev->cyScreen) + 1;
                if (ppdev->flCaps & CAPS_SPLIT_FRAMEBUFFER && (lpadLines & 0x1))
                    lpadLines++;

                ptl.x = 0;                    // Allocate strip directly after the front buffer
                ptl.y = ppdev->cyScreen;

                pohtmptmp = pohAllocate (ppdev, &ptl, ppdev->cxScreen, lpadLines, FLOH_MAKE_PERMANENT);

                ASSERTDD (pohtmptmp, "16BPP Pad buffer alloc failed");
            }
        }
        else
        {
            // Allocate the off-screen buffer. When we get it back, its
            // position should be immediately below the visible screen.
            // Since we have checked that we have enough VRAM and GLINT
            // never has off-screen memory to the right, it will fail only
            // if we get our logic mixed up. e.g. if the initialization
            // routines were re-ordered so that the brush cache got called
            // before this routine.
            //
            poh = pohAllocate(ppdev, NULL, cx, cy, FLOH_MAKE_PERMANENT);
            ASSERTDD((poh != NULL) && (poh->x == 0) && (poh->y == ppdev->cyScreen),
             "off-screen buffer allocated in incorrect position");

            DISPDBG((DBGLVL, "allocated off-screen buffer at (%d,%d), w %d h %d",
                            poh->x, poh->y, poh->cx, poh->cy));
            glintInfo->bufferOffset[1] = lTotal;
            if (GLINT_FS_DBL_BUF)
            {
                glintInfo->bufferOffset[1] += leftOffset;
                glintInfo->bufferRow[1] = (lTotal + leftOffset) / rowSz;
                ASSERTDD(GLINT_BUFFER_OFFSET(1)%rowSz == 0, "off-screen buffer origin not on RAS line");
            }
            else
                leftOffset = 0;
            DISPDBG((DBGLVL, "offscreen buffer at offset 0x%x", GLINT_BUFFER_OFFSET(1)));
        }
                    
#ifdef LATER
            // We want to create a DIB and surface for the off-screen bitmap.
            // However, the bitmap must start at the correct origin. i.e. if
            // we had to offset the origin to match the VRAM page size (for
            // full screen double buffering) we must move the origin in the
            // poh. Since the node is allocated permanently we don't have to
            // worry about changing poh->x and poh->y. Famous last words?
            //
            if (leftOffset > 0)
            {
                poh->x += leftOffset % ppdev->cxMemory;
                poh->y += leftOffset / ppdev->cxMemory;
            }

            // allocate our DSURF object for the off-screen buffer.
            //
            pdsurf = ENGALLOCMEM(FL_ZERO_MEMORY, 
                                 sizeof(DSURF), 
                                 ALLOC_TAG_GDI(C));
            if (pdsurf == NULL)
            {
                DISPDBG((ERRLVL, "bInitializeGlint - Failed pdsurf allocation"));
                return(FALSE);
            }

            ppdev->pdsurfOffScreen = pdsurf;        // Remember it for clean-up

            pdsurf->poh     = poh;
            poh->pdsurf     = pdsurf;
            pdsurf->dt      = DT_SCREEN;
            pdsurf->bOffScreen = TRUE;            
            pdsurf->sizl.cx = ppdev->cxScreen;  // the poh may be bigger but
            pdsurf->sizl.cy = ppdev->cyScreen;  //  this is the valid size.
            pdsurf->ppdev   = ppdev;

            if (!bCreateScreenDIBForOH(ppdev, poh, HOOK_SYNCHRONIZE))
            {
                DISPDBG((WRNLVL, "bCreateScreenDIBForOH failed for off-screen buffer"));
                return(FALSE);
            }
            if(pdsurf->pso)
            {
                DISPDBG((DBGLVL, "pdsurf->pso for off-screen memory:"));
                DISPDBG((DBGLVL, "DHSURF 0x%x", pdsurf->pso->dhsurf));
                DISPDBG((DBGLVL, "HSURF 0x%x", pdsurf->pso->hsurf));
                DISPDBG((DBGLVL, "DHPDEV 0x%x", pdsurf->pso->dhpdev));
                DISPDBG((DBGLVL, "sizlBitmap %d, %d", pdsurf->pso->sizlBitmap.cx, pdsurf->pso->sizlBitmap.cy));
                DISPDBG((DBGLVL, "cjBits 0x%x", pdsurf->pso->cjBits));
                DISPDBG((DBGLVL, "pvBits 0x%x", pdsurf->pso->pvBits));
                DISPDBG((DBGLVL, "pvScan0 0x%x", pdsurf->pso->pvScan0));
                DISPDBG((DBGLVL, "lDelta %d", pdsurf->pso->lDelta));
                DISPDBG((DBGLVL, "iBitmapFormat 0x%x", pdsurf->pso->iBitmapFormat));
                DISPDBG((DBGLVL, "iType 0x%x", pdsurf->pso->iType));
                DISPDBG((DBGLVL, "fjBitmap 0x%x", pdsurf->pso->fjBitmap));
            }
#endif  // LATER
//@@END_DDKSPLIT
    }

//@@BEGIN_DDKSPLIT
ConfigurePermediaBuffers:
//@@END_DDKSPLIT

    // Work out the position and sizes for Z buffer and texture memory.
    // For PERMEDIA we need to reserve these with the heap manager since we
    // have a unified memory. For the moment, we will use all the available
    // extra memory for textures. Maybe later make it configurable to allow
    // the 2D driver some off-screen memory.
    // NB. P2 allocates a font cache here, it may be preferable to use the
    //     registry to determine the size of the cache

    LOCALBUFFER_PIXEL_WIDTH  = 0;    // bits
    LOCALBUFFER_PIXEL_OFFSET = 0;    // Z pels
    LOCALBUFFER_PIXEL_COUNT  = 0;    // Z pels
    FONT_MEMORY_OFFSET       = 0;    // dwords
    FONT_MEMORY_SIZE         = 0;    // dwords
    TEXTURE_MEMORY_OFFSET    = 0;    // dwords
    TEXTURE_MEMORY_SIZE      = 0;    // dwords

    {
        ULONG       cjGlyphCache;
        LONG        LBPelSize, PatchWidth, PatchRemainder, ZScreenWidth;
        ULONG       cyPermanentCaches, cyGlyphCache, cyPointerCache;
        LONG yOrg, ZHeight;

        cjGlyphCache = 300 * 1024;

//@@BEGIN_DDKSPLIT
#if 0
        // we don't have a brush cache for these chips
        ppdev->flStatus &= ~ENABLE_BRUSH_CACHE;
#endif
//@@END_DDKSPLIT

        // 3D extension fails if we have no textures or Z buffer but still
        // operates without a back buffer. So if we don't have enough
        // memory for Z or textures then abort buffer configuration.
        // (if width=16 => pelsize=1,patchwidth=128)
        LOCALBUFFER_PIXEL_WIDTH = 32;
        LBPelSize = 2;
        PatchWidth = 64;

        DISPDBG((DBGLVL, "bInitializeGlint: P3 Localbuffer width set to %i", LOCALBUFFER_PIXEL_WIDTH ));

        if (ppdev->cPelSize >= LBPelSize)
        {
            ZHeight = ppdev->cyScreen >> (ppdev->cPelSize - LBPelSize);
        }
        else
        {
            ZHeight = ppdev->cyScreen << (LBPelSize - ppdev->cPelSize);
        }

        bCreateBackBuffer = TRUE;

        // Decide if we want to allocate some stereo buffers.
        if(ppdev->flCaps & CAPS_STEREO)
        {
            bCreateStereoBuffers = TRUE;
        }

        cy  = ppdev->cyScreen;          // front buffer height
        cy += ZHeight;                  // add on Z buffer height
        cy += TEXTURE_OH_MIN_HEIGHT;    // minimum required texture memory

        if (cy > ppdev->cyMemory)
        {
            // Start DirectDraw after the end of the screen
            ppdev->heap.DDrawOffscreenStart = ppdev->cxMemory * ppdev->cyScreen;
            DISPDBG((ERRLVL, "not enough memory for 3D buffers, dd: 0x%x\n", ppdev->heap.DDrawOffscreenStart));
            goto CompletePermediaBuffers;
        }

        // is there room for a back buffer?

        if ((cy + ppdev->cyScreen) > ppdev->cyMemory)
        {
            bCreateBackBuffer = FALSE;
        }
        else if (bCreateBackBuffer)
        {
            cy += ppdev->cyScreen;
        }

        // is there room for stereo buffers?
        if ((cy + (2*ppdev->cyScreen)) > ppdev->cyMemory)
        {
            bCreateStereoBuffers = FALSE;
        }
        else if (bCreateStereoBuffers)
        {
            cy += (2*ppdev->cyScreen);
        }

        // cy is now the total length of all buffers required for 3D.
        // cyPermanentCaches is the combined height of the 2D caches that lie between the front & back buffers
        cyPermanentCaches = 0;

        // yOrg is the start of offscreen memory
        yOrg = ppdev->cyScreen + cyPermanentCaches;

        if (bCreateBackBuffer)
        {
            glintInfo->flags |= GLICAP_BITBLT_DBL_BUF | GLICAP_FULL_SCREEN_DBL_BUF;

            if (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_BACK)
            {
                ULONG   bb, patchWidth, patchSize, x, y;

/*
                        Align   Size    cPelSize    2 - cPS     4 - cPS
                32bpp:  0x100   0x1000      2        0 >> 1      2 >>  4
                16bpp:  0x 80   0x 800      1        1 >> 2      3 >>  8
                 8bpp:  0x 40   0x 400      0        2 >> 4      4 >> 16

            patchSize = 0x400 << ppdev->cPelSize;    // Bytes
            regAlign  =  0x40 << ppdev->cPelSize;    // 128 bits

            reg = bufferOffset >> (4 - ppdev->cPelSize);
            bufferOffsetAlignment = regAlign << (4 - ppdev->cPelSize);    // 1024
                                = (0x40 << ppdev->cPelSize) << (4 - ppdev->cPelSize);
                                = 0x40 << 4;
                                = 1024;

            NB: verticalAlignment = 16 scanlines;
*/
                bb = ((ppdev->cxMemory * yOrg) + 1023) & ~1023;
                if( bb % ppdev->cxMemory )
                    bb = (bb / ppdev->cxMemory) + 1;
                else
                    bb = bb / ppdev->cxMemory;
                bb = (bb + 15) & ~15;
                bb *= ppdev->cxMemory;

                ppdev->heap.DDrawOffscreenStart =            // Save DirectDraw off-screen offset
                    glintInfo->bufferRow[1]    =
                    glintInfo->bufferOffset[1] = bb;

                x = bb % ppdev->cxMemory;
                y = bb / ppdev->cxMemory;
                glintInfo->backBufferXY = (x & 0xFFFF) | (y << 16);
                //LOAD_FBWRITE_OFFSET( 1, glintInfo->backBufferXY );

                yOrg = y + ppdev->cyScreen;    // Y origin of next buffer
            } 
            else 
            {
                ppdev->heap.DDrawOffscreenStart =        // Save DirectDraw off-screen offset
                glintInfo->bufferRow[1]    =
                glintInfo->bufferOffset[1] = ppdev->cxMemory * yOrg;
                glintInfo->backBufferXY = yOrg << 16;
                //LOAD_FBWRITE_OFFSET( 1, glintInfo->backBufferXY );
                yOrg += ppdev->cyScreen;    // Y origin of next buffer
            }
            DISPDBG((DBGLVL, "offscreen buffer at offset 0x%x", GLINT_BUFFER_OFFSET(1)));
        } 
        else 
        {
            // DirectDraw can use the memory that is left over
            ppdev->heap.DDrawOffscreenStart = ppdev->cxMemory * yOrg;
            DISPDBG((DBGLVL, "No Permedia back buffer being created dd: 0x%x", ppdev->heap.DDrawOffscreenStart));
        }

        // Setup stereo front and back buffers if they're required.
        // We just place them directly after the back buffer.
        // Patching requirements should be satisfied as long as the
        // front and back are patched/unpatched together.
        if (bCreateStereoBuffers)
        {
            // Stereo back buffer
            glintInfo->backRightBufferXY = (glintInfo->backBufferXY + (ppdev->cyScreen << 16));
            glintInfo->bufferRow[2] = glintInfo->bufferOffset[2] =
            (glintInfo->bufferOffset[1] + (ppdev->cxMemory * ppdev->cyScreen));

            // Stereo front buffer
            glintInfo->frontRightBufferXY = glintInfo->backRightBufferXY + (ppdev->cyScreen << 16);
            glintInfo->bufferRow[3] = glintInfo->bufferOffset[3] =
            (glintInfo->bufferOffset[2] + (ppdev->cxMemory * ppdev->cyScreen));

            
            yOrg += (2*ppdev->cyScreen);    // Y origin of next buffer
            
            // We successfully allocated stereo buffers so set the flag.
            glintInfo->flags |= GLICAP_STEREO_BUFFERS;
        }
        else
        {
            // If we aren't in stereo mode then set the right buffers to their
            // left equivalents.
            glintInfo->frontRightBufferXY = 0;
            glintInfo->backRightBufferXY = glintInfo->backBufferXY;
            glintInfo->bufferRow[2] = glintInfo->bufferOffset[2] = glintInfo->bufferOffset[1];
            glintInfo->bufferRow[3] = glintInfo->bufferOffset[3] = glintInfo->bufferOffset[0];
        }

        {
            // Place the local buffer at end of memory (picks up dedicated page selector).
            // Textures are placed between the back buffer and the local buffer memory.
            // The width of the local buffer is controlled via a registry variable.
            
            ULONG TopOfLBMemoryDwords ;


            // If the screen width is not a multiple of the patch size then
            // we allocate a slightly larger Z buffer which is.
            if(PatchRemainder = ppdev->cxScreen % PatchWidth)
            {
                ZScreenWidth = ppdev->cxScreen + (PatchWidth - PatchRemainder);
            }
            else
            {
                ZScreenWidth = ppdev->cxScreen;
            }
            // Store the actual Z buffer width
            glintInfo->P3RXLocalBufferWidth = ZScreenWidth;

            LOCALBUFFER_PIXEL_COUNT = ppdev->cyScreen * ZScreenWidth ;
            
            // LB offset in units of LB pixels
            {
                ULONG TotalMemoryInDwords = (ppdev->cyMemory * ppdev->cxMemory) >> (2 - ppdev->cPelSize) ;
                
                // Working in unit of LB pixels, and working backwards from the end of memory               
                LOCALBUFFER_PIXEL_OFFSET = TotalMemoryInDwords << (2 - LBPelSize) ;
                // Ensure the top left of the last patch starts on a patch boundary
                LOCALBUFFER_PIXEL_OFFSET -= LOCALBUFFER_PIXEL_OFFSET % (PatchWidth*16);

                // Calculate the start of the local buffer memory (used later)
                TopOfLBMemoryDwords = (LOCALBUFFER_PIXEL_OFFSET - LOCALBUFFER_PIXEL_COUNT) >> (2 - LBPelSize) ;

                // Need to subtract one row of patches because origin is at start of 
                // last row of patches
                LOCALBUFFER_PIXEL_OFFSET -= (ZScreenWidth*16) ;
                // Add the offset of the bottom left pixel within the bottom left
                // patch.
                LOCALBUFFER_PIXEL_OFFSET += PatchWidth*15;
            }
            
            DISPDBG((DBGLVL, "bInitializeGlint: P3 cxScreen %i cyScreen %i cPelSize %i", ppdev->cxScreen, ppdev->cyScreen, ppdev->cPelSize));
            DISPDBG((DBGLVL, "bInitializeGlint: P3 cxMemory %i cyMemory %i cPelSize %i", ppdev->cxMemory, ppdev->cyMemory, ppdev->cPelSize));
            DISPDBG((DBGLVL, "bInitializeGlint: P3 LOCALBUFFER_PIXEL_OFFSET %i LOCALBUFFER_PIXEL_COUNT %i ", LOCALBUFFER_PIXEL_OFFSET, LOCALBUFFER_PIXEL_COUNT));

            // Texture memory offset in DWORDS
            TEXTURE_MEMORY_OFFSET = (ppdev->cxMemory * yOrg) >> (2 - ppdev->cPelSize); 
            
            // Texture size calculation
            if (TopOfLBMemoryDwords > TEXTURE_MEMORY_OFFSET)
            {
                TEXTURE_MEMORY_SIZE = TopOfLBMemoryDwords - TEXTURE_MEMORY_OFFSET ;
            }
            else
            {
                TEXTURE_MEMORY_SIZE = 0 ;
            }
                
            DISPDBG((DBGLVL, "bInitializeGlint: P3 TEXTURE_MEMORY_OFFSET %i", TEXTURE_MEMORY_OFFSET));
            DISPDBG((DBGLVL, "bInitializeGlint: P3 TEXTURE_MEMORY_SIZE in dwords %i", TEXTURE_MEMORY_SIZE));
        }

#       if DBG
        {
            ULONG   lbS, lbE, tS, tE;
            DISPDBG((DBGLVL, "bIGlint: front buffer = 0x%08Xp (%4dL) -> 0x%08Xp (%4dL)", glintInfo->bufferOffset[0], glintInfo->fbWriteOffset[0] >> 16, glintInfo->bufferOffset[0] + (ppdev->cyScreen * ppdev->cxMemory), (glintInfo->fbWriteOffset[0] >> 16) + ppdev->cyScreen));
            DISPDBG((DBGLVL, "bIGlint:  back buffer = 0x%08Xp (%4dL) -> 0x%08Xp (%4dL)", glintInfo->bufferOffset[1], glintInfo->backBufferXY     >> 16, glintInfo->bufferOffset[1] + (ppdev->cyScreen * ppdev->cxMemory), (glintInfo->backBufferXY     >> 16) + ppdev->cyScreen));
            lbS = LOCALBUFFER_PIXEL_OFFSET - (ZScreenWidth * (ppdev->cyScreen - 1));
            lbE = LOCALBUFFER_PIXEL_OFFSET + ZScreenWidth;
            if( ppdev->cPelSize >= LBPelSize ) {
                lbS = lbS >> (ppdev->cPelSize - LBPelSize);
                lbE = lbE >> (ppdev->cPelSize - LBPelSize);
            } else {
                lbS = lbS << (LBPelSize - ppdev->cPelSize);
                lbE = lbE << (LBPelSize - ppdev->cPelSize);
            }
            lbS /= ppdev->cxMemory;     lbE /= ppdev->cxMemory;
            DISPDBG((DBGLVL, "bIGlint: local buffer = 0x%08Xp (%4dL) -> 0x%08Xp (%4dL)", LOCALBUFFER_PIXEL_OFFSET - (ZScreenWidth * (ppdev->cyScreen - 1)), lbS, LOCALBUFFER_PIXEL_OFFSET + ZScreenWidth, lbE));
            tS = (TEXTURE_MEMORY_OFFSET << (2 - ppdev->cPelSize)) / ppdev->cxMemory;
            tE = (TEXTURE_MEMORY_SIZE   << (2 - ppdev->cPelSize)) / ppdev->cxMemory;
            DISPDBG((DBGLVL, "bIGlint:      texture = 0x%08Xx (%4dL) + 0x%08Xx = 0x%08Xx (%4dL)", TEXTURE_MEMORY_OFFSET, tS, TEXTURE_MEMORY_SIZE, TEXTURE_MEMORY_OFFSET + TEXTURE_MEMORY_SIZE, tS + tE));
        }
#       endif
    }

CompletePermediaBuffers:
    
    // work out the fudge factor to add onto VTGVLineNumber to get the current
    // video scanline. VTGVLineNumber returns VTGVLimit for the last visible
    // line on the screen and 1 for line after that. Use the
    // GLINT_GET_VIDEO_SCANLINE macro to retrieve the current scanline.
    //
    READ_GLINT_CTRL_REG (VTGVLimit, glintInfo->vtgvLimit);
    glintInfo->scanFudge = glintInfo->vtgvLimit - ppdev->cyScreen + 1;
   
    // work out partial products for the screen stride. We need to record
    // the products for 8, 16 and 32 bit width 'pixels', only one is the
    // correct width, but we want to be able to pretend to use 16 and 32
    // bit pixels occasionally on an 8 bit pixel framestore for speed.

    cPelSize = ppdev->cPelSize;
    if(cPelSize == GLINTDEPTH24)
    {
        // 24bpp: special case (3 bytes per pixel)
        width = ppdev->cxMemory * 3;
    }
    else
    {
        width = ppdev->cxMemory << cPelSize;    // width of framestore in bytes
    }

    DISPDBG((DBGLVL, "assuming screen stride is %d bytes\n", width));

    // Hardware write mask emulation with DRAMS works for byte masks only
    // I.e. 0xFF00FF00 will work, 0x0FF00FF0 will not.

    READ_GLINT_CTRL_REG( LocalMemCaps, ulValue );
    if (ulValue & (1 << 28))
    {
        glintInfo->flags |= GLICAP_HW_WRITE_MASK_BYTES;
    }
    else
    {
        glintInfo->flags |= GLICAP_HW_WRITE_MASK;
    }
  
    DISPDBG((DBGLVL, "bInitializeGlint OK"));

#if DBG
    // print this stuff out for debugging purposes
    if (GLINT_HW_WRITE_MASK)
        DISPDBG((DBGLVL, "Hardware Writemasking enabled"));

    ASSERTDD(!GLINT_CS_DBL_BUF, "Color Space double buffering enabled");

    if (GLINT_FS_DBL_BUF)
    {
        DISPDBG((DBGLVL, "Full screen double buffering enabled"));
        DISPDBG((DBGLVL, "second buffer at pixel offset 0x%x, origin (%d,%d), RowAddr %d",
            GLINT_BUFFER_OFFSET(1),
            GLINT_BUFFER_OFFSET(1) % ppdev->cxMemory,
            GLINT_BUFFER_OFFSET(1) / ppdev->cxMemory,
            glintInfo->bufferRow[1]));
    }
    if (GLINT_BLT_DBL_BUF)
    {
        DISPDBG((DBGLVL, "BITBLT double buffering enabled"));
        DISPDBG((DBGLVL, "second buffer at pixel offset 0x%x, origin (%d,%d)",
            GLINT_BUFFER_OFFSET(1),
            GLINT_BUFFER_OFFSET(1) % ppdev->cxMemory,
            GLINT_BUFFER_OFFSET(1) / ppdev->cxMemory));
    }
    if (GLINT_FAST_FILL_SIZE > 0)
        DISPDBG((DBGLVL, "using fast fill size of %d (%s fast fill bug workarounds)",
            GLINT_FAST_FILL_SIZE, GLINT_FIX_FAST_FILL ? "need" : "don't need"));
#endif  // DBG

    return(TRUE);
    
} // bInitializeGlint

/******************************Public*Routine******************************\
* VOID vDisableGlint
*
* Do whatever we need to when the surface is disabled.
*
\**************************************************************************/

VOID vDisableGlint(PPDEV ppdev)
{
    DSURF*  pdsurf;
    GLINT_DECL;

    if (!glintInfo)
        return;

    if (glintInfo->PXRXDMABuffer.virtAddr && glintInfo->PXRXDMABuffer.physAddr.LowPart == 0)
    {
        DISPDBG((DBGLVL, "DrvDisableSurface: "
                         "freeing PXRX virtual DMA buffer %p, size %xh", 
                         glintInfo->PXRXDMABuffer.virtAddr, 
                         glintInfo->PXRXDMABuffer.size));

        ENGFREEMEM(glintInfo->PXRXDMABuffer.virtAddr);
        glintInfo->PXRXDMABuffer.virtAddr = NULL;
        glintInfo->PXRXDMABuffer.size = 0;
    }

    // free up any contexts we allocated
    //
    if (glintInfo->ddCtxtId >= 0)
    {
        vGlintFreeContext(ppdev, glintInfo->ddCtxtId);
    }

//@@BEGIN_DDKSPLIT
#ifdef  LATER
     pdsurf = ppdev->pdsurfOffScreen;
    if (pdsurf != NULL)
        vDeleteScreenDIBFromOH(pdsurf->poh);
#endif
//@@END_DDKSPLIT

    // Free GlintInfo and zero it.
    ENGFREEMEM(glintInfo);  
    glintInfo = NULL;
    
} // vDisableGlint

/******************************Public*Routine******************************\
* VOID vAssertModeGlint
*
* We're about to switch to/from full screen mode so do whatever we need to
* to save context etc.
*
\**************************************************************************/

VOID vAssertModeGlint(PPDEV ppdev, BOOL bEnable)
{
    GLINT_DECL;

    if (!glintInfo)
        return;

    if (!bEnable)
    {
        // Reset our software copy of the depth configured for this PDEV
        // back to the native depth. If we don't do this we may end up
        // with the copy and the hardware being out of sync when we
        // re-enable. Also, do a context switch to save our core register
        // state ready for when we get back in. All this forces a SYNC
        // as well which is a good thing.
        //
        VALIDATE_DD_CONTEXT;
        GLINT_DEFAULT_FB_DEPTH;
        GLINT_VALIDATE_CONTEXT(-1);
    }
    else
    {
        // re-enabling our PDEV so reload our context.
        //
        VALIDATE_DD_CONTEXT;

//@@BEGIN_DDKSPLIT
#if GAMMA_CORRECTION
        //
        // Restore the current gamma LUT.
        //
        bInstallGammaLUT(ppdev, &glintInfo->gammaLUT, FALSE);

#endif  // GAMMA_CORRECTION
//@@END_DDKSPLIT
    }
    
} // vAssertModeGlint
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\paint.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: paint.c
*
* Content: DrvPaint support
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"

/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
\**************************************************************************/

BYTE gaMix[] =
{
    0xFF,  // R2_WHITE        - Allow rop = gaMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE        - Allow rop = gaMix[mix & 0xFF]
};

/******************************Public*Routine******************************\
* BOOL DrvPaint
*
\**************************************************************************/

BOOL DrvPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix)
{
    BOOL bRet;
    ROP4 rop4;

    rop4 = ((MIX) gaMix[mix >> 8] << 8) | gaMix[mix & 0xf];

    // Since our DrvFillPath routine handles almost all fills, DrvPaint
    // won't get called all that much (mainly via PaintRgn, FillRgn, or
    // complex clipped polygons).  As such, we save some code and simply
    // punt to DrvBitBlt:

    DISPDBG((DBGLVL, "DrvPaint: calling DrvBitBlt"));

    if (rop4 == 0x5555)
    {
        // special processing for Invert

        bRet = DrvBitBlt(pso,               // Dst
                         pso,               // Src
                         NULL,              // Mask
                         pco,               // Clip
                         NULL,              // pxlo
                         &pco->rclBounds,   // Bounding Dest rect
                         (POINTL*)(&pco->rclBounds), // Source point
                         NULL,              // Mask point
                         NULL,              // Brush
                         NULL,              // brush origin
                         0x3333);           // not src
    }
    else
    {
        bRet = DrvBitBlt(pso, NULL, NULL, pco, NULL, &pco->rclBounds, NULL,
                         NULL, pbo, pptlBrush, rop4);
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\precomp.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: precomp.h
*
* Content: Common headers used throughout the display driver.  This entire 
*          include file will typically be pre-compiled.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <windef.h>
#include <winerror.h>
#include <wingdi.h>
#include <winddi.h>
#include <devioctl.h>
#include <ntddvdeo.h>
#include <ioaccess.h>

#define GLINT   1
#define DBG_TRACK_CODE 0

#include "driver.h"
#include "glint.h"
#include "lines.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\palette.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: palette.c
*
* Content: Palette support.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"
#include <math.h>

// Global Table defining the 20 Window default colours.  For 256 colour
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.

PALETTEENTRY gapalBase[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};

/******************************Public*Routine******************************\
* BOOL bInitializePalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitializePalette(
PDEV*    ppdev,
DEVINFO* pdi)
{
    PALETTEENTRY*   ppal;
    PALETTEENTRY*   ppalTmp;
    ULONG           ulLoop;
    ULONG           ulMask;
    BYTE            jRed;
    BYTE            jGre;
    BYTE            jBlu;
    HPALETTE        hpal;

    DISPDBG((DBGLVL, "bInitializePalette called"));

    // mask is zero for palette driven modes
    ulMask = ppdev->flRed | ppdev->flGreen | ppdev->flBlue;
    if ((ppdev->iBitmapFormat == BMF_8BPP) && (ulMask == 0))
    {
        // Allocate our palette:

        ppal = (PALETTEENTRY*)ENGALLOCMEM(FL_ZERO_MEMORY,
                        (sizeof(PALETTEENTRY) * 256), ALLOC_TAG_GDI(F));
        if (ppal == NULL)
        {
            goto ReturnFalse;
        }

        ppdev->pPal = ppal;

        // Generate 256 (8*8*4) RGB combinations to fill the palette

        jRed = 0;
        jGre = 0;
        jBlu = 0;

        ppalTmp = ppal;

        for (ulLoop = 256; ulLoop != 0; ulLoop--)
        {
            ppalTmp->peRed   = jRed;
            ppalTmp->peGreen = jGre;
            ppalTmp->peBlue  = jBlu;
            ppalTmp->peFlags = 0;

            ppalTmp++;

            if (!(jRed += 32))
            {
                if (!(jGre += 32))
                {
                    jBlu += 64;
                }
            }
        }

        // Fill in Windows reserved colours from the WIN 3.0 DDK
        // The Window Manager reserved the first and last 10 colours for
        // painting windows borders and for non-palette managed applications.

        for (ulLoop = 0; ulLoop < 10; ulLoop++)
        {
            // First 10

            ppal[ulLoop]       = gapalBase[ulLoop];

            // Last 10

            ppal[246 + ulLoop] = gapalBase[ulLoop+10];
        }

        // Create handle for palette.

        hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*) ppal, 0, 0, 0);
    }
    else
    {              
        DISPDBG((DBGLVL, "creating True Color palette, "
                         "masks rgb = 0x%x, 0x%x, 0x%x",
                         ppdev->flRed, ppdev->flGreen, ppdev->flBlue));
                         
        hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                                ppdev->flRed, ppdev->flGreen, ppdev->flBlue);
    }

    ppdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    if (hpal == 0)
    {
        goto ReturnFalse;
    }

    return(TRUE);

ReturnFalse:

    DISPDBG((WRNLVL, "Failed bInitializePalette"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vUninitializePalette
*
* Frees resources allocated by bInitializePalette.
*
* Note: In an error case, this may be called before bInitializePalette.
*
\**************************************************************************/

VOID vUninitializePalette(PDEV* ppdev)
{
    // Delete the default palette if we created one:

    if (ppdev->hpalDefault != 0)
    {
        EngDeletePalette(ppdev->hpalDefault);
    }

    if (ppdev->pPal != (PALETTEENTRY*) NULL)
    {
        ENGFREEMEM(ppdev->pPal);
    }
}

/******************************Public*Routine******************************\
* BOOL bEnablePalette
*
* Initialize the hardware's 8bpp palette registers.
*
\**************************************************************************/

BOOL bEnablePalette(PDEV* ppdev)
{
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       ulReturnedDataLength;
    ULONG       ulMask;

    DISPDBG((DBGLVL, "bEnablePalette called"));

    ulMask = ppdev->flRed | ppdev->flGreen | ppdev->flBlue;

    if ((ppdev->iBitmapFormat == BMF_8BPP) && (ulMask == 0))
    {
        // Fill in pScreenClut header info:
        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        // Copy colours in:
        RtlCopyMemory(pScreenClut->LookupTable, ppdev->pPal,
                      sizeof(ULONG) * 256);

        // Set palette registers:
        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_COLOR_REGISTERS,
                             pScreenClut,
                             MAX_CLUT_SIZE,
                             NULL,
                             0,
                             &ulReturnedDataLength))
        {
            DISPDBG((WRNLVL, "Failed bEnablePalette"));
            return(FALSE);
        }
    }

    DISPDBG((DBGLVL, "Passed bEnablePalette"));
    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisablePalette
*
* Undoes anything done in bEnablePalette.
*
\**************************************************************************/

VOID vDisablePalette(
PDEV*   ppdev)
{
    // Nothin' to do
}

/******************************Public*Routine******************************\
* VOID vAssertModePalette
*
* Sets/resets the palette in preparation for full-screen/graphics mode.
*
\**************************************************************************/

VOID vAssertModePalette(
PDEV*   ppdev,
BOOL    bEnable)
{
    // USER immediately calls DrvSetPalette after switching out of
    // full-screen, so we don't have to worry about resetting the
    // palette here.
#if(_WIN32_WINNT >= 0x500)
    // UPDATE: Windows 2000 in multi-monitor mode: DrvSetPalette only sent
    // to the primary monitor on exit from fullscreen (and then only if the
    // primary is in 8bpp mode). If the primary is not 8bpp indexed, but
    // the secondary is, there is no DrvSetPalette for the secondary, even
    // though it was sent DrvAssertMode(FALSE)
    if(bEnable)
        bEnablePalette(ppdev);
    else
        vDisablePalette(ppdev);
#endif
}

/******************************Public*Routine******************************\
* BOOL DrvSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    PVIDEO_CLUTDATA pScreenClutData;
    PDEV*           ppdev;
    ULONG           ulMask;

    UNREFERENCED_PARAMETER(fl);

    ppdev = (PDEV*) dhpdev;

    ulMask = ppdev->flRed | ppdev->flGreen | ppdev->flBlue;    

    if (ulMask != 0)
    {
        DISPDBG((WRNLVL, "DrvSetPalette: trying to set true color palette"));
        return FALSE;
    }

    // Fill in pScreenClut header info:

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                     (ULONG*) pScreenClutData))
    {
        DISPDBG((WRNLVL, "DrvSetPalette failed PALOBJ_cGetColors\n"));
        goto ReturnFalse;
    }

    // Set the high reserved byte in each palette entry to 0.

    while(cColors--)
    {
        pScreenClutData[cColors].Unused = 0;
    }

    // Set palette registers

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_COLOR_REGISTERS,
                         (PVOID)pScreenClut,
                         MAX_CLUT_SIZE,
                         NULL,
                         0,
                         &cColors))
    {
        DISPDBG((WRNLVL, "DrvSetPalette failed DeviceIoControl\n"));
        goto ReturnFalse;
    }

    return(TRUE);

ReturnFalse:

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bInstallGammaLUT
*
* Load a given gamma LUT into the RAMDAC and also save it in the registry.
*
\**************************************************************************/

BOOL
bInstallGammaLUT(PPDEV ppdev, PVIDEO_CLUT pScreenClut, BOOL waitVBlank)
{
    ULONG ulReturnedDataLength;
    BOOL bRet;
    GLINT_DECL;

    // only do this for 15, 16 or 32 bpp. Not 15/16 for RGB640.
    if ((ppdev->ulWhite == 0x0f0f0f) || (ppdev->cPelSize == 0) ||
        ((ppdev->flCaps & CAPS_RGB640_POINTER) && (ppdev->cPelSize == 1)))
    {
        return FALSE;
    }

    if (glintInfo->OverlayMode == GLINT_ENABLE_OVERLAY)
    {
        DISPDBG((WRNLVL, "Overlays enabled. cannot install GAMMA LUT"));
        return FALSE;
    }

    if (pScreenClut->NumEntries == 0)
    {
        DISPDBG((WRNLVL, "bInstallGammaLUT: Empty LUT"));
        return TRUE;
    }

    // Set palette registers.
    if (waitVBlank)
    {
        GLINT_WAIT_FOR_VBLANK;
    }

    bRet = !EngDeviceIoControl(
                        ppdev->hDriver,
                        IOCTL_VIDEO_SET_COLOR_REGISTERS,
                        pScreenClut,
                        MAX_CLUT_SIZE,
                        NULL,
                        0,
                        &ulReturnedDataLength);

//@@BEGIN_DDKSPLIT
#if 0
    // if we succeeded save the ramp in the registry and locally

    if (bRet)
    {
        bGlintRegistrySaveGammaLUT(ppdev, pScreenClut);
    }
#endif
//@@END_DDKSPLIT

    return(bRet);
}        

/******************************Public*Routine******************************\
* VOID vSetNewGammaValue
*
* Loads up a true color palette with the specified gamma correction factor.
* This is straightforward for 24 bit true color. For 15 and 16 bpp we rely
* on the miniport having enabled the palette for sparse lookup. i.e. each
* 5 or 6 bit component is shifted left to create an 8 bit component before
* the lookup.
*
* Note: the display driver shouldn't really do anything with floats or
* doubles. I restrict their use to this function which is why the gamma
* value is presented as a 16.16 fixed point number. And this function must
* be called only from within an OPELGL escape. On NT 4 FP regs are saved
* and restored for OGL escapes only.
*
\**************************************************************************/

VOID
vSetNewGammaValue(PPDEV ppdev, ULONG ulgv, BOOL waitVBlank)
{
    PVIDEO_CLUTDATA pScreenClutData;
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       i;
    UCHAR       gc;
    double      gv;
    double      dcol;
    GLINT_DECL;

    // gamma can't be zero or we blow up
    if (ulgv == 0)
    {
        DISPDBG((WRNLVL, "can't use gamma value of zero"));
        return;
    }

    // only do this for 15, 16 or 32 bpp.

    if ((ppdev->ulWhite == 0x0f0f0f) || (ppdev->cPelSize == 0))
    {
        return;
    }

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = 256;
    pScreenClut->FirstEntry = 0;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    //
    // special case gamma of 1.0 so we can load the LUT at startup without
    // needing any floating point calculations. NT 4 only allows FP ops in
    // an OGL escape. Can't use FLOATOBJ because we need to use pow().
    //
    if (ulgv == 0x10000)
    {
        for (i = 0; i < 256; ++i)
        {
            pScreenClutData[i].Red    = (UCHAR)i;
            pScreenClutData[i].Green  = (UCHAR)i;
            pScreenClutData[i].Blue   = (UCHAR)i;
            pScreenClutData[i].Unused = 0;
        }
    }
    else
    {
        // pre-work out 1/gamma
        gv = (double)(ulgv >> 16) + (double)(ulgv & 0xffff) / 65536.0;
        gv = 1.0 / gv;

        for (i = 0; i < 256; ++i)
        {
            dcol = (double)i;
            gc = (UCHAR)(255.0 * pow((dcol/255.0), gv));

            pScreenClutData[i].Red    = gc;
            pScreenClutData[i].Green  = gc;
            pScreenClutData[i].Blue   = gc;
            pScreenClutData[i].Unused = 0;
        }
    }

    if (bInstallGammaLUT(ppdev, pScreenClut, waitVBlank))
    {
        RtlCopyMemory(&glintInfo->gammaLUT, pScreenClut, MAX_CLUT_SIZE);
    }
}

//*****************************************************************************
// FUNC: DrvIcmSetDeviceGammaRamp
// ARGS: dhpdev (I) - handle to physical device object
//       iFormat (I) - always IGRF_RGB_256WORDS
//       lpRamp (I) - when iFormat == IGRF_RGB_256WORDS, this points to a 
//                    GAMMARAMP structure
// RETN: TRUE if successful
//-----------------------------------------------------------------------------
// Sets the hardware Gamma ramp
//*****************************************************************************

BOOL DrvIcmSetDeviceGammaRamp(DHPDEV dhpdev, ULONG iFormat, VOID *pRamp)
{
    BOOL            bRet = FALSE;
    PDEV            *ppdev  = (PDEV *) dhpdev;
    GAMMARAMP       *pgr    = (GAMMARAMP *)pRamp;
    PVIDEO_CLUTDATA pScreenClutData;
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    ULONG           i;
    ULONG           cj;

    DISPDBG((DBGLVL, "DrvIcmSetDeviceGammaRamp"));

    if(iFormat == IGRF_RGB_256WORDS)
    {
        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

        for (i = 0; i < 256; ++i)
        {
            pScreenClutData[i].Red    = (UCHAR)(pgr->Red[i] >> 8);
            pScreenClutData[i].Green  = (UCHAR)(pgr->Green[i] >> 8);
            pScreenClutData[i].Blue   = (UCHAR)(pgr->Blue[i] >> 8);
            pScreenClutData[i].Unused = 0;
        }

        bRet = bInstallGammaLUT(ppdev, pScreenClut, FALSE);
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\lineto.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDISAMPLE CODE *
*                           *******************
*
* Module Name: LineTo.c
*
* Content: The code in this file handles the DrvLineTo() API call. 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* BOOL DrvLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix)
*
* DrvLineTo() is an optimised, integer co-ordinate, API call that doesn't
* support styling. The integer-line code in Strips.c is called to do the 
* hard work.
*
* Note that:
*   1. pco can be NULL.
*   2. we only handle simple clipping.
*
\**************************************************************************/

BOOL DrvLineTo(
    SURFOBJ*   pso,
    CLIPOBJ*   pco,
    BRUSHOBJ*  pbo,
    LONG       x1,
    LONG       y1,
    LONG       x2,
    LONG       y2,
    RECTL      *prclBounds,
    MIX        mix)
{
    PDEV*     ppdev;
    DSURF*    pdsurf;
    BOOL      ResetGLINT;                   // Does GLINT need resetting?
    DWORD     logicOp;
    RECTL*    prclClip = (RECTL*) NULL;
    ULONG     iSolidColor = pbo->iSolidColor;
    BOOL      retVal;  
    GLINT_DECL_VARS;

    // Pass the surface off to GDI if it's a device bitmap 
    // that we've converted to a DIB 
    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt & DT_DIB)
    {
        return(EngLineTo(pdsurf->pso, 
                         pco, 
                         pbo, 
                         x1, 
                         y1, 
                         x2, 
                         y2, 
                         prclBounds, 
                         mix));
    }

    // Return to sender if the clipping is too difficult
    if (pco && pco->iDComplexity == DC_COMPLEX)
    {
        return(FALSE);
    }

    ppdev = (PDEV*) pso->dhpdev;
    GLINT_DECL_INIT;
    REMOVE_SWPOINTER(pso);

    DISPDBG((DBGLVL, "Drawing DrvLines through GLINT"));

    SETUP_PPDEV_OFFSETS(ppdev, pdsurf);

    // Set up the clipping rectangle, if there is one
    if (pco && pco->iDComplexity == DC_RECT)
    {
        prclClip = &(pco->rclBounds);
    }
    
    // Get the logic op.
    logicOp = GlintLogicOpsFromR2[mix & 0xff];

    // Need to set up Glint modes and colors appropriately for the line.
    ResetGLINT = (*ppdev->pgfnInitStrips)(ppdev, 
                                          iSolidColor, 
                                          logicOp, 
                                          prclClip);

    // We have to convert our integer co-ords to 28.4 fixed points.
    retVal = ppdev->pgfnIntegerLine(ppdev, 
                                    x1 << 4,
                                    y1 << 4, 
                                    x2 << 4, 
                                    y2 << 4);

    // If we have to restore the state then... do it.
    if (ResetGLINT)
    {
        (*ppdev->pgfnResetStrips)(ppdev);
    }

    return (retVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\pointer.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: pointer.c
*
* Content:
*
* This module contains the hardware pointer support for the display
* driver. This supports the IBM RGB525 RAMDAC pointer. We also have
* support for color space double buffering using the RAMDAC pixel
* read mask.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"
#include "p3rd.h"

BOOL bSet3ColorPointerShapeP3RD(PPDEV ppdev, SURFOBJ *psoMask, SURFOBJ *psoColor, 
                                LONG x, LONG y, LONG xHot, LONG yHot);
BOOL bSet15ColorPointerShapeP3RD(PPDEV ppdev, SURFOBJ *psoMask, SURFOBJ *psoColor, 
                                 LONG x, LONG y, LONG xHot, LONG yHot);


/******************************Public*Routine******************************\
* VOID DrvMovePointer
*
* NOTE: Because we have set GCAPS_ASYNCMOVE, this call may occur at any
*       time, even while we're executing another drawing call!
*
\**************************************************************************/

VOID DrvMovePointer(
SURFOBJ*    pso,
LONG        x,
LONG        y,
RECTL*      prcl)
{
    OH*     poh;
    PDEV*   ppdev = (PDEV*) pso->dhpdev;

    DISPDBG((DBGLVL, "DrvMovePointer called"));

    if (x > -1)
    {
        // Convert the pointer's position from relative to absolute
        // coordinates (this is only significant for multiple board
        // support):

        poh = ((DSURF*) pso->dhsurf)->poh;
        x += poh->x;
        y += poh->y;

        // If we're doing any hardware zooming then the cusor position will
        // have to be doubled.
        //
        if (ppdev->flCaps & CAPS_ZOOM_Y_BY2)
            y *= 2;
        if (ppdev->flCaps & CAPS_ZOOM_X_BY2)
                x *= 2;

        // If they have genuinely moved the cursor, then 
        // move it
        if (x != ppdev->HWPtrPos_X || y != ppdev->HWPtrPos_Y)
        {
            vMovePointerP3RD(ppdev, x, y);

            ppdev->HWPtrPos_X = x;
            ppdev->HWPtrPos_Y = y;
        }

        // We may have to make the pointer visible:

        if (!(ppdev->flPointer & PTR_HW_ACTIVE))
        {
            DISPDBG((DBGLVL, "Showing hardware pointer"));
            ppdev->flPointer |= PTR_HW_ACTIVE;
            vShowPointerP3RD(ppdev, TRUE);
        }
    }
    else if (ppdev->flPointer & PTR_HW_ACTIVE)
    {
        // The pointer is visible, and we've been asked to hide it:

        DISPDBG((DBGLVL, "Hiding hardware pointer"));
        ppdev->flPointer &= ~PTR_HW_ACTIVE;
        vShowPointerP3RD(ppdev, FALSE);
    }
#if DBG
    else
    {
        DISPDBG((DBGLVL, "DrvMovePointer: x == -1 but not PTR_HW_ACTIVE"));
    }
#endif

    // Note that we don't have to modify 'prcl', since we have a
    // NOEXCLUDE pointer...

    DISPDBG((DBGLVL, "DrvMovePointer exited"));
}                                                  

/******************************Public*Routine******************************\
* VOID DrvSetPointerShape
*
* Sets the new pointer shape.
*                                                                              
\**************************************************************************/

ULONG DrvSetPointerShape(
SURFOBJ*    pso,
SURFOBJ*    psoMsk,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL*      prcl,
FLONG       fl)
{
    PDEV*   ppdev;
    OH      *poh;
    BOOL    bAccept;
    DISPDBG((DBGLVL, "DrvSetPointerShape called"));

    ppdev = (PDEV*) pso->dhpdev;

    if (!(fl & SPS_CHANGE))
    {
        goto HideAndDecline;
    }

    ASSERTDD(psoMsk != NULL, "GDI gave us a NULL psoMsk.  It can't do that!");
    ASSERTDD(pso->iType == STYPE_DEVICE, "GDI gave us a weird surface");

    if (x != -1)
    {
        // Convert the pointer's position from relative to absolute
        // coordinates (this is only significant for multiple board
        // support):

        if (pso->dhsurf != NULL)
        {
            poh = ((DSURF*) pso->dhsurf)->poh;
            x += poh->x;
            y += poh->y;
        }

        // If we're doing any hardware zooming then the cusor position will
        // have to be doubled.
        //
        if (ppdev->flCaps & CAPS_ZOOM_Y_BY2)
            y *= 2;
        if (ppdev->flCaps & CAPS_ZOOM_X_BY2)
            x *= 2;
    }

    // See if our hardware cursor can handle this.
    bAccept = bSetPointerShapeP3RD(ppdev, psoMsk, psoColor, pxlo,
                                   x, y, xHot, yHot);

    if (bAccept)
    {
        if (x != -1)
        {
            // Save the X and Y values
            ppdev->HWPtrPos_X = x;
            ppdev->HWPtrPos_Y = y;

            ppdev->flPointer |= PTR_HW_ACTIVE;
        }
        else
        {
            ppdev->flPointer &= ~PTR_HW_ACTIVE;
        }

        // Since it's a hardware pointer, GDI doesn't have to worry about
        // overwriting the pointer on drawing operations (meaning that it
        // doesn't have to exclude the pointer), so we return 'NOEXCLUDE'.
        // Since we're returning 'NOEXCLUDE', we also don't have to update
        // the 'prcl' that GDI passed us.

        return(SPS_ACCEPT_NOEXCLUDE);
    }
    
HideAndDecline:

    // Remove whatever pointer is installed.
    DrvMovePointer(pso, -2, -1, NULL);

    DISPDBG((DBGLVL, "Cursor declined"));

    return(SPS_DECLINE);
}

/******************************Public*Routine******************************\
* VOID vDisablePointer
*
\**************************************************************************/

VOID vDisablePointer(
PDEV*   ppdev)
{
    if(ppdev->bPointerEnabled)
    {
        vDisablePointerP3RD(ppdev);
    }
}

/******************************Public*Routine******************************\
* VOID vAssertModePointer
*
* Do whatever has to be done to enable everything but hide the pointer.
*
\**************************************************************************/

VOID vAssertModePointer(
PDEV*   ppdev,
BOOL    bEnable)
{
    // Invalidate the hardware pointer cache
    HWPointerCacheInvalidate (&(ppdev->HWPtrCache));

    // Remove the hardware pointer
    vShowPointerP3RD(ppdev, FALSE);

    ppdev->flPointer &= ~PTR_HW_ACTIVE;
}

/******************************Public*Routine******************************\
* BOOL bEnablePointer
*
\**************************************************************************/

BOOL bEnablePointer(
PDEV*   ppdev)
{
    // Initialise the pointer cache.
    HWPointerCacheInit (&(ppdev->HWPtrCache));

    // Set the last cursor to something invalid
    ppdev->HWPtrLastCursor = HWPTRCACHE_INVALIDENTRY;

    // Initialise the X and Y values to something invalid.
    ppdev->HWPtrPos_X = 1000000000;
    ppdev->HWPtrPos_Y = 1000000000;

    // Call the enable function
    vEnablePointerP3RD(ppdev);

    // Mark the pointer as enabled for this PDEV
    ppdev->bPointerEnabled = TRUE;

    return(TRUE);
}

/****************************************************************************************
 *                                                                                      *
 * 64 x 64 Hardware Pointer Caching                                                     *
 * --------------------------------                                                        *
 * The code below implements hardware independent caching of pointers, it maintains     *
 * a cache big enough to store ONE 64x64 cursor or FOUR 32x32 cursors. The code will    *
 * work with all RAMDACs that support this form of caching (i.e. the RGB525 and TVP3033)*
 * however the TVP3026 supports a 64x64 cursor but this can't be broken down into 4     *
 * smaller ones.                                                                        *
 *                                                                                        *
 ****************************************************************************************/

/******************************Public*Routine******************************\
* LONG HWPointerCacheInit
* 
* Initialise the hardware pointer cache.
\**************************************************************************/

VOID
HWPointerCacheInit (HWPointerCache * ptrCache)
{
    ptrCache->ptrCacheInUseCount   = 0;
    ptrCache->ptrCacheCurTimeStamp = 0;
}

/******************************Public*Routine******************************\
* LONG HWPointerCacheCheckAndAdd
* 
* This function does a byte-by-byte comparison of the supplied pointer data
* with each pointer that is in cache, if it finds a matching one then it 
* returns the index of the item in the cache (0 to 3) otherwise it adds it to
* the cache and returns the index.
\**************************************************************************/

LONG
HWPointerCacheCheckAndAdd (HWPointerCache * ptrCache, ULONG cx, ULONG cy, 
                           LONG lDelta, BYTE * scan0, BOOL * isCached)
{
    BOOL pointerIsCached = FALSE;
    BOOL isLargePtr = (cx > 32) || (cy > 32);
    LONG i, j, z;
    LONG cacheItem;

#if !defined(_WIN64)
//@@BEGIN_DDKSPLIT
// Quick Fix IA64 AV 
//@@END_DDKSPLIT
    // If there are entries in the cache and they are the same format as the one
    // that we are looking for then search the cache.
    if (ptrCache->ptrCacheInUseCount && ptrCache->ptrCacheIsLargePtr == isLargePtr)
    {
        // *** SEARCH THE CACHE ***

        LONG xInBytes       = (cx >> 3);
        LONG yInLines       = (cy << 1);            // The AND plane and the XOR plane
        BYTE jMask          = gajMask [cx & 0x7];
        LONG cacheCnt       = ptrCache->ptrCacheInUseCount;

        // Examine all valid entries in the cache to see if they are the same as the
        // pointer that we've been handed.
        for (z = 0; !pointerIsCached && z < cacheCnt; z++)
        {
            BYTE * cacheLinePtr = ((BYTE *) ptrCache->ptrCacheData) + (z * SMALL_POINTER_MEM);
            BYTE * cachePtr;
            LONG   cacheLDelta  = ptrCache->ptrCacheItemList [z].ptrCacheLDelta;
            BYTE * scanLinePtr  = (BYTE *) scan0;
            BYTE * scanPtr;

            // Compare the data
            for (i = 0, pointerIsCached = TRUE; pointerIsCached && i < yInLines; i++)
            {
                cachePtr = cacheLinePtr;
                scanPtr = scanLinePtr;

                // Compare each byte - could do a series of long comparisons here.
                for (j = 0; (j < xInBytes) && (*scanPtr == *cachePtr); j++, scanPtr++, cachePtr++)
                    ;
                
                pointerIsCached = (j == xInBytes) && 
                                  ((*scanPtr & jMask) == (*cachePtr & jMask));

                cacheLinePtr += cacheLDelta;
                scanLinePtr  += lDelta;
            }
                
            cacheItem = z;
        }
    }
#endif //  !defined(_WIN64)

    // If we couldn't find an entry in the pointer cache then add one to the cache.
    if (!pointerIsCached)
    {
        /* **** ADD POINTER TO THE CACHE ****** */

        LONG xInBytes        = ((cx + 7) >> 3);
        LONG yInLines        = (cy << 1);            // The AND plane and the XOR plane
        BYTE * scanLinePtr   = (BYTE *) scan0;
        BYTE * scanPtr;
        BYTE * cacheLinePtr;
        BYTE * cachePtr;
        LONG cacheLDelta    = (cx <= 32) ? 4 : 8;
        BYTE jMask          = gajMask [cx & 0x7];

        // If the new pointer is a big one then re-use item 0, else if
        // the pointer is small and there are some spare entries then allocate
        // a free entry, otherwise find the least recently used entry and use 
        // that.
        if (isLargePtr)
        {
            cacheItem = 0;
        }
        else if (ptrCache->ptrCacheInUseCount < SMALL_POINTER_MAX)
        {
            cacheItem = ptrCache->ptrCacheInUseCount++;
        }
        else
        {
            ULONG oldestValue = 0xFFFFFFFF;

            // look for the LRU entry
            for (z = 0, cacheItem = 0; z < SMALL_POINTER_MAX; z++)
            {
                if (ptrCache->ptrCacheItemList [z].ptrCacheTimeStamp < oldestValue)
                {
                    cacheItem = z;
                    oldestValue = ptrCache->ptrCacheItemList [z].ptrCacheTimeStamp;
                }
            }
        }
        
        // Get a pointer to the first line in the cache
        cacheLinePtr = ((BYTE *) ptrCache->ptrCacheData) + (cacheItem * SMALL_POINTER_MEM);

        // Add the pointer to the cache
        for (i = 0; i < yInLines; i++)
        {
            cachePtr = cacheLinePtr;
            scanPtr = scanLinePtr;

            for (j = 0; (j < xInBytes); j++, scanPtr++, cachePtr++)
                *cachePtr = *scanPtr;
            
            cacheLinePtr += cacheLDelta;
            scanLinePtr  += lDelta;
        }

        // If the pointer type is different then reset the whole
        // cache
        if (ptrCache->ptrCacheIsLargePtr != isLargePtr)
        {
            ptrCache->ptrCacheInUseCount = 1;
            ptrCache->ptrCacheIsLargePtr = (BYTE)isLargePtr;
        }

        // Set up the cache entry
        ptrCache->ptrCacheItemList [cacheItem].ptrCacheLDelta   = cacheLDelta;
        ptrCache->ptrCacheItemList [cacheItem].ptrCacheCX       = cx;
        ptrCache->ptrCacheItemList [cacheItem].ptrCacheCY       = cy;
    }

    // Set the timestamp
    ptrCache->ptrCacheItemList [cacheItem].ptrCacheTimeStamp = ptrCache->ptrCacheCurTimeStamp++;

    // Set up the return value to say whether the pointer was cached
    *isCached = pointerIsCached;

    return (cacheItem);
}

//@@BEGIN_DDKSPLIT
// NickM says we have to disable the cursor to stop nasty flashing occurring,
// however there is a potential exploding flashing cursor syndrome that this may 
// cause.
// Note that this problem only seems to cause us problems when switching between
// mono and colour cursors.
//@@END_DDKSPLIT

#define DISABLE_CURSOR_MODE(){                                                            \
    ULONG curCurMode, curLine;                                                            \
    ULONG start = (pP3RDinfo->y > 8) ? (pP3RDinfo->y - 8) : 0;                            \
    ULONG end = pP3RDinfo->y + 64;                                                        \
    do  {                                                                                \
        READ_GLINT_CTRL_REG (LineCount, curLine);                                        \
    } while ((curLine >= start) && (curLine <= end));                                    \
    P3RD_READ_INDEX_REG(P3RD_CURSOR_MODE, curCurMode);                                    \
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_MODE, (curCurMode & (~P3RD_CURSOR_MODE_ENABLED)));    \
}

// Look-up table for masking the right edge of the given pointer bitmap:
//
BYTE gajMask[] = {
    0x00, 0x80, 0xC0, 0xE0,
    0xF0, 0xF8, 0xFC, 0xFE,
};

/******************************Public*Routine******************************\
* VOID vShowPointerP3RD
*
* Show or hide the 3Dlabs P3RD hardware pointer.
*
\**************************************************************************/

VOID
vShowPointerP3RD(
PPDEV   ppdev,
BOOL    bShow)
{
    ULONG cmr;
    GLINT_DECL_VARS;
    P3RD_DECL_VARS;
    
    GLINT_DECL_INIT;
    P3RD_DECL_INIT;

    DISPDBG((DBGLVL, "vShowPointerP3RD (%s)", bShow ? "on" : "off"));

    if (bShow)
    {
        // no need to sync since this case is called only if we've just moved
        // the cursor and that will already have done a sync.
        P3RD_LOAD_INDEX_REG(P3RD_CURSOR_MODE, (pP3RDinfo->cursorModeCurrent | P3RD_CURSOR_MODE_ENABLED));
        P3RD_MOVE_CURSOR (pP3RDinfo->x, pP3RDinfo->y);
    }
    else
    {
        // move the cursor off screen
        P3RD_LOAD_INDEX_REG(P3RD_CURSOR_Y_HIGH, 0xff);
    }
}

/******************************Public*Routine******************************\
* VOID vMovePointerP3RD
*
* Move the 3Dlabs P3RD hardware pointer.
*
\**************************************************************************/

VOID
vMovePointerP3RD(
PPDEV   ppdev,
LONG    x,
LONG    y)
{
    GLINT_DECL_VARS;
    P3RD_DECL_VARS;
    
    GLINT_DECL_INIT;
    P3RD_DECL_INIT;

    DISPDBG((DBGLVL, "vMovePointerP3RD to (%d, %d)", x, y));

    pP3RDinfo->x = x;
    pP3RDinfo->y = y;

    P3RD_SYNC_WITH_GLINT;

    P3RD_MOVE_CURSOR (x, y);
}

/******************************Public*Routine******************************\
* BOOL bSetPointerShapeP3RD
*
* Set the 3Dlabs hardware pointer shape.
*
\**************************************************************************/

UCHAR nibbleToByteP3RD[] = {

    0x00,   // 0000 --> 00000000
    0x80,   // 0001 --> 10000000
    0x20,   // 0010 --> 00100000
    0xA0,   // 0011 --> 10100000
    0x08,   // 0100 --> 00001000
    0x88,   // 0101 --> 10001000
    0x28,   // 0110 --> 00101000
    0xA8,   // 0111 --> 10101000
    0x02,   // 1000 --> 00000010
    0x82,   // 1001 --> 10000010
    0x22,   // 1010 --> 00100010
    0xA2,   // 1011 --> 10100010
    0x0A,   // 1100 --> 00001010
    0x8A,   // 1101 --> 10001010
    0x2A,   // 1110 --> 00101010
    0xAA,   // 1111 --> 10101010
};

BOOL
bSetPointerShapeP3RD(
PPDEV       ppdev,
SURFOBJ     *pso,       // defines AND and MASK bits for cursor
SURFOBJ     *psoColor,  // we may handle some color cursors at some point
XLATEOBJ*   pxlo,
LONG        x,          // If -1, pointer should be created hidden
LONG        y,
LONG        xHot,
LONG        yHot)
{
    ULONG   cx;
    ULONG   cy;
    LONG    i;
    LONG    j;
    ULONG   ulValue;
    BYTE*   pjAndScan;
    BYTE*   pjXorScan;
    BYTE*   pjAnd;
    BYTE*   pjXor;
    BYTE    andByte;
    BYTE    xorByte;
    BYTE    jMask;
    LONG    lDelta;
    LONG    cpelFraction;
    LONG    cjWhole;
    LONG    cClear;
    LONG    cRemPels;
    BOOL    pointerIsCached;
    LONG    cacheItem;
    LONG    cursorBytes;
    LONG    cursorRAMOff;
    ULONG   lutIndex0, lutIndex1;
    GLINT_DECL_VARS;
    P3RD_DECL_VARS;
    
    GLINT_DECL_INIT;
    P3RD_DECL_INIT;

    DISPDBG((DBGLVL, "bSetPointerShapeP3RD started"));

    // Do we have a colour cursor ?
    if (psoColor != NULL)
    {
        HSURF   hsurfDst = NULL;    // We'll use these later.
        SURFOBJ * psoDst = NULL;

        if (psoColor->iType == STYPE_DEVBITMAP)
        {
            // it's an offscreen bitmap: we'll use its DIB
            DSURF *pdsurfSrc = (DSURF *)psoColor->dhsurf;
            psoColor = pdsurfSrc->pso;

            // If we have patching enabled then it could be that we aren't allowed
            // to directly access framebuffer memory, if that is the case then
            // we have to fall-back to software. Note that when running 3D apps there
            // won't be any off-screen memory so cursors will be hardware ones.
            // Note that bitmaps that were in off-screen and have been kicked back
            // into host memory will have pdsurfSrc->dt set to DT_DIB.
            if (glintInfo->GdiCantAccessFramebuffer && ((pdsurfSrc->dt & DT_DIB) == 0))
            {
                DISPDBG((DBGLVL, "declining off-screen cursor in a patched framebuffer"));
                return (FALSE);
            }
        }

        // Is it 15,16 or 32BPP.

        if(!(ppdev->iBitmapFormat == BMF_16BPP || ppdev->iBitmapFormat == BMF_32BPP))
        {
            // currently we only handle DIB cursors at 32bpp, 16bpp & 15bpp.
            DISPDBG((DBGLVL, "declining non-32bpp, non-16bpp colored cursor - iType(%d) iBitmapFormat(%d)", psoColor->iType, psoColor->iBitmapFormat));
            return FALSE;
        }

        // If we have a bitmap which we don't understand then we have to convert it using
        // the EngCopyBits() function.
        if ((pxlo != NULL && pxlo->flXlate != XO_TRIVIAL)    ||
            (psoColor->iType != STYPE_BITMAP)                  )
        {
            RECTL   rclDst;
            SIZEL   sizlDst;
            ULONG   DstPixelOrigin;
            POINTL  ptlSrc;

#if DBG
            if(pxlo != NULL && pxlo->flXlate != XO_TRIVIAL) 
            {
                DISPDBG((DBGLVL, "colored cursor - nontrivial xlate: flXlate(%xh)", pxlo->flXlate));
            }
#endif  //  DBG

            // Firstly we need to create a bitmap (hsurfDst) and a surface (psoDst) 
            // which we can translate the cursor data in psoColor into.
            sizlDst.cy = pso->sizlBitmap.cy >> 1;    // divide by 2 'cos cy includes AND and XOR masks
            sizlDst.cx = pso->sizlBitmap.cx;

            DISPDBG((DBGLVL, "Creating bitmap for destination: dimension %dx%d", sizlDst.cx, sizlDst.cy));
            
            hsurfDst = (HSURF) EngCreateBitmap(sizlDst, BMF_TOPDOWN, ppdev->iBitmapFormat, 0, NULL);
            if (hsurfDst == NULL)
            {
                DISPDBG((DBGLVL, "bSetPointerShapeP3RD: EngCreateBitmap failed"));
                return FALSE;
            }

            // Now we lock the bitmap to get ourselves a surface object. 
            psoDst = EngLockSurface(hsurfDst);
            if (psoDst == NULL)
            {
                DISPDBG((DBGLVL, "bSetPointerShapeP3RD: EngLockSurface failed"));
            }
            else
            {
                // Now do the bitmap conversion using EngCopyBits(). The 
                // destination rectangle is the minimum size and the source starts
                // from (0,0) into pso->pvScan0.
                rclDst.left = 0;
                rclDst.top = 0;
                rclDst.right = sizlDst.cx;
                rclDst.bottom = sizlDst.cy;
                ptlSrc.x = 0;
                ptlSrc.y = 0;
                
                DISPDBG((DBGLVL, "bSetPointerShapeP3RD: copying to bitmap"));

                if (!EngCopyBits(psoDst, psoColor, NULL, pxlo, &rclDst, &ptlSrc))
                {
                    // Oh no copybits failed, free up the the surfaces & bitmaps.
                    DISPDBG((DBGLVL, "bSetPointerShapeP3RD: EngLockSurface failed"));

                    EngUnlockSurface(psoDst);
                    EngDeleteSurface(hsurfDst);
                    return FALSE;
                }
                else
                {
                    // Copybits suceeded, set psoColor to point at the translated
                    // data.
                    DISPDBG((DBGLVL, "bSetPointerShapeP3RD: EngLockSurface OK"));

                    psoColor = psoDst;
                }
            }
        }

        // Draw the cursor, this function will return an error if there are
        // too many colours in the pointer.
        if(!bSet15ColorPointerShapeP3RD(ppdev, pso, psoColor, x, y, xHot, yHot)) 
        {
            DISPDBG((DBGLVL, "declining colored cursor"));
            return FALSE;
        }

        // If we, earlier, translated psoColor into the framebuffer pixel format then
        // we now need to free the intermediate surfaces and bitmaps.
        if (psoDst)
        {
            EngUnlockSurface(psoDst);
        }
        if (hsurfDst)
        {
            EngDeleteSurface(hsurfDst);
        }
        
        DISPDBG((DBGLVL, "bSetPointerShapeP3RD done"));
        return(TRUE);
    }

    // If we are switching from a colour cursor to a mono one then disable
    // the cursor in the cursor mode. Note that this is potentially dangerous
    // and we are seeing screen flashes on occasions.

    if (pP3RDinfo->cursorSize != P3RD_CURSOR_SIZE_32_MONO &&
        pP3RDinfo->cursorSize != P3RD_CURSOR_SIZE_64_MONO)
    {
        DISABLE_CURSOR_MODE();
    }

    // Note that 'sizlBitmap.cy' accounts for the double height due to the inclusion of both the AND masks
    // and the XOR masks. We're only interested in the true pointer dimensions, so we divide by 2.
    cx = pso->sizlBitmap.cx;            
    cy = pso->sizlBitmap.cy >> 1;       

    // we can handle up to 64x64.  cValid indicates the number of
    // bytes occupied by cursor on one line
    if (cx <= 32 && cy <= 32)
    {
        // 32 horiz pixels: 2 bits per pixel, 1 horiz line per 8 bytes
        pP3RDinfo->cursorSize = P3RD_CURSOR_SIZE_32_MONO;
        cursorBytes = 32 * 32 * 2 / 8;
        cClear   = 8 - 2 * ((cx+7) / 8);
        cRemPels = (32 - cy) << 3;
    }
    else if (cx <= 64 && cy <= 64)
    {
        // 64 horiz pixels: 2 bits per pixel, 1 horiz line per 16 bytes
        pP3RDinfo->cursorSize = P3RD_CURSOR_SIZE_64_MONO;
        cursorBytes = 64 * 64 * 2 / 8;
        cClear   = 16 - 2 * ((cx+7) / 8);
        cRemPels = (64 - cy) << 4;
    }
    else
    {
        DISPDBG((DBGLVL, "declining cursor: %d x %d is too big", cx, cy));
        return(FALSE);  // cursor is too big to fit in the hardware
    }

    // Check to see if the pointer is cached, add it to the cache if it isn't
    cacheItem = HWPointerCacheCheckAndAdd (&(ppdev->HWPtrCache), cx, cy, pso->lDelta, pso->pvScan0, &pointerIsCached);
    
    DISPDBG((DBGLVL, "bSetPointerShapeP3RD: Add Cache iscac %d item %d", (int) pointerIsCached, cacheItem));

    pP3RDinfo->cursorModeCurrent = pP3RDinfo->cursorModeOff | P3RD_CURSOR_SEL(pP3RDinfo->cursorSize, cacheItem);

    // hide the pointer
    vShowPointerP3RD(ppdev, FALSE);

    if (!pointerIsCached)
    {
        // Now we're going to take the requested pointer AND masks and XOR
        // masks and interleave them by taking a nibble at a time from each,
        // expanding each out and or'ing together. Use the nibbleToByteP3RD array
        // to help this.
        //
        // 'psoMsk' is actually cy * 2 scans high; the first 'cy' scans
        // define the AND mask.

        pjAndScan = pso->pvScan0;
        lDelta    = pso->lDelta;
        pjXorScan = pjAndScan + (cy * lDelta);

        cjWhole      = cx >> 3;                 // Each byte accounts for 8 pels
        cpelFraction = cx & 0x7;                // Number of fractional pels
        jMask        = gajMask[cpelFraction];

        // we've got auto-increment turned on so just point to the first entry to write to
        // in the array then write repeatedly until the cursor pattern has been transferred
        cursorRAMOff = cacheItem * cursorBytes;
        P3RD_CURSOR_ARRAY_START(cursorRAMOff);

        for (i = cy; --i >= 0; pjXorScan += lDelta, pjAndScan += lDelta)
        {
            pjAnd = pjAndScan;
            pjXor = pjXorScan;

            // interleave nibbles from whole words. We are using Windows cursor mode.
            // Note, the AND bit occupies the higher bit position for each
            // 2bpp cursor pel; the XOR bit is in the lower bit position.
            // The nibbleToByteP3RD array expands each nibble to occupy the bit
            // positions for the AND bytes. So when we use it to calculate
            // the XOR bits we shift the result right by 1.
            //
            for (j = cjWhole; --j >= 0; ++pjAnd, ++pjXor)
            {
                andByte = *pjAnd;
                xorByte = *pjXor;
                ulValue = nibbleToByteP3RD[andByte >> 4] | (nibbleToByteP3RD[xorByte >> 4] >> 1);
                P3RD_LOAD_CURSOR_ARRAY (ulValue);

                andByte &= 0xf;
                xorByte &= 0xf;
                ulValue = nibbleToByteP3RD[andByte] | (nibbleToByteP3RD[xorByte] >> 1);
                P3RD_LOAD_CURSOR_ARRAY (ulValue);
            }

            if (cpelFraction) 
            {
                andByte = *pjAnd & jMask;
                xorByte = *pjXor & jMask;
                ulValue = nibbleToByteP3RD[andByte >> 4] | (nibbleToByteP3RD[xorByte >> 4] >> 1);
                P3RD_LOAD_CURSOR_ARRAY (ulValue);

                andByte &= 0xf;
                xorByte &= 0xf;
                ulValue = nibbleToByteP3RD[andByte] | (nibbleToByteP3RD[xorByte] >> 1);
                P3RD_LOAD_CURSOR_ARRAY (ulValue);
            }

            // finally clear out any remaining cursor pels on this line.
            //
            if (cClear) 
            {
                for (j = 0; j < cClear; ++j) 
                {
                    P3RD_LOAD_CURSOR_ARRAY (P3RD_CURSOR_2_COLOR_TRANSPARENT);
                }
            }
        }

        // if we've loaded fewer than the full number of lines configured in the
        // cursor RAM, clear out the remaining lines. cRemPels is precalculated to
        // be the number of lines * number of pels per line.
        //
        if (cRemPels > 0)
        {
            do 
            {
                P3RD_LOAD_CURSOR_ARRAY (P3RD_CURSOR_2_COLOR_TRANSPARENT);
            } 
            while (--cRemPels > 0);
        }
    }

    // now set-up the cursor colors
    // Norte that the P3 cursor has the color LUT upside down.
    lutIndex0 = P3RD_CALCULATE_LUT_INDEX (0);
    lutIndex1 = P3RD_CALCULATE_LUT_INDEX (1);

    P3RD_CURSOR_PALETTE_CURSOR_RGB(lutIndex0, 0x00, 0x00, 0x00);
    P3RD_CURSOR_PALETTE_CURSOR_RGB(lutIndex1, 0xFF, 0xFF, 0xFF);

    // If the new cursor is different to the last cursor then set up
    // the hot spot and other bits'n'pieces. As we currently only support
    // mono cursors we don't need to reload the cursor palette
    if (ppdev->HWPtrLastCursor != cacheItem || !pointerIsCached)
    {
        // Make this item the last item
        ppdev->HWPtrLastCursor = cacheItem;

        P3RD_CURSOR_HOTSPOT(xHot, yHot);
    }

    if (x != -1)
    {
        vMovePointerP3RD (ppdev, x, y);

        // need to explicitly show the pointer
        vShowPointerP3RD(ppdev, TRUE);
    }

    DISPDBG((DBGLVL, "bSetPointerShapeP3RD done"));
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bSet3ColorPointerShapeP3RD
*
* stores the 3-color cursor in the RAMDAC: currently only 32bpp and 15/16bpp
* cursors are supported
*
\**************************************************************************/

BOOL
bSet3ColorPointerShapeP3RD(
PPDEV       ppdev,
SURFOBJ     *psoMask,   // defines AND and MASK bits for cursor
SURFOBJ     *psoColor,  // we may handle some color cursors at some point
LONG        x,          // If -1, pointer should be created hidden
LONG        y,
LONG        xHot,
LONG        yHot)
{
    LONG    cx, cy;
    LONG    cxcyCache;
    LONG    cjCacheRow, cjCacheRemx, cjCacheRemy, cj;
    BYTE    *pjAndMask, *pj;
    ULONG   *pulColor, *pul;
    LONG    cjAndDelta, cjColorDelta;
    LONG    iRow, iCol;
    BYTE    AndBit, AndByte;
    ULONG   CI2ColorIndex, CI2ColorData;
    ULONG   ulColor;
    ULONG   aulColorsIndexed[3];
    LONG    Index, HighestIndex = 0;
    ULONG   r, g, b;
    ULONG   whichOne = 0;
    GLINT_DECL_VARS;
    P3RD_DECL_VARS;
    
    GLINT_DECL_INIT;
    P3RD_DECL_INIT;

    DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD started"));

    cx = psoColor->sizlBitmap.cx;
    cy = psoColor->sizlBitmap.cy;

    if (cx <= 32 && cy <= 32)
    {
        ULONG curItem;
        cxcyCache = 32;

        // If we are using a mono/3-colour cursor in the first or second entry then
        // download to the third entry, otherwise use the first entry.
        curItem = (pP3RDinfo->cursorModeCurrent >> 1) & 0x7;
        if (curItem == 1 || curItem == 2)
            whichOne = 2;

        pP3RDinfo->cursorSize = P3RD_CURSOR_SIZE_32_3COLOR;
        pP3RDinfo->cursorModeCurrent = pP3RDinfo->cursorModeOff | P3RD_CURSOR_SEL(pP3RDinfo->cursorSize, whichOne) | P3RD_CURSOR_MODE_3COLOR;

        // We don't cache color cursors, because we want to force the mono cursor to use the 
        // either the first or third entries we can't just do a HWPointerCacheInvalidate(), because
        // the mono cursor code will use the first entry or the time. So, if we want the 
        // mono code to use the 3rd entry we say that first 2 cache entries are valid but mess them        
        // up by incrementing the first byte, so that the cache check will always fail.
        ppdev->HWPtrCache.ptrCacheInUseCount = (BYTE) whichOne;
        for (iCol = 0; iCol < ppdev->HWPtrCache.ptrCacheInUseCount; iCol++)
            (*(((BYTE *) ppdev->HWPtrCache.ptrCacheData) + (iCol * SMALL_POINTER_MEM)))++;

    }
    else if (cx <= 64 && cy <= 64)
    {
        // 64x64 cursor : we'll cache it in cursor partition 0 and scrub the old cache
        cxcyCache = 64;

        pP3RDinfo->cursorSize = P3RD_CURSOR_SIZE_64_3COLOR;
        pP3RDinfo->cursorModeCurrent = pP3RDinfo->cursorModeOff | P3RD_CURSOR_SEL(pP3RDinfo->cursorSize, 0) | P3RD_CURSOR_MODE_3COLOR;

        // we don't cache color cursors
        HWPointerCacheInvalidate (&(ppdev->HWPtrCache));
    }
    else
    {
        DISPDBG((DBGLVL, "declining cursor: %d x %d is too big", cx, cy));
        return(FALSE);  // cursor is too big to fit in the hardware
    }

    // work out the remaining bytes in the cache (in x and y) that will need clearing
    cjCacheRow  = 2 * cxcyCache / 8;
    cjCacheRemx =  cjCacheRow - 2 * ((cx+7) / 8);
    cjCacheRemy = (cxcyCache - cy) * cjCacheRow;

    // set-up a pointer to the 1bpp AND mask bitmap
    pjAndMask = psoMask->pvScan0;
    cjAndDelta = psoMask->lDelta;

    // set-up a pointer to the 32bpp color bitmap
    pulColor = psoColor->pvScan0;
    cjColorDelta = psoColor->lDelta;

    // Hide the pointer
    vShowPointerP3RD(ppdev, FALSE);

    // load the cursor array (we have auto-increment turned on so initialize to entry 0 here)
    P3RD_CURSOR_ARRAY_START(whichOne * (32 * 32 * 2 / 8));
    for (iRow = 0; iRow < cy; ++iRow, pjAndMask += cjAndDelta, (BYTE *)pulColor += cjColorDelta)
    {
        DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: Row %d (of %d): pjAndMask(%p) pulColor(%p)", iRow, cy, pjAndMask, pulColor));
        pj = pjAndMask;
        pul = pulColor;
        CI2ColorIndex = CI2ColorData = 0;

        for (iCol = 0; iCol < cx; ++iCol, CI2ColorIndex += 2)
        {
            AndBit = (BYTE)(7 - (iCol & 7));
            if (AndBit == 7)
            {
                // we're onto the next byte of the and mask
                AndByte = *pj++;
            }
            if (CI2ColorIndex == 8)
            {
                // we've filled a byte with 4 CI2 colors
                DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: writing cursor data %xh", CI2ColorData));
                P3RD_LOAD_CURSOR_ARRAY(CI2ColorData);
                CI2ColorData = 0;
                CI2ColorIndex = 0;
            }

            // get the source pixel
            if (ppdev->cPelSize == GLINTDEPTH32)
            {
                ulColor = *pul++;
            }
            else
            {
                ulColor = *(USHORT *)pul;
                (USHORT *)pul += 1;
            }

            DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: Column %d (of %d) AndByte(%08xh) AndBit(%d) ulColor(%08xh)", iCol, cx, AndByte, AndBit, ulColor));

//@@BEGIN_DDKSPLIT
#if 0
            // TMM: We only used to assume a pixel was transparent if the
            // AND mask bit was set and the pixel was zero, I am pretty sure
            // that this is wrong. We also used to do some stuff with 
            // inverse pixels but that was wrong as well.
            if(AndByte & (1 << AndBit))
            {
                // transparent and seeing as the CI2ColorData is initialized to 0 we don't
                // have to explicitly clear these bits - go on to the next pixel
                DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: transparent - ignore"));
                continue;
            }
#else
//@@END_DDKSPLIT
            // Figure out what to do with it:-
            // AND  Color   Result
            //  0     X     color
            //  1     0     transparent
            //  1     1     inverse
            if (AndByte & (1 << AndBit))
            {
                // Transparent or inverse
                if (ulColor == ppdev->ulWhite)
                {
                    // color == white: inverse, but we don't support this. We've destroyed the cache for nothing
                    DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: failed - inverted colors aren't supported"));
                    return(FALSE);
                }

//@@BEGIN_DDKSPLIT
                // if we get here the color should be black. However, if the pointer surface has been translated it
                // might not be exactly black (e.g. as for the pointer at the start of Riven), so we don't do the test
                //if(ulColor == 0)
//@@END_DDKSPLIT
                {
                    // color == black: transparent and seeing as the CI2ColorData is initialized to 0 we don't
                    //have to explicitly clear these bits - go on to the next pixel
                    DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: transparent - ignore"));
                    continue;
                }
            }
//@@BEGIN_DDKSPLIT
#endif
//@@END_DDKSPLIT

            // get the index for this color: first see if we've already indexed it
            DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: looking up color %08xh", ulColor));

            for(Index = 0; Index < HighestIndex && aulColorsIndexed[Index] != ulColor; ++Index);

            if (Index == 3)
            {
                // too many colors in this cursor
                DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: failed - cursor has more than 3 colors"));
                return(FALSE);
            }
            else if (Index == HighestIndex)
            {
                // we've found another color: add it to the color index
                DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: adding %08xh to cursor palette", ulColor));
                aulColorsIndexed[HighestIndex++] = ulColor;
            }
            // add this pixel's index to the CI2 cursor data. NB. Need Index+1 as 0 == transparent
            CI2ColorData |= (Index + 1) <<  CI2ColorIndex;
        }

        // end of the cursor row: save the remaining indexed pixels then blank any unused columns
        DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: writing remaining data for this row (%08xh) and %d trailing bytes", CI2ColorData, cjCacheRemx));

        P3RD_LOAD_CURSOR_ARRAY(CI2ColorData);

        if (cjCacheRemx)
        {
            for (cj = cjCacheRemx; --cj >=0;)
            {
                P3RD_LOAD_CURSOR_ARRAY(P3RD_CURSOR_3_COLOR_TRANSPARENT);
            }
        }
    }

    // end of cursor: blank any unused rows Nb. cjCacheRemy == cy blank rows * cj bytes per row
    DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: writing %d trailing bytes for this cursor", cjCacheRemy));

    for (cj = cjCacheRemy; --cj >= 0;)
    {
        // 0 == transparent
        P3RD_LOAD_CURSOR_ARRAY(P3RD_CURSOR_3_COLOR_TRANSPARENT);
    }

    DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: setting up the cursor palette"));

    // now set-up the cursor palette

    for (iCol = 0; iCol < HighestIndex; ++iCol)
    {
        ULONG lutIndex;

        // the cursor colors are at native depth, convert them to 24bpp
        if (ppdev->cPelSize == GLINTDEPTH32)
        {
            // 32bpp
            b = 0xff &  aulColorsIndexed[iCol];
            g = 0xff & (aulColorsIndexed[iCol] >> 8);
            r = 0xff & (aulColorsIndexed[iCol] >> 16);
        }
        else //(ppdev->cPelSize == GLINTDEPTH16)
        {
            if (ppdev->ulWhite == 0xffff)
            {
                // 16bpp
                b = (0x1f &  aulColorsIndexed[iCol])         << 3;
                g = (0x3f & (aulColorsIndexed[iCol] >> 5))   << 2;
                r = (0x1f & (aulColorsIndexed[iCol] >> 11))  << 3;
            }
            else
            {
                // 15bpp
                b = (0x1f &  aulColorsIndexed[iCol])         << 3;
                g = (0x1f & (aulColorsIndexed[iCol] >> 5))   << 3;
                r = (0x1f & (aulColorsIndexed[iCol] >> 10))  << 3;
            }
        }
        // The P3 cursor has the color LUT upside down.
        lutIndex = P3RD_CALCULATE_LUT_INDEX (iCol);
        P3RD_CURSOR_PALETTE_CURSOR_RGB(lutIndex, r, g, b);
    }

    // enable the cursor
    P3RD_CURSOR_HOTSPOT(xHot, yHot);
    if (x != -1)
    {
        vMovePointerP3RD (ppdev, x, y);

        // need to explicitly show the pointer
        vShowPointerP3RD(ppdev, TRUE);
    }

    DISPDBG((DBGLVL, "b3ColorSetPointerShapeP3RD done"));
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bSet15ColorPointerShapeP3RD
*
* stores the 15-color cursor in the RAMDAC: currently only 32bpp and 15/16bpp
* cursors are supported
*
\**************************************************************************/

BOOL
bSet15ColorPointerShapeP3RD(
PPDEV       ppdev,
SURFOBJ     *psoMask,   // defines AND and MASK bits for cursor
SURFOBJ     *psoColor,  // we may handle some color cursors at some point
LONG        x,          // If -1, pointer should be created hidden
LONG        y,
LONG        xHot,
LONG        yHot)
{
    LONG    cx, cy;
    LONG    cxcyCache;
    LONG    cjCacheRow, cjCacheRemx, cjCacheRemy, cj;
    BYTE    *pjAndMask, *pj;
    ULONG   *pulColor, *pul;
    LONG    cjAndDelta, cjColorDelta;
    LONG    iRow, iCol;
    BYTE    AndBit, AndByte;
    ULONG   CI4ColorIndex, CI4ColorData;
    ULONG   ulColor;
    ULONG   aulColorsIndexed[15];
    LONG    Index, HighestIndex = 0;
    ULONG   r, g, b;
    ULONG   whichOne = 0;
    GLINT_DECL_VARS;
    P3RD_DECL_VARS;
    
    GLINT_DECL_INIT;
    P3RD_DECL_INIT;

    DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD started"));

    // If we are switching from a mono cursor to a colour one then disable
    // the cursor in the cursor mode. Note that this is potentially dangerous
    // and we are seeing screen flashes on occasions.
    if (pP3RDinfo->cursorSize == P3RD_CURSOR_SIZE_32_MONO || pP3RDinfo->cursorSize == P3RD_CURSOR_SIZE_64_MONO)
    {
        DISABLE_CURSOR_MODE();
    }

    cx = psoColor->sizlBitmap.cx;
    cy = psoColor->sizlBitmap.cy;

    if (cx <= 32 && cy <= 32)
    {
        ULONG curItem;
        cxcyCache = 32;

        // If we are using a mono cursor in the first or second entry, or we have a
        // 15 colour cursor in the top half of cursor memory then download
        // this colour cursor to the download to the 2nd half of cursor memory, otherwise
        // download to the top half.
        curItem = (pP3RDinfo->cursorModeCurrent >> 1) & 0x7;
        if (curItem == 1 || curItem == 2 || curItem == 5)
            whichOne = 1;
        
        pP3RDinfo->cursorSize = P3RD_CURSOR_SIZE_32_15COLOR;
        pP3RDinfo->cursorModeCurrent = pP3RDinfo->cursorModeOff | P3RD_CURSOR_SEL(pP3RDinfo->cursorSize, whichOne) | P3RD_CURSOR_MODE_15COLOR;

        // We don't cache color cursors, because we want to force the mono cursor to use the 
        // either the first or third entries we can't just do a HWPointerCacheInvalidate(), because
        // the mono cursor code will use the first entry or the time. So, if we want the 
        // mono code to use the 3rd entry we say that first 2 cache entries are valid but mess them
        // up by incrementing the first byte, so that the cache check will always fail.
        ppdev->HWPtrCache.ptrCacheInUseCount = (whichOne == 0) ? 2 : 0;
        for (iCol = 0; iCol < ppdev->HWPtrCache.ptrCacheInUseCount; iCol++)
            (*(((BYTE *) ppdev->HWPtrCache.ptrCacheData) + (iCol * SMALL_POINTER_MEM)))++;
    }
    else if (cx <= 64 && cy <= 64)
    {
        // it's too big to cache as a fifteen color cursor, but we might just be able to cache it
        // if it has 3 or fewer colors
        BOOL bRet;

        bRet = bSet3ColorPointerShapeP3RD(ppdev, psoMask, psoColor, x, y, xHot, yHot);
        return(bRet);
    }
    else
    {
        DISPDBG((DBGLVL, "declining cursor: %d x %d is too big", cx, cy));
        return(FALSE);  // cursor is too big to fit in the hardware
    }

    // work out the remaining bytes in the cache (in x and y) that will need clearing
    cjCacheRow  = 2 * cxcyCache / 8;
    cjCacheRemx =  cjCacheRow - 2 * ((cx+7) / 8);
    cjCacheRemy = (cxcyCache - cy) * cjCacheRow;

    // set-up a pointer to the 1bpp AND mask bitmap
    pjAndMask = psoMask->pvScan0;
    cjAndDelta = psoMask->lDelta;

    // set-up a pointer to the 32bpp color bitmap
    pulColor = psoColor->pvScan0;
    cjColorDelta = psoColor->lDelta;

    // hide the pointer
    vShowPointerP3RD(ppdev, FALSE);

    // load the cursor array (we have auto-increment turned on so initialize to entry 0 here)
    P3RD_CURSOR_ARRAY_START(whichOne * (32 * 32 * 4 / 8));
    for (iRow = 0; iRow < cy; ++iRow, pjAndMask += cjAndDelta, (BYTE *)pulColor += cjColorDelta)
    {
        DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: Row %d (of %d): pjAndMask(%p) pulColor(%p)", iRow, cy, pjAndMask, pulColor));
        pj = pjAndMask;
        pul = pulColor;
        CI4ColorIndex = CI4ColorData = 0;

        for (iCol = 0; iCol < cx; ++iCol, CI4ColorIndex += 4)
        {
            AndBit = (BYTE)(7 - (iCol & 7));
            if (AndBit == 7)
            {
                // we're onto the next byte of the and mask
                AndByte = *pj++;
            }
            if (CI4ColorIndex == 8)
            {
                // we've filled a byte with 2 CI4 colors
                DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: writing cursor data %xh", CI4ColorData));
                P3RD_LOAD_CURSOR_ARRAY(CI4ColorData);
                CI4ColorData = 0;
                CI4ColorIndex = 0;
            }

            // get the source pixel
            if (ppdev->cPelSize == GLINTDEPTH32)
            {
                ulColor = *pul++;
            }
            else
            {
                ulColor = *(USHORT *)pul;
                (USHORT *)pul += 1;
            }

            DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: Column %d (of %d) AndByte(%08xh) AndBit(%d) ulColor(%08xh)", iCol, cx, AndByte, AndBit, ulColor));

//@@BEGIN_DDKSPLIT
#if 0
            // TMM: We only used to assume a pixel was transparent if the
            // AND mask bit was set and the pixel was zero, I am pretty sure
            // that this is wrong. We also used to do some stuff with 
            // inverse pixels but that was wrong as well.
            if(AndByte & (1 << AndBit))
            {
                // transparent and seeing as the CI2ColorData is initialized to 0 we don't
                // have to explicitly clear these bits - go on to the next pixel
                DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: transparent - ignore"));
                continue;
            }
#else
//@@END_DDKSPLIT
            // Figure out what to do with it:-
            // AND  Color   Result
            //  0     X     color
            //  1     0     transparent
            //  1     1     inverse
            if (AndByte & (1 << AndBit))
            {
                // Transparent or inverse
                if(ulColor == ppdev->ulWhite)
                {
                    // color == white: inverse, but we don't support this. We've destroyed the cache for nothing
                    DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: failed - inverted colors aren't supported"));
                    return(FALSE);
                }

                // if we get here the color should be black. However, if the pointer surface has been translated it
                // might not be exactly black (e.g. as for the pointer at the start of Riven), so we don't do the test
                //if(ulColor == 0)
                {
                    // color == black: transparent and seeing as the CI2ColorData is initialized to 0 we don't
                    //have to explicitly clear these bits - go on to the next pixel
                    DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: transparent - ignore"));
                    continue;
                }
            }
//@@BEGIN_DDKSPLIT
#endif
//@@END_DDKSPLIT

            // get the index for this color: first see if we've already indexed it
            DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: looking up color %08xh", ulColor));

            for (Index = 0; Index < HighestIndex && aulColorsIndexed[Index] != ulColor; ++Index);

            if (Index == 15)
            {
                // too many colors in this cursor
                DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: failed - cursor has more than 15 colors"));
                return(FALSE);
            }
            else if (Index == HighestIndex)
            {
                // we've found another color: add it to the color index
                DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: adding %08xh to cursor palette", ulColor));
                aulColorsIndexed[HighestIndex++] = ulColor;
            }
            // add this pixel's index to the CI4 cursor data. NB. Need Index+1 as 0 == transparent
            CI4ColorData |= (Index + 1) << CI4ColorIndex;
        }

        // end of the cursor row: save the remaining indexed pixels then blank any unused columns
        DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: writing remaining data for this row (%08xh) and %d trailing bytes", CI4ColorData, cjCacheRemx));

        P3RD_LOAD_CURSOR_ARRAY(CI4ColorData);

        if (cjCacheRemx)
        {
            for (cj = cjCacheRemx; --cj >=0;)
            {
                P3RD_LOAD_CURSOR_ARRAY(P3RD_CURSOR_15_COLOR_TRANSPARENT);
            }
        }
    }

    // end of cursor: blank any unused rows Nb. cjCacheRemy == cy blank rows * cj bytes per row

    DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: writing %d trailing bytes for this cursor", cjCacheRemy));

    for (cj = cjCacheRemy; --cj >= 0;)
    {
        // 0 == transparent
        P3RD_LOAD_CURSOR_ARRAY(P3RD_CURSOR_15_COLOR_TRANSPARENT);
    }

    DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: setting up the cursor palette"));

    // now set-up the cursor palette

    for (iCol = 0; iCol < HighestIndex; ++iCol)
    {
        ULONG lutIndex;

        // the cursor colors are at native depth, convert them to 24bpp

        if (ppdev->cPelSize == GLINTDEPTH32)
        {
            // 32bpp
            b = 0xff &  aulColorsIndexed[iCol];
            g = 0xff & (aulColorsIndexed[iCol] >> 8);
            r = 0xff & (aulColorsIndexed[iCol] >> 16);
        }
        else //(ppdev->cPelSize == GLINTDEPTH16)
        {
            if (ppdev->ulWhite == 0xffff)
            {
                // 16bpp
                b = (0x1f &  aulColorsIndexed[iCol])         << 3;
                g = (0x3f & (aulColorsIndexed[iCol] >> 5))   << 2;
                r = (0x1f & (aulColorsIndexed[iCol] >> 11))  << 3;
            }
            else
            {
                // 15bpp
                b = (0x1f &  aulColorsIndexed[iCol])         << 3;
                g = (0x1f & (aulColorsIndexed[iCol] >> 5))   << 3;
                r = (0x1f & (aulColorsIndexed[iCol] >> 10))  << 3;
            }
        }
        // The P3 cursor has the color LUT upside down.
        lutIndex = P3RD_CALCULATE_LUT_INDEX (iCol);
        P3RD_CURSOR_PALETTE_CURSOR_RGB(lutIndex, r, g, b);
    }

    // enable the cursor
    P3RD_CURSOR_HOTSPOT(xHot, yHot);
    if (x != -1)
    {
        vMovePointerP3RD (ppdev, x, y);
        // need to explicitly show the pointer
        vShowPointerP3RD(ppdev, TRUE);
    }

    DISPDBG((DBGLVL, "b3ColorSetPointerShapeP3RD done"));
    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vEnablePointerP3RD
*
* Get the hardware ready to use the 3Dlabs P3RD hardware pointer.
*
\**************************************************************************/

VOID
vEnablePointerP3RD(
PPDEV ppdev)
{
    pP3RDRAMDAC pRamdac;
    ULONG       ul;

    GLINT_DECL_VARS;
    P3RD_DECL_VARS;
    
    GLINT_DECL_INIT;

    DISPDBG((DBGLVL, "vEnablePointerP3RD called"));

    ppdev->pvPointerData = &ppdev->ajPointerData[0];
    
    P3RD_DECL_INIT;
    // get a pointer to the RAMDAC registers from the memory mapped
    // control register space.
    //
    pRamdac = (pP3RDRAMDAC)(ppdev->pulRamdacBase);

    // set up memory mapping for the control registers and save in the pointer
    // specific area provided in ppdev.
    //

    P3RD_PAL_WR_ADDR    = TRANSLATE_ADDR(&(pRamdac->RDPaletteWriteAddress));
    P3RD_PAL_RD_ADDR    = TRANSLATE_ADDR(&(pRamdac->RDPaletteAddressRead));
    P3RD_PAL_DATA       = TRANSLATE_ADDR(&(pRamdac->RDPaletteData));
    P3RD_PIXEL_MASK     = TRANSLATE_ADDR(&(pRamdac->RDPixelMask));
    P3RD_INDEX_ADDR_HI  = TRANSLATE_ADDR(&(pRamdac->RDIndexHigh));
    P3RD_INDEX_ADDR_LO  = TRANSLATE_ADDR(&(pRamdac->RDIndexLow));
    P3RD_INDEX_DATA     = TRANSLATE_ADDR(&(pRamdac->RDIndexedData));
    P3RD_INDEX_CONTROL  = TRANSLATE_ADDR(&(pRamdac->RDIndexControl));

    // not used, but set-up zero anyway
    ppdev->xPointerHot = 0;
    ppdev->yPointerHot = 0;

    // enable auto-increment
    ul = READ_P3RDREG_ULONG(P3RD_INDEX_CONTROL);
    ul |= P3RD_IDX_CTL_AUTOINCREMENT_ENABLED;
    WRITE_P3RDREG_ULONG(P3RD_INDEX_CONTROL, ul);

    P3RD_READ_INDEX_REG(P3RD_CURSOR_CONTROL, pP3RDinfo->cursorControl);

    pP3RDinfo->cursorModeCurrent = pP3RDinfo->cursorModeOff = 0;
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_MODE, pP3RDinfo->cursorModeOff);

    P3RD_INDEX_REG(P3RD_CURSOR_X_LOW);
    P3RD_LOAD_DATA(0);    // cursor x low
    P3RD_LOAD_DATA(0);    // cursor x high
    P3RD_LOAD_DATA(0);    // cursor y low
    P3RD_LOAD_DATA(0xff); // cursor y high
    P3RD_LOAD_DATA(0);    // cursor x hotspot
    P3RD_LOAD_DATA(0);    // cursor y hotspot
}

/******************************Public*Routine******************************\
* BOOL vDisablePointerP3RD
*
* Does basic pointer tidying up.
\**************************************************************************/

VOID vDisablePointerP3RD(PDEV * ppdev)
{
    // Undraw the pointer, may not be necessary on P3, but we do it
    // on P2.
    vShowPointerP3RD(ppdev, FALSE);
}

//@@BEGIN_DDKSPLIT
#if 0
/******************************Public*Routine******************************\
* VOID vSetOverlayModeP3RD
*
* Enable or disable RAMDAC overlays for the P3RD RAMDAC.
*
*
\**************************************************************************/

VOID
vSetOverlayModeP3RD (PDEV * ppdev, 
ULONG   EnableOverlay,                // 0 to disable, 1 to enable
ULONG   TransparentColor)
{
    ULONG p3rdVal;
    GLINT_DECL_VARS;
    P3RD_DECL_VARS;
    GLINT_DECL_INIT;
    P3RD_DECL_INIT;

    P3RD_READ_INDEX_REG (P3RD_MISC_CONTROL, p3rdVal);        // Read current setting

    if (EnableOverlay == GLINT_ENABLE_OVERLAY)
    {
        // Enable Overlay
        p3rdVal |= P3RD_MISC_CONTROL_OVERLAYS_ENABLED;        // Enable overlays
        p3rdVal |= P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;    // Enable direct colour
        P3RD_LOAD_INDEX_REG (P3RD_MISC_CONTROL, p3rdVal);

        P3RD_LOAD_INDEX_REG (P3RD_OVERLAY_KEY, TransparentColor);    // Set transparent colour
    }
    else
    {
        // Disable Overlay
        p3rdVal &= ~P3RD_MISC_CONTROL_OVERLAYS_ENABLED;        // Disable overlays
        p3rdVal &= ~P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;    // Disable direct colour
        P3RD_LOAD_INDEX_REG (P3RD_MISC_CONTROL, p3rdVal);
    }
}

VOID 
vP3RDSetPixelMask(
PPDEV   ppdev,
ULONG   ulMask)
{
    GLINT_DECL_VARS;
    P3RD_DECL_VARS;
    GLINT_DECL_INIT;
    P3RD_DECL_INIT;
    P3RD_SET_PIXEL_READMASK (ulMask);
}

/******************************Public*Routine******************************\
* BOOL bP3RDSwapCSBuffers
*
* Use the pixel read mask to perform color space double buffering. This is
* only called when we have 12bpp with interleaved nibbles. We do a polled
* wait for VBLANK before the swap. In the future we may do all this in the
* miniport via interrupts.
*
* Returns
*   We should never be called if this is inappropriate so return TRUE.
*
\**************************************************************************/

BOOL
bP3RDSwapCSBuffers(
PPDEV   ppdev,
LONG    bufNo)
{
    ULONG index;
    ULONG color;
    GLINT_DECL_VARS;
    P3RD_DECL_VARS;
    GLINT_DECL_INIT;
    P3RD_DECL_INIT;

    // work out the RAMDAC read pixel mask for the buffer, wait for VBLANK
    // and switch it.
    //
    DISPDBG((DBGLVL, "loading the palette to swap to buffer %d", bufNo));
    P3RD_PALETTE_START_WR (0);
    GLINT_WAIT_FOR_VBLANK;     
    if (bufNo == 0)
    {
        for (index = 0; index < 16; ++index)
            for (color = 0; color <= 0xff; color += 0x11)
                P3RD_LOAD_PALETTE (color, color, color);
    }
    else
    {
        for (color = 0; color <= 0xff; color += 0x11)
            for (index = 0; index < 16; ++index)
                P3RD_LOAD_PALETTE (color, color, color);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bP3RDCheckCSBuffering
*
* Determine whether we can do color space double buffering in the current
* mode.
*
* Returns
*   TRUE if we can do the color space double buffering, FALSE otherwise.
*
\**************************************************************************/

BOOL
bP3RDCheckCSBuffering(PPDEV ppdev)
{
    // pixels must be 32 bits deep. White is set to the combined masks for
    // each of red, green and blue. The pattern 0x0f0f0f is unique to
    // interleaved 12 bpp mode.
    //
    return ((ppdev->cPelSize == 2) && (ppdev->ulWhite == 0x0f0f0f));
}

#endif
//@@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\lines.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: lines.h
*
* Content: Line drawing constants and structures.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

typedef struct _PDEV PDEV;      // Handy forward declaration

// We have to be careful that we don't overflow any registers when using
// the hardware to draw lines (as opposed to going through the strips
// routines, which will never overflow).  We accomplish this by simply
// checking the bounds of the path; if it is so large that any of the
// hardware terms may overflow, we punt the entire path to the strips
// code (should be pretty rare).

#define MAX_INTEGER_BOUND  (1535)   // S3's line length term is limited to
#define MIN_INTEGER_BOUND  (-512)   //   a maximum value of 2047

// We have special strip routines when all strips have at most this many
// pixels:

#define MAX_SHORT_STROKE_LENGTH 15

// # of strip drawers in every group:

#define NUM_STRIP_DRAW_DIRECTIONS 4

// # of strip drawers for doing either solid lines or styled lines:

#define NUM_STRIP_DRAW_STYLES 8

typedef LONG STYLEPOS;

#define STYLE_MAX_COUNT     16
#define STYLE_MAX_VALUE     0x3fffL
#define RUN_MAX             20
#define STRIP_MAX           100
#define STYLE_DENSITY       3

// Flip and round flags:

#define FL_H_ROUND_DOWN         0x00000080L     // .... .... 1... ....
#define FL_V_ROUND_DOWN         0x00000100L     // .... ...1 .... ....

#define FL_FLIP_D               0x00000005L     // .... .... .... .1.1
#define FL_FLIP_V               0x00000008L     // .... .... .... 1...
#define FL_FLIP_SLOPE_ONE       0x00000010L     // .... .... ...1 ....
#define FL_FLIP_HALF            0x00000002L     // .... .... .... ..1.
#define FL_FLIP_H               0x00000200L     // .... ..1. .... ....

#define FL_ROUND_MASK           0x0000001CL     // .... .... ...1 11..
#define FL_ROUND_SHIFT          2

#define FL_RECTLCLIP_MASK       0x0000000CL     // .... .... .... 11..
#define FL_RECTLCLIP_SHIFT      2

#define FL_STRIP_MASK           0x00000003L     // .... .... .... ..11
#define FL_STRIP_SHIFT          0

#define FL_SIMPLE_CLIP          0x00000020      // .... .... ..1. ....
#define FL_COMPLEX_CLIP         0x00000040      // .... .... .1.. ....
#define FL_CLIP                (FL_SIMPLE_CLIP | FL_COMPLEX_CLIP)

#define FL_ARBITRARYSTYLED      0x00000400L     // .... .1.. .... ....
#define FL_MASKSTYLED           0x00000800L     // .... 1... .... ....
#define FL_STYLED              (FL_ARBITRARYSTYLED | FL_MASKSTYLED)
#define FL_ALTERNATESTYLED      0x00001000L     // ...1 .... .... ....

#define FL_STYLE_MASK           0x00000C00L
#define FL_STYLE_SHIFT          10

// Simpler flag bits in high byte:

#define FL_DONT_DO_HALF_FLIP    0x00002000L     // ..1. .... .... ....
#define FL_PHYSICAL_DEVICE      0x00004000L     // .1.. .... .... ....

// Logical operation which requires a read (for GLINT)
#define FL_READ                 0x00008000L     // 1... .... .... ....

// Miscellaneous DDA defines:

#define LROUND(x, flRoundDown) (((x) + F/2 - ((flRoundDown) > 0)) >> 4)
#define F                     16
#define FLOG2                 4
#define LFLOOR(x)             ((x) >> 4)
#define FXFRAC(x)             ((x) & (F - 1))

////////////////////////////////////////////////////////////////////////////
// NOTE: The following structures must exactly match those declared in
//       lines.inc!

typedef struct _STRIP {
    LONG   cStrips;               // # of strips in array
    LONG   flFlips;               // Indicates if line goes up or down
    POINTL ptlStart;             // first point
    LONG   alStrips[STRIP_MAX];   // Array of strips
} STRIP;

typedef struct _LINESTATE {
    STYLEPOS*       pspStart;       // Pointer to start of style array
    STYLEPOS*       pspEnd;         // Pointer to end of style array
    STYLEPOS*       psp;            // Pointer to current style entry

    STYLEPOS        spRemaining;    // To go in current style
    STYLEPOS        spTotal;        // Sum of style array
    STYLEPOS        spTotal2;       // Twice sum of style array
    STYLEPOS        spNext;         // Style state at start of next line
    STYLEPOS        spComplex;      // Style state at start of complex clip line

    STYLEPOS*       aspRtoL;        // Style array in right-to-left order
    STYLEPOS*       aspLtoR;        // Style array in left-to-right order

    ULONG           ulStyleMask;    // Are we working on a gap in the style?
                                    // 0xff if yes, 0x0 if not
    ULONG           xyDensity;      // Density of style
    ULONG           cStyle;         // Size of style array

    ULONG           ulStyleMaskLtoR;// Original style mask, left-to-right order
    ULONG           ulStyleMaskRtoL;// Original style mask, right-to-left order

    BOOL            ulStartMask;    // Determines if first element in style
                                    // array is for a gap or a dash

} LINESTATE;                        /* ls */

// Strip drawer prototype:

typedef VOID (*PFNSTRIP)(PDEV*, STRIP*, LINESTATE*);

// Strip drawers (P3RX):

VOID vPXRXSolidHorizontalLine(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vPXRXSolidVerticalLine(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vPXRXSolidDiagonalHorizontalLine(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vPXRXSolidDiagonalVerticalLine(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vPXRXStyledHorizontalLine(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vPXRXStyledVerticalLine(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

// External calls:

BOOL bLines(PDEV*, POINTFIX*, POINTFIX*, RUN* prun, ULONG,
            LINESTATE*, RECTL*, PFNSTRIP*, FLONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\p3rd.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: p3rd.h
*
* Content: This module contains the definitions for the P2ST internal RAMDAC.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#define VideoDebugPrint

//
// 3Dlabs P3RD RAMDAC definitions
// This set of registers resides at &(pCtrlRegs->ExternalVideo)
//
typedef struct _p3rd_regs
{
    RAMDAC_REG  RDPaletteWriteAddress;
    RAMDAC_REG  RDPaletteData;
    RAMDAC_REG  RDPixelMask;
    RAMDAC_REG  RDPaletteAddressRead;
    RAMDAC_REG  RDIndexLow;
    RAMDAC_REG  RDIndexHigh;
    RAMDAC_REG  RDIndexedData;
    RAMDAC_REG  RDIndexControl;

} P3RDRAMDAC, *pP3RDRAMDAC;

// structure containing the mapped addresses for each of the P3RD registers.
// We need this since some chips like the Alpha cannot be accessed by simply
// writing to the memory mapped register. So instead we set up the following
// struct of memory addresses at init time and use these instead. All these
// addresses must be passed to WRITE/READ_FAST_ULONG.
// We also keep software copies of various registers in here so we can turn
// on and off individual bits more easily.
//
typedef struct _p3rd_data {

    // register addresses

    ULONG * RDPaletteWriteAddress;
    ULONG * RDPaletteData;
    ULONG * RDPixelMask;
    ULONG * RDPaletteAddressRead;
    ULONG * RDIndexLow;
    ULONG * RDIndexHigh;
    ULONG * RDIndexedData;
    ULONG * RDIndexControl;

    // RAMDAC state info
    ULONG       cursorModeOff;        // cursor disabled
    ULONG       cursorModeCurrent;    // disabled 32/64 mode cursor 
    ULONG       cursorControl;        // x & y zoom, etc.
    ULONG       cursorSize;            // see P3RD_CURSOR_SIZE_*
    ULONG       x, y;
} P3RDData, *pP3RDData;


// macro declared by any function wishing to use the P2ST internal RAMDAC . MUST be declared
// after GLINT_DECL.
//
#define P3RD_DECL_VARS pP3RDData pP3RDinfo
#define P3RD_DECL_INIT pP3RDinfo = (pP3RDData)(ppdev->pvPointerData = &ppdev->ajPointerData[0])

#define P3RD_DECL \
            P3RD_DECL_VARS; \
            P3RD_DECL_INIT

// use the following macros as the address to pass to the
// WRITE_P3RDREG_ULONG function
//
//  Palette Access
#define P3RD_PAL_WR_ADDR            (pP3RDinfo->RDPaletteWriteAddress)
#define P3RD_PAL_RD_ADDR            (pP3RDinfo->RDPaletteAddressRead)
#define P3RD_PAL_DATA               (pP3RDinfo->RDPaletteData)

// Pixel mask
#define P3RD_PIXEL_MASK             (pP3RDinfo->RDPixelMask)

// Access to the indexed registers
#define P3RD_INDEX_ADDR_LO          (pP3RDinfo->RDIndexLow)
#define P3RD_INDEX_ADDR_HI          (pP3RDinfo->RDIndexHigh)
#define P3RD_INDEX_DATA             (pP3RDinfo->RDIndexedData)
#define P3RD_INDEX_CONTROL          (pP3RDinfo->RDIndexControl)


// bit field definitions for the direct access registers
#define P3RD_IDX_CTL_AUTOINCREMENT_ENABLED  0x01

// indexed register definitions accessed via P3RD_LOAD_INDEX_REG() and P3RD_READ_INDEX_REG()
#define P3RD_MISC_CONTROL               0x0000
#define P3RD_SYNC_CONTROL               0x0001
#define P3RD_DAC_CONTROL                0x0002
#define P3RD_PIXEL_SIZE                 0x0003
#define P3RD_COLOR_FORMAT               0x0004
#define P3RD_CURSOR_MODE                0x0005
#define P3RD_CURSOR_CONTROL             0x0006
#define P3RD_CURSOR_X_LOW               0x0007
#define P3RD_CURSOR_X_HIGH              0x0008
#define P3RD_CURSOR_Y_LOW               0x0009
#define P3RD_CURSOR_Y_HIGH              0x000a
#define P3RD_CURSOR_HOTSPOT_X           0x000b
#define P3RD_CURSOR_HOTSPOT_Y           0x000c
#define P3RD_OVERLAY_KEY                0x000d
#define P3RD_PAN                        0x000e
#define P3RD_SENSE                      0x000f
#define P3RD_CHECK_CONTROL              0x0018
#define P3RD_CHECK_PIXEL_RED            0x0019
#define P3RD_CHECK_PIXEL_GREEN          0x001a
#define P3RD_CHECK_PIXEL_BLUE           0x001b
#define P3RD_CHECK_LUT_RED              0x001c
#define P3RD_CHECK_LUT_GREEN            0x001d
#define P3RD_CHECK_LUT_BLUE             0x001e
#define P3RD_DCLK_SETUP_1               0x01f0
#define P3RD_DCLK_SETUP_2               0x01f1
#define P3RD_MCLK_SETUP_1               0x01f2
#define P3RD_MCLK_SETUP_2               0x01f3
#define P3RD_DCLK_CONTROL               0x0200
#define P3RD_DCLK0_PRE_SCALE            0x0201
#define P3RD_DCLK0_FEEDBACK_SCALE       0x0202
#define P3RD_DCLK0_POST_SCALE           0x0203
#define P3RD_DCLK1_PRE_SCALE            0x0204
#define P3RD_DCLK1_FEEDBACK_SCALE       0x0205
#define P3RD_DCLK1_POST_SCALE           0x0206
#define P3RD_DCLK2_PRE_SCALE            0x0207
#define P3RD_DCLK2_FEEDBACK_SCALE       0x0208
#define P3RD_DCLK2_POST_SCALE           0x0209
#define P3RD_DCLK3_PRE_SCALE            0x020a
#define P3RD_DCLK3_FEEDBACK_SCALE       0x020b
#define P3RD_DCLK3_POST_SCALE           0x020c
#define P3RD_MCLK_CONTROL               0x020d
#define P3RD_MCLK_PRE_SCALE             0x020e
#define P3RD_MCLK_FEEDBACK_SCALE        0x020f
#define P3RD_MCLK_POST_SCALE            0x0210
#define P3RD_CURSOR_PALETTE_START       0x0303      // 303..32f
#define P3RD_CURSOR_PATTERN_START       0x0400      // 400..7ff

// bit field definitions for the indexed registers
#define P3RD_MISC_CONTROL_OVERLAYS_ENABLED      0x10
#define P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED  0x08
#define P3RD_MISC_CONTROL_HIGHCOLORRES          0x01

#define P3RD_SYNC_CONTROL_VSYNC_ACTIVE_LOW  0x00
#define P3RD_SYNC_CONTROL_HSYNC_ACTIVE_LOW  0x00

#define P3RD_DAC_CONTROL_BLANK_PEDESTAL_ENABLED 0x80

#define P3RD_PIXEL_SIZE_8BPP            0x00
#define P3RD_PIXEL_SIZE_16BPP           0x01
#define P3RD_PIXEL_SIZE_24_BPP          0x04
#define P3RD_PIXEL_SIZE_32BPP           0x02

#define P3RD_COLOR_FORMAT_CI8           0x0e
#define P3RD_COLOR_FORMAT_8BPP          0x05
#define P3RD_COLOR_FORMAT_15BPP         0x01
#define P3RD_COLOR_FORMAT_16BPP         0x10
#define P3RD_COLOR_FORMAT_32BPP         0x00
#define P3RD_COLOR_FORMAT_LINEAR_EXT    0x40

#define P3RD_CURSOR_MODE_REVERSE        0x40
#define P3RD_CURSOR_MODE_WINDOWS        0x00
#define P3RD_CURSOR_MODE_X              0x10
#define P3RD_CURSOR_MODE_3COLOR         0x20
#define P3RD_CURSOR_MODE_15COLOR        0x30
#define P3RD_CURSOR_MODE_64x64          0x00
#define P3RD_CURSOR_MODE_P0_32x32x2     0x02
#define P3RD_CURSOR_MODE_P1_32x32x2     0x04
#define P3RD_CURSOR_MODE_P2_32x32x2     0x06
#define P3RD_CURSOR_MODE_P3_32x32x2     0x08
#define P3RD_CURSOR_MODE_P01_32x32x4    0x0a
#define P3RD_CURSOR_MODE_P23_32x32x4    0x0c
#define P3RD_CURSOR_MODE_ENABLED        0x01

#define P3RD_CURSOR_CONTROL_RPOS_ENABLED    0x04
#define P3RD_CURSOR_CONTROL_DOUBLE_Y        0x02
#define P3RD_CURSOR_CONTROL_DOUBLE_X        0x01

#define P3RD_DCLK_CONTROL_LOCKED    0x02    // read-only
#define P3RD_DCLK_CONTROL_ENABLED   0x01

#define P3RD_MCLK_CONTROL_LOCKED    0x02    // read-only
#define P3RD_MCLK_CONTROL_ENABLED   0x01

#define P3RD_CURSOR_PALETTE_CURSOR_RGB(RGBIndex, Red, Green, Blue) \
{ \
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_PALETTE_START+3*(int)RGBIndex+0, Red); \
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_PALETTE_START+3*(int)RGBIndex+1, Green); \
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_PALETTE_START+3*(int)RGBIndex+2, Blue); \
}

#define P3RD_SYNC_WITH_GLINT

//
// generic read/write routines for P3RD registers
//
#define WRITE_P3RDREG_ULONG(r, d) \
{ \
    WRITE_FAST_ULONG(r, d); \
    MEMORY_BARRIER(); \
}

#define READ_P3RDREG_ULONG(r)    READ_FAST_ULONG(r)


#if 0
// need a delay between each write to the P3RD. The only way to guarantee
// that the write has completed is to read from a GLINT control register.
// Reading forces any posted writes to be flushed out. PPC needs 2 reads
// to give us enough time.
#define P3RD_DELAY \
{ \
    volatile LONG __junk; \
    GLINT_GET_PACKING_MODE(__junk); \
    GLINT_GET_PACKING_MODE(__junk); \
}
#else
#define P3RD_DELAY
#endif

// macro to load a given data value into an internal P3RD register. The
// second macro loads an internal index register assuming that we have
// already zeroed the high address register.
//
#define P3RD_INDEX_REG(index) \
{ \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", P3RD_INDEX_ADDR_LO, (index) & 0xff)); \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_ADDR_LO, (ULONG)((index) & 0xff)); \
    P3RD_DELAY; \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", P3RD_INDEX_ADDR_HI, (index) >> 8)); \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_ADDR_HI, (ULONG)((index) >> 8)); \
    P3RD_DELAY; \
}

#define P3RD_LOAD_DATA(data) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
    P3RD_DELAY; \
}

#define P3RD_LOAD_INDEX_REG(index, data) \
{ \
    P3RD_INDEX_REG(index);                            \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", P3RD_INDEX_DATA, (data) & 0xff)); \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
    P3RD_DELAY; \
}

#define P3RD_READ_INDEX_REG(index, data) \
{ \
    P3RD_INDEX_REG(index);                            \
    data = READ_P3RDREG_ULONG(P3RD_INDEX_DATA) & 0xff;   \
    P3RD_DELAY; \
    VideoDebugPrint(("0x%x <-- *(0x%x)\n", data, P3RD_INDEX_DATA)); \
}

#define P3RD_LOAD_INDEX_REG_LO(index, data) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_ADDR_LO, (ULONG)(index));  \
    P3RD_DELAY; \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_DATA,    (ULONG)(data));   \
    P3RD_DELAY; \
}

// macros to load a given RGB triple into the P3RD palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use P3RD_PALETTE_START and multiple P3RD_LOAD_PALETTE calls to load
// a contiguous set of entries. Use P3RD_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//
#define P3RD_PALETTE_START_WR(index) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_PAL_WR_ADDR,     (ULONG)(index));    \
    P3RD_DELAY; \
}

#define P3RD_PALETTE_START_RD(index) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_PAL_RD_ADDR,     (ULONG)(index));    \
    P3RD_DELAY; \
}

#define P3RD_LOAD_PALETTE(red, green, blue) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_PAL_DATA,    (ULONG)(red));      \
    P3RD_DELAY; \
    WRITE_P3RDREG_ULONG(P3RD_PAL_DATA,    (ULONG)(green));    \
    P3RD_DELAY; \
    WRITE_P3RDREG_ULONG(P3RD_PAL_DATA,    (ULONG)(blue));     \
    P3RD_DELAY; \
}

#define P3RD_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_PAL_WR_ADDR, (ULONG)(index));    \
    P3RD_DELAY; \
    WRITE_P3RDREG_ULONG(P3RD_PAL_DATA,    (ULONG)(red));      \
    P3RD_DELAY; \
    WRITE_P3RDREG_ULONG(P3RD_PAL_DATA,    (ULONG)(green));    \
    P3RD_DELAY; \
    WRITE_P3RDREG_ULONG(P3RD_PAL_DATA,    (ULONG)(blue));     \
    P3RD_DELAY; \
}

// macro to read back a given RGB triple from the P3RD palette. Use after
// a call to P3RD_PALETTE_START_RD
//
#define P3RD_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR)(READ_P3RDREG_ULONG(P3RD_PAL_DATA) & 0xff);        \
    P3RD_DELAY; \
    green = (UCHAR)(READ_P3RDREG_ULONG(P3RD_PAL_DATA) & 0xff);        \
    P3RD_DELAY; \
    blue  = (UCHAR)(READ_P3RDREG_ULONG(P3RD_PAL_DATA) & 0xff);        \
    P3RD_DELAY; \
}

// macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//
#define P3RD_SET_PIXEL_READMASK(mask) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_PIXEL_MASK,  (ULONG)(mask)); \
    P3RD_DELAY; \
}

#define P3RD_READ_PIXEL_READMASK(mask) \
{ \
    mask = READ_P3RDREG_ULONG(P3RD_PIXEL_MASK) & 0xff; \
}

// Windows format byte-packed cursor data: each byte represents 4 consecutive pixels
#define P3RD_CURSOR_2_COLOR_BLACK           0x00
#define P3RD_CURSOR_2_COLOR_WHITE           0x55
#define P3RD_CURSOR_2_COLOR_TRANSPARENT     0xAA
#define P3RD_CURSOR_2_COLOR_HIGHLIGHT       0xFF
#define P3RD_CURSOR_3_COLOR_TRANSPARENT     0x00
#define P3RD_CURSOR_15_COLOR_TRANSPARENT    0x00

// macros to load values into the cursor array usage is P3RD_CURSOR_ARRAR_START() followed by 
// n iterations of P3RD_LOAD_CURSOR_ARRAY() or P3RD_READ_CURSOR_ARRAY()
//
#define P3RD_CURSOR_ARRAY_START(offset) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_ADDR_LO,   (ULONG)(((offset)+P3RD_CURSOR_PATTERN_START) & 0xff));  \
    P3RD_DELAY; \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_ADDR_HI,   (ULONG)(((offset)+P3RD_CURSOR_PATTERN_START) >> 8));    \
    P3RD_DELAY; \
}

#define P3RD_LOAD_CURSOR_ARRAY(data) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_DATA, (ULONG)(data)); \
    P3RD_DELAY; \
}

#define P3RD_READ_CURSOR_ARRAY(data) \
{ \
    data = READ_P3RDREG_ULONG(P3RD_INDEX_DATA) & 0xff; \
    P3RD_DELAY; \
}

// macro to move the cursor
//
#define P3RD_MOVE_CURSOR(x, y) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_ADDR_HI, (ULONG)0);              \
    P3RD_DELAY; \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_X_LOW,       (ULONG)((x) & 0xff));   \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_X_HIGH,      (ULONG)((x) >> 8));     \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_Y_LOW,       (ULONG)((y) & 0xff));   \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_Y_HIGH,      (ULONG)((y) >> 8));     \
}

// macro to change the cursor hotspot
//
#define P3RD_CURSOR_HOTSPOT(x, y) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_ADDR_HI,   (ULONG)(0)); \
    P3RD_DELAY; \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_HOTSPOT_X,  (ULONG)(x));    \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_HOTSPOT_Y,  (ULONG)(y));    \
}
    
// Cursor sizes
#define P3RD_CURSOR_SIZE_64_MONO    0
#define P3RD_CURSOR_SIZE_32_MONO    1
#define P3RD_CURSOR_SIZE_64_3COLOR  0 
#define P3RD_CURSOR_SIZE_32_3COLOR  1
#define P3RD_CURSOR_SIZE_32_15COLOR 5

#define P3RD_CURSOR_SEL(cursorSize, cursorIndex) \
    (((cursorSize + cursorIndex) & 7) << 1)

//
// Warning the P3 has an upside down cursor LUT, which means that
// items read from LUT entry 0 are actually read from entry 14.
// Therefore we have some macros to calculate the right value.
//
// Permedia4 behaves more naturally.
//
#define P3RD_CALCULATE_LUT_INDEX(x) \
    (glintInfo->deviceInfo.DeviceId == PERMEDIA4_ID ? (x) : (14-(x)))

// Exported functions from P3RD.c

PTRENABLE       vEnablePointerP3RD;
PTRDISABLE      vDisablePointerP3RD;
PTRSETSHAPE     bSetPointerShapeP3RD;
PTRMOVE         vMovePointerP3RD;
PTRSHOW         vShowPointerP3RD;
//@@BEGIN_DDKSPLIT
//DACSETUPOVERLAY vSetOverlayModeP3RD;
//PTRSETPIXMSK    vP3RDSetPixelMask;
//PTRSWPCSBUF     bP3RDSwapCSBuffers;
//PTRCHKCSBUF     bP3RDCheckCSBuffering;
//@@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\pxrx.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: pxrx.c
*
* Content: Permedia3 code.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"
#include "pxrx.h"


#if DBG
    ULONG   inPxRxContextSwitch = FALSE;
#endif


#define TEST_MINIMUM_FIFO_SPACE(min, str)        do { ; } while(0)

extern GAPFNstripFunc   gapfnStripPXRX[];

// table to determine which logicops use a source colour/pixel
const DWORD LogicOpReadSrc[] = {
    0,                                /* 00 */
    1,                                /* 01 */
    1,                                /* 02 */
    1,                                /* 03 */
    1,                                /* 04 */
    0,                                /* 05 */
    1,                                /* 06 */
    1,                                /* 07 */
    1,                                /* 08 */
    1,                                /* 09 */
    0,                                /* 10 */
    1,                                /* 11 */
    1,                                /* 12 */
    1,                                /* 13 */
    1,                                /* 14 */
    0,                                /* 15 */
};

const ULONG render2D_NativeBlt[16] = {
    /*  0:     0        clear        */ __RENDER2D_SPANS,
    /*  1:   S &  D     AND          */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /*  2:   S & ~D     AND reverse  */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /*  3:   S          COPY         */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /*  4:  ~S &  D     AND inverted */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /*  5:        D     no op        */ __RENDER2D_SPANS,
    /*  6:   S ^  D     XOR          */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /*  7:   S |  D     OR           */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /*  8: ~(S |  D)    NOR          */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /*  9: ~(S ^  D)    equiv        */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /* 10:       ~D     invert       */ __RENDER2D_SPANS,
    /* 11:   S | ~D     OR reverse   */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /* 12:  ~S          copy invert  */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /* 13:  ~S | D      OR invert    */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /* 14: ~(S & D)     NAND         */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /* 15:     1        set          */ __RENDER2D_SPANS,
};

const ULONG render2D_FillSolid[16] = {
    /*  0:     0        clear        */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /*  1:   S &  D     AND          */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /*  2:   S & ~D     AND reverse  */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /*  3:   S          COPY         */ __RENDER2D_INCX | __RENDER2D_INCY,
    /*  4:  ~S &  D     AND inverted */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /*  5:        D     no op        */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /*  6:   S ^  D     XOR          */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /*  7:   S |  D     OR           */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /*  8: ~(S |  D)    NOR          */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /*  9: ~(S ^  D)    equiv        */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /* 10:       ~D     invert       */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /* 11:   S | ~D     OR reverse   */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /* 12:  ~S          copy invert  */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /* 13:  ~S | D      OR invert    */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /* 14: ~(S & D)     NAND         */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /* 15:     1        set          */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
};

const ULONG config2D_FillColour[16] = {
    /*  0:     0        clear        */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 0),
    /*  1:   S &  D     AND          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 1) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  2:   S & ~D     AND reverse  */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 2) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  3:   S          COPY         */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS                                                     | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  4:  ~S &  D     AND inverted */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 4) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  5:        D     no op        */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 5) | __CONFIG2D_FBDESTREAD,
    /*  6:   S ^  D     XOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 6) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  7:   S |  D     OR           */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 7) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  8: ~(S |  D)    NOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 8) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  9: ~(S ^  D)    equiv        */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 9) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 10:       ~D     invert       */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(10) | __CONFIG2D_FBDESTREAD,
    /* 11:   S | ~D     OR reverse   */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(11) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 12:  ~S          copy invert  */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(12)                            | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 13:  ~S | D      OR invert    */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(13) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 14: ~(S & D)     NAND         */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(14) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 15:     1        set          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(15),
};

const ULONG config2D_FillColour32bpp[16] = {
    /*  0:     0        clear        */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 0),
    /*  1:   S &  D     AND          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 1) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  2:   S & ~D     AND reverse  */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 2) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  3:   S          COPY         */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_USERSCISSOR                            | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  4:  ~S &  D     AND inverted */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 4) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  5:        D     no op        */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 5) | __CONFIG2D_FBDESTREAD,
    /*  6:   S ^  D     XOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 6) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  7:   S |  D     OR           */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 7) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  8: ~(S |  D)    NOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 8) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  9: ~(S ^  D)    equiv        */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 9) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 10:       ~D     invert       */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(10) | __CONFIG2D_FBDESTREAD,
    /* 11:   S | ~D     OR reverse   */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(11) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 12:  ~S          copy invert  */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(12)                            | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 13:  ~S | D      OR invert    */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(13) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 14: ~(S & D)     NAND         */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(14) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 15:     1        set          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(15),
};

const ULONG config2D_FillColourDual[16] = {
    /*  0:     0        clear        */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 0),
    /*  1:   S &  D     AND          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 1) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  2:   S & ~D     AND reverse  */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 2) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  3:   S          COPY         */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 3)                            | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  4:  ~S &  D     AND inverted */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 4) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  5:        D     no op        */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 5) | __CONFIG2D_FBDESTREAD,
    /*  6:   S ^  D     XOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 6) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  7:   S |  D     OR           */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 7) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  8: ~(S |  D)    NOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 8) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  9: ~(S ^  D)    equiv        */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 9) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 10:       ~D     invert       */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(10) | __CONFIG2D_FBDESTREAD,
    /* 11:   S | ~D     OR reverse   */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(11) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 12:  ~S          copy invert  */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(12)                            | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 13:  ~S | D      OR invert    */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(13) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 14: ~(S & D)     NAND         */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(14) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 15:     1        set          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(15),
};

const ULONG config2D_FillSolid[16] = {
    /*  0:     0        clear        */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 0),
    /*  1:   S &  D     AND          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 1) | __CONFIG2D_FBDESTREAD,
    /*  2:   S & ~D     AND reverse  */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 2) | __CONFIG2D_FBDESTREAD,
    /*  3:   S          COPY         */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC,
    /*  4:  ~S &  D     AND inverted */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 4) | __CONFIG2D_FBDESTREAD,
    /*  5:        D     no op        */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 5) | __CONFIG2D_FBDESTREAD,
    /*  6:   S ^  D     XOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 6) | __CONFIG2D_FBDESTREAD,
    /*  7:   S |  D     OR           */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 7) | __CONFIG2D_FBDESTREAD,
    /*  8: ~(S |  D)    NOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 8) | __CONFIG2D_FBDESTREAD,
    /*  9: ~(S ^  D)    equiv        */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 9) | __CONFIG2D_FBDESTREAD,
    /* 10:       ~D     invert       */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(10) | __CONFIG2D_FBDESTREAD,
    /* 11:   S | ~D     OR reverse   */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(11) | __CONFIG2D_FBDESTREAD,
    /* 12:  ~S          copy invert  */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(12),
    /* 13:  ~S | D      OR invert    */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(13) | __CONFIG2D_FBDESTREAD,
    /* 14: ~(S & D)     NAND         */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(14) | __CONFIG2D_FBDESTREAD,
    /* 15:     1        set          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(15),
};

const ULONG config2D_FillSolidVariableSpans[16] = {
    /*  0:     0        clear        */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 0),
    /*  1:   S &  D     AND          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 1) | __CONFIG2D_FBDESTREAD,
    /*  2:   S & ~D     AND reverse  */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 2) | __CONFIG2D_FBDESTREAD,
    /*  3:   S          COPY         */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 3),
    /*  4:  ~S &  D     AND inverted */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 4) | __CONFIG2D_FBDESTREAD,
    /*  5:        D     no op        */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 5) | __CONFIG2D_FBDESTREAD,
    /*  6:   S ^  D     XOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 6) | __CONFIG2D_FBDESTREAD,
    /*  7:   S |  D     OR           */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 7) | __CONFIG2D_FBDESTREAD,
    /*  8: ~(S |  D)    NOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 8) | __CONFIG2D_FBDESTREAD,
    /*  9: ~(S ^  D)    equiv        */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 9) | __CONFIG2D_FBDESTREAD,
    /* 10:       ~D     invert       */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(10) | __CONFIG2D_FBDESTREAD,
    /* 11:   S | ~D     OR reverse   */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(11) | __CONFIG2D_FBDESTREAD,
    /* 12:  ~S          copy invert  */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(12),
    /* 13:  ~S | D      OR invert    */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(13) | __CONFIG2D_FBDESTREAD,
    /* 14: ~(S & D)     NAND         */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(14) | __CONFIG2D_FBDESTREAD,
    /* 15:     1        set          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(15),
};

const ULONG config2D_FillSolid32bpp[16] = {
    /*  0:     0        clear        */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 0),
    /*  1:   S &  D     AND          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 1) | __CONFIG2D_FBDESTREAD,
    /*  2:   S & ~D     AND reverse  */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 2) | __CONFIG2D_FBDESTREAD,
    /*  3:   S          COPY         */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_USERSCISSOR,
    /*  4:  ~S &  D     AND inverted */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 4) | __CONFIG2D_FBDESTREAD,
    /*  5:        D     no op        */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 5) | __CONFIG2D_FBDESTREAD,
    /*  6:   S ^  D     XOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 6) | __CONFIG2D_FBDESTREAD,
    /*  7:   S |  D     OR           */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 7) | __CONFIG2D_FBDESTREAD,
    /*  8: ~(S |  D)    NOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 8) | __CONFIG2D_FBDESTREAD,
    /*  9: ~(S ^  D)    equiv        */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 9) | __CONFIG2D_FBDESTREAD,
    /* 10:       ~D     invert       */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(10) | __CONFIG2D_FBDESTREAD,
    /* 11:   S | ~D     OR reverse   */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(11) | __CONFIG2D_FBDESTREAD,
    /* 12:  ~S          copy invert  */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(12),
    /* 13:  ~S | D      OR invert    */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(13) | __CONFIG2D_FBDESTREAD,
    /* 14: ~(S & D)     NAND         */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(14) | __CONFIG2D_FBDESTREAD,
    /* 15:     1        set          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(15),
};

const ULONG config2D_NativeBlt[16] = {
    /*  0:     0        clear        */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE( 0),
    /*  1:   S &  D     AND          */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE( 1) | __CONFIG2D_FBDESTREAD,
    /*  2:   S & ~D     AND reverse  */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE( 2) | __CONFIG2D_FBDESTREAD,
    /*  3:   S          COPY         */ __CONFIG2D_FBWRITE,
    /*  4:  ~S &  D     AND inverted */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE( 4) | __CONFIG2D_FBDESTREAD,
    /*  5:        D     no op        */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE( 5) | __CONFIG2D_FBDESTREAD,
    /*  6:   S ^  D     XOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE( 6) | __CONFIG2D_FBDESTREAD,
    /*  7:   S |  D     OR           */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE( 7) | __CONFIG2D_FBDESTREAD,
    /*  8: ~(S |  D)    NOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE( 8) | __CONFIG2D_FBDESTREAD,
    /*  9: ~(S ^  D)    equiv        */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE( 9) | __CONFIG2D_FBDESTREAD,
    /* 10:       ~D     invert       */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE(10) | __CONFIG2D_FBDESTREAD,
    /* 11:   S | ~D     OR reverse   */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE(11) | __CONFIG2D_FBDESTREAD,
    /* 12:  ~S          copy invert  */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE(12),
    /* 13:  ~S | D      OR invert    */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE(13) | __CONFIG2D_FBDESTREAD,
    /* 14: ~(S & D)     NAND         */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE(14) | __CONFIG2D_FBDESTREAD,
    /* 15:     1        set          */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE(15),
};

typedef struct Tag_Data_TAG {
    ULONG   tag;
    ULONG   data;
} Tag_Data;

Tag_Data DefaultContext_P3[] = {
    { __GlintTagFilterMode,                     0x00000000 },    // [0x180]
//    { __GlintTagAStart,                           0x00000000 },    // [0x0F9]
//    { __GlintTagBStart,                           0x00000000 },    // [0x0F6]
//    { __GlintTagFStart,                           0x00000000 },    // [0x0D4]
//    { __GlintTagGStart,                           0x00000000 },    // [0x0F3]

    { __GlintTagAlphaBlendAlphaMode,            __PERMEDIA_DISABLE },    // [0x5F5]
    { __GlintTagAlphaBlendColorMode,            __PERMEDIA_DISABLE },    // [0x5F4]
    { __GlintTagAlphaDestColor,                 0xFFFFFFFF },    // [0x5F1]
    { __GlintTagAlphaSourceColor,               0xFFFFFFFF },    // [0x5F0]
    { __GlintTagAlphaTestMode,                  __PERMEDIA_DISABLE },    // [0x100]
    { __GlintTagAntialiasMode,                  __PERMEDIA_DISABLE },    // [0x101]
    { __GlintTagAreaStippleMode,                __PERMEDIA_DISABLE },    // [0x034]

    { __GlintTagColor,                          0xFFFFFFFF },    // [0x0FE]
    { __GlintTagColorDDAMode,                   __PERMEDIA_DISABLE },    // [0x0FC]
    { __GlintTagConstantColor,                  0xFFFFFFFF },    // [0x0FD]

//    { __GlintTagBasePageOfWorkingSet,         0x00000000 },    // [0x699]
    { __GlintTagBitMaskPattern,                 0xFFFFFFFF },    // [0x00D]
//    { __GlintTagBorderColor0,                 0x00000000 },    // [0x095]
//    { __GlintTagBorderColor1,                 0x00000000 },    // [0x09F]

    { __GlintTagChromaFailColor,                0x00000000 },    // [0x5F3]
    { __GlintTagChromaPassColor,                0xFFFFFFFF },    // [0x5F2]
    { __GlintTagChromaTestMode,                 __PERMEDIA_DISABLE },    // [0x1E3]
    {  __PXRXTagChromaLower,                    0x00000000 },    // [0x1E2]
    {  __PXRXTagChromaUpper,                    0xFFFFFFFF },    // [0x1E1]

//    { __GlintTagD3DAlphaTestMode,             0x00000000 },    // [0x5F8]
    { __DeltaTagDeltaMode,                         (1 << 19) },    // [0x260]
//    { __DeltaTagDeltaControl,                    (1 << 11) },    // [0x26A]    // P3, R3 & P4 Only
//    { __GlintTagDeltaTexture01,                   0x00000000 },    // [0x28B]
//    { __GlintTagDeltaTexture11,                   0x00000000 },    // [0x28C]
//    { __GlintTagDeltaTexture21,                   0x00000000 },    // [0x28D]
//    { __GlintTagDeltaTexture31,                   0x00000000 },    // [0x28E]
    { __DeltaTagXBias,                          P3_LINES_BIAS_P },    // [0x290]
    { __DeltaTagYBias,                          P3_LINES_BIAS_P },    // [0x291]

    { __GlintTagDepth,                          0x00000000 },    // [0x135]
    { __GlintTagDepthMode,                      __PERMEDIA_DISABLE },    // [0x134]
    { __GlintTagDitherMode,                     __PERMEDIA_DISABLE },// ??? 0x00000403,    // [0x103]
//    { __GlintTagEndOfFeedback,                    0x00000000 },    // [0x1FF]

//    { __GlintTagFBBlockColor,                 0x00000000 },    // [0x159]
//    { __GlintTagFBBlockColor0,                    0x00000000 },    // [0x60C]
//    { __GlintTagFBBlockColor1,                    0x00000000 },    // [0x60D]
//    { __GlintTagFBBlockColor2,                    0x00000000 },    // [0x60E]
//    { __GlintTagFBBlockColor3,                    0x00000000 },    // [0x60F]
//    { __GlintTagFBBlockColorBack,             0x00000000 },    // [0x614]
//    { __GlintTagFBBlockColorBack0,                0x00000000 },    // [0x610]
//    { __GlintTagFBBlockColorBack1,                0x00000000 },    // [0x611]
//    { __GlintTagFBBlockColorBack2,                0x00000000 },    // [0x612]
//    { __GlintTagFBBlockColorBack3,                0x00000000 },    // [0x613]
//    { __GlintTagFBBlockColorBackExt,          0x00000000 },    // [0x61D]
//    { __GlintTagFBBlockColorBackL,                0x00000000 },    // [0x18C]
//    { __GlintTagFBBlockColorBackU,                0x00000000 },    // [0x18B]
//    { __GlintTagFBBlockColorExt,              0x00000000 },    // [0x61C]
//    { __GlintTagFBBlockColorL,                    0x00000000 },    // [0x18E]
//    { __GlintTagFBBlockColorU,                    0x00000000 },    // [0x18D]
//    { __GlintTagFBColor,                      0x00000000 },    // [0x153]
//    { __GlintTagFBData,                           0x00000000 },    // [0x154]

//    { __GlintTagFBDestReadEnables,                0x00000000 },    // [0x5DD]
    { __GlintTagFBSoftwareWriteMask,            0xFFFFFFFF },    // [0x104]
    { __GlintTagFBSourceData,                   0x00000000 },    // [0x155]
//    { __GlintTagFBWriteMaskExt,                   0x00000000 },    // [0x61E]

//    { __GlintTagFastBlockLimits,              0x00000000 },    // [0x026]
//    { __GlintTagFastClearDepth,                   0x00000000 },    // [0x13C]
//    { __GlintTagFeedbackX,                        0x00000000 },    // [0x1F1]
//    { __GlintTagFeedbackY,                        0x00000000 },    // [0x1F2]
//    { __GlintTagFlushSpan,                        0x00000000 },    // [0x00C]
    { __GlintTagFogColor,                       0xFFFFFFFF },    // [0x0D3]
    { __GlintTagFogMode,                        0x00000001 },    // [0x0D2]

    { __GlintTagGIDMode,                        __PERMEDIA_DISABLE },    // [0x6A7]
//    { __GlintTagGlyphData,                        0x00000000 },    // [0x6CC]
//    { __GlintTagGlyphPosition,                    0x00000000 },    // [0x6C1]
//    { __GlintTagHeadPhysicalPageAllocation0,  0x00000000 },    // [0x690]
//    { __GlintTagHeadPhysicalPageAllocation1,  0x00000000 },    // [0x691]
//    { __GlintTagHeadPhysicalPageAllocation2,  0x00000000 },    // [0x692]
//    { __GlintTagHeadPhysicalPageAllocation3,  0x00000000 },    // [0x693]
//    { __GlintTagInvalidateCache,              0x00000000 },    // [0x66B]
//    { __GlintTagKdBStart,                     0x00000000 },    // [0x1A6]
//    { __GlintTagKdGStart,                     0x00000000 },    // [0x1A3]
//    { __GlintTagKdRStart,                     0x00000000 },    // [0x1A0]
//    { __GlintTagKsBStart,                     0x00000000 },    // [0x196]
//    { __GlintTagKsGStart,                     0x00000000 },    // [0x193]
//    { __GlintTagKsRStart,                     0x00000000 },    // [0x190]

//    { __GlintTagLBCancelWrite,                    0x00000000 },    // [0x13D]        // Obsoleted !!! ??? !!!
//    { __GlintTagLBClearDataL,                 0x00000000 },    // [0x6AA]
//    { __GlintTagLBClearDataU,                 0x00000000 },    // [0x6AB]
//    { __GlintTagLBDepth,                      0x00000000 },    // [0x116]
//    { __GlintTagLBDestReadBufferAddr,         0x005FF000 },    // [0x6A2]        ???
//    { __GlintTagLBDestReadBufferOffset,           0x00000000 },    // [0x6A3]
//    { __GlintTagLBDestReadEnables,                0x00000000 },    // [0x6A1]
//    { __GlintTagLBReadFormat,                 0x0C4C0420 },    // [0x111]        ???
//    { __GlintTagLBReadMode,                       0x00000000 },    // [0x110]        // Obsoleted !!! ??? !!!
//    { __GlintTagLBSourceData,                 0x00000000 },    // [0x114]
//    { __GlintTagLBSourceOffset,                   0x00000000 },    // [0x112]
//    { __GlintTagLBSourceReadBufferAddr,           0x005FF000 },    // [0x6A5]        ???
//    { __GlintTagLBSourceReadBufferOffset,     0x00000000 },    // [0x6A6]
//    { __GlintTagLBStencil,                        0x00000000 },    // [0x115]
//    { __GlintTagLBWindowBase,                 0x00000000 },    // [0x117]
//    { __GlintTagLBWindowOffset,                   0x00000000 },    // [0x11F]
//    { __GlintTagLBWriteBufferAddr,                0x005FF000 },    // [0x6A8]        ???
//    { __GlintTagLBWriteBufferOffset,          0x00000000 },    // [0x6A9]
//    { __GlintTagLBWriteFormat,                    0x0C4C0420 },    // [0x119]        ???

//    { __GlintTagLUTIndex,                     0x00000000 },    // [0x098]
//    { __GlintTagLUTData,                      0x00000000 },    // [0x099]
//    { __GlintTagLUTAddress,                       0x00000000 },    // [0x09A]
//    { __GlintTagLUTTransfer,                  0x00000000 },    // [0x09B]
    { __GlintTagLineStippleMode,                __PERMEDIA_DISABLE },    // [0x035]
//    { __GlintTagLoadLineStippleCounters,      0x00000000 },    // [0x036]
//    { __GlintTagLOD,                          0x00000000 },    // [0x07A]
    { __GlintTagLOD1,                           0x00000000 },    // [0x089]
    { __GlintTagLodRange0,                      0x00C00000 },    // [0x669]
    { __GlintTagLodRange1,                      0x00C00000 },    // [0x66A]
    { __GlintTagLogicalOpMode,                  __PERMEDIA_DISABLE },    // [0x105]
//    { __GlintTagLogicalTexturePageTableAddr,  0x00000000 },    // [0x69A]
//    { __GlintTagLogicalTexturePageTableLength,    0x00000000 },    // [0x69B]
//    { __GlintTagMaxHitRegion,                 0x00000000 },    // [0x186]
//    { __GlintTagMaxRegion,                        0x00000000 },    // [0x183]
//    { __GlintTagMergeSpanData,                    0x00000000 },    // [0x5E7]
//    { __GlintTagMinHitRegion,                 0x00000000 },    // [0x185]
//    { __GlintTagMinRegion,                        0x00000000 },    // [0x182]
//    { __GlintTagPCIWindowBase0,                   0x00000000 },    // [0x5E8]
//    { __GlintTagPCIWindowBase1,                   0x00000000 },    // [0x5E9]
//    { __GlintTagPCIWindowBase2,                   0x00000000 },    // [0x5EA]
//    { __GlintTagPCIWindowBase3,                   0x00000000 },    // [0x5EB]
//    { __GlintTagPCIWindowBase4,                   0x00000000 },    // [0x5EC]
//    { __GlintTagPCIWindowBase5,                   0x00000000 },    // [0x5ED]
//    { __GlintTagPCIWindowBase6,                   0x00000000 },    // [0x5EE]
//    { __GlintTagPCIWindowBase7,                   0x00000000 },    // [0x5EF]
//    { __GlintTagPacked4Pixels,                    0x00000000 },    // [0x6CD]
//    { __GlintTagPhysicalPageAllocationTableAddr,0x00000000 },    // [0x698]
//    { __GlintTagPickResult,                       0x00000000 },    // [0x187]
//    { __GlintTagPointTable0,                  0x00000000 },    // [0x010]
//    { __GlintTagPointTable1,                  0x00000000 },    // [0x011]
//    { __GlintTagPointTable2,                  0x00000000 },    // [0x012]
//    { __GlintTagPointTable3,                  0x00000000 },    // [0x013]
//    { __GlintTagPrepareToRender,              0x00000000 },    // [0x021]
//    { __GlintTagProvokingVertex,              0x00000000 },    // [0x267]
//    { __GlintTagQ1Start,                      0x00000000 },    // [0x086]
//    { __GlintTagRLCount,                      0x00000000 },    // [0x6CF]
//    { __GlintTagRLData,                           0x00000000 },    // [0x6CE]
//    { __GlintTagRLEMask,                      0x00000000 },    // [0x189]
//    { __GlintTagRStart,                           0x00000000 },    // [0x0F0]
    { __GlintTagRasterizerMode,                                    // [0x014]
                                                (1 << 0) |         // mirror bitmasks
                                                (3 << 7) |        // byteswap bitmasks ABCD => DCBA
                                                (1 << 18) },    // YLimits enabled
//    { __GlintTagRectangleOrigin,              0x00000000 },    // [0x6C0]
    { __GlintTagRenderPatchOffset,              0x00000000 },    // [0x6C2]
//    { __GlintTagRepeatLine,                       0x00000000 },    // [0x265]
//    { __GlintTagRepeatTriangle,                   0x00000000 },    // [0x262]
//    { __GlintTagResetPickResult,              0x00000000 },    // [0x184]
    { __GlintTagRouterMode,                     0x00000000 },    // [0x108]
//    { __GlintTagS1Start,                      0x00000000 },    // [0x080]
//    { __GlintTagSaveLineStippleCounters,      0x00000000 },    // [0x038]
//    { __GlintTagScanlineOwnership,                0x00000000 },    // [0x016]
    { __GlintTagScissorMaxXY,                   0x7FFF7FFF },    // [0x032]
//    { __GlintTagScissorMinXY,                 0x00000000 },    // [0x031]
    { __GlintTagScissorMode,                    __PERMEDIA_DISABLE },    // [0x030]
//    { __GlintTagSetLogicalTexturePage,            0x00000000 },    // [0x66C]
    { __GlintTagSizeOfFramebuffer,              0x00080000 },    // [0x615]
//    { __GlintTagStartXDom,                        0x00000000 },    // [0x000]
//    { __GlintTagStartXSub,                        0x00000000 },    // [0x002]
//    { __GlintTagStartY,                           0x00000000 },    // [0x004]
    { __GlintTagStatisticMode,                  0x00000000 },    // [0x181]
//    { __GlintTagStencil,                      0x00000000 },    // [0x133]
    { __GlintTagStencilData,                    0x00FFFFFF },    // [0x132]
    { __GlintTagStencilMode,                    0x00040000 },    // [0x131]        ???
//    { __GlintTagSuspendUntilFrameBlank,           0x00000000 },    // [0x18F]
//    { __GlintTagSync,                         0x00000000 },    // [0x188]
//    { __GlintTagT1Start,                      0x00000000 },    // [0x083]
//    { __GlintTagTailPhysicalPageAllocation0,  0x00000000 },    // [0x694]
//    { __GlintTagTailPhysicalPageAllocation1,  0x00000000 },    // [0x695]
//    { __GlintTagTailPhysicalPageAllocation2,  0x00000000 },    // [0x696]
//    { __GlintTagTailPhysicalPageAllocation3,  0x00000000 },    // [0x697]
    {  __PXRXTagTextureApplicationMode,         __PERMEDIA_DISABLE },    // [0x0D0]
    { __GlintTagQStart,                         0x00000000 },    // [0x077]
    { __GlintTagSStart,                         0x00000000 },    // [0x071]
    { __GlintTagTStart,                         0x00000000 },    // [0x074]

//    { __GlintTagTextureCacheControl,          0x00000000 },    // [0x092]
//    { __GlintTagTextureChromaLower0,          0x00000000 },    // [0x09E]
//    { __GlintTagTextureChromaLower1,          0x00000000 },    // [0x0C1]
//    { __GlintTagTextureChromaUpper0,          0x00000000 },    // [0x09D]
//    { __GlintTagTextureChromaUpper1,          0x00000000 },    // [0x0C0]
    { __GlintTagTextureCompositeAlphaMode0,     0x00008000 },    // [0x662]    ???
    { __GlintTagTextureCompositeAlphaMode1,     0x00008000 },    // [0x664]    ???
    { __GlintTagTextureCompositeColorMode0,     __PERMEDIA_DISABLE },    // [0x661]
    { __GlintTagTextureCompositeColorMode1,     0x00008000 },    // [0x663]    ???
    { __GlintTagTextureCompositeFactor0,        0xFFFFFFFF },    // [0x665]    ???
    { __GlintTagTextureCompositeFactor1,        0xFFFFFFFF },    // [0x666]    ???
    { __GlintTagTextureCompositeMode,           0x00000000 },    // [0x660]
    {  __PXRXTagTextureCoordMode,               __PERMEDIA_ENABLE |    // [0x070]
                                                    (1 << 1) |        // SWrap repeat
                                                    (1 << 3) |        // TWrap repeat
                                                    (1 << 17) },    // texture map type == 2D
//    { __GlintTagTextureData,                  0x00000000 },    // [0x11D]
//    { __GlintTagTextureDownloadOffset,            0x00000000 },    // [0x11E]
    { __GlintTagTextureEnvColor,                0xFFFFFFFF },    // [0x0D1]
    { __GlintTagTextureFilterMode,              __PERMEDIA_DISABLE },    // [0x09C]
//    { __GlintTagTextureFormat,                    0x00000000 },    // [0x091]
    { __GlintTagTextureIndexMode0,              __PERMEDIA_ENABLE |    // [0x667]
                                                    (10 << 1) |        // texture map log2(width) == log2(1024)
                                                    (10 << 5) |        // texture map log2(height) == log2(1024)
                                                    (1 << 10) |        // UWrap repeat
                                                    (1 << 12) |        // VWrap repeat
                                                    (1 << 14) |        // texture map type == 2D
                                                    (1 << 21) },    // nearest neighbour bias = 0
    { __GlintTagTextureIndexMode1,              0x00200000 },    // [0x668]    ???
    { __GlintTagTextureLODBiasS,                0x00000000 },    // [0x08A]    ???
    { __GlintTagTextureLODBiasT,                0x00000000 },    // [0x08B]    ???
//    { __GlintTagTextureLODScale,              0x00000000 },    // [0x268]
//    { __GlintTagTextureLODScale1,             0x00000000 },    // [0x269]
//    { __GlintTagTextureMapWidth0,             0x00000000 },    // [0x683]
//    { __GlintTagTextureMapWidth1,             0x00000000 },    // [0x684]
//    { __GlintTagTextureReadMode,              0x00000000 },    // [0x090]
    { __GlintTagTextureReadMode0,               __PERMEDIA_ENABLE |    // [0x680]
                                                    (7 << 25) |        // byteswap: HGFEDCBA
                                                    (1 << 28) },    // mirror bitmap
    { __GlintTagTextureReadMode1,               0x00000400 },    // [0x681]    ???

//    { __GlintTagTouchLogicalPage,             0x00000000 },    // [0x66E]
//    { __GlintTagUpdateLineStippleCounters,        0x00000000 },    // [0x037]
//    { __GlintTagUpdateLogicalTextureInfo,     0x00000000 },    // [0x66D]
//    { __GlintTagV0FloatA,                     0x00000000 },    // [0x238]
//    { __GlintTagV0FloatB,                     0x00000000 },    // [0x237]
//    { __GlintTagV0FloatF,                     0x00000000 },    // [0x239]
//    { __GlintTagV0FloatG,                     0x00000000 },    // [0x236]
//    { __GlintTagV0FloatKdB,                       0x00000000 },    // [0x20F]
//    { __GlintTagV0FloatKdG,                       0x00000000 },    // [0x20E]
//    { __GlintTagV0FloatKdR,                       0x00000000 },    // [0x20D]
//    { __GlintTagV0FloatKsB,                       0x00000000 },    // [0x20C]
//    { __GlintTagV0FloatKsG,                       0x00000000 },    // [0x20B]
//    { __GlintTagV0FloatKsR,                       0x00000000 },    // [0x20A]
//    { __GlintTagV0FloatPackedColour,          0x00000000 },    // [0x23E]
//    { __GlintTagV0FloatPackedSpecularFog,     0x00000000 },    // [0x23F]
//    { __GlintTagV0FloatQ,                     0x00000000 },    // [0x232]
//    { __GlintTagV0FloatQ1,                        0x00000000 },    // [0x202]
//    { __GlintTagV0FloatR,                     0x00000000 },    // [0x235]
//    { __GlintTagV0FloatS,                     0x00000000 },    // [0x230]
//    { __GlintTagV0FloatS1,                        0x00000000 },    // [0x200]
//    { __GlintTagV0FloatT,                     0x00000000 },    // [0x231]
//    { __GlintTagV0FloatT1,                        0x00000000 },    // [0x201]
//    { __GlintTagV0FloatX,                     0x00000000 },    // [0x23A]
//    { __GlintTagV0FloatY,                     0x00000000 },    // [0x23B]
//    { __GlintTagV0FloatZ,                     0x00000000 },    // [0x23C]
//    { __GlintTagV0Reserved0,                  0x00000000 },    // [0x203]
//    { __GlintTagV0Reserved1,                  0x00000000 },    // [0x204]
//    { __GlintTagV0Reserved2,                  0x00000000 },    // [0x205]
//    { __GlintTagV0Reserved3,                  0x00000000 },    // [0x206]
//    { __GlintTagV0Reserved4,                  0x00000000 },    // [0x207]
//    { __GlintTagV0Reserved5,                  0x00000000 },    // [0x208]
//    { __GlintTagV0Reserved6,                  0x00000000 },    // [0x209]
//    { __GlintTagV0Reserved7,                  0x00000000 },    // [0x233]
//    { __GlintTagV0Reserved8,                  0x00000000 },    // [0x234]
//    { __GlintTagV1FloatA,                     0x00000000 },    // [0x248]
//    { __GlintTagV1FloatB,                     0x00000000 },    // [0x247]
//    { __GlintTagV1FloatF,                     0x00000000 },    // [0x249]
//    { __GlintTagV1FloatG,                     0x00000000 },    // [0x246]
//    { __GlintTagV1FloatKdB,                       0x00000000 },    // [0x21F]
//    { __GlintTagV1FloatKdG,                       0x00000000 },    // [0x21E]
//    { __GlintTagV1FloatKdR,                       0x00000000 },    // [0x21D]
//    { __GlintTagV1FloatKsB,                       0x00000000 },    // [0x21C]
//    { __GlintTagV1FloatKsG,                       0x00000000 },    // [0x21B]
//    { __GlintTagV1FloatKsR,                       0x00000000 },    // [0x21A]
//    { __GlintTagV1FloatPackedColour,          0x00000000 },    // [0x24E]
//    { __GlintTagV1FloatPackedSpecularFog,     0x00000000 },    // [0x24F]
//    { __GlintTagV1FloatQ,                     0x00000000 },    // [0x242]
//    { __GlintTagV1FloatQ1,                        0x00000000 },    // [0x212]
//    { __GlintTagV1FloatR,                     0x00000000 },    // [0x245]
//    { __GlintTagV1FloatS,                     0x00000000 },    // [0x240]
//    { __GlintTagV1FloatS1,                        0x00000000 },    // [0x210]
//    { __GlintTagV1FloatT,                     0x00000000 },    // [0x241]
//    { __GlintTagV1FloatT1,                        0x00000000 },    // [0x211]
//    { __GlintTagV1FloatX,                     0x00000000 },    // [0x24A]
//    { __GlintTagV1FloatY,                     0x00000000 },    // [0x24B]
//    { __GlintTagV1FloatZ,                     0x00000000 },    // [0x24C]
//    { __GlintTagV1Reserved0,                  0x00000000 },    // [0x213]
//    { __GlintTagV1Reserved1,                  0x00000000 },    // [0x214]
//    { __GlintTagV1Reserved2,                  0x00000000 },    // [0x215]
//    { __GlintTagV1Reserved3,                  0x00000000 },    // [0x216]
//    { __GlintTagV1Reserved4,                  0x00000000 },    // [0x217]
//    { __GlintTagV1Reserved5,                  0x00000000 },    // [0x218]
//    { __GlintTagV1Reserved6,                  0x00000000 },    // [0x219]
//    { __GlintTagV1Reserved7,                  0x00000000 },    // [0x243]
//    { __GlintTagV1Reserved8,                  0x00000000 },    // [0x244]
//    { __GlintTagV2FloatA,                     0x00000000 },    // [0x258]
//    { __GlintTagV2FloatB,                     0x00000000 },    // [0x257]
//    { __GlintTagV2FloatF,                     0x00000000 },    // [0x259]
//    { __GlintTagV2FloatG,                     0x00000000 },    // [0x256]
//    { __GlintTagV2FloatKdB,                       0x00000000 },    // [0x22F]
//    { __GlintTagV2FloatKdG,                       0x00000000 },    // [0x22E]
//    { __GlintTagV2FloatKdR,                       0x00000000 },    // [0x22D]
//    { __GlintTagV2FloatKsB,                       0x00000000 },    // [0x22C]
//    { __GlintTagV2FloatKsG,                       0x00000000 },    // [0x22B]
//    { __GlintTagV2FloatKsR,                       0x00000000 },    // [0x22A]
//    { __GlintTagV2FloatPackedColour,          0x00000000 },    // [0x25E]
//    { __GlintTagV2FloatPackedSpecularFog,     0x00000000 },    // [0x25F]
//    { __GlintTagV2FloatQ,                     0x00000000 },    // [0x252]
//    { __GlintTagV2FloatQ1,                        0x00000000 },    // [0x222]
//    { __GlintTagV2FloatR,                     0x00000000 },    // [0x255]
//    { __GlintTagV2FloatS,                     0x00000000 },    // [0x250]
//    { __GlintTagV2FloatS1,                        0x00000000 },    // [0x220]
//    { __GlintTagV2FloatT,                     0x00000000 },    // [0x251]
//    { __GlintTagV2FloatT1,                        0x00000000 },    // [0x221]
//    { __GlintTagV2FloatX,                     0x00000000 },    // [0x25A]
//    { __GlintTagV2FloatY,                     0x00000000 },    // [0x25B]
//    { __GlintTagV2FloatZ,                     0x00000000 },    // [0x25C]
//    { __GlintTagV2Reserved0,                  0x00000000 },    // [0x223]
//    { __GlintTagV2Reserved1,                  0x00000000 },    // [0x224]
//    { __GlintTagV2Reserved2,                  0x00000000 },    // [0x225]
//    { __GlintTagV2Reserved3,                  0x00000000 },    // [0x226]
//    { __GlintTagV2Reserved4,                  0x00000000 },    // [0x227]
//    { __GlintTagV2Reserved5,                  0x00000000 },    // [0x228]
//    { __GlintTagV2Reserved6,                  0x00000000 },    // [0x229]
//    { __GlintTagV2Reserved7,                  0x00000000 },    // [0x253]
//    { __GlintTagV2Reserved8,                  0x00000000 },    // [0x254]
//    { __GlintTagVTGAddress,                       0x00000000 },    // [0x616]
//    { __GlintTagVTGData,                      0x00000000 },    // [0x617]
//    { __GlintTagWaitForCompletion,                0x00000000 },    // [0x017]

    { __GlintTagWindow,                         0x00000000 },    // [0x130]
    { __GlintTagWindowOrigin,                   0x00000000 },    // [0x039]
//    { __GlintTagXBias,                            0x00000000 },    // [0x290]
//    { __GlintTagYBias,                            0x00000000 },    // [0x291]
    { __GlintTagYLimits,                        0x7FFF0000 },    // [0x015]    // Allow y values from 0 to 32767
    {  __PXRXTagYUVMode,                        __PERMEDIA_DISABLE },    // [0x1E0]

//    { __GlintTagZFogBias,                     0x00000000 },    // [0x0D7]
//    { __GlintTagZStartL,                      0x00000000 },    // [0x137]
//    { __GlintTagZStartU,                      0x00000000 },    // [0x136]
//    { __GlintTagdAdx,                         0x00000000 },    // [0x0FA]
//    { __GlintTagdAdyDom,                      0x00000000 },    // [0x0FB]
//    { __GlintTagdBdx,                         0x00000000 },    // [0x0F7]
//    { __GlintTagdBdyDom,                      0x00000000 },    // [0x0F8]
//    { __GlintTagdFdx,                         0x00000000 },    // [0x0D5]
//    { __GlintTagdFdyDom,                      0x00000000 },    // [0x0D6]
//    { __GlintTagdGdx,                         0x00000000 },    // [0x0F4]
//    { __GlintTagdGdyDom,                      0x00000000 },    // [0x0F5]
//    { __GlintTagdKdBdx,                           0x00000000 },    // [0x1A7]
//    { __GlintTagdKdBdyDom,                        0x00000000 },    // [0x1A8]
//    { __GlintTagdKdGdx,                           0x00000000 },    // [0x1A4]
//    { __GlintTagdKdGdyDom,                        0x00000000 },    // [0x1A5]
//    { __GlintTagdKdRdx,                           0x00000000 },    // [0x1A1]
//    { __GlintTagdKdRdyDom,                        0x00000000 },    // [0x1A2]
//    { __GlintTagdKsBdx,                           0x00000000 },    // [0x197]
//    { __GlintTagdKsBdyDom,                        0x00000000 },    // [0x198]
//    { __GlintTagdKsGdx,                           0x00000000 },    // [0x194]
//    { __GlintTagdKsGdyDom,                        0x00000000 },    // [0x195]
//    { __GlintTagdKsRdx,                           0x00000000 },    // [0x191]
//    { __GlintTagdKsRdyDom,                        0x00000000 },    // [0x192]
//    { __GlintTagdQ1dx,                            0x00000000 },    // [0x087]
//    { __GlintTagdQ1dyDom,                     0x00000000 },    // [0x088]
    { __GlintTagdQdx,                           0x00000000 },    // [0x078]
    { __GlintTagdQdy,                           0x00000000 },    // [0x07D]
    { __GlintTagdQdyDom,                        0x00000000 },    // [0x079]
//    { __GlintTagdRdx,                         0x00000000 },    // [0x0F1]
//    { __GlintTagdRdyDom,                      0x00000000 },    // [0x0F2]
//    { __GlintTagdS1dx,                            0x00000000 },    // [0x081]
//    { __GlintTagdS1dyDom,                     0x00000000 },    // [0x082]
    { __GlintTagdSdx,                           1 << (32 - 10) },    // [0x072]
    { __GlintTagdSdy,                           0x00000000 },    // [0x07B]
    { __GlintTagdSdyDom,                        0x00000000 },    // [0x073]
//    { __GlintTagdT1dx,                            0x00000000 },    // [0x084]
//    { __GlintTagdT1dyDom,                     0x00000000 },    // [0x085]
    { __GlintTagdTdx,                           0x00000000 },    // [0x075]
    { __GlintTagdTdy,                           0x00000000 },    // [0x07C]
    { __GlintTagdTdyDom,                        1 << (32 - 10) },    // [0x076]

    { __GlintTagdXDom,                          0          },    // [0x001]
    { __GlintTagdXSub,                          0          },    // [0x003]
    { __GlintTagdY,                             INTtoFIXED(1) },    // [0x005]
//    { __GlintTagdZdxL,                            0x00000000 },    // [0x139]
//    { __GlintTagdZdxU,                            0x00000000 },    // [0x138]
//    { __GlintTagdZdyDomL,                     0x00000000 },    // [0x13B]
//    { __GlintTagdZdyDomU,                     0x00000000 },    // [0x13A]
    { __GlintTagLBDestReadMode,                 0x00000000 },  // [0x6A0]
    { __GlintTagLBSourceReadMode,               0x00000000 },  // [0x6A4]
    { __GlintTagLBWriteMode,                    0x00000000 },  // [0x118]
};

DWORD   NUM_P3_CTXT_TAGS = (sizeof(DefaultContext_P3) / sizeof(DefaultContext_P3[0]));

void pxrxSetupDualWrites_Patching( PPDEV ppdev ) {
    ULONG   bypass = 0;
    GLINT_DECL;

    DISPDBG((7, "pxrxSetupDualWrites_Patching entered"));

    __RENDER2D_OP_PATCHORDER = 0;

    glintInfo->fbWriteModeSingleWrite = 1;
    glintInfo->fbWriteModeDualWrite = 1 | (1 << 4) | (1 << 12) | (1 << 13);
    glintInfo->fbWriteModeSingleWriteStereo = 1 | (1 << 4) | (1 << 12) | (1 << 15);
    glintInfo->fbWriteModeDualWriteStereo = 1 | (1 << 4) | (1 << 12) | (1 << 13) | (1 << 14) | (1 << 15);

    if( glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_FRONT ) {
        DISPDBG((7, "pxrxSetupDualWrites_Patching: Enabling front buffer patching"));

        __RENDER2D_OP_PATCHORDER = __RENDER2D_OP_PATCHORDER_PATCHED;
        glintInfo->fbWriteModeSingleWrite |= (1 << 16) | (1 << 18) | (1 << 20) | (1 << 22);
        glintInfo->fbWriteModeDualWrite |= (1 << 16);
        glintInfo->fbWriteModeSingleWriteStereo |= (1 << 16) | (1 << 18) | (1 << 20) | (1 << 22);
        glintInfo->fbWriteModeDualWriteStereo |= (1 << 16) | (1 << 20);
    }

    bypass |= ppdev->cPelSize << 5;
    if( ppdev->cxMemory <= 1024 )
        bypass |= (0 << 7);
    else if( ppdev->cxMemory <= 2048 )
        bypass |= (1 << 7);
    else if( ppdev->cxMemory <= 4096 )
        bypass |= (2 << 7);
    else if( ppdev->cxMemory <= 8192 )
        bypass |= (3 << 7);

    if( glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_BACK ) {
        DISPDBG((7, "pxrxSetupDualWrites_Patching: Enabling back buffer patching"));

        __RENDER2D_OP_PATCHORDER = __RENDER2D_OP_PATCHORDER_PATCHED;
        glintInfo->fbWriteModeDualWrite |= (1 << 18);
        glintInfo->fbWriteModeDualWriteStereo |= (1 << 18) | (1 << 22);
    }

    if( glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_FRONT ) {
        if( glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_BACK ) {
            // Patched front and back:
            bypass |= (1 << 2);

            // We need to do very odd things with a non power of 2 stride :-(.
//          if( ppdev->cxMemory > 8192 )
            if( ppdev->cxMemory != 1024 )
                glintInfo->GdiCantAccessFramebuffer = TRUE; // bypass 'effective stride' is too big
        } else {
            // Patched front only:
            glintInfo->GdiCantAccessFramebuffer = TRUE;
        }
    } else {
        if( glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_BACK ) {
            // Patched back only:
            glintInfo->GdiCantAccessFramebuffer = TRUE;
        } else {
            // Linear front and back:
        }
    }

    if( glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE ) {
        DISPDBG((7, "pxrxSetupDualWrites_Patching: Enabling dual writes"));

        if( glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE )
            glintInfo->fbWriteMode = glintInfo->fbWriteModeDualWriteStereo;
        else
            glintInfo->fbWriteMode = glintInfo->fbWriteModeDualWrite;

        glintInfo->pxrxFlags |= PXRX_FLAGS_DUAL_WRITING;

        glintInfo->fbWriteOffset[1] = glintInfo->backBufferXY;
        glintInfo->fbWriteOffset[2] = glintInfo->backRightBufferXY;

    } else {
        DISPDBG((7, "pxrxSetupDualWrites_Patching: Disabling dual writes"));

        if( glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE )
            glintInfo->fbWriteMode = glintInfo->fbWriteModeSingleWriteStereo;
        else
            glintInfo->fbWriteMode = glintInfo->fbWriteModeSingleWrite;

        glintInfo->pxrxFlags &= ~PXRX_FLAGS_DUAL_WRITING;

        glintInfo->fbWriteOffset[1] = 0x00000000;
        glintInfo->fbWriteOffset[2] = 0x00000000;
    }

    if( glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE ) {
        DISPDBG((7, "pxrxSetupDualWrites_Patching: Enabling stereo writes"));

        glintInfo->pxrxFlags |= PXRX_FLAGS_STEREO_WRITING;
    
        glintInfo->fbWriteOffset[3] = glintInfo->frontRightBufferXY;
    }
    else {
        DISPDBG((7, "pxrxSetupDualWrites_Patching: Disabling stereo writes"));

        glintInfo->pxrxFlags &= ~PXRX_FLAGS_STEREO_WRITING;
    
        glintInfo->fbWriteOffset[3] = 0x00000000;
    }

    if( (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE) ||
        (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE) ) {
        // Unfortunately, the bypass requires the back buffer to be aligned on a
        // (power of 2) * 1MB boundary. So for the time being, just pretend we
        // can't actually dual write through it.

        // Also, we can't set the bypass up to read from the back buffer. So when
        // OGL has page flipped so that the back buffer is now the current buffer
        // any logic-ops will get source data from the wrong location :-(.

        glintInfo->GdiCantAccessFramebuffer = TRUE;
        /*{
            ULONG   size = (ppdev->cxMemory * (glintInfo->backBufferXY >> 16)) + (glintInfo->backBufferXY & 0xFFFF);
            int     i;

            size <<= ppdev->cPelSize;
            size >>= 20;
            for( i = 0; i <= 7; i++ )
                if( size & (1 << i) )
                    break;

            if( i < 0 )
                glintInfo->GdiCantAccessFramebuffer = TRUE;
            else
                bypass |= (i << 7);
        }*/
    }

//@@BEGIN_DDKSPLIT
//  if( GLINT_P3R3 ) {
//@@END_DDKSPLIT
        switch( ppdev->cPelSize ) {
            case GLINTDEPTH32:
                if( (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_FRONT) ||
                    (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_BACK) ) {
                    ppdev->pgfnFillSolid    = p3r3FillSolidVariableSpans;
                    ppdev->pgfnFillPatColor = p3r3FillPatColorVariableSpans;
                    ppdev->pgfnFillPatMono  = p3r3FillPatMonoVariableSpans;
                } else {
                    ppdev->pgfnFillSolid    = p3r3FillSolid32bpp;
                    ppdev->pgfnFillPatColor = p3r3FillPatColor32bpp;
                    ppdev->pgfnFillPatMono  = p3r3FillPatMono32bpp;
                }
            break;

            case GLINTDEPTH8:
                if( (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_FRONT) ||
                    (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_BACK) ) {
                    ppdev->pgfnFillPatMono  = p3r3FillPatMonoVariableSpans;
                } else {
                    ppdev->pgfnFillPatMono  = pxrxFillPatMono;
                }
            break;
        }
//@@BEGIN_DDKSPLIT
//  }
//@@END_DDKSPLIT

    if( (glintInfo->pxrxFlags & (PXRX_FLAGS_PATCHING_FRONT | PXRX_FLAGS_PATCHING_BACK)) ||
        (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE) ||
        (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE) ||
        glintInfo->GdiCantAccessFramebuffer ||
        ((ppdev->cPelSize != GLINTDEPTH16) && (ppdev->cPelSize != GLINTDEPTH32)) ) 
    {
        ppdev->pgfnCopyXfer8bppLge  = pxrxCopyXfer8bppLge;
        ppdev->pgfnCopyXfer8bpp     = pxrxCopyXfer8bppLge;
    } else {
        ppdev->pgfnCopyXfer8bppLge  = pxrxCopyXfer8bppLge;
        ppdev->pgfnCopyXfer8bpp     = vGlintCopyBltBypassDownloadXlate8bpp;
    }

    WRITE_GLINT_CTRL_REG( PXRXByAperture2Stride,    ppdev->cxMemory );
    WRITE_GLINT_CTRL_REG( PXRXByAperture2Mode,      bypass );

    glintInfo->pxrxByDMAReadMode = bypass;

    if(ppdev->flCaps & CAPS_USE_AGP_DMA)
        glintInfo->pxrxByDMAReadMode |= PXRX_BYPASS_READ_DMA_AGP_BIT;

    WRITE_GLINT_CTRL_REG( PXRXByDMAReadMode,        glintInfo->pxrxByDMAReadMode );
    WRITE_GLINT_CTRL_REG( PXRXByDMAReadStride,      ppdev->cxMemory );

    DISPDBG((7, "pxrxSetupDualWrites_Patching exited"));
}

void pxrxRestore2DContext( PPDEV ppdev, BOOL switchingIn ) {
    ULONG   i, f, b;
    ULONG   enableFlags;
    GLINT_DECL;

#if DBG
    inPxRxContextSwitch = TRUE;
#endif

    DISPDBG((7, "pxrxRestore2DContext entered"));

    if( switchingIn ) {
        // Switching in to 2D...
        gi_pxrxDMA.NTbuff   = 0;
        gi_pxrxDMA.NTptr    = gi_pxrxDMA.DMAaddrL[gi_pxrxDMA.NTbuff];
        gi_pxrxDMA.P3at     = gi_pxrxDMA.NTptr;
        gi_pxrxDMA.NTdone   = gi_pxrxDMA.NTptr;
#if PXRX_DMA_BUFFER_CHECK
        glintInfo->NTwait   = gi_pxrxDMA.NTptr;
#endif

        CHECK_PXRX_DMA_VALIDITY( CHECK_SWITCH, 0 );

        pxrxSetupDualWrites_Patching( ppdev );

        DISPDBG((8, "pxrxRestore2DContext: restoring core registers"));

        WAIT_PXRX_DMA_TAGS( NUM_P3_CTXT_TAGS );

        for( i = 0; i < NUM_P3_CTXT_TAGS; i++ )
            QUEUE_PXRX_DMA_TAG( DefaultContext_P3[i].tag, DefaultContext_P3[i].data );

        if( glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE ) {
            f = (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_FRONT) ? 1 : 0;
            b = (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_BACK ) ? 1 : 0;
        } else
            f = b = (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_FRONT) ? 1 : 0;

        WAIT_PXRX_DMA_TAGS( 40 );


        QUEUE_PXRX_DMA_TAG( __DeltaTagDeltaControl,                (1 << 11) );

        QUEUE_PXRX_DMA_TAG( __GlintTagPixelSize,                    2 - ppdev->cPelSize );            // [0x018]

        QUEUE_PXRX_DMA_TAG( __GlintTagForegroundColor,              glintInfo->foregroundColour );    // [0x618]
        QUEUE_PXRX_DMA_TAG( __GlintTagBackgroundColor,              glintInfo->backgroundColour );    // [0x619]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferAddr0,        glintInfo->fbDestAddr[0] );        // [0x5D0]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferAddr1,        glintInfo->fbDestAddr[1] );        // [0x5D1]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferAddr2,        glintInfo->fbDestAddr[2] );        // [0x5D2]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferAddr3,        glintInfo->fbDestAddr[3] );        // [0x5D3]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferOffset0,      glintInfo->fbDestOffset[0] );    // [0x5D4]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferOffset1,      glintInfo->fbDestOffset[1] );    // [0x5D5]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferOffset2,      glintInfo->fbDestOffset[2] );    // [0x5D6]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferOffset3,      glintInfo->fbDestOffset[3] );    // [0x5D7]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferWidth0,       glintInfo->fbDestWidth[0] );    // [0x5D8]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferWidth1,       glintInfo->fbDestWidth[1] );    // [0x5D9]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferWidth2,       glintInfo->fbDestWidth[2] );    // [0x5DA]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferWidth3,       glintInfo->fbDestWidth[3] );    // [0x5DB]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBSourceReadBufferAddr,       glintInfo->fbSourceAddr );        // [0x5E1]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBSourceReadBufferOffset,     glintInfo->fbSourceOffset );    // [0x5E2]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBSourceReadBufferWidth,      glintInfo->fbSourceWidth );        // [0x5E3]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferAddr0,           glintInfo->fbWriteAddr[0] );    // [0x600]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferAddr1,           glintInfo->fbWriteAddr[1] );    // [0x601]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferAddr2,           glintInfo->fbWriteAddr[2] );    // [0x602]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferAddr3,           glintInfo->fbWriteAddr[3] );    // [0x603]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferOffset0,         glintInfo->fbWriteOffset[0] );    // [0x604]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferOffset1,         glintInfo->fbWriteOffset[1] );    // [0x605]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferOffset2,         glintInfo->fbWriteOffset[2] );    // [0x606]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferOffset3,         glintInfo->fbWriteOffset[3] );    // [0x607]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferWidth0,          glintInfo->fbWriteWidth[0] );    // [0x608]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferWidth1,          glintInfo->fbWriteWidth[1] );    // [0x609]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferWidth2,          glintInfo->fbWriteWidth[2] );    // [0x60A]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferWidth3,          glintInfo->fbWriteWidth[3] );    // [0x60B]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteMode,                  glintInfo->fbWriteMode );        // [0x157]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBHardwareWriteMask,          glintInfo->DefaultWriteMask );    // [0x158]
        glintInfo->WriteMask = glintInfo->DefaultWriteMask;

        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadMode,               glintInfo->fbDestMode);            // [0x5DC]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBSourceReadMode,                (1 << 0) | (1 << 1) | (f << 8) );    // [0x5E0]

        QUEUE_PXRX_DMA_TAG( __GlintTagScreenSize,                   MAKEDWORD_XY(ppdev->cxScreen, ppdev->cyScreen) );    // [0x033]

        QUEUE_PXRX_DMA_TAG( __GlintTagLUTMode,                      glintInfo->lutMode );            // [0x66F]
        QUEUE_PXRX_DMA_TAG( __GlintTagConfig2D,                     glintInfo->config2D );            // [0x6C3]

        SEND_PXRX_DMA_FORCE;

        //wait for host in id to come out.
        SYNC_WITH_GLINT;

        // Invalidate some caches:
        ppdev->PalLUTType = LUTCACHE_INVALID;
        RtlZeroMemory( &ppdev->abeMono, sizeof(ppdev->abeMono) );

        DISPDBG((7, "pxrxRestore2DContext: restoring control registers"));

        if( (ppdev->sendPXRXdmaBatch != ppdev->sendPXRXdmaForce) && INTERRUPTS_ENABLED ) {
            gi_pxrxDMA.scheme = glintInfo->usePXRXdma;
            glintInfo->pInterruptCommandBlock->Control |= PXRX_SEND_ON_VBLANK_ENABLED;
            READ_GLINT_CTRL_REG ( IntEnable, enableFlags );
            WRITE_GLINT_CTRL_REG( IntEnable, enableFlags | INTR_ENABLE_VBLANK );
        } else
            gi_pxrxDMA.scheme = USE_PXRX_DMA_NONE;

    } else {
        // Switching out of 2D...
        if( INTERRUPTS_ENABLED )
            glintInfo->pInterruptCommandBlock->Control &= ~PXRX_SEND_ON_VBLANK_ENABLED;
    }

#if DBG
    inPxRxContextSwitch = FALSE;
#endif

    DISPDBG((7, "pxrxRestore2DContext exited"));
}

VOID pxrxSetupFunctionPointers( PPDEV ppdev )
{
    ULONG   ul;
    GLINT_DECL;

    switch( glintInfo->usePXRXdma ) {
        case USE_PXRX_DMA_FIFO:
            ppdev->sendPXRXdmaForce             = sendPXRXdmaFIFO;
            ppdev->sendPXRXdmaQuery             = sendPXRXdmaFIFO;
            ppdev->sendPXRXdmaBatch             = sendPXRXdmaFIFO;
            ppdev->switchPXRXdmaBuffer          = switchPXRXdmaBufferFIFO;
            ppdev->waitPXRXdmaCompletedBuffer   = waitPXRXdmaCompletedBufferFIFO;
        break;

        default:
            DISPDBG((ERRLVL,"Unknown PXRX dma scheme!"));
    }

    if( !INTERRUPTS_ENABLED )
        ppdev->sendPXRXdmaBatch = ppdev->sendPXRXdmaQuery = ppdev->sendPXRXdmaForce;

    ppdev->pgfnCopyBltCopyROP   = pxrxCopyBltNative;
    ppdev->pgfnCopyBltNative    = pxrxCopyBltNative;
    ppdev->pgfnCopyBlt          = pxrxCopyBltNative;
    ppdev->pgfnFillSolid        = pxrxFillSolid;
    ppdev->pgfnFillPatMono      = pxrxFillPatMono;
    ppdev->pgfnFillPatColor     = pxrxFillPatColor;
    ppdev->pgfnXfer1bpp         = pxrxXfer1bpp;
    ppdev->pgfnXfer4bpp         = pxrxXfer4bpp;
    ppdev->pgfnXfer8bpp         = pxrxXfer8bpp;
//  ppdev->pgfnXfer16bpp        = pxrxXfer16bpp;
//  ppdev->pgfnXfer24bpp        = pxrxXfer24bpp;
    ppdev->pgfnXferImage        = pxrxXferImage;
    ppdev->pgfnMaskCopyBlt      = pxrxMaskCopyBlt;
    ppdev->pgfnPatRealize       = pxrxPatRealize;
    ppdev->pgfnMonoOffset       = pxrxMonoOffset;
    ppdev->pgfnFillPolygon      = bGlintFastFillPolygon;
    ppdev->pgfnDrawLine         = pxrxDrawLine;
    ppdev->pgfnIntegerLine      = pxrxIntegerLine;
    ppdev->pgfnContinueLine     = pxrxContinueLine;
    ppdev->pgfnInitStrips       = pxrxInitStrips;
    ppdev->pgfnResetStrips      = pxrxResetStrips;
    ppdev->pgfnRepNibbles       = pxrxRepNibbles;

    ppdev->pgfnUpload = pxrxFifoUpload; 

    // add any depth-specific function overrides here
    switch( ppdev->cPelSize ) 
    {
        case GLINTDEPTH32:
            ppdev->pgfnFillSolid    = p3r3FillSolid32bpp;
            ppdev->pgfnFillPatColor = p3r3FillPatColor32bpp;
            ppdev->pgfnFillPatMono  = p3r3FillPatMono32bpp;
        break;

        case GLINTDEPTH16:
            // this specialization seems to give the same 
            // performance as the generic color pattern fill
            //ppdev->pgfnFillPatColor   = p3r3FillPatColor16bpp;
        break;

        case GLINTDEPTH8:
            ppdev->pgfnFillSolid    = p3r3FillSolidVariableSpans;
            ppdev->pgfnFillPatColor = p3r3FillPatColorVariableSpans;
        break;
    }

    ppdev->pgfnCopyXferImage    = NULL; 
    ppdev->pgfnCopyXfer24bpp    = pxrxCopyXfer24bpp;
    ppdev->pgfnCopyXfer4bpp     = NULL;
    if( (glintInfo->pxrxFlags & (PXRX_FLAGS_PATCHING_FRONT | PXRX_FLAGS_PATCHING_BACK)) ||
        (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE) ||
        (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE) ||
        glintInfo->GdiCantAccessFramebuffer ||
        ((ppdev->cPelSize != GLINTDEPTH16) && (ppdev->cPelSize != 
        GLINTDEPTH32)) )
    {
        ppdev->pgfnCopyXfer8bppLge  = pxrxCopyXfer8bppLge;
        ppdev->pgfnCopyXfer8bpp     = pxrxCopyXfer8bppLge;
    } else {
        ppdev->pgfnCopyXfer8bppLge  = pxrxCopyXfer8bppLge;
        ppdev->pgfnCopyXfer8bpp     = vGlintCopyBltBypassDownloadXlate8bpp;
    }

    ppdev->gapfnStrip = &gapfnStripPXRX[0];
}

VOID pxrxCopyBltNative( PPDEV ppdev, RECTL *pRect, LONG count, DWORD logicOp, POINTL *pptlSrc, RECTL *pRectDst )
{
    ULONG   config2D, render2D;
    int     dx, dy;
    GLINT_DECL;

    DISPDBG((7, "pxrxCopyBltNative: (%d, %d) => (%d,%d -> %d,%d) x %d, logicOp = %d, offset = (%d, %d)",
                 pptlSrc->x, pptlSrc->y, pRectDst->left, pRectDst->top, pRectDst->right, pRectDst->bottom,
                 count, logicOp, ppdev->xyOffsetDst & 0xffff, ppdev->xyOffsetDst >> 16));

    ASSERTDD(count > 0, "Can't handle zero rectangles");
    ASSERTDD(logicOp <= 15, "Weird hardware Rop");

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 7 + 3 );

    config2D = config2D_NativeBlt[logicOp];
    render2D = render2D_NativeBlt[logicOp] | __RENDER2D_OP_PATCHORDER;

    if( LogicopReadDest[logicOp] )
        SET_READ_BUFFERS;

    dx = pptlSrc->x - pRectDst->left;
    dy = pptlSrc->y - pRectDst->top;

    if(ppdev->DstPixelOrigin == ppdev->SrcPixelOrigin)
    {
        if( dy >= 0 )
            render2D |= __RENDER2D_INCY;

        if( dx >= 0 )
            render2D |= __RENDER2D_INCX;
        // source and dest are part of the same surface
        if( (dy == 0) && (dx > -64) && (dx < 64) )
                config2D |= __CONFIG2D_FBBLOCKING;
    }

    LOAD_FBSOURCE_ADDR( ppdev->SrcPixelOrigin );
    LOAD_FBSOURCE_OFFSET_XY( dx + ppdev->xOffset, dy + (ppdev->xyOffsetSrc >> 16) );
    LOAD_FBSOURCE_WIDTH( ppdev->SrcPixelDelta );
    LOAD_CONFIG2D( config2D );

    DISPDBG((8, "offset: (%d, %d) -> (%d, %d), d = (%d, %d), %cve X, %cve Y", pptlSrc->x, pptlSrc->y, pRectDst->left, pRectDst->top,
             dx, dy, (render2D & __RENDER2D_INCX) ? '+' : '-', (render2D & __RENDER2D_INCY) ? '+' : '-'));

    while( 1 ) {
        render2D &= ~(__RENDER2D_WIDTH_MASK | __RENDER2D_HEIGHT_MASK);
        render2D |= __RENDER2D_WIDTH(pRect->right - pRect->left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top);

        DISPDBG((8, "dest rect: (%d, %d -> %d, %d)", pRect->left, pRect->top, pRect->right, pRect->bottom));

        QUEUE_PXRX_DMA_INDEX2( __GlintTagFillRectanglePosition, __GlintTagFillRender2D );
        QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(pRect->left, pRect->top) );
        QUEUE_PXRX_DMA_DWORD( render2D );

        FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

        if( !(--count) )
            break;

        ++pRect;

        WAIT_PXRX_DMA_DWORDS( 3 );
    }

    SEND_PXRX_DMA_BATCH;
}

VOID pxrxFillSolid( PPDEV ppdev, LONG count, RECTL *pRect, ULONG logicOp, ULONG bgLogicOp, RBRUSH_COLOR rbc, POINTL *pptlBrush )
{
    DWORD   config2D, render2D;
    ULONG   ulColor = rbc.iSolidColor;
    GLINT_DECL;

    DISPDBG((7, "pxrxFillSolid: %d rects, logicOp = %d, colour = 0x%08X", count, logicOp, rbc.iSolidColor));

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 5 + 2 );

    config2D = config2D_FillSolid[logicOp];
    render2D = render2D_FillSolid[logicOp] | __RENDER2D_OP_PATCHORDER;

    if( LogicopReadDest[logicOp] )
        SET_READ_BUFFERS;

    LOAD_FOREGROUNDCOLOUR( ulColor );
    LOAD_CONFIG2D( config2D );

    while( 1 ) {
        DISPDBG((8, "rect: (%d, %d) to (%d, %d)", pRect->left, pRect->top, pRect->right, pRect->bottom));

        render2D &= ~(__RENDER2D_WIDTH_MASK | __RENDER2D_HEIGHT_MASK);
        render2D |= __RENDER2D_WIDTH(pRect->right - pRect->left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top);
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(pRect->left, pRect->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D );

        FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

        if( !(--count) )
            break;

        ++pRect;

        WAIT_PXRX_DMA_TAGS( 2 );
    }
    
    SEND_PXRX_DMA_BATCH;
}

VOID p3r3FillSolidVariableSpans( PPDEV ppdev, LONG count, RECTL *pRect, ULONG logicOp, ULONG bgLogicOp, RBRUSH_COLOR rbc, POINTL *pptlBrush )
{
    DWORD   config2D, render2D;
    ULONG   ulColor = rbc.iSolidColor;
    GLINT_DECL;

    DISPDBG((7, "p3r3FillSolidVariableSpans: %d rects, logicOp = %d, colour = 0x%08X", count, logicOp, rbc.iSolidColor));

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 5 + 2 );

    config2D = config2D_FillSolidVariableSpans[logicOp];
    render2D = __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS | __RENDER2D_OP_PATCHORDER;

    if( LogicopReadDest[logicOp] )
        SET_READ_BUFFERS;

    LOAD_FOREGROUNDCOLOUR( ulColor );
    LOAD_CONFIG2D( config2D );

    while( 1 ) {
        DISPDBG((8, "rect: (%d, %d) to (%d, %d)", pRect->left, pRect->top, pRect->right, pRect->bottom));

        render2D &= ~(__RENDER2D_WIDTH_MASK | __RENDER2D_HEIGHT_MASK);
        render2D |= __RENDER2D_WIDTH(pRect->right - pRect->left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top);
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(pRect->left, pRect->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D );

        FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

        if( !(--count) )
            break;

        ++pRect;

        WAIT_PXRX_DMA_TAGS( 2 );
    }

    SEND_PXRX_DMA_BATCH;
}

VOID p3r3FillSolid32bpp( PPDEV ppdev, LONG count, RECTL *pRect, ULONG logicOp, ULONG bgLogicOp, RBRUSH_COLOR rbc, POINTL *pptlBrush )
{
    DWORD   config2D, render2D;
    ULONG   ulColor = rbc.iSolidColor, left;
    GLINT_DECL;

    config2D = config2D_FillSolid32bpp[logicOp];
    render2D = render2D_FillSolid[logicOp] | __RENDER2D_OP_PATCHORDER;

    if(OFFSCREEN_LIN_DST(ppdev) && (config2D & __CONFIG2D_USERSCISSOR))
    {
        // When filling linear DFBs we can't use the scissor and align to a 32 pixel boundary in x because
        // the coords aren't aligned to a scanline boundary in x. NB. Rectangular DFBs coords in x are always
        // relative to the start of a scanline so the scissor alignment works.
        p3r3FillSolidVariableSpans(ppdev, count, pRect, logicOp, bgLogicOp, rbc, pptlBrush);
        return;
    }

    DISPDBG((7, "p3r3FillSolid32bpp: %d rects, logicOp = %d, colour = 0x%08X", count, logicOp, rbc.iSolidColor));

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 5 + 2 );

    if( LogicopReadDest[logicOp] )
        SET_READ_BUFFERS;

    LOAD_FOREGROUNDCOLOUR( ulColor );
    LOAD_CONFIG2D( config2D );

    if( config2D & __CONFIG2D_USERSCISSOR ) {
        while( 1 ) {
            left = pRect->left & ~31;

            DISPDBG((8, "rect: (%d:%d, %d) to (%d, %d)", pRect->left, left, pRect->top, pRect->right, pRect->bottom));

            render2D &= ~(__RENDER2D_WIDTH_MASK | __RENDER2D_HEIGHT_MASK);
            render2D |= __RENDER2D_WIDTH(pRect->right - left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top);

            QUEUE_PXRX_DMA_INDEX3( __GlintTagFillScissorMinXY, __GlintTagFillRectanglePosition, __GlintTagFillRender2D );
            QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(pRect->left ,      0) );
            QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(left, pRect->top) );
            QUEUE_PXRX_DMA_DWORD( render2D );

            FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

            if( !(--count) )
                break;

            ++pRect;

            WAIT_PXRX_DMA_DWORDS( 5 );
        }
    } else {
        while( 1 ) {

            DISPDBG((8, "rect: (%d, %d) to (%d, %d)", pRect->left, pRect->top, pRect->right, pRect->bottom));

            render2D &= ~(__RENDER2D_WIDTH_MASK | __RENDER2D_HEIGHT_MASK);
            render2D |= __RENDER2D_WIDTH(pRect->right - pRect->left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top);
            QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(pRect->left, pRect->top) );
            QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D );

            FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

            if( !(--count) )
                break;

            ++pRect;

            WAIT_PXRX_DMA_TAGS( 2 );
        }
    }

    SEND_PXRX_DMA_BATCH;
}

VOID pxrxFillPatMono( PPDEV ppdev, LONG count, RECTL *pRect, ULONG fgLogicOp, ULONG bgLogicOp, RBRUSH_COLOR rbc, POINTL *pptlBrush )
{
    BRUSHENTRY  *pbe;
    ULONG       fgColor, bgColor;
    DWORD       config2D, render2D;
    LONG        c;
    GLINT_DECL;

    DISPDBG((7, "pxrxFillPatMono: %d rects. fgLogicOp = %d, bgLogicop %d", count, fgLogicOp, bgLogicOp));

    // if anything has changed with the brush we must re-realize it. If the brush
    // has been kicked out of the area stipple unit we must fully realize it. If
    // only the alignment has changed we can simply update the alignment for the
    // stipple.
    //
    pbe = rbc.prb->apbe;
    if( (pbe == NULL) || (pbe->prbVerify != rbc.prb) ) {
        DISPDBG((8, "full brush realise"));
        (*ppdev->pgfnPatRealize)(ppdev, rbc.prb, pptlBrush);
    }
    else if( (rbc.prb->ptlBrushOrg.x != pptlBrush->x) ||
             (rbc.prb->ptlBrushOrg.y != pptlBrush->y) ) {
        DISPDBG((8, "changing brush offset"));
        (*ppdev->pgfnMonoOffset)(ppdev, rbc.prb, pptlBrush);
    }

    fgColor = rbc.prb->ulForeColor;
    bgColor = rbc.prb->ulBackColor;
    DISPDBG((8, "fgColor 0x%x, bgColor 0x%x", fgColor, bgColor));

    // we get some common operations which are really noops. we can save
    // lots of time by cutting these out. As this happens a lot for masking
    // operations it's worth doing.

    if( ((fgLogicOp == __GLINT_LOGICOP_AND) && (fgColor == ppdev->ulWhite))
        || ((fgLogicOp == __GLINT_LOGICOP_OR ) && (fgColor == 0))
        || ((fgLogicOp == __GLINT_LOGICOP_XOR) && (fgColor == 0)) )
            fgLogicOp = __GLINT_LOGICOP_NOOP;

    // same for background
    if( ((bgLogicOp == __GLINT_LOGICOP_AND) && (bgColor == ppdev->ulWhite))
        || ((bgLogicOp == __GLINT_LOGICOP_OR ) && (bgColor == 0))
        || ((bgLogicOp == __GLINT_LOGICOP_XOR) && (bgColor == 0)) )
            bgLogicOp = __GLINT_LOGICOP_NOOP;

    if( (fgLogicOp == __GLINT_LOGICOP_NOOP) && (bgLogicOp == __GLINT_LOGICOP_NOOP) ) {
        DISPDBG((8, "both ops are no-op so lets quit now"));
        return;
    }

    config2D = __CONFIG2D_CONSTANTSRC | __CONFIG2D_FBWRITE;
    render2D = __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_AREASTIPPLE | __RENDER2D_OP_PATCHORDER;
    
    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 9 + 2 );

    if( (fgLogicOp != __GLINT_LOGICOP_COPY) || (bgLogicOp != __GLINT_LOGICOP_NOOP) ||
        (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITING) ||
        (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITING) ) {
        config2D |= __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(fgLogicOp) | __CONFIG2D_LOGOP_BACK(bgLogicOp);
        render2D |= __RENDER2D_SPANS;
    } else {
        LOAD_FBWRITE_ADDR( 1, ppdev->DstPixelOrigin );
        LOAD_FBWRITE_WIDTH( 1, ppdev->DstPixelDelta );
        LOAD_FBWRITE_OFFSET( 1, ppdev->xyOffsetDst );
    }

    if( LogicopReadDest[fgLogicOp] || LogicopReadDest[bgLogicOp] ) {
        config2D |= __CONFIG2D_FBDESTREAD;
        SET_READ_BUFFERS;
    }

    if( LogicOpReadSrc[fgLogicOp] )
        LOAD_FOREGROUNDCOLOUR( fgColor );
    if( LogicOpReadSrc[bgLogicOp] )
        LOAD_BACKGROUNDCOLOUR( bgColor );

    LOAD_CONFIG2D( config2D );

    c = count;
    while( TRUE ) {
        DISPDBG((8, "mono pattern fill to rect (%d,%d) to (%d,%d)", pRect->left, pRect->top, pRect->right, pRect->bottom));

        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(pRect->left, pRect->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D | __RENDER2D_WIDTH(pRect->right - pRect->left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top) );

        FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

        if (--c == 0)
            break;

        pRect++;
        WAIT_PXRX_DMA_TAGS( 2 );
    }

    SEND_PXRX_DMA_BATCH;

    DISPDBG((7, "pxrxFillPatMono returning"));
}

VOID p3r3FillPatMonoVariableSpans( PPDEV ppdev, LONG count, RECTL *pRect, ULONG fgLogicOp, ULONG bgLogicOp, RBRUSH_COLOR rbc, POINTL *pptlBrush )
{
    BRUSHENTRY  *pbe;
    ULONG       fgColor, bgColor;
    DWORD       config2D, render2D;
    LONG        c;
    GLINT_DECL;

    DISPDBG((7, "p3r3FillPatMonoVariableSpans: %d rects. fgLogicOp = %d, bgLogicop %d", count, fgLogicOp, bgLogicOp));

    // if anything has changed with the brush we must re-realize it. If the brush
    // has been kicked out of the area stipple unit we must fully realize it. If
    // only the alignment has changed we can simply update the alignment for the
    // stipple.
    //
    pbe = rbc.prb->apbe;
    if( (pbe == NULL) || (pbe->prbVerify != rbc.prb) ) {
        DISPDBG((8, "full brush realise"));
        (*ppdev->pgfnPatRealize)(ppdev, rbc.prb, pptlBrush);
    }
    else if( (rbc.prb->ptlBrushOrg.x != pptlBrush->x) ||
             (rbc.prb->ptlBrushOrg.y != pptlBrush->y) ) {
        DISPDBG((8, "changing brush offset"));
        (*ppdev->pgfnMonoOffset)(ppdev, rbc.prb, pptlBrush);
    }

    fgColor = rbc.prb->ulForeColor;
    bgColor = rbc.prb->ulBackColor;
    DISPDBG((8, "fgColor 0x%x, bgColor 0x%x", fgColor, bgColor));

    // we get some common operations which are really noops. we can save
    // lots of time by cutting these out. As this happens a lot for masking
    // operations it's worth doing.

    if( ((fgLogicOp == __GLINT_LOGICOP_AND) && (fgColor == ppdev->ulWhite))
        || ((fgLogicOp == __GLINT_LOGICOP_OR ) && (fgColor == 0))
        || ((fgLogicOp == __GLINT_LOGICOP_XOR) && (fgColor == 0)) )
            fgLogicOp = __GLINT_LOGICOP_NOOP;

    // same for background
    if( ((bgLogicOp == __GLINT_LOGICOP_AND) && (bgColor == ppdev->ulWhite))
        || ((bgLogicOp == __GLINT_LOGICOP_OR ) && (bgColor == 0))
        || ((bgLogicOp == __GLINT_LOGICOP_XOR) && (bgColor == 0)) )
            bgLogicOp = __GLINT_LOGICOP_NOOP;

    if( (fgLogicOp == __GLINT_LOGICOP_NOOP) && (bgLogicOp == __GLINT_LOGICOP_NOOP) ) {
        DISPDBG((8, "both ops are no-op so lets quit now"));
        return;
    }

    config2D = __CONFIG2D_CONSTANTSRC | __CONFIG2D_FBWRITE;
    render2D = __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS | __RENDER2D_AREASTIPPLE | __RENDER2D_OP_PATCHORDER;
    
    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 7 + 2 );

    config2D |= __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(fgLogicOp) | __CONFIG2D_LOGOP_BACK(bgLogicOp);

    if( LogicopReadDest[fgLogicOp] || LogicopReadDest[bgLogicOp] ) {
        config2D |= __CONFIG2D_FBDESTREAD;
        SET_READ_BUFFERS;
    }

    if( LogicOpReadSrc[fgLogicOp] )
        LOAD_FOREGROUNDCOLOUR( fgColor );
    if( LogicOpReadSrc[bgLogicOp] )
        LOAD_BACKGROUNDCOLOUR( bgColor );

    LOAD_CONFIG2D( config2D );

    c = count;
    while( TRUE ) {
        DISPDBG((8, "mono pattern fill to rect (%d,%d) to (%d,%d)", pRect->left, pRect->top, pRect->right, pRect->bottom));

        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(pRect->left, pRect->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D | __RENDER2D_WIDTH(pRect->right - pRect->left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top) );

        FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

        if (--c == 0)
            break;

        pRect++;
        WAIT_PXRX_DMA_TAGS( 2 );
    }
    
    SEND_PXRX_DMA_BATCH;

    DISPDBG((7, "p3r3FillPatMonoVariableSpans returning"));
}

VOID p3r3FillPatMono32bpp( PPDEV ppdev, LONG count, RECTL *pRect, ULONG fgLogicOp, ULONG bgLogicOp, RBRUSH_COLOR rbc, POINTL *pptlBrush )
{
    BRUSHENTRY  *pbe;
    ULONG       fgColor, bgColor;
    DWORD       config2D, render2D;
    LONG        c, left;
    GLINT_DECL;

    DISPDBG((7, "p3r3FillPatMono32bpp: %d rects. fgLogicOp = %d, bgLogicop %d", count, fgLogicOp, bgLogicOp));

    // if anything has changed with the brush we must re-realize it. If the brush
    // has been kicked out of the area stipple unit we must fully realize it. If
    // only the alignment has changed we can simply update the alignment for the
    // stipple.
    //
    pbe = rbc.prb->apbe;
    if( (pbe == NULL) || (pbe->prbVerify != rbc.prb) ) {
        DISPDBG((8, "full brush realise"));
        (*ppdev->pgfnPatRealize)(ppdev, rbc.prb, pptlBrush);
    }
    else if( (rbc.prb->ptlBrushOrg.x != pptlBrush->x) ||
             (rbc.prb->ptlBrushOrg.y != pptlBrush->y) ) {
        DISPDBG((8, "changing brush offset"));
        (*ppdev->pgfnMonoOffset)(ppdev, rbc.prb, pptlBrush);
    }

    fgColor = rbc.prb->ulForeColor;
    bgColor = rbc.prb->ulBackColor;
    DISPDBG((8, "fgColor 0x%x, bgColor 0x%x", fgColor, bgColor));

    // we get some common operations which are really noops. we can save
    // lots of time by cutting these out. As this happens a lot for masking
    // operations it's worth doing.

    if( ((fgLogicOp == __GLINT_LOGICOP_AND) && (fgColor == ppdev->ulWhite))
        || ((fgLogicOp == __GLINT_LOGICOP_OR ) && (fgColor == 0))
        || ((fgLogicOp == __GLINT_LOGICOP_XOR) && (fgColor == 0)) )
            fgLogicOp = __GLINT_LOGICOP_NOOP;

    // same for background
    if( ((bgLogicOp == __GLINT_LOGICOP_AND) && (bgColor == ppdev->ulWhite))
        || ((bgLogicOp == __GLINT_LOGICOP_OR ) && (bgColor == 0))
        || ((bgLogicOp == __GLINT_LOGICOP_XOR) && (bgColor == 0)) )
            bgLogicOp = __GLINT_LOGICOP_NOOP;

    if( (fgLogicOp == __GLINT_LOGICOP_NOOP) && (bgLogicOp == __GLINT_LOGICOP_NOOP) ) {
        DISPDBG((8, "both ops are no-op so lets quit now"));
        return;
    }

    config2D = __CONFIG2D_CONSTANTSRC | __CONFIG2D_FBWRITE;
    render2D = __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_AREASTIPPLE | __RENDER2D_OP_PATCHORDER;
    
    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 9 + 3 );

    if( (fgLogicOp != __GLINT_LOGICOP_COPY) || (bgLogicOp != __GLINT_LOGICOP_NOOP) ||
        (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITING)  ||
        (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITING) ||
        OFFSCREEN_LIN_DST(ppdev)) {
        config2D |= __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(fgLogicOp) | __CONFIG2D_LOGOP_BACK(bgLogicOp);
        render2D |= __RENDER2D_SPANS;
    } else {
        config2D |= __CONFIG2D_USERSCISSOR;
        LOAD_FBWRITE_ADDR( 1, ppdev->DstPixelOrigin );
        LOAD_FBWRITE_WIDTH( 1, ppdev->DstPixelDelta );
        LOAD_FBWRITE_OFFSET( 1, ppdev->xyOffsetDst );
    }

    if( LogicopReadDest[fgLogicOp] || LogicopReadDest[bgLogicOp] ) {
        config2D |= __CONFIG2D_FBDESTREAD;
        SET_READ_BUFFERS;
    }

    if( LogicOpReadSrc[fgLogicOp] )
        LOAD_FOREGROUNDCOLOUR( fgColor );
    if( LogicOpReadSrc[bgLogicOp] )
        LOAD_BACKGROUNDCOLOUR( bgColor );

    LOAD_CONFIG2D( config2D );

    c = count;
    if( config2D & __CONFIG2D_USERSCISSOR ) {
        while( TRUE ) {
            left = pRect->left & ~31;

            DISPDBG((8, "rect: (%d:%d, %d) to (%d, %d)", pRect->left, left, pRect->top, pRect->right, pRect->bottom));

            QUEUE_PXRX_DMA_INDEX3( __GlintTagFillScissorMinXY, __GlintTagFillRectanglePosition, __GlintTagFillRender2D );
            QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(pRect->left ,      0) );
            QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(left, pRect->top) );
            QUEUE_PXRX_DMA_DWORD( render2D | __RENDER2D_WIDTH(pRect->right - left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top) );

            if (--c == 0)
                break;

            pRect++;
            WAIT_PXRX_DMA_DWORDS( 5 );
        }
    } else {
        while( TRUE ) {
            DISPDBG((8, "mono pattern fill to rect (%d,%d) to (%d,%d)", pRect->left, pRect->top, pRect->right, pRect->bottom));

            QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(pRect->left, pRect->top) );
            QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D | __RENDER2D_WIDTH(pRect->right - pRect->left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top) );

            FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

            if (--c == 0)
                break;

            pRect++;
            WAIT_PXRX_DMA_TAGS( 2 );
        }
    }
    
    SEND_PXRX_DMA_BATCH;

    DISPDBG((7, "p3r3FillPatMono32bpp returning"));
}

/*
     8 Bpp:
        orgmodeCopy     = 3;
        orgmodeLogic    = 3;
        lmodeCopy       = (1 << 27);
        lmodeLogic      = (1 << 27);

    15 Bpp:
    16 Bpp:
    32 Bpp:
        orgmodeCopy     = 1;
        orgmodeLogic    = 3;
        lmodeCopy       = (1 << 27);
        lmodeLogic      = (1 << 27);

ULONG   orgmodeCopy = 1,            orgmodeLogic = 3;
ULONG     lmodeCopy = (1 << 27),      lmodeLogic = (1 << 27);

ULONG   orgmode;
ULONG   lmode;
*/

VOID pxrxFillPatColor( PPDEV ppdev, LONG count, RECTL *pRect, ULONG logicOp, ULONG bgLogicOp, RBRUSH_COLOR rbc, POINTL *pptlBrush ) {
    BRUSHENTRY  *pbe;
    DWORD       config2D, render2D;
    LONG        index = 0, i;
    ULONG       *pulBrush;
    ULONG       cRows, cCols;
    POINTL      brushOrg;
    GLINT_DECL;

    DISPDBG((7, "pxrxFillPatColor: %d rects, logicOp = %d, brush = 0x%08X", count, logicOp, rbc.prb));

    // Determine the brush origin:
    brushOrg = *pptlBrush;
    if( (logicOp == __GLINT_LOGICOP_COPY) && (ppdev->cPelSize != 0) )
        brushOrg.x +=  (8 - (ppdev->xyOffsetDst & 0xFFFF)) & 7;

    // If anything has changed with the brush we must re-realize it.
    pbe = rbc.prb->apbe;
    if( (ppdev->PalLUTType != LUTCACHE_BRUSH) || (pbe == NULL) || (pbe->prbVerify != rbc.prb) ) {
        DISPDBG((8, "realising brush"));
        (*ppdev->pgfnPatRealize)(ppdev, rbc.prb, &brushOrg);
    } else
    if( (rbc.prb->ptlBrushOrg.x != brushOrg.x) || (rbc.prb->ptlBrushOrg.y != brushOrg.y) ||
        (rbc.prb->patternBase != ((glintInfo->lutMode >> 18) & 255)) ) {
        ULONG   lutMode = glintInfo->lutMode;
        DISPDBG((8, "resetting LUTMode"));

        rbc.prb->ptlBrushOrg.x = brushOrg.x;
        rbc.prb->ptlBrushOrg.y = brushOrg.y;

        DISPDBG((8, "setting new LUT brush origin to (%d, %d)", rbc.prb->ptlBrushOrg.x & 7, rbc.prb->ptlBrushOrg.y & 7));

        lutMode &= ~((7 << 8) | (7 << 12) | (7 << 15) | (255 << 18) | (1 << 26) | (1 << 27));
        lutMode |= (1 << 27) | (1 << 8) | (rbc.prb->patternBase << 18) |
                   (((8 - rbc.prb->ptlBrushOrg.x) & 7) << 12) | (((8 - rbc.prb->ptlBrushOrg.y) & 7) << 15);
        WAIT_PXRX_DMA_TAGS( 1 );
        LOAD_LUTMODE( lutMode );
    } else {
        // we're cached already!
        DISPDBG((7, "pxrxFillPatColor: reusing LUT for brush @ %d, origin = (%d,%d)", rbc.prb->patternBase, rbc.prb->ptlBrushOrg.x & 7, rbc.prb->ptlBrushOrg.y & 7));
    }

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 5 + 2 );

    if( (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITING) ||
        (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITING) ) {
        config2D = config2D_FillColourDual[logicOp];
        render2D = __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS | __RENDER2D_OP_PATCHORDER;    // render2D_FillSolidDual[logicOp]

        if( LogicopReadDest[logicOp] )
            SET_READ_BUFFERS;
    } else {
        config2D = config2D_FillColour[logicOp];
        render2D = render2D_FillSolid[logicOp] | __RENDER2D_OP_PATCHORDER;

        if( LogicopReadDest[logicOp] ) {
            SET_READ_BUFFERS;
        }
        else if( logicOp == __GLINT_LOGICOP_COPY ) {
            LOAD_FBWRITE_ADDR( 1, ppdev->DstPixelOrigin );
            LOAD_FBWRITE_WIDTH( 1, ppdev->DstPixelDelta );
            LOAD_FBWRITE_OFFSET( 1, ppdev->xyOffsetDst );
        }
    }

    LOAD_CONFIG2D( config2D );

    while( 1 ) {
        DISPDBG((8, "rect: (%d, %d) to (%d, %d)", pRect->left, pRect->top, pRect->right, pRect->bottom));

        render2D &= ~(__RENDER2D_WIDTH_MASK | __RENDER2D_HEIGHT_MASK);
        render2D |= __RENDER2D_WIDTH(pRect->right - pRect->left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top);
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(pRect->left, pRect->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D );

        FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

        WAIT_PXRX_DMA_TAGS( 2 );

        if( !(--count) )
            break;

        ++pRect;
    }

    // Invalidate the foreground/background colours 'cos the LUT has just corrupted them!
    WAIT_PXRX_DMA_TAGS( 2 );
    QUEUE_PXRX_DMA_TAG( __GlintTagForegroundColor, glintInfo->foregroundColour );
    QUEUE_PXRX_DMA_TAG( __GlintTagBackgroundColor, glintInfo->backgroundColour );

    SEND_PXRX_DMA_BATCH;
}

VOID p3r3FillPatColorVariableSpans( PPDEV ppdev, LONG count, RECTL *pRect, ULONG logicOp, ULONG bgLogicOp, RBRUSH_COLOR rbc, POINTL *pptlBrush ) {
    BRUSHENTRY  *pbe;
    DWORD       config2D, render2D;
    LONG        index = 0, i;
    ULONG       *pulBrush;
    ULONG       cRows, cCols;
    POINTL      brushOrg;
    GLINT_DECL;

    DISPDBG((7, "p3r3FillPatColorVariableSpans: %d rects, logicOp = %d, brush = 0x%08X", count, logicOp, rbc.prb));

    // Determine the brush origin:
    brushOrg = *pptlBrush;
    if( (logicOp == __GLINT_LOGICOP_COPY) && (ppdev->cPelSize != 0) )
        brushOrg.x +=  (8 - (ppdev->xyOffsetDst & 0xFFFF)) & 7;

    // If anything has changed with the brush we must re-realize it.
    pbe = rbc.prb->apbe;
    if( (ppdev->PalLUTType != LUTCACHE_BRUSH) || (pbe == NULL) || (pbe->prbVerify != rbc.prb) ) {
        DISPDBG((8, "realising brush"));
        (*ppdev->pgfnPatRealize)(ppdev, rbc.prb, &brushOrg);
    } else
    if( (rbc.prb->ptlBrushOrg.x != brushOrg.x) || (rbc.prb->ptlBrushOrg.y != brushOrg.y) ||
        (rbc.prb->patternBase != ((glintInfo->lutMode >> 18) & 255)) ) {
        ULONG   lutMode = glintInfo->lutMode;
        DISPDBG((8, "resetting LUTMode"));

        rbc.prb->ptlBrushOrg.x = brushOrg.x;
        rbc.prb->ptlBrushOrg.y = brushOrg.y;

        DISPDBG((8, "setting new LUT brush origin to (%d, %d)", rbc.prb->ptlBrushOrg.x & 7, rbc.prb->ptlBrushOrg.y & 7));

        lutMode &= ~((7 << 8) | (7 << 12) | (7 << 15) | (255 << 18) | (1 << 26) | (1 << 27));
        lutMode |= (1 << 27) | (1 << 8) | (rbc.prb->patternBase << 18) |
                   (((8 - rbc.prb->ptlBrushOrg.x) & 7) << 12) | (((8 - rbc.prb->ptlBrushOrg.y) & 7) << 15);
        WAIT_PXRX_DMA_TAGS( 1 );
        LOAD_LUTMODE( lutMode );
    } else {
        // we're cached already!
        DISPDBG((7, "p3r3FillPatColorVariableSpans: reusing LUT for brush @ %d, origin = (%d,%d)", rbc.prb->patternBase, rbc.prb->ptlBrushOrg.x & 7, rbc.prb->ptlBrushOrg.y & 7));
    }

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 5 + 2 );

    config2D = config2D_FillColourDual[logicOp];
    render2D = __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS | __RENDER2D_OP_PATCHORDER;

    if( LogicopReadDest[logicOp] )
        SET_READ_BUFFERS;

    LOAD_CONFIG2D( config2D );

    while( 1 ) {
        DISPDBG((8, "rect: (%d, %d) to (%d, %d)", pRect->left, pRect->top, pRect->right, pRect->bottom));

        render2D &= ~(__RENDER2D_WIDTH_MASK | __RENDER2D_HEIGHT_MASK);
        render2D |= __RENDER2D_WIDTH(pRect->right - pRect->left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top);
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(pRect->left, pRect->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D );

        FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

        WAIT_PXRX_DMA_TAGS( 2 );

        if( !(--count) )
            break;

        ++pRect;
    }

    // Invalidate the foreground/background colours 'cos the LUT has just corrupted them!
    WAIT_PXRX_DMA_TAGS( 2 );
    QUEUE_PXRX_DMA_TAG( __GlintTagForegroundColor, glintInfo->foregroundColour );
    QUEUE_PXRX_DMA_TAG( __GlintTagBackgroundColor, glintInfo->backgroundColour );

    SEND_PXRX_DMA_BATCH;
}

VOID pxrxCacheBrush16bpp(PDEV *ppdev, RBRUSH_COLOR rbc, POINTL *pbrushOrg)
{
    BRUSHENTRY  *pbe;
    GLINT_DECL;

    // If anything has changed with the brush we must re-realize it.
    pbe = rbc.prb->apbe;
    if( (ppdev->PalLUTType != LUTCACHE_BRUSH) || (pbe == NULL) || (pbe->prbVerify != rbc.prb) ) {
        DISPDBG((8, "pxrxCacheBrush16bpp: realising brush"));
        ppdev->pgfnPatRealize(ppdev, rbc.prb, pbrushOrg);
    } else
    if( (rbc.prb->ptlBrushOrg.x != pbrushOrg->x) || (rbc.prb->ptlBrushOrg.y != pbrushOrg->y) ||
        (rbc.prb->patternBase != ((glintInfo->lutMode >> 18) & 255)) ) {
        ULONG   lutMode = glintInfo->lutMode;
        DISPDBG((8, "pxrxCacheBrush16bpp: resetting LUTMode"));

        rbc.prb->ptlBrushOrg.x = pbrushOrg->x;
        rbc.prb->ptlBrushOrg.y = pbrushOrg->y;

        DISPDBG((8, "pxrxCacheBrush16bpp: setting new LUT brush origin to (%d, %d)", rbc.prb->ptlBrushOrg.x & 7, rbc.prb->ptlBrushOrg.y & 7));

        lutMode &= ~((7 << 8) | (7 << 12) | (7 << 15) | (255 << 18) | (1 << 26) | (1 << 27));
        lutMode |= (1 << 27) | (1 << 8) | (rbc.prb->patternBase << 18) |
                   (((8 - rbc.prb->ptlBrushOrg.x) & 7) << 12) | (((8 - rbc.prb->ptlBrushOrg.y) & 7) << 15);
        WAIT_PXRX_DMA_TAGS( 1 );
        LOAD_LUTMODE( lutMode );
    } else {
        // we're cached already!
        DISPDBG((7, "pxrxCacheBrush16bpp: reusing LUT for brush @ %d, origin = (%d,%d)", rbc.prb->patternBase, rbc.prb->ptlBrushOrg.x & 7, rbc.prb->ptlBrushOrg.y & 7));
    }
}

VOID p3r3FillPatColor16bpp( PPDEV ppdev, LONG count, RECTL *pRect, ULONG logicOp, ULONG bgLogicOp, RBRUSH_COLOR rbc, POINTL *pptlBrush ) {
    DWORD       config2D, render2D;
    LONG        cx, cy, i;
    POINTL      brushOrg;
    BOOL        bCoreInitialized = FALSE;
    BOOL        bBypassInitialized = FALSE;
    GLINT_DECL;

    DISPDBG((7, "pxrxFillPatColor16bpp: %d rects, logicOp = %d, brush = 0x%08X", count, logicOp, rbc.prb));

    // Determine the brush origin:
    brushOrg = *pptlBrush;
    if( (logicOp == __GLINT_LOGICOP_COPY) && (ppdev->cPelSize != 0) )
        brushOrg.x +=  (8 - (ppdev->xyOffsetDst & 0xFFFF)) & 7;

    while( 1 ) {
        cx = pRect->right - pRect->left;
        cy = pRect->bottom - pRect->top;

        // render through core
        if(!bCoreInitialized) {
            pxrxCacheBrush16bpp(ppdev, rbc, &brushOrg);

            SET_WRITE_BUFFERS;

            WAIT_PXRX_DMA_TAGS( 5 + 2 );

            if( (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITING) ||
                (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITING) ) {
                config2D = config2D_FillColourDual[logicOp];
                render2D = __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS | __RENDER2D_OP_PATCHORDER;    // render2D_FillSolidDual[logicOp]

                if( LogicopReadDest[logicOp] )
                    SET_READ_BUFFERS;
            } else {
                config2D = config2D_FillColour[logicOp];
                render2D = render2D_FillSolid[logicOp] | __RENDER2D_OP_PATCHORDER;

                if( LogicopReadDest[logicOp] ) {
                    SET_READ_BUFFERS;
                }
                else if( logicOp == __GLINT_LOGICOP_COPY ) {
                    LOAD_FBWRITE_ADDR( 1, ppdev->DstPixelOrigin );
                    LOAD_FBWRITE_WIDTH( 1, ppdev->DstPixelDelta );
                    LOAD_FBWRITE_OFFSET( 1, ppdev->xyOffsetDst );
                }
            }

            LOAD_CONFIG2D( config2D );

            bCoreInitialized = TRUE;
        }
        render2D &= ~(__RENDER2D_WIDTH_MASK | __RENDER2D_HEIGHT_MASK);
        render2D |= __RENDER2D_WIDTH(pRect->right - pRect->left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top);
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(pRect->left, pRect->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D );

        FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

        WAIT_PXRX_DMA_TAGS( 2 );

        if( !(--count) )
            break;

        ++pRect;
    }

    // Invalidate the foreground/background colours 'cos the LUT has just corrupted them!
    WAIT_PXRX_DMA_TAGS( 2 );
    QUEUE_PXRX_DMA_TAG( __GlintTagForegroundColor, glintInfo->foregroundColour );
    QUEUE_PXRX_DMA_TAG( __GlintTagBackgroundColor, glintInfo->backgroundColour );

    SEND_PXRX_DMA_BATCH;
}

VOID pxrxCacheBrush32bpp(PDEV *ppdev, RBRUSH_COLOR rbc, POINTL *pbrushOrg)
{
    BRUSHENTRY  *pbe;
    GLINT_DECL;

    // If anything has changed with the brush we must re-realize it.
    pbe = rbc.prb->apbe;
    if( (ppdev->PalLUTType != LUTCACHE_BRUSH) || (pbe == NULL) || (pbe->prbVerify != rbc.prb) ) {
        DISPDBG((8, "pxrxCacheBrush32bpp: realising brush"));
        ppdev->pgfnPatRealize(ppdev, rbc.prb, pbrushOrg);
    } else
    if( (rbc.prb->ptlBrushOrg.x != pbrushOrg->x) || (rbc.prb->ptlBrushOrg.y != pbrushOrg->y) ||
        (rbc.prb->patternBase != ((glintInfo->lutMode >> 18) & 255)) ) {
        ULONG   lutMode = glintInfo->lutMode;
        DISPDBG((8, "pxrxCacheBrush32bpp: resetting LUTMode"));

        rbc.prb->ptlBrushOrg.x = pbrushOrg->x;
        rbc.prb->ptlBrushOrg.y = pbrushOrg->y;

        DISPDBG((8, "pxrxCacheBrush32bpp: setting new LUT brush origin to (%d, %d)", rbc.prb->ptlBrushOrg.x & 7, rbc.prb->ptlBrushOrg.y & 7));

        lutMode &= ~((7 << 8) | (7 << 12) | (7 << 15) | (255 << 18) | (1 << 26) | (1 << 27));
        lutMode |= (1 << 27) | (1 << 8) | (rbc.prb->patternBase << 18) |
                   (((8 - rbc.prb->ptlBrushOrg.x) & 7) << 12) | (((8 - rbc.prb->ptlBrushOrg.y) & 7) << 15);
        WAIT_PXRX_DMA_TAGS( 1 );
        LOAD_LUTMODE( lutMode );
    } else {
        // we're cached already!
        DISPDBG((7, "pxrxCacheBrush32bpp: reusing LUT for brush @ %d, origin = (%d, %d)", rbc.prb->patternBase, rbc.prb->ptlBrushOrg.x & 7, rbc.prb->ptlBrushOrg.y & 7));
    }
}

VOID p3r3FillPatColor32bpp( PPDEV ppdev, LONG count, RECTL *pRect, ULONG logicOp, ULONG bgLogicOp, RBRUSH_COLOR rbc, POINTL *pptlBrush ) {
    POINTL      brushOrg;
    DWORD       config2D, render2D;
    LONG        cx, cy, i, left;
    BOOL        bCoreInitialized = FALSE;
    BOOL        bBypassInitialized = FALSE;
    GLINT_DECL;

    // Determine the brush origin:
    brushOrg = *pptlBrush;

    DISPDBG((7, "p3r3FillPatColor32bpp: %d rects, logicOp = %d, brush = 0x%08X", count, logicOp, rbc.prb));

    while( 1 ) {
        cx = pRect->right - pRect->left;
        cy = pRect->bottom - pRect->top;

        // render through core
        if(!bCoreInitialized) {
            pxrxCacheBrush32bpp(ppdev, rbc, &brushOrg);
            SET_WRITE_BUFFERS;

            WAIT_PXRX_DMA_TAGS( 5 + 2 );

            if( (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITING) ||
                (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITING) ||
                OFFSCREEN_LIN_DST(ppdev)) {
                config2D = config2D_FillColourDual[logicOp];
                render2D = __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS | __RENDER2D_OP_PATCHORDER;    // render2D_FillSolidDual[logicOp]

                if( LogicopReadDest[logicOp] )
                    SET_READ_BUFFERS;
            } else {
                config2D = config2D_FillColour32bpp[logicOp];
                render2D = render2D_FillSolid[logicOp] | __RENDER2D_OP_PATCHORDER;

                if( LogicopReadDest[logicOp] ) {
                    SET_READ_BUFFERS;
                }
                else if( logicOp == __GLINT_LOGICOP_COPY ) {
                    LOAD_FBWRITE_ADDR( 1, ppdev->DstPixelOrigin );
                    LOAD_FBWRITE_WIDTH( 1, ppdev->DstPixelDelta );
                    LOAD_FBWRITE_OFFSET( 1, ppdev->xyOffsetDst );
                }
            }
            LOAD_CONFIG2D( config2D );

            bCoreInitialized = TRUE;
            if( config2D & __CONFIG2D_USERSCISSOR ) {
                left = pRect->left & ~31;

                DISPDBG((8, "p3r3FillPatColor32bpp: scissor core fill (%d:%d, %d) to (%d, %d)", pRect->left, left, pRect->top, pRect->right, pRect->bottom));

                render2D &= ~(__RENDER2D_WIDTH_MASK | __RENDER2D_HEIGHT_MASK);
                render2D |= __RENDER2D_WIDTH(pRect->right - left) | __RENDER2D_HEIGHT(cy);

                QUEUE_PXRX_DMA_INDEX3( __GlintTagFillScissorMinXY, __GlintTagFillRectanglePosition, __GlintTagFillRender2D );
                QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(pRect->left ,    0) );
                QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(left,            pRect->top) );
                QUEUE_PXRX_DMA_DWORD( render2D );

                FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

                WAIT_PXRX_DMA_DWORDS( 5 );
            } else {
                DISPDBG((8, "p3r3FillPatColor32bpp: core fill (%d, %d) to (%d, %d)", pRect->left, pRect->top, pRect->right, pRect->bottom));

                render2D &= ~(__RENDER2D_WIDTH_MASK | __RENDER2D_HEIGHT_MASK);
                render2D |= __RENDER2D_WIDTH(cx) | __RENDER2D_HEIGHT(cy);
                QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(pRect->left, pRect->top) );
                QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D );

                FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

                WAIT_PXRX_DMA_TAGS( 2 );
            }
        }
        if( !(--count) )
            break;

        ++pRect;
    }


    // Invalidate the foreground/background colours 'cos the LUT has just corrupted them!
    WAIT_PXRX_DMA_TAGS( 2 );
    QUEUE_PXRX_DMA_TAG( __GlintTagForegroundColor, glintInfo->foregroundColour );
    QUEUE_PXRX_DMA_TAG( __GlintTagBackgroundColor, glintInfo->backgroundColour );

    SEND_PXRX_DMA_BATCH;
}

VOID pxrxMaskCopyBlt( PPDEV ppdev, RECTL *a, LONG b, SURFOBJ *c, POINTL *d, ULONG e, ULONG f, POINTL *g, RECTL *h ) {
    DISPDBG((ERRLVL,"pxrxMaskCopyBlt was called"));
}

VOID pxrxPatRealize( PPDEV ppdev, RBRUSH *prb, POINTL *pptlBrush )
{
    BRUSHENTRY  *pbe;
    LONG        iBrushCache;
    LONG        i;
    DWORD       *pSrc;
    GLINT_DECL;

    DISPDBG((7, "pxrxPatRealize started"));

    pbe = prb->apbe;
    if( prb->fl & RBRUSH_2COLOR ) {
        if( (pbe == NULL) || (pbe->prbVerify != prb) ) {
            // mono brushes are realized into the area stipple unit. For this we
            // have a set of special BRUSHENTRYs, one for each board.
            DISPDBG((8, "loading mono brush into cache"));
            pbe = &ppdev->abeMono;
            pbe->prbVerify           = prb;
            prb->apbe = pbe;
        }
    } else {
        if( ppdev->PalLUTType != LUTCACHE_BRUSH ) {
            // Someone has hijacked the LUT so we need to invalidate it:
            ppdev->PalLUTType = LUTCACHE_BRUSH;

            for( i = 0; i < MAX_P3_BRUSHES; i++ )
                ppdev->abeP3[i].prbVerify = NULL;
        }

        if( (pbe == NULL) || (pbe->prbVerify != prb) ) {
            // colourbrushes are realized into the LUT unit table.
            DISPDBG((8, "loading colour brush into cache"));

            iBrushCache = ppdev->iBrushCacheP3;
            pbe         = &ppdev->abeP3[iBrushCache];

            // Update our links:
            pbe->prbVerify                  = prb;
            prb->apbe        = pbe;
            prb->patternBase    = iBrushCache * (256 / MAX_P3_BRUSHES);        // Should be related to colour depth ???
            DISPDBG((8, "new cache entry allocated for color brush @ entry %d", prb->patternBase));

            iBrushCache++;
            if( iBrushCache >= MAX_P3_BRUSHES )
                iBrushCache = 0;
            ppdev->iBrushCacheP3 = iBrushCache;
        }
    }

    pSrc = &prb->aulPattern[0];

    // we're going to load mono patterns into the area stipple and set the
    // start offset to the brush origin. WARNING: we assume that we are
    // running little endian. I believe this is always true for NT.
    if( prb->fl & RBRUSH_2COLOR ) {

        // this function loads the stipple offset into the hardware. We also call
        // this function on its own if the brush is realized but its offset changes.
        // In that case we don't have to go through a complete realize again.
        (*ppdev->pgfnMonoOffset)(ppdev, prb, pptlBrush);

        DISPDBG((8, "area stipple pattern:"));
        WAIT_PXRX_DMA_DWORDS( 9 );
        QUEUE_PXRX_DMA_INC( __GlintTagAreaStipplePattern0, 8 );
        QUEUE_PXRX_DMA_BUFF( pSrc, 8 );
        SEND_PXRX_DMA_BATCH;

        //for( i = 0; i < 8; ++i, ++pSrc ) {
        //  DISPDBG((8, "\t0x%08x", *pSrc));
        //}

        DISPDBG((7, "area stipple downloaded. pxrxPatRealize done"));
        return;
    } else {
        ULONG   lutMode;

        prb->ptlBrushOrg.x = pptlBrush->x;
        prb->ptlBrushOrg.y = pptlBrush->y;
        lutMode = (1 << 27) | (1 << 8) | (prb->patternBase << 18) |        // SpanOp = 8x8 brush, pattern base, x-offset, y-offset
                (((8 - prb->ptlBrushOrg.x) & 7) << 12) | (((8 - prb->ptlBrushOrg.y) & 7) << 15);

        DISPDBG((8, "setting new LUT brush origin to (%d, %d) @ %d", prb->ptlBrushOrg.x & 7, prb->ptlBrushOrg.y & 7, prb->patternBase));

        switch( ppdev->cPelSize ) {
            case 0:                // 8 bpp
                DISPDBG((8, "LUT pattern (8bpp, 8x8):"));

                WAIT_PXRX_DMA_DWORDS( 4 + 17 );
                LOAD_LUTMODE( lutMode );
                QUEUE_PXRX_DMA_TAG( __PXRXTagLUTIndex, prb->patternBase );
                QUEUE_PXRX_DMA_HOLD( __PXRXTagLUTData, 8 * 2 );
                QUEUE_PXRX_DMA_BUFF( pSrc, 8 * 2 );

                //for( i = 0; i < 8; ++i ) {
                //  DISPDBG((8, "\t0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x",
                //             pSrc[0] & 0xFF, (pSrc[0] >> 8) & 0xFF, (pSrc[0] >> 16) & 0xFF, (pSrc[0] >> 24) & 0xFF,
                //             pSrc[1] & 0xFF, (pSrc[1] >> 8) & 0xFF, (pSrc[2] >> 16) & 0xFF, (pSrc[3] >> 24) & 0xFF));
                //  pSrc += 2;
                //}
                SEND_PXRX_DMA_BATCH;

                DISPDBG((7, "LUT downloaded. pxrxPatRealize done"));
            return;

            case 1:                // 16 bpp
                DISPDBG((8, "LUT pattern (16bpp, 8x8):"));

                WAIT_PXRX_DMA_DWORDS( 4 + 33 );
                LOAD_LUTMODE( lutMode );
                QUEUE_PXRX_DMA_TAG( __PXRXTagLUTIndex, prb->patternBase );
                QUEUE_PXRX_DMA_HOLD( __PXRXTagLUTData, 8 * 4 );
                QUEUE_PXRX_DMA_BUFF( pSrc, 8 * 4 );

                //for( i = 0; i < 8; ++i ) {
                //  DISPDBG((8, "\t0x%04x, 0x%04x, 0x%04x, 0x%04x, 0x%04x, 0x%04x, 0x%04x, 0x%04x",
                //             pSrc[0] & 0xFFFF, pSrc[0] >> 16, pSrc[1] & 0xFFFF, pSrc[1] >> 16,
                //             pSrc[2] & 0xFFFF, pSrc[2] >> 16, pSrc[3] & 0xFFFF, pSrc[3] >> 16));
                //  pSrc += 4;
                //}
                SEND_PXRX_DMA_BATCH;

                DISPDBG((7, "LUT downloaded. pxrxPatRealize done"));
            return;

            case 2:                // 32 bpp
                DISPDBG((8, "LUT pattern (32bpp, 8x8):"));

                WAIT_PXRX_DMA_DWORDS( 4 + 65 );
                LOAD_LUTMODE( lutMode );
                QUEUE_PXRX_DMA_TAG( __PXRXTagLUTIndex, prb->patternBase );
                QUEUE_PXRX_DMA_HOLD( __PXRXTagLUTData, 8 * 8 );
                QUEUE_PXRX_DMA_BUFF( pSrc, 8 * 8 );

                //for( i = 0; i < 8; ++i ) {
                //  DISPDBG((8, "\t0x%06x, 0x%06x, 0x%06x, 0x%06x, 0x%06x, 0x%06x, 0x%06x, 0x%06x",
                //             pSrc[0], pSrc[1], pSrc[2], pSrc[3], pSrc[4], pSrc[5], pSrc[6], pSrc[7]));
                //  pSrc += 8;
                //}
                SEND_PXRX_DMA_BATCH;

                DISPDBG((7, "LUT downloaded. pxrxPatRealize done"));
            return;
        }
    }

    DISPDBG((-1, "pxrxPatRealize: Failed to realize brush!"));
}

VOID pxrxMonoOffset( PPDEV ppdev, RBRUSH *prb, POINTL *pptlBrush )
{
    DWORD   mode;
    GLINT_DECL;

    DISPDBG((7, "pxrxMonoOffset started"));
    // construct the AreaStippleMode value. It contains the pattern size,
    // the offset for the brush origin and the enable bit. Remember the
    // offset so we can later check if it changes and update the hardware.
    // Remember the mode so we can do a mirrored stipple easily.
    prb->ptlBrushOrg.x = pptlBrush->x;
    prb->ptlBrushOrg.y = pptlBrush->y;
    mode =  __PERMEDIA_ENABLE |
            AREA_STIPPLE_XSEL(__GLINT_AREA_STIPPLE_32_PIXEL_PATTERN) |
            AREA_STIPPLE_YSEL(__GLINT_AREA_STIPPLE_8_PIXEL_PATTERN) |
            AREA_STIPPLE_MIRROR_X |
            AREA_STIPPLE_XOFF(8 - (prb->ptlBrushOrg.x & 7)) |
            AREA_STIPPLE_YOFF(8 - (prb->ptlBrushOrg.y & 7));
    if( glintInfo->config2D & __CONFIG2D_OPAQUESPANS )
        mode |= (1 << 20);
    prb->areaStippleMode = mode;

    DISPDBG((8, "setting new area stipple offset to %d, %d",
                    8 - (prb->ptlBrushOrg.x & 7),
                    8 - (prb->ptlBrushOrg.y & 7)));

    WAIT_PXRX_DMA_TAGS( 1 );
    QUEUE_PXRX_DMA_TAG( __GlintTagAreaStippleMode, mode );
//  SEND_PXRX_DMA_BATCH;
    DISPDBG((7, "pxrxMonoOffset done"));
}

VOID pxrxRepNibbles( PPDEV ppdev, RECTL *a, CLIPOBJ *b ) {
    DISPDBG((ERRLVL,"pxrxRepNibbles was called"));
}


#if PXRX_DMA_BUFFER_CHECK
void checkPXRXdmaValidBuffer( PPDEV ppdev, GlintDataPtr glintInfo, ULONG type, ULONG count ) {
    ULONG   *ptr, origCount = count, failure = FALSE;

    if(!inPxRxContextSwitch && (*ppdev->pCurrentCtxt != glintInfo->ddCtxtId))
    {
        DISPDBG((-1000, "CHECK_PXRX_DMA_VALIDITY: ERROR - not in 2D context!!!" ));
        return;
    }

    ASSERTDD( (gi_pxrxDMA.NTbuff == 0) || (gi_pxrxDMA.NTbuff == 1), "CHECK_PXRX_DMA_VALIDITY failed for NTbuff!");

    /*
          0k -  16k = 16k = protection zone 0          pxrxDMA.bufferBase
         16k -  56k = 40k = buffer 0 (40k)          gi_pxrxDMA.DMAaddrL[0]
         56k -  72k = 16k = protection zone 1       gi_pxrxDMA.DMAaddrEndL[0]
         72k - 112k = 40k = buffer 1                gi_pxrxDMA.DMAaddrL[1]
        112k - 128k = 16k = protection zone 2       gi_pxrxDMA.DMAaddrEndL[1]
                                                       pxrxDMA.bufferTop
    */

//  DISPDBG((-1, "0x%08X - 0x%08X = 0x%08X ?=? 0x%08X", gi_pxrxDMA.DMAaddrL[0],    pxrxDMA_bufferBase    , (gi_pxrxDMA.DMAaddrL[0] -    pxrxDMA_bufferBase    ), PXRX_DMA_BUFFER_CHECK_SIZE));
//  DISPDBG((-1, "0x%08X - 0x%08X = 0x%08X ?=? 0x%08X", gi_pxrxDMA.DMAaddrL[1], gi_pxrxDMA.DMAaddrEndL[0], (gi_pxrxDMA.DMAaddrL[1] - gi_pxrxDMA.DMAaddrEndL[0]), PXRX_DMA_BUFFER_CHECK_SIZE));
//  DISPDBG((-1, "0x%08X - 0x%08X = 0x%08X ?=? 0x%08X",    pxrxDMA_bufferTop  , gi_pxrxDMA.DMAaddrEndL[1], (   pxrxDMA_bufferTop   - gi_pxrxDMA.DMAaddrEndL[1]), PXRX_DMA_BUFFER_CHECK_SIZE));

    // start0 - base == bufferSize
    if( (gi_pxrxDMA.DMAaddrL[0] - glintInfo->pxrxDMA_bufferBase) != (PXRX_DMA_BUFFER_CHECK_SIZE) ) {
        DISPDBG((-1000, "CHECK_BUFF failed on protection zone 0's size! (%d vs %d)",
                 gi_pxrxDMA.DMAaddrL[0] - glintInfo->pxrxDMA_bufferBase, PXRX_DMA_BUFFER_CHECK_SIZE));
        DebugBreak();
    }
    // start1 - end0 == bufferSize
    if( (gi_pxrxDMA.DMAaddrL[1] - gi_pxrxDMA.DMAaddrEndL[0]) != (PXRX_DMA_BUFFER_CHECK_SIZE) ) {
        DISPDBG((-1000, "CHECK_BUFF failed on protection zone 1's size! (%d vs %d)",
                 gi_pxrxDMA.DMAaddrL[1] - gi_pxrxDMA.DMAaddrEndL[0], PXRX_DMA_BUFFER_CHECK_SIZE));
        DebugBreak();
    }
    // top - end1 == bufferSize
    if( (glintInfo->pxrxDMA_bufferTop - gi_pxrxDMA.DMAaddrEndL[1]) != (PXRX_DMA_BUFFER_CHECK_SIZE) ) {
        DISPDBG((-1000, "CHECK_BUFF failed on protection zone 2's size! (%d vs %d)",
                 glintInfo->pxrxDMA_bufferTop - gi_pxrxDMA.DMAaddrEndL[1], PXRX_DMA_BUFFER_CHECK_SIZE));
        DebugBreak();
    }

    // end0 - start0 == end1 - start1
    if( (gi_pxrxDMA.DMAaddrEndL[0] - gi_pxrxDMA.DMAaddrL[0]) != (gi_pxrxDMA.DMAaddrEndL[1] - gi_pxrxDMA.DMAaddrL[1]) ) {
        DISPDBG((-1000, "CHECK_BUFF failed on buffer sizes! (%d vs %d)",
                 gi_pxrxDMA.DMAaddrEndL[0] - gi_pxrxDMA.DMAaddrL[0], gi_pxrxDMA.DMAaddrEndL[1] - gi_pxrxDMA.DMAaddrL[1]));
        DebugBreak();
    }

    // (start0 <= NTptr <= end0) || (start1 <= NTptr <= end1)
    if( ((gi_pxrxDMA.NTptr < gi_pxrxDMA.DMAaddrL[0]) || (gi_pxrxDMA.NTptr > gi_pxrxDMA.DMAaddrEndL[0])) &&
        ((gi_pxrxDMA.NTptr < gi_pxrxDMA.DMAaddrL[1]) || (gi_pxrxDMA.NTptr > gi_pxrxDMA.DMAaddrEndL[1])) ) {
        DISPDBG((-1000, "CHECK_BUFF failed for NTptr!"));
        DISPDBG((-1000, "    0x%08X: (0x%08X:0x%08X) or (0x%08X:0x%08X)", gi_pxrxDMA.NTptr,
                gi_pxrxDMA.DMAaddrL[0], gi_pxrxDMA.DMAaddrEndL[0],
                gi_pxrxDMA.DMAaddrL[1], gi_pxrxDMA.DMAaddrEndL[1]));
        DebugBreak();
    } else {
        // startCurrent <= NTptr <= endCurrent
        if( (gi_pxrxDMA.NTptr < gi_pxrxDMA.DMAaddrL[gi_pxrxDMA.NTbuff]) ||
            (gi_pxrxDMA.NTptr > gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff]) ) {
            DISPDBG((-1000, "CHECK_BUFF failed for NTptr II!"));
            DISPDBG((-1000, "    0x%08X <= 0x%08X <= 0x%08X",
                    gi_pxrxDMA.DMAaddrL[gi_pxrxDMA.NTbuff], gi_pxrxDMA.NTptr,
                    gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff]));
            DebugBreak();
        }
    }
    // (start0 <= P3ptr <= end0) || (start1 <= P3ptr <= end1)
    if( ((gi_pxrxDMA.P3at < gi_pxrxDMA.DMAaddrL[0]) && (gi_pxrxDMA.P3at > gi_pxrxDMA.DMAaddrEndL[0])) &&
        ((gi_pxrxDMA.P3at < gi_pxrxDMA.DMAaddrL[1]) && (gi_pxrxDMA.P3at > gi_pxrxDMA.DMAaddrEndL[1])) ) {
        DISPDBG((-1000, "CHECK_BUFF failed for P3at!"));
        DISPDBG((-1000, "    0x%08X: (0x%08X:0x%08X) or (0x%08X:0x%08X)", gi_pxrxDMA.P3at,
                gi_pxrxDMA.DMAaddrL[0], gi_pxrxDMA.DMAaddrEndL[0],
                gi_pxrxDMA.DMAaddrL[1], gi_pxrxDMA.DMAaddrEndL[1]));
        DebugBreak();
    }

    // P3at <= NTptr (if in the same buffer)
    if( (gi_pxrxDMA.P3at >= gi_pxrxDMA.DMAaddrL[gi_pxrxDMA.NTbuff]) && (gi_pxrxDMA.P3at <= gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff]) ) {
        if( gi_pxrxDMA.P3at > gi_pxrxDMA.NTptr ) {
            DISPDBG((-1000, "CHECK_BUFF failed for P3at vs NTptr! (0x%08X <= 0x%08X)", gi_pxrxDMA.P3at, gi_pxrxDMA.NTptr));
            DebugBreak();
        }
    }
    // NTptr <= NTwait 
    if( gi_pxrxDMA.NTptr > glintInfo->NTwait ) {
        DISPDBG((-1000, "CHECK_BUFF failed for NTptr vs NTwait! (0x%08X <= 0x%08X)", gi_pxrxDMA.NTptr, glintInfo->NTwait));
        DebugBreak();
    }

//@@BEGIN_DDKSPLIT
//AZN
// Here we have a FI AV when glintInfo->pxrxDMA_bufferBase != NULL but points
// to invalid memory!
//@@END_DDKSPLIT
    // Protection zone 0: should be filled with (addr & 0x0FFFFFF0)
    for( ptr = glintInfo->pxrxDMA_bufferBase; ptr < gi_pxrxDMA.DMAaddrL[0]; ptr++ ) {
        ASSERTDBG(*ptr == (((ULONG_PTR) ptr) & 0x0FFFFFF0), (-1000, 
                               "CHECK_BUFF failed on protection zone 0: 0x%08X vs 0x%08X!", 
                                ((ULONG_PTR) ptr) & 0x0FFFFFF0, *ptr));
        //if( ptr > glintInfo->pxrxDMA_bufferBase + 40 )        break;
    }

    // Protection zone 1: should be filled with (addr & 0x0FFFFFF0)
    for( ptr = gi_pxrxDMA.DMAaddrEndL[0]; ptr < gi_pxrxDMA.DMAaddrL[1]; ptr++ ) {
        ASSERTDBG(*ptr == (((ULONG_PTR) ptr) & 0x0FFFFFF0), (-1000, 
                                "CHECK_BUFF failed on protection zone 1: 0x%08X vs 0x%08X!", 
                                ((ULONG_PTR) ptr) & 0x0FFFFFF0, *ptr));
        //if( ptr > gi_pxrxDMA.DMAaddrEndL[0] + 40 )        break;
    }

    // Protection zone 2: should be filled with (addr & 0x0FFFFFF0)
    for( ptr = gi_pxrxDMA.DMAaddrEndL[1]; ptr < glintInfo->pxrxDMA_bufferTop; ptr++ ) {
        ASSERTDBG(*ptr == (((ULONG_PTR) ptr) & 0x0FFFFFF0), (-1000, 
                                "CHECK_BUFF failed on protection zone 2: 0x%08X vs 0x%08X!", 
                                ((ULONG_PTR) ptr) & 0x0FFFFFF0, *ptr));
        //if( ptr > gi_pxrxDMA.DMAaddrEndL[1] + 40 )        break;
    }

    switch( type ) {
        case CHECK_QUEUE:
            // Check that each dword contains 0x12345678:
            while( count-- ) {
                ptr = gi_pxrxDMA.NTptr + count;
                if( *ptr != 0x12345678 ) {
                    DISPDBG((-1000, "CHECK_QUEUE failed: 0x%08X vs 0x12345678 @ 0x%08X!", *ptr, ptr));
                    failure = TRUE;
                }
            }
        break;

        case CHECK_WAIT:
            // Check that each dword contains its address...
            // Then replace it with 0x12345678:

            while( count-- ) {
                ptr = gi_pxrxDMA.NTptr + count;
                if( (*ptr != (ULONG_PTR) ptr) && (*ptr != 0x12345678) ) {
                    DISPDBG((-1000, "CHECK_WAIT failed: 0x%08X vs 0x%08X @ 0x%08X!", 
                                    *ptr, (ULONG_PTR) ptr, ptr));
                    failure = TRUE;
                }
                *ptr = 0x12345678;
            }
        break;

        case CHECK_SEND:
            // Check that each dword contains neither its address nor 0x12345678:
            for( ptr = (ULONG *) gi_pxrxDMA.P3at; ptr < gi_pxrxDMA.NTptr; ptr++ ) {
                if( *ptr == (ULONG_PTR) ptr ) {
                    DISPDBG((-1000, "CHECK_SEND failed I: 0x%08X is 0x%08X!", ptr, *ptr));
                    failure = TRUE;
                }

                if( *ptr == 0x12345678 ) {
                    DISPDBG((-1000, "CHECK_SEND failed II: 0x%08X is 0x%08X!", ptr, *ptr));
                    failure = TRUE;
                }
            }

            for( ptr = gi_pxrxDMA.NTptr; ptr < gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff]; ptr++ ) {
                if( (*ptr != (ULONG_PTR) ptr) && (*ptr != 0x12345678) ) {
                    DISPDBG((-1000, "CHECK_SEND failed III: 0x%08X vs 0x%08X/0x12345678 @ 0x%08X!", *ptr, 
                                    (ULONG_PTR) ptr, ptr));
                    failure = TRUE;
                }

                if( ptr > (gi_pxrxDMA.NTptr + 4) )
                    break;
            }
        break;

        case CHECK_SWITCH:
            // Fill each dword with its address:
            for( ptr = gi_pxrxDMA.DMAaddrL[gi_pxrxDMA.NTbuff]; ptr < gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff]; ptr++ )
                *ptr = PtrToUlong(ptr);
        break;
    }

    if( failure ) {
        DISPDBG((-1000, "Check failed, count = %d", origCount));
        DebugBreak();
    }

}
#endif


/*******************************************************/
/*** Assorted versions of the SEND_PXRX_DMA 'macro'  ***/
/*** For use with the FAKE_DMA flag to test that DMA ***/
/*** will actually work on all combinations of P3,   ***/
/*** Gamma, & buggy motherboards!                    ***/
/*******************************************************/



/*******************/
/*** FIFO Access ***/
void sendPXRXdmaFIFO( PPDEV ppdev, GlintDataPtr glintInfo ) {
    LONG    count;
    ULONG   *NTptr = gi_pxrxDMA.NTptr;
    ULONG   *P3at = (ULONG *) gi_pxrxDMA.P3at;
    
    CHECK_PXRX_DMA_VALIDITY( CHECK_SEND, 0 );
    
    count = (DWORD)(NTptr - P3at);
    
    DISPDBG((DBGLVL, "SEND_PXRX_DMA:fifo() %d dwords @ %d:0x%08X -> 0x%08X", count, gi_pxrxDMA.NTbuff, P3at, NTptr));

    if( count > 0) {
        volatile ULONG  *dst;
        ULONG           *src, space;

        DISPDBG((DBGLVL, "Sending FIFO tags (0x%08X x %d)", P3at, count));

        src = P3at;
        while( count > 0 ) {
            GET_INPUT_FIFO_SPACE( space );

            // Don't exceed real FIFO size
            space = min (space, glintInfo->MaxInFifoEntries);

            dst = (ULONG *) glintInfo->regs.InFIFOInterface;
            while( space-- && count-- ) {
                MEMORY_BARRIER();
                WRITE_FAST_ULONG( dst, *src );
                MEMORY_BARRIER();
                dst++;
                src++;
            }
        }
    }
    GLINT_CORE_BUSY;

    gi_pxrxDMA.NTdone = NTptr;
    gi_pxrxDMA.P3at   = NTptr;
    DISPDBG((DBGLVL, "Sent PXRX DMA"));
}

void switchPXRXdmaBufferFIFO( PPDEV ppdev, GlintDataPtr glintInfo ) {
    TEMP_MACRO_VARS;

    DISPDBG((DBGLVL, "SWITCH_PXRX_DMA_BUFFER() from %d:0x%08X", gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr));    

    /* Close the old buffer and post it     */
    SEND_PXRX_DMA_FORCE;

    /* Switch to the new buffer             */
    gi_pxrxDMA.NTbuff = !gi_pxrxDMA.NTbuff;

    /* Ensure that the new buffer is empty  */
    //WAIT_PXRX_DMA_COMPLETED_BUFFER;    // Not needed when running through FIFOs.

    /* Start using the new buffer           */
    gi_pxrxDMA.NTptr  = gi_pxrxDMA.DMAaddrL[gi_pxrxDMA.NTbuff];
    gi_pxrxDMA.P3at   = gi_pxrxDMA.NTptr;
#if PXRX_DMA_BUFFER_CHECK
    glintInfo->NTwait = gi_pxrxDMA.NTptr;
#endif
    DISPDBG((DBGLVL, "SWITCH_PXRX_DMA_BUFFER() to %d:0x%08X", gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr));

    CHECK_PXRX_DMA_VALIDITY( CHECK_SWITCH, 0 );
}

void waitPXRXdmaCompletedBufferFIFO( PPDEV ppdev, GlintDataPtr glintInfo ) {
    ASSERTDD(FALSE,"waitPXRXdmaCompletedBufferFIFO was called!");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\pxrxstrp.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: pxrxstrp.c
*
* Content:
*
//@@BEGIN_DDKSPLIT
* All the line code in this driver amounts to a big bag of dirt.  Someday,
* I'm going to rewrite it all.  Not today, though (sigh)...
* Original comment!. Rewritten for GLINT. Styled lines could do with more
* work, but Solid lines should be about as optimal as possible without
* rewriting the algorithm that calls these functions.
//@@END_DDKSPLIT
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "pxrx.h"

/**************************************************************************\
*
* BOOL pxrxInitStrips
*
\**************************************************************************/
BOOL pxrxInitStrips( 
    PPDEV ppdev, 
    ULONG ulColor, 
    DWORD logicOp, 
    RECTL *prclClip ) 
{
    DWORD config2D;
    BOOL  bInvalidateScissor = FALSE;
    GLINT_DECL;

    VALIDATE_DD_CONTEXT;

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 7 );

    if( logicOp == __GLINT_LOGICOP_COPY ) 
    {
        config2D = __CONFIG2D_CONSTANTSRC | 
                   __CONFIG2D_FBWRITE;
    } 
    else 
    {
        config2D = __CONFIG2D_LOGOP_FORE(logicOp) | 
                   __CONFIG2D_CONSTANTSRC         | 
                   __CONFIG2D_FBWRITE;

        if( LogicopReadDest[logicOp] ) 
        {
            config2D |= __CONFIG2D_FBDESTREAD;
            SET_READ_BUFFERS;
        }
    }

    LOAD_FOREGROUNDCOLOUR( ulColor );

    if( prclClip ) 
    {
        config2D |= __CONFIG2D_USERSCISSOR;
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMinXY, 
                            MAKEDWORD_XY(prclClip->left,  prclClip->top   ) );
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY, 
                            MAKEDWORD_XY(prclClip->right, prclClip->bottom) );
        
        if(ppdev->cPelSize == GLINTDEPTH32)
        {
            bInvalidateScissor = TRUE;
        }
    }
    
    LOAD_CONFIG2D( config2D );

    SEND_PXRX_DMA_BATCH;

    glintInfo->savedConfig2D = config2D;
    glintInfo->savedLOP = logicOp;
    glintInfo->savedCol = ulColor;
    glintInfo->savedClip = prclClip;

    DISPDBG((DBGLVL, "pxrxInitStrips done"));
    return (bInvalidateScissor);
}

/**************************************************************************\
*
* VOID pxrxResetStrips
*
\**************************************************************************/
VOID pxrxResetStrips( 
    PPDEV ppdev ) 
{
    GLINT_DECL;

    DISPDBG((DBGLVL, "pxrxResetStrips called"));

    // Reset the scissor maximums:
    WAIT_PXRX_DMA_TAGS( 1 );
    QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY, 0x7FFF7FFF );
    SEND_PXRX_DMA_BATCH;
}

/**************************************************************************\
*
* VOID pxrxIntegerLine
*
\**************************************************************************/
BOOL pxrxIntegerLine( 
    PPDEV ppdev, 
    LONG  X1, 
    LONG  Y1, 
    LONG  X2, 
    LONG  Y2 ) 
{
    LONG    dx, dy, adx, ady;
    GLINT_DECL;

    // Convert points to INT format:
    X1 >>= 4;
    Y1 >>= 4;
    X2 >>= 4;
    Y2 >>= 4;

    if( (adx = dx = X2 - X1) < 0 )
    {
        adx = -adx;
    }

    if( (ady = dy = Y2 - Y1) < 0 )
    {
        ady = -ady;
    }

    WAIT_PXRX_DMA_TAGS( 3+2 );
    if( adx > ady ) 
    {
        // X major line:
        if( ady == dy ) 
        {
            // +ve minor delta
            if((ady)        && 
               (adx != ady) && 
               (adx > MAX_LENGTH_CONFORMANT_P3_INTEGER_LINES_P) ) 
            {
                DISPDBG((DBGLVL, "pxrxIntegerLine failed"));
                return FALSE;
            }

            DISPDBG((DBGLVL, "pxrxIntegerLine: [X +] delta = (%d, %d), "
                             "bias = (0x%08x)", 
                             dx, dy, P3_LINES_BIAS_P));
                             
            QUEUE_PXRX_DMA_TAG( __DeltaTagYBias, P3_LINES_BIAS_P );
        } 
        else 
        {
            // -ve minor delta
            if( (ady)        && 
                (adx != ady) && 
                (adx > MAX_LENGTH_CONFORMANT_P3_INTEGER_LINES_N) ) 
            {
                DISPDBG((DBGLVL, "pxrxIntegerLine failed"));
                return FALSE;
            }

            DISPDBG((DBGLVL, "pxrxIntegerLine: [X -] delta = (%d, %d), "
                             "bias = (0x%08x)", 
                             dx, dy, P3_LINES_BIAS_N));
                             
            QUEUE_PXRX_DMA_TAG( __DeltaTagYBias, P3_LINES_BIAS_N );
        }
    } 
    else 
    {
        // Y major line:
        if( adx == dx ) 
        {
            // +ve minor delta
            if( (adx)        && 
                (adx != ady) && 
                (ady > MAX_LENGTH_CONFORMANT_P3_INTEGER_LINES_P) ) 
            {
                DISPDBG((DBGLVL, "pxrxIntegerLine failed"));
                return FALSE;
            }

            DISPDBG((DBGLVL, "pxrxIntegerLine: [Y +] delta = (%d, %d), "
                             "bias = (0x%08x)", 
                             dx, dy, P3_LINES_BIAS_P));
                             
            QUEUE_PXRX_DMA_TAG( __DeltaTagXBias, P3_LINES_BIAS_P );
        } 
        else 
        {
            // -ve minor delta
            if( (adx)        && 
                (adx != ady) && 
                (ady > MAX_LENGTH_CONFORMANT_P3_INTEGER_LINES_N) ) 
            {
                DISPDBG((DBGLVL, "pxrxIntegerLine failed"));
                return FALSE;
            }

            DISPDBG((DBGLVL, "pxrxIntegerLine: [Y -] delta = (%d, %d), "
                             "bias = (0x%08x)", 
                             dx, dy, P3_LINES_BIAS_N));
                             
            QUEUE_PXRX_DMA_TAG( __DeltaTagXBias, P3_LINES_BIAS_N );
        }
    }

    QUEUE_PXRX_DMA_INDEX3( __DeltaTagLineCoord0, 
                           __DeltaTagLineCoord1, 
                           __DeltaTagDrawLine2D01 );
                           
    QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(X1, Y1) );
    QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(X2, Y2) );
    QUEUE_PXRX_DMA_DWORD( 0 );

    SEND_PXRX_DMA_BATCH;

    glintInfo->lastLine = 1;

    DISPDBG((DBGLVL, "pxrxIntegerLine done"));
    return TRUE;
}

/**************************************************************************\
*
* BOOL pxrxContinueLine
*
\**************************************************************************/
BOOL pxrxContinueLine( 
    PPDEV ppdev, 
    LONG  X1, 
    LONG  Y1, 
    LONG  X2, 
    LONG  Y2 ) 
{
    LONG    dx, dy, adx, ady;
    GLINT_DECL;

    // Convert points to INT format:
    X1 >>= 4;
    Y1 >>= 4;
    X2 >>= 4;
    Y2 >>= 4;

    if( (adx = dx = X2 - X1) < 0 )
    {
        adx = -adx;
    }

    if( (ady = dy = Y2 - Y1) < 0 )
    {
        ady = -ady;
    }

    WAIT_PXRX_DMA_TAGS( 3+2 );
    
    if( adx > ady ) 
    {
        // X major line:
        if( ady == dy ) 
        {
            // +ve minor delta
            if( (ady)        && 
                (adx != ady) && 
                (adx > MAX_LENGTH_CONFORMANT_P3_INTEGER_LINES_P) ) 
            {
                DISPDBG((DBGLVL, "pxrxContinueLine failed"));
                return FALSE;
            }

            DISPDBG((DBGLVL, "pxrxContinueLine: delta = (%d, %d), "
                             "bias = (0x%08x), last = %d", 
                             dx, dy, P3_LINES_BIAS_P, glintInfo->lastLine));
                             
            QUEUE_PXRX_DMA_TAG( __DeltaTagYBias, P3_LINES_BIAS_P );
        } 
        else 
        {
            // -ve minor delta
            if( (ady)        && 
                (adx != ady) && 
                (adx > MAX_LENGTH_CONFORMANT_P3_INTEGER_LINES_N) ) 
            {
                DISPDBG((DBGLVL, "pxrxContinueLine failed"));
                return FALSE;
            }

            DISPDBG((DBGLVL, "pxrxContinueLine: delta = (%d, %d), "
                             "bias = (0x%08x), last = %d", 
                             dx, dy, P3_LINES_BIAS_N, glintInfo->lastLine));
                             
            QUEUE_PXRX_DMA_TAG( __DeltaTagYBias, P3_LINES_BIAS_N );
        }
    } 
    else 
    {
        // Y major line:
        if( adx == dx ) 
        {
            // +ve minor delta
            if( (adx)        && 
                (adx != ady) && 
                (ady > MAX_LENGTH_CONFORMANT_P3_INTEGER_LINES_P) ) 
            {
                DISPDBG((DBGLVL, "pxrxContinueLine failed"));
                return FALSE;
            }

            DISPDBG((DBGLVL, "pxrxContinueLine: delta = (%d, %d), "
                             "bias = (0x%08x), last = %d", 
                             dx, dy, P3_LINES_BIAS_P, glintInfo->lastLine));
                             
            QUEUE_PXRX_DMA_TAG( __DeltaTagXBias, P3_LINES_BIAS_P );
        } 
        else 
        {
            // -ve minor delta
            if( (adx)        && 
                (adx != ady) && 
                (ady > MAX_LENGTH_CONFORMANT_P3_INTEGER_LINES_N) ) 
            {
                DISPDBG((DBGLVL, "pxrxContinueLine failed"));
                return FALSE;
            }

            DISPDBG((DBGLVL, "pxrxContinueLine: delta = (%d, %d), "
                             "bias = (0x%08x), last = %d", 
                             dx, dy, P3_LINES_BIAS_N, glintInfo->lastLine));
                             
            QUEUE_PXRX_DMA_TAG( __DeltaTagXBias, P3_LINES_BIAS_N );
        }
    }

    if( glintInfo->lastLine == 0 ) 
    {
        QUEUE_PXRX_DMA_INDEX2( __DeltaTagLineCoord1, 
                               __DeltaTagDrawLine2D01 );
        QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(X2, Y2) );
        QUEUE_PXRX_DMA_DWORD( 0 );
        glintInfo->lastLine = 1;
    } 
    else if( glintInfo->lastLine == 1 ) 
    {
        QUEUE_PXRX_DMA_INDEX2( __DeltaTagLineCoord0, 
                               __DeltaTagDrawLine2D10 );
        QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(X2, Y2) );
        QUEUE_PXRX_DMA_DWORD( 0 );
        glintInfo->lastLine = 0;
    }
    else
    {
        // lastline == 2
        QUEUE_PXRX_DMA_INDEX3( __DeltaTagLineCoord0, 
                               __DeltaTagLineCoord1, 
                               __DeltaTagDrawLine2D01 );
        QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(X1, Y1) );
        QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(X2, Y2) );
        QUEUE_PXRX_DMA_DWORD( 0 );

        glintInfo->lastLine = 1;
    }

    SEND_PXRX_DMA_BATCH;

    DISPDBG((DBGLVL, "pxrxContinueLine done"));
    return TRUE;
}


/******************************Public*Routine******************************\
* VOID vPXRXSolidHorizontalLine
*
* Draws left-to-right x-major near-horizontal lines using short-stroke
* vectors.  
*
\**************************************************************************/

VOID vPXRXSolidHorizontalLine( 
    PDEV      *ppdev, 
    STRIP     *pStrip, 
    LINESTATE *pLineState )
{
    LONG    cStrips;
    PLONG   pStrips;
    LONG    iCurrent;
    GLINT_DECL;

    cStrips = pStrip->cStrips;

    WAIT_PXRX_DMA_TAGS( 10 );

    QUEUE_PXRX_DMA_TAG( __GlintTagdXDom, 0 );
    QUEUE_PXRX_DMA_TAG( __GlintTagdXSub, 0 );

    // Set up the start point
    QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom, INTtoFIXED(pStrip->ptlStart.x) );
    QUEUE_PXRX_DMA_TAG( __GlintTagStartY,    INTtoFIXED(pStrip->ptlStart.y) );

    // Set up the deltas for rectangle drawing. Also set Y return value.
    if( !(pStrip->flFlips & FL_FLIP_V) ) 
    {
        QUEUE_PXRX_DMA_TAG( __GlintTagdY,       INTtoFIXED(1) );
        pStrip->ptlStart.y += cStrips;
    } 
    else 
    {
        QUEUE_PXRX_DMA_TAG( __GlintTagdY,       INTtoFIXED(-1) );
        pStrip->ptlStart.y -= cStrips;
    }

    pStrips = pStrip->alStrips;

    // We have to do first strip manually, as we have to use RENDER
    // for the first strip, and CONTINUENEW... for the following strips
    iCurrent = pStrip->ptlStart.x + *pStrips++; // Xsub, Start of next strip
    QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub, INTtoFIXED(iCurrent) );
    QUEUE_PXRX_DMA_TAG( __GlintTagCount,     1 );// Rectangle 1 scanline high
    QUEUE_PXRX_DMA_TAG( __GlintTagRender,    __RENDER_TRAPEZOID_PRIMITIVE );

    if( --cStrips ) 
    {
        while( cStrips > 1 ) 
        {
            // First strip of each pair to fill. XSub is valid. Need new Xdom
            iCurrent += *pStrips++;
            QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom, INTtoFIXED(iCurrent) );
            QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewDom, 1 );

            WAIT_PXRX_DMA_TAGS( 2 + 2 );

            // Second strip of each pair to fill. XDom is valid. Need new XSub
            iCurrent += *pStrips++;
            QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub, INTtoFIXED(iCurrent) );
            QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewSub, 1 );

            cStrips -=2;
        }

        // We may have one last line to draw. Xsub will be valid.
        if( cStrips ) 
        {
            iCurrent += *pStrips++;
            QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom, INTtoFIXED(iCurrent) );
            QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewDom, 1 );
        }
    }

    SEND_PXRX_DMA_BATCH;

    // Return last point. Y already calculated when we knew the direction.
    pStrip->ptlStart.x = iCurrent;
}

/******************************Public*Routine******************************\
* VOID vPXRXSolidVertical
*
* Draws left-to-right y-major near-vertical lines using short-stroke
* vectors.  
*
\**************************************************************************/

VOID vPXRXSolidVerticalLine( 
    PDEV      *ppdev, 
    STRIP     *pStrip, 
    LINESTATE *pLineState )
{
    LONG    cStrips, yDir;
    PLONG   pStrips;
    LONG    iCurrent, iLen, iLenSum;
    GLINT_DECL;

    cStrips = pStrip->cStrips;

    WAIT_PXRX_DMA_TAGS( 10 );

    QUEUE_PXRX_DMA_TAG( __GlintTagdXDom,        0 );
    QUEUE_PXRX_DMA_TAG( __GlintTagdXSub,        0 );

    // Set up the start point
    QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom, INTtoFIXED(pStrip->ptlStart.x) );
    QUEUE_PXRX_DMA_TAG( __GlintTagStartY,    INTtoFIXED(pStrip->ptlStart.y) );

    // Set up the deltas for rectangle drawing.
    if( !(pStrip->flFlips & FL_FLIP_V) )
    {
        yDir = 1;
    }
    else
    {
        yDir = -1;
    }
    
    QUEUE_PXRX_DMA_TAG( __GlintTagdY, INTtoFIXED(yDir) );

    pStrips = pStrip->alStrips;

    // We have to do first strip manually, as we have to use RENDER
    // for the first strip, and CONTINUENEW... for the following strips
    iCurrent = pStrip->ptlStart.x + 1;          // Xsub, Start of next strip
    iLenSum = (iLen = *pStrips++);
    
    QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub, INTtoFIXED(iCurrent) );
    QUEUE_PXRX_DMA_TAG( __GlintTagCount, iLen ); // Rectangle 1 scanline high
    QUEUE_PXRX_DMA_TAG( __GlintTagRender, __RENDER_TRAPEZOID_PRIMITIVE );

    if( --cStrips ) 
    {
        while( cStrips > 1 ) 
        {
            // First strip of each pair to fill. XSub is valid. Need new Xdom
            iCurrent++;
            iLenSum += (iLen = *pStrips++);
            QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom, INTtoFIXED(iCurrent) );
            QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewDom, iLen );

            WAIT_PXRX_DMA_TAGS( 2 + 2 );

            // Second strip of each pair to fill. XDom is valid. Need new XSub
            iCurrent++;
            iLenSum += (iLen = *pStrips++);
            QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub, INTtoFIXED(iCurrent) );
            QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewSub, iLen );      
            cStrips -=2;
        }

        // We may have one last line to draw. Xsub will be valid.
        if( cStrips ) 
        {
            iCurrent++;
            iLenSum += (iLen = *pStrips++);
            QUEUE_PXRX_DMA_TAG(__GlintTagStartXDom, INTtoFIXED(iCurrent));
            QUEUE_PXRX_DMA_TAG(__GlintTagContinueNewDom, iLen);
        }
    }

    SEND_PXRX_DMA_BATCH;

    // Return last point. 
    pStrip->ptlStart.x = iCurrent;
    pStrip->ptlStart.y += iLenSum * yDir;
}

/******************************Public*Routine******************************\
* VOID vPXRXSolidDiagonalVertical
*
* Draws left-to-right y-major near-diagonal lines using short-stroke
* vectors.  
*
\**************************************************************************/

VOID vPXRXSolidDiagonalVerticalLine( 
    PDEV      *ppdev, 
    STRIP     *pStrip, 
    LINESTATE *pLineState )
{
    LONG    cStrips, yDir;
    PLONG   pStrips;
    LONG    iCurrent, iLen, iLenSum;
    GLINT_DECL;

    cStrips = pStrip->cStrips;

    if( !(pStrip->flFlips & FL_FLIP_V) )
    {
        yDir = 1;
    }
    else
    {
        yDir = -1;
    }

    WAIT_PXRX_DMA_TAGS( 10 );

    // Set up the deltas for rectangle drawing.
    QUEUE_PXRX_DMA_TAG( __GlintTagdXDom,        INTtoFIXED(1) );
    QUEUE_PXRX_DMA_TAG( __GlintTagdXSub,        INTtoFIXED(1) );
    QUEUE_PXRX_DMA_TAG( __GlintTagdY,           INTtoFIXED(yDir) );

    pStrips = pStrip->alStrips;

    // We have to do first strip manually, as we have to use RENDER
    // for the first strip, and CONTINUENEW... for the following strips
    QUEUE_PXRX_DMA_TAG( __GlintTagStartY,    INTtoFIXED(pStrip->ptlStart.y) );
    QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom, INTtoFIXED(pStrip->ptlStart.x+1) );
    QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub, INTtoFIXED(pStrip->ptlStart.x) );

    iLenSum = (iLen = *pStrips++);
    iCurrent = pStrip->ptlStart.x + iLen - 1;       // Start of next strip

    QUEUE_PXRX_DMA_TAG( __GlintTagCount, iLen);     // Trap iLen scanline high
    QUEUE_PXRX_DMA_TAG( __GlintTagRender, __RENDER_TRAPEZOID_PRIMITIVE);

    if( --cStrips ) 
    {
        while( cStrips > 1 ) 
        {
            // First strip of each pair to fill. XSub is valid. Need new Xdom
            QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom, INTtoFIXED(iCurrent) );
            iLenSum += (iLen = *pStrips++);
            iCurrent += iLen - 1;
            QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewDom, iLen );

            WAIT_PXRX_DMA_TAGS( 2 + 2 );

            // Second strip of each pair to fill. XDom is valid. Need new XSub
            QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub, INTtoFIXED(iCurrent) );
            iLenSum += (iLen = *pStrips++);
            iCurrent += iLen - 1;
            QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewSub, iLen );      

            cStrips -=2;
        }

        // We may have one last line to draw. Xsub will be valid.
        if (cStrips) 
        {
            QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom, INTtoFIXED(iCurrent) );
            iLenSum += (iLen = *pStrips++);
            iCurrent += iLen - 1;
            QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewDom, iLen );
        }
    }

    SEND_PXRX_DMA_BATCH;

    // Return last point. 
    pStrip->ptlStart.x = iCurrent;
    pStrip->ptlStart.y += iLenSum * yDir;
}

/******************************Public*Routine******************************\
* VOID vPXRXSolidDiagonalHorizontalLine
*
* Draws left-to-right x-major near-diagonal lines using short-stroke
* vectors.  
*
\**************************************************************************/

VOID vPXRXSolidDiagonalHorizontalLine( 
    PDEV      *ppdev, 
    STRIP     *pStrip, 
    LINESTATE *pLineState )
{
    LONG    cStrips, yDir, xCurrent, yCurrent, iLen;
    PLONG   pStrips;
    GLINT_DECL;

    // This routine has to be implemented in a different way to the other 3
    // solid line drawing functions because the rasterizer unit will not 
    // produce 2 pixels on the same scanline without a lot of effort in 
    // producing delta values. In this case, we have to draw a complete new
    // primitive for each strip. Therefore, we have to use lines rather than
    // trapezoids to generate the required strips. With lines we use 4 messages
    // per strip, where trapezoids would use 5.

    cStrips = pStrip->cStrips;

    if( !(pStrip->flFlips & FL_FLIP_V) )
    {
        yDir = 1;
    }
    else
    {
        yDir = -1;
    }

    pStrips = pStrip->alStrips;

    xCurrent = pStrip->ptlStart.x;
    yCurrent = pStrip->ptlStart.y;

    WAIT_PXRX_DMA_TAGS( 3 + 4 );

    // Set up the deltas for rectangle drawing.
    QUEUE_PXRX_DMA_TAG( __GlintTagdXDom,    INTtoFIXED(1) );
    QUEUE_PXRX_DMA_TAG( __GlintTagdXSub,    INTtoFIXED(1) );
    QUEUE_PXRX_DMA_TAG( __GlintTagdY,       INTtoFIXED(yDir) );

    while( TRUE ) 
    {
        // Set up the start point
        QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom,    INTtoFIXED(xCurrent) );
        QUEUE_PXRX_DMA_TAG( __GlintTagStartY,       INTtoFIXED(yCurrent) );

        iLen = *pStrips++;
        QUEUE_PXRX_DMA_TAG( __GlintTagCount, iLen );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender, __RENDER_LINE_PRIMITIVE );

        xCurrent += iLen;
        if( yDir > 0 ) 
        {
            yCurrent += iLen - 1;
        }
        else
        {
            yCurrent -= iLen - 1;
        }

        if( !(--cStrips) )
        {
            break;
        }

        WAIT_PXRX_DMA_TAGS( 4 );
    }

    SEND_PXRX_DMA_BATCH;

    // Return last point. 
    pStrip->ptlStart.x = xCurrent;
    pStrip->ptlStart.y = yCurrent;
}


/******************************Public*Routine******************************\
* VOID vPXRXStyledHorizontal
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles x-major lines that run left-to-right,
* and are comprised of horizontal strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vPXRXStyledHorizontalLine( 
    PDEV      *ppdev, 
    STRIP     *pstrip, 
    LINESTATE *pls )
{
    LONG    x;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;
    GLINT_DECL;

//@@BEGIN_DDKSPLIT
    // This routine does some quite complex things with patterns. For ease of
    // implementation on GLINT, I have just changed the relevant parts. This,
    // therefore, is definitly not an optimal solution. However, styled lines
    // are really not that important. If anyone feels inclined to do more work
    // here, then fine! XXXX
//@@END_DDKSPLIT    

    if( pstrip->flFlips & FL_FLIP_V )
    {
        dy  = -1;
    }
    else
    {
        dy  = 1;
    }

    cStrips = pstrip->cStrips;        // Total number of strips we'll do
    plStrip = pstrip->alStrips;        // Points to current strip
    x       = pstrip->ptlStart.x;    // x position of start of first strip
    y       = pstrip->ptlStart.y;    // y position of start of first strip

    // Set up the deltas for horizontal line drawing.
    WAIT_PXRX_DMA_TAGS( 2 );
    QUEUE_PXRX_DMA_TAG( __GlintTagdXDom,    INTtoFIXED(1) );
    QUEUE_PXRX_DMA_TAG( __GlintTagdY,       0 );

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if( bIsGap )
    {
        goto SkipAGap;
    }
    else
    {
        goto OutputADash;
    }

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
    {
        pls->psp = pls->pspStart;
    }

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
    {
        goto SkipAGap;
    }

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
        {
            goto AllDone;
        }

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;

        if (cStyle == 0)
        {
            goto PrepareToOutputADash;
        }
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
    {
        pls->psp = pls->pspStart;
    }

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip, so set 'y'
        // to be the current scan:

        goto OutputADash;
    }

    while( TRUE ) 
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if( cStrips == 0 )
        {
            goto AllDone;
        }

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        // With glint we just download the lines to draw

        WAIT_PXRX_DMA_TAGS( 4 );

        QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom,    INTtoFIXED(x) );
        QUEUE_PXRX_DMA_TAG( __GlintTagStartY,       INTtoFIXED(y) );
        QUEUE_PXRX_DMA_TAG( __GlintTagCount,        cThis );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender,       __GLINT_LINE_PRIMITIVE );

        x += cThis;

        if( cStyle == 0 )
        {
            goto PrepareToSkipAGap;
        }
    }

AllDone:

    SEND_PXRX_DMA_BATCH;

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vPXRXStyledVertical
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles y-major lines that run left-to-right,
* and are comprised of vertical strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vPXRXStyledVerticalLine( 
    PDEV      *ppdev, 
    STRIP     *pstrip, 
    LINESTATE *pls )
{
    LONG    x;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;
    GLINT_DECL;

//@@BEGIN_DDKSPLIT
    // This routine does some quite complex things with patterns. For ease of
    // implemantation on GLINT, I have just changed the relevant parts. This,
    // therefore, is definitly not an optimal solution. However, styled lines
    // are really not that important. If anyone feels inclined to do more work
    // here, then fine! XXXX
//@@END_DDKSPLIT

    if( pstrip->flFlips & FL_FLIP_V )
    {
        dy = -1;
    }
    else
    {
        dy = 1;
    }

    cStrips = pstrip->cStrips;        // Total number of strips we'll do
    plStrip = pstrip->alStrips;        // Points to current strip
    x       = pstrip->ptlStart.x;    // x position of start of first strip
    y       = pstrip->ptlStart.y;    // y position of start of first strip

    // Set up the deltas for vertical line drawing.
    WAIT_PXRX_DMA_TAGS( 2 );
    QUEUE_PXRX_DMA_TAG( __GlintTagdXDom,    0 );
    QUEUE_PXRX_DMA_TAG( __GlintTagdY,       INTtoFIXED(dy) );

    // dxDom and dXSub are initialised to 0, 0, so 
    // we don't need  to re-load them here.

    cStrip = *plStrip;                // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
    {
        goto SkipAGap;
    }
    else
    {
        goto OutputADash;
    }

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
    {
        pls->psp = pls->pspStart;
    }

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
    {
        goto SkipAGap;
    }

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
        {
            goto AllDone;
        }

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        y += (dy > 0) ? cThis : -cThis;

        if (cStyle == 0)
        {
            goto PrepareToOutputADash;
        }
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
    {
        pls->psp = pls->pspStart;
    }

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        goto OutputADash;
    }

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
        {
            goto AllDone;
        }

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        // With glint we just download the lines to draw

        WAIT_PXRX_DMA_TAGS( 4 );

        QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom,    INTtoFIXED(x) );
        QUEUE_PXRX_DMA_TAG( __GlintTagStartY,       INTtoFIXED(y) );
        QUEUE_PXRX_DMA_TAG( __GlintTagCount,        cThis );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender,       __GLINT_LINE_PRIMITIVE );

        y += (dy > 0) ? cThis : -cThis;

        if( cStyle == 0 )
        {
            goto PrepareToSkipAGap;
        }
    }

AllDone:

    SEND_PXRX_DMA_BATCH;

    // Update our state variables so that the next line can continue
    // where we left off:
    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}

/**************************************************************************\
 * For a given sub-pixel coordinate (x.m, y.n) in 28.4 fixed point
 * format this array is indexed by (m,n) and indicates whether the
 * given sub-pixel is within a GIQ diamond. m coordinates run left
 * to right; n coordinates ru top to bottom so index the array with
 * ((n<<4)+m). The array as seen here really contains 4 quarter
 * diamonds.
\**************************************************************************/
static unsigned char    in_diamond[] = {
/*          0 1 2 3 4 5 6 7 8 9 a b c d e f          */

/* 0 */     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,    /* 0 */
/* 1 */     1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,    /* 1 */
/* 2 */     1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,    /* 2 */
/* 3 */     1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,    /* 3 */
/* 4 */     1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,    /* 4 */
/* 5 */     1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,    /* 5 */
/* 6 */     1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,    /* 6 */
/* 7 */     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,    /* 7 */
/* 8 */     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,    /* 8 */
/* 9 */     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,    /* 9 */
/* a */     1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,    /* a */
/* b */     1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,    /* b */
/* c */     1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,    /* c */
/* d */     1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,    /* d */
/* e */     1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,    /* e */
/* f */     1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,    /* f */

/*          0 1 2 3 4 5 6 7 8 9 a b c d e f          */
};
/*
 * For lines with abs(slope) != 1 use IN_DIAMOND to determine if an
 * end point is in a diamond. For lines of slope = 1 use IN_S1DIAMOND.
 * For lines of slope = -1 use IN_SM1DIAMOND. The last two are a bit
 * strange. The documentation leaves us with a problem for slope 1
 * lines which run exactly betwen the diamonds. According to the docs
 * such a line can enter a diamond, leave it and enter again. This is
 * plainly rubbish so along the appropriate edge of the diamond we
 * consider a slope 1 line to be inside the diamond. This is the
 * bottom right edge for lines of slope -1 and the bottom left edge for
 * lines of slope 1.
 */
#define IN_DIAMOND(m, n)    (in_diamond[((m) << 4) + (n)])
#define IN_S1DIAMOND(m, n)  ((in_diamond[((m) << 4) + (n)]) || \
                        ((m) - (n) == 8))
#define IN_SM1DIAMOND(m, n) ((in_diamond[((m) << 4) + (n)]) || \
                        ((m) + (n) == 8))

/**************************************************************************\
*
* BOOL pxrxDrawLine
*
\**************************************************************************/

BOOL pxrxDrawLine( 
    PPDEV ppdev, 
    LONG  fx1, 
    LONG  fy1, 
    LONG  fx2, 
    LONG  fy2 ) 
{
    register LONG   adx, ady, tmp;
    FIX     m1, n1, m2, n2;
    LONG    dx, dy;
    LONG    dX, dY;
    LONG    count, startX, startY;
    GLINT_DECL;

    // This function is only called if we have a line with non integer end 
    // points and the unsigned coordinates are no greater than 15.4. 
    //
    // We can only guarantee to do lines whose coords need <= 12 bits
    // of integer. This is because to get the delta we must shift
    // by 16 bits. This includes 4 bits of fraction which means if
    // we have more than 12 bits of integer we get overrun on the
    // shift. We could use floating point to give us a better 16
    // bits of integer but this requires an extra set of multiplies
    // and divides in order to convert from 28.4 to fp. In any case
    // we have to have a test to reject coords needing > 16 bits
    // of integer.
    // Actually, we can deal with 16.4 coordinates provided dx and dy
    // never require more than 12 bits of integer.
    // So optimise for the common case where the line is completely
    // on the screen (actually 0 to 2047.f). Since the coords have
    // 4 bits of fraction we note that a 32 bit signed number
    // outside the range 0 to 2047.f will have one of its top 17
    // bits set. So logical or all the coords and test against
    // 0xffff8000. This is about as quick a test as we can get for
    // both ends of the line being on the screen. If this test fails
    // then we can check everything else at a leisurely pace.

    // get signed and absolute deltas 
    if ((adx = dx = fx2 - fx1) < 0)
    {
        adx = -adx;
    }
    
    if ((ady = dy = fy2 - fy1) < 0)
    {
        ady = -ady;
    }

    // Refuse to draw any lines whose delta is out of range.
    // We have to shift the delta by 16, so we dont want to loose any
    // precision. 
    if ((adx | ady) & 0xffff8000)
    {
        return(FALSE);
    }

    // fractional bits are used to check if point is in a diamond
    m1 = fx1 & 0xf;
    n1 = fy1 & 0xf;
    m2 = fx2 & 0xf;
    n2 = fy2 & 0xf;


    // The rest of the code is a series of cases. Each one is "called" by a
    // goto. This is simply to keep the nesting down. Main cases are: lines
    // with absolute slope == 1; x-major lines; and y-major lines. We draw
    // lines as they are given rather than always drawing in one direction.
    // This adds extra code but saves the time required to swap the points
    // and adjust for not drawing the end point.

    startX = fx1 << 12;
    startY = fy1 << 12;

    DISPDBG((DBGLVL, "GDI Line %x, %x  deltas %x, %x", 
                     startX, startY, dx, dy));

    if (adx < ady)
    {
        goto y_major;
    }

    if (adx > ady)
    {
        goto x_major;
    }


//slope1_line:

    // All slope 1 lines are sampled in X. i.e. we move the start coord to
    // an integer x and let GLINT truncate in y. This is because all GIQ
    // lines are rounded down in y for values exactly half way between two
    // pixels. If we sampled in y then we would have to round up in x for
    // lines of slope 1 and round down in x for other lines. Sampling in x
    // allows us to use the same GLINT bias in all cases (0x7fff). We do
    // the x round up or down when we move the start point.
 
    if (dx != dy)
    {
        goto slope_minus_1;
    }
    
    if (dx < 0)
    {
        goto slope1_reverse;
    }

    dX = 1 << 16;
    dY = 1 << 16;

    if (IN_S1DIAMOND(m1, n1))
    {
        tmp = (startX + 0x8000) & ~0xffff;
    }
    else
    {
        tmp = (startX + 0xffff) & ~0xffff;
    }
    
    startY += tmp - startX;
    startX = tmp;
    
    if (IN_S1DIAMOND(m2, n2))
    {
        fx2 = (fx2 + 0x8) & ~0xf;   // nearest integer 
    }
    else
    {
        fx2 = (fx2 + 0xf) & ~0xf;   // next integer 
    }
    
    count = (fx2 >> 4) - (startX >> 16);

    goto Draw_Line;

slope1_reverse:
    dX = -1 << 16;
    dY = -1 << 16;
    
    if (IN_S1DIAMOND(m1, n1))
    {
        tmp = (startX + 0x8000) & ~0xffff;
    }
    else
    {
        tmp = startX & ~0xffff;
    }
    
    startY += tmp - startX;
    startX = tmp;
    
    if (IN_S1DIAMOND(m2, n2))
    {
        fx2 = (fx2 + 0x8) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 &= ~0xf;            // previous integer 
    }
    
    count = (startX >> 16) - (fx2 >> 4);

    goto Draw_Line;

slope_minus_1:
    if (dx < 0)
    {
        goto slope_minus_dx;
    }

    // dx > 0, dy < 0 
    
    dX = 1 << 16;
    dY = -1 << 16;
    
    if (IN_SM1DIAMOND(m1, n1))
    {
        tmp = (startX + 0x7fff) & ~0xffff;
    }
    else
    {
        tmp = (startX + 0xffff) & ~0xffff;
    }
    
    startY += startX - tmp;
    startX = tmp;
    
    if (IN_SM1DIAMOND(m2, n2))
    {
        fx2 = (fx2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 = (fx2 + 0xf) & ~0xf;   // next integer
    }
    
    count = (fx2 >> 4) - (startX >> 16);

    goto Draw_Line;

slope_minus_dx:

    dX = -1 << 16;
    dY = 1 << 16;
    
    if (IN_SM1DIAMOND(m1, n1))
    {
        tmp = (startX + 0x7fff) & ~0xffff;
    }
    else
    {
        tmp = startX & ~0xffff;
    }
    
    startY += startX - tmp;
    startX = tmp;
    
    if (IN_SM1DIAMOND(m2, n2))
    {
        fx2 = (fx2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 &= ~0xf;            // previous integer
    }
        
    count = (startX >> 16) - (fx2 >> 4);

    goto Draw_Line;

x_major:
    // Dont necessarily render through glint if we are worried
    // about conformance.
    if ((adx > (MAX_LENGTH_CONFORMANT_NONINTEGER_LINES << 4)) &&
        (glintInfo->flags & GLICAP_NT_CONFORMANT_LINES)      &&
        (ady != 0))
    {
        return(FALSE);
    }

    if (dx < 0)
    {
        goto right_to_left_x;
    }

// left_to_right_x:

     // line goes left to right. Round up the start x to an integer
     // coordinate. This is the coord of the first diamond that the
     // line crosses. Adjust start y to match this point on the line.

    dX = 1 << 16;
    
    if (IN_DIAMOND(m1, n1))
    {
        tmp = (startX + 0x7fff) & ~0xffff;  // nearest integer
    }
    else
    {
        tmp = (startX + 0xffff) & ~0xffff;  // next integer
    }

    // we can optimise for horizontal lines
    if (dy != 0) 
    {
        dY = dy << 16;

        // Need to explicitly round delta down for -ve deltas.
        if (dy < 0)
        {
            dY -= adx - 1;
        }
    
        dY /= adx;
        startY += (((tmp - startX) >> 12) * dY) >> 4;
    }
    else
    {
        dY = 0;
    }
    
    startX = tmp;

    if (IN_DIAMOND(m2, n2))
    {
        fx2 = (fx2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 = (fx2 + 0xf) & ~0xf;   // next integer
    }
    
    count = (fx2 >> 4) - (startX >> 16);

    goto Draw_Line;

right_to_left_x:

    dX = -1 << 16;
    
    if (IN_DIAMOND(m1, n1))
    {
        tmp = (startX + 0x7fff) & ~0xffff;  // nearest integer
    }
    else
    {
        tmp = startX & ~0xffff;         // previous integer
    }

    // we can optimise for horizontal lines 
    if (dy != 0) 
    {
        dY = dy << 16;

        // Need to explicitly round delta down for -ve deltas.
        if (dy < 0)
        {
            dY -= adx - 1;
        }
    
        dY /= adx;
        startY += (((startX - tmp) >> 12) * dY) >> 4;
    }
    else
    {
        dY = 0;
    }
    
    startX = tmp;

    if (IN_DIAMOND(m2, n2))
    {
        fx2 = (fx2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 &= ~0xf;               // previous integer
    }
    
    count = (startX >> 16) - (fx2 >> 4);

    goto Draw_Line;

y_major:
    // Dont necessarily render through glint if we are worried
    // about conformance.
    if ((ady > (MAX_LENGTH_CONFORMANT_NONINTEGER_LINES << 4)) &&
        (glintInfo->flags & GLICAP_NT_CONFORMANT_LINES)       &&
        (adx != 0))
    {
        return(FALSE);
    }

    if (dy < 0)
    {
        goto high_to_low_y;
    }

// low_to_high_y:

    dY = 1 << 16;
    
    if (IN_DIAMOND(m1, n1))
    {
        tmp = (startY + 0x7fff) & ~0xffff;  // nearest integer
    }
    else
    {
        tmp = (startY + 0xffff) & ~0xffff;  // next integer
    }

    // we can optimise for vertical lines
    if (dx != 0) 
    {
        dX = dx << 16;

        // Need to explicitly round delta down for -ve deltas.
        if (dx < 0)
        {
            dX -= ady - 1;
        }
    
        dX /= ady;
        startX += (((tmp - startY) >> 12) * dX) >> 4;
    }
    else
    {
        dX = 0;
    }
    
    startY = tmp;

    if (IN_DIAMOND(m2, n2))
    {
        fy2 = (fy2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fy2 = (fy2 + 0xf) & ~0xf;   // next integer
    }
    
    count = (fy2 >> 4) - (startY >> 16);

    goto Draw_Line;

high_to_low_y:

    dY = -1 << 16;
    
    if (IN_DIAMOND(m1, n1))
    {
        tmp = (startY + 0x7fff) & ~0xffff;  // nearest integer
    }
    else
    {
        tmp = startY & ~0xffff;         // previous integer
    }

    // we can optimise for horizontal lines
    if (dx != 0) 
    {
        dX = dx << 16;

        // Need to explicitly round delta down for -ve deltas.
        if (dx < 0)
        {
            dX -= ady - 1;
        }
    
        dX /= ady;
        startX += (((startY - tmp) >> 12) * dX) >> 4;
    }
    else
    {
        dX = 0;
    }
    
    startY = tmp;

    if (IN_DIAMOND(m2, n2))
    {
        fy2 = (fy2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fy2 &= ~0xf;            // previous integer
    }
    
    count = (startY >> 16) - (fy2 >> 4);

Draw_Line:
    WAIT_PXRX_DMA_TAGS( 6 );

    QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom,    startX + 0x7fff );
    QUEUE_PXRX_DMA_TAG( __GlintTagStartY,       startY + 0x7fff );
    QUEUE_PXRX_DMA_TAG( __GlintTagdXDom,        dX );
    QUEUE_PXRX_DMA_TAG( __GlintTagdY,           dY );
    QUEUE_PXRX_DMA_TAG( __GlintTagCount,        count );
    QUEUE_PXRX_DMA_TAG( __GlintTagRender,       __RENDER_LINE_PRIMITIVE );

    SEND_PXRX_DMA_BATCH;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\pxrxpoly.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: pxrxPoly.c
*
* Content: Draws polygons.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#define DBG_TRACK_CODE 0

#include "precomp.h"
#include "pxrx.h"

#define DO_SPANONLY_VERSION 0
#define RIGHT 0
#define LEFT  1
#define ABS(a)    ((a) < 0 ? -(a) : (a))

typedef struct _EDGEDATA {
LONG      x;                // Current x position
LONG      dx;               // # pixels to advance x on each scan
LONG      lError;           // Current DDA error
LONG      lErrorUp;         // DDA error increment on each scan
LONG      lErrorDown;       // DDA error adjustment
POINTFIX* pptfx;            // Points to start of current edge
LONG      dptfx;            // Delta (in bytes) from pptfx to next point
LONG      cy;               // Number of scans to go for this edge
} EDGEDATA;                        

#define GetMoreFifoEntries( numberNeeded )              \
    do {                                                \
        nSpaces -= numberNeeded;                        \
        if( nSpaces <= 0 ) {                            \
            do {                                        \
                nSpaces = 10 + numberNeeded;            \
                WAIT_FREE_PXRX_DMA_TAGS( nSpaces );     \
                nSpaces -= numberNeeded;                \
            } while( nSpaces <= 0 );                    \
        }                                               \
    } while(0)


/*
#define SETUP_COLOUR_STUFF      do { setupColourStuff(ppdev, glintInfo,                                        \
                                                      &fgColor, &fgLogicOp,                                    \
                                                      &bgColor, &bgLogicOp,                                    \
                                                      prb, pptlBrush,                                        \
                                                      &config2D, &renderMsg, &invalidatedFGBG); } while(0)

static void setupColourStuff( PDEV *ppdev, GlintDataRec *glintInfo,
                              ULONG *fgColor_In, ULONG *fgLogicOp_In,
                              ULONG *bgColor_In, ULONG *bgLogicOp_In,
                              RBRUSH *prb, POINTL *pptlBrush,
                              ULONG *config2D_In, ULONG *renderMsg_In, ULONG *invalidatedFGBG_In ) {
    ULONG   fgColor = *fgColor_In, fgLogicOp = *fgLogicOp_In;
    ULONG   bgColor = *bgColor_In, bgLogicOp = *bgLogicOp_In;
    ULONG   config2D = *config2D_In, renderMsg = *renderMsg_In;
    ULONG   invalidatedFGBG = *invalidatedFGBG_In;
    TEMP_MACRO_VARS;
*/

#define SETUP_COLOUR_STUFF                                                                                  \
    do {                                                                                                    \
        SET_WRITE_BUFFERS;                                                                                    \
                                                                                                            \
        if( fgColor != 0xFFFFFFFF ) {                                                                        \
            WAIT_PXRX_DMA_TAGS( 4 );                                                                        \
            /* Solid colour filled polygon */                                                                \
            if( (fgLogicOp == __GLINT_LOGICOP_COPY) &&                                                        \
                (ppdev->cPelSize != GLINTDEPTH8) && (ppdev->cPelSize != GLINTDEPTH32) ) {                    \
                config2D |= __CONFIG2D_CONSTANTSRC;                                                            \
            } else {                                                                                        \
                config2D |= __CONFIG2D_LOGOP_FORE(fgLogicOp) | __CONFIG2D_CONSTANTSRC;                        \
                renderMsg |= __RENDER_VARIABLE_SPANS;                                                        \
                                                                                                            \
                if( LogicopReadDest[fgLogicOp] ) {                                                            \
                    config2D |= __CONFIG2D_FBDESTREAD;                                                        \
                    SET_READ_BUFFERS;                                                                        \
                }                                                                                            \
            }                                                                                                \
                                                                                                            \
            if( LogicOpReadSrc[fgLogicOp] )                                                                    \
                LOAD_FOREGROUNDCOLOUR( fgColor );                                                            \
                                                                                                            \
            DISPDBG((DBGLVL, "bGlintFastFillPolygon: solid fill, col = 0x%08x, logicOp = %d", fgColor, fgLogicOp));    \
        } else {                                                                                            \
            /* Brush filled polygon */                                                                        \
            BRUSHENTRY *pbe;                                                                                \
                                                                                                            \
            pbe = prb->apbe;                                                                    \
                                                                                                            \
            if( prb->fl & RBRUSH_2COLOR ) {                                                                    \
                /* Monochrome brush */                                                                        \
                config2D |= __CONFIG2D_CONSTANTSRC;                                                            \
                renderMsg |= __RENDER_AREA_STIPPLE_ENABLE;                                                    \
                                                                                                            \
                /* if anything has changed with the brush we must re-realize it. If the brush */            \
                /* has been kicked out of the area stipple unit we must fully realize it. If  */            \
                /* only the alignment has changed we can simply update the alignment for the  */            \
                /* stipple.                                                                      */            \
                if( (pbe == NULL) || (pbe->prbVerify != prb) ) {                                            \
                    DISPDBG((DBGLVL, "full brush realise"));                                                        \
                    (*ppdev->pgfnPatRealize)(ppdev, prb, pptlBrush);                                        \
                } else if( (prb->ptlBrushOrg.x != pptlBrush->x) ||                            \
                         (prb->ptlBrushOrg.y != pptlBrush->y) ) {                            \
                    DISPDBG((DBGLVL, "changing brush offset"));                                                    \
                    (*ppdev->pgfnMonoOffset)(ppdev, prb, pptlBrush);                                        \
                }                                                                                            \
                                                                                                            \
                fgColor = prb->ulForeColor;                                                                    \
                bgColor = prb->ulBackColor;                                                                    \
                                                                                                            \
                if( ((bgLogicOp == __GLINT_LOGICOP_AND) && (bgColor == ppdev->ulWhite))                        \
                    || ((bgLogicOp == __GLINT_LOGICOP_OR ) && (bgColor == 0))                                \
                    || ((bgLogicOp == __GLINT_LOGICOP_XOR) && (bgColor == 0)) )                                \
                        bgLogicOp = __GLINT_LOGICOP_NOOP;                                                    \
                                                                                                            \
                if( ((fgLogicOp != __GLINT_LOGICOP_COPY) || (bgLogicOp != __GLINT_LOGICOP_NOOP)) ||            \
                    (ppdev->cPelSize == GLINTDEPTH32) || (ppdev->cPelSize == GLINTDEPTH8) ) {                \
                    config2D |= __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(fgLogicOp) | __CONFIG2D_LOGOP_BACK(bgLogicOp);        \
                    renderMsg |= __RENDER_VARIABLE_SPANS;                                                    \
                }                                                                                            \
                                                                                                            \
                WAIT_PXRX_DMA_TAGS( 5 );                                                                    \
                                                                                                            \
                if( LogicopReadDest[fgLogicOp] || LogicopReadDest[bgLogicOp] ) {                            \
                    config2D |= __CONFIG2D_FBDESTREAD;                                                        \
                    SET_READ_BUFFERS;                                                                        \
                }                                                                                            \
                                                                                                            \
                if( LogicOpReadSrc[fgLogicOp] )                                                                \
                    LOAD_FOREGROUNDCOLOUR( fgColor );                                                        \
                if( LogicOpReadSrc[bgLogicOp] )                                                                \
                    LOAD_BACKGROUNDCOLOUR( bgColor );                                                        \
                                                                                                            \
                DISPDBG((DBGLVL, "bGlintFastFillPolygon: mono pat fill, col = 0x%08x:0x%08x, logicOp = %d:%d",            \
                            fgColor, bgColor, fgLogicOp, bgLogicOp));                                        \
            } else {                                                                                        \
                /* Colour brush */                                                                            \
                POINTL  brushOrg;                                                                            \
                                                                                                            \
                brushOrg = *pptlBrush;                                                                        \
                if( (fgLogicOp == __GLINT_LOGICOP_COPY) && (ppdev->cPelSize != 0) )                            \
                    brushOrg.x +=  (8 - (ppdev->xyOffsetDst & 0xFFFF)) & 7;                                    \
                                                                                                            \
                if( (ppdev->PalLUTType != LUTCACHE_BRUSH) || (pbe == NULL) || (pbe->prbVerify != prb) ) {    \
                    DISPDBG((DBGLVL, "realising brush"));                                                        \
                    (*ppdev->pgfnPatRealize)(ppdev, prb, &brushOrg);                                        \
                } else                                                                                      \
                if( (prb->ptlBrushOrg.x != brushOrg.x) || (prb->ptlBrushOrg.y != brushOrg.y) ||                \
                    (prb->patternBase != ((glintInfo->lutMode >> 18) & 255)) ) {                \
                    ULONG   lutMode = glintInfo->lutMode;                                                    \
                                                                                                            \
                    DISPDBG((DBGLVL, "resetting LUTMode"));                                                        \
                                                                                                            \
                    prb->ptlBrushOrg.x = brushOrg.x;                                            \
                    prb->ptlBrushOrg.y = brushOrg.y;                                            \
                                                                                                            \
                    DISPDBG((DBGLVL, "setting new LUT offset to %d, %d", (8 - prb->ptlBrushOrg.x) & 7, (8 - prb->ptlBrushOrg.y) & 7));            \
                                                                                                            \
                    lutMode &= ~((7 << 8) | (7 << 12) | (7 << 15) | (255 << 18) | (1 << 26) | (1 << 27));    \
                    lutMode |= (1 << 8) | (1 << 27) | (prb->patternBase << 18) |                \
                               (((8 - prb->ptlBrushOrg.x) & 7) << 12) | (((8 - prb->ptlBrushOrg.y) & 7) << 15);                                \
                    WAIT_PXRX_DMA_TAGS( 1 );                                                                \
                    LOAD_LUTMODE( lutMode );                                                                \
                } else {                                                                                    \
                    /* we're cached already! */                                                                \
                    DISPDBG((DBGLVL, "reusing LUT for brush @ %d, origin = (%d,%d)", prb->patternBase, prb->ptlBrushOrg.x, prb->ptlBrushOrg.y));    \
                }                                                                                            \
                                                                                                            \
                WAIT_PXRX_DMA_TAGS( 4 );                                                                    \
                if( (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITING) ||                                        \
                    (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE) ||                                        \
                    (ppdev->cPelSize == GLINTDEPTH8) || (ppdev->cPelSize == GLINTDEPTH32) ) {                \
                    config2D |= config2D_FillColourDual[fgLogicOp];                                            \
                                                                                                            \
                    if( LogicopReadDest[fgLogicOp] )                                                        \
                        SET_READ_BUFFERS;                                                                    \
                                                                                                            \
                    renderMsg |= __RENDER_VARIABLE_SPANS;                                                    \
                } else {                                                                                    \
                    config2D |= config2D_FillColour[fgLogicOp];                                                \
                                                                                                            \
                    if( fgLogicOp != __GLINT_LOGICOP_COPY )                                                    \
                        renderMsg |= __RENDER_VARIABLE_SPANS;                                                \
                                                                                                            \
                    if( LogicopReadDest[fgLogicOp] ) {                                                        \
                        SET_READ_BUFFERS;                                                                    \
                    } else if( fgLogicOp == __GLINT_LOGICOP_COPY ) {                                        \
                        LOAD_FBWRITE_ADDR( 1, ppdev->DstPixelOrigin );                                        \
                        LOAD_FBWRITE_WIDTH( 1, ppdev->DstPixelDelta );                                        \
                        LOAD_FBWRITE_OFFSET( 1, ppdev->xyOffsetDst );                                        \
                    }                                                                                        \
                }                                                                                            \
                                                                                                            \
                if( config2D & __CONFIG2D_LUTENABLE )                                                        \
                    invalidatedFGBG = TRUE;                                                                    \
                                                                                                            \
                DISPDBG((DBGLVL, "bGlintFastFillPolygon: colour pat fill, patBase = %d, logicOp = %d", prb->patternBase, fgLogicOp));                    \
            }                                                                                                \
        }                                                                                                    \
                                                                                                            \
        WAIT_PXRX_DMA_TAGS( 1 );                                                                            \
        LOAD_CONFIG2D( config2D );                                                                            \
        nSpaces = 0;                                                                                        \
    } while( 0 )

/*
;
    *fgColor_In         = fgColor;
    *fgLogicOp_In       = fgLogicOp;
    *bgColor_In         = bgColor;
    *bgLogicOp_In       = bgLogicOp;
    *config2D_In        = config2D;
    *renderMsg_In       = renderMsg;
    *invalidatedFGBG_In = invalidatedFGBG;
}
*/


/******************************Public*Routine******************************\
* BOOL bGlintFastFillPolygon
*
* Draws a non-complex, unclipped polygon.  'Non-complex' is defined as
* having only two edges that are monotonic increasing in 'y'.  That is,
* the polygon cannot have more than one disconnected segment on any given
* scan.  Note that the edges of the polygon can self-intersect, so hourglass
* shapes are permissible.  This restriction permits this routine to run two
* simultaneous DDAs, and no sorting of the edges is required.
*
* Note that NT's fill convention is different from that of Win 3.1 or 4.0.
* With the additional complication of fractional end-points, our convention
* is the same as in 'X-Windows'.  But a DDA is a DDA is a DDA, so once you
* figure out how we compute the DDA terms for NT, you're golden.
*
* This routine handles patterns only when the glint area stipple can be
* used.  The reason for this is that once the stipple initialization is
* done, pattern fills appear to the programmer exactly the same as solid
* fills (with the slight difference of an extra bit in the render command).
*
* We break each polygon down to a sequenze of screen aligned trapeziods, which
* the glint can handle.
*
* Optimisation list follows ....
*
* This routine is in no way the ultimate convex polygon drawing routine
* Some obvious things that would make it faster:
*
*    1) Write it in Assembler
*
*    2) Make the non-complex polygon detection faster.  If I could have
*       modified memory before the start of after the end of the buffer,
*       I could have simplified the detection code.  But since I expect
*       this buffer to come from GDI, I can't do that.  Another thing
*       would be to have GDI give a flag on calls that are guaranteed
*       to be convex, such as 'Ellipses' and 'RoundRects'.  Note that
*       the buffer would still have to be scanned to find the top-most
*       point.
*
*    3) Implement support for a single sub-path that spans multiple
*       path data records, so that we don't have to copy all the points
*       to a single buffer like we do in 'fillpath.c'.
*
*    4) Use 'ebp' and/or 'esp' as a general register in the inner loops
*       of the Asm loops, and also Pentium-optimize the code.  It's safe
*       to use 'esp' on NT because it's guaranteed that no interrupts
*       will be taken in our thread context, and nobody else looks at the
*       stack pointer from our context.
*
*    5) When we get to a part of the polygon where both vertices are of 
*       equal height, the algorithm essentially starts the polygon again.
*       Using the GLINT Continue message could speed things up in certain
*       cases.
*
* Returns TRUE if the polygon was drawn; FALSE if the polygon was complex.
*
\**************************************************************************/

BOOL bGlintFastFillPolygon(
    PDEV        *ppdev,
    LONG        cEdges,             // Includes close figure edge
    POINTFIX    *pptfxFirst,        // Ptr to first point
    ULONG       fgColor,            // Solid color fill
    ULONG       fgLogicOp,          // Logical Operation to perform
    ULONG       bgLogicOp,          // background logic op
    CLIPOBJ     *pco,               // Clip Object. 
    RBRUSH      *prb,
    POINTL      *pptlBrush )        // Pattern alignment
{
    POINTFIX    *pptfxLast;         // Points to the last point in the polygon array
    POINTFIX    *pptfxTop;          // Points to the top-most point in the polygon
    POINTFIX    *pptfxScan;         // Current edge pointer for finding pptfxTop
    LONG        cScanEdges;         // Number of edges scanned to find pptfxTop
                                    //  (doesn't include the closefigure edge)
    POINTFIX    *pnt[2];            // DDA terms and stuff
    POINTFIX    *npnt[2];           // DDA terms and stuff
    LONG        dx[2], dy[2], gdx[2];
    ULONG       orx, ory;           // all values ored, to eliminate complex polygons
    LONG        count;
    LONG        nClips;             // Number of clipping rectangles to render in
    CLIPENUM    *pClipRegion = (CLIPENUM *)(ppdev->pvTmpBuffer);
    RECTL       *pClipList;         // List of clip rects
    LONG        xOffFixed;
    ULONG       bgColor;
    BOOL        bTrivialClip, invalidatedFGBG = FALSE;
    BOOL        invalidatedScissor = FALSE;
    ULONG       config2D =  __CONFIG2D_FBWRITE;
    ULONG       renderMsg = __RENDER_TRAPEZOID_PRIMITIVE | 
                            __RENDER_FAST_FILL_ENABLE;
    LONG        nSpaces;
    GLINT_DECL;

    DISPDBG((DBGLVL, "bGlintFastFillPolygon: "
                     "Checking polygon for renderability by glint"));
    ASSERTDD(cEdges > 1, "Polygon with less than 2 edges");

    /////////////////////////////////////////////////////////////////
    // See if the polygon is 'non-complex'

    pptfxScan = pptfxFirst;
    pptfxTop  = pptfxFirst;                 // Assume for now that the first
                                            //  point in path is the topmost
    pptfxLast = pptfxFirst + cEdges - 1;
    orx = pptfxScan->x;
    ory = pptfxScan->y;

    // 'pptfxScan' will always point to the first point in the current
    // edge, and 'cScanEdges' will the number of edges remaining, including
    // the current one:

    cScanEdges = cEdges - 1;     // The number of edges, not counting close figure

    if( (pptfxScan + 1)->y > pptfxScan->y ) 
    {
        // Collect all downs:
        do 
        {
            ory |= (++pptfxScan)->y;
            orx |= pptfxScan->x;
            if( --cScanEdges == 0 )
            {
                goto SetUpForFilling;
            }
        } while( (pptfxScan + 1)->y >= pptfxScan->y );

        // Collect all ups:
        do 
        {
            ory |= (++pptfxScan)->y;
            orx |= pptfxScan->x;
            if( --cScanEdges == 0 )
            {
                goto SetUpForFillingCheck;
            }
        } while( (pptfxScan + 1)->y <= pptfxScan->y );

        // Collect all downs:
        pptfxTop = pptfxScan;

        do 
        {
            if( (pptfxScan + 1)->y > pptfxFirst->y )
                break;

            ory |= (++pptfxScan)->y;
            orx |= pptfxScan->x;
            if( --cScanEdges == 0 )
            {
                goto SetUpForFilling;
            }
        } while( (pptfxScan + 1)->y >= pptfxScan->y );

        DISPDBG((DBGLVL, "Reject: GLINT can't fill down-up-down polygon"));
        return FALSE;
        
    } 
    else 
    {
        // Collect all ups:
        do 
        {
            ory |= (++pptfxTop)->y;      // We increment this now because we
            orx |= pptfxTop->x;          //  want it to point to the very last
                                         //  point if we early out in the next
                                         //  statement...
            if( --cScanEdges == 0 )
            {
                goto SetUpForFilling;
            }
            
        } while( (pptfxTop + 1)->y <= pptfxTop->y );

        // Collect all downs:
        pptfxScan = pptfxTop;
        do 
        {
            ory |= (++pptfxScan)->y;
            orx |= pptfxScan->x;
            if( --cScanEdges == 0 )
            {
                goto SetUpForFilling;
            }
        } while( (pptfxScan + 1)->y >= pptfxScan->y );

        // Collect all ups:
        do 
        {
            if( (pptfxScan + 1)->y < pptfxFirst->y )
            {
                break;
            }

            ory |= (++pptfxScan)->y;
            orx |= pptfxScan->x;
            if( --cScanEdges == 0 )
            {
                goto SetUpForFilling;
            }
            
        } while( (pptfxScan + 1)->y <= pptfxScan->y );

        DISPDBG((DBGLVL, "Reject: GLINT can't fill up-down-up polygon"));
        return FALSE;
    }

SetUpForFillingCheck:

    // We check to see if the end of the current edge is higher
    // than the top edge we've found so far
             
    if( pptfxScan->y < pptfxTop->y )
    {
        pptfxTop = pptfxScan;
    }

SetUpForFilling:

    // can only use block fills for trivial clip so work it out here
    bTrivialClip = (pco == NULL) || (pco->iDComplexity == DC_TRIVIAL);

    if( DO_SPANONLY_VERSION )
    {
        goto BreakIntoSpans;
    }

    if( (ory & 0xffffc00f) || (orx & 0xffff8000) ) 
    {
        ULONG   neg, posx, posy;

        // fractional Y must be done as spans
        if( ory & 0xf )
        {
            goto BreakIntoSpans;
        }

        // Run through all the vertices and check that none of them
        // have a negative component less than -256.
        neg = posx = posy = 0;
        for( pptfxScan = pptfxFirst; pptfxScan <= pptfxLast; pptfxScan++ ) 
        {
            if( pptfxScan->x < 0 )
            {
                neg |= -pptfxScan->x;
            }
            else
            {
                posx |= pptfxScan->x;
            }
            
            if( pptfxScan->y < 0 )
            {
                neg |= -pptfxScan->y;
            }
            else
            {
                posy |= pptfxScan->y;
            }
        }
  
        // We don't want to handle any polygon with a negative vertex
        // at <= -256 in either coordinate ???
        if( neg & 0xfffff000 ) 
        {
            DISPDBG((WRNLVL, "Coords out of range for fast fill"));
            return FALSE;
        }
    }

    // The code can handle the polygon now. Lets go ahead and render it! 

    // Compiler gets its register allocation wrong. This forces it to redo them
    GLINT_DECL_INIT;

    DISPDBG((DBGLVL, "bGlintFastFillPolygon: "
                     "Polygon is renderable. Go ahead and render"));

    // Work out offset to add to each of the coords downloaded to GLINT
    // To get correct results, we need to add on nearly one to each X
    // coordinate. 
    // Also add on offsets to bitmap (This might be an off screen bitmap)
    xOffFixed = INTtoFIXED(0) + NEARLY_ONE;

    // determine how many passes we require to draw all the clip rects
    if( bTrivialClip ) 
    {
        // Just draw, no clipping to perform.
        pClipList = NULL; // Indicate no clip list
        nClips = 1;
    } 
    else 
    {
        if( pco->iDComplexity == DC_RECT ) 
        {
            nClips = 1;
            pClipList = &pco->rclBounds;
        } 
        else 
        {
            // It may be slow to render the entire polygon for each clip 
            // rect, especially if the object is very complex. An arbitary 
            // limit of up to CLIP_LIMIT regions will be rendered by this 
            // function. Return false if more than CLIP_LIMIT regions.
            nClips = CLIPOBJ_cEnumStart(pco, 
                                        FALSE, 
                                        CT_RECTANGLES, 
                                        CD_ANY, 
                                        CLIP_LIMIT);
            
            if( nClips == -1 )
            {
                return FALSE; // More than CLIP_LIMIT.
            }

            // Put the regions into our clip buffer
            if( (CLIPOBJ_bEnum(pco, sizeof (CLIPENUM), (ULONG*)pClipRegion)) ||
                (pClipRegion->c != nClips) )
            {
                DISPDBG((DBGLVL, "bGlintFastFillPolygon: "
                                 "CLIPOBJ_bEnum inconsistency %d = %d", 
                                 pClipRegion->c, nClips));
            }
            
            pClipList = &(pClipRegion->arcl[0]);
        }

        config2D |= __CONFIG2D_USERSCISSOR;
    }

    SETUP_COLOUR_STUFF;

    WAIT_PXRX_DMA_TAGS( 11 );
    QUEUE_PXRX_DMA_TAG( __GlintTagdY, INTtoFIXED(1) );

    DISPDBG((DBGLVL, "Rendering Polygon. %d clipping rectangles", nClips));

    if( nClips && pClipList )
    {
        invalidatedScissor = TRUE;
    }

    // JME: check for 0 nClips //azn
    if( nClips-- ) 
    {
        while( 1 ) 
        {
            // Need to set up clip rect each pass 
            if( pClipList ) 
            {
                DISPDBG((DBGLVL, "Clip rect = (%d, %d -> %d, %d)", 
                                 pClipList->left, pClipList->top, 
                                 pClipList->right, pClipList->bottom));
                QUEUE_PXRX_DMA_TAG( __GlintTagScissorMinXY, 
                                            MAKEDWORD_XY(pClipList->left , 
                                                         pClipList->top   ) );
                QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY, 
                                            MAKEDWORD_XY(pClipList->right, 
                                                         pClipList->bottom) );
                pClipList++;
            }

            // Initialize left and right points (current) to top point.
            npnt[LEFT]  = pptfxTop;
            npnt[RIGHT] = pptfxTop;

            while( 1 ) 
            {
                // npnt[] is always the valid point to draw from
                do 
                {
                    pnt[LEFT] = npnt[LEFT];
                    npnt[LEFT] = pnt[LEFT] - 1;   

                    if (npnt[LEFT] < pptfxFirst)
                    {
                        npnt[LEFT] = pptfxLast;
                    }

                    // Special case of flat based polygon, need to break now 
                    // as polygon is finished
                    if (npnt[LEFT] == npnt[RIGHT]) 
                    {
                        goto FinishedPolygon;
                    }

                    DISPDBG((DBGLVL, "LEFT: pnt %P npnt %P FIRST %P LAST %P", 
                                     pnt[LEFT], npnt[LEFT], 
                                     pptfxFirst, pptfxLast));
                    DISPDBG((DBGLVL, "x 0x%04X y 0x%04X Next: x 0x%04X y 0x%04X", 
                                     pnt[LEFT]->x, pnt[LEFT]->y, 
                                     npnt[LEFT]->x, npnt[LEFT]->y));
                                     
                } while( pnt[LEFT]->y == npnt[LEFT]->y );
        
                do {
                    pnt[RIGHT] = npnt[RIGHT];
                    npnt[RIGHT] = pnt[RIGHT] + 1;     

                    if (npnt[RIGHT] > pptfxLast)
                    {
                        npnt[RIGHT] = pptfxFirst;
                    }

                    DISPDBG((DBGLVL, "RIGHT: pnt %P npnt %P FIRST %P LAST %P", 
                                     pnt[RIGHT], npnt[RIGHT], 
                                     pptfxFirst, pptfxLast));
                    DISPDBG((DBGLVL, "x 0x%04X y 0x%04X Next: x 0x%04X y 0x%04X", 
                                     pnt[RIGHT]->x, pnt[RIGHT]->y, 
                                     npnt[RIGHT]->x, npnt[RIGHT]->y));
                } while( pnt[RIGHT]->y == npnt[RIGHT]->y );
        
                // Start up new rectangle. Whenever we get to this code, both
                // points should have equal y values, and need to be restarted.
                DISPDBG((DBGLVL, "New: Top: (0x%04X, 0x%04X)->(0x%04X, 0x%04X)"
                                 "    Next: (0x%04X, 0x%04X)->(0x%04X, 0x%04X)",                          
                                 pnt[LEFT]->x, pnt[LEFT]->y, 
                                 pnt[RIGHT]->x, pnt[RIGHT]->y, 
                                 npnt[LEFT]->x, npnt[LEFT]->y, 
                                 npnt[RIGHT]->x, npnt[RIGHT]->y));

                QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom,    
                                        FIXtoFIXED(pnt[LEFT]->x) + xOffFixed );
                QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub,    
                                        FIXtoFIXED(pnt[RIGHT]->x) + xOffFixed);
                QUEUE_PXRX_DMA_TAG( __GlintTagStartY,       
                                        FIXtoFIXED(pnt[RIGHT]->y) );

                // We have 2 15.4 coordinates. We need to divide them and 
                // change them into a 15.16 coordinate. We know the y 
                // coordinate is not fractional, so we do not loose 
                // precision by shifting right by 4
                dx[LEFT] = (npnt[LEFT]->x - pnt[LEFT]->x) << 12;
                dy[LEFT] = (npnt[LEFT]->y - pnt[LEFT]->y) >> 4;

                // Need to ensure we round delta down. 
                // divide rounds towards zero
                if( dx[LEFT] < 0 )
                {
                    dx[LEFT] -= dy[LEFT] - 1;
                }

                gdx[LEFT] = dx[LEFT] / dy[LEFT];
                
                QUEUE_PXRX_DMA_TAG( __GlintTagdXDom,    gdx[LEFT] );

                dx[RIGHT] = (npnt[RIGHT]->x - pnt[RIGHT]->x) << 12;
                dy[RIGHT] = (npnt[RIGHT]->y - pnt[RIGHT]->y) >> 4;

                // Need to ensure we round delta down. 
                // divide rounds towards zero
                if( dx[RIGHT] < 0 )
                {
                    dx[RIGHT] -= dy[RIGHT] - 1;
                }

                gdx[RIGHT] = dx[RIGHT] / dy[RIGHT];
                
                QUEUE_PXRX_DMA_TAG( __GlintTagdXSub, gdx[RIGHT] );

                // Work out number of scanlines to render
                if (npnt[LEFT]->y < npnt[RIGHT]->y)
                {
                    count = dy[LEFT];
                }
                else
                {
                    count = dy[RIGHT];
                }

                QUEUE_PXRX_DMA_TAG( __GlintTagCount, count );
                QUEUE_PXRX_DMA_TAG( __GlintTagRender, renderMsg );
                SEND_PXRX_DMA_BATCH;


                // With lots of luck, top trapezoid should be drawn now!
                // Repeatedly draw more trapezoids until points are equal
                // If y values are equal, then we can start again from
                // scratch. 

                while( (npnt[LEFT]    != npnt[RIGHT]) && 
                       (npnt[LEFT]->y != npnt[RIGHT]->y) ) 
                {
                    // Some continues are required for next rectangle
                    if( npnt[LEFT]->y < npnt[RIGHT]->y ) 
                    {
                        // We have reached npnt[LEFT]. npnt[RIGHT] is still ok
                        do 
                        {
                            pnt[LEFT] = npnt[LEFT];
                            npnt[LEFT] = pnt[LEFT] - 1;   

                            if (npnt[LEFT] < pptfxFirst)
                            {
                                npnt[LEFT] = pptfxLast;
                            }

                        } while( pnt[LEFT]->y == npnt[LEFT]->y );
                    
                        // We have a new npnt[LEFT] now.
                        DISPDBG((DBGLVL, "Dom: Top: x: %x y: %x "
                                         "    Next: x: %x y: %x x: %x y: %x", 
                                          pnt[LEFT]->x, pnt[LEFT]->y, 
                                          npnt[LEFT]->x, npnt[LEFT]->y, 
                                          npnt[RIGHT]->x, npnt[RIGHT]->y));

                        dx[LEFT] = (npnt[LEFT]->x - pnt[LEFT]->x) << 12;
                        dy[LEFT] = (npnt[LEFT]->y - pnt[LEFT]->y) >> 4;

                        // Need to ensure we round delta down. 
                        // divide rounds towards zero
                        if( dx[LEFT] < 0 )
                        {
                            dx[LEFT] -= dy[LEFT] - 1;
                        }

                        gdx[LEFT] = dx[LEFT] / dy[LEFT];

                        if( npnt[LEFT]->y < npnt[RIGHT]->y )
                        {
                            count = dy[LEFT];
                        }
                        else
                        {
                            count = (ABS(npnt[RIGHT]->y - pnt[LEFT]->y)) >> 4;
                        }

                        WAIT_PXRX_DMA_TAGS( 3 );
                        QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom,        
                                        FIXtoFIXED(pnt[LEFT]->x) + xOffFixed );
                        QUEUE_PXRX_DMA_TAG( __GlintTagdXDom,      gdx[LEFT] );
                        QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewDom, count );
                    } 
                    else 
                    {
                        // We have reached npnt[RIGHT]. npnt[LEFT] is still ok
                        do {
                            pnt[RIGHT] = npnt[RIGHT];
                            npnt[RIGHT] = pnt[RIGHT] + 1;     

                            if( npnt[RIGHT] > pptfxLast )
                            {
                                npnt[RIGHT] = pptfxFirst;
                            }

                        } while( pnt[RIGHT]->y == npnt[RIGHT]->y );

                        // We have a new npnt[RIGHT] now.
                        DISPDBG((DBGLVL, "Sub: Top: x: %x y: %x "
                                         "    Next: x: %x y: %x x: %x y: %x", 
                                         pnt[RIGHT]->x, pnt[RIGHT]->y, 
                                         npnt[LEFT]->x, npnt[LEFT]->y, 
                                         npnt[RIGHT]->x, npnt[RIGHT]->y));
        
                        dx[RIGHT] = (npnt[RIGHT]->x - pnt[RIGHT]->x) << 12;
                        dy[RIGHT] = (npnt[RIGHT]->y - pnt[RIGHT]->y) >> 4;

                        // Need to ensure we round delta down. 
                        // divide rounds towards zero
                        if( dx[RIGHT] < 0 )
                        {
                            dx[RIGHT] -= dy[RIGHT] - 1;
                        }

                        gdx[RIGHT] = dx[RIGHT] / dy[RIGHT];

                        if( npnt[RIGHT]->y < npnt[LEFT]->y )
                        {
                            count = dy[RIGHT];
                        }
                        else
                        {
                            count = (ABS(npnt[LEFT]->y - pnt[RIGHT]->y)) >> 4;
                        }

                        WAIT_PXRX_DMA_TAGS( 3 );
                        QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub,        
                                        FIXtoFIXED(pnt[RIGHT]->x) + xOffFixed );
                        QUEUE_PXRX_DMA_TAG( __GlintTagdXSub,       gdx[RIGHT] );
                        QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewSub,   count );
                    }
                }

                // Repeatedly draw more trapezoids until points are equal
                // If y values are equal, then we can start again from
                // scratch. 
                if( npnt[LEFT] == npnt[RIGHT] )
                {
                    break;
                }
                
                WAIT_PXRX_DMA_TAGS( 7 ); // 7 entries needed to 
                                         // render first trapezoid
            }

    FinishedPolygon:

            if( !nClips-- )
            {
                break;
            }

            // entries needed to clip and render first trapezoid
            WAIT_PXRX_DMA_TAGS( 2 + 7 );
            
        } // while
    } // if

    DISPDBG((DBGLVL, "bGlintFastFillPolygon: returning TRUE"));

    // Need to send ContinueNewSub(0) to flush the framebuffer ??? //azn

    if( invalidatedFGBG ) 
    {
        WAIT_PXRX_DMA_DWORDS( 3 );
        QUEUE_PXRX_DMA_INDEX2( __GlintTagForegroundColor, 
                                        __GlintTagBackgroundColor );
        QUEUE_PXRX_DMA_DWORD( glintInfo->foregroundColour );
        QUEUE_PXRX_DMA_DWORD( glintInfo->backgroundColour );
    }

    if( (ppdev->cPelSize == GLINTDEPTH32) && invalidatedScissor ) 
    {
        WAIT_PXRX_DMA_TAGS( 1 );
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY, 0x7FFF7FFF );
    }

    SEND_PXRX_DMA_BATCH;

    return TRUE;

/******************************************************************************/

// This is the code to break the polygon into spans.
BreakIntoSpans:

    DISPDBG((DBGLVL, "Breaking into spans"));

    {
        LONG      yTrapezoid;   // Top scan for next trapezoid
        LONG      cyTrapezoid;  // Number of scans in current trapezoid
        POINTFIX* pptfxOld;     // Start point in current edge
        LONG      yStart;       // y-position of start point in current edge
        LONG      dM;           // Edge delta in FIX units in x direction
        LONG      dN;           // Edge delta in FIX units in y direction
        LONG      iEdge;
        LONG      lQuotient;
        LONG      lRemainder;
        LONG      i;
        EDGEDATA  aed[2];// DDA terms and stuff
        EDGEDATA* ped;
        LONG      tmpXl, tmpXr;
        DWORD     continueMessage = 0;

        // This span code cannot handle a clip list yet!
        if( !bTrivialClip )
        {
            return FALSE;
        }

        DISPDBG((DBGLVL, "Starting Spans Code"));

        /////////////////////////////////////////////////////////////////
        // Some Initialization

        yTrapezoid = (pptfxTop->y + 15) >> 4;

        // Make sure we initialize the DDAs appropriately:
        aed[LEFT].cy  = 0;
        aed[RIGHT].cy = 0;

        // For now, guess as to which is the left and which is the right edge:
        aed[LEFT].dptfx  = -(LONG) sizeof(POINTFIX);
        aed[RIGHT].dptfx = sizeof(POINTFIX);
        aed[LEFT].pptfx  = pptfxTop;
        aed[RIGHT].pptfx = pptfxTop;

        DISPDBG((DBGLVL, "bGlintFastFillPolygon: Polygon is renderable. "
                         "Go ahead and render"));

        // Work out offset to add to each of the coords downloaded to GLINT
        // To get correct results, we need to add on nearly one to each X
        // coordinate. 
        // Also add on offsets to bitmap (This might be an off screen bitmap)
        xOffFixed = INTtoFIXED(0);

        WAIT_PXRX_DMA_TAGS( 4 );
        QUEUE_PXRX_DMA_TAG( __GlintTagCount,    0 );
        QUEUE_PXRX_DMA_TAG( __GlintTagdXDom,    0 );
        QUEUE_PXRX_DMA_TAG( __GlintTagdXSub,    0);
        QUEUE_PXRX_DMA_TAG( __GlintTagdY,       INTtoFIXED(1));

        DISPDBG((DBGLVL, "Rendering Polygon"));

        nSpaces = 0;
NewTrapezoid:

        DISPDBG((DBGLVL, "New Trapezoid"));

        /////////////////////////////////////////////////////////////////
        // DDA initialization

        for( iEdge = 1; iEdge >= 0; iEdge-- ) 
        {
            ped = &aed[iEdge];
            if( ped->cy == 0 ) 
            {
                // Need a new DDA:
                do 
                {
                    cEdges--;
                    if( cEdges < 0 ) 
                    {
                        DISPDBG((DBGLVL, "bGlintFastFillPolygon: "
                                         "returning TRUE"));
                        return TRUE;
                    }

                    // Find the next left edge, accounting for wrapping:
                    pptfxOld = ped->pptfx;
                    ped->pptfx = (POINTFIX*)((BYTE*) ped->pptfx + ped->dptfx);

                    if( ped->pptfx < pptfxFirst )
                    {
                        ped->pptfx = pptfxLast;
                    }
                    else if( ped->pptfx > pptfxLast )
                    {
                        ped->pptfx = pptfxFirst;
                    }

                    // Have to find the edge that spans yTrapezoid:
                    ped->cy = ((ped->pptfx->y + 15) >> 4) - yTrapezoid;

                    // With fractional coordinate end points, we may get edges
                    // that don't cross any scans, in which case we try the
                    // next one:
                } while( ped->cy <= 0 );

                // 'pptfx' now points to the end point of the edge spanning
                // the scan 'yTrapezoid'.
                dN = ped->pptfx->y - pptfxOld->y;
                dM = ped->pptfx->x - pptfxOld->x;

                ASSERTDD(dN > 0, "Should be going down only");

                // Compute the DDA increment terms:
                if( dM < 0 ) 
                {
                    dM = -dM;
                    if( dM < dN ) 
                    {                        // Can't be '<='
                        ped->dx       = -1;
                        ped->lErrorUp = dN - dM;
                    } 
                    else 
                    {
                        QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                        ped->dx       = -lQuotient;        // - dM / dN
                        ped->lErrorUp = lRemainder;        // dM % dN
                        if( ped->lErrorUp > 0 ) 
                        {
                            ped->dx--;
                            ped->lErrorUp = dN - ped->lErrorUp;
                        }
                    }
                } 
                else 
                {
                    if( dM < dN ) 
                    {                        // Can't be '<='
                        ped->dx       = 0;
                        ped->lErrorUp = dM;
                    } 
                    else 
                    {
                        QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                        ped->dx       = lQuotient;        // dM / dN
                        ped->lErrorUp = lRemainder;        // dM % dN
                    }
                }

                ped->lErrorDown = dN; // DDA limit
                ped->lError     = -1; // Error is initially zero (add dN - 1 for
                                      //  the ceiling, but subtract off dN so 
                                      //  that we can check the sign instead of 
                                      //  comparing to dN)

                ped->x = pptfxOld->x;
                yStart = pptfxOld->y;

                if( (yStart & 15) != 0 ) 
                {
                    // Advance to the next integer y coordinate
                    for( i = 16 - (yStart & 15); i != 0; i-- ) 
                    {
                        ped->x      += ped->dx;
                        ped->lError += ped->lErrorUp;
                        if( ped->lError >= 0 ) 
                        {
                            ped->lError -= ped->lErrorDown;
                            ped->x++;
                        }
                    }
                }

                if( (ped->x & 15) != 0 ) 
                {
                    ped->lError -= ped->lErrorDown * (16 - (ped->x & 15));
                    ped->x += 15;    // We'll want the ceiling in just a bit...
                }

                // Chop off those fractional bits, convert to GLINT format
                // and add in the bitmap offset:
                ped->x = ped->x >> 4;
                ped->lError >>= 4;

                // Convert to GLINT format positions and deltas
                ped->x  = INTtoFIXED(ped->x) + xOffFixed;
                ped->dx = INTtoFIXED(ped->dx);
            }
        }

        cyTrapezoid = min(aed[LEFT].cy, aed[RIGHT].cy); // #scans in this trap
        aed[LEFT].cy  -= cyTrapezoid;
        aed[RIGHT].cy -= cyTrapezoid;
        yTrapezoid    += cyTrapezoid;                 // Top scan in next trap

        SETUP_COLOUR_STUFF;

        // If the left and right edges are vertical, simply output as
        // a rectangle:

        DISPDBG((DBGLVL, "Generate spans for glint"));

        do 
        {
            GetMoreFifoEntries( 4 );

            // Reset render position to the top of the trapezoid.
            QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom,    aed[RIGHT].x );
            QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub,    aed[LEFT].x );
            QUEUE_PXRX_DMA_TAG( __GlintTagStartY,       
                                    INTtoFIXED(yTrapezoid - cyTrapezoid) );
            QUEUE_PXRX_DMA_TAG( __GlintTagRender,       renderMsg );
            SEND_PXRX_DMA_BATCH;

            continueMessage = __GlintTagContinue;

            if( ((aed[LEFT].lErrorUp | aed[RIGHT].lErrorUp) == 0) &&
                ((aed[LEFT].dx       | aed[RIGHT].dx) == 0) &&
                (cyTrapezoid > 1) ) 
            {
                //////////////////////////////////////////////////////////////
                // Vertical-edge special case

                DISPDBG((DBGLVL, "Vertical Edge Special Case"));

                GetMoreFifoEntries( 1 );
                QUEUE_PXRX_DMA_TAG( continueMessage, cyTrapezoid );

                continue;
            }

            while( TRUE ) 
            {
                //////////////////////////////////////////////////////////////
                // Run the DDAs

                DISPDBG((DBGLVL, "Doing a span 0x%x to 0x%x, 0x%x scans left. "
                            "Continue %s",
                            aed[LEFT].x, aed[RIGHT].x, cyTrapezoid,
                            (continueMessage == __GlintTagContinueNewDom) ? "NewDom" :
                            ((continueMessage == __GlintTagContinue) ? "" : "NewSub")));

                GetMoreFifoEntries( 1 );
                QUEUE_PXRX_DMA_TAG( continueMessage, 1 );

                // We have finished this trapezoid. Go get the next one!

                // Advance the right wall:
                tmpXr = aed[RIGHT].x;
                aed[RIGHT].x      += aed[RIGHT].dx;
                aed[RIGHT].lError += aed[RIGHT].lErrorUp;

                if( aed[RIGHT].lError >= 0 ) 
                {
                    aed[RIGHT].lError -= aed[RIGHT].lErrorDown;
                    aed[RIGHT].x += INTtoFIXED(1);
                }

                // Advance the left wall:
                tmpXl = aed[LEFT].x;
                aed[LEFT].x      += aed[LEFT].dx;
                aed[LEFT].lError += aed[LEFT].lErrorUp;

                if( aed[LEFT].lError >= 0 ) 
                {
                    aed[LEFT].lError -= aed[LEFT].lErrorDown;
                    aed[LEFT].x += INTtoFIXED(1);
                }

                if( --cyTrapezoid == 0 )
                {
                    break;
                }

                // Setup the GLINT X registers if we have changed either end.
                if( tmpXr != aed[RIGHT].x ) 
                {
                    if( tmpXl != aed[LEFT].x ) 
                    {
                        GetMoreFifoEntries( 3 );

                        QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub, aed[LEFT].x );
                        QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewSub,   0 );
                    } 
                    else 
                    {
                        GetMoreFifoEntries( 1 );
                    }
                    QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom, aed[RIGHT].x );
                    continueMessage = __GlintTagContinueNewDom;                
                } 
                else if( tmpXl != aed[LEFT].x ) 
                {
                    GetMoreFifoEntries( 1 );
                    QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub, aed[LEFT].x );
                    continueMessage = __GlintTagContinueNewSub;
                }                
            }
        } while( 0 );

        DISPDBG((DBGLVL, "Generate spans for glint done"));
        goto NewTrapezoid;
    }

    if( invalidatedFGBG ) 
    {
        WAIT_PXRX_DMA_DWORDS( 3 );
        QUEUE_PXRX_DMA_INDEX2( __GlintTagForegroundColor, 
                                            __GlintTagBackgroundColor );
        QUEUE_PXRX_DMA_DWORD( glintInfo->foregroundColour );
        QUEUE_PXRX_DMA_DWORD( glintInfo->backgroundColour );
    }

    SEND_PXRX_DMA_BATCH;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\pxrx.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: pxrx.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef PXRX_H
#define PXRX_H

//@@BEGIN_DDKSPLIT
//AZN since these are defines as 0 in the source code, we'll ifdef out the
//    relevant code and later delete it all together
#define USE_RLE_DOWNLOADS       0
#define USE_RLE_UPLOADS         0
//@@END_DDKSPLIT

//@@BEGIN_DDKSPLIT
// AZN don't do on IA64 as IA64 doesn't like this code
//@@END_DDKSPLIT
#if 0 //!defined(_WIN64) && DBG
#   define PXRX_DMA_BUFFER_CHECK            1
//  NB: the size is in dwords...
#   define PXRX_DMA_BUFFER_CHECK_SIZE       4
#endif

enum {
    USE_PXRX_DMA_NONE = 0,
    USE_PXRX_DMA_FIFO,
};

// PxRx structures

typedef struct BypassDMACmd
{
    ULONG   physSysAddr;        // physical address of DMA buffer in system memory, 128 bit aligned
    ULONG   physVidMemAddr;        // physical address of video memory source/dest of transfer, 128 bit aligned
    USHORT  ByteEnableFirst;    // byte enable mask for the first 128 bits
    USHORT  ByteEnableLast;        // byte enable mask for the last 128 bits
    ULONG   Length;                // length of transfer, in 128 bit units
}
BYDMACMD;

#define PXRX_BYPASS_READ_DMA_ACTIVE_BIT     (1 << 22)
#define PXRX_BYPASS_READ_DMA_AGP_BIT        (1 << 23)

//@@BEGIN_DDKSPLIT
/*
    FBDestReadBufferAddr[0] = Frame buffer
    FBDestReadBufferAddr[1] = Scratch 1
    FBDestReadBufferAddr[2] = Scratch 2
    FBDestReadBufferAddr[3] = Scratch 3

    FBDestReadBufferOffset[0] = (x, y) of visible screen
    FBDestReadBufferOffset[1] = ?
    FBDestReadBufferOffset[2] = ?
    FBDestReadBufferOffset[3] = ?


    FBWriteBufferAddr[0] = Frame buffer
    FBWriteBufferAddr[1] = Scratch 1
    FBWriteBufferAddr[2] = Frame buffer (for double writes)
    FBWriteBufferAddr[3] = Scratch 2

    FBWriteBufferOffset[0] = (x, y) of front buffer
    FBWriteBufferOffset[1] = ?
    FBWriteBufferOffset[2] = (x, y) of back buffer
    FBWriteBufferOffset[3] = ?


    FBSourceBufferAddr   = Frame buffer
    FBSourceBufferOffset = Scratch

    NB:
        ScissorMaxXY is assumed to be 0x7FFF7FFF.
        If changed, it must be reset at the end of the primitive.
*/

/*
    DMA transfer schemes:
    ---------------------

    Current DMA method:
        P3 only:
            DMACounts are sent to the input FIFO on a regular basis.
            P3 itself concatenates these into huge DMA buffers thus
            keeping the FIFOs empty and the PCI bus bursting.

        P3 + Gamma:
            Write only the initial DMAAddress + DMACount to the FIFO.
            When the DMA interrupt occurs, write a single address +
            count for all the DMA blocks which have occured in the
            mean time. If non are pending, restart from the beginning.

        P3 + Gamma (non-interrupt):
            Write DMAAddress + DMACount to the input FIFO on a regular
            basis. When the FIFO is full, sit around waiting for it to
            empty.
            This means very limited DMA bursting and no load spreading,
            i.e. fast and slow portions of the rendering will not even
            themselves out. Instead the host and chip will almost be
            running in lockstep.

    Proposed, new improved DMA method:
        P3 only:
            Queue data in DMA buffers.
            SEND_DMA only updates a shared memory buffer end pointer.
            On VBlank, miniport kicks off a DMA up to the current buffer end pointer.
            Exception: if buffer end is too far ahead of buffer start, SEND_DMA will kick of the DMA anyway.
            Problem: how do we know where the buffer start pointer is currently at?

            [buf]Size       = amount of data in buffer
            [buf]Start      = address of first data element in buffer
            [buf]Ptr        = current address of operator within buffer
            [buf]End        = address of last data element in buffer

            buffer          = whole DMA buffer allocated, irrespective of current use
            queued data     = just going into buffer, driver is not yet aware
            pending data    = sitting in buffer, chip is not yet aware
            working data    = chip knows about it and is working its way through

            WAIT for space:
                if( (queuePtr + requiredSpace + 1) > bufferEnd )
                    wrapPoint = queuePtr
                    send queued data to pending data
                    send pending data to working data
                    reset queue
                    reset pending
                    workingStart = bufferStart

                while( (queuePtr + requiredSpace + 1) > queueEnd )
                    wait
                    queueEnd = workingPtr
                    if( queueEnd < bufferStart )
                        queueEnd = wrapPoint - (bufferStart - queueEnd)

            QUEUE data:
                *queuePtr = dataElement
                queuePtr++

            SEND data:
                send queued data to pending data
                if( pendingSize > maxThreshold )        // Too much data is waiting to go
                    send pending data to working data

            VBLANK:
                if( pendingSize > 0 )
                    send pending data to working data

            Queued -> Pending:
                pendingEnd = queuePtr

            Pending -> Working:
                workingExtend   += pendingEnd - pendingStart
                pendingStart     = pendingEnd

            Reset Queue:
                    queuedPtr    = bufferStart

            Reset Pending:
                    pendingStart = bufferStart
                    pendingEnd   = bufferStart


            Notes:
                workingStart    = LoadReg(DMAAddress)
                workingPtr      = ReadReg(DMAAddress), has problems when workingStart is changed
                workingExtend   = LoadReg(DMAContinue)

                wrapPoint       = address of the end of the used buffer (not necessary == bufferEnd)

                assert( (queueEnd + 1) <= workingPtr ) [ always at least '???>->***', never '???>>***']
                    'queueEnd == queuePtr == workingPtr' causes problems of is everything done
                    and dusted or not yet started?

                gaps at the end of the buffer are a problem:
                    the 'workingPtr < bufferStart' case is affected as the actual workingPtr must be
                    determined relative to the end of the used buffer rather than the entire buffer

                workingPtr is cached as queueEnd:
                    reading workingPtr is a slow operation and, moreover, will delay the DMA itself
                    so this is cached to speed up the million and one WAIT calls



            bufferStart       workingPtr         pendingStart     pendingEnd     queuePtr      bufferEnd
                |---------------->********************|++++++++++++++++|?????????????>-------------|


            bufferStart       queuePtr         workingPtr     pendingStart     pendingEnd      bufferEnd
    invalid     |????????????????>------------------>****************|+++++++++++++++|?????????????|
       \/
       \/
       \/   bufferStart                                                                            bufferEnd
        >>>     |????????????????>------------------>*******************************************|##|
    pendingStart/pendingEnd   queuePtr         workingPtr                               wrapPoint


            bufferStart       pendingEnd         queuePtr     workingPtr                           bufferEnd
                |+++++++++++++++++|??????????????????>------------->****************************|##|
           pendingStart                                                                 wrapPoint


            bufferStart       pendingStart         pendingEnd     queuePtr      workingPtr         bufferEnd
    @...........|****************|++++++++++++++++++++|????????????????>------------->**********|##|
workingPtr                                                                              wrapPoint

                                        -        = buffer   [empty space]
                                        *        = working  [owned by the chip]
                                        +        = pending  [owned by the driver]
                                        ?        = working  [owned by the current primitive]
                                        #        = wasted   [skipped over because a primitive did not fit]


    Emergency backup method:
        Do not use DMA, do everything via the input FIFO.


    DMA transfer macros & data storage:
    -----------------------------------

    WAIT_FREE_PXRX_DMA_TAGS(count)      wait for space for count tag/data pair, return the number of free tag/data pair spaces
    WAIT_FREE_PXRX_DMA_DWORDS(count)    wait for space for count dwords,        return the number of free dword spaces
    WAIT_PXRX_DMA_TAGS(count)           wait for space for count tag/data pairs
    WAIT_PXRX_DMA_DWORDS(count)         wait for space for count tag/data

    SEND_PXRX_DMA_FORCE                 Post the current queue to the chip (guarantees to do the send)
    SEND_PXRX_DMA_QUERY                     "        (will only send if the chip is not blocked)
    SEND_PXRX_DMA_BATCH                     "        (will merely batch the data to be sent later)

    QUEUE_PXRX_DMA_TAG(tag, data)       queue a tag/data pair
    QUEUE_PXRX_DMA_HOLD(tag, count)     prepare to queue count dwords as data for held tag
    QUEUE_PXRX_DMA_INC(tag, count)      prepare to queue count dwords as data for incremented tag
    QUEUE_PXRX_DMA_INDEXn(tagN, ...)    prepare to queue n dwords as data for indexed tags
    QUEUE_PXRX_DMA_DWORD(data)          queue a dword
    QUEUE_PXRX_DMA_BUFF(ptr, len)       queue len dwords starting from ptr
    QUEUE_PXRX_DMA_DWORD_DELAYED(ptr)   advance the next free entry one dword, return a pointer the skipped dword

    NTbuff          0 or 1      Buffer NT is currently writing into
    NTptr           address     Next address NT will write to

    P3at            address     Address P3 was last told to read to

    DMAaddrL[2]     lin addr    Linear start address of DMA buffers 0 and 1
    DMAaddrEndL[2]  lin addr    Linear end address of DMA buffers 0 and 1
    DMAaddrP[2]     phys addr   Physical start address of DMA buffers 0 and 1
    DMAaddrEndP[2]  phys addr   Physical end address of DMA buffers 0 and 1

    At start of day:
        NTbuff = 0;
        NTptr = DMAaddrL[NTbuff];
        P3at = NTptr;
        WRITE_PXRX_4KREG( __GlintTagDMAAddress, DMAaddrP[NTbuff] );
*/
//@@END_DDKSPLIT

#define gi_pxrxDMA      (*glintInfo->pxrxDMA)

#define PXRX_DMA_POST_NOW                do{ ; } while(0)

/**********************************/
/*** Macros for assembling tags ***/

#define ASSEMBLE_PXRX_DMA_HOLD(tag, count)        ( (tag) | (((count) - 1) << 16)                )
#define ASSEMBLE_PXRX_DMA_INC(tag, count)        ( (tag) | (((count) - 1) << 16) | (1 << 14)    )

#define PXRX_DMA_INDEX_GROUP(Tag)                                                    ( (Tag & 0xFF0) | (2 << 14) )
#define ASSEMBLE_PXRX_DMA_INDEX2(Tag1, Tag2)                                        ( PXRX_DMA_INDEX_GROUP(Tag1) | (1 << ((Tag1 & 0xF) + 16)) | (1 << ((Tag2 & 0xF) + 16)) )
#define ASSEMBLE_PXRX_DMA_INDEX3(Tag1, Tag2, Tag3)                                    ( PXRX_DMA_INDEX_GROUP(Tag1) | (1 << ((Tag1 & 0xF) + 16)) | (1 << ((Tag2 & 0xF) + 16)) | (1 << ((Tag3 & 0xF) + 16)) )
#define ASSEMBLE_PXRX_DMA_INDEX4(Tag1, Tag2, Tag3, Tag4)                            ( PXRX_DMA_INDEX_GROUP(Tag1) | (1 << ((Tag1 & 0xF) + 16)) | (1 << ((Tag2 & 0xF) + 16)) | (1 << ((Tag3 & 0xF) + 16)) | (1 << ((Tag4 & 0xF) + 16)) )
#define ASSEMBLE_PXRX_DMA_INDEX5(Tag1, Tag2, Tag3, Tag4, Tag5)                        ( PXRX_DMA_INDEX_GROUP(Tag1) | (1 << ((Tag1 & 0xF) + 16)) | (1 << ((Tag2 & 0xF) + 16)) | (1 << ((Tag3 & 0xF) + 16)) | (1 << ((Tag4 & 0xF) + 16)) | (1 << ((Tag5 & 0xF) + 16)) )
#define ASSEMBLE_PXRX_DMA_INDEX6(Tag1, Tag2, Tag3, Tag4, Tag5, Tag6)                ( PXRX_DMA_INDEX_GROUP(Tag1) | (1 << ((Tag1 & 0xF) + 16)) | (1 << ((Tag2 & 0xF) + 16)) | (1 << ((Tag3 & 0xF) + 16)) | (1 << ((Tag4 & 0xF) + 16)) | (1 << ((Tag5 & 0xF) + 16)) | (1 << ((Tag6 & 0xF) + 16)) )
#define ASSEMBLE_PXRX_DMA_INDEX7(Tag1, Tag2, Tag3, Tag4, Tag5, Tag6, Tag7)            ( PXRX_DMA_INDEX_GROUP(Tag1) | (1 << ((Tag1 & 0xF) + 16)) | (1 << ((Tag2 & 0xF) + 16)) | (1 << ((Tag3 & 0xF) + 16)) | (1 << ((Tag4 & 0xF) + 16)) | (1 << ((Tag5 & 0xF) + 16)) | (1 << ((Tag6 & 0xF) + 16)) | (1 << ((Tag7 & 0xF) + 16)) )
#define ASSEMBLE_PXRX_DMA_INDEX8(Tag1, Tag2, Tag3, Tag4, Tag5, Tag6, Tag7, Tag8)    ( PXRX_DMA_INDEX_GROUP(Tag1) | (1 << ((Tag1 & 0xF) + 16)) | (1 << ((Tag2 & 0xF) + 16)) | (1 << ((Tag3 & 0xF) + 16)) | (1 << ((Tag4 & 0xF) + 16)) | (1 << ((Tag5 & 0xF) + 16)) | (1 << ((Tag6 & 0xF) + 16)) | (1 << ((Tag7 & 0xF) + 16)) | (1 << ((Tag8 & 0xF) + 16)) )

/********************************/
/*** Macros for queueing data ***/

#define NTCON_FAKE_DMA_DWORD(data)        ( data )
#define NTCON_FAKE_DMA_INC(tag, count)    ( ASSEMBLE_PXRX_DMA_INC(tag, count) )
#define NTCON_FAKE_DMA_COPY(buff, size)  do { RtlCopyMemory( gi_pxrxDMA.NTptr, buff, size * sizeof(ULONG) ); } while(0)

/*
    Debug output format:
        'operation( data ) @ <buffer number>:<buffer address> [Q <batch>:<queue>:<wait>]'

    Where:
        batch   = data waiting to be sent to the chip
        queue   = data still being assembled
        wait    = remaining space which has been waited for
*/

#define QUEUE_PXRX_DMA_TAG(tag, data)                                                \
    do {                                                                            \
        CHECK_PXRX_DMA_VALIDITY(CHECK_QUEUE, 2);                                    \
        DISPDBG((DBGLVL, "QUEUE_PXRX_DMA_TAG(  %s, 0x%08X) @ %d:0x%08X [Q %d:%d:%d]",    \
                 GET_TAG_STR(tag), data, gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr,        \
                 gi_pxrxDMA.NTdone - gi_pxrxDMA.P3at,                                \
                 gi_pxrxDMA.NTptr + 2 - gi_pxrxDMA.NTdone,                            \
                 glintInfo->NTwait - gi_pxrxDMA.NTptr - 2));                        \
        *(gi_pxrxDMA.NTptr) = NTCON_FAKE_DMA_DWORD(tag);                            \
        *(gi_pxrxDMA.NTptr + 1) = NTCON_FAKE_DMA_DWORD(data);                        \
        gi_pxrxDMA.NTptr += 2;                                                        \
        PXRX_DMA_POST_NOW;                                                            \
    } while(0)

#define QUEUE_PXRX_DMA_DWORD(data)                                                    \
    do {                                                                            \
        CHECK_PXRX_DMA_VALIDITY(CHECK_QUEUE, 1);                                    \
        DISPDBG((DBGLVL, "QUEUE_PXRX_DMA_DWORD(0x%08X) @ %d:0x%08X [Q %d:%d:%d]",    \
                 data, gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr,                            \
                 gi_pxrxDMA.NTdone - gi_pxrxDMA.P3at,                                \
                 gi_pxrxDMA.NTptr + 1 - gi_pxrxDMA.NTdone,                            \
                 glintInfo->NTwait - gi_pxrxDMA.NTptr - 1));                        \
        *(gi_pxrxDMA.NTptr++) = NTCON_FAKE_DMA_DWORD(data);                            \
        PXRX_DMA_POST_NOW;                                                            \
    } while(0)

#define QUEUE_PXRX_DMA_BUFF(buff, size)                                                \
    do {                                                                            \
        CHECK_PXRX_DMA_VALIDITY(CHECK_QUEUE, (size));                                \
        DISPDBG((DBGLVL, "QUEUE_PXRX_DMA_BUFF( 0x%08X + %d) @ %d:0x%08X [Q %d:%d:%d]",    \
                 buff, (size), gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr,                    \
                 gi_pxrxDMA.NTdone - gi_pxrxDMA.P3at,                                \
                 gi_pxrxDMA.NTptr + size - gi_pxrxDMA.NTdone,                        \
                 glintInfo->NTwait - gi_pxrxDMA.NTptr - size));                        \
        NTCON_FAKE_DMA_COPY( buff, (size) );                                        \
        gi_pxrxDMA.NTptr += size;                                                    \
        PXRX_DMA_POST_NOW;                                                            \
    } while(0)

#define QUEUE_PXRX_DMA_HOLD(tag, count)                                                \
    do {                                                                            \
        CHECK_PXRX_DMA_VALIDITY(CHECK_QUEUE, 1);                                    \
        DISPDBG((DBGLVL, "QUEUE_PXRX_DMA_HOLD( %s x %d) @ %d:0x%08X [Q %d:%d:%d]",    \
                 GET_TAG_STR(tag), count, gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr,        \
                 gi_pxrxDMA.NTdone - gi_pxrxDMA.P3at,                                \
                 gi_pxrxDMA.NTptr + 1 - gi_pxrxDMA.NTdone,                            \
                 glintInfo->NTwait - gi_pxrxDMA.NTptr - 1));                        \
        *(gi_pxrxDMA.NTptr++) = ASSEMBLE_PXRX_DMA_HOLD(NTCON_FAKE_DMA_DWORD(tag), count);    \
        PXRX_DMA_POST_NOW;                                                            \
    } while(0)

#define QUEUE_PXRX_DMA_INC(tag, count)                                                \
    do {                                                                            \
        CHECK_PXRX_DMA_VALIDITY(CHECK_QUEUE, 1);                                    \
        DISPDBG((DBGLVL, "QUEUE_PXRX_DMA_INC(  %s x %d) @ %d:0x%08X [Q %d:%d:%d]",    \
                 GET_TAG_STR(tag), count, gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr,        \
                 gi_pxrxDMA.NTdone - gi_pxrxDMA.P3at,                                \
                 gi_pxrxDMA.NTptr + 1 - gi_pxrxDMA.NTdone,                            \
                 glintInfo->NTwait - gi_pxrxDMA.NTptr - 1));                        \
        *(gi_pxrxDMA.NTptr++) = NTCON_FAKE_DMA_INC(tag, count);                        \
        PXRX_DMA_POST_NOW;                                                            \
    } while(0)

#define QUEUE_PXRX_DMA_DWORD_DELAYED(ptr)                                        \
    do {                                                                        \
        CHECK_PXRX_DMA_VALIDITY(CHECK_QUEUE, 1);                                \
        DISPDBG((DBGLVL, "QUEUE_PXRX_DMA_DELAYED(0x%08X) @ %d:0x%08X [Q %d:%d:%d]",    \
                 gi_pxrxDMA.NTptr, gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr,            \
                 gi_pxrxDMA.NTdone - gi_pxrxDMA.P3at,                            \
                 gi_pxrxDMA.NTptr + 1 - gi_pxrxDMA.NTdone,                        \
                 glintInfo->NTwait - gi_pxrxDMA.NTptr - 1));                    \
        ptr = gi_pxrxDMA.NTptr++;                                                \
    } while(0)

#define QUEUE_PXRX_DMA_BUFF_DELAYED(ptr, size)                                    \
    do {                                                                        \
        CHECK_PXRX_DMA_VALIDITY(CHECK_QUEUE, size);                                \
        ptr = gi_pxrxDMA.NTptr;                                                    \
        DISPDBG((DBGLVL, "QUEUE_PXRX_DMA_BUFF_DELAYED(0x%08X x %d) @ %d:0x%08X [Q %d:%d:%d]",    \
                 ptr, size, gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr,                \
                 gi_pxrxDMA.NTdone - gi_pxrxDMA.P3at,                            \
                 gi_pxrxDMA.NTptr + size - gi_pxrxDMA.NTdone,                    \
                 glintInfo->NTwait - gi_pxrxDMA.NTptr - size));                    \
        gi_pxrxDMA.NTptr += size;                                                \
    } while(0)

#define QUEUE_PXRX_DMA_INDEX2(Tag1, Tag2)                                       do { QUEUE_PXRX_DMA_DWORD( ASSEMBLE_PXRX_DMA_INDEX2(Tag1, Tag2) ); } while(0)
#define QUEUE_PXRX_DMA_INDEX3(Tag1, Tag2, Tag3)                                 do { QUEUE_PXRX_DMA_DWORD( ASSEMBLE_PXRX_DMA_INDEX3(Tag1, Tag2, Tag3) ); } while(0)
#define QUEUE_PXRX_DMA_INDEX4(Tag1, Tag2, Tag3, Tag4)                           do { QUEUE_PXRX_DMA_DWORD( ASSEMBLE_PXRX_DMA_INDEX4(Tag1, Tag2, Tag3, Tag4) ); } while(0)
#define QUEUE_PXRX_DMA_INDEX5(Tag1, Tag2, Tag3, Tag4, Tag5)                     do { QUEUE_PXRX_DMA_DWORD( ASSEMBLE_PXRX_DMA_INDEX5(Tag1, Tag2, Tag3, Tag4, Tag5) ); } while(0)
#define QUEUE_PXRX_DMA_INDEX6(Tag1, Tag2, Tag3, Tag4, Tag5, Tag6)               do { QUEUE_PXRX_DMA_DWORD( ASSEMBLE_PXRX_DMA_INDEX6(Tag1, Tag2, Tag3, Tag4, Tag5, Tag6) ); } while(0)
#define QUEUE_PXRX_DMA_INDEX7(Tag1, Tag2, Tag3, Tag4, Tag5, Tag6, Tag7)         do { QUEUE_PXRX_DMA_DWORD( ASSEMBLE_PXRX_DMA_INDEX7(Tag1, Tag2, Tag3, Tag4, Tag5, Tag6, Tag7) ); } while(0)
#define QUEUE_PXRX_DMA_INDEX8(Tag1, Tag2, Tag3, Tag4, Tag5, Tag6, Tag7, Tag8)   do { QUEUE_PXRX_DMA_DWORD( ASSEMBLE_PXRX_DMA_INDEX8(Tag1, Tag2, Tag3, Tag4, Tag5, Tag6, Tag7, Tag8) ); } while(0)

/*****************************************/
/*** Macros for waiting for free space ***/

#if PXRX_DMA_BUFFER_CHECK
#   define SET_WAIT_POINTER(dwords)     glintInfo->NTwait = gi_pxrxDMA.NTptr + (dwords)
#else
#   define SET_WAIT_POINTER(dwords)
#endif

#define WAIT_PXRX_DMA_TAGS(count)                                                                \
    do {                                                                                        \
        DISPDBG((DBGLVL, "WAIT_PXRX_DMA_TAGS(  %d) %d free @ %d:0x%08X [Q %d:%d]", (count),        \
                 (gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff] - gi_pxrxDMA.NTptr) / 2,            \
                 gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr,                                            \
                 gi_pxrxDMA.NTdone - gi_pxrxDMA.P3at, gi_pxrxDMA.NTptr - gi_pxrxDMA.NTdone));    \
        /* If no room, need to switch buffers */                                                \
        if( (gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff] - gi_pxrxDMA.NTptr) <= ((LONG) (count) * 2) ) {    \
            /* The current buffer is full so switch to a new one    */                            \
            SWITCH_PXRX_DMA_BUFFER;                                                                \
        }                                                                                        \
        ASSERTDD((gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff] - gi_pxrxDMA.NTptr) > ((LONG) (count) * 2), "WAIT_PXRX_DMA_TAGS: run out of space!");    \
        SET_WAIT_POINTER((count) * 2);                                                            \
        CHECK_PXRX_DMA_VALIDITY(CHECK_WAIT, (count) * 2);                                        \
    } while(0)

#define WAIT_PXRX_DMA_DWORDS(count)                                                                \
    do {                                                                                        \
        DISPDBG((DBGLVL, "WAIT_PXRX_DMA_DWORDS(%d) %d free @ %d:0x%08X [Q %d:%d]", (count),        \
                 gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff] - gi_pxrxDMA.NTptr,                    \
                 gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr,                                            \
                 gi_pxrxDMA.NTdone - gi_pxrxDMA.P3at, gi_pxrxDMA.NTptr - gi_pxrxDMA.NTdone));    \
        if( (gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff] - gi_pxrxDMA.NTptr) <= ((LONG) (count)) ) {        \
            /* The current buffer is full so switch to a new one    */                            \
            SWITCH_PXRX_DMA_BUFFER;                                                                \
        }                                                                                        \
        ASSERTDD((gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff] - gi_pxrxDMA.NTptr) > ((LONG) (count)), "WAIT_PXRX_DMA_DWORDS: run out of space!");        \
        SET_WAIT_POINTER(count);                                                                \
        CHECK_PXRX_DMA_VALIDITY(CHECK_WAIT, count);                                                \
    } while(0)

#define WAIT_FREE_PXRX_DMA_TAGS(count)                                                            \
    do {                                                                                        \
        /* Wait for space */                                                                    \
        WAIT_PXRX_DMA_TAGS((count));                                                            \
        /* Return the total free space */                                                        \
        count = (DWORD)((gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff] - gi_pxrxDMA.NTptr) / 2);   \
        SET_WAIT_POINTER((count) * 2);                                                            \
        CHECK_PXRX_DMA_VALIDITY(CHECK_WAIT, (count) * 2);                                        \
    } while(0)

#define WAIT_FREE_PXRX_DMA_DWORDS(count)                                                        \
    do {                                                                                        \
        /* Wait for space */                                                                    \
        WAIT_PXRX_DMA_DWORDS ((count));                                                            \
        /* Return the total free space */                                                        \
        count = (DWORD)(gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff] - gi_pxrxDMA.NTptr);                    \
        SET_WAIT_POINTER(count);                                                                \
        CHECK_PXRX_DMA_VALIDITY(CHECK_WAIT, count);                                                \
    } while(0)



/****************************************************/
/*** DMA buffer validity and other error checking ***/
#if PXRX_DMA_BUFFER_CHECK
#   define CHECK_PXRX_DMA_VALIDITY(type, count)     do { checkPXRXdmaValidBuffer(ppdev, glintInfo, type, count); } while(0)
#   define CHECK_QUEUE  0
#   define CHECK_WAIT   1
#   define CHECK_SEND   2
#   define CHECK_SWITCH 3

    void    checkPXRXdmaValidBuffer( PPDEV, GlintDataPtr, ULONG, ULONG );
#else   // PXRX_DMA_BUFFER_CHECK
#   define CHECK_PXRX_DMA_VALIDITY(type, count)     do { ; } while(0)
#endif  // PXRX_DMA_BUFFER_CHECK


/****************************************************/

/******************************************************/
/*** The actual DMA processing macros and functions ***/
    /*
        Function pointers:
            sendPXRXdmaForce                Will not return until the DMA has been started
            sendPXRXdmaQuery                Will send if there is FIFO space
            sendPXRXdmaBatch                Will only batch the data up
            switchPXRXdmaBuffer             Switches from one buffer to another
            waitPXRXdmaCompletedBuffer      Waits for next buffer to become available
    */

    void sendPXRXdmaFIFO                        ( PPDEV ppdev, GlintDataPtr glintInfo );
    void switchPXRXdmaBufferFIFO                ( PPDEV ppdev, GlintDataPtr glintInfo );
    void waitPXRXdmaCompletedBufferFIFO         ( PPDEV ppdev, GlintDataPtr glintInfo );

#   define SEND_PXRX_DMA_FORCE              do { ppdev->          sendPXRXdmaForce( ppdev, glintInfo ); } while(0)
#   define SEND_PXRX_DMA_QUERY              do { ppdev->          sendPXRXdmaQuery( ppdev, glintInfo ); } while(0)
#   define SEND_PXRX_DMA_BATCH              do { ppdev->          sendPXRXdmaBatch( ppdev, glintInfo ); } while(0)
#   define SWITCH_PXRX_DMA_BUFFER           do { ppdev->       switchPXRXdmaBuffer( ppdev, glintInfo ); } while(0)
#   define WAIT_PXRX_DMA_COMPLETED_BUFFER   do { ppdev->waitPXRXdmaCompletedBuffer( ppdev, glintInfo ); } while(0)

/************ End of PXRX DMA macros ************/
/************************************************/


#define LOAD_FOREGROUNDCOLOUR(value)                                                    \
    do {                                                                                \
        if( (value) != glintInfo->foregroundColour ) {                                    \
            glintInfo->foregroundColour = (value);                                        \
            QUEUE_PXRX_DMA_TAG( __GlintTagForegroundColor, glintInfo->foregroundColour );    \
        }                                                                                \
    } while(0)

#define LOAD_BACKGROUNDCOLOUR(value)                                                    \
    do {                                                                                \
        if( (value) != glintInfo->backgroundColour ) {                                    \
            glintInfo->backgroundColour = (value);                                        \
            QUEUE_PXRX_DMA_TAG( __GlintTagBackgroundColor, glintInfo->backgroundColour );    \
        }                                                                                \
    } while(0)

////////////////////////
// FBWriteBuffer[0-3] //
#define USE_FBWRITE_BUFFERS(mask)                                                        \
    do {                                                                                \
        if( ((mask) << 12) != (glintInfo->fbWriteMode & (15 << 12)) ) {                    \
            glintInfo->fbWriteMode &= ~(15 << 12);                                        \
            glintInfo->fbWriteMode |= ((mask) << 12);                                    \
            QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteMode, glintInfo->fbWriteMode );        \
        }                                                                                \
    } while(0)

#define LOAD_FBWRITE_OFFSET(buff, xy)                                                    \
    do {                                                                                \
        if( glintInfo->fbWriteOffset[buff] != (xy) ) {                                    \
            glintInfo->fbWriteOffset[buff] = (xy);                                        \
            QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferOffset0 + buff, (xy) );            \
            DISPDBG((7, "LOAD_FBWRITE_OFFSET(%d, %08x)", buff, (xy)));                    \
        }                                                                                \
    } while(0)

#define LOAD_FBWRITE_OFFSET_XY(buff, x, y)                                                \
    do {                                                                                \
        _temp_ul = MAKEDWORD_XY(x, y);                                                    \
        LOAD_FBWRITE_OFFSET(buff, _temp_ul);                                            \
    } while(0)

#define LOAD_FBWRITE_ADDR(buff, addr)                                                    \
    do {                                                                                \
        _temp_ul = (addr) << ppdev->cPelSize;                                            \
        if( glintInfo->fbWriteAddr[buff] != (ULONG)_temp_ul ) {                            \
            glintInfo->fbWriteAddr[buff] = (ULONG)_temp_ul;                                \
            QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferAddr0 + buff, _temp_ul);            \
            DISPDBG((7, "LOAD_FBWRITE_ADDR(%d, %08x)", buff, _temp_ul));                \
        }                                                                                \
    } while(0)

#define LOAD_FBWRITE_WIDTH(buff, width)                                                    \
    do {                                                                                \
        if( glintInfo->fbWriteWidth[buff] != (ULONG)(width) ) {                            \
            glintInfo->fbWriteWidth[buff] = (ULONG)(width);                                \
            QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferWidth0 + buff, (width) );        \
            DISPDBG((7, "LOAD_FBWRITE_WIDTH(%d, %08x)", buff, (width)));                \
        }                                                                                \
    } while(0)

// With rectangular heaps offscreen destinations always have DstPixelOrigin == 0 && xyOffsetDst != 0
// With linear heaps offscreen destinations always have DstPixelOrigin != 0
// For onscreen destinations both these values are guaranteed to be 0 for either heap method
#define OFFSCREEN_DST(ppdev)        (ppdev->bDstOffScreen)

#if(_WIN32_WINNT < 0x500)
#define OFFSCREEN_RECT_DST(ppdev)   OFFSCREEN_DST(ppdev)
#define OFFSCREEN_LIN_DST(ppdev)    (FALSE)
#else
#define OFFSCREEN_RECT_DST(ppdev)    (OFFSCREEN_DST(ppdev) && (ppdev->flStatus & STAT_LINEAR_HEAP) == 0)
#define OFFSCREEN_LIN_DST(ppdev)    (OFFSCREEN_DST(ppdev) && (ppdev->flStatus & STAT_LINEAR_HEAP))
#endif

#define SET_WRITE_BUFFERS                                                                       \
    do {                                                                                        \
        gi_pxrxDMA.bFlushRequired = FALSE;                                                        \
                                                                                                \
        if( (glintInfo->fbWriteOffset[0] != (ULONG) ppdev->xyOffsetDst) ||                         \
            (glintInfo->fbWriteWidth[0] != (ULONG) ppdev->DstPixelDelta) ||                        \
            (glintInfo->fbWriteAddr[0] != (ULONG) (ppdev->DstPixelOrigin << ppdev->cPelSize)) ||    \
            (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE) ||                                    \
            (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE)) {                                    \
                                                                                                \
            WAIT_PXRX_DMA_TAGS( 14 );                                                            \
            LOAD_FBWRITE_ADDR( 0, ppdev->DstPixelOrigin );                                        \
            LOAD_FBWRITE_WIDTH( 0, ppdev->DstPixelDelta );                                        \
            LOAD_FBWRITE_OFFSET( 0, ppdev->xyOffsetDst );                                        \
                                                                                                \
            /* Are we rendering to the screen? */                                                \
            if( OFFSCREEN_DST(ppdev) ) {                                                        \
                DISPDBG((DBGLVL, "PXRX: Offscreen bitmap"));                                \
                /* No. So make sure multiple writes are off */                                    \
                if( ((glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE) &&                        \
                    (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITING)) ||                        \
                    ((glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE) &&                            \
                    (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITING)) ) {                        \
                    DISPDBG((DBGLVL, "PXRX: Disabling multiple writes"));                    \
                                                                                                \
                    glintInfo->fbWriteMode = glintInfo->fbWriteModeSingleWrite;                    \
                    QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteMode, glintInfo->fbWriteMode );        \
                    glintInfo->pxrxFlags &= ~PXRX_FLAGS_DUAL_WRITING;                            \
                    glintInfo->pxrxFlags &= ~PXRX_FLAGS_STEREO_WRITING;                            \
                }                                                                                \
            } else {                                                                            \
                DISPDBG((DBGLVL, "PXRX: Visible screen"));                                    \
                /* Yes. So do we need to re-enable multiple writes? */                            \
                if( glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE ) {                            \
                    LOAD_FBWRITE_ADDR( 1, 0 );                                                    \
                    LOAD_FBWRITE_WIDTH( 1, ppdev->DstPixelDelta );                                \
                    LOAD_FBWRITE_ADDR( 2, 0 );                                                    \
                    LOAD_FBWRITE_WIDTH( 2, ppdev->DstPixelDelta );                                \
                    if( glintInfo->currentCSbuffer == 0 ) {                                        \
                        LOAD_FBWRITE_OFFSET( 1, glintInfo->backBufferXY );                        \
                        LOAD_FBWRITE_OFFSET( 2, glintInfo->backRightBufferXY );                    \
                    } else {                                                                    \
                        LOAD_FBWRITE_OFFSET( 1, 0 );                                            \
                        LOAD_FBWRITE_OFFSET( 2, glintInfo->frontRightBufferXY );                \
                    }                                                                            \
                }                                                                                \
                if( glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE ) {                            \
                    LOAD_FBWRITE_ADDR( 3, 0 );                                                    \
                    LOAD_FBWRITE_WIDTH( 3, ppdev->DstPixelDelta );                                \
                    if( glintInfo->currentCSbuffer == 0 ) {                                        \
                        LOAD_FBWRITE_OFFSET( 3, glintInfo->frontRightBufferXY );                \
                    }                                                                            \
                    else {                                                                        \
                        LOAD_FBWRITE_OFFSET( 3, glintInfo->backRightBufferXY );                \
                    }                                                                            \
                }                                                                                \
                if( (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE) &&                            \
                    (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE) ) {                        \
                    if( !((glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITING) &&                    \
                         (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITING)) ) {                \
                        DISPDBG((DBGLVL, "PXRX: Re-enabling dual stereo writes"));            \
                                                                                                \
                        glintInfo->fbWriteMode = glintInfo->fbWriteModeDualWriteStereo;            \
                        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteMode, glintInfo->fbWriteMode );    \
                        glintInfo->pxrxFlags |= PXRX_FLAGS_DUAL_WRITING;                        \
                        glintInfo->pxrxFlags |= PXRX_FLAGS_STEREO_WRITING;                        \
                    }                                                                            \
                }                                                                                \
                else if( glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE ) {                        \
                    if( !(glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITING) ) {                    \
                        DISPDBG((DBGLVL, "PXRX: Re-enabling dual writes"));                \
                                                                                                \
                        glintInfo->fbWriteMode = glintInfo->fbWriteModeDualWrite;                \
                        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteMode, glintInfo->fbWriteMode );    \
                        glintInfo->pxrxFlags |= PXRX_FLAGS_DUAL_WRITING;                        \
                    }                                                                            \
                }                                                                                \
                else if( glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE ) {                        \
                    if( !(glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITING) ) {                    \
                        DISPDBG((DBGLVL, "PXRX: Re-enabling stereo writes"));                \
                                                                                                \
                        glintInfo->fbWriteMode = glintInfo->fbWriteModeSingleWriteStereo;        \
                        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteMode, glintInfo->fbWriteMode );    \
                        glintInfo->pxrxFlags |= PXRX_FLAGS_STEREO_WRITING;                        \
                    }                                                                            \
                }                                                                                \
            }                                                                                    \
                                                                                                \
            DISPDBG((DBGLVL, "setWriteBuffers: current = %d", glintInfo->currentCSbuffer));                                            \
            DISPDBG((DBGLVL, "setWriteBuffers:   ppdev = 0x%08X, 0x%08X", ppdev->DstPixelOrigin, ppdev->xyOffsetDst));                \
            DISPDBG((DBGLVL, "setWriteBuffers: buff[0] = 0x%08X, 0x%08X", glintInfo->fbWriteAddr[0], glintInfo->fbWriteOffset[0]));    \
            DISPDBG((DBGLVL, "setWriteBuffers: buff[1] = 0x%08X, 0x%08X", glintInfo->fbWriteAddr[1], glintInfo->fbWriteOffset[1]));    \
        }                                                                                        \
    } while(0)

///////////////////////////
// FBDestReadBuffer[0-3] //
#define SET_READ_BUFFERS                                                                \
    do {                                                                                \
        LOAD_FBDEST_ADDR( 0, ppdev->DstPixelOrigin );                                    \
        LOAD_FBDEST_WIDTH( 0, ppdev->DstPixelDelta );                                    \
        LOAD_FBDEST_OFFSET( 0, ppdev->xyOffsetDst );                                    \
    } while(0)

#define LOAD_FBDEST_ADDR(buff, addr)                                                    \
    do {                                                                                \
        _temp_ul = (addr) << ppdev->cPelSize;                                            \
        if( glintInfo->fbDestAddr[buff] != (ULONG)_temp_ul ) {                            \
            glintInfo->fbDestAddr[buff] = (ULONG)_temp_ul;                                \
            QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferAddr0 + buff, _temp_ul );        \
            DISPDBG((7, "LOAD_FBDEST_ADDR(%d, %08x)", buff, _temp_ul));                    \
        }                                                                                \
    } while(0)

#define LOAD_FBDEST_OFFSET(buff, xy)                                                    \
    do {                                                                                \
        if( glintInfo->fbDestOffset[buff] != (xy) ) {                                    \
            glintInfo->fbDestOffset[buff] = (xy);                                        \
            QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferOffset0 + buff, (xy) );        \
            DISPDBG((7, "LOAD_FBDEST_OFFSET(%d, %08x)", buff, (xy)));                    \
        }                                                                                \
    } while(0)

#define LOAD_FBDEST_WIDTH(buff, width)                                                    \
    do {                                                                                \
        if( glintInfo->fbDestWidth[buff] != (ULONG)(width) ) {                            \
            glintInfo->fbDestWidth[buff] = (ULONG)(width);                                \
            QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferWidth0 + buff, (width) );        \
            DISPDBG((7, "LOAD_FBDEST_WIDTH(%d, %08x)", buff, (width)));                    \
        }                                                                                \
    } while(0)

////////////////////////
// FBSourceReadBuffer //
#define LOAD_FBSOURCE_OFFSET(xy)                                                        \
    do {                                                                                \
        if( glintInfo->fbSourceOffset != (xy) ) {                                        \
            glintInfo->fbSourceOffset = (xy);                                            \
            QUEUE_PXRX_DMA_TAG( __GlintTagFBSourceReadBufferOffset, (xy) );                \
            DISPDBG((7, "LOAD_FBSOURCE_OFFSET(%08x)", (xy)));                            \
        }                                                                                \
    } while(0)

#define LOAD_FBSOURCE_OFFSET_XY(x, y)                                                    \
    do {                                                                                \
        _temp_ul = MAKEDWORD_XY((x), (y));                                                \
        LOAD_FBSOURCE_OFFSET(_temp_ul);                                                    \
    } while(0)

#define LOAD_FBSOURCE_ADDR(addr)                                                        \
    do {                                                                                \
        _temp_ul = (addr) << ppdev->cPelSize;                                            \
        if( glintInfo->fbSourceAddr != _temp_ul ) {                                        \
            glintInfo->fbSourceAddr = _temp_ul;                                            \
            QUEUE_PXRX_DMA_TAG( __GlintTagFBSourceReadBufferAddr, _temp_ul );            \
            DISPDBG((7, "LOAD_FBSOURCE_ADDR(%08x)", _temp_ul));                            \
        }                                                                                \
    } while(0)

#define LOAD_FBSOURCE_WIDTH(width)                                                        \
    do {                                                                                \
        if( glintInfo->fbSourceWidth != (ULONG)(width) ) {                                \
            glintInfo->fbSourceWidth = (ULONG)(width);                                    \
            QUEUE_PXRX_DMA_TAG( __GlintTagFBSourceReadBufferWidth, (width) );            \
            DISPDBG((7, "LOAD_FBSOURCE_WIDTH(%08x)", (width)));                            \
        }                                                                                \
    } while(0)

// NB: Enable must never be set in 'mode' when calling LOAD_LUTMODE
#define LOAD_LUTMODE(mode)                                                                \
    do {                                                                                \
        if( glintInfo->config2D & __CONFIG2D_LUTENABLE )                                \
            (mode) |= (1 << 0);                                                            \
                                                                                        \
        if( (mode) != glintInfo->lutMode ) {                                            \
            glintInfo->lutMode = (mode);                                                \
            QUEUE_PXRX_DMA_TAG( __GlintTagLUTMode, glintInfo->lutMode );                \
        }                                                                                \
    } while(0)


// FLUSH_PXRX_PATCHED_RENDER2D
// We only need to send a continue new sub for the final primitive in a patched framebuffer and then only if
// it falls within a single patch in X and is rendered using the Render2D command. The preferred method is to
// have the message sent during the vblank period, the bFlushRequired flag is reset every SET_WRITE_BUFFERS 
// so that the message is only sent when the display driver becomes idle.
#define FLUSH_PXRX_PATCHED_RENDER2D(left, right)                                                              \
    do                                                                                                          \
    {                                                                                                          \
        if(glintInfo->pxrxFlags & (PXRX_FLAGS_PATCHING_FRONT | PXRX_FLAGS_PATCHING_BACK))                      \
        {                                                                                                      \
            if( INTERRUPTS_ENABLED && (glintInfo->pInterruptCommandBlock->Control & PXRX_SEND_ON_VBLANK_ENABLED) )      \
            {                                                                                                  \
                gi_pxrxDMA.bFlushRequired = TRUE;                                                                \
            }                                                                                                  \
            else                                                                                              \
            {                                                                                                  \
                ULONG PatchMask = 0x40 << (2 - ppdev->cPelSize);                                              \
                ULONG labs = left + (ppdev->xyOffsetDst & 0xFFFF);                                              \
                ULONG rabs = right + (ppdev->xyOffsetDst & 0xFFFF);                                              \
                                                                                                              \
                if((labs & PatchMask) == (rabs & PatchMask))                                                  \
                {                                                                                              \
                    WAIT_PXRX_DMA_TAGS(1);                                                                      \
                    QUEUE_PXRX_DMA_TAG(__GlintTagContinueNewSub, 0);                                          \
                }                                                                                              \
            }                                                                                                  \
        }                                                                                                      \
    }                                                                                                          \
    while(0)

// bits in the Config2D register (PXRX only)
#define __CONFIG2D_OPAQUESPANS          (1 << 0)
#define __CONFIG2D_MULTIRX              (1 << 1)
#define __CONFIG2D_USERSCISSOR          (1 << 2)
#define __CONFIG2D_FBDESTREAD           (1 << 3)
#define __CONFIG2D_ALPHABLEND           (1 << 4)
#define __CONFIG2D_DITHER               (1 << 5)
#define __CONFIG2D_LOGOP_FORE(op)       ((1 << 6) | ((op) << 7))
#define __CONFIG2D_LOGOP_FORE_ENABLE    (1 << 6)
#define __CONFIG2D_LOGOP_FORE_MASK      (31 << 6)
#define __CONFIG2D_LOGOP_BACK(op)       ((1 << 11) | ((op) << 12))
#define __CONFIG2D_LOGOP_BACK_ENABLE    (1 << 11)
#define __CONFIG2D_LOGOP_BACK_MASK      (31 << 11)
#define __CONFIG2D_CONSTANTSRC          (1 << 16)
#define __CONFIG2D_FBWRITE              (1 << 17)
#define __CONFIG2D_FBBLOCKING           (1 << 18)
#define __CONFIG2D_EXTERNALSRC          (1 << 19)
#define __CONFIG2D_LUTENABLE            (1 << 20)
#define __CONFIG2D_ENABLES              (__CONFIG2D_OPAQUESPANS | \
                                         __CONFIG2D_USERSCISSOR | \
                                         __CONFIG2D_FBDESTREAD  | \
                                         __CONFIG2D_ALPHABLEND  | \
                                         __CONFIG2D_DITHER      | \
                                         __CONFIG2D_CONSTANTSRC | \
                                         __CONFIG2D_FBWRITE     | \
                                         __CONFIG2D_FBBLOCKING  | \
                                         __CONFIG2D_EXTERNALSRC | \
                                         __CONFIG2D_LUTENABLE)

#define LOAD_CONFIG2D(value)                                               \
    do {                                                                   \
        if( (value) != glintInfo->config2D ) {                             \
            glintInfo->config2D = (value);                                 \
            QUEUE_PXRX_DMA_TAG( __GlintTagConfig2D, glintInfo->config2D ); \
        }                                                                  \
    } while(0)

// bits in the Render2D command (PXRX only)
#define __RENDER2D_WIDTH(width)             (INT16(width))
#define __RENDER2D_HEIGHT(height)           (INT16(height) << 16)
#define __RENDER2D_OP_NORMAL                (0 << 12)
#define __RENDER2D_OP_SYNCDATA              (1 << 12)
#define __RENDER2D_OP_SYNCBITMASK           (2 << 12)
#define __RENDER2D_OP_PATCHORDER_PATCHED    (3 << 12)
#define __RENDER2D_FBSRCREAD                (1 << 14)
#define __RENDER2D_SPANS                    (1 << 15)
#define __RENDER2D_INCY                     (1 << 29)
#define __RENDER2D_INCX                     (1 << 28)
#define __RENDER2D_AREASTIPPLE              (1 << 30)
#define __RENDER2D_WIDTH_MASK               (4095 << 0)
#define __RENDER2D_HEIGHT_MASK              (4095 << 16)

#define __RENDER2D_OP_PATCHORDER            glintInfo->render2Dpatching

extern const DWORD  LogicOpReadSrc[];            // indicates which logic ops need a source colour
extern const ULONG  render2D_NativeBlt[16];
extern const ULONG  render2D_FillSolid[16];
extern const ULONG  render2D_FillSolidDual[16];
extern const ULONG  config2D_FillColour[16];
extern const ULONG  config2D_FillColourDual[16];
extern const ULONG  config2D_FillSolid[16];
extern const ULONG  config2D_FillSolidVariableSpans[16];
extern const ULONG  config2D_NativeBlt[16];

void pxrxSetupFunctionPointers( PPDEV );
void pxrxRestore2DContext( PPDEV ppdev, BOOL switchingIn );
void pxrxSetupDualWrites_Patching( PPDEV ppdev );

void pxrxMonoDownloadRaw    ( PPDEV ppdev, ULONG AlignWidth, ULONG *pjSrc, LONG lSrcDelta, LONG cy );
void pxrxMonoDownloadRLE    ( PPDEV ppdev, ULONG AlignWidth, ULONG *pjSrc, LONG lSrcDelta, LONG cy );

VOID pxrxCopyBltNative  (PDEV*, RECTL*, LONG, DWORD, POINTL*, RECTL*);
VOID pxrxFillSolid      (PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR, POINTL*);
VOID pxrxFillPatMono    (PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR, POINTL*);
VOID pxrxFillPatColor   (PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR, POINTL*);
VOID pxrxXfer1bpp       (PDEV*, RECTL*, LONG, ULONG, ULONG, SURFOBJ*, POINTL*, RECTL*, XLATEOBJ*);
VOID pxrxXfer4bpp       (PDEV*, RECTL*, LONG, ULONG, ULONG, SURFOBJ*, POINTL*, RECTL*, XLATEOBJ*);
VOID pxrxXfer8bpp       (PDEV*, RECTL*, LONG, ULONG, ULONG, SURFOBJ*, POINTL*, RECTL*, XLATEOBJ*);
VOID pxrxXferImage      (PDEV*, RECTL*, LONG, ULONG, ULONG, SURFOBJ*, POINTL*, RECTL*, XLATEOBJ*);
VOID pxrxMaskCopyBlt    (PDEV*, RECTL*, LONG, SURFOBJ*, POINTL*, ULONG, ULONG, POINTL*, RECTL*);
VOID pxrxPatRealize     (PDEV*, RBRUSH*, POINTL*);
VOID pxrxMonoOffset     (PDEV*, RBRUSH*, POINTL*);
BOOL bGlintFastFillPolygon    (PDEV*, LONG, POINTFIX*, ULONG, ULONG, DWORD, CLIPOBJ*, RBRUSH*, POINTL*);
BOOL pxrxDrawLine       (PDEV*, LONG, LONG, LONG, LONG);
BOOL pxrxIntegerLine    (PDEV*, LONG, LONG, LONG, LONG);
BOOL pxrxContinueLine   (PDEV*, LONG, LONG, LONG, LONG);
BOOL pxrxInitStrips     (PDEV*, ULONG, DWORD, RECTL*);
VOID pxrxResetStrips    (PDEV*);
VOID pxrxRepNibbles     (PDEV*, RECTL*, CLIPOBJ*);
VOID pxrxFifoUpload     (PDEV*, LONG, RECTL*, SURFOBJ*, POINTL*, RECTL*);
VOID pxrxMemUpload  (PDEV*, LONG, RECTL*, SURFOBJ*, POINTL*, RECTL*);
VOID pxrxRLEFifoUpload(PPDEV ppdev, LONG crcl, RECTL *prcl, SURFOBJ *psoDst, POINTL *pptlSrc, RECTL *prclDst);
VOID pxrxCopyXfer24bpp  (PDEV *, SURFOBJ *, POINTL *, RECTL *, RECTL *, LONG);
VOID pxrxCopyXfer8bppLge(PDEV *, SURFOBJ *, POINTL *, RECTL *, RECTL *, LONG, XLATEOBJ *);
VOID pxrxCopyXfer8bpp   (PDEV *, SURFOBJ *, POINTL *, RECTL *, RECTL *, LONG, XLATEOBJ *);

BOOL bPxRxUncachedText              (PDEV* ppdev, GLYPHPOS* pgp, LONG cGlyph, ULONG ulCharInc);
BOOL bPxRxUncachedClippedText       (PDEV* ppdev, GLYPHPOS* pgp, LONG cGlyph, ULONG ulCharInc, CLIPOBJ *pco);

VOID p3r3FillSolidVariableSpans     (PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR, POINTL*);
VOID p3r3FillSolid32bpp             (PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR, POINTL*);
VOID p3r3FillPatMono32bpp           (PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR, POINTL*);
VOID p3r3FillPatMonoVariableSpans   (PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR, POINTL*);
VOID p3r3FillPatColor32bpp          (PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR, POINTL*);
VOID p3r3FillPatColor16bpp          (PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR, POINTL*);
VOID p3r3FillPatColorVariableSpans  (PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR, POINTL*);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\registry.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: registry.c
*
* Content: Routines to initialize the registry and lookup string values.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"

/******************************Public*Data*Struct**************************\
* BOOL bGlintQueryRegistryValueUlong
*
* Take a string and look up its value in the registry. We assume that the
* value fits into 4 bytes. Fill in the supplied DWORD pointer with the value.
*
* Returns:
*   TRUE if we found the string, FALSE if not. Note, if we failed to init
*   the registry the query funtion will simply fail and we act as though
*   the string was not defined.
*
\**************************************************************************/

BOOL
bGlintQueryRegistryValueUlong(PPDEV ppdev, LPWSTR valueStr, PULONG pData)
{
    ULONG ReturnedDataLength;
    ULONG inSize;
    ULONG outData;
    PWCHAR inStr;
    
    // get the string length including the NULL
    for (inSize = 2, inStr = valueStr; *inStr != 0; ++inStr, inSize += 2);

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_QUERY_REGISTRY_DWORD,
                           valueStr,                        // input buffer
                           inSize,
                           &outData,                        // output buffer
                           sizeof(ULONG),
                           &ReturnedDataLength))
    {
        DISPDBG((WRNLVL, "bGlintQueryRegistryValueUlong failed"));
        return(FALSE);
    }
    
    *pData = outData;
    DISPDBG((DBGLVL, "bGlintQueryRegistryValueUlong "
                     "returning 0x%x (ReturnedDataLength = %d)",
                     *pData, ReturnedDataLength));
    return(TRUE);
}

//@@BEGIN_DDKSPLIT
#if 0
/******************************Public*Data*Struct**************************\
* BOOL bGlintRegistryRetrieveGammaLUT
*
* Look up the registry to reload the saved gamma LUT into memory.
*
* Returns:
*   TRUE if we found the string, FALSE if not. Note, if we failed to init
*   the registry the query funtion will simply fail and we act as though
*   the string was not defined.
*
\**************************************************************************/

BOOL
bGlintRegistryRetrieveGammaLUT(
    PPDEV ppdev,
    PVIDEO_CLUT pScreenClut
    )
{
    ULONG ReturnedDataLength;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT,
                           NULL,         // input buffer
                           0,
                           pScreenClut,  // output buffer
                           MAX_CLUT_SIZE,
                           &ReturnedDataLength))
    {
        DISPDBG((-1, "IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT failed"));
        return(FALSE);
    }

    return(TRUE);
}

/******************************Public*Data*Struct**************************\
* BOOL bGlintRegistrySaveGammaLUT
*
* Save the gamma lut in the registry for later reloading.
*
* Returns:
*   TRUE if we found the string, FALSE if not. Note, if we failed to init
*   the registry the query funtion will simply fail and we act as though
*   the string was not defined.
*
\**************************************************************************/

BOOL
bGlintRegistrySaveGammaLUT(
    PPDEV ppdev,
    PVIDEO_CLUT pScreenClut
    )
{
    ULONG ReturnedDataLength;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_REG_SAVE_GAMMA_LUT,
                           pScreenClut,  // input buffer
                           MAX_CLUT_SIZE,
                           NULL,         // output buffer
                           0,
                           &ReturnedDataLength))
    {
        DISPDBG((-1, "IOCTL_VIDEO_REG_SAVE_GAMMA_LUT failed"));
        return(FALSE);
    }

    return(TRUE);
}

ULONG
GetOGLDriverVersion(PPDEV ppdev)
{
    return(2);
}
#endif
//@@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\pxrxxfer.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: pxrxXfer.c
*
* Content: Bit transfer code
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "ereg.h"
#include "pxrx.h"

#if _DEBUG
static BOOL trapOnMisAlignment = TRUE;

#define  TEST_DWORD_ALIGNED(ptr)                                           \
    do {                                                                   \
        ULONG   addr = (ULONG) ptr;                                        \
                                                                           \
        if( trapOnMisAlignment )                                           \
            ASSERTDD((addr & 3) == 0, "TEST_DWORD_ALIGNED(ptr) failed!");  \
        else                                                               \
        if( addr & 3 )                                                     \
            DISPDBG((-1, "TEST_DWORD_ALIGNED(0x%08X) is out by %d bytes!", \
                          addr, addr & 3));                                \
    } while(0)
#else
#   define  TEST_DWORD_ALIGNED(addr)        do { ; } while(0)
#endif

/**************************************************************************\
*
* VOID pxrxXfer1bpp
*
\**************************************************************************/
VOID pxrxXfer1bpp( 
    PPDEV    ppdev, 
    RECTL    *prcl, 
    LONG     count, 
    ULONG    fgLogicOp, 
    ULONG    bgLogicOp, 
    SURFOBJ  *psoSrc, 
    POINTL   *pptlSrc, 
    RECTL    *prclDst, 
    XLATEOBJ *pxlo ) 
{
    DWORD   config2D, render2D;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE    *pjSrcScan0;
    BYTE    *pjSrc;
    LONG    dxSrc;
    LONG    dySrc;
    LONG    xLeft;
    LONG    yTop;
    LONG    xOffset;
    ULONG   fgColor;
    ULONG   bgColor;
    RBRUSH_COLOR    rbc;
    GLINT_DECL;

    ASSERTDD(count > 0, "Can't handle zero rectangles");
    ASSERTDD(fgLogicOp <= 15, "Weird fg hardware Rop");
    ASSERTDD(bgLogicOp <= 15, "Weird bg hardware Rop");
    ASSERTDD(pptlSrc != NULL && psoSrc != NULL, "Can't have NULL sources");

    DISPDBG((DBGLVL, "pxrxXfer1bpp: original dstRect: (%d,%d) to (%d,%d)", 
                     prclDst->left, prclDst->top, 
                     prclDst->right, prclDst->bottom));

    dxSrc = pptlSrc->x - prclDst->left;
    dySrc = pptlSrc->y - prclDst->top;    // Add to destination to get source

    lSrcDelta = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;
    
    DISPDBG((DBGLVL, "bitmap baseAddr 0x%x, stride %d, w %d, h %d", 
                     pjSrcScan0, lSrcDelta, 
                     psoSrc->sizlBitmap.cx, psoSrc->sizlBitmap.cy));
    DISPDBG((DBGLVL, "fgColor 0x%x, bgColor 0x%x", 
                     pxlo->pulXlate[1], pxlo->pulXlate[0]));
    DISPDBG((DBGLVL, "fgLogicOp %d, bgLogicOp %d", 
                     fgLogicOp, bgLogicOp));

    fgColor = pxlo->pulXlate[1];
    bgColor = pxlo->pulXlate[0];

    // we get some common operations which are really noops. we can save
    // lots of time by cutting these out. As this happens a lot for masking
    // operations it's worth doing.

    if( ((fgLogicOp == __GLINT_LOGICOP_AND) && (fgColor == ppdev->ulWhite)) ||
        ((fgLogicOp == __GLINT_LOGICOP_OR ) && (fgColor == 0))              ||
        ((fgLogicOp == __GLINT_LOGICOP_XOR) && (fgColor == 0))               )
    {
        fgLogicOp = __GLINT_LOGICOP_NOOP;
    }

    // same for background
    if( ((bgLogicOp == __GLINT_LOGICOP_AND) && (bgColor == ppdev->ulWhite)) ||
        ((bgLogicOp == __GLINT_LOGICOP_OR ) && (bgColor == 0))              ||
        ((bgLogicOp == __GLINT_LOGICOP_XOR) && (bgColor == 0))               )
    {
        bgLogicOp = __GLINT_LOGICOP_NOOP;
    }

    if( (fgLogicOp == __GLINT_LOGICOP_NOOP) && 
        (bgLogicOp == __GLINT_LOGICOP_NOOP) ) 
    {
        DISPDBG((DBGLVL, "both ops are no-op so lets quit now"));
        return;
    }

    config2D = glintInfo->config2D;
    
    config2D &= ~(__CONFIG2D_LOGOP_FORE_ENABLE | 
                  __CONFIG2D_LOGOP_BACK_ENABLE | 
                  __CONFIG2D_ENABLES);
                  
    config2D |= __CONFIG2D_CONSTANTSRC | 
                __CONFIG2D_FBWRITE | 
                __CONFIG2D_USERSCISSOR;
                
    render2D = __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_OP_SYNCBITMASK;

    if( (fgLogicOp != __GLINT_LOGICOP_COPY) || 
        (bgLogicOp != __GLINT_LOGICOP_NOOP) ) 
    {
        config2D &= ~(__CONFIG2D_LOGOP_FORE_MASK | 
                      __CONFIG2D_LOGOP_BACK_MASK);
        config2D |= __CONFIG2D_OPAQUESPANS | 
                    __CONFIG2D_LOGOP_FORE(fgLogicOp) | 
                    __CONFIG2D_LOGOP_BACK(bgLogicOp);
        render2D |= __RENDER2D_SPANS;
    }

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 6 );

    if( LogicopReadDest[fgLogicOp] || LogicopReadDest[bgLogicOp] ) 
    {
        config2D |= __CONFIG2D_FBDESTREAD;
        SET_READ_BUFFERS;
    }

    if( LogicOpReadSrc[fgLogicOp] )
    {
        LOAD_FOREGROUNDCOLOUR( fgColor );
    }
    
    if( LogicOpReadSrc[bgLogicOp] )
    {
        LOAD_BACKGROUNDCOLOUR( bgColor );
    }

    LOAD_CONFIG2D( config2D );

    while( TRUE ) 
    {
        DISPDBG((DBGLVL, "mono download to rect (%d,%d) to (%d,%d)", 
                         prcl->left, prcl->top, prcl->right, prcl->bottom));

        yTop  = prcl->top;
        xLeft = prcl->left;
        cx = prcl->right - xLeft;
        cy = prcl->bottom - yTop;

        // pjSrc is first dword containing a bit to download. xOffset is the
        // offset to that bit. i.e. the bit offset from the previous 32bit
        // boundary at the left hand edge of the rectangle.
        xOffset = (xLeft + dxSrc) & 0x1f;
        pjSrc = (BYTE*)((UINT_PTR)(pjSrcScan0 +
                               (yTop  + dySrc) * lSrcDelta +
                               (xLeft + dxSrc) / 8  // byte aligned
                              ) & ~3);              // dword aligned

        DISPDBG((DBGLVL, "pjSrc 0x%x, lSrcDelta %d", pjSrc, lSrcDelta));
        DISPDBG((DBGLVL, "\txOffset %d, cx %d, cy %d", xOffset, cx, cy));

        // this algorithm downloads aligned 32-bit chunks from the
        // source but uses the scissor clip to define the edge of the
        // rectangle.
        //
        {
            ULONG   AlignWidth, LeftEdge;
            AlignWidth = (xOffset + cx + 31) & ~31;
            LeftEdge = xLeft - xOffset;

            DISPDBG((7, "AlignWidth %d", AlignWidth));

            WAIT_PXRX_DMA_DWORDS( 5 );
            QUEUE_PXRX_DMA_INDEX4( __GlintTagFillScissorMinXY, 
                                   __GlintTagFillScissorMaxXY, 
                                   __GlintTagFillRectanglePosition, 
                                   __GlintTagFillRender2D );

            QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(xLeft,             0) );
            QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(prcl->right, 0x7fff) );

            QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(LeftEdge,             yTop) );
            QUEUE_PXRX_DMA_DWORD( render2D | 
                                  __RENDER2D_WIDTH(AlignWidth) | 
                                  __RENDER2D_HEIGHT(cy) );
            SEND_PXRX_DMA_BATCH;

//@@BEGIN_DDKSPLIT
#if USE_RLE_DOWNLOADS
            pxrxMonoDownloadRLE( ppdev, 
                                 AlignWidth, 
                                 (ULONG *) pjSrc, 
                                 lSrcDelta >> 2, 
                                 cy );
#else
//@@END_DDKSPLIT
            pxrxMonoDownloadRaw( ppdev, 
                                 AlignWidth, 
                                 (ULONG *) pjSrc, 
                                 lSrcDelta >> 2, 
                                 cy );
//@@BEGIN_DDKSPLIT                                 
#endif
//@@END_DDKSPLIT
        }

        if( --count == 0 )
        {
            break;
        }

        prcl++;
    }

    // Reset the scissor maximums:
    if( ppdev->cPelSize == GLINTDEPTH32 ) {
        WAIT_PXRX_DMA_TAGS( 1 );
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY, 0x7FFF7FFF );
//@@BEGIN_DDKSPLIT        
//      SEND_PXRX_DMA_BATCH;
//@@END_DDKSPLIT
    }

    FLUSH_PXRX_PATCHED_RENDER2D(prclDst->left, prclDst->right);
    SEND_PXRX_DMA_BATCH;

    DISPDBG((DBGLVL, "pxrxXfer1bpp returning"));
}

/**************************************************************************\
*
* void pxrxMonoDownloadRaw
*
\**************************************************************************/
void pxrxMonoDownloadRaw( 
    PPDEV ppdev, 
    ULONG AlignWidth, 
    ULONG *pjSrc, 
    LONG lSrcDelta, 
    LONG cy ) 
{
    GLINT_DECL;

    if( AlignWidth == 32 ) 
    {
        LONG    nSpaces = 0;
        ULONG   bits;
        DISPDBG((DBGLVL, "Doing Single Word per scan download"));
        do 
        {
            nSpaces = 10;
            WAIT_FREE_PXRX_DMA_DWORDS( nSpaces );
            
            if( cy < --nSpaces )
            {
                nSpaces = cy;
            }
            
            cy -= nSpaces;

            QUEUE_PXRX_DMA_HOLD( __GlintTagBitMaskPattern, nSpaces );
            
            while( --nSpaces >= 0 ) 
            {
                TEST_DWORD_ALIGNED( pjSrc );
                QUEUE_PXRX_DMA_DWORD( *pjSrc );
                pjSrc += lSrcDelta;
            }
            
            SEND_PXRX_DMA_BATCH;
        } while( cy > 0 );        
    } 
    else 
    {
        // multiple 32 bit words per scanline. convert the delta to the
        // delta as we need it at the end of each line by subtracting the
        // width in bytes of the data we're downloading. Note, pjSrc
        // is always 1 LONG short of the end of the line because we break
        // before adding on the last ULONG. Thus, we subtract sizeof(ULONG)
        // from the original adjustment.
        LONG    nScan = AlignWidth >> 5;
        LONG    nRemainder;
        ULONG   bits;

        DISPDBG((7, "Doing Multiple Word per scan download"));
        while( TRUE ) 
        {
            WAIT_PXRX_DMA_DWORDS( nScan + 1 );
            QUEUE_PXRX_DMA_HOLD( __GlintTagBitMaskPattern, nScan );
            TEST_DWORD_ALIGNED( pjSrc );
            QUEUE_PXRX_DMA_BUFF( pjSrc, nScan );
            SEND_PXRX_DMA_BATCH;
            pjSrc += lSrcDelta;

            if( --cy == 0 )
            {
                break;
            }
        }
    }
}


/**************************************************************************\
*
* VOID pxrxXfer8bpp
*
\**************************************************************************/
VOID pxrxXfer8bpp( 
    PPDEV ppdev, 
    RECTL *prcl, 
    LONG count, 
    ULONG logicOp, 
    ULONG bgLogicOp, 
    SURFOBJ *psoSrc, 
    POINTL *pptlSrc, 
    RECTL *prclDst, 
    XLATEOBJ *pxlo ) 
{
    ULONG       config2D, render2D, lutMode, pixelSize;
    BOOL        invalidLUT = FALSE;
    LONG        dx, dy, cy;
    LONG        lSrcDelta, lSrcDeltaDW, lTrueDelta, alignOff;
    ULONG       AlignWidth, LeftEdge;
    BYTE*       pjSrcScan0;
    ULONG*      pjSrc;
    UINT_PTR    startPos;
    LONG        cPelInv;
    ULONG       ul;
    LONG        nRemainder;
//@@BEGIN_DDKSPLIT
#if USE_RLE_DOWNLOADS
    ULONG       len, data, holdCount;
    ULONG       *tagPtr;
#endif
//@@END_DDKSPLIT
    GLINT_DECL;

    DISPDBG((DBGLVL, "pxrxXfer8bpp(): src = (%d,%d) -> (%d,%d), "
                     "count = %d, logicOp = %d, palette id = %d", 
                     prcl->left, prcl->right, prcl->top, prcl->bottom, 
                     count, logicOp, pxlo->iUniq));

    // Set up the LUT table:

    if( (ppdev->PalLUTType != LUTCACHE_XLATE) || 
        (ppdev->iPalUniq != pxlo->iUniq) ) 
    {
        // Someone has hijacked the LUT so we need to invalidate it:
        ppdev->PalLUTType = LUTCACHE_XLATE;
        ppdev->iPalUniq = pxlo->iUniq;
        invalidLUT = TRUE;
    } 
    else 
    {
        DISPDBG((DBGLVL, "pxrxXfer8bpp: reusing cached xlate"));
    }

    WAIT_PXRX_DMA_TAGS( 1 + 1 );

    lutMode = glintInfo->lutMode & ~((3 << 2) | (1 << 4) | (7 << 8));
    lutMode |= (ppdev->cPelSize + 2) << 8;
    LOAD_LUTMODE( lutMode );

    if( invalidLUT ) 
    {
        ULONG   *pulXlate = pxlo->pulXlate;
        LONG    cEntries = 256;

        QUEUE_PXRX_DMA_TAG( __PXRXTagLUTIndex, 0 );

        if( ppdev->cPelSize == 0 ) 
        {
            // 8bpp
            WAIT_PXRX_DMA_TAGS( cEntries );

            do 
            {
                ul = *(pulXlate++);
                ul |= ul << 8;
                ul |= ul << 16;
                QUEUE_PXRX_DMA_TAG( __PXRXTagLUTData, ul );
            } while( --cEntries );
        } 
        else if( ppdev->cPelSize == 1 ) 
        {    
            // 16bpp
            WAIT_PXRX_DMA_TAGS( cEntries );

            do 
            {
                ul = *(pulXlate++);
                ul |= ul << 16;
                QUEUE_PXRX_DMA_TAG( __PXRXTagLUTData, ul );
            } while( --cEntries );
        } 
        else 
        {
            WAIT_PXRX_DMA_DWORDS( 1 + cEntries );

            QUEUE_PXRX_DMA_HOLD( __PXRXTagLUTData, cEntries );
            QUEUE_PXRX_DMA_BUFF( pulXlate, cEntries );
        }
    }

    config2D = __CONFIG2D_FBWRITE     | 
               __CONFIG2D_USERSCISSOR | 
               __CONFIG2D_EXTERNALSRC | 
               __CONFIG2D_LUTENABLE;
               
    render2D = __RENDER2D_INCX        |  
               __RENDER2D_INCY        | 
               __RENDER2D_OP_SYNCDATA | 
               __RENDER2D_SPANS;

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 6 );

    if( logicOp != __GLINT_LOGICOP_COPY ) 
    {
        config2D |= __CONFIG2D_LOGOP_FORE(logicOp) | __CONFIG2D_FBWRITE;
        render2D |= __RENDER2D_SPANS;

        if( LogicopReadDest[logicOp] ) 
        {
            config2D |= __CONFIG2D_FBDESTREAD;
            SET_READ_BUFFERS;
        }
    }

    LOAD_CONFIG2D( config2D );

//@@BEGIN_DDKSPLIT
#if USE_RLE_DOWNLOADS
    QUEUE_PXRX_DMA_TAG( __GlintTagDownloadTarget, __GlintTagColor );
#endif
//@@END_DDKSPLIT

    cPelInv = 2 - ppdev->cPelSize;
    pixelSize = (1 << 31)       | // Everything before the LUT runs at 8bpp
                (2 << 2)        | 
                (2 << 4)        | 
                (2 << 6)        |        
                (cPelInv << 8)  | 
                (cPelInv << 10) | 
                (cPelInv << 12) | 
                (cPelInv << 14);
                
    QUEUE_PXRX_DMA_TAG( __GlintTagPixelSize, pixelSize );

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    while( TRUE ) 
    {
        DISPDBG((DBGLVL, "download to rect (%d,%d) to (%d,%d)", 
                         prcl->left, prcl->top, 
                         prcl->right, prcl->bottom));

        // 8bpp => 1 pixel per byte => 4 pixels per dword

        // Assume source bitmap width is dword aligned
        ASSERTDD((lSrcDelta & 3) == 0, 
                 "pxrxXfer8bpp: SOURCE BITMAP WIDTH IS NOT DWORD ALIGNED!!!");

        startPos = (((UINT_PTR) pjSrcScan0) + ((prcl->top + dy) * lSrcDelta)) 
                        + (prcl->left + dx);    // pointer to first pixel, 
                                                // in pixels/bytes
        pjSrc    = (ULONG *) (startPos & ~3);   // dword pointer to dword 
                                                // aligned first pixel

        if(NULL == pjSrc)
        {
            DISPDBG((ERRLVL, "ERROR: pxrxXfer8bpp return ,has pjSrc NULL"));
            return;
        }
        
        alignOff = (ULONG)(startPos & 3); // number of pixels past dword 
                                          // alignment of a scanline
        LeftEdge = prcl->left - alignOff; // dword aligned left edge in pixels
        AlignWidth = ((prcl->right - LeftEdge) + 3) & ~3; // dword aligned width 
                                                          // in pixels
        cy = prcl->bottom - prcl->top;    // number of scanlines to do

        DISPDBG((DBGLVL, "pjSrcScan0 = 0x%08X, "
                         "startPos = 0x%08X, pjSrc = 0x%08X", 
                         pjSrcScan0, startPos, pjSrc));
        DISPDBG((DBGLVL, "offset = %d pixels", alignOff));
        DISPDBG((DBGLVL, "Aligned rect = (%d -> %d) => %d pixels => %d dwords", 
                         LeftEdge, LeftEdge + AlignWidth, 
                         AlignWidth, AlignWidth >> 2));

        WAIT_PXRX_DMA_TAGS( 4 );

        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMinXY,         
                                    MAKEDWORD_XY(prcl->left,       0) );
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY,         
                                    MAKEDWORD_XY(prcl->right, 0x7fff) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    
                                    MAKEDWORD_XY(LeftEdge, prcl->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             
                                    render2D                     | 
                                    __RENDER2D_WIDTH(AlignWidth) | 
                                    __RENDER2D_HEIGHT(cy) );
        SEND_PXRX_DMA_BATCH;

        AlignWidth  >>= 2;            // dword aligned width in dwords
        lSrcDeltaDW = lSrcDelta >> 2; // scanline delta in dwords 
                                      // (start to start)
        lTrueDelta  = lSrcDeltaDW - AlignWidth; // scanline delta in dwords 
                                                // (end   to start)
        DISPDBG((DBGLVL, "Delta = %d bytes = %d dwords -> %d - %d dwords", 
                         lSrcDelta, lSrcDeltaDW, lTrueDelta, AlignWidth));

//@@BEGIN_DDKSPLIT
#if USE_RLE_DOWNLOADS
        // Do an RLE download:
        tagPtr = NULL;

        do 
        {
            WAIT_PXRX_DMA_TAGS( AlignWidth + 1 );

            nRemainder = AlignWidth;
            while( nRemainder-- ) 
            {
                TEST_DWORD_ALIGNED( pjSrc );
                data = *(pjSrc++);
                len = 1;

                TEST_DWORD_ALIGNED( pjSrc );
                while( nRemainder && (*pjSrc == data) ) 
                {
                    pjSrc++;
                    len++;
                    nRemainder--;
                    TEST_DWORD_ALIGNED( pjSrc );
                }

                if( len >= 4 ) 
                {
                    if( tagPtr ) 
                    {
                        *tagPtr = ASSEMBLE_PXRX_DMA_HOLD( __GlintTagColor, 
                                                          holdCount );
                        tagPtr = NULL;
                    }

                    QUEUE_PXRX_DMA_INDEX2( __GlintTagRLData, 
                                           __GlintTagRLCount );
                    QUEUE_PXRX_DMA_DWORD( data );
                    QUEUE_PXRX_DMA_DWORD( len );
                    len = 0;
                } 
                else 
                {
                    if( !tagPtr ) 
                    {
                        QUEUE_PXRX_DMA_DWORD_DELAYED( tagPtr );
                        holdCount = 0;
                    }

                    holdCount += len;
                    while( len-- )
                    {
                        QUEUE_PXRX_DMA_DWORD( data );
                    }
                }
            }

            if( tagPtr ) 
            {
                *tagPtr = ASSEMBLE_PXRX_DMA_HOLD( __GlintTagColor, 
                                                  holdCount );
                tagPtr = NULL;
            }
            pjSrc += lTrueDelta;
            SEND_PXRX_DMA_BATCH;
        } while( --cy > 0 );
#else
//@@END_DDKSPLIT
        // Do a raw download:
        while( TRUE ) 
        {
            DISPDBG((DBGLVL, "cy = %d", cy));

            WAIT_PXRX_DMA_DWORDS( AlignWidth + 1 );
            QUEUE_PXRX_DMA_HOLD( __GlintTagColor, AlignWidth );
            TEST_DWORD_ALIGNED( pjSrc );
            QUEUE_PXRX_DMA_BUFF( pjSrc, AlignWidth );
            SEND_PXRX_DMA_BATCH;

            if( --cy == 0 )
            {
                break;
            }

            pjSrc += lSrcDeltaDW;
        }
//@@BEGIN_DDKSPLIT        
#endif
//@@END_DDKSPLIT

        if( --count == 0 )
        {
            break;
        }

        prcl++;
    }

    // Reset some defaults:
    WAIT_PXRX_DMA_TAGS( 2 );
    QUEUE_PXRX_DMA_TAG( __GlintTagPixelSize, cPelInv );
    if( ppdev->cPelSize == GLINTDEPTH32 )
    {
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY, 0x7FFF7FFF );
    }

    SEND_PXRX_DMA_BATCH;

    DISPDBG((DBGLVL, "pxrxXfer8bpp return"));
}

/**************************************************************************\
*
* VOID pxrxXferImage
*
\**************************************************************************/
VOID pxrxXferImage( 
    PPDEV ppdev, 
    RECTL *prcl, 
    LONG count, 
    ULONG logicOp, 
    ULONG bgLogicOp, 
    SURFOBJ *psoSrc, 
    POINTL *pptlSrc, 
    RECTL *prclDst, 
    XLATEOBJ *pxlo ) 
{
    DWORD       config2D, render2D;
    LONG        dx, dy, cy;
    LONG        lSrcDelta, lTrueDelta, lSrcDeltaDW, alignOff;
    BYTE*       pjSrcScan0;
    ULONG*      pjSrc;
    UINT_PTR    startPos;
    LONG        cPel, cPelInv;
    ULONG       cPelMask;
    ULONG       AlignWidth, LeftEdge;
    LONG        nRemainder;
//@@BEGIN_DDKSPLIT    
#if USE_RLE_DOWNLOADS
    ULONG       len, data, holdCount;
    ULONG       *tagPtr;
#endif
//@@END_DDKSPLIT
    GLINT_DECL;

    SEND_PXRX_DMA_FORCE;

    ASSERTDD((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL), 
             "Can handle trivial xlate only");
    ASSERTDD(psoSrc->iBitmapFormat == ppdev->iBitmapFormat, 
             "Source must be same colour depth as screen");
    ASSERTDD(count > 0, 
             "Can't handle zero rectangles");
    ASSERTDD(logicOp <= 15, 
             "Weird hardware Rop");

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top; // Add to destination to get source
    cPel = ppdev->cPelSize;         // number of bytes per pixel = 1 << cPel
    cPelInv = 2 - cPel;             // number of pixels per byte = 1 << cPelInv
                                    // (pixels -> dwords = >> cPenInv)
    cPelMask = (1 << cPelInv) - 1;  // mask to obtain number of pixels 
                                    // past a dword

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    DISPDBG((DBGLVL, "pxrxXferImage with logic op %d for %d rects", 
                     logicOp, count));

    config2D = glintInfo->config2D & ~(__CONFIG2D_LOGOP_FORE_ENABLE | 
                                       __CONFIG2D_LOGOP_BACK_ENABLE | 
                                       __CONFIG2D_ENABLES);
    config2D |= __CONFIG2D_FBWRITE    | 
                __CONFIG2D_USERSCISSOR;
    render2D = __RENDER2D_INCX        | 
               __RENDER2D_INCY        | 
               __RENDER2D_OP_SYNCDATA | 
               __RENDER2D_SPANS;
    
    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 5 );

    if( logicOp != __GLINT_LOGICOP_COPY ) 
    {
        config2D &= ~__CONFIG2D_LOGOP_FORE_MASK;
        config2D |= __CONFIG2D_LOGOP_FORE(logicOp) | 
                    __CONFIG2D_EXTERNALSRC;

        if( LogicopReadDest[logicOp] ) 
        {
            config2D |= __CONFIG2D_FBDESTREAD;
            SET_READ_BUFFERS;
        }
    }

    LOAD_CONFIG2D( config2D );

//@@BEGIN_DDKSPLIT
#if USE_RLE_DOWNLOADS
    QUEUE_PXRX_DMA_TAG( __GlintTagDownloadTarget, 
                        __GlintTagColor );
#endif
//@@END_DDKSPLIT

    while( TRUE ) 
    {
        cy = prcl->bottom - prcl->top;

        DISPDBG((DBGLVL, "download to rect (%d,%d) to (%d,%d)", 
                         prcl->left, prcl->top, prcl->right, prcl->bottom));

        ASSERTDD((lSrcDelta & 3) == 0, 
                 "pxrxXferImage: SOURCE BITMAP WIDTH IS NOT DWORD ALIGNED!!!");

        // pjSrc points to the first pixel to copy
        // lTrueDelta is the additional amount to add onto the pjSrc pointer
        //    when we get to the end of the scanline.
        startPos = ((UINT_PTR) pjSrcScan0) + ((prcl->top + dy) * lSrcDelta) + 
                                                  ((prcl->left + dx) << cPel);
        alignOff = ((ULONG) (startPos & 3)) >> cPel;  // number of pixels past
                                                      // dword aligned start
        pjSrc = (ULONG *) (startPos & ~3); // dword aligned pointer to 1st pixel
        
        if(NULL == pjSrc)
        {
            DISPDBG((ERRLVL, "ERROR: "
                             "pxrxXferImage return because of pjSrc NULL"));
            return;
        }        
        
        // dword aligned left edge in pixels
        LeftEdge    = prcl->left - alignOff;                            
        // dword aligned width in pixels
        AlignWidth  = (prcl->right - LeftEdge + cPelMask) & ~cPelMask;    
        
        DISPDBG((DBGLVL, "Aligned rect = (%d -> %d) => %d pixels", 
                         LeftEdge, LeftEdge + AlignWidth, AlignWidth));
        DISPDBG((DBGLVL, "pjSrcScan0 = 0x%08X, "
                         "pjSrc = 0x%08X, alignOff = %d pixels", 
                         pjSrcScan0, pjSrc, alignOff));

        ASSERTDD( ((UINT_PTR) pjSrcScan0) + ((prcl->top + dy) * lSrcDelta) + 
                              ((LeftEdge + dx) << cPel) == (UINT_PTR) pjSrc,
                  "pxrxXferImage: "
                  "Aligned left edge does not match aligned pjSrc!" );

        WAIT_PXRX_DMA_DWORDS( 5 );

        QUEUE_PXRX_DMA_INDEX4( __GlintTagFillScissorMinXY, 
                               __GlintTagFillScissorMaxXY, 
                               __GlintTagFillRectanglePosition, 
                               __GlintTagFillRender2D );
                               
        QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(prcl->left, 0) );
        QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(prcl->right, 0x7fff) );
        QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(LeftEdge, prcl->top) );
        QUEUE_PXRX_DMA_DWORD( render2D | 
                              __RENDER2D_WIDTH(AlignWidth) | 
                              __RENDER2D_HEIGHT(cy) );
        SEND_PXRX_DMA_BATCH;

        AlignWidth >>= cPelInv;                 // dword aligned width in dwords
        lSrcDeltaDW = lSrcDelta >> 2;           // scanline delta in dwords 
                                                //(start to start)
        lTrueDelta  = lSrcDeltaDW - AlignWidth; // scanline delta in dwords 
                                                // (end   to start)
                                                
        DISPDBG((DBGLVL, "Delta = %d bytes = %d dwords -> %d - %d dwords", 
                         lSrcDelta, lSrcDeltaDW, lTrueDelta, AlignWidth));

//@@BEGIN_DDKSPLIT
#if USE_RLE_DOWNLOADS
        // Do an RLE download:
        tagPtr = NULL;

        do 
        {
            WAIT_PXRX_DMA_TAGS( AlignWidth + 1 );

            nRemainder = AlignWidth;
            while( nRemainder-- ) 
            {
                TEST_DWORD_ALIGNED( pjSrc );
                data = *(pjSrc++);
                len = 1;

                TEST_DWORD_ALIGNED( pjSrc );
                while( nRemainder && (*pjSrc == data) ) 
                {
                    pjSrc++;
                    len++;
                    nRemainder--;
                    TEST_DWORD_ALIGNED( pjSrc );
                }

                if( len >= 4 ) 
                {
                    if( tagPtr ) 
                    {
                        *tagPtr = ASSEMBLE_PXRX_DMA_HOLD( __GlintTagColor, 
                                                          holdCount );
                        tagPtr = NULL;
                    }

                    QUEUE_PXRX_DMA_INDEX2( __GlintTagRLData, 
                                           __GlintTagRLCount );
                                           
                    QUEUE_PXRX_DMA_DWORD( data );
                    QUEUE_PXRX_DMA_DWORD( len );
                    len = 0;
                    
                } 
                else 
                {
                    if( !tagPtr ) 
                    {
                        QUEUE_PXRX_DMA_DWORD_DELAYED( tagPtr );
                        holdCount = 0;
                    }

                    holdCount += len;
                    while( len-- )
                    {
                        QUEUE_PXRX_DMA_DWORD( data );
                    }
                }
            }

            if( tagPtr ) 
            {
                *tagPtr = ASSEMBLE_PXRX_DMA_HOLD( __GlintTagColor, holdCount );
                tagPtr = NULL;
            }
            pjSrc += lTrueDelta;
//          SEND_PXRX_DMA_BATCH;
        } while( --cy > 0 );
#else
//@@END_DDKSPLIT
        // Do a raw download:
        while( TRUE ) 
        {
            DISPDBG((DBGLVL, "cy = %d", cy));

            WAIT_PXRX_DMA_DWORDS( AlignWidth + 1 );
            QUEUE_PXRX_DMA_HOLD( __GlintTagColor, AlignWidth );
            TEST_DWORD_ALIGNED( pjSrc );
            QUEUE_PXRX_DMA_BUFF( pjSrc, AlignWidth );
//          SEND_PXRX_DMA_BATCH;

            if( --cy == 0 )
            {
                break;
            }
            pjSrc += lSrcDeltaDW;
        }
//@@BEGIN_DDKSPLIT        
#endif
//@@END_DDKSPLIT

        if( --count == 0 )
        {
            break;
        }

        prcl++;
    }

    // Reset the scissor maximums:
    if( ppdev->cPelSize == GLINTDEPTH32 ) 
    {
        WAIT_PXRX_DMA_TAGS( 1 );
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY, 0x7FFF7FFF );
//      SEND_PXRX_DMA_BATCH;
    }
    FLUSH_PXRX_PATCHED_RENDER2D(prclDst->left, prclDst->right);
    SEND_PXRX_DMA_BATCH;

    DISPDBG((DBGLVL, "pxrxXferImage return"));
}

/**************************************************************************\
*
* VOID pxrxXfer4bpp
*
\**************************************************************************/      
VOID pxrxXfer4bpp( 
    PPDEV ppdev, 
    RECTL *prcl, 
    LONG count, 
    ULONG logicOp, 
    ULONG bgLogicOp, 
    SURFOBJ *psoSrc, 
    POINTL *pptlSrc, 
    RECTL *prclDst, 
    XLATEOBJ *pxlo ) 
{
    ULONG       config2D, render2D, lutMode, pixelSize;
    BOOL        invalidLUT = FALSE;
    LONG        dx, dy;
    LONG        cy;
    BYTE*       pjSrcScan0;
    ULONG*      pjSrc;
    LONG        cPelInv;
    ULONG       ul;
    ULONG       AlignWidth, LeftEdge;
    UINT_PTR    startPos;
    LONG        nRemainder;
    LONG        lSrcDelta, lSrcDeltaDW;
    LONG        alignOff;
    GLINT_DECL;

    DISPDBG((DBGLVL, "pxrxXfer4bpp(): src = (%d,%d) -> (%d,%d), count = %d, "
                     "logicOp = %d, palette id = %d", 
                     prcl->left, prcl->right, prcl->top, prcl->bottom, count, 
                     logicOp, pxlo->iUniq));

    // Set up the LUT table:
    if( (ppdev->PalLUTType != LUTCACHE_XLATE) || 
        (ppdev->iPalUniq != pxlo->iUniq) ) 
    {
        // Someone has hijacked the LUT so we need to invalidate it:
        ppdev->PalLUTType = LUTCACHE_XLATE;
        ppdev->iPalUniq = pxlo->iUniq;
        invalidLUT = TRUE;
    } 
    else 
    {
        DISPDBG((DBGLVL, "pxrxXfer4bpp: reusing cached xlate"));
    }

    WAIT_PXRX_DMA_TAGS( 1 + 1 + 16 );

    lutMode = glintInfo->lutMode & ~((3 << 2) | (1 << 4) | (7 << 8));
    lutMode |= (ppdev->cPelSize + 2) << 8;
    LOAD_LUTMODE( lutMode );

    if( invalidLUT ) 
    {
        ULONG   *pulXlate = pxlo->pulXlate;
        LONG    cEntries = 16;

        QUEUE_PXRX_DMA_TAG( __PXRXTagLUTIndex, 0 );

        if( ppdev->cPelSize == 0 )    // 8bpp
        {
            do 
            {
                ul = *(pulXlate++);
                ul |= ul << 8;
                ul |= ul << 16;
                QUEUE_PXRX_DMA_TAG( __PXRXTagLUTData, ul );
            } while( --cEntries );
        }
        else if( ppdev->cPelSize == 1 )    // 16bpp
        {
            do 
            {
                ul = *(pulXlate++);
                ul |= ul << 16;
                QUEUE_PXRX_DMA_TAG( __PXRXTagLUTData, ul );
            } while( --cEntries );
        }
        else 
        {
            QUEUE_PXRX_DMA_HOLD( __PXRXTagLUTData, cEntries );
            QUEUE_PXRX_DMA_BUFF( pulXlate, cEntries );
        }
    }

    config2D = glintInfo->config2D & ~(__CONFIG2D_LOGOP_FORE_ENABLE | 
                                       __CONFIG2D_LOGOP_BACK_ENABLE | 
                                       __CONFIG2D_ENABLES);
                                       
    config2D |= __CONFIG2D_FBWRITE    | 
                __CONFIG2D_USERSCISSOR;
                
    render2D = __RENDER2D_INCX        | 
               __RENDER2D_INCY        | 
               __RENDER2D_OP_SYNCDATA | 
               __RENDER2D_SPANS;

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 6 );

    if( logicOp != __GLINT_LOGICOP_COPY ) 
    {
        config2D &= ~(__CONFIG2D_LOGOP_FORE_MASK | 
                      __CONFIG2D_LOGOP_BACK_MASK);
        config2D |= __CONFIG2D_LOGOP_FORE(logicOp) | 
                    __CONFIG2D_FBWRITE;
                    
        render2D |= __RENDER2D_SPANS;

        if( LogicopReadDest[logicOp] ) 
        {
            config2D |= __CONFIG2D_FBDESTREAD;
            SET_READ_BUFFERS;
        }

        if( LogicOpReadSrc[logicOp] ) 
        {
            config2D |= __CONFIG2D_EXTERNALSRC | 
                        __CONFIG2D_LUTENABLE;
        }
    } 
    else 
    {
        config2D |= __CONFIG2D_EXTERNALSRC | 
                    __CONFIG2D_LUTENABLE;
    }

    LOAD_CONFIG2D( config2D );

    QUEUE_PXRX_DMA_TAG( __GlintTagDownloadTarget, __GlintTagColor );
    cPelInv = 2 - ppdev->cPelSize;
    // Everything before the LUT runs at 8bpp
    pixelSize = (1 << 31)       | 
                (2 << 2)        | 
                (2 << 4)        | 
                (2 << 6)        | 
                (2 << 16)       |        
                (cPelInv << 8)  | 
                (cPelInv << 10) | 
                (cPelInv << 12) | 
                (cPelInv << 14);
                
    QUEUE_PXRX_DMA_TAG( __GlintTagPixelSize, pixelSize );

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;  // Add to destination to get source
//  cPel = ppdev->cPelSize;
//  cPelMask = (1 << cPelInv) - 1;

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    while( TRUE ) 
    {
        DISPDBG((DBGLVL, "download to rect (%d,%d) to (%d,%d)", 
                         prcl->left, prcl->top, prcl->right, prcl->bottom));

        // 4bpp => 2 pixels per byte => 8 pixels per dword

        // Assume source bitmap width is dword aligned
        ASSERTDD( (lSrcDelta & 3) == 0, 
                  "pxrxXfer4bpp: SOURCE BITMAP WIDTH IS NOT DWORD ALIGNED!!!");

        // pointer to first pixel, in bytes (32/64 bits long)
        startPos = (((UINT_PTR) pjSrcScan0) + ((prcl->top + dy) * lSrcDelta)) + 
                                                       ((prcl->left + dx) >> 1);    
        pjSrc = (ULONG *) (startPos & ~3); // dword pointer to dword 
                                           // aligned first pixel

        if(NULL == pjSrc)
        {
            DISPDBG((ERRLVL, "ERROR: "
                             "pxrxXfer4bpp return because of pjSrc NULL"));            
            return;
        }

        // pointer to first pixel, in pixels (33/65 bits long!)
        startPos = (( ((UINT_PTR) pjSrcScan0) + 
                      ((prcl->top + dy) * lSrcDelta)) << 1) 
                   + (prcl->left + dx);    
                   
        alignOff = (ULONG)(startPos & 7); // number of pixels past dword 
                                          // alignment of a scanline

        LeftEdge = prcl->left - alignOff; // dword aligned left edge in pixels
        // dword aligned width in pixels
        AlignWidth  = ((prcl->right - LeftEdge) + 7) & ~7;    
        cy          = prcl->bottom - prcl->top; // number of scanlines to do

        DISPDBG((DBGLVL, "pjSrcScan0 = 0x%08X, startPos = 0x%08X (>>1), "
                         "pjSrc = 0x%08X", 
                         pjSrcScan0, startPos >> 1, pjSrc));
        DISPDBG((DBGLVL, "offset = %d pixels", alignOff));
        DISPDBG((DBGLVL, "Aligned rect = (%d -> %d) => %d pixels => %d dwords", 
                         LeftEdge, LeftEdge + AlignWidth, 
                         AlignWidth, AlignWidth >> 3));

        WAIT_PXRX_DMA_TAGS( 4 );

        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMinXY,         
                                        MAKEDWORD_XY(prcl->left,       0) );
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY,         
                                        MAKEDWORD_XY(prcl->right, 0x7fff) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    
                                        MAKEDWORD_XY(LeftEdge, prcl->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,  render2D | 
                                                 __RENDER2D_WIDTH(AlignWidth) |
                                                 __RENDER2D_HEIGHT(cy) );
        SEND_PXRX_DMA_BATCH;

        AlignWidth  >>= 3;            // dword aligned width in dwords
        lSrcDeltaDW = lSrcDelta >> 2; // dword aligned scanline offset in dwords
        
        DISPDBG((DBGLVL, "Delta = %d pixels = %d dwords", 
                         lSrcDelta << 1, lSrcDeltaDW));

        //    pjSrc       = dword aligned pointer to first 
        //                         dword of first scanline
        //    AlignWidth  = number of dwords per scanline
        //    lTrueDelta  = dword offset between first dwords 
        //                         of consecutive scanlines
        //    cy          = number of scanlines

        while( TRUE ) 
        {
            nRemainder = AlignWidth;

            DISPDBG((DBGLVL, "cy = %d", cy));

            WAIT_PXRX_DMA_DWORDS( AlignWidth + 1 );
            QUEUE_PXRX_DMA_HOLD( __GlintTagPacked4Pixels, AlignWidth );
            TEST_DWORD_ALIGNED( pjSrc );
            QUEUE_PXRX_DMA_BUFF( pjSrc, AlignWidth );

            if( --cy == 0 )
            {
                break;
            }
            pjSrc += lSrcDeltaDW;
            SEND_PXRX_DMA_BATCH;
        }

        if( --count == 0 )
        {
            break;
        }

        prcl++;
    }

    // Reset some defaults:
    WAIT_PXRX_DMA_TAGS( 2 );
    QUEUE_PXRX_DMA_TAG( __GlintTagPixelSize, cPelInv );
    if( ppdev->cPelSize == GLINTDEPTH32 )
    {
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY, 0x7FFF7FFF );
    }

    SEND_PXRX_DMA_BATCH;

    DISPDBG((DBGLVL, "pxrxXfer4bpp return"));
}

/**************************************************************************\
*
* VOID pxrxCopyXfer24bpp
*
\**************************************************************************/      

VOID pxrxCopyXfer24bpp( 
    PPDEV ppdev, 
    SURFOBJ *psoSrc, 
    POINTL *pptlSrc, 
    RECTL *prclDst, 
    RECTL *prcl, 
    LONG count ) 
{
    ULONG   config2D, render2D, pixelSize;
    LONG        dx, dy, cy, LeftEdge;
    LONG        lSrcDelta, lSrcDeltaDW, lTrueDelta, alignOff;
    UINT_PTR    startPos;
    BYTE*       pjSrcScan0;
    ULONG*      pjSrc;
    LONG        cPelInv;
    ULONG       ul, nRemainder;
    ULONG       padLeft, padLeftDW, padRight, padRightDW, dataWidth;
    ULONG       AlignWidth, AlignWidthDW, AlignExtra;
    GLINT_DECL;

    DISPDBG((DBGLVL, "pxrxCopyXfer24bpp(): "
                     "src = (%d,%d) -> (%d,%d), count = %d", 
                     prcl->left, prcl->right, prcl->top, prcl->bottom, count));

    config2D = glintInfo->config2D & ~(__CONFIG2D_LOGOP_FORE_ENABLE | 
                                       __CONFIG2D_LOGOP_BACK_ENABLE | 
                                       __CONFIG2D_ENABLES);
    config2D |= __CONFIG2D_FBWRITE     | 
                __CONFIG2D_EXTERNALSRC | 
                __CONFIG2D_USERSCISSOR;
                
    render2D = __RENDER2D_INCX        | 
               __RENDER2D_INCY        | 
               __RENDER2D_OP_SYNCDATA | 
               __RENDER2D_SPANS;

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 3 );

    QUEUE_PXRX_DMA_TAG( __GlintTagDownloadTarget,       __GlintTagColor );
    QUEUE_PXRX_DMA_TAG( __GlintTagDownloadGlyphWidth,   3 );
    LOAD_CONFIG2D( config2D );

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    while( TRUE ) 
    {
        DISPDBG((DBGLVL, "download to rect "
                         "(%d,%d -> %d,%d) + (%d, %d) = (%d x %d)", 
                         prcl->left, prcl->top, prcl->right, prcl->bottom,
                         dx, dy, 
                         prcl->right - prcl->left, 
                         prcl->bottom - prcl->top));

        // 24bpp => 1 pixel per 3 bytes => 4 pixel per 3 dwords

        // Assume source bitmap width is dword aligned
        ASSERTDD( (lSrcDelta & 3) == 0, 
                  "pxrxCopyXfer24bpp: "
                  "SOURCE BITMAP WIDTH IS NOT DWORD ALIGNED!!!" );
        ASSERTDD( (((UINT_PTR) pjSrcScan0) & 3) == 0, 
                  "pxrxCopyXfer24bpp: "
                  "SOURCE BITMAP START LOCATION IS NOT DWORD ALIGNED!!!" );

        cy = prcl->bottom - prcl->top;  // number of scanlines to do
        startPos = (((UINT_PTR) pjSrcScan0) + 
                     ((prcl->top + dy) * lSrcDelta)) + 
                   ((prcl->left + dx) * 3); // pointer to first pixel of first 
                                            // scanline, in bytes
                                            
        alignOff = (ULONG)(startPos & 3);    // number of bytes past dword 
                                             // alignment to first pixel
        pjSrc = (ULONG *) (startPos & ~3);   // dword pointer to dword aligned 
                                             // first pixel

        if(NULL == pjSrc)
        {
            DISPDBG((ERRLVL, "ERROR: "
                             "pxrxCopyXfer24bpp return because of pjSrc NULL"));            
            return;
        }
        
        padLeft = (4 - alignOff) % 4;   // number of pixels to add to regain 
                                        // dword alignment on left edge
        padLeftDW = (padLeft * 3) / 4;  // number of dwords to add 
                                        // on the left edge
        LeftEdge = prcl->left - padLeft;

        // dword aligned width in pixels (= 4 pixel aligned = 3 dword aligned!)
        AlignWidth = (prcl->right - LeftEdge + 3) & ~3;        
        // number of pixels overhang on the right
        padRight = (LeftEdge + AlignWidth) - prcl->right;    
        // number of dwords to add on the right edge
        padRightDW = (padRight * 3) / 4;                        

        AlignWidthDW = (AlignWidth * 3) / 4; // dword aligned width in dwords
        lSrcDeltaDW = lSrcDelta >> 2;        // dword aligned scanline offset 
                                             //                    in dwords
        // the amount of AlignWidth which is actually src bitmap                                             
        dataWidth = AlignWidthDW - padLeftDW - padRightDW;    

        DISPDBG((DBGLVL, "startPos = 0x%08X, alignOff = %d, "
                         "pjSrc = 0x%08X, lSrcDeltaDW = %d", 
                         startPos, alignOff, pjSrc, lSrcDeltaDW));
        DISPDBG((DBGLVL, "padLeft = %d pixels = %d dwords, LeftEdge = %d", 
                         padLeft, padLeftDW, LeftEdge));
        DISPDBG((DBGLVL, "AlignWidth = %d pixels = %d dwords", 
                         AlignWidth, AlignWidthDW));
        DISPDBG((DBGLVL, "padRight = %d pixels = %d dwords", padRight, padRightDW));

        WAIT_PXRX_DMA_TAGS( 4 );

        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMinXY,         
                                            MAKEDWORD_XY(prcl->left,       0));
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY,         
                                            MAKEDWORD_XY(prcl->right, 0x7fff));
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    
                                            MAKEDWORD_XY(LeftEdge, prcl->top));
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,  render2D                     | 
                                                 __RENDER2D_WIDTH(AlignWidth) | 
                                                 __RENDER2D_HEIGHT(cy) );

        while( cy-- ) 
        {
            DISPDBG((DBGLVL, "cy = %d", cy));

            WAIT_PXRX_DMA_DWORDS( AlignWidthDW + 1 );
            QUEUE_PXRX_DMA_HOLD( __GlintTagGlyphData, AlignWidthDW );

            if( padLeftDW )
            {
                QUEUE_PXRX_DMA_DWORD( 0xDEADDEAD );
            }
            
            if( padLeftDW == 2 )
            {
                QUEUE_PXRX_DMA_DWORD( 0xDEADDEAD );
            }

            QUEUE_PXRX_DMA_BUFF( pjSrc, dataWidth );

            if( padRightDW )
            {
                QUEUE_PXRX_DMA_DWORD( 0xDEADDEAD );
            }
            
            if( padRightDW == 2 )
            {
                QUEUE_PXRX_DMA_DWORD( 0xDEADDEAD );
            }

            SEND_PXRX_DMA_BATCH;

            pjSrc += lSrcDeltaDW;
        }
        
//@@BEGIN_DDKSPLIT        
/*/
        alignOff    = (prcl->left + dx + 3) & ~3;                // number of pixels past dword alignment of first pixel of a scanline
        pjSrc       = (ULONG *) (startPos - (alignOff * 3));    // dword pointer to dword aligned first pixel
        LeftEdge    = prcl->left - alignOff;                    // dword aligned left edge in pixels
        AlignWidth  = ((((prcl->right - LeftEdge) * 3) + 3) & ~3) / 3;        // dword aligned width in pixels (IS NOT = 4 pixel aligned = 3 dword aligned!)
        AlignExtra  = AlignWidth - (prcl->right - LeftEdge);    // extra pixels beyond the genuine width (which might overstomp a page boundary)
        if( AlignExtra )
            cy--;

        DISPDBG((7, "pjSrcScan0 = 0x%08X, startPos = 0x%08X, pjSrc = 0x%08X", pjSrcScan0, startPos, pjSrc));
        DISPDBG((7, "offset = %d pixels", alignOff));
        DISPDBG((7, "Aligned rect = (%d -> %d) => %d pixels", LeftEdge, LeftEdge + AlignWidth, AlignWidth));
        DISPDBG((7, "Rendering %d scanlines", cy));

        WAIT_PXRX_DMA_TAGS( 4 );

        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMinXY,         MAKEDWORD_XY(prcl->left,       0) );
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY,         MAKEDWORD_XY(prcl->right, 0x7fff) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(LeftEdge, prcl->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D | __RENDER2D_WIDTH(AlignWidth) | __RENDER2D_HEIGHT(cy) );

        AlignWidthDW    = (AlignWidth * 3) / 4;                    // dword aligned width in dwords
        lSrcDeltaDW     = lSrcDelta >> 2;                        // dword aligned scanline offset in dwords
        DISPDBG((7, "Delta = %d bytes = %d dwords (%d dwords wide)", lSrcDelta, lSrcDeltaDW, AlignWidthDW));

        while( cy-- ) {
            DISPDBG((9, "cy = %d", cy));

            WAIT_PXRX_DMA_DWORDS( AlignWidthDW + 1 );
            QUEUE_PXRX_DMA_HOLD( __GlintTagGlyphData, AlignWidthDW );
            TEST_DWORD_ALIGNED( pjSrc );
            QUEUE_PXRX_DMA_BUFF( pjSrc, AlignWidthDW );
            SEND_PXRX_DMA_BATCH;

            pjSrc += lSrcDeltaDW;
        }

        if( AlignExtra ) {
            ULONG   dataWidth;
            ULONG   dataExtra;

            dataWidth = ((((prcl->right - LeftEdge) * 3) + 3) & ~3) / 4;    // dword aligned width in dwords, 1 dword aligned
            dataExtra = AlignWidthDW - dataWidth;                            // extra dwords past end of image
            DISPDBG((7, "Last scanline: %d + %d = %d pixels = %d + %d = %d dwords",
                     prcl->right - LeftEdge, AlignExtra, AlignWidth, dataWidth, dataExtra, AlignWidthDW));
            ASSERTDD( (dataWidth + dataExtra) == AlignWidthDW, "pxrxCopyXfer24bpp: Last scanline does not add up!" );

            WAIT_PXRX_DMA_DWORDS( AlignWidthDW + 5 );

            QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(LeftEdge, prcl->bottom - 1) );
            QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D | __RENDER2D_WIDTH(AlignWidth) | __RENDER2D_HEIGHT(1) );

            TEST_DWORD_ALIGNED( pjSrc );
            QUEUE_PXRX_DMA_HOLD( __GlintTagGlyphData, AlignWidthDW );
            QUEUE_PXRX_DMA_BUFF( pjSrc, dataWidth );                    // Send the partial scanline
            while( dataExtra-- )
                QUEUE_PXRX_DMA_DWORD( 0xDEADDEAD );                        // Pad out to flush the data

            // Resend download target to flush the remaining partial pixels ???
        }
/**/
//@@END_DDKSPLIT

        if( --count == 0 )
        {
            break;
        }

        prcl++;
    }

    // Reset the scissor maximums:
    if( ppdev->cPelSize == GLINTDEPTH32 ) 
    {
        WAIT_PXRX_DMA_TAGS( 1 );
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY, 0x7FFF7FFF );
    }

    SEND_PXRX_DMA_BATCH;

    DISPDBG((DBGLVL, "pxrxCopyXfer24bpp return"));
}

/**************************************************************************\
*
* VOID pxrxCopyXfer8bppLge
*
\**************************************************************************/     
VOID pxrxCopyXfer8bppLge( 
    PPDEV ppdev, 
    SURFOBJ *psoSrc, 
    POINTL *pptlSrc, 
    RECTL *prclDst, 
    RECTL *prcl, 
    LONG count, 
    XLATEOBJ *pxlo ) 
{
    ULONG       config2D, render2D, lutMode, pixelSize;
    BOOL        invalidLUT = FALSE;
    LONG        dx, dy, cy;
    LONG        lSrcDelta, lSrcDeltaDW, lTrueDelta, alignOff;
    ULONG       AlignWidth, LeftEdge;
    BYTE*       pjSrcScan0;
    ULONG*      pjSrc;
    UINT_PTR    startPos;
    LONG        cPelInv;
    ULONG       ul, i;
    LONG        nRemainder;
//@@BEGIN_DDKSPLIT
#if USE_RLE_DOWNLOADS
    ULONG       len, data, holdCount;
#endif
//@@END_DDKSPLIT
    ULONG       *tagPtr;
    ULONG       *pulXlate = pxlo->pulXlate;
    GLINT_DECL;

    DISPDBG((DBGLVL, "pxrxCopyXfer8bpp(): src = (%d,%d) -> (%d,%d), "
                     "count = %d, palette id = %d", 
                     prcl->left, prcl->right, prcl->top, prcl->bottom, 
                     count, pxlo->iUniq));

    SET_WRITE_BUFFERS;

    if( (count == 1) && 
        ((cy = (prcl->bottom - prcl->top)) == 1) ) 
    {
        ULONG   width = prcl->right - prcl->left, extra;
        BYTE    *srcPtr;

        config2D = __CONFIG2D_FBWRITE    | 
                   __CONFIG2D_EXTERNALSRC;
        render2D = __RENDER2D_INCX        | 
                   __RENDER2D_INCY        | 
                   __RENDER2D_OP_SYNCDATA | 
                   __RENDER2D_SPANS;

        dx = pptlSrc->x - prclDst->left;
        dy = pptlSrc->y - prclDst->top;  // Add to destination to get source

        lSrcDelta  = psoSrc->lDelta;
        pjSrcScan0 = psoSrc->pvScan0;
        startPos = (((UINT_PTR) pjSrcScan0) + 
                     ((prcl->top + dy) * lSrcDelta)) + (prcl->left + dx);
        srcPtr = (BYTE *) startPos;

        WAIT_PXRX_DMA_DWORDS( 7 + width );

        LOAD_CONFIG2D( config2D );

        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    
                                        MAKEDWORD_XY(prcl->left, prcl->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,  render2D | 
                                                 __RENDER2D_WIDTH(width) | 
                                                 __RENDER2D_HEIGHT(1) );

        if( ppdev->cPelSize == 0 )     // 8bpp
        {
            extra = width & 3;
            width >>= 2;

            if( extra ) 
            {
                QUEUE_PXRX_DMA_HOLD( __GlintTagColor, width + 1 );
                QUEUE_PXRX_DMA_BUFF_DELAYED( tagPtr, width + 1 );
            } else {
                QUEUE_PXRX_DMA_HOLD( __GlintTagColor, width );
                QUEUE_PXRX_DMA_BUFF_DELAYED( tagPtr, width );
            }

            DISPDBG((DBGLVL, "width was %d, is now %d + %d", 
                             prcl->right - prcl->left, width, extra));

            for( i = 0; i < width; i++, srcPtr += 4 )
            {
                *(tagPtr++) = (pulXlate[srcPtr[3]] << 24) | 
                              (pulXlate[srcPtr[2]] << 16) | 
                              (pulXlate[srcPtr[1]] <<  8) | 
                               pulXlate[srcPtr[0]];
            }

            if( extra == 1 )
            {
                *(tagPtr++) = pulXlate[srcPtr[0]];
            }
            else if( extra == 2 )
            {
                *(tagPtr++) = (pulXlate[srcPtr[1]] << 8) | 
                               pulXlate[srcPtr[0]];
            }
            else if (extra == 3)
            {
                *(tagPtr++) = (pulXlate[srcPtr[2]] << 16) | 
                              (pulXlate[srcPtr[1]] <<  8) | 
                               pulXlate[srcPtr[0]];
            }
        } 
        else if( ppdev->cPelSize == 1 )     // 16bpp
        {
            extra = width & 1;
            width >>= 1;

            QUEUE_PXRX_DMA_HOLD( __GlintTagColor, width + extra );
            QUEUE_PXRX_DMA_BUFF_DELAYED( tagPtr, width + extra );

            DISPDBG((DBGLVL, "width was %d, is now %d + %d", 
                             prcl->right - prcl->left, width, extra));

            for( i = 0; i < width; i++, srcPtr += 2 )
            {
                *(tagPtr++) = (pulXlate[srcPtr[1]] << 16) | 
                               pulXlate[srcPtr[0]];
            }

            if( extra )
            {
                *(tagPtr++) = pulXlate[srcPtr[0]];
            }
        } 
        else 
        {
            QUEUE_PXRX_DMA_HOLD( __GlintTagColor, width );
            QUEUE_PXRX_DMA_BUFF_DELAYED( tagPtr, width );

            DISPDBG((DBGLVL, "width was %d, is now %d + %d", 
                             prcl->right - prcl->left, width, 0));

            for( i = 0; i < width; i++ )
            {
                *(tagPtr++) = pulXlate[*(srcPtr++)];
            }
        }

        SEND_PXRX_DMA_BATCH;

        return;
    }

    // Set up the LUT table:

    if( (ppdev->PalLUTType != LUTCACHE_XLATE) || 
        (ppdev->iPalUniq != pxlo->iUniq) ) 
    {
        // Someone has hijacked the LUT so we need to invalidate it:
        ppdev->PalLUTType = LUTCACHE_XLATE;
        ppdev->iPalUniq = pxlo->iUniq;
        invalidLUT = TRUE;
    } 
    else 
    {
        DISPDBG((DBGLVL, "pxrxCopyXfer8bpp: reusing cached xlate"));
    }

    WAIT_PXRX_DMA_TAGS( 1 + 1 );

    lutMode = glintInfo->lutMode & ~((3 << 2) | (1 << 4) | (7 << 8));
    lutMode |= (ppdev->cPelSize + 2) << 8;
    LOAD_LUTMODE( lutMode );

    if( invalidLUT ) 
    {
        LONG    cEntries = 256;
        
        pulXlate = pxlo->pulXlate;        

        QUEUE_PXRX_DMA_TAG( __PXRXTagLUTIndex, 0 );

        if( ppdev->cPelSize == 0 )     // 8bpp
        {
            WAIT_PXRX_DMA_TAGS( cEntries );

            do 
            {
                ul = *(pulXlate++);
                ul |= ul << 8;
                ul |= ul << 16;
                QUEUE_PXRX_DMA_TAG( __PXRXTagLUTData, ul );
            } while( --cEntries );
        } 
        else if( ppdev->cPelSize == 1 )     // 16bpp
        {
            WAIT_PXRX_DMA_TAGS( cEntries );

            do 
            {
                ul = *(pulXlate++);
                ul |= ul << 16;
                QUEUE_PXRX_DMA_TAG( __PXRXTagLUTData, ul );
            } while( --cEntries );
        } 
        else 
        {
            WAIT_PXRX_DMA_DWORDS( 1 + cEntries );

            QUEUE_PXRX_DMA_HOLD( __PXRXTagLUTData, cEntries );
            QUEUE_PXRX_DMA_BUFF( pulXlate, cEntries );
        }
    }

    config2D = glintInfo->config2D & ~(__CONFIG2D_LOGOP_FORE_ENABLE | 
                                       __CONFIG2D_LOGOP_BACK_ENABLE | 
                                       __CONFIG2D_ENABLES);
    config2D |= __CONFIG2D_FBWRITE     | 
                __CONFIG2D_USERSCISSOR | 
                __CONFIG2D_EXTERNALSRC | 
                __CONFIG2D_LUTENABLE;
    render2D = __RENDER2D_INCX        | 
               __RENDER2D_INCY        | 
               __RENDER2D_OP_SYNCDATA | 
               __RENDER2D_SPANS;

    WAIT_PXRX_DMA_TAGS( 3 );

    LOAD_CONFIG2D( config2D );

//@@BEGIN_DDKSPLIT
#if USE_RLE_DOWNLOADS
    QUEUE_PXRX_DMA_TAG( __GlintTagDownloadTarget, __GlintTagColor );
#endif
//@@END_DDKSPLIT

    cPelInv = 2 - ppdev->cPelSize;
    // Everything before the LUT runs at 8bpp
    pixelSize = (1 << 31)       | 
                (2 << 2)        | 
                (2 << 4)        | 
                (2 << 6)        |        
                (cPelInv << 8)  | 
                (cPelInv << 10) | 
                (cPelInv << 12) | 
                (cPelInv << 14);
                
    QUEUE_PXRX_DMA_TAG( __GlintTagPixelSize, pixelSize );

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    while( TRUE ) 
    {
        DISPDBG((DBGLVL, "download to rect (%d,%d) to (%d,%d)", 
                         prcl->left, prcl->top, prcl->right, prcl->bottom));

        // 8bpp => 1 pixel per byte => 4 pixels per dword

        // Assume source bitmap width is dword aligned
        ASSERTDD( (lSrcDelta & 3) == 0, 
                  "pxrxCopyXfer8bpp: "
                  "SOURCE BITMAP WIDTH IS NOT DWORD ALIGNED!!!" );

        // pointer to first pixel, in pixels/bytes
        startPos    = (((UINT_PTR) pjSrcScan0) + 
                        ((prcl->top + dy) * lSrcDelta)) 
                      + (prcl->left + dx);    

        // dword pointer to dword aligned first pixel                      
        pjSrc       = (ULONG *) (startPos & ~3);     
        
        if(NULL == pjSrc)
        {
            DISPDBG((ERRLVL, "ERROR: pxrxCopyXfer8bppLge "
                             "return because of pjSrc NULL"));
            return;
        }
        
        alignOff = (ULONG)(startPos & 3);  // number of pixels past dword 
                                           // alignment of a scanline
        LeftEdge = prcl->left - alignOff;  // dword aligned left edge in pixels
        AlignWidth = ((prcl->right - LeftEdge) + 3) & ~3; // dword aligned width 
                                                          // in pixels
        cy = prcl->bottom - prcl->top;     // number of scanlines to do

        DISPDBG((DBGLVL, "pjSrcScan0 = 0x%08X, startPos = 0x%08X, "
                         "pjSrc = 0x%08X", 
                         pjSrcScan0, startPos, pjSrc));
        DISPDBG((DBGLVL, "offset = %d pixels", alignOff));
        DISPDBG((DBGLVL, "Aligned rect = (%d -> %d) => %d pixels => %d dwords", 
                         LeftEdge, LeftEdge + AlignWidth, 
                         AlignWidth, AlignWidth >> 2));

        WAIT_PXRX_DMA_TAGS( 4 );

        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMinXY,         
                                        MAKEDWORD_XY(prcl->left,       0) );
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY,         
                                        MAKEDWORD_XY(prcl->right, 0x7fff) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    
                                        MAKEDWORD_XY(LeftEdge, prcl->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D, render2D                     | 
                                                __RENDER2D_WIDTH(AlignWidth) | 
                                                __RENDER2D_HEIGHT(cy) );
        SEND_PXRX_DMA_BATCH;

        AlignWidth  >>= 2;              // dword aligned width in dwords
        lSrcDeltaDW = lSrcDelta >> 2;   // scanline delta in dwords 
                                        // (start to start)
        lTrueDelta  = lSrcDeltaDW - AlignWidth;  // scanline delta in dwords 
                                                 // (end   to start)
                                                 
        DISPDBG((DBGLVL, "Delta = %d bytes = %d dwords -> %d - %d dwords", 
                         lSrcDelta, lSrcDeltaDW, lTrueDelta, AlignWidth));

//@@BEGIN_DDKSPLIT
#if USE_RLE_DOWNLOADS
        // Do an RLE download:
        tagPtr = NULL;

        do 
        {
            WAIT_PXRX_DMA_TAGS( AlignWidth + 1 );

            nRemainder = AlignWidth;
            while( nRemainder-- ) 
            {
                TEST_DWORD_ALIGNED( pjSrc );
                data = *(pjSrc++);
                len = 1;

                TEST_DWORD_ALIGNED( pjSrc );
                while( nRemainder && (*pjSrc == data) ) 
                {
                    pjSrc++;
                    len++;
                    nRemainder--;
                    TEST_DWORD_ALIGNED( pjSrc );
                }

                if( len >= 4 ) 
                {
                    if( tagPtr ) 
                    {
                        *tagPtr = ASSEMBLE_PXRX_DMA_HOLD( __GlintTagColor, 
                                                          holdCount );
                        tagPtr = NULL;
                    }

                    QUEUE_PXRX_DMA_INDEX2( __GlintTagRLData, __GlintTagRLCount );
                    QUEUE_PXRX_DMA_DWORD( data );
                    QUEUE_PXRX_DMA_DWORD( len );
                    len = 0;
                } 
                else 
                {
                    if( !tagPtr ) 
                    {
                        QUEUE_PXRX_DMA_DWORD_DELAYED( tagPtr );
                        holdCount = 0;
                    }

                    holdCount += len;
                    
                    while( len-- )
                    {
                        QUEUE_PXRX_DMA_DWORD( data );
                    }
                }
            }

            if( tagPtr ) 
            {
                *tagPtr = ASSEMBLE_PXRX_DMA_HOLD( __GlintTagColor, holdCount );
                tagPtr = NULL;
            }
            
            pjSrc += lTrueDelta;
            SEND_PXRX_DMA_BATCH;
        } while( --cy > 0 );
#else
//@@END_DDKSPLIT
        // Do a raw download:
        while( TRUE ) 
        {
            DISPDBG((DBGLVL, "cy = %d", cy));

            WAIT_PXRX_DMA_DWORDS( AlignWidth + 1 );
            QUEUE_PXRX_DMA_HOLD( __GlintTagColor, AlignWidth );
            TEST_DWORD_ALIGNED( pjSrc );
            QUEUE_PXRX_DMA_BUFF( pjSrc, AlignWidth );
            SEND_PXRX_DMA_BATCH;

            if( --cy == 0 )
            {
                break;
            }

            pjSrc += lSrcDeltaDW;
        }
//@@BEGIN_DDKSPLIT        
#endif
//@@END_DDKSPLIT

        if( --count == 0 )
        {
            break;
        }

        prcl++;
    }

    // Reset some defaults:
    WAIT_PXRX_DMA_TAGS( 2 );
    QUEUE_PXRX_DMA_TAG( __GlintTagPixelSize, cPelInv );
    if( ppdev->cPelSize == GLINTDEPTH32 )
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY, 0x7FFF7FFF );

    SEND_PXRX_DMA_BATCH;

    DISPDBG((DBGLVL, "pxrxCopyXfer8bpp return"));
}


//****************************************************************************
// FUNC: pxrxMemUpload
// ARGS: ppdev (I) - pointer to the physical device object
//       crcl (I) - number of destination clipping rectangles
//       prcl (I) - array of destination clipping rectangles
//       psoDst (I) - destination surface
//       pptlSrc (I) - offset into source surface
//       prclDst (I) - unclipped destination rectangle
// RETN:  void
//****************************************************************************
VOID pxrxMemUpload(
    PPDEV ppdev, 
    LONG crcl, 
    RECTL *prcl, 
    SURFOBJ *psoDst, 
    POINTL *pptlSrc, 
    RECTL *prclDst)
{
    BYTE *pDst, *pSrc;
    LONG dwScanLineSize, cySrc, lSrcOff, lSrcStride;
    GLINT_DECL;

    // Make sure we're not performing other operations on the fb areas we want
    SYNC_WITH_GLINT;
    
    ASSERTDD(psoDst->iBitmapFormat == ppdev->iBitmapFormat, 
             "Dest must be same colour depth as screen");
             
    ASSERTDD(crcl > 0, "Can't handle zero rectangles");

    for(; --crcl >= 0; ++prcl) 
    {
        // This gives an offset for offscreen DIBs (zero for primary rectangles)
        lSrcOff = ppdev->DstPixelOrigin + 
                  (ppdev->xyOffsetDst & 0xffff) +
                  (ppdev->xyOffsetDst >> 16) * ppdev->DstPixelDelta;

        // Determine stride on wheter we are blitting from the 
        // primary or from an offscreen DIB
        if (( ppdev->DstPixelOrigin == 0 ) && 
            (ppdev->xyOffsetDst == 0)       )
        {
            lSrcStride = ppdev->lDelta;
        }
        else
        {
            lSrcStride = ppdev->DstPixelDelta * ppdev->cjPelSize;
        }              
    
        // pSrc must point to mem mapped primary      
        pSrc = (BYTE *)ppdev->pjScreen 
                 + (lSrcOff * ppdev->cjPelSize)         
                 + ((LONG)pptlSrc->x * ppdev->cjPelSize) 
                 + ((LONG)pptlSrc->y * lSrcStride); 
  
        // pDst must point to the sysmem SURFOBJ 
        pDst = (BYTE *)psoDst->pvScan0 
                 + ((LONG)prcl->left * ppdev->cjPelSize) 
                 + ((LONG)prcl->top  * (LONG)psoDst->lDelta);                     

        // dwScanLineSize must have the right size to transfer in bytes
        dwScanLineSize = ((LONG)prcl->right - (LONG)prcl->left) * ppdev->cjPelSize;

        // Number of scan lines to transfer
        cySrc = prcl->bottom - prcl->top;

        // Do the copy
        while (--cySrc >= 0) 
        {
            // memcpy(dst, src, size)
            memcpy(pDst, pSrc, dwScanLineSize);
            pDst += psoDst->lDelta; // add stride
            pSrc += lSrcStride;  // add stride
        }
    }

} // pxrxMemUpload


//****************************************************************************
// FUNC: pxrxFifoUpload
// ARGS: ppdev (I) - pointer to the physical device object
//       crcl (I) - number of destination clipping rectangles
//       prcl (I) - array of destination clipping rectangles
//       psoDst (I) - destination surface
//       pptlSrc (I) - offset into source surface
//       prclDst (I) - unclipped destination rectangle
// RETN:  void
//----------------------------------------------------------------------------
// upload from on-chip source into host memory surface. Upload in spans 
// (64-bit aligned) to minimise messages through the core and entries in the 
// host out fifo.
//****************************************************************************
VOID pxrxFifoUpload(
    PPDEV ppdev, 
    LONG crcl, 
    RECTL *prcl, 
    SURFOBJ *psoDst, 
    POINTL *pptlSrc, 
    RECTL *prclDst)
{
    LONG    xDomSrc, xSubSrc, yStartSrc, cxSrc, cySrc;
    LONG    culPerSrcScan;
    LONG    culDstDelta;
    BOOL    bRemPerSrcScan;
    ULONG   *pulDst, *pulDstScan;
    ULONG   leftMask, rightMask;
    LONG    cul, ul;
    LONG    cFifoSpaces;
    __GlintFilterModeFmat FilterMode;
    GLINT_DECL;

    WAIT_PXRX_DMA_TAGS(1);
    QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadMode, (glintInfo->fbDestMode | 0x103));
    SEND_PXRX_DMA_FORCE;

//@@BEGIN_DDKSPLIT
#if USE_RLE_UPLOADS

    // NB. using cxSrc >= 16 is slightly slower overall. These tests were empirically developed 
    //     from WB99 BG & HE benchmarks
    cxSrc = prcl->right - prcl->left;
    if(cxSrc >= 32 && (cxSrc < 80 || (cxSrc >= 128 && cxSrc < 256) || cxSrc == ppdev->cxScreen))
    {
        pxrxRLEFifoUpload(ppdev, crcl, prcl, psoDst, pptlSrc, prclDst);
        return;
    }

#endif //USE_RLE_UPLOADS
//@@END_DDKSPLIT

    DISPDBG((DBGLVL, "pxrxFifoUpload: prcl = (%d, %d -> %d, %d), "
                     "prclDst = (%d, %d -> %d, %d), ptlSrc(%d, %d), count = %d",
                     prcl->left, prcl->top, prcl->right, prcl->bottom, 
                     prclDst->left, prclDst->top, prclDst->right, 
                     prclDst->bottom, pptlSrc->x, pptlSrc->y, crcl));

    DISPDBG((DBGLVL, "pxrxFifoUpload: psoDst: cx = %d, cy = %d, "
                     "lDelta = %d, pvScan0=%P)",
                     psoDst->sizlBitmap.cx, psoDst->sizlBitmap.cy, 
                     psoDst->lDelta, psoDst->pvScan0));
                     
    DISPDBG((DBGLVL, "pxrxFifoUpload: xyOffsetDst = (%d, %d), "
                     "xyOffsetSrc = (%d, %d)",
                     ppdev->xyOffsetDst & 0xFFFF, ppdev->xyOffsetDst >> 16,
                     ppdev->xyOffsetSrc & 0xFFFF, ppdev->xyOffsetSrc >> 16));

    ASSERTDD(psoDst->iBitmapFormat == ppdev->iBitmapFormat, 
             "Dest must be same colour depth as screen");
    ASSERTDD(crcl > 0, "Can't handle zero rectangles");

    WAIT_PXRX_DMA_TAGS(5);

    LOAD_CONFIG2D(__CONFIG2D_FBDESTREAD);
    SET_READ_BUFFERS;

    // enable filter mode so we can get Sync 
    // and color messages on the output FIFO
    *(DWORD *)(&FilterMode) = 0;
    FilterMode.Synchronization = __GLINT_FILTER_TAG;
    FilterMode.Color             = __GLINT_FILTER_DATA;
    QUEUE_PXRX_DMA_TAG(__GlintTagFilterMode, *(DWORD *)(&FilterMode));

    for(; --crcl >= 0; ++prcl) 
    {
        DISPDBG((DBGLVL, "pxrxFifoUpload: dest prcl(%xh,%xh..%xh,%xh)", 
                         prcl->left, prcl->top, prcl->right, prcl->bottom));

        // calculate pixel-aligned source
        xDomSrc   = pptlSrc->x + prcl->left  - prclDst->left;
        xSubSrc   = pptlSrc->x + prcl->right - prclDst->left;
        yStartSrc = pptlSrc->y + prcl->top   - prclDst->top;
        cySrc     = prcl->bottom - prcl->top;

        DISPDBG((DBGLVL, "pxrxFifoUpload: src (%xh,%xh..%xh,%xh)", 
                         xDomSrc, yStartSrc, xSubSrc, yStartSrc + cySrc));

        // will upload ulongs aligned to ulongs
        if (ppdev->cPelSize == GLINTDEPTH32) 
        {
            cxSrc = xSubSrc - xDomSrc;
            culPerSrcScan = cxSrc;
            leftMask  = 0xFFFFFFFF;
            rightMask = 0xFFFFFFFF;
        }    
        else 
        {
            if (ppdev->cPelSize == GLINTDEPTH16) 
            {
                ULONG cPixFromUlongBoundary = prcl->left & 1;

                xDomSrc -= cPixFromUlongBoundary;
                cxSrc = xSubSrc - xDomSrc;
                culPerSrcScan  = (xSubSrc - xDomSrc + 1) >> 1;

                leftMask  = 0xFFFFFFFF << (cPixFromUlongBoundary << 4);
                rightMask = 0xFFFFFFFF >> (((xDomSrc - xSubSrc) & 1) << 4);

            }
            else 
            {
                ULONG cPixFromUlongBoundary = prcl->left & 3;

                xDomSrc -= cPixFromUlongBoundary;
                cxSrc = xSubSrc - xDomSrc;
                culPerSrcScan  = (xSubSrc - xDomSrc + 3) >> 2;

                leftMask  = 0xFFFFFFFF << (cPixFromUlongBoundary << 3);
                rightMask = 0xFFFFFFFF >> (((xDomSrc - xSubSrc) & 3) << 3);

            }     
            // We just want a single mask if the area to upload is less 
            // than one word wide.
            if (culPerSrcScan == 1)
            {
                leftMask &= rightMask;
            }
        }

        // uploading 64 bit aligned source
        bRemPerSrcScan = culPerSrcScan & 1;

        // Work out where the destination data goes to
        culDstDelta = psoDst->lDelta >> 2;
        pulDst = ((ULONG *)psoDst->pvScan0) + 
                  (prcl->left >> (2 - ppdev->cPelSize)) 
                 + culDstDelta * prcl->top;

        DISPDBG((DBGLVL, "pxrxFifoUpload: uploading aligned "
                         "src (%xh,%xh..%xh,%xh)", 
                         xDomSrc, yStartSrc, 
                         xDomSrc + cxSrc, yStartSrc + cySrc));

        // Render the rectangle
        WAIT_PXRX_DMA_TAGS(2);
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,
                                            MAKEDWORD_XY(xDomSrc, yStartSrc));
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,         
                                            __RENDER2D_OP_NORMAL    | 
                                            __RENDER2D_SPANS        |
                                            __RENDER2D_INCY         | 
                                            __RENDER2D_INCX         | 
                                            __RENDER2D_WIDTH(cxSrc) | 
                                            __RENDER2D_HEIGHT(cySrc));
        SEND_PXRX_DMA_FORCE;
        
        // If the start and end masks are 0xffffffff, we can just upload 
        // the words and put them directly into the destination. Otherwise, 
        // or the first and last word on any scanline we have to mask 
        // off any pixels that are outside the render area. We know the 
        // glint will have 0 in the undesired right hand edge pixels, as 
        // these were not in the render area. We dont know anything about 
        // the destination though.
        
        if ((leftMask == 0xFFFFFFFF) && (rightMask == 0xFFFFFFFF))
        {
            DISPDBG((DBGLVL, "pxrxFifoUpload: no edge masks"));
            
            while (--cySrc >= 0) 
            {
                pulDstScan = pulDst;
                pulDst += culDstDelta;

                DISPDBG((DBGLVL, "pxrxFifoUpload: uploading scan of %xh "
                                 "ulongs to %p (Remainder %xh)", 
                                 culPerSrcScan, pulDstScan, bRemPerSrcScan));

                cul = culPerSrcScan;
                while(cul)
                {
                    WAIT_OUTPUT_FIFO_NOT_EMPTY(cFifoSpaces);
                    if (cFifoSpaces > cul)
                    {
                        cFifoSpaces = cul;
                    }

                    cul -= cFifoSpaces;
                    while (--cFifoSpaces >= 0) 
                    {
                        READ_OUTPUT_FIFO(ul);
                        DISPDBG((DBGLVL, "pxrxFifoUpload: read %08.8xh from "
                                         "output FIFO", ul));
                         *pulDstScan++ = ul;
                    }
                }
                
                if(bRemPerSrcScan)
                {
                    WAIT_OUTPUT_FIFO_NOT_EMPTY(cFifoSpaces);
                    READ_OUTPUT_FIFO(ul);
                    DISPDBG((DBGLVL, "pxrxFifoUpload: read remainder %08.8xh "
                                     "from output FIFO", ul));
                }
            }
        }
        else if(culPerSrcScan == 1)
        {
            DISPDBG((DBGLVL, "pxrxFifoUpload: single ulong per scan"));

            while (--cySrc >= 0) 
            {
                WAIT_OUTPUT_FIFO_NOT_EMPTY(cFifoSpaces);
                READ_OUTPUT_FIFO(ul);
                DISPDBG((DBGLVL, "pxrxFifoUpload: "
                                 "read %08.8xh from output FIFO", ul));

                // leftMask contains both masks in this case
                *pulDst = (*pulDst & ~leftMask) | (ul & leftMask);

                ASSERTDD(bRemPerSrcScan, "one word per scan upload should "
                                         "always leave a remainder");
                WAIT_OUTPUT_FIFO_NOT_EMPTY(cFifoSpaces);
                READ_OUTPUT_FIFO(ul);
                DISPDBG((DBGLVL, "pxrxFifoUpload: read remainder %08.8xh "
                                 "from output FIFO", ul));
                pulDst += culDstDelta;
            }
        }
        else
        {
            DISPDBG((DBGLVL, "pxrxFifoUpload: scan with left & right edge "
                             "masks: %08.8x .. %08.8x", leftMask, rightMask));

            while (--cySrc >= 0) 
            {
                pulDstScan = pulDst;
                pulDst += culDstDelta;

                DISPDBG((DBGLVL, "pxrxFifoUpload: uploading scan of %xh "
                                 "ulongs to %p", culPerSrcScan, pulDstScan));

                // get first ulong
                WAIT_OUTPUT_FIFO_NOT_EMPTY(cFifoSpaces);
                --cFifoSpaces;
                READ_OUTPUT_FIFO(ul);
                
                DISPDBG((DBGLVL, "pxrxFifoUpload: "
                                 "read %08.8xh from output FIFO", ul));
                                 
                *pulDstScan++ = (*pulDstScan & ~leftMask) | (ul & leftMask);
                 
                // get middle ulongs
                cul = culPerSrcScan - 2; 
                while (cul) 
                {
                    if (cFifoSpaces > cul)
                    {
                        cFifoSpaces = cul;
                    }

                    cul -= cFifoSpaces;
                    while (--cFifoSpaces >= 0) 
                    {
                        READ_OUTPUT_FIFO(ul);
                        DISPDBG((DBGLVL, "pxrxFifoUpload: "
                                         "read %08.8xh from output FIFO", ul));
                         *pulDstScan++ = ul;
                    }
                    WAIT_OUTPUT_FIFO_NOT_EMPTY(cFifoSpaces);
                }
                  
                // get last ulong
                READ_OUTPUT_FIFO(ul);
                DISPDBG((DBGLVL, "pxrxFifoUpload: "
                                 "read %08.8xh from output FIFO", ul));
                                 
                *pulDstScan = (*pulDstScan & ~rightMask) | (ul & rightMask);

                if(bRemPerSrcScan)
                {
                    WAIT_OUTPUT_FIFO_NOT_EMPTY(cFifoSpaces);
                    READ_OUTPUT_FIFO(ul);
                    DISPDBG((DBGLVL, "pxrxFifoUpload: read remainder "
                                     "%08.8xh from output FIFO", ul));
                }
            }
        }
    }

#if DBG
    cul = 0xaa55aa55;
    DISPDBG((DBGLVL, "pxrxFifoUpload: waiting for sync (id = %08.8xh)", cul));
    WAIT_PXRX_DMA_TAGS(1);
    QUEUE_PXRX_DMA_TAG(__GlintTagSync, cul);
    SEND_PXRX_DMA_FORCE;
    do
    {
        WAIT_OUTPUT_FIFO_READY;
        READ_OUTPUT_FIFO(ul);
        DISPDBG((DBGLVL, "pxrxFifoUpload: read %08.8xh from output FIFO", ul));
        if(ul != __GlintTagSync)
        {
            DISPDBG((ERRLVL,"pxrxFifoUpload: didn't read back sync!"));
        }
    }
    while(ul != __GlintTagSync);
    DISPDBG((DBGLVL, "pxrxFifoUpload: got sync"));
#endif

    // no need to initiate DMA with this tag - it will get flushed with the 
    // next primitive and meanwhile will not affect local memory
    WAIT_PXRX_DMA_TAGS(1);
    QUEUE_PXRX_DMA_TAG(__GlintTagFilterMode, 0);
    SEND_PXRX_DMA_BATCH;

    GLINT_CORE_IDLE;

    DISPDBG((DBGLVL, "pxrxFifoUpload: done"));
}

//****************************************************************************
// VOID vGlintCopyBltBypassDownloadXlate8bpp
//
// using the bypass mechanism we can take advantage of write-combining
//       which can be quicker than using the FIFO
// NB. supports 32bpp and 16bpp destinations
//****************************************************************************
VOID vGlintCopyBltBypassDownloadXlate8bpp(
    PDEV     *ppdev,
    SURFOBJ  *psoSrc,
    POINTL   *pptlSrc,
    RECTL    *prclDst,
    RECTL    *prclClip,
    LONG      crclClip,
    XLATEOBJ *pxlo)
{
    LONG    xOff;
    BYTE    *pjSrcScan0;
    LONG    cjSrcDelta, xSrcOff, ySrcOff;
    ULONG   *pulDstScan0;
    LONG    culDstDelta, xDstOff;
    LONG    cScans, cPixPerScan, c;
    ULONG   cjSrcDeltaRem, cjDstDeltaRem;
    ULONG   *aulXlate;
    BYTE    *pjSrc;
    GLINT_DECL;

//@@BEGIN_DDKSPLIT
#if 0
    {
        SIZEL sizlDst;
        sizlDst.cx = prclClip->right - prclClip->left;
        sizlDst.cy = prclClip->bottom - prclClip->top;
        DISPDBG((DBGLVL, "vGlintCopyBltBypassDownloadXlate8bpp(): "
                         "cRects(%d) sizlDst(%d,%d)", 
                         crclClip, sizlDst.cx, sizlDst.cy));
    }
#endif //DBG
//@@END_DDKSPLIT

    pjSrcScan0 = (BYTE *)psoSrc->pvScan0;
    cjSrcDelta = psoSrc->lDelta;
    
    // need to add arclClip[n].left to get xSrc
    xSrcOff = pptlSrc->x - prclDst->left; 
    // need to add arclClip[n].top to get ySrc
    ySrcOff = pptlSrc->y - prclDst->top;  

    pulDstScan0 = (ULONG *)ppdev->pjScreen;
    culDstDelta = ppdev->DstPixelDelta >> (2 - ppdev->cPelSize);
    xDstOff     = ppdev->DstPixelOrigin + (ppdev->xyOffsetDst & 0xffff) +
                  (ppdev->xyOffsetDst >> 16) * ppdev->DstPixelDelta;

    aulXlate = pxlo->pulXlate;

    SYNC_IF_CORE_BUSY;

    for (; --crclClip >= 0; ++prclClip)
    {
        cScans = prclClip->bottom - prclClip->top;
        cPixPerScan = prclClip->right - prclClip->left;
        cjSrcDeltaRem = cjSrcDelta - cPixPerScan;
        pjSrc = -1 + pjSrcScan0 + xSrcOff + prclClip->left
                + ((prclClip->top + ySrcOff) * cjSrcDelta);

        if (ppdev->cPelSize == GLINTDEPTH32)
        {
            ULONG *pulDst;
            cjDstDeltaRem = (culDstDelta - cPixPerScan) << 2;
            pulDst = -1 + pulDstScan0 + xDstOff + prclClip->left
                     + prclClip->top * culDstDelta;
                     
            for (; 
                 --cScans >= 0; 
                 pjSrc += cjSrcDeltaRem, (BYTE *)pulDst += cjDstDeltaRem)
            {
                for(c = cPixPerScan; --c >= 0;)
                {
                    *++pulDst = aulXlate[*++pjSrc];
                }
            }
        }
        else // (GLINTDEPTH16)
        {
            USHORT *pusDst;
            cjDstDeltaRem = 
                        (culDstDelta << 2) - (cPixPerScan << ppdev->cPelSize);
                        
            pusDst = -1 + (USHORT *)pulDstScan0 + xDstOff + prclClip->left
                        + ((prclClip->top * culDstDelta) << 1);
                     
            for (; 
                 --cScans >= 0; 
                 pjSrc += cjSrcDeltaRem, (BYTE *)pusDst += cjDstDeltaRem)
            {
                for (c = cPixPerScan; --c >= 0;)
                {
                    *++pusDst = (USHORT)aulXlate[*++pjSrc];
                }
            }
        }
    }
}

//@@BEGIN_DDKSPLIT
#if 0
/**************************************************************************\
*
* void pxrxMonoDownloadRLE
*
\**************************************************************************/
void pxrxMonoDownloadRLE( 
    PPDEV ppdev, 
    ULONG AlignWidth, 
    ULONG *pjSrc, 
    LONG lSrcDelta, 
    LONG cy ) 
{
    ULONG   len, data, holdCount;
    ULONG   *tagPtr = NULL;
    GLINT_DECL;

    WAIT_PXRX_DMA_TAGS( 1 );
    QUEUE_PXRX_DMA_TAG( __GlintTagDownloadTarget, 
                        __GlintTagBitMaskPattern );

    if( AlignWidth == 32 ) 
    {
        ULONG   bits;
        DISPDBG((DBGLVL, "Doing Single Word per scan download"));

        WAIT_PXRX_DMA_DWORDS( cy + 1 );

        while( cy-- ) 
        {
            TEST_DWORD_ALIGNED( pjSrc );
            data = *pjSrc;
            pjSrc += lSrcDelta;
            len = 1;

            TEST_DWORD_ALIGNED( pjSrc );
            while( cy && (*pjSrc == data) ) 
            {
                pjSrc += lSrcDelta;
                len++;
                cy--;
                TEST_DWORD_ALIGNED( pjSrc );
            }

            if( len >= 4 ) 
            {
                if( tagPtr ) 
                {
                    *tagPtr = ASSEMBLE_PXRX_DMA_HOLD( __GlintTagBitMaskPattern,
                                                      holdCount );
                    tagPtr = NULL;
                }

                QUEUE_PXRX_DMA_INDEX2( __GlintTagRLData, __GlintTagRLCount );
                QUEUE_PXRX_DMA_DWORD( data );
                QUEUE_PXRX_DMA_DWORD( len );
                len = 0;
            } 
            else 
            {
                if( !tagPtr ) 
                {
                    QUEUE_PXRX_DMA_DWORD_DELAYED( tagPtr );
                    holdCount = 0;
                }

                holdCount += len;
                while( len-- )
                {
                    QUEUE_PXRX_DMA_DWORD( data );
                }
            }
        }

        if( tagPtr ) 
        {
            *tagPtr = ASSEMBLE_PXRX_DMA_HOLD( __GlintTagBitMaskPattern, 
                                              holdCount );
            tagPtr = NULL;
        }
    } 
    else 
    {
        // multiple 32 bit words per scanline. convert the delta to the
        // delta as we need it at the end of each line by subtracting the
        // width in bytes of the data we're downloading. Note, pjSrc
        // is always 1 LONG short of the end of the line because we break
        // before adding on the last ULONG. Thus, we subtract sizeof(ULONG)
        // from the original adjustment.
        LONG    nRemainder;
        ULONG   bits;
        LONG    lSrcDeltaScan = lSrcDelta - (AlignWidth >> 5);

        DISPDBG((DBGLVL, "Doing Multiple Word per scan download"));

        while( TRUE ) 
        {
            nRemainder = AlignWidth >> 5;
            WAIT_PXRX_DMA_DWORDS( nRemainder + 1 );

            while( nRemainder-- ) 
            {
                TEST_DWORD_ALIGNED( pjSrc );
                data = *(pjSrc++);
                len = 1;

                TEST_DWORD_ALIGNED( pjSrc );
                while( nRemainder && (*pjSrc == data) ) 
                {
                    pjSrc++;
                    len++;
                    nRemainder--;
                    TEST_DWORD_ALIGNED( pjSrc );
                }

                if( len >= 4 ) 
                {
                    if( tagPtr ) 
                    {
                        *tagPtr = ASSEMBLE_PXRX_DMA_HOLD( 
                                            __GlintTagBitMaskPattern, 
                                            holdCount );
                        tagPtr = NULL;
                    }

                    QUEUE_PXRX_DMA_INDEX2( __GlintTagRLData, 
                                           __GlintTagRLCount );
                    QUEUE_PXRX_DMA_DWORD( data );
                    QUEUE_PXRX_DMA_DWORD( len );
                    len = 0;
                } 
                else 
                {
                    if( !tagPtr ) 
                    {
                        QUEUE_PXRX_DMA_DWORD_DELAYED( tagPtr );
                        holdCount = 0;
                    }

                    holdCount += len;
                    while( len-- )
                    {
                        QUEUE_PXRX_DMA_DWORD( data );
                    }
                }
            }

            if( tagPtr ) 
            {
                *tagPtr = ASSEMBLE_PXRX_DMA_HOLD( __GlintTagBitMaskPattern, 
                                                  holdCount );
                tagPtr = NULL;
            }

            if( --cy == 0 )
            {
                break;
            }

            SEND_PXRX_DMA_BATCH;
            pjSrc += lSrcDeltaScan;
        }
    }
    SEND_PXRX_DMA_BATCH;
}


//*********************************************************************************************
// FUNC: pxrxRLEFifoUpload
// ARGS: ppdev (I) - pointer to the physical device object
//       crcl (I) - number of destination clipping rectangles
//       prcl (I) - array of destination clipping rectangles
//       psoDst (I) - destination surface
//       pptlSrc (I) - offset into source surface
//       prclDst (I) - unclipped destination rectangle
// RETN:  void
//---------------------------------------------------------------------------------------------
// upload from on-chip source into host memory surface. Upload in spans (64-bit aligned) to 
// minimise messages through the core and entries in the host out fifo. Upload is RLE encoded.
//*********************************************************************************************
VOID pxrxRLEFifoUpload(PPDEV ppdev, LONG crcl, RECTL *prcl, SURFOBJ *psoDst, POINTL *pptlSrc, RECTL *prclDst)
{
    LONG    xDomSrc, xSubSrc, yStartSrc, cxSrc, cySrc;
    LONG    culPerSrcScan;
    LONG    culDstDelta;
    BOOL    bRemPerSrcScan;
    ULONG   *pulDst, *pulDstScan;
    ULONG   leftMask, rightMask;
    LONG    cul, ul;
    LONG    cFifoSpaces;
    ULONG   RLECount, RLEData;
    __GlintFilterModeFmat FilterMode;
    GLINT_DECL;

    DISPDBG((7, "pxrxFifoUpload: prcl = (%d, %d -> %d, %d), prclDst = (%d, %d -> %d, %d), ptlSrc(%d, %d), count = %d",
                 prcl->left, prcl->top, prcl->right, prcl->bottom, 
                 prclDst->left, prclDst->top, prclDst->right, prclDst->bottom, pptlSrc->x, pptlSrc->y, crcl));

    DISPDBG((7, "pxrxFifoUpload: psoDst: cx = %d, cy = %d, lDelta = %d, pvScan0=%P)",
                 psoDst->sizlBitmap.cx, psoDst->sizlBitmap.cy, psoDst->lDelta, psoDst->pvScan0));
    DISPDBG((7, "pxrxFifoUpload: xyOffsetDst = (%d, %d), xyOffsetSrc = (%d, %d)",
                 ppdev->xyOffsetDst & 0xFFFF, ppdev->xyOffsetDst >> 16,
                 ppdev->xyOffsetSrc & 0xFFFF, ppdev->xyOffsetSrc >> 16));

    ASSERTDD(psoDst->iBitmapFormat == ppdev->iBitmapFormat, "Dest must be same colour depth as screen");
    ASSERTDD(crcl > 0, "Can't handle zero rectangles");

    WAIT_PXRX_DMA_TAGS(6);
    QUEUE_PXRX_DMA_TAG( __GlintTagRLEMask,  0xffffffff);
    LOAD_CONFIG2D(__CONFIG2D_FBDESTREAD);
    SET_READ_BUFFERS;

    // enable filter mode so we can get Sync and color messages on the output FIFO
    *(DWORD *)(&FilterMode) = 0;   
    FilterMode.Synchronization = __GLINT_FILTER_TAG;
    FilterMode.Color             = __GLINT_FILTER_DATA;
    FilterMode.RLEHostOut      = TRUE;
    QUEUE_PXRX_DMA_TAG(__GlintTagFilterMode, *(DWORD*)(&FilterMode));

    for(; --crcl >= 0; ++prcl) 
    {
        DISPDBG((7, "pxrxFifoUpload: dest prcl(%xh,%xh..%xh,%xh)", prcl->left, prcl->top, prcl->right, prcl->bottom));

        // calculate pixel-aligned source
        xDomSrc   = pptlSrc->x + prcl->left  - prclDst->left;
        xSubSrc   = pptlSrc->x + prcl->right - prclDst->left;
        yStartSrc = pptlSrc->y + prcl->top   - prclDst->top;
        cySrc     = prcl->bottom - prcl->top;

        DISPDBG((8, "pxrxFifoUpload: src (%xh,%xh..%xh,%xh)", xDomSrc, yStartSrc, xSubSrc, yStartSrc + cySrc));

        // will upload ulongs aligned to ulongs
        if (ppdev->cPelSize == GLINTDEPTH32) 
        {
            cxSrc = xSubSrc - xDomSrc;
            culPerSrcScan = cxSrc;
            leftMask  = 0xFFFFFFFF;
            rightMask = 0xFFFFFFFF;
        }    
        else 
        {
            if (ppdev->cPelSize == GLINTDEPTH16) 
            {
                ULONG cPixFromUlongBoundary = prcl->left & 1;

                xDomSrc -= cPixFromUlongBoundary;
                cxSrc = xSubSrc - xDomSrc;
                culPerSrcScan  = (xSubSrc - xDomSrc + 1) >> 1;

                leftMask  = 0xFFFFFFFF << (cPixFromUlongBoundary << 4);
                rightMask = 0xFFFFFFFF >> (((xDomSrc - xSubSrc) & 1) << 4);

            }
            else 
            {
                ULONG cPixFromUlongBoundary = prcl->left & 3;

                xDomSrc -= cPixFromUlongBoundary;
                cxSrc = xSubSrc - xDomSrc;
                culPerSrcScan  = (xSubSrc - xDomSrc + 3) >> 2;

                leftMask  = 0xFFFFFFFF << (cPixFromUlongBoundary << 3);
                rightMask = 0xFFFFFFFF >> (((xDomSrc - xSubSrc) & 3) << 3);

            }     
            // We just want a single mask if the area to upload is less than one word wide.
            if (culPerSrcScan == 1)
                leftMask &= rightMask;
        }

        // uploading 64 bit aligned source
        bRemPerSrcScan = culPerSrcScan & 1;

        // the remainder will be encoded in the run: it's simpler just to add it in now
        // then check bRemPerSrcScan during the upload
        DISPDBG((8, "pxrxFifoUpload: Adding remainder into culPerSrcScan for RLE"));
        culPerSrcScan += bRemPerSrcScan;

        // Work out where the destination data goes to
        culDstDelta = psoDst->lDelta >> 2;
        pulDst = ((ULONG *)psoDst->pvScan0) + (prcl->left >> (2 - ppdev->cPelSize)) + culDstDelta * prcl->top;

        DISPDBG((8, "pxrxFifoUpload: uploading aligned src (%xh,%xh..%xh,%xh)", xDomSrc, yStartSrc, 
                                                                             xDomSrc + cxSrc, yStartSrc + cySrc));

        // Render the rectangle
        WAIT_PXRX_DMA_TAGS(2);
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,MAKEDWORD_XY(xDomSrc, yStartSrc));
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,         __RENDER2D_OP_NORMAL | __RENDER2D_SPANS |
                                                        __RENDER2D_INCY | __RENDER2D_INCX | 
                                                        __RENDER2D_WIDTH(cxSrc) | __RENDER2D_HEIGHT(cySrc));
        SEND_PXRX_DMA_FORCE;
        
        // If the start and end masks are 0xffffffff, we can just upload the words and put them
        // directly into the destination. Otherwise, or the first and last word on any scanline
        // we have to mask off any pixels that are outside the render area. We know the glint will
        // have 0 in the undesired right hand edge pixels, as these were not in the render area. We
        // dont know anything about the destination though.
        if (leftMask == 0xFFFFFFFF && rightMask == 0xFFFFFFFF) 
        {
            DISPDBG((8, "pxrxFifoUpload: no edge masks"));
            while (--cySrc >= 0) 
            {
                pulDstScan = pulDst;
                pulDst += culDstDelta;

                DISPDBG((9, "pxrxFifoUpload: uploading scan of %xh ulongs to %p (Remainder %xh)", 
                            culPerSrcScan, pulDstScan, bRemPerSrcScan));

                cul = culPerSrcScan;
                while(cul)
                {
                    WAIT_OUTPUT_FIFO_COUNT(2);
                    READ_OUTPUT_FIFO(RLECount);
                    READ_OUTPUT_FIFO(RLEData);
                    DISPDBG((10, "pxrxFifoUpload: RLECount = %xh RLEData = 08.8xh", RLECount, RLEData));
                    cul -= RLECount;
                    if(cul == 0 && bRemPerSrcScan)
                    {
                        // discard the last ulong
                        --RLECount;
                    }
                    while(RLECount--)
                    {
                        DISPDBG((10, "pxrxFifoUpload: written ulong"));
                           *pulDstScan++ = RLEData;
                    }
                }
            }
        }
        else if(culPerSrcScan == 1)
        {
            DISPDBG((8, "pxrxFifoUpload: single ulong per scan"));

            while (--cySrc >= 0) 
            {
                // the remainder has already been added into culPerSrcScan so this can't happen
                DISPDBG((ERRLVL,"pxrxFifoUpload: got single ulong per scan - but we always upload 64 bit quanta!"));
                pulDst += culDstDelta;
            }
        }
        else
        {
            DISPDBG((8, "pxrxFifoUpload: scan with left & right edge masks: %08.8x .. %08.8x", leftMask, rightMask));

            while (--cySrc >= 0) 
            {
                pulDstScan = pulDst;
                pulDst += culDstDelta;

                DISPDBG((9, "pxrxFifoUpload: uploading scan of %xh ulongs to %p", culPerSrcScan, pulDstScan));

                cul = culPerSrcScan;
                while(cul)
                {
                    WAIT_OUTPUT_FIFO_COUNT(2);
                    READ_OUTPUT_FIFO(RLECount);
                    READ_OUTPUT_FIFO(RLEData);
                    DISPDBG((10, "pxrxFifoUpload: RLECount = %xh RLEData = %08.8xh", RLECount, RLEData));

                    if(cul - bRemPerSrcScan == 0)
                    {
                        DISPDBG((10, "pxrxFifoUpload: discarding last ulong"));
                        break;
                    }

                    if(culPerSrcScan - bRemPerSrcScan == 1)
                    {
                        // one pixel per scan
                        DISPDBG((10, "pxrxFifoUpload: written single pixel scan"));
                        *pulDstScan = (*pulDstScan & ~leftMask) | (RLEData & leftMask);
                        cul -= RLECount;
                        continue;
                    }

                    if(cul == culPerSrcScan)
                    {
                        DISPDBG((10, "pxrxFifoUpload: written left edge"));
                        *pulDstScan++ = (*pulDstScan & ~leftMask) | (RLEData & leftMask); // first ulong
                        --RLECount;
                        --cul;
                    }
                    cul -= RLECount;
                    if(cul == 0)
                    {
                        // this is the last run of the scan: process the last ulong separately in order
                        // to apply the right edge mask
                        RLECount -= 1 + bRemPerSrcScan;
                    }
                    else if(cul - bRemPerSrcScan == 0)
                    {
                        // this is the penultimate run of the scan and the last one will just include the
                        // remainder: process the last ulong separately in order to apply the right edge mask
                        --RLECount;
                    }
                    while(RLECount--)
                    {
                        DISPDBG((10, "pxrxFifoUpload: written middle ulong"));
                           *pulDstScan++ = RLEData;
                    }

                    if(cul == 0 || cul - bRemPerSrcScan == 0)
                    {
                        DISPDBG((10, "pxrxFifoUpload: written right edge"));
                        *pulDstScan = (*pulDstScan & ~rightMask) | (RLEData & rightMask); // last ulong
#if DBG
                        if(cul - bRemPerSrcScan == 0)
                        {
                            DISPDBG((10, "pxrxFifoUpload: discarding last ulong"));
                        }
#endif
                    }
                }
            }
        }
    }

#if DBG
    cul = 0xaa55aa55;
    DISPDBG((8, "pxrxFifoUpload: waiting for sync (id = %08.8xh)", cul));
    WAIT_PXRX_DMA_TAGS(1);
    QUEUE_PXRX_DMA_TAG(__GlintTagSync, cul);
    SEND_PXRX_DMA_FORCE;
    do
    {
        WAIT_OUTPUT_FIFO_READY;
        READ_OUTPUT_FIFO(ul);
        DISPDBG((8, "pxrxFifoUpload: read %08.8xh from output FIFO", ul));
        if(ul != __GlintTagSync)
        {
            DISPDBG((ERRLVL,"pxrxFifoUpload: didn't read back sync!"));
        }
    }
    while(ul != __GlintTagSync);
    DISPDBG((8, "pxrxFifoUpload: got sync"));
#endif

    // no need to initiate DMA with this tag - it will get flushed with the next primitive and
    // meanwhile will not affect local memory
    WAIT_PXRX_DMA_TAGS(1);
    QUEUE_PXRX_DMA_TAG(__GlintTagFilterMode, 0);
    SEND_PXRX_DMA_BATCH;

    GLINT_CORE_IDLE;

    DISPDBG((7, "pxrxFifoUpload: done"));
}


//****************************************************************************
// FUNC: vGlintCopyBltBypassDownload32bpp
// DESC: using the bypass mechanism we can take advantage of write-combining
//       which can be quicker than using the FIFO
//****************************************************************************

VOID vGlintCopyBltBypassDownload32bpp(
PDEV    *ppdev,
SURFOBJ *psoSrc,
POINTL  *pptlSrc,
RECTL   *prclDst,
RECTL   *prclClip,
LONG    crclClip)
{
    LONG    xOff;
    ULONG   *pulSrcScan0;
    LONG    culSrcDelta, xSrcOff, ySrcOff;
    ULONG   *pulDstScan0;
    LONG    culDstDelta, xDstOff;
    LONG    cScans, cPixPerScan, c;
    ULONG   cjSrcDeltaRem, cjDstDeltaRem;
    ULONG   *pulSrc;
    ULONG   *pulDst;
    ULONG   tmp0, tmp1, tmp2;
    GLINT_DECL;

#if DBG && 0
    {
        SIZEL sizlDst;
        sizlDst.cx = prclClip->right - prclClip->left;
        sizlDst.cy = prclClip->bottom - prclClip->top;
        DISPDBG((-1, "vGlintCopyBltBypassDownload32bpp(): cRects(%d) sizlDst(%d,%d)", crclClip, sizlDst.cx, sizlDst.cy));
    }
#endif //DBG

    pulSrcScan0 = (ULONG *)psoSrc->pvScan0;
    culSrcDelta = psoSrc->lDelta >> 2;
    xSrcOff = pptlSrc->x - prclDst->left; // need to add arclClip[n].left to get xSrc
    ySrcOff = pptlSrc->y - prclDst->top;  // need to add arclClip[n].top to get ySrc

    pulDstScan0 = (ULONG *)ppdev->pjScreen;
    culDstDelta = ppdev->DstPixelDelta >> (2 - ppdev->cPelSize);
    xDstOff     = ppdev->DstPixelOrigin + (ppdev->xyOffsetDst & 0xffff) +
                  (ppdev->xyOffsetDst >> 16) * ppdev->DstPixelDelta;

    SYNC_IF_CORE_BUSY;

    for (; --crclClip >= 0; ++prclClip)
    {
        cScans = prclClip->bottom - prclClip->top;
        cPixPerScan = prclClip->right - prclClip->left;
        cjSrcDeltaRem = (culSrcDelta - cPixPerScan) * 4;
        cjDstDeltaRem = (culDstDelta - cPixPerScan) * 4;

        // calc source & destination address, -1 to allow for prefix-increment
        pulSrc = -1 + pulSrcScan0 + xSrcOff + prclClip->left
                 + ((prclClip->top + ySrcOff) * culSrcDelta);
        pulDst = -1 + pulDstScan0 + xDstOff + prclClip->left
                 + prclClip->top * culDstDelta;

        for (; --cScans >= 0; (BYTE *)pulSrc += cjSrcDeltaRem, (BYTE *)pulDst += cjDstDeltaRem)
        {
#if defined(_X86_)
            __asm
            {
                mov     edi, pulDst
                mov     ecx, cPixPerScan
                mov     esi, pulSrc
                shr     ecx, 2
                push    ebp
                test    ecx, ecx
                jle     EndOfLine
              LoopFours:
                mov     eax, [esi+4]
                mov     ebx, [esi+8]
                mov     edx, [esi+12]
                mov     ebp, [esi+16]
                add     esi, 16
                mov     [edi+4], eax
                mov     [edi+8], ebx
                add     edi, 16
                mov     [edi-4], edx
                dec     ecx
                mov     [edi], ebp
                jne     LoopFours
              EndOfLine:
                pop     ebp
                mov     pulSrc, esi
                mov     pulDst, edi
            }     
            // do the remaining 0, 1, 2 or 3 pixels on this line
            switch (cPixPerScan & 3)
            {
                case 3:
                    tmp0 = *++pulSrc;
                    tmp1 = *++pulSrc;
                    tmp2 = *++pulSrc;
                    *++pulDst = tmp0;
                    *++pulDst = tmp1;
                    *++pulDst = tmp2;
                    break;
               case 2:
                    tmp0 = *++pulSrc;
                    tmp1 = *++pulSrc;
                    *++pulDst = tmp0;
                    *++pulDst = tmp1;
                    break;
                case 1:
                    tmp0 = *++pulSrc;
                    *++pulDst = tmp0;
            }

#else
            for(c = cPixPerScan; --c >= 0;)
            {
                *++pulDst = *++pulSrc;
            }
#endif
        }
    }
}

//****************************************************************************
// FUNC: vGlintCopyBltBypassDownload24bppTo32bpp
// DESC: using the bypass mechanism we can take advantage of write-combining
//       which can be quicker than using the FIFO
//****************************************************************************

VOID vGlintCopyBltBypassDownload24bppTo32bpp(
PDEV    *ppdev,
SURFOBJ *psoSrc,
POINTL  *pptlSrc,
RECTL   *prclDst,
RECTL   *prclClip,
LONG    crclClip)
{
    LONG    xOff;
    BYTE    *pjSrcScan0;
    LONG    cjSrcDelta;
    LONG    xSrcOff, ySrcOff;
    ULONG   *pulDstScan0;
    LONG    culDstDelta, xDstOff;
    LONG    cScans, cPixPerScan, c;
    BYTE    *pjSrc;
    BYTE    *pj;
    ULONG   *pulDst, *puld;
    GLINT_DECL;

#if DBG && 0
    {
        SIZEL sizlDst;
        sizlDst.cx = prclClip->right - prclClip->left;
        sizlDst.cy = prclClip->bottom - prclClip->top;
        DISPDBG((-1, "vGlintCopyBltBypassDownload24bppTo32bpp(): cRects(%d) sizlDst(%d,%d)", crclClip, sizlDst.cx, sizlDst.cy));
    }
#endif //DBG

    pjSrcScan0 = (BYTE *)psoSrc->pvScan0;
    cjSrcDelta = psoSrc->lDelta;
    xSrcOff = pptlSrc->x - prclDst->left; // need to add arclClip[n].left to get xSrc
    ySrcOff = pptlSrc->y - prclDst->top;  // need to add arclClip[n].top to get ySrc

    pulDstScan0 = (ULONG *)ppdev->pjScreen;
    culDstDelta = ppdev->DstPixelDelta >> (2 - ppdev->cPelSize);
    xDstOff     = ppdev->DstPixelOrigin + (ppdev->xyOffsetDst & 0xffff) +
                  (ppdev->xyOffsetDst >> 16) * ppdev->DstPixelDelta;

    SYNC_IF_CORE_BUSY;

    for (; --crclClip >= 0; ++prclClip)
    {
        cScans = prclClip->bottom - prclClip->top;
        cPixPerScan = prclClip->right - prclClip->left;

        // calc source & destination address, -1 to allow for prefix-increment
        // convert x values to 24bpp coords (but avoid multiplication by 3)
        c = xSrcOff + prclClip->left;
        c = c + (c << 1);
        pjSrc = pjSrcScan0 + c + ((prclClip->top + ySrcOff) * cjSrcDelta);
        pulDst = -1 + pulDstScan0 + xDstOff + prclClip->left
                 + prclClip->top * culDstDelta;

        for (; --cScans >= 0; pjSrc += cjSrcDelta, pulDst += culDstDelta)
        {
            // read one less pixel per scan than there actually is to avoid any possibility of 
            // a memory access violation (we read 4 bytes but only 3 of them might be valid)
            for (pj = pjSrc, puld = pulDst, c = cPixPerScan-1; --c >= 0; pj += 3)
            {
                *++puld = *(ULONG *)pj & 0x00ffffff;
            }
            // now do the last pixel
            ++puld;
            *(USHORT *)puld = *(USHORT *)pj;
            ((BYTE *)puld)[2] = ((BYTE *)pj)[2];
        }
    }
}

//****************************************************************************
// FUNC: vGlintCopyBltBypassDownload16bpp
// DESC: using the bypass mechanism we can take advantage of write-combining
//       which can be quicker than using the FIFO
//****************************************************************************

VOID vGlintCopyBltBypassDownload16bpp(
PDEV    *ppdev,
SURFOBJ *psoSrc,
POINTL  *pptlSrc,
RECTL   *prclDst,
RECTL   *prclClip,
LONG     crclClip)
{
    LONG    xOff;
    ULONG   *pulSrcScan0;
    LONG    culSrcDelta, xSrcOff, ySrcOff;
    ULONG   *pulDstScan0;
    LONG    culDstDelta, xDstOff;
    LONG    cScans, cPixPerScan;
    ULONG   *pulSrc;
    ULONG   *pulDst;
    GLINT_DECL;

#if DBG && 0
    {
        SIZEL sizlDst;
        sizlDst.cx = prclClip->right - prclClip->left;
        sizlDst.cy = prclClip->bottom - prclClip->top;
        DISPDBG((-1, "vGlintCopyBltBypassDownload16bpp(): cRects(%d) sizlDst(%d,%d)", crclClip, sizlDst.cx, sizlDst.cy));
    }
#endif //DBG

    pulSrcScan0 = (ULONG *)psoSrc->pvScan0;
    culSrcDelta = psoSrc->lDelta >> 2;
    xSrcOff = pptlSrc->x - prclDst->left; // need to add arclClip[n].left to get xSrc
    ySrcOff = pptlSrc->y - prclDst->top;  // need to add arclClip[n].top to get ySrc

    pulDstScan0 = (ULONG *)ppdev->pjScreen;
    culDstDelta = ppdev->DstPixelDelta >> (2 - ppdev->cPelSize);
    xDstOff     = ppdev->DstPixelOrigin + (ppdev->xyOffsetDst & 0xffff) +
                  (ppdev->xyOffsetDst >> 16) * ppdev->DstPixelDelta;

    SYNC_IF_CORE_BUSY;

    for (; --crclClip >= 0; ++prclClip)
    {
        cScans = prclClip->bottom - prclClip->top;
        cPixPerScan = prclClip->right - prclClip->left;

        pulSrc = (ULONG *)((USHORT *)pulSrcScan0 + xSrcOff + prclClip->left)
                   + ((prclClip->top + ySrcOff) * culSrcDelta);
        pulDst = (ULONG *)((USHORT *)pulDstScan0 + xDstOff + prclClip->left)
                   + prclClip->top * culDstDelta;

        for (; --cScans >= 0; pulSrc += culSrcDelta, pulDst += culDstDelta)
        {
            ULONG   *pulSrcScan = pulSrc;
            ULONG   *pulDstScan = pulDst;
            LONG    cPix = cPixPerScan;
            LONG    cWords;

            if ((UINT_PTR)pulDstScan % sizeof(ULONG))
            {
                // we're not on a ulong boundary so write the first pixel of the scanline
                *(USHORT *)pulDstScan = *(USHORT *)pulSrcScan;
                pulDstScan = (ULONG *)((USHORT *)pulDstScan + 1);
                pulSrcScan = (ULONG *)((USHORT *)pulSrcScan + 1);
                --cPix;
            }

            // write out the ulong-aligned words of the scanline
            for (cWords = cPix / 2; --cWords >= 0;)
            {
                *pulDstScan++ = *pulSrcScan++;
            }

            // write any remaining pixel
            if (cPix % 2)
            {
                *(USHORT *)pulDstScan = *(USHORT *)pulSrcScan;
            }
        }
    }
}

//****************************************************************************
// FUNC: vGlintCopyBltBypassDownloadXlate4bpp
// DESC: using the bypass mechanism we can take advantage of write-combining
//       which can be quicker than using the FIFO
// NB. supports 32bpp and 16bpp destinations. Doesn't yet support 24bpp 
//     destinations. No plans to add 8bpp support.
//****************************************************************************

VOID vGlintCopyBltBypassDownloadXlate4bpp(
PDEV     *ppdev,
SURFOBJ  *psoSrc,
POINTL   *pptlSrc,
RECTL    *prclDst,
RECTL    *prclClip,
LONG      crclClip,
XLATEOBJ *pxlo)
{
    LONG    xOff;
    BYTE    *pjSrcScan0;
    LONG    cjSrcDelta, xSrcOff, ySrcOff;
    ULONG   *pulDstScan0;
    LONG    culDstDelta, xDstOff;
    LONG    cScans, cPixPerScan, c;
    ULONG   cjSrcDeltaRem, cjDstDeltaRem;
    ULONG   *aulXlate;
    BOOL    bSrcLowNybble;
    BYTE    *pjSrc, j, *pj;
    GLINT_DECL;

#if DBG && 0
    {
        SIZEL sizlDst;
        sizlDst.cx = prclClip->right - prclClip->left;
        sizlDst.cy = prclClip->bottom - prclClip->top;
        DISPDBG((-1, "vGlintCopyBltBypassDownloadXlate4bpp(): cRects(%d) sizlDst(%d,%d)", crclClip, sizlDst.cx, sizlDst.cy));
    }
#endif //DBG

    pjSrcScan0 = (BYTE *)psoSrc->pvScan0;
    cjSrcDelta = psoSrc->lDelta;
    xSrcOff = pptlSrc->x - prclDst->left; // need to add arclClip[n].left to get xSrc
    ySrcOff = pptlSrc->y - prclDst->top;  // need to add arclClip[n].top to get ySrc

    pulDstScan0 = (ULONG *)ppdev->pjScreen;
    culDstDelta = ppdev->DstPixelDelta >> (2 - ppdev->cPelSize);
    xDstOff     = ppdev->DstPixelOrigin + (ppdev->xyOffsetDst & 0xffff) +
                  (ppdev->xyOffsetDst >> 16) * ppdev->DstPixelDelta;

    aulXlate = pxlo->pulXlate;

    SYNC_IF_CORE_BUSY;

    for (; --crclClip >= 0; ++prclClip)
    {
        cScans = prclClip->bottom - prclClip->top;
        cPixPerScan = prclClip->right - prclClip->left;
        bSrcLowNybble = (xSrcOff + prclClip->left) & 1;
        cjSrcDeltaRem = cjSrcDelta - (cPixPerScan / 2 + ((cPixPerScan & 1) || bSrcLowNybble));
        pjSrc = -1 + pjSrcScan0 + (xSrcOff + prclClip->left) / 2 
                + ((prclClip->top + ySrcOff) * cjSrcDelta);

        if (ppdev->cPelSize == GLINTDEPTH32)
        {
            ULONG   *pulDst;

            cjDstDeltaRem = (culDstDelta - cPixPerScan) * 4;
            pulDst = -1 + pulDstScan0 + xDstOff + prclClip->left + prclClip->top * culDstDelta;

            if (bSrcLowNybble)
            {
                for (; --cScans >= 0; pjSrc += cjSrcDeltaRem, (BYTE *)pulDst += cjDstDeltaRem)
                {
                    j = *++pjSrc;
                    for (c = cPixPerScan / 2; --c >= 0;)
                    {
                        *++pulDst = aulXlate[j & 0xf];
                        j = *++pjSrc;
                        *++pulDst = aulXlate[j >> 4];
                    }
                    if (cPixPerScan & 1)
                    {
                        *++pulDst = aulXlate[j & 0xf];
                    }
                }
            }
            else
            {
                for (; --cScans >= 0; pjSrc += cjSrcDeltaRem, (BYTE *)pulDst += cjDstDeltaRem)
                {
                    for (c = cPixPerScan / 2; --c >= 0;)
                    {
                        j = *++pjSrc;
                        *++pulDst = aulXlate[j >> 4];
                        *++pulDst = aulXlate[j & 0xf];
                    }
                    if (cPixPerScan & 1)
                    {
                        j = *++pjSrc;
                        *++pulDst = aulXlate[j >> 4];
                    }
                }
            }
        }
        else if (ppdev->cPelSize == GLINTDEPTH16)
        {
            USHORT  *pusDst;

            cjDstDeltaRem = (culDstDelta << 2) - (cPixPerScan << ppdev->cPelSize);
            pusDst = -1 + (USHORT *)pulDstScan0 + xDstOff + prclClip->left
                     + prclClip->top * culDstDelta * 2;

            if (bSrcLowNybble)
            {
                for (; --cScans >= 0; pjSrc += cjSrcDeltaRem, (BYTE *)pusDst += cjDstDeltaRem)
                {
                    j = *++pjSrc;
                    for (c = cPixPerScan / 2; --c >= 0;)
                    {
                        *++pusDst = (USHORT)aulXlate[j & 0xf];
                        j = *++pjSrc;
                        *++pusDst = (USHORT)aulXlate[j >> 4];
                    }
                    if (cPixPerScan & 1)
                    {
                        *++pusDst = (USHORT)aulXlate[j & 0xf];
                    }
                }
            }
            else
            {
                for (; --cScans >= 0; pjSrc += cjSrcDeltaRem, (BYTE *)pusDst += cjDstDeltaRem)
                {
                    for (c = cPixPerScan / 2; --c >= 0;)
                    {
                        j = *++pjSrc;
                        *++pusDst = (USHORT)aulXlate[j >> 4];
                        *++pusDst = (USHORT)aulXlate[j & 0xf];
                    }
                    if (cPixPerScan & 1)
                    {
                        j = *++pjSrc;
                        *++pusDst = (USHORT)aulXlate[j >> 4];
                    }
                }
            }
        }
    }
}

#endif
//@@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\stroke.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: Stroke.c
*
* Content: DrvStrokePath support
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"

typedef VOID    (* GAPFNstripFunc)(PPDEV, STRIP*, LINESTATE*);

GAPFNstripFunc  gapfnStripPXRX[] =
{
    vPXRXSolidHorizontalLine,
    vPXRXSolidVerticalLine,
    vPXRXSolidDiagonalHorizontalLine,
    vPXRXSolidDiagonalVerticalLine,

// Should be NUM_STRIP_DRAW_DIRECTIONS = 4 strip drawers in every group

    vPXRXSolidHorizontalLine,
    vPXRXSolidVerticalLine,
    vPXRXSolidDiagonalHorizontalLine,
    vPXRXSolidDiagonalVerticalLine,

// Should be NUM_STRIP_DRAW_STYLES = 8 strip drawers in total for doing
// solid lines, and the same number for non-solid lines:

    vPXRXStyledHorizontalLine,
    vPXRXStyledVerticalLine,
    vPXRXStyledVerticalLine,  // Diagonal goes here
    vPXRXStyledVerticalLine,  // Diagonal goes here

    vPXRXStyledHorizontalLine,
    vPXRXStyledVerticalLine,
    vPXRXStyledVerticalLine,  // Diagonal goes here
    vPXRXStyledVerticalLine,  // Diagonal goes here
};

// Style array for alternate style (alternates one pixel on, one pixel off):

STYLEPOS gaspAlternateStyle[] = { 1 };

/******************************Public*Routine******************************\
* BOOL DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix)
*
* Strokes the path.
*
\**************************************************************************/

BOOL DrvStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)
{
    STYLEPOS  aspLtoR[STYLE_MAX_COUNT];
    STYLEPOS  aspRtoL[STYLE_MAX_COUNT];
    LINESTATE ls;
    PFNSTRIP* apfn;
    FLONG     fl;
    PDEV*     ppdev;
    DSURF*    pdsurf;
    OH*       poh;
    RECTL     arclClip[4];                  // For rectangular clipping
    BOOL      ResetGLINT;                   // Does GLINT need resetting?
    BOOL      bRet;
    DWORD     logicOp;
    GLINT_DECL_VARS;

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB or if Glint Line debugging has been turned off.

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt & DT_DIB)
    {
        return(EngStrokePath(pdsurf->pso, ppo, pco, pxo, pbo, pptlBrush,
                             pla, mix));
    }

    ppdev = (PDEV*) pso->dhpdev;
    GLINT_DECL_INIT;

    REMOVE_SWPOINTER(pso);

    DISPDBG((DBGLVL, "Drawing Lines through GLINT"));

    // We'll be drawing to the screen or an off-screen DFB; copy the surface's
    // offset now so that we won't need to refer to the DSURF again:

    SETUP_PPDEV_OFFSETS(ppdev, pdsurf);

    fl = 0;

    // Look after styling initialization:

    if (pla->fl & LA_ALTERNATE)
    {
        ls.cStyle      = 1;
        ls.spTotal     = 1;
        ls.spTotal2    = 2;
        ls.spRemaining = 1;
        ls.aspRtoL     = &gaspAlternateStyle[0];
        ls.aspLtoR     = &gaspAlternateStyle[0];
        ls.spNext      = HIWORD(pla->elStyleState.l);
        ls.xyDensity   = 1;
        fl            |= FL_ARBITRARYSTYLED;
        ls.ulStartMask = 0L;
    }
    else if (pla->pstyle != (FLOAT_LONG*) NULL)
    {
        PFLOAT_LONG pstyle;
        STYLEPOS*   pspDown;
        STYLEPOS*   pspUp;

        pstyle = &pla->pstyle[pla->cstyle];

        ls.xyDensity = STYLE_DENSITY;
        ls.spTotal   = 0;
        while (pstyle-- > pla->pstyle)
        {
            ls.spTotal += pstyle->l;
        }
        ls.spTotal *= STYLE_DENSITY;
        ls.spTotal2 = 2 * ls.spTotal;

        // Compute starting style position (this is guaranteed not to overflow):

        ls.spNext = HIWORD(pla->elStyleState.l) * STYLE_DENSITY +
                    LOWORD(pla->elStyleState.l);

        fl        |= FL_ARBITRARYSTYLED;
        ls.cStyle  = pla->cstyle;
        ls.aspRtoL = aspRtoL;
        ls.aspLtoR = aspLtoR;

        if (pla->fl & LA_STARTGAP)
            ls.ulStartMask = 0xffffffffL;
        else
            ls.ulStartMask = 0L;

        pstyle  = pla->pstyle;
        pspDown = &ls.aspRtoL[ls.cStyle - 1];
        pspUp   = &ls.aspLtoR[0];

        while (pspDown >= &ls.aspRtoL[0])
        {
            *pspDown = pstyle->l * STYLE_DENSITY;
            *pspUp   = *pspDown;

            pspUp++;
            pspDown--;
            pstyle++;
        }
    }

    bRet = TRUE;
    apfn = &ppdev->gapfnStrip[NUM_STRIP_DRAW_STYLES * ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];

    // Set up to enumerate the path:

    if (pco->iDComplexity != DC_COMPLEX)
    {
        PATHDATA  pd;
        RECTL*    prclClip = (RECTL*) NULL;
        BOOL      bMore;
        ULONG     cptfx;
        POINTFIX  ptfxStartFigure;
        POINTFIX  ptfxLast;
        POINTFIX* pptfxFirst;
        POINTFIX* pptfxBuf;

        if (pco->iDComplexity == DC_RECT)
        {
            fl |= FL_SIMPLE_CLIP;

            // This is the only clip region of importance to GLINT
            arclClip[0]        =  pco->rclBounds;

            // FL_FLIP_D:

            arclClip[1].top    =  pco->rclBounds.left;
            arclClip[1].left   =  pco->rclBounds.top;
            arclClip[1].bottom =  pco->rclBounds.right;
            arclClip[1].right  =  pco->rclBounds.bottom;

            // FL_FLIP_V:

            arclClip[2].top    = -pco->rclBounds.bottom + 1;
            arclClip[2].left   =  pco->rclBounds.left;
            arclClip[2].bottom = -pco->rclBounds.top + 1;
            arclClip[2].right  =  pco->rclBounds.right;

            // FL_FLIP_V | FL_FLIP_D:

            arclClip[3].top    =  pco->rclBounds.left;
            arclClip[3].left   = -pco->rclBounds.bottom + 1;
            arclClip[3].bottom =  pco->rclBounds.right;
            arclClip[3].right  = -pco->rclBounds.top + 1;

            prclClip = arclClip;
        }

        pd.flags = 0;

        // Get the logic op and set up the flag to indicate reads from
        // the frame buffer will occur.
        logicOp = GlintLogicOpsFromR2[mix & 0xff];
        if (LogicopReadDest[logicOp])
            fl |= FL_READ;

        // Need to set up Glint modes and colors appropriately for the lines.

        ResetGLINT = (*ppdev->pgfnInitStrips)(ppdev, pbo->iSolidColor,
                            logicOp, prclClip);

        PATHOBJ_vEnumStart(ppo);

        do {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            cptfx = pd.count;
            if (cptfx == 0)
            {
                break;
            }

            if (pd.flags & PD_BEGINSUBPATH)
            {
                ptfxStartFigure  = *pd.pptfx;
                pptfxFirst       = pd.pptfx;
                pptfxBuf         = pd.pptfx + 1;
                cptfx--;
            }
            else
            {
                pptfxFirst       = &ptfxLast;
                pptfxBuf         = pd.pptfx;
            }

            if (pd.flags & PD_RESETSTYLE)
            {
                ls.spNext = 0;
            }

            if (cptfx > 0)
            {
                if (!bLines(ppdev,
                            pptfxFirst,
                            pptfxBuf,
                            (RUN*) NULL,
                            cptfx,
                            &ls,
                            prclClip,
                            apfn,
                            fl)) {
                    bRet = FALSE;
                    goto ResetReturn;
                }
            }

            ptfxLast = pd.pptfx[pd.count - 1];

            if (pd.flags & PD_CLOSEFIGURE)
            {
                if (!bLines(ppdev,
                            &ptfxLast,
                            &ptfxStartFigure,
                            (RUN*) NULL,
                            1,
                            &ls,
                            prclClip,
                            apfn,
                            fl)) {
                    bRet = FALSE;
                    goto ResetReturn;
                }
            }
        } while (bMore);

        if (fl & FL_STYLED)
        {
            // Save the style state:

            ULONG ulHigh;
            ULONG ulLow;

            // Masked styles don't normalize the style state.  It's a good
            // thing to do, so let's do it now:

            if ((ULONG) ls.spNext >= (ULONG) ls.spTotal2)
            {
                ls.spNext = (ULONG) ls.spNext % (ULONG) ls.spTotal2;
            }

            ulHigh = ls.spNext / ls.xyDensity;
            ulLow  = ls.spNext % ls.xyDensity;

            pla->elStyleState.l = MAKELONG(ulLow, ulHigh);
        }
    }
    else
    {
        // Local state for path enumeration:

        BOOL bMore;
        union {
            BYTE     aj[FIELD_OFFSET(CLIPLINE, arun) + RUN_MAX * sizeof(RUN)];
            CLIPLINE cl;
        } cl;

        fl |= FL_COMPLEX_CLIP;

        // Need to set up Glint modes and colors appropriately for the lines.
        // NOTE, with a complex clip, we can not yet use GLINT for fast lines

        ResetGLINT = (*ppdev->pgfnInitStrips)(ppdev, pbo->iSolidColor,
                            GlintLogicOpsFromR2[mix & 0xff], NULL);

        // We use the clip object when non-simple clipping is involved:

        PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pla);

        do {
            bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(cl), &cl.cl);
            if (cl.cl.c != 0)
            {
                if (fl & FL_STYLED)
                {
                    ls.spComplex = HIWORD(cl.cl.lStyleState) * ls.xyDensity
                                 + LOWORD(cl.cl.lStyleState);
                }

                if (!bLines(ppdev,
                            &cl.cl.ptfxA,
                            &cl.cl.ptfxB,
                            &cl.cl.arun[0],
                            cl.cl.c,
                            &ls,
                            (RECTL*) NULL,
                            apfn,
                            fl))
                {
                    bRet = FALSE;
                    goto ResetReturn;
                }
            }
        } while (bMore);
    }

ResetReturn:

    if (ResetGLINT)
    {
        (*ppdev->pgfnResetStrips)(ppdev);
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\sync.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: sync.c
*
* Content: DrvSynchronize
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "pxrx.h"

/******************************Public*Routine******************************\
* VOID DrvSynchronize
*
* Synchronize with the GLINT.
*
* Before letting GDI draw onto our screen DIBs we must synchronize with GLINT.
* We do this by hooking HOOK_SYNCHRONIZE when we create a DIV that points to
* the screen (or off-screen). GDI then calls DrvSynchronize() before trying
* to render to any of these screen DIBs. The advantage is that we can forget
* about doing SYNC_WITH_GLINT in the code and have GDI call DrvSynchronize
* at the appropriate moment.
*
\**************************************************************************/

VOID
DrvSynchronize(
DHPDEV  dhpdev,
RECTL   *prcl)
{
    PDEV*   ppdev = (PDEV*) dhpdev;
    GLINT_DECL;

    DISPDBG((DBGLVL, "DrvSynchronize called"));

    // These chips use cached syncs

    SYNC_IF_CORE_BUSY;
}

//@@BEGIN_DDKSPLIT
#if 0
#if USE_LD_GLINT_FIFO_FUNCTION

void loadGlintFIFOrelease( GlintDataPtr glintInfo, ULONG tag, ULONG data ) {
/**/
    TEMP_MACRO_VARS;

    LD_GLINT_FIFO_FREE( tag, data );
/*/
    static ULONG    fifoSpace = 0;
    ULONG           *dst;
    TEMP_MACRO_VARS;

    if( fifoSpace < 2 ) {
        GET_INPUT_FIFO_SPACE( fifoSpace );

        if ( GLINT_GAMMA_PRESENT ) {
            if( space > MAX_GAMMA_FIFO_ENTRIES )
                space = MAX_GAMMA_FIFO_ENTRIES;
        }
        else {
            if( space > MAX_P3_FIFO_ENTRIES )
                space = MAX_P3_FIFO_ENTRIES;
        }
    }

    dst = (ULONG *) glintInfo->regs.InFIFOInterface;
    MEMORY_BARRIER();
    WRITE_FAST_ULONG( dst, tag );
    dst++;
    MEMORY_BARRIER();
    WRITE_FAST_ULONG( dst, data );
/**/
}

void loadGlintFIFOdebug( GlintDataPtr glintInfo, ULONG tag, ULONG data ) {
    TEMP_MACRO_VARS;

    LD_GLINT_FIFO_DBG( tag, data )
}

#if DBG
LoadGlintFIFO   loadGlintFIFO = loadGlintFIFOdebug;
#else
LoadGlintFIFO   loadGlintFIFO = loadGlintFIFOrelease;
#endif   // DBG
#endif  // USE_LD_GLINT_FIFO_FUNCTION

#endif // 0
//@@END_DDKSPLIT

#if USE_SYNC_FUNCTION



void syncWithGlint( PPDEV ppdev, GlintDataPtr glintInfo ) 
{
    DWORD   gsync;
    ULONG   bmask;
    TEMP_MACRO_VARS;

    WAIT_DMA_COMPLETE;

    // Setting the pxrxDMA->bFlushRequired flag below to false ensures that 
    // the interrupt routine will not try to write to the chip. Without 
    // this check, the Vblank interrupt can attempt to flush outstanding 2D 
    // rendering by writing ContinueNewSub tag and data to the chip.
    // The problem with this is that the interrupt can occur between the 
    // writes of the tag and data in the code below, and if this happens,
    // the tag and data becomes out of step and typically results in a hang.
    //
    // Note that we have to set a MUTEX otherwise we still get hangs on a 
    // multi-processor system when an interrupt routine can be running 
    // simultaneously on another processor. The MUTEX avoids race conditions.
    
    GET_INTR_CMD_BLOCK_MUTEX(&glintInfo->pInterruptCommandBlock->General);
    glintInfo->pxrxDMA->bFlushRequired = FALSE ;

    WAIT_GLINT_FIFO(4);
    LD_GLINT_FIFO(__GlintTagFilterMode, 0x400);
    LD_GLINT_FIFO(__GlintTagSync, 0);
    LD_GLINT_FIFO(__GlintTagFilterMode, 0x0);
    
    do {
        WAIT_OUTPUT_FIFO_READY;
        READ_OUTPUT_FIFO(gsync);
        DISPDBG((DBGLVL, "SYNC: got 0x%x from output FIFO", gsync));
    } while (gsync != __GlintTagSync);
    
    glintInfo->bGlintCoreBusy = FALSE;
    RELEASE_INTR_CMD_BLOCK_MUTEX(&glintInfo->pInterruptCommandBlock->General);
}


void waitDMAcomplete( PPDEV ppdev, GlintDataPtr glintInfo ) 
{
    TEMP_MACRO_VARS;

    if (ppdev->currentCtxt == glintInfo->ddCtxtId)
    {
        SEND_PXRX_DMA_FORCE;
    }

    if (!(ppdev->g_GlintBoardStatus & GLINT_DMA_COMPLETE)) 
    {
        if (ppdev->g_GlintBoardStatus & GLINT_INTR_CONTEXT) 
        {
            // do any VBLANK wait, wait Q to empty and last DMA to complete
            PINTERRUPT_CONTROL_BLOCK pBlock = glintInfo->pInterruptCommandBlock;
            
            while (pBlock->Control & SUSPEND_DMA_TILL_VBLANK)
            {
                NULL;
            }
            
            while (pBlock->frontIndex != pBlock->backIndex)
            {
                NULL;
            }
        }
        
        if ((GET_DMA_COUNT(_temp_volatile_i)) > 0) 
        {
            do 
            {
                while (--_temp_volatile_i > 0)
                {
                    NULL;
                }
            } while ((GET_DMA_COUNT(_temp_volatile_i)) > 0);
        }
        
        ppdev->g_GlintBoardStatus |= GLINT_DMA_COMPLETE;
    }
}

#endif  // USE_SYNC_FUNCTION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\textout.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: textout.c
*
* Content: 
*
* glyph rendering module. Uses glyph caching for P3 and
* glyph expansion for older Glint series accelerators.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

//@@BEGIN_DDKSPLIT
//
// There are three basic methods for drawing text with hardware
// acceleration:
//
// 1) Glyph caching -- Glyph bitmaps are cached by the accelerator
//       (probably in off-screen memory), and text is drawn by
//       referring the hardware to the cached glyph locations.
//
// 2) Glyph expansion -- Each individual glyph is colour-expanded
//       directly to the screen from the monochrome glyph bitmap
//       supplied by GDI.
//
// 3) Buffer expansion -- The CPU is used to draw all the glyphs into
//       a 1bpp monochrome bitmap, and the hardware is then used
//       to colour-expand the result.
//
// The fastest method depends on a number of variables, such as the
// colour expansion speed, bus speed, CPU speed, average glyph size,
// and average string length.
//
// For the S3 with normal sized glyphs, I've found that caching the
// glyphs in off-screen memory is typically the slowest method.
// Buffer expansion is typically fastest on the slow ISA bus (or when
// memory-mapped I/O isn't available on the x86), and glyph expansion
// is best on fast buses such as VL and PCI.
//
// Glyph expansion is typically faster than buffer expansion for very
// large glyphs, even on the ISA bus, because less copying by the CPU
// needs to be done.  Unfortunately, large glyphs are pretty rare.
//
// An advantange of the buffer expansion method is that opaque text will
// never flash -- the other two methods typically need to draw the
// opaquing rectangle before laying down the glyphs, which may cause
// a flash if the raster is caught at the wrong time.
//
//@@END_DDKSPLIT

#include "precomp.h"
#include "pxrx.h"

//*********************************************************************************************
// FUNC: vPxRxClipSolid
// ARGS: ppdev (I) - pointer to physical device object
//       crcl (I) - number of rectangles
//       prcl (I) - array of rectangles
//       iColor (I) - the solid fill color
//       pco (I) - pointer to the clip region object
// RETN: void
//---------------------------------------------------------------------------------------------
// Fill a series of rectangles clipped by pco with a solid color. This function should only
// be called when the clipping operation is non-trivial
//*********************************************************************************************

VOID vPxRxClipSolid(PDEV* ppdev, LONG crcl, RECTL* prcl, ULONG iColor, CLIPOBJ* pco)
{
    BOOL            bMore;              // Flag for clip enumeration
    CLIPENUM        ce;                 // Clip enumeration object
    ULONG           i;
    ULONG           j;
    RECTL           arclTmp[4];
    ULONG           crclTmp;
    RECTL*          prclTmp;
    RECTL*          prclClipTmp;
    LONG            iLastBottom;
    RECTL*          prclClip;
    RBRUSH_COLOR    rbc;
    GLINT_DECL;

    ASSERTDD((crcl > 0) && (crcl <= 4), "Expected 1 to 4 rectangles");
    ASSERTDD((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL), "Expected a non-null clip object");

    rbc.iSolidColor = iColor;

    if (pco->iDComplexity == DC_RECT)
    {
        crcl = cIntersect(&pco->rclBounds, prcl, crcl);
        if (crcl != 0)
        {
            ppdev->pgfnFillSolid(ppdev, crcl, prcl, __GLINT_LOGICOP_COPY, 
                                                    __GLINT_LOGICOP_COPY, rbc, NULL);
        }
    }
    else // iDComplexity == DC_COMPLEX
    {
        // Bottom of last rectangle to fill
        iLastBottom = prcl[crcl - 1].bottom;

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN, 0);

        do  {

            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (VOID*)&ce);

            for (j = ce.c, prclClip = ce.arcl; j-- > 0; prclClip++)
            {
                // Since the rectangles and the region enumeration are both
                // right-down, we can zip through the region until we reach
                // the first fill rect, and are done when we've passed the
                // last fill rect.

                if (prclClip->top >= iLastBottom)
                {
                    return; // Past last fill rectangle; nothing left to do
                }

                if (prclClip->bottom > prcl->top)
                {
                    // We've reached the top Y scan of the first rect, so
                    // it's worth bothering checking for intersection.

                    prclTmp     = prcl;
                    prclClipTmp = arclTmp;

                    for (i = crcl, crclTmp = 0; i--; prclTmp++)
                    {
                        // Intersect fill and clip rectangles
                        if (bIntersect(prclTmp, prclClip, prclClipTmp))
                        {
                            // Add to list if anything's left to draw:
                            crclTmp++;
                            prclClipTmp++;
                        }
                    }

                    // Draw the clipped rects
                    if (crclTmp)
                    {
                        ppdev->pgfnFillSolid(ppdev, crclTmp, &arclTmp[0],
                                              __GLINT_LOGICOP_COPY, __GLINT_LOGICOP_COPY, rbc, NULL);
                    }
                }
            }
        }  while(bMore);
    }
}

//*********************************************************************************************
// FUNC: bPxRxUncachedText
// ARGS: ppdev (I) - pointer to physical device object
//         pgp (I) - array of glyphs to render
//       cGlyph (I) - number of glyphs to render
//       ulCharInc (I) - fixed character spacing increment (0 if proportional font)
// RETN: TRUE if glyphs were rendered
//---------------------------------------------------------------------------------------------
// Renders an array of proportional or monospaced glyphs. This function requires RasterizerMode
// to be set-up to correctly byteswap and mirror bitmasks.
// NB. currently render to cxGlyphAligned rather than cxGlyph, this saves a lot of work on the
//     host but probably costs, on average, four bits per glyph row; as this is a fallback
//     routine I've not investigated whether this method is optimal.
//*********************************************************************************************

BOOL bPxRxUncachedText(PDEV* ppdev, GLYPHPOS* pgp, LONG cGlyph, ULONG ulCharInc)
{
    GLYPHBITS   *pgb;
    LONG        cxGlyph, cyGlyph, cxGlyphAligned;
    LONG        x, y;
    ULONG       *pulGlyph;
    LONG        cjGlyph;
    LONG        culGlyph;
    LONG        cjGlyphRem;
    LONG        cj;
    ULONG       ul;
    GLINT_DECL;

    DISPDBG((7, "bPxRxUncachedText: entered"));

    if (ulCharInc)
    {
        x = pgp->ptl.x + pgp->pgdf->pgb->ptlOrigin.x - ulCharInc;
        y = pgp->ptl.y + pgp->pgdf->pgb->ptlOrigin.y;
    }

    for ( ; --cGlyph >= 0; ++pgp)
    {
        pgb = pgp->pgdf->pgb;
        if (ulCharInc)
        {
            x += ulCharInc;
        }
        else
        {
            x = pgp->ptl.x + pgb->ptlOrigin.x;
            y = pgp->ptl.y + pgb->ptlOrigin.y;
        }

        cyGlyph = pgb->sizlBitmap.cy;
        cxGlyph = pgb->sizlBitmap.cx;
        cxGlyphAligned = ((cxGlyph + 7 ) & ~7);

        // Render2D turns on FastFillEnable which is incompatible with PackedBitMasks

        WAIT_PXRX_DMA_TAGS(4);

        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition, MAKEDWORD_XY(x, y));
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,          __RENDER2D_INCX | __RENDER2D_INCY |
                                                         __RENDER2D_OP_SYNCBITMASK |
                                                         __RENDER2D_WIDTH(cxGlyphAligned) |
                                                         __RENDER2D_HEIGHT(0));
        QUEUE_PXRX_DMA_TAG(__GlintTagCount,              cyGlyph);
        QUEUE_PXRX_DMA_TAG(__GlintTagRender,             __RENDER_TRAPEZOID_PRIMITIVE |
                                                         __RENDER_SYNC_ON_BIT_MASK);

        pulGlyph   = (ULONG *)pgb->aj;
        cjGlyph    = (cxGlyphAligned >> 3) * cyGlyph;
        culGlyph   = cjGlyph >> 2;
        cjGlyphRem = cjGlyph & 3;

        ul = culGlyph + (cjGlyphRem != 0);
        WAIT_PXRX_DMA_DWORDS(ul + 1);
        QUEUE_PXRX_DMA_HOLD(__GlintTagBitMaskPattern, ul);

        for ( ; --culGlyph >= 0; ++pulGlyph)
        {
            QUEUE_PXRX_DMA_DWORD(*pulGlyph);
        }

        if (cjGlyphRem)
        {
            for (ul = cj = 0; cj < cjGlyphRem; ++cj, ++(BYTE *)pulGlyph)
            {
                ul |= ((ULONG)(*(BYTE *)pulGlyph)) << (cj << 3);
            }
            QUEUE_PXRX_DMA_DWORD(ul);
        }
    }

    // The rasterizer's set-up to expect a continue after each Render command (NB. but not Render2D, etc),
    // so it won't flush the text to the framebuffer unless we specifically tell it to

    WAIT_PXRX_DMA_TAGS(1);
    QUEUE_PXRX_DMA_TAG(__GlintTagContinueNewSub, 0);

    DISPDBG((7, "bPxRxUncachedText: exited"));
    return(TRUE);
}

//*********************************************************************************************
// FUNC: bPxRxUncachedClippedText
// ARGS: ppdev (I) - pointer to physical device object
//         pgp (I) - array of glyphs to render
//       cGlyph (I) - number of glyphs to render
//       ulCharInc (I) - fixed character spacing increment (0 if proportional font)
//       pco (I) - pointer to the clip region object
// RETN: TRUE if glyphs were rendered
//---------------------------------------------------------------------------------------------
// Renders an array of proportional or monospaced glyphs. This function requires RasterizerMode
// to be set-up to correctly byteswap and mirror bitmasks.
// NB. currently render to cxGlyphAligned rather than cxGlyph, this saves a lot of work on the
//     host but probably costs, on average, four bits per glyph row; as this is a fallback
//     routine I've not investigated whether this method is optimal.
//*********************************************************************************************

BOOL bPxRxUncachedClippedText(PDEV* ppdev, GLYPHPOS* pgp, LONG cGlyph, ULONG ulCharInc, CLIPOBJ *pco)
{
    GLYPHBITS   *pgb;
    LONG        cxGlyph, cyGlyph, cxGlyphAligned;
    LONG        x, y;
    ULONG       *pulGlyph;
    LONG        cjGlyph;
    LONG        culGlyph;
    LONG        cjGlyphRem;
    LONG        cj;
    ULONG       ul;
    LONG        cGlyphOriginal = 0;
    GLYPHPOS    *pgpOriginal = NULL;
    BOOL        bMore, invalidatedScissor = FALSE;
    CLIPENUM    ce;
    RECTL       *prclClip;
    BOOL        bClipSet;
    GLINT_DECL;

    DISPDBG((7, "bPxRxUncachedClippedText: entered"));

    if (pco->iDComplexity == DC_RECT)
    {
        bMore    = FALSE;
        ce.c     = 1;
        prclClip = &pco->rclBounds;

        goto SingleRectangle;
    }

    cGlyphOriginal  = cGlyph;
    pgpOriginal     = pgp;

    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
    do {
        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

        for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
        {
            cGlyph = cGlyphOriginal;
            pgp = pgpOriginal;

        SingleRectangle:
            bClipSet = FALSE;

            if (ulCharInc)
            {
                x = pgp->ptl.x + pgp->pgdf->pgb->ptlOrigin.x - ulCharInc;
                y = pgp->ptl.y + pgp->pgdf->pgb->ptlOrigin.y;
            }

            for ( ; --cGlyph >= 0; ++pgp)
            {
                pgb = pgp->pgdf->pgb;
                if(ulCharInc)
                {
                    x += ulCharInc;
                }
                else
                {
                    x = pgp->ptl.x + pgb->ptlOrigin.x;
                    y = pgp->ptl.y + pgb->ptlOrigin.y;
                }

                cyGlyph = pgb->sizlBitmap.cy;
                cxGlyph = pgb->sizlBitmap.cx;
                cxGlyphAligned = ((cxGlyph + 7 ) & ~7);

                if ((prclClip->right  > x)           && (prclClip->bottom > y) &&
                    (prclClip->left   < x + cxGlyph) && (prclClip->top    < y + cyGlyph))
                {
                    // Lazily set the hardware clipping:
                    if(!bClipSet)
                    {
                        WAIT_PXRX_DMA_TAGS(3);
                        QUEUE_PXRX_DMA_TAG(__GlintTagScissorMinXY, (prclClip->top << SCISSOR_YOFFSET) |
                                                                   (prclClip->left << SCISSOR_XOFFSET));
                        QUEUE_PXRX_DMA_TAG(__GlintTagScissorMaxXY, (prclClip->bottom << SCISSOR_YOFFSET) |
                                                                   (prclClip->right << SCISSOR_XOFFSET));
                        QUEUE_PXRX_DMA_TAG(__GlintTagScissorMode,  (USER_SCISSOR_ENABLE | SCREEN_SCISSOR_DEFAULT));
                        invalidatedScissor = TRUE;

                        bClipSet = TRUE;
                    }

                    // Render2D turns on FastFillEnable which is incompatible with PackedBitMasks

                    WAIT_PXRX_DMA_TAGS(4);
                    QUEUE_PXRX_DMA_TAG(__GlintTagRectanglePosition, MAKEDWORD_XY(x, y));
                    QUEUE_PXRX_DMA_TAG(__GlintTagRender2D,          __RENDER2D_INCX |
                                                                    __RENDER2D_INCY |
                                                                    __RENDER2D_OP_SYNCBITMASK |
                                                                    __RENDER2D_WIDTH(cxGlyphAligned) |
                                                                    __RENDER2D_HEIGHT(0));
                    QUEUE_PXRX_DMA_TAG(__GlintTagCount,             cyGlyph);
                    QUEUE_PXRX_DMA_TAG(__GlintTagRender,            __RENDER_TRAPEZOID_PRIMITIVE |
                                                                    __RENDER_SYNC_ON_BIT_MASK);

                    pulGlyph   = (ULONG *)pgb->aj;
                    cjGlyph    = (cxGlyphAligned >> 3) * cyGlyph;
                    culGlyph   = cjGlyph >> 2;
                    cjGlyphRem = cjGlyph & 3;

                    ul = culGlyph + (cjGlyphRem != 0);
                    WAIT_PXRX_DMA_DWORDS(ul + 1);
                    QUEUE_PXRX_DMA_HOLD(__GlintTagBitMaskPattern, ul);

                    for ( ; --culGlyph >= 0; ++pulGlyph)
                    {
                        QUEUE_PXRX_DMA_DWORD(*pulGlyph);
                    }

                    if (cjGlyphRem)
                    {
                        for (ul = cj = 0; cj < cjGlyphRem; ++cj, ++(BYTE *)pulGlyph)
                        {
                            ul |= ((ULONG)(*(BYTE *)pulGlyph)) << (cj << 3);
                        }
                        QUEUE_PXRX_DMA_DWORD(ul);
                    }
                }
            }
        }
    } while(bMore);

    // reset clipping

    if (invalidatedScissor)
    {
        glintInfo->config2D |= __CONFIG2D_USERSCISSOR;

        WAIT_PXRX_DMA_TAGS(1);
        QUEUE_PXRX_DMA_TAG(__GlintTagScissorMaxXY, 0x7FFF7FFF);
    }

    // The rasterizer's set-up to expect a continue after each Render command (NB. but not Render2D, etc),
    // so it won't flush the text to the framebuffer unless we specifically tell it to

    WAIT_PXRX_DMA_TAGS(1);
    QUEUE_PXRX_DMA_TAG(__GlintTagContinueNewSub, 0);

    DISPDBG((7, "bPxRxUncachedClippedText: exited"));
    return(TRUE);
}

//*********************************************************************************************
// FUNC: DrvTextOut
// ARGS: pso (I) - pointer to surface object to render to
//       pstro (I) - pointer to the string object to be rendered
//       pfo (I) - pointer to the font object
//       pco (I) - pointer to the clip region object
//       prclExtra (I) - If we had set GCAPS_HORIZSTRIKE, we would have to fill these extra
//                       rectangles (it is used  largely for underlines). It's not a big
//                       performance win (GDI will call our DrvBitBlt to draw these).
//       prclOpaque (I) - pointer to the opaque background rectangle
//       pboFore (I) - pointer to the foreground brush object
//       pboOpaque (I) - pointer to the brush for the opaque background rectangle
//       pptlBrush (I) - pointer to the brush origin, Always unused, unless 
//                       GCAPS_ARBRUSHOPAQUE set
//       mix (I) - should always be a COPY operation
// RETN: TRUE - pstro glyphs have been rendered
//---------------------------------------------------------------------------------------------
// GDI calls this function when it has strings it wants us to render: this function should be
// exported in 'enable.c'.
//*********************************************************************************************

BOOL DrvTextOut(SURFOBJ* pso, STROBJ* pstro, FONTOBJ* pfo, CLIPOBJ* pco, RECTL* prclExtra,
                RECTL* prclOpaque, BRUSHOBJ* pboFore, BRUSHOBJ* pboOpaque, POINTL* pptlBrush, 
                MIX mix)
{
    PDEV*           ppdev;
    LONG            xOff;
    DSURF*          pdsurf;
    OH*             poh;
    ULONG           renderBits;
    ULONG           ulColor;
    ULONG           cGlyph;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgp;
    BYTE            iDComplexity;
    RECTL           rclOpaque;
    BOOL            bRet = TRUE;
    GLINT_DECL_VARS;

    pdsurf = (DSURF*) pso->dhsurf;
    ppdev  = (PDEV*) pso->dhpdev;

    REMOVE_SWPOINTER(pso);

    if (pdsurf->dt & DT_SCREEN)
    {
        GLINT_DECL_INIT;

        SETUP_PPDEV_OFFSETS(ppdev, pdsurf);
        xOff = ppdev->xOffset = pdsurf->poh->x;

        VALIDATE_DD_CONTEXT;

        DISPDBG((9, "DrvTextOut: ppdev = %p pso->dhsurf->dt == %d", ppdev, pdsurf->dt));

        // The DDI spec says we'll only ever get foreground and background mixes of R2_COPYPEN:

        ASSERTDD(mix == 0x0d0d, "GDI should only give us a copy mix");

        if (glintInfo->WriteMask != 0xffffffff)
        {
            // the texture unit requires all 32bpp of pixel data, so if we've got the upper
            // 8 bits masked out for overlays we need to reenable these bits temporarily
            WAIT_PXRX_DMA_TAGS(1);
            glintInfo->WriteMask = 0xffffffff;
            QUEUE_PXRX_DMA_TAG(__GlintTagFBHardwareWriteMask, 0xffffffff);
        }

        iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

        if (prclOpaque != NULL)
        {
            int x,y,cx,cy;
            RBRUSH_COLOR rbc;

            ////////////////////////////////////////////////////////////
            // Opaque Initialization
            ////////////////////////////////////////////////////////////

            if (iDComplexity == DC_TRIVIAL)
            {
        DrawOpaqueRect:
                rbc.iSolidColor = pboOpaque->iSolidColor;
                ppdev->pgfnFillSolid(ppdev, 1, prclOpaque, __GLINT_LOGICOP_COPY, __GLINT_LOGICOP_COPY, rbc, NULL);
            }
            else if (iDComplexity == DC_RECT)
            {
                DISPDBG((7, "DrvTextOut: drawing opaquing rect with rectangular clipping"));
                if (bIntersect(prclOpaque, &pco->rclBounds, &rclOpaque))
                {
                    prclOpaque = &rclOpaque;
                    goto DrawOpaqueRect;
                }
            }
            else
            {
                // vPxRxClipSolid modifies the rect list we pass in but prclOpaque
                // is probably a GDI structure so don't change it. This is also
                // necessary for multi-headed drivers.
                RECTL   tmpOpaque = *prclOpaque;

                DISPDBG((7, "DrvTextOut: drawing opaquing rect with complex clipping"));

                vPxRxClipSolid(ppdev, 1, &tmpOpaque, pboOpaque->iSolidColor, pco);
            }
        }

        if (prclOpaque == NULL)
        {
            // opaque initialization would have ensured the registers were correctly 
            // set up for a solid fill, without it we'll need to perform our own
            // initialization.

            SET_WRITE_BUFFERS;
            WAIT_PXRX_DMA_TAGS(1);
            LOAD_CONFIG2D(__CONFIG2D_CONSTANTSRC | __CONFIG2D_FBWRITE);
        }

        ////////////////////////////////////////////////////////////
        // Transparent Initialization
        ////////////////////////////////////////////////////////////

        ulColor = pboFore->iSolidColor;
        WAIT_PXRX_DMA_TAGS(1);
        LOAD_FOREGROUNDCOLOUR( ulColor );

        STROBJ_vEnumStart(pstro);

        do {
            if (pstro->pgp != NULL)
            {
                // There's only the one batch of glyphs, so save ourselves a call:
                pgp         = pstro->pgp;
                cGlyph      = pstro->cGlyphs;
                bMoreGlyphs = FALSE;
            }
            else
            {
                // never get here in WinBench97 business graphics
                bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
            }

            if (cGlyph > 0)
            {
                // fall back to uncached rendering

                if (iDComplexity == DC_TRIVIAL)
                {
                    bRet = bPxRxUncachedText(ppdev, pgp, cGlyph, pstro->ulCharInc);
                }
                else
                {
                    bRet = bPxRxUncachedClippedText(ppdev, pgp, cGlyph, pstro->ulCharInc, pco);
                }
            }
        } while (bMoreGlyphs && bRet);

        if(glintInfo->DefaultWriteMask != 0xffffffff)
        {
            WAIT_PXRX_DMA_TAGS(1);
            glintInfo->WriteMask = glintInfo->DefaultWriteMask;
            QUEUE_PXRX_DMA_TAG(__GlintTagFBHardwareWriteMask, glintInfo->DefaultWriteMask);
        }

        SEND_PXRX_DMA_QUERY;
    }
    else
    {
        // We're drawing to a DFB we've converted to a DIB, so just call GDI
        // to handle it:
        return(EngTextOut(pdsurf->pso, pstro, pfo, pco, prclExtra, prclOpaque,
                        pboFore, pboOpaque, pptlBrush, mix));
    }

    DISPDBG((9, "DrvTextOut: exiting"));
    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\thunk.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: thunk.c
*
* Content:
*
* This module exists solely for testing, to make it is easy to instrument
* all the driver's Drv calls.
*
* Note that most of this stuff will only be compiled in a checked (debug)
* build.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"

#if DBG

// default these to FALSE
BOOL    bPuntCopyBits = FALSE;
BOOL    bPuntBitBlt = FALSE;
BOOL    bPuntTextOut = FALSE;
BOOL    bPuntStrokePath = FALSE;
BOOL    bPuntLineTo = FALSE;
BOOL    bPuntFillPath = FALSE;
BOOL    bPuntPaint = FALSE;

#endif //DBG

////////////////////////////////////////////////////////////////////////////

#if DBG || !SYNCHRONIZEACCESS_WORKS

// This entire module is only enabled for Checked builds, or when we
// have to explicitly synchronize bitmap access ourselves.

////////////////////////////////////////////////////////////////////////////
// By default, GDI does not synchronize drawing to device-bitmaps.  Since
// our hardware dictates that only one thread can access the accelerator
// at a time, we have to synchronize bitmap access.
//
// If we're running on Windows NT 3.1, we have to do it ourselves.
//
// If we're running on Windows NT 3.5 or later, we can ask GDI to do it
// by setting HOOK_SYNCHRONIZEACCESS when we associate a device-bitmap
// surface.

extern HSEMAPHORE g_cs;

#define SYNCH_ENTER() EngAcquireSemaphore(g_cs);
#define SYNCH_LEAVE() EngReleaseSemaphore(g_cs);

////////////////////////////////////////////////////////////////////////////

BOOL gbNull = FALSE;    // Set to TRUE with the debugger to test the speed
                        //   of NT with an inifinitely fast display driver
                        //   (actually, almost infinitely fast since we're
                        //   not hooking all the calls we could be)

BOOL inBitBlt = FALSE;

DHPDEV DbgEnablePDEV(
DEVMODEW*   pDevmode,
PWSTR       pwszLogAddress,
ULONG       cPatterns,
HSURF*      ahsurfPatterns,
ULONG       cjGdiInfo,
ULONG*      pGdiInfo,
ULONG       cjDevInfo,
DEVINFO*    pDevInfo,
HDEV        hdev,
PWSTR       pwszDeviceName,
HANDLE      hDriver)
{
    DHPDEV bRet;

    SYNCH_ENTER();
    DISPDBG((5, "DrvEnablePDEV"));

    bRet = DrvEnablePDEV(
                pDevmode,
                pwszLogAddress,
                cPatterns,
                ahsurfPatterns,
                cjGdiInfo,
                pGdiInfo,
                cjDevInfo,
                pDevInfo,
                hdev,
                pwszDeviceName,
                hDriver);

    DISPDBG((6, "DrvEnablePDEV done"));
    SYNCH_LEAVE();

    return(bRet);
}

VOID DbgCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvCompletePDEV"));

    DrvCompletePDEV(
                dhpdev,
                hdev);

    DISPDBG((6, "DrvCompletePDEV done"));
    SYNCH_LEAVE();
}

VOID DbgDisablePDEV(DHPDEV dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDisable"));

    DrvDisablePDEV(dhpdev);

    DISPDBG((6, "DrvDisable done"));
    SYNCH_LEAVE();
}

HSURF DbgEnableSurface(DHPDEV dhpdev)
{
    HSURF h;

    SYNCH_ENTER();
    DISPDBG((5, "DrvEnableSurface"));

    h = DrvEnableSurface(dhpdev);

    DISPDBG((6, "DrvEnableSurface done"));
    SYNCH_LEAVE();

    return(h);
}

VOID DbgDisableSurface(DHPDEV dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDisableSurface"));

    DrvDisableSurface(dhpdev);

    DISPDBG((6, "DrvDisableSurface done"));
    SYNCH_LEAVE();
}

BOOL  DbgAssertMode(
DHPDEV dhpdev,
BOOL   bEnable)
{
    BOOL bRet;    
    SYNCH_ENTER();
    DISPDBG((5, "DrvAssertMode"));

    bRet = DrvAssertMode(dhpdev,bEnable);

    DISPDBG((6, "DrvAssertMode done"));
    SYNCH_LEAVE();

    return(bRet);
}

//
// We do not SYNCH_ENTER since we have not initalized the driver.
// We just want to get the list of modes from the miniport.
//

ULONG DbgGetModes(
HANDLE    hDriver,
ULONG     cjSize,
DEVMODEW* pdm)
{
    ULONG u;

    DISPDBG((5, "DrvGetModes"));

    u = DrvGetModes(
                hDriver,
                cjSize,
                pdm);

    DISPDBG((6, "DrvGetModes done"));

    return(u);
}

VOID DbgMovePointer(SURFOBJ *pso,LONG x,LONG y,RECTL *prcl)
{
    if (gbNull)
        return;

#if DBG
    {
        PPDEV ppdev = (PPDEV)pso->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);
    }
#endif

    // We don't synchronise access to this routine. If the cursor is hardware
    // the move can be done at any time and if it is software GDI locks the
    // access for us.

    DISPDBG((15, "DrvMovePointer 0x%x 0x%x", x, y));

    DrvMovePointer(pso,x,y,prcl);

    DISPDBG((16, "DrvMovePointer done"));
}

ULONG DbgSetPointerShape(
SURFOBJ*  pso,
SURFOBJ*  psoMask,
SURFOBJ*  psoColor,
XLATEOBJ* pxlo,
LONG      xHot,
LONG      yHot,
LONG      x,
LONG      y,
RECTL*    prcl,
FLONG     fl)
{
    ULONG u;

    if (gbNull)
        return(SPS_ACCEPT_NOEXCLUDE);

    SYNCH_ENTER();

#if DBG
    {
        PPDEV ppdev = (PPDEV)pso->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);
    }
#endif

    DISPDBG((5, "DrvSetPointerShape"));

    u = DrvSetPointerShape(
                pso,
                psoMask,
                psoColor,
                pxlo,
                xHot,
                yHot,
                x,
                y,
                prcl,
                fl);

    DISPDBG((6, "DrvSetPointerShape done"));
    SYNCH_LEAVE();

    return(u);
}

ULONG DbgDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG* pul)
{
    ULONG u;

    if (gbNull)
        return(DCR_DRIVER);

    DISPDBG((5, "DrvDitherColor"));

    u = DrvDitherColor(
                dhpdev,
                iMode,
                rgb,
                pul);

    DISPDBG((6, "DrvDitherColor done"));

    return(u);
}

BOOL DbgSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvSetPalette"));

    u = DrvSetPalette(
                dhpdev,
                ppalo,
                fl,
                iStart,
                cColors);

    DISPDBG((6, "DrvSetPalette done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    #if DBG
    {
        PPDEV ppdev = (psoSrc && psoSrc->iType != STYPE_BITMAP) ? (PPDEV)psoSrc->dhpdev : (PPDEV)psoDst->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);

        if(bPuntCopyBits)
        {
            SYNCH_ENTER();
            if(psoSrc->iType != STYPE_BITMAP)
            {
                DSURF *pdsurfSrc = (DSURF *)psoSrc->dhsurf;
                psoSrc = pdsurfSrc->pso;
            }
            if(psoDst->iType != STYPE_BITMAP)
            {
                DSURF *pdsurfDst = (DSURF *)psoDst->dhsurf;
                psoDst = pdsurfDst->pso;
            }
            u = EngCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc);
            SYNCH_LEAVE();
            return(u);
        }
    }
    #endif //DBG
    
    SYNCH_ENTER();

    DISPDBG((5, "DrvCopyBits"));

    u = DrvCopyBits(
                psoDst,
                psoSrc,
                pco,
                pxlo,
                prclDst,
                pptlSrc);

    DISPDBG((6, "DrvCopyBits done"));
    SYNCH_LEAVE();

    return(u);
}


BOOL DbgBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    #if DBG
    {
        PPDEV ppdev = (psoSrc && psoSrc->iType != STYPE_BITMAP) ? (PPDEV)psoSrc->dhpdev : (PPDEV)psoDst->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);

        if(bPuntBitBlt)
        {
            SYNCH_ENTER();
            if(psoSrc && psoSrc->iType != STYPE_BITMAP)
            {
                DSURF *pdsurfSrc = (DSURF *)psoSrc->dhsurf;
                psoSrc = pdsurfSrc->pso;
            }
            if(psoDst && psoDst->iType != STYPE_BITMAP)
            {
                DSURF *pdsurfDst = (DSURF *)psoDst->dhsurf;
                psoDst = pdsurfDst->pso;
            }
            u = EngBitBlt(psoDst, psoSrc, psoMask, pco, pxlo, prclDst, pptlSrc, pptlMask, pbo, pptlBrush, rop4);
            SYNCH_LEAVE();
            return(u);
        }
    }
    #endif //DBG

    SYNCH_ENTER();

    DISPDBG((5, "DrvBitBlt: psoDst(%p) psoSrc(%p) psoMask(%p) pbo(%p) rop(%08x)", psoDst, psoSrc, psoMask, pbo, rop4));

    inBitBlt = TRUE;
    u = DrvBitBlt(
                psoDst,
                psoSrc,
                psoMask,
                pco,
                pxlo,
                prclDst,
                pptlSrc,
                pptlMask,
                pbo,
                pptlBrush,
                rop4);
    inBitBlt = FALSE;

    DISPDBG((6, "DrvBitBlt done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    #if DBG
    {
        PPDEV ppdev = (PPDEV)pso->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);

        if(bPuntTextOut)
        {
            SYNCH_ENTER();
            if(pso->iType != STYPE_BITMAP)
            {
                DSURF *pdsurf = (DSURF *)pso->dhsurf;
                pso = pdsurf->pso;
            }
            u = EngTextOut(pso, pstro, pfo, pco, prclExtra, prclOpaque, pboFore, pboOpaque, pptlOrg, mix);
            SYNCH_LEAVE();
            return(u);
        }
    }
    #endif //DBG

    SYNCH_ENTER();

    DISPDBG((5, "DrvTextOut"));

    u = DrvTextOut(
                pso,
                pstro,
                pfo,
                pco,
                prclExtra,
                prclOpaque,
                pboFore,
                pboOpaque,
                pptlOrg,
                mix);

    DISPDBG((6, "DrvTextOut done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrushOrg,
LINEATTRS* plineattrs,
MIX        mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    #if DBG
    {
        PPDEV ppdev = (PPDEV)pso->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);

        if(bPuntStrokePath)
        {
            SYNCH_ENTER();
            if(pso && pso->iType != STYPE_BITMAP)
            {
                DSURF *pdsurf = (DSURF *)pso->dhsurf;
                pso = pdsurf->pso;
            }
            u = EngStrokePath(pso, ppo, pco, pxo, pbo, pptlBrushOrg, plineattrs, mix);
            SYNCH_LEAVE();
            return(u);
        }
    }
    #endif //DBG

    SYNCH_ENTER();
    DISPDBG((5, "DrvStrokePath"));

    u = DrvStrokePath(
                pso,
                ppo,
                pco,
                pxo,
                pbo,
                pptlBrushOrg,
                plineattrs,
                mix);

    DISPDBG((6, "DrvStrokePath done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgLineTo(
    SURFOBJ*   pso,
    CLIPOBJ*   pco,
    BRUSHOBJ*  pbo,
    LONG       x1,
    LONG       y1,
    LONG       x2,
    LONG       y2,
    RECTL      *prclBounds,
    MIX        mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    #if DBG
    {
        PPDEV ppdev = (PPDEV)pso->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);

        if(bPuntLineTo)
        {
            SYNCH_ENTER();
            if(pso && pso->iType != STYPE_BITMAP)
            {
                DSURF *pdsurf = (DSURF *)pso->dhsurf;
                pso = pdsurf->pso;
            }
            u = EngLineTo(pso, pco, pbo,    x1, y1, x2, y2, prclBounds, mix);
            SYNCH_LEAVE();
            return(u);
        }
    }
    #endif //DBG

    SYNCH_ENTER();
    DISPDBG((5, "DrvLineTo"));

    u = DrvLineTo(
                pso,
                pco,
                pbo,
                x1,
                y1,
                x2,
                y2,
                prclBounds,
                mix);

    DISPDBG((6, "DrvLineTo done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgFillPath(
SURFOBJ*  pso,
PATHOBJ*  ppo,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix,
FLONG     flOptions)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    #if DBG
    {
        PPDEV ppdev = (PPDEV)pso->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);

        if(bPuntFillPath)
        {
            SYNCH_ENTER();
            if(pso && pso->iType != STYPE_BITMAP)
            {
                DSURF *pdsurf = (DSURF *)pso->dhsurf;
                pso = pdsurf->pso;
            }
            u = EngFillPath(pso, ppo, pco, pbo, pptlBrushOrg, mix, flOptions);
            SYNCH_LEAVE();
            return(u);
        }
    }
    #endif //DBG

    SYNCH_ENTER();
    DISPDBG((5, "DrvFillPath"));

    u = DrvFillPath(pso,
                ppo,
                pco,
                pbo,
                pptlBrushOrg,
                mix,
                flOptions);

    DISPDBG((6, "DrvFillPath done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    #if DBG
    {
        PPDEV ppdev = (PPDEV)pso->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);

        if(bPuntPaint)
        {
            SYNCH_ENTER();
            if(pso && pso->iType != STYPE_BITMAP)
            {
                DSURF *pdsurf = (DSURF *)pso->dhsurf;
                pso = pdsurf->pso;
            }
            u = EngPaint(pso, pco, pbo, pptlBrushOrg, mix);
            SYNCH_LEAVE();
            return(u);
        }
    }
    #endif //DBG

    SYNCH_ENTER();
    DISPDBG((5, "DrvPaint"));

    u = DrvPaint(
                pso,
                pco,
                pbo,
                pptlBrushOrg,
                mix);

    DISPDBG((6, "DrvPaint done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgRealizeBrush(
BRUSHOBJ* pbo,
SURFOBJ*  psoTarget,
SURFOBJ*  psoPattern,
SURFOBJ*  psoMask,
XLATEOBJ* pxlo,
ULONG     iHatch)
{
    BOOL u;

//@@BEGIN_DDKSPLIT
    // Note: The only time DrvRealizeBrush is called by GDI is when we've
    //       called BRUSHOBJ_pvGetRbrush in the middle of a DrvBitBlt
    //       call, and GDI had to call us back.  Since we're still in the
    //       middle of DrvBitBlt, synchronization has already taken care of.
    //       For the same reason, this will never be called when 'gbNull'
    //       is TRUE, so it doesn't even make sense to check gbNull...

    // I've seen this to be untrue at least once on a MIPS so ...
//@@END_DDKSPLIT

    if (!inBitBlt)
        SYNCH_ENTER();

    DISPDBG((5, "DrvRealizeBrush"));

    u = DrvRealizeBrush(
                pbo,
                psoTarget,
                psoPattern,
                psoMask,
                pxlo,
                iHatch);

    DISPDBG((6, "DrvRealizeBrush done"));
    if (!inBitBlt)
        SYNCH_LEAVE();

    return(u);
}

HBITMAP DbgCreateDeviceBitmap(DHPDEV dhpdev, SIZEL sizl, ULONG iFormat)
{
    HBITMAP hbm;

//@@BEGIN_DDKSPLIT
#if 0
    if (gbNull)                     // I would pretend to have created a
        return(FALSE);              //   bitmap when gbNull is set, by we
                                    //   would need some code to back this
                                    //   up so that the system wouldn't
                                    //   crash...
#endif
//@@END_DDKSPLIT

    SYNCH_ENTER();

    #if DBG
    {
        PPDEV ppdev = (PPDEV)dhpdev;
        CHECK_MEMORY_VIEW(ppdev);
    }
    #endif

    DISPDBG((5, "DrvCreateDeviceBitmap"));

    hbm = DrvCreateDeviceBitmap(dhpdev, sizl, iFormat);

    DISPDBG((6, "DrvCreateDeviceBitmap done"));
    SYNCH_LEAVE();

    return(hbm);
}

VOID DbgDeleteDeviceBitmap(DHSURF dhsurf)
{
    SYNCH_ENTER();

    #if DBG
    {
        PPDEV ppdev = ((DSURF *)dhsurf)->ppdev;
        CHECK_MEMORY_VIEW(ppdev);
    }
    #endif

    DISPDBG((5, "DrvDeleteDeviceBitmap"));

    DrvDeleteDeviceBitmap(dhsurf);

    DISPDBG((6, "DrvDeleteDeviceBitmap done"));
    SYNCH_LEAVE();
}

//@@BEGIN_DDKSPLIT
#define DRV_STRETCH_SUPPORTED 0

#if DRV_STRETCH_SUPPORTED

#if DBG

#define STRETCH_COPY            0x00000000
#define STRETCH_DOWNLOAD        0x00000001

#define STRETCH_COLORONCOLOR    0x00000000
#define STRETCH_BLACKONWHITE    0x00000002
#define STRETCH_WHITEONBLACK    0x00000004

#define STRETCH_SOURCE_1BPP     0x00000000
#define STRETCH_SOURCE_4BPP     0x00000008
#define STRETCH_SOURCE_8BPP     0x00000010
#define STRETCH_SOURCE_16BPP    0x00000020
#define STRETCH_SOURCE_24BPP    0x00000040
#define STRETCH_SOURCE_32BPP    0x00000080

#define STRETCH_ONE2ONE_X       0x00000000
#define STRETCH_GROW_X          0x00000100
#define STRETCH_SHRINK_X        0x00000200

#define STRETCH_ONE2ONE_Y       0x00000000
#define STRETCH_GROW_Y          0x00000400
#define STRETCH_SHRINK_Y        0x00000800

ULONG aStretch[0x900];

#endif // DBG

BOOL DbgStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMask,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMask,
ULONG               iMode)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvStretchBlt"));

    #if SYNCHRONIZEACCESS_WORKS
    {
        // Our DrvStretchBlt routine calls back to EngStretchBlt, which
        // calls back to our DrvCopyBits routine -- so we have to be
        // re-entrant for synchronization...

        SYNCH_LEAVE();
    }
    #endif // SYNCHRONIZEACCESS_WORKS

#if DBG
    {
        int i;
        SIZEL   sizlSrc;
        SIZEL   sizlDst;

        i  = (psoSrc->iType == STYPE_BITMAP) ? STRETCH_DOWNLOAD : 
                                               STRETCH_COPY;

        i |= (iMode == COLORONCOLOR) ? STRETCH_COLORONCOLOR : 
             (iMode == BLACKONWHITE) ? STRETCH_BLACKONWHITE : 
                                       STRETCH_WHITEONBLACK;

        i |= (psoSrc->iBitmapFormat == BMF_1BPP)  ? STRETCH_SOURCE_1BPP :
             (psoSrc->iBitmapFormat == BMF_4BPP)  ? STRETCH_SOURCE_4BPP :
             (psoSrc->iBitmapFormat == BMF_8BPP)  ? STRETCH_SOURCE_8BPP :
             (psoSrc->iBitmapFormat == BMF_16BPP) ? STRETCH_SOURCE_16BPP :
             (psoSrc->iBitmapFormat == BMF_24BPP) ? STRETCH_SOURCE_24BPP :
                                                    STRETCH_SOURCE_32BPP;

        sizlSrc.cx = prclSrc->right - prclSrc->left;
        if((int)sizlSrc.cx < 0)
            sizlSrc.cx = (ULONG)-(int)sizlSrc.cx;

        sizlSrc.cy = prclSrc->bottom - prclSrc->top;
        if((int)sizlSrc.cy < 0)
            sizlSrc.cy = (ULONG)-(int)sizlSrc.cy;

        sizlDst.cx = prclDst->right - prclDst->left;
        if((int)sizlDst.cx < 0)
            sizlDst.cx = (ULONG)-(int)sizlDst.cx;

        sizlDst.cy = prclDst->bottom - prclDst->top;
        if((int)sizlDst.cy < 0)
            sizlDst.cy = (ULONG)-(int)sizlDst.cy;


        i |= (sizlSrc.cx == sizlDst.cx) ? STRETCH_ONE2ONE_X :
             (sizlSrc.cx < sizlDst.cx)  ? STRETCH_GROW_X :
                                          STRETCH_SHRINK_X;

        i |= (sizlSrc.cy == sizlDst.cy) ? STRETCH_ONE2ONE_Y :
             (sizlSrc.cy < sizlDst.cy)  ? STRETCH_GROW_Y :
                                          STRETCH_SHRINK_Y;

        ++aStretch[i];
    }
#endif

    u = DrvStretchBlt(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlHTOrg,
                      prclDst, prclSrc, pptlMask, iMode);

    #if SYNCHRONIZEACCESS_WORKS
    {
        SYNCH_ENTER();
    }
    #endif // SYNCHRONIZEACCESS_WORKS

    DISPDBG((6, "DrvStretchBlt done"));
    SYNCH_LEAVE();

    return(u);
}

#endif  // DRV_STRETCH_SUPPORTED
//@@END_DDKSPLIT

ULONG
DbgEscape(
    SURFOBJ *pso,
    ULONG   iEsc,
    ULONG   cjIn,
    VOID    *pvIn,
    ULONG   cjOut,
    VOID    *pvOut)
{
    ULONG u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();

    #if DBG
    {
        PPDEV ppdev = (PPDEV)pso->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);
    }
    #endif

    DISPDBG((5, "DrvEscape"));

    u = DrvEscape(pso, iEsc, cjIn, pvIn, cjOut, pvOut);

    DISPDBG((6, "DrvEscape done"));
    SYNCH_LEAVE();

    return(u);
}

ULONG
DbgDrawEscape(
    SURFOBJ *pso,
    ULONG   iEsc,
    CLIPOBJ *pco,
    RECTL   *prcl,
    ULONG   cjIn,
    VOID    *pvIn)
{
    ULONG u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();

    #if DBG
    {
        PPDEV ppdev = (PPDEV)pso->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);
    }
    #endif

    DISPDBG((5, "DrvDrawEscape"));

    // Nothing to do....

    u = (ULONG)-1;

    DISPDBG((6, "DrvDrawEscape done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgResetPDEV(
DHPDEV dhpdevOld,
DHPDEV dhpdevNew)
{
    BOOL bRet;

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvResetPDEV"));

    bRet = DrvResetPDEV(dhpdevOld, dhpdevNew);

    DISPDBG((6, "<< DrvResetPDEV"));
    SYNCH_LEAVE();

    return(bRet);
}

VOID DbgSynchronize(
DHPDEV  dhpdev,
RECTL   *prcl)
{
    DISPDBG((5, "DbgSynchronize"));

    //
    // don't do SYNCH_ENTER checks here as we will be called from within
    // an Eng routine that is called from within a Drv function.
    //

    DrvSynchronize(
                dhpdev,
                prcl);

    DISPDBG((6, "DbgSynchronize done"));
}

#if WNT_DDRAW

BOOL DbgGetDirectDrawInfo(
DHPDEV          dhpdev,
DD_HALINFO*     pHalInfo,
DWORD*          lpdwNumHeaps,
VIDEOMEMORY*    pvmList,
DWORD*          lpdwNumFourCC,
DWORD*          lpdwFourCC)
{
    BOOL b;

    DISPDBG((5, ">> DbgQueryDirectDrawInfo"));

    b = DrvGetDirectDrawInfo(dhpdev,
                             pHalInfo,
                             lpdwNumHeaps,
                             pvmList,
                             lpdwNumFourCC,
                             lpdwFourCC);

    DISPDBG((6, "<< DbgQueryDirectDrawInfo"));

    return(b);
}

BOOL DbgEnableDirectDraw(
DHPDEV                  dhpdev,
DD_CALLBACKS*           pCallBacks,
DD_SURFACECALLBACKS*    pSurfaceCallBacks,
DD_PALETTECALLBACKS*    pPaletteCallBacks)
{
    BOOL b;

    SYNCH_ENTER();
    DISPDBG((5, ">> DbgEnableDirectDraw"));

    b = DrvEnableDirectDraw(dhpdev,
                            pCallBacks,
                            pSurfaceCallBacks,
                            pPaletteCallBacks);

    DISPDBG((6, "<< DbgEnableDirectDraw"));
    SYNCH_LEAVE();

    return(b);
}

VOID DbgDisableDirectDraw(
DHPDEV      dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((5, ">> DbgDisableDirectDraw"));

    DrvDisableDirectDraw(dhpdev);

    DISPDBG((6, "<< DbgDisableDirectDraw"));
    SYNCH_LEAVE();
}
#endif // WNT_DDRAW

#if(_WIN32_WINNT >= 0x500)

BOOL DbgIcmSetDeviceGammaRamp(
DHPDEV     dhpdev,
ULONG      iFormat,
LPVOID     lpRamp)
{
    BOOL b;
    SYNCH_ENTER();
    DISPDBG((5, ">> DbgIcmSetDeviceGammaRamp"));

    b = DrvIcmSetDeviceGammaRamp(dhpdev, iFormat, lpRamp);

    DISPDBG((6, "<< DbgIcmSetDeviceGammaRamp"));
    SYNCH_LEAVE();
    return(b);
}

BOOL DbgGradientFill(
SURFOBJ    *psoDest,
CLIPOBJ    *pco,
XLATEOBJ   *pxlo,
TRIVERTEX  *pVertex,
ULONG       nVertex,
PVOID       pMesh,
ULONG       nMesh,
RECTL      *prclExtents,
POINTL     *pptlDitherOrg,
ULONG       ulMode)
{
    BOOL b;
    SYNCH_ENTER();
    DISPDBG((5, ">> DbgGradientFill"));

    b = DrvGradientFill(psoDest, pco, pxlo, pVertex, nVertex, pMesh, nMesh, prclExtents, pptlDitherOrg, ulMode);

    DISPDBG((6, "<< DbgGradientFill"));
    SYNCH_LEAVE();
    return(b);
}

BOOL DbgAlphaBlend(
SURFOBJ     *psoDest,
SURFOBJ     *psoSrc,
CLIPOBJ     *pco,
XLATEOBJ    *pxlo,
RECTL       *prclDest,
RECTL       *prclSrc,
BLENDOBJ    *pBlendObj)
{
    BOOL b;
    SYNCH_ENTER();
    DISPDBG((5, ">> DbgAlphaBlend"));

    b = DrvAlphaBlend(psoDest, psoSrc, pco, pxlo, prclDest, prclSrc, pBlendObj);

    DISPDBG((6, "<< DbgAlphaBlend"));
    SYNCH_LEAVE();
    return(b);
}

BOOL DbgTransparentBlt(
SURFOBJ     *psoDst,
SURFOBJ     *psoSrc,
CLIPOBJ     *pco,
XLATEOBJ    *pxlo,
RECTL       *prclDst,
RECTL       *prclSrc,
ULONG        iTransColor,
ULONG        ulReserved)
{
    BOOL b;
    SYNCH_ENTER();
    DISPDBG((5, ">> DbgTransparentBlt"));

    b = DrvTransparentBlt(psoDst, psoSrc, pco, pxlo, prclDst, prclSrc, iTransColor, ulReserved);

    DISPDBG((6, "<< DbgTransparentBlt"));
    SYNCH_LEAVE();
    return(b);
}

VOID DbgNotify(
SURFOBJ     *pso,
ULONG        iType,
PVOID        pvData)
{
    SYNCH_ENTER();
    DISPDBG((5, ">> DbgNotify"));

    DrvNotify(pso, iType, pvData);

    DISPDBG((6, "<< DbgNotify"));
    SYNCH_LEAVE();
}
 
#endif // (_WIN32_WINNT >= 0x500)

#endif // DBG || !SYNCHRONIZEACCESS_WORKS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\driver.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: driver.h
*
* Content: Contains prototypes for the display driver.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#define ENABLE_DXMANAGED_LINEAR_HEAP (_WIN32_WINNT >= 0x500 && WNT_DDRAW)

//////////////////////////////////////////////////////////////////////
// Put all the conditional-compile constants here.  There had better
// not be many!

#define SYNCHRONIZEACCESS_WORKS 1

// Useful for visualizing the 2-d heap:

#define DEBUG_HEAP              0

typedef struct _PDEV PDEV;      // Handy forward declaration

#define ALLOC_TAG_DX(id)   MAKEFOURCC('P','3','D',#@ id)
#define ALLOC_TAG_GDI(id)  MAKEFOURCC('P','3','G',#@ id)

//////////////////////////////////////////////////////////////////////
// Miscellaneous shared stuff

#define DLL_NAME                L"perm3dd"  // Name of the DLL in UNICODE

#define CLIP_LIMIT          50  // We'll be taking 800 bytes of stack space

#define DRIVER_EXTRA_SIZE   0   // Size of the DriverExtra information in the
                                //   DEVMODE structure

#define TMP_BUFFER_SIZE     16384   // Size in bytes of 'pvTmpBuffer'.  Has to
                                    //   be at least enough to store an entire
                                    //   scan line (i.e. 8192 for 2048x????x32).

typedef struct _CLIPENUM {
    LONG    c;
    RECTL   arcl[CLIP_LIMIT];   // Space for enumerating complex clipping

} CLIPENUM;                         /* ce, pce */


//////////////////////////////////////////////////////////////////////
// Text stuff

typedef struct _XLATECOLORS {       // Specifies foreground and background
ULONG   iBackColor;                 //   colours for faking a 1bpp XLATEOBJ
ULONG   iForeColor;
} XLATECOLORS;                          /* xlc, pxlc */

//////////////////////////////////////////////////////////////////////
// Dither stuff

// Describes a single colour tetrahedron vertex for dithering:

typedef struct _VERTEX_DATA {
    ULONG ulCount;              // Number of pixels in this vertex
    ULONG ulVertex;             // Vertex number
} VERTEX_DATA;                      /* vd, pv */

VERTEX_DATA*    vComputeSubspaces(ULONG, VERTEX_DATA*);
VOID            vDitherColor(ULONG*, VERTEX_DATA*, VERTEX_DATA*, ULONG);

//////////////////////////////////////////////////////////////////////
// Brush stuff

// 'Slow' brushes are used when we don't have hardware pattern capability,
// and we have to handle patterns using screen-to-screen blts:

#define SLOW_BRUSH_CACHE_DIM_X  8
#define SLOW_BRUSH_CACHE_DIM_Y  1   // Controls the number of brushes cached
                                    //   in off-screen memory, when we don't
                                    //   have the S3 hardware pattern support.
                                    //   We allocate 3 x 3 brushes, so we can
                                    //   cache a total of 9 brushes:
#define SLOW_BRUSH_COUNT        (SLOW_BRUSH_CACHE_DIM_X * SLOW_BRUSH_CACHE_DIM_Y)
#define SLOW_BRUSH_DIMENSION    40  // After alignment is taken care of,
                                    //   every off-screen brush cache entry
                                    //   will be 48 pels in both dimensions
#define SLOW_BRUSH_ALLOCATION   (SLOW_BRUSH_DIMENSION + 8)
                                    // Actually allocate 72x72 pels for each
                                    //   pattern, using the 8 extra for brush
                                    //   alignment

// 'Fast' brushes are used when we have hardware pattern capability:

#define FAST_BRUSH_COUNT        16  // Total number of non-hardware brushes
                                    //   cached off-screen
#define FAST_BRUSH_DIMENSION    8   // Every off-screen brush cache entry
                                    //   is 8 pels in both dimensions
#define FAST_BRUSH_ALLOCATION   8   // We have to align ourselves, so this is
                                    //   the dimension of each brush allocation

// Common to both implementations:

#define RBRUSH_2COLOR           1   // For RBRUSH flags

#define TOTAL_BRUSH_COUNT       max(FAST_BRUSH_COUNT, SLOW_BRUSH_COUNT)
                                    // This is the maximum number of brushes
                                    //   we can possibly have cached off-screen
#define TOTAL_BRUSH_SIZE        64  // We'll only ever handle 8x8 patterns,
                                    //   and this is the number of pels

// For now assume that all brushes are 64 entries (8x8 @ 32bpp):
// At 16bpp we should be able to handle 8 brushes, no idea what happens at 8bpp!
#define MAX_P3_BRUSHES      4

typedef struct _BRUSHENTRY BRUSHENTRY;

// NOTE: Changes to the RBRUSH or BRUSHENTRY structures must be reflected
//       in strucs.inc!

typedef struct _RBRUSH {
    ULONG       iUniq;            // our own unique brush ID
    FLONG       fl;             // Type flags
    DWORD       areaStippleMode;// area stipple mode if 1bpp.

/*** get rid of bTransparent later. We need it now so everything compiles OK ***/
    BOOL        bTransparent;   // TRUE if brush was realized for a transparent
                                //   blt (meaning colours are white and black),
                                //   FALSE if not (meaning it's already been
                                //   colour-expanded to the correct colours).
                                //   Value is undefined if the brush isn't
                                //   2 colour.
    ULONG       ulForeColor;    // Foreground colour if 1bpp
    ULONG       ulBackColor;    // Background colour if 1bpp
    ULONG       patternBase;    // Position of brush in LUT (colour P3 only)
    POINTL      ptlBrushOrg;    // Brush origin of cached pattern.  Initial
                                //   value should be -1
    BRUSHENTRY* apbe;           // Points to brush-entry that keeps track
                                //   of the cached off-screen brush bits
    ULONG       aulPattern[1];  // Open-ended array for keeping copy of the
      // Don't put anything     //   actual pattern bits in case the brush
      //   after here, or       //   origin changes, or someone else steals
      //   you'll be sorry!     //   our brush entry (declared as a ULONG
                                //   for proper dword alignment)

} RBRUSH;                           /* rb, prb */

typedef struct _BRUSHENTRY {
    RBRUSH*     prbVerify;      // We never dereference this pointer to
                                //   find a brush realization; it is only
                                //   ever used in a compare to verify
                                //   that for a given realized brush, our
                                //   off-screen brush entry is still valid.
    LONG        x;              // x-position of cached pattern
    LONG        y;              // y-position of cached pattern

} BRUSHENTRY;                       /* be, pbe */

typedef union _RBRUSH_COLOR {
    RBRUSH*     prb;
    ULONG       iSolidColor;
} RBRUSH_COLOR;                     /* rbc, prbc */

// 2D display driver DMA buffer definitions
typedef struct DMABuffer
{
    LARGE_INTEGER   pphysStart;
    PULONG          pulStart;
    PULONG          pulEnd;
    PULONG          pulCurrent;
    ULONG           cb;
}
DMA_BUFFER;

#define DD_DMA_BUFFER_SIZE (ppdev->DMABuffer.cb)

#define QUERY_DD_DMA_FREE_ULONGS(c) \
    c = ((ULONG)(1 + ppdev->DMABuffer.pulEnd - ppdev->DMABuffer.pulCurrent))

#define QUERY_DD_DMA_FREE_TAGDATA_PAIRS(cFree) \
    QUERY_DD_DMA_FREE_ULONGS(cFree) >> 1

#define WRITE_DD_DMA_ULONG(ul) \
    *ppdev->DMABuffer.pulCurrent++ = ul

#define WRITE_DD_DMA_TAGDATA(Tag, Data) \
{ \
    WRITE_DD_DMA_ULONG(Tag); \
    WRITE_DD_DMA_ULONG(Data); \
}

#define DD_DMA_XFER_IN_PROGRESS (!(ppdev->g_GlintBoardStatus & GLINT_DMA_COMPLETE))

#define WAIT_DD_DMA_COMPLETE \
{ \
    WAIT_IMMEDIATE_DMA_COMPLETE; \
    ppdev->g_GlintBoardStatus |= GLINT_DMA_COMPLETE; \
    ppdev->DMABuffer.pulCurrent = ppdev->DMABuffer.pulStart; \
}

/////////////////////////////////////////////////////////////////////////
// Heap stuff

// forward declaration, rather than include the DX headers here
typedef struct tagLinearAllocatorInfo LinearAllocatorInfo, *pLinearAllocatorInfo;

typedef enum {
    OH_FREE = 0,        // The off-screen allocation is available for use
    OH_DISCARDABLE,     // The allocation is occupied by a discardable bitmap
                        //   that may be moved out of off-screen memory
    OH_PERMANENT,       // The allocation is occupied by a permanent bitmap
                        //   that cannot be moved out of off-screen memory
} OHSTATE;

typedef struct _DSURF DSURF;
typedef struct _OH OH;
typedef struct _OH
{
    OHSTATE  ohState;       // State of off-screen allocation
    LONG     x;             // x-coordinate of left edge of allocation
    LONG     y;             // y-coordinate of top edge of allocation
    LONG     cx;            // Width in pixels of allocation
    LONG     cy;            // Height in pixels of allocation
    LONG     pixOffset;     // Offset in pixels to origin of bitmap
    LONG     lPixDelta;        // always == ppdev->cxMemory for rectangular bitmaps, otherwise == bitmap stride
    LONG     cxReserved;    // Dimensions of original reserved rectangle;
    LONG     cyReserved;    //   zero if rectangle is not 'reserved'
    OH*      pohNext;       // When OH_FREE or OH_RESERVE, points to the next
                            //   free node, in ascending cxcy value.  This is
                            //   kept as a circular doubly-linked list with a
                            //   sentinel at the end.
                            // When OH_DISCARDABLE, points to the next most
                            //   recently created allocation.  This is kept as
                            //   a circular doubly-linked list.
    OH*      pohPrev;       // Opposite of 'pohNext'
    ULONG    cxcy;          // Width and height in a dword for searching
    OH*      pohLeft;       // Rectangular heap: Adjacent allocation when in-use or available 
    OH*      pohUp;
    OH*      pohRight;
    OH*      pohDown;
    DSURF*   pdsurf;        // Points to our DSURF structure
    VOID*    pvScan0;       // Points to start of first scan-line
    BOOL     bOffScreen;

    BOOL     bDXManaged;        // TRUE if this is linear DFB, FALSE if it's rectangular

#if (_WIN32_WINNT >= 0x500)
    LinearAllocatorInfo *pvmHeap;    // if (bLinear) this points to the heap from which the DFB was allocated
    FLATPTR     fpMem;                // if (bLinear) this pointers to the DFB bitmap in the heap
#endif
};                              /* oh, poh */

// This is the smallest structure used for memory allocations:

typedef struct _OHALLOC OHALLOC;
typedef struct _OHALLOC
{
    OHALLOC* pohaNext;
    OH       aoh[1];
} OHALLOC;                      /* oha, poha */

typedef struct _HEAP
{
    LONG     cxMax;         // Largest possible free space by area
    LONG     cyMax;
    LONG     cxBounds;      // Largest possible bounding rectangle
    LONG     cyBounds;
    OH       ohFree;        // Head of the free list, containing those
                            //   rectangles in off-screen memory that are
                            //   available for use.  pohNext points to
                            //   hte smallest available rectangle, and pohPrev
                            //   points to the largest available rectangle,
                            //   sorted by cxcy.
    OH       ohDiscardable; // Head of the discardable list that contains all
                            //   bitmaps located in offscreen memory that
                            //   are eligible to be tossed out of the heap.
                            //   It is kept in order of creation: pohNext
                            //   points to the most recently created; pohPrev
                            //   points to the least recently created.
    OH       ohPermanent;   // List of permanently allocated rectangles
    OH*      pohFreeList;   // List of OH node data structures available
    OHALLOC* pohaChain;     // Chain of allocations

    ULONG   DDrawOffscreenStart;

#if (_WIN32_WINNT >= 0x500)
    LinearAllocatorInfo *pvmLinearHeap;
    ULONG       cLinearHeaps;
#endif
} HEAP;                         /* heap, pheap */

typedef enum {
    DT_SCREEN     = 0x1,    // Surface is kept in screen memory
    DT_DIB        = 0x2,    // Surface is kept as a DIB
    DT_DIRECTDRAW = 0x4,    // Surface is derived from ddraw surface
} DSURFTYPE;                    /* dt, pdt */

typedef struct _DSURF
{
    DSURFTYPE dt;           // DSURF status (whether off-screen or in a DIB)
    BOOL      bOffScreen;   // DFB (off-screen) driver surface, not the on-screen surface
    SIZEL     sizl;         // Size of the original bitmap (could be smaller
                            //   than poh->sizl)
    PDEV*     ppdev;        // Need this for deleting the bitmap

    // If the bitmap is in the heap we can still keep a GDI accessible bitmap
    // for it because the screen is fully and linearly mapped. When we kick
    // the bitmap off the heap we delete this bitmap and create a real
    // memory bitmap. So when DT_SCREEN, we use both pointers. Hence not a
    // union. 0I'm not convinced it's valid to change the public entries in a
    // SURFOBJ to turn one surface into another (i.e. create a bitmap to point
    // to the screen and later change it to point to memory) so I'm not doing
    // it. Hence, we delete and recreate the screen bitmap surface when
    // changing between DT_SCREEN and DT_DIB. Remember when we move the DIB
    // back onto the screen it generally won't be in the same place so the
    // base pointer has to change.

    OH*         poh;    // If DT_SCREEN, points to off-screen heap node.
    SURFOBJ*    pso;    // If DT_SCREEN, points to GDI accessible surface for the bitmap
                        //      else if DT_DIB, points to locked GDI surface

    // The following are used for DT_DIB only...

    ULONG     cBlt;         // Counts down the number of blts necessary at
                            //   the current uniqueness before we'll consider
                            //   putting the DIB back into off-screen memory
    ULONG     iUniq;        // Tells us whether there have been any heap
                            //   'free's since the last time we looked at
                            //   this DIB

} DSURF;                          /* dsurf, pdsurf */


// Number of blts necessary before we'll consider putting a DIB DFB back
// into off-screen memory:
#define HEAP_COUNT_DOWN     6

// Flags for 'pohAllocate':
typedef enum {
    FLOH_ONLY_IF_ROOM       = 0x00000001,   // Don't kick stuff out of off-
    FLOH_MAKE_PERMANENT     = 0x00000002,   // Allocate a permanent entry
    FLOH_RESERVE            = 0x00000004,   // Allocate an off-screen entry,
} FLOH;

BOOL bEnableOffscreenHeap(PDEV*);
VOID vDisableOffscreenHeap(PDEV*);
VOID vEnable2DOffscreenMemory(PDEV *);
BOOL bDisable2DOffscreenMemory(PDEV *);

BOOL bAssertModeOffscreenHeap(PDEV*, BOOL);
OH*  pohAllocate(PDEV*, POINTL*, LONG, LONG, FLOH);
VOID vSurfUsed(SURFOBJ*);
OH*  pohFree(PDEV*, OH*);

OH*  pohMoveOffscreenDfbToDib(PDEV*, OH*);
BOOL bMoveDibToOffscreenDfbIfRoom(PDEV*, DSURF*);

BOOL bCreateScreenDIBForOH(PDEV*, OH*, ULONG);
VOID vDeleteScreenDIBFromOH(OH *);

/////////////////////////////////////////////////////////////////////////
// Bank manager stuff

#define BANK_DATA_SIZE  80      // Number of bytes to allocate for the
                                //   miniport down-loaded bank code working
                                //   space

typedef struct _BANK
{
    // Private data:

    RECTL    rclDraw;           // Rectangle describing the remaining undrawn
                                //   portion of the drawing operation
    RECTL    rclSaveBounds;     // Saved from original CLIPOBJ for restoration
    BYTE     iSaveDComplexity;  // Saved from original CLIPOBJ for restoration
    BYTE     fjSaveOptions;     // Saved from original CLIPOBJ for restoration
    LONG     iBank;             // Current bank
    PDEV*    ppdev;             // Saved copy

    // Public data:

    SURFOBJ* pso;               // Surface wrapped around the bank.  Has to be
                                //   passed as the surface in any banked call-
                                //   back.
    CLIPOBJ* pco;               // Clip object that is the intersection of the
                                //   original clip object with the bounds of the
                                //   current bank.  Has to be passed as the clip
                                //   object in any banked call-back.

} BANK;                         /* bnk, pbnk */

typedef enum {
    BANK_OFF = 0,       // We've finished using the memory aperture
    BANK_ON,            // We're about to use the memory aperture
    BANK_DISABLE,       // We're about to enter full-screen; shut down banking
    BANK_ENABLE,        // We've exited full-screen; re-enable banking

} BANK_MODE;                    /* bankm, pbankm */

typedef VOID (FNBANKMAP)(VOID*, LONG);
typedef VOID (FNBANKSELECTMODE)(VOID*, BANK_MODE);
typedef VOID (FNBANKINITIALIZE)(VOID*, BOOL);
typedef BOOL (FNBANKCOMPUTE)(PDEV*, RECTL*, RECTL*, LONG*, LONG*);

VOID vBankStart(PDEV*, RECTL*, CLIPOBJ*, BANK*);
BOOL bBankEnum(BANK*);

FNBANKCOMPUTE bBankComputeNonPower2;
FNBANKCOMPUTE bBankComputePower2;

BOOL bEnableBanking(PDEV*);
VOID vDisableBanking(PDEV*);
VOID vAssertModeBanking(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Pointer stuff

#define POINTER_DATA_SIZE       128     // Number of bytes to allocate for the
                                        //   miniport down-loaded pointer code
                                        //   working space
#define HW_INVISIBLE_OFFSET     2       // Offset from 'ppdev->yPointerBuffer'
                                        //   to the invisible pointer
#define HW_POINTER_DIMENSION    64      // Maximum dimension of default
                                        //   (built-in) hardware pointer
#define HW_POINTER_TOTAL_SIZE   1024    // Total size in bytes required
                                        //   to define the hardware pointer

typedef enum {
    PTR_HW_ACTIVE   = 1,        // The hardware pointer is active and visible
                                //   on screen
    PTR_SW_ACTIVE   = 2,        // The software pointer is active
} PTRFLAGS;

BOOL bEnablePointer(PDEV*);
VOID vDisablePointer(PDEV*);
VOID vAssertModePointer(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// 64 x 64 Hardware Pointer Caching data structures

#define SMALL_POINTER_MEM (32 * 4 * 2)                // Bytes reqd for 32x32 cursor
#define LARGE_POINTER_MEM (SMALL_POINTER_MEM * 4)    // Bytes reqd for 64x64 cursor
#define SMALL_POINTER_MAX 4                         // No of cursors in cache

#define HWPTRCACHE_INVALIDENTRY (SMALL_POINTER_MAX + 1)    // Well-known value

// Pointer cache item data structure, there is one of these for every
// cached pointer
typedef struct {                            
    ULONG   ptrCacheTimeStamp;        // Timestamp used for LRU cache ageing
    ULONG   ptrCacheCX;                // width of cursor
    ULONG   ptrCacheCY;                // height of cursor
    LONG    ptrCacheLDelta;            // Line delta
} HWPointerCacheItemEntry;

// The complete cache looks like this
typedef struct {
    BYTE    ptrCacheIsLargePtr;        // TRUE if we have one 64x64 cursor, FALSE if we 
                                    // have multiple 32x32 cursors
    BYTE    ptrCacheInUseCount;        // The no. of cache items used
    ULONG   ptrCacheCurTimeStamp;    // The date stamp used for LRU stuff
    ULONG   ptrCacheData [LARGE_POINTER_MEM / 4];    // The cached pointer data
    HWPointerCacheItemEntry ptrCacheItemList [SMALL_POINTER_MAX];    // The cache item list
} HWPointerCache;

/////////////////////////////////////////////////////////////////////////
// Palette stuff

BOOL bEnablePalette(PDEV*);
VOID vDisablePalette();
VOID vAssertModePalette(PDEV*, BOOL);

BOOL bInitializePalette(PDEV*, DEVINFO*);
VOID vUninitializePalette(PDEV*);

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))

#if WNT_DDRAW
/////////////////////////////////////////////////////////////////////////
// DirectDraw stuff

// Sync with 2D driver
VOID vNTSyncWith2DDriver(PDEV *ppdev);

// Set up off-screen video memory for DirectDraw
BOOL bSetupOffscreenForDDraw (BOOL enableFlag, PDEV *ppdev, volatile ULONG ** VBlankAddress, volatile ULONG **bOverlayEnabled,
                              volatile ULONG **VBLANKUpdateOverlay, volatile ULONG **VBLANKUpdateOverlayWidth,
                              volatile ULONG **VBLANKUpdateOverlayHeight);

// Get framebuffer/Localbuffer info for DirectDraw
void GetFBLBInfoForDDraw (PDEV * ppdev, 
                          void ** fbPtr,            // Framebuffer pointer
                          void ** lbPtr,            // Localbuffer pointer
                          DWORD * fbSizeInBytes,    // Size of framebuffer
                          DWORD * lbSizeInBytes,    // Size of localbuffer
                          DWORD * fbOffsetInBytes,    // Offset to 1st 'free' byte in framebuffer
                          BOOL  * bSDRAM);            // TRUE if SDRAM (i.e. no h/w writemask)

// Get chip info for DirectDraw
void GetChipInfoForDDraw (PDEV* ppdev, 
                          DWORD* pdwChipID, 
                          DWORD* pdwChipRev, 
                          DWORD* pdwChipFamily, 
                          DWORD *pdwGammaRev);

LONG DDSendDMAData(PDEV* ppdev, ULONG PhysAddr, ULONG_PTR VirtAddr, LONG nDataEntries);
LONG DDGetFreeDMABuffer(DWORD *physAddr, ULONG_PTR *virtAddr, DWORD *bufferSize);
void DDFreeDMABuffer(void* dwPhysAddress);
LONG DDWaitDMAComplete(PDEV* ppdev);

#define ROUND_UP_TO_64K(x)  (((ULONG)(x) + 0x10000 - 1) & ~(0x10000 - 1))

BOOL _DD_DDE_bEnableDirectDraw(PDEV*);
VOID _DD_DDE_vDisableDirectDraw(PDEV*);
VOID _DD_DDE_vAssertModeDirectDraw(PDEV*, BOOL);
BOOL _DD_DDE_CreatePPDEV(PDEV* ppdev);
void _DD_DDE_DestroyPPDEV(PDEV* ppdev);
void _DD_DDE_ResetPPDEV(PDEV* ppdevOld, PDEV* ppdevNew);
VOID vAssertModeGlintExt(PDEV* ppdev, BOOL bEnable);

#endif // WNT_DDRAW

//////////////////////////////////////////////////////////////////////
// Low-level blt function prototypes


typedef VOID (GFNCOPY)(PDEV*, RECTL*, LONG, DWORD, POINTL*, RECTL*);
typedef VOID (GFNFILL)(PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR,
                                                                    POINTL*);
typedef VOID (GFNXFER)(PDEV*, RECTL*, LONG, ULONG, ULONG, SURFOBJ*, POINTL*,
                                                        RECTL*, XLATEOBJ*);
typedef VOID (GFNMCPY)(PDEV*, RECTL*, LONG, SURFOBJ*, POINTL*, ULONG, ULONG,
                                                            POINTL*, RECTL*);
typedef BOOL (GFNPOLY)(PDEV*, LONG, POINTFIX*, ULONG, ULONG, DWORD, CLIPOBJ*,
                                                             RBRUSH*, POINTL*);
typedef BOOL (GFNLINE)(PDEV*, LONG, LONG, LONG, LONG);
typedef VOID (GFNPATR)(PDEV*, RBRUSH*, POINTL*);
typedef VOID (GFNMONO)(PDEV*, RBRUSH*, POINTL*);
typedef BOOL (GFNINIS)(PDEV*, ULONG, DWORD, RECTL*);
typedef VOID (GFNRSTS)(PDEV*);
typedef VOID (GFNREPN)(PDEV*, RECTL*, CLIPOBJ*);
typedef VOID (GFNUPLD)(PDEV*, LONG, RECTL*, SURFOBJ*, POINTL*, RECTL*);
typedef VOID (SWAPCSBUFL)(PDEV**, LONG);

typedef VOID (GFN3DEXCL)(PDEV *, BOOL);
typedef VOID (GFNCOPYD)(PDEV *, SURFOBJ *, POINTL *, RECTL *, RECTL *, LONG);
typedef VOID (GFNXCOPYD)(PDEV *, SURFOBJ *, POINTL *, RECTL *, RECTL *, LONG, XLATEOBJ *);

#if (_WIN32_WINNT >= 0x500)
typedef BOOL (GFNGRADRECT)(PDEV *, TRIVERTEX *, ULONG, GRADIENT_RECT *, ULONG, ULONG, RECTL *, LONG);
typedef BOOL (GFNTRANSBLT)(PDEV *, RECTL *, POINTL *, ULONG, RECTL *, LONG);
typedef BOOL (GFNALPHABLT)(PDEV *, RECTL *, POINTL *, BLENDOBJ *, RECTL *, LONG);
#endif

typedef VOID (PTRENABLE)(PDEV *);
typedef VOID (PTRDISABLE)(PDEV *);
typedef BOOL (PTRSETSHAPE)(PDEV *, SURFOBJ *, SURFOBJ *, XLATEOBJ *, LONG, LONG, LONG, LONG);
typedef VOID (PTRMOVE)(PDEV *, LONG, LONG);
typedef VOID (PTRSHOW)(PDEV *, BOOL);

typedef struct _STRIP       STRIP;            // Actually in lines.h
typedef struct _LINESTATE   LINESTATE;        // Actually in lines.h
typedef VOID (* GAPFNstripFunc)(PDEV*, STRIP*, LINESTATE*);

// PXRX 2D DMA functions:
typedef struct _glint_data  *GlintDataPtr;    // Actually in Glint.h
typedef struct _PDEV        *PPDEV;            // Actually in Glint.h
typedef void    (* SendPXRXdma               )( PPDEV ppdev, GlintDataPtr glintInfo );
typedef void    (* SwitchPXRXdmaBuffer       )( PPDEV ppdev, GlintDataPtr glintInfo );
typedef void    (* WaitPXRXdmaCompletedBuffer)( PPDEV ppdev, GlintDataPtr glintInfo );


////////////////////////////////////////////////////////////////////////
// Capabilities flags
//
// These are private flags passed to us from the GLINT miniport.  They
// come from the high word of the 'AttributeFlags' field of the
// 'VIDEO_MODE_INFORMATION' structure (found in 'ntddvdeo.h') passed
// to us via an 'VIDEO_QUERY_AVAIL_MODES' or 'VIDEO_QUERY_CURRENT_MODE'
// IOCTL.
//
// NOTE: These definitions must match those in the GLINT miniport's 'glint.h'!

typedef enum {
    // NT4 uses the DeviceSpecificAttributes field so the low word is available
    CAPS_ZOOM_X_BY2         = 0x00000001,   // Hardware has zoomed by 2 in X
    CAPS_ZOOM_Y_BY2         = 0x00000002,   // Hardware has zoomed by 2 in Y
    CAPS_SPARSE_SPACE       = 0x00000004,    // Framebuffer is sparsely mapped 
                                            // (don't allow direct access). The machine
                                            // is probably an Alpha.
    CAPS_QUEUED_DMA         = 0x00000008,   // DMA address/count via the FIFO
    CAPS_LOGICAL_DMA        = 0x00000010,   // DMA through logical address table
    CAPS_USE_AGP_DMA        = 0x00000020,   // AGP DMA can be used.
    CAPS_P3RD_POINTER       = 0x00000040,    // Use the 3Dlabs P3RD RAMDAC
    CAPS_STEREO             = 0x00000080,    // Stereo mode enabled.
    CAPS_SW_POINTER         = 0x00010000,   // No hardware pointer; use software
                                            //  simulation
    CAPS_GLYPH_EXPAND       = 0x00020000,   // Use glyph-expand method to draw
                                            //  text.
    CAPS_RGB525_POINTER     = 0x00040000,   // Use IBM RGB525 cursor
    CAPS_FAST_FILL_BUG      = 0x00080000,   // Chip fast fill bug exists
    CAPS_INTERRUPTS         = 0x00100000,   // interrupts available
    CAPS_DMA_AVAILABLE      = 0x00200000,   // DMA is supported
    CAPS_DISABLE_OVERLAY    = 0x00400000,   // Chip do not support overlay
    CAPS_8BPP_RGB           = 0x00800000,   // Use RGB in 8bpp mode
    CAPS_RGB640_POINTER     = 0x01000000,   // Use IBM RGB640 cursor
    CAPS_DUAL_GLINT         = 0x02000000,   // Dual board (currently dual TX or MX)
    CAPS_GLINT2_RAMDAC      = 0x04000000,   // Second of dual glint attached to the RAMDAC
    CAPS_ENHANCED_TX        = 0x08000000,   // TX is in enhanced mode
    CAPS_ACCEL_HW_PRESENT   = 0x10000000,   // Accel Graphics Hardware
    CAPS_TVP4020_POINTER    = 0x20000000,   // Use Permedia2 builtin pointer
    CAPS_SPLIT_FRAMEBUFFER  = 0x40000000,   // Dual-GLINT with a split framebuffer
    CAPS_P2RD_POINTER       = 0x80000000    // Use the 3Dlabs P2RD RAMDAC
} CAPS;

////////////////////////////////////////////////////////////////////////
// Status flags

typedef enum {
    // STAT_* indicates that the resource actually exists
    STAT_GLYPH_CACHE        = 0x00000001,   // Glyph cache successfully allocated
    STAT_BRUSH_CACHE        = 0x00000002,   // Brush cache successfully allocated
    STAT_DEV_BITMAPS        = 0x00000004,   // Device Bitmaps are allowed
    STAT_POINTER_CACHE      = 0x00000008,   // Software cursor support configured
    STAT_LINEAR_HEAP        = 0x00000010,    // Linear heap configured

    // ENABLE_* indicates whether resource is currently available
    ENABLE_GLYPH_CACHE      = 0x00010000,   // Glyph cache enabled
    ENABLE_BRUSH_CACHE      = 0x00020000,   // Brush cache enabled
    ENABLE_DEV_BITMAPS      = 0x00040000,   // Device Bitmaps enabled
    ENABLE_POINTER_CACHE    = 0x00080000,   // Software cursor support enabled
    ENABLE_LINEAR_HEAP      = 0x00100000,    // linear heap support is available

#if WNT_DDRAW
    STAT_DIRECTDRAW         = 0x80000000,   // DirectDraw is enabled
#endif  WNT_DDRAW
} STATUS;

// Texel LUT Cache types and additional cache info
typedef enum
{
    LUTCACHE_INVALID, LUTCACHE_XLATE, LUTCACHE_BRUSH
}
LUTCACHE;

typedef struct _glint_ctxt_table GlintCtxtTable;

////////////////////////////////////////////////////////////////////////
// The Physical Device data structure

typedef struct  _PDEV
{
    DWORD       cFlags;                    // The cache flags
    LONG        xOffset;
    LONG        DstPixelOrigin;         // pixel offset to the current destination DFB
    LONG        SrcPixelOrigin;         // pixel offset to the current source DFB
    ULONG       xyOffsetDst;            // x & y offset to the current destination DFB
    ULONG       xyOffsetSrc;            // x & y offset to the current source DFB
    LONG        DstPixelDelta;
    LONG        SrcPixelDelta;
    BOOL        bDstOffScreen;

    BYTE*       pjScreen;               // Points to base screen address
    ULONG       iBitmapFormat;          // BMF_8BPP or BMF_16BPP or BMF_32BPP
                                        //   (our current colour depth)
    CAPS        flCaps;                 // Capabilities flags
    STATUS      flStatus;               // Status flags
    BOOL        bEnabled;               // In graphics mode (not full-screen)

    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV
    HSURF       hsurfScreen;            // Engine's handle to screen surface
    DSURF*      pdsurfScreen;           // Our private DSURF for the screen
    DSURF*      pdsurfOffScreen;        // Our private DSURF for the back buffer

    LONG        cxScreen;               // Visible screen width
    LONG        cyScreen;               // Visible screen height
    LONG        cxMemory;               // Width of Video RAM
    LONG        cyMemory;               // Height of Video RAM
    ULONG       ulMode;                 // Mode the mini-port driver is in.
    LONG        lDelta;                 // Distance from one scan to the next.
    ULONG       Vrefresh;                // Screen refresh frequency in Hz

    FLONG       flHooks;                // What we're hooking from GDI
    LONG        cjPelSize;              // Number of bytes per pel, according
                                        //   to GDI
    LONG        cPelSize;               // 0 if 8bpp, 1 if 16bpp, 2 if 32bpp
    ULONG       ulWhite;                // 0xff if 8bpp, 0xffff if 16bpp,
                                        //   0xffffffff if 32bpp
    ULONG*      pulCtrlBase[3];         // Mapped control registers for this PDEV
                                        //   2 entries to support Dual-TX
                                        //   1 entry for dense alpha mapping
    ULONG*      pulRamdacBase;          // Mapped control registers for the RAMDAC
    VOID*       pvTmpBuffer;            // General purpose temporary buffer,
                                        //   TMP_BUFFER_SIZE bytes in size
                                        //   (Remember to synchronize if you
                                        //   use this for device bitmaps or
                                        //   async pointers)
    DMA_BUFFER  DMABuffer;                // DMA buffer used by the 2D driver 
                                        //   (currently this is the same buffer as
                                        //   the line buffer in glintInfo)

    ////////// Palette stuff:

    PALETTEENTRY* pPal;                 // The palette if palette managed
    HPALETTE    hpalDefault;            // GDI handle to the default palette.
    FLONG       flRed;                  // Red mask for 16/32bpp bitfields
    FLONG       flGreen;                // Green mask for 16/32bpp bitfields
    FLONG       flBlue;                 // Blue mask for 16/32bpp bitfields
    ULONG       iPalUniq;                // P2 TexelLUT palette tracker
    ULONG       cPalLUTInvalidEntries;    // P2 TexelLUT invalidation tracker
    LUTCACHE    PalLUTType;                // P2 TexelLUT cached object type

    ////////// Heap stuff:

    HEAP        heap;                   // All our off-screen heap data
    ULONG       iHeapUniq;              // Incremented every time room is freed
                                        //   in the off-screen heap
    SURFOBJ*    psoPunt;                // Wrapper surface for having GDI draw
                                        //   on off-screen bitmaps
    SURFOBJ*    psoPunt2;               // Another one for off-screen to off-
                                        //   screen blts
    OH*         pohScreen;              // Off-screen heap structure for the
                                        //   visible screen
    ////////// Banking stuff:

    LONG        cjBank;                 // Size of a bank, in bytes
    LONG        cPower2ScansPerBank;    // Used by 'bBankComputePower2'
    LONG        cPower2BankSizeInBytes; // Used by 'bBankComputePower2'
    CLIPOBJ*    pcoBank;                // Clip object for banked call backs
    SURFOBJ*    psoBank;                // Surface object for banked call backs
    VOID*       pvBankData;             // Points to aulBankData[0]
    ULONG       aulBankData[BANK_DATA_SIZE / 4];
                                        // Private work area for downloaded
                                        //   miniport banking code

    FNBANKMAP*          pfnBankMap;
    FNBANKSELECTMODE*   pfnBankSelectMode;
    FNBANKCOMPUTE*      pfnBankCompute;

    ////////// Pointer stuff:

    BOOL        bPointerEnabled;

    LONG        xPointerHot;            // xHot of current hardware pointer
    LONG        yPointerHot;            // yHot of current hardware pointer

    LONG        yPointerBuffer;         // Start of off-screen pointer buffer
    LONG        dyPointerCurrent;       // y offset in buffer to current pointer
                                        //   (either 0 or 1)
    ULONG       ulHwGraphicsCursorModeRegister_45;
                                        // Default value for index 45
    PTRFLAGS    flPointer;              // Pointer state flags
    VOID*       pvPointerData;          // Points to ajPointerData[0]
    BYTE        ajPointerData[POINTER_DATA_SIZE];
                                        // Private work area for downloaded
                                        //   miniport pointer code
    ////////// Brush stuff:

    BOOL        bRealizeTransparent;    // Hint to DrvRealizeBrush for whether
                                        //   the brush should be realized as
                                        //   transparent or not
    LONG        cPatterns;              // Count of bitmap patterns created
    LONG        iBrushCache;            // Index for next brush to be allocated
    LONG        cBrushCache;            // Total number of brushes cached
    ULONG       iBrushCacheP3;          // Index for next LUT brush to be allocated
    BRUSHENTRY  abeMono;                // Keeps track of area stipple brush
    BRUSHENTRY  abeP3[MAX_P3_BRUSHES];  // Keeps track of LUT brushes
    BRUSHENTRY  abe[TOTAL_BRUSH_COUNT]; // Keeps track of brush cache
    HBITMAP     ahbmPat[HS_DDI_MAX];    // Engine handles to standard patterns

    /////////// Image download scratch area
    OH          *pohImageDownloadArea;
    ULONG       cbImageDownloadArea;

        ////////// Hardware pointer cache stuff:

    HWPointerCache  HWPtrCache;         // The cache data structure itself
    LONG        HWPtrLastCursor;        // The index of the last cursor that we drew
    LONG        HWPtrPos_X;             // The last X position of the cursor
    LONG        HWPtrPos_Y;             // The last Y position of the cursor

    PVOID       glintInfo;              // info about the interface to GLINT
    LONG        currentCtxt;            // id of the context currently loaded
    GlintCtxtTable* pGContextTable;     // pointer to contexts table
    ULONG       g_GlintBoardStatus;     // indicate whether DMA has completed,
                                        // the GLINT is synced etc

    LONG        FrameBufferLength;      // Length of framebuffer in bytes

    LONG        Disable2DCount;

// pointers to low level routines
    GFNCOPY     *pgfnCopyBlt;
    GFNCOPY     *pgfnCopyBltNative;     //azn unused
    GFNCOPY     *pgfnCopyBltCopyROP;
    GFNFILL     *pgfnFillSolid;
    GFNFILL     *pgfnFillPatMono;
    GFNFILL     *pgfnFillPatColor;
    GFNXFER     *pgfnXfer1bpp;
    GFNXFER     *pgfnXfer4bpp;
    GFNXFER     *pgfnXfer8bpp;
    GFNXFER     *pgfnXferImage;
    GFNXFER     *pgfnXferNative;    //azn unused
    GFNMCPY     *pgfnMaskCopyBlt;
    GFNPATR     *pgfnPatRealize;
    GFNMONO     *pgfnMonoOffset;
    GFNPOLY     *pgfnFillPolygon;
    GFNLINE     *pgfnDrawLine;
    GFNLINE     *pgfnIntegerLine;
    GFNLINE     *pgfnContinueLine;
    GFNINIS     *pgfnInitStrips;
    GFNRSTS     *pgfnResetStrips;
    GFNREPN     *pgfnRepNibbles;    //azn unused
    GFNUPLD     *pgfnUpload;
    GFNCOPYD    *pgfnCopyXferImage;
    GFNCOPYD    *pgfnCopyXfer16bpp; //azn unused
    GFNCOPYD    *pgfnCopyXfer24bpp;
    GFNXCOPYD   *pgfnCopyXfer8bppLge;
    GFNXCOPYD   *pgfnCopyXfer8bpp;
    GFNXCOPYD   *pgfnCopyXfer4bpp;

#if (_WIN32_WINNT >= 0x500)
    GFNGRADRECT     *pgfnGradientFillRect;
    GFNTRANSBLT     *pgfnTransparentBlt;
    GFNALPHABLT     *pgfnAlphaBlend;
#endif

    GAPFNstripFunc  *gapfnStrip;    // Line drawing functions

    // PXRX 2D stuff:
    SendPXRXdma                 sendPXRXdmaForce;        // Will not return until the DMA has been started
    SendPXRXdma                 sendPXRXdmaQuery;        // Will send if there is FIFO space
    SendPXRXdma                 sendPXRXdmaBatch;        // Will only batch the data up
    SwitchPXRXdmaBuffer         switchPXRXdmaBuffer;
    WaitPXRXdmaCompletedBuffer  waitPXRXdmaCompletedBuffer;

#if WNT_DDRAW
    void *      thunkData;                // Opaque pointer to DDRAWs global data
    LONG        DDContextID;            // DDRAW contextID
    LONG        DDContextRefCount;
    DWORD       oldIntEnableFlags;        // Interrupt enable flags when DDRAW started
#endif  //  WNT_DDRAW

} PDEV, *PPDEV;

// azn  -take out???
#define REMOVE_SWPOINTER(surface)

/////////////////////////////////////////////////////////////////////////
// Miscellaneous prototypes:

BOOL bIntersect(RECTL*, RECTL*, RECTL*);
LONG cIntersect(RECTL*, RECTL*, LONG);
BOOL bFastFill(PDEV*, LONG, POINTFIX*, ULONG, ULONG, ULONG, RBRUSH*);
DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION*, DWORD*);

BOOL bInitializeModeFields(PDEV*, GDIINFO*, DEVINFO*, DEVMODEW*);

BOOL bEnableHardware(PDEV*);
VOID vDisableHardware(PDEV*);
BOOL bAssertModeHardware(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// The x86 C compiler insists on making a divide and modulus operation
// into two DIVs, when it can in fact be done in one.  So we use this
// macro.
//
// Note: QUOTIENT_REMAINDER implicitly takes unsigned arguments.

#if defined(i386)

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    __asm mov eax, ulNumerator                                  \
    __asm sub edx, edx                                          \
    __asm div ulDenominator                                     \
    __asm mov ulQuotient, eax                                   \
    __asm mov ulRemainder, edx                                  \
}

#else

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    ulQuotient  = (ULONG) ulNumerator / (ULONG) ulDenominator;  \
    ulRemainder = (ULONG) ulNumerator % (ULONG) ulDenominator;  \
}

#endif

/////////////////////////////////////////////////////////////////////////
// OVERLAP - Returns TRUE if the same-size lower-right exclusive
//           rectangles defined by 'pptl' and 'prcl' overlap:

#define OVERLAP(prcl, pptl)                                             \
    (((prcl)->right  > (pptl)->x)                                   &&  \
     ((prcl)->bottom > (pptl)->y)                                   &&  \
     ((prcl)->left   < ((pptl)->x + (prcl)->right - (prcl)->left))  &&  \
     ((prcl)->top    < ((pptl)->y + (prcl)->bottom - (prcl)->top)))

//
// Work out the pixel offset for a DFB. We calculate this for Y only. Because
// we have to support dual-screen on Permedia we need to subtract X from the
// rasterised coordinates to prevent the rasteriser X registers from overflow.
//
#define POH_SET_RECTANGULAR_PIXEL_OFFSET(ppdev, poh) \
{ \
    (poh)->pixOffset = 0; \
}

//
// Convert a pixel offset suitable for a render through the core into
// an offset that can be used to access the frame buffer directly.
// This is trivial when we don't have a Gamma Geo twin. We assume
// that the value is a whole number of scan lines.
//
#define RENDER_PIXOFFSET_TO_FB_PIXOFFSET(pixoff) (pixoff)

//////////////////////////////////////////////////////////////////////
// Cache flag manipulation


#define cFlagFBReadDefault          0x01        // Cache flag definitions
#define cFlagLogicalOpDisabled      0x02
#define cFlagConstantFBWrite        0x04
#define cFlagScreenToScreenCopy     0x08

//@@BEGIN_DDKSPLIT
#define VERIFY_SETFLAGS 0
#define VERIFY_CHECKFLAGS 0
#if DBG && (VERIFY_SETFLAGS || VERIFY_CHECKFLAGS)
    // The following Macros are debug versions. They aren't included in the normal
    // debug build because they do a sync and, hence, slow things down.
    #if VERIFY_CHECKFLAGS
         extern void __CheckFlags(PDEV *p, ULONG x);
        #define CHECK_CACHEFLAGS(p,x) (__CheckFlags(p, (ULONG)x), (p)->cFlags & (x))
    #else
        #define CHECK_CACHEFLAGS(p,x)((p)->cFlags & (x))    // Cache flag macros
    #endif //VERIFY_CHECKFLAGS

    #if VERIFY_SETFLAGS
        #define SET_CACHEFLAGS(p,x)    \
        {    \
            ULONG lop, fbr, cFlags = (p)->cFlags = (x);    \
            SYNC_WITH_GLINT;    \
            READ_GLINT_FIFO_REG (__GlintTagLogicalOpMode, lop);    \
            READ_GLINT_FIFO_REG (__GlintTagFBReadMode, fbr);    \
            READ_GLINT_FIFO_REG (__GlintTagLogicalOpMode, lop);    \
            ASSERTDD ((cFlags & cFlagFBReadDefault) == 0 || ((cFlags & cFlagFBReadDefault) && fbr == glintInfo->FBReadMode),    \
                      "SCF: Bad set fbread cache flag");    \
            /* ASSERTDD (((cFlags & cFlagFBReadDefault) == 0 && fbr != glintInfo->FBReadMode), */ \
            /*          "SCF: Bad clear fbread cache flag"); */    \
            ASSERTDD ((cFlags & cFlagLogicalOpDisabled) == 0 || ((cFlags & cFlagLogicalOpDisabled) && (lop & 0x1) == 0x0),    \
                      "SCF: Bad set logicop cache flag");    \
            /* ASSERTDD (((cFlags & cFlagLogicalOpDisabled) == 0 && (lop & 0x1)), */    \
            /*          "SCF: Bad clear logicop cache flag");    */    \
            ASSERTDD ((cFlags & cFlagConstantFBWrite) == 0 || ((cFlags & cFlagConstantFBWrite) && (lop & (1<<5))),    \
                      "SCF: Bad set const fbwrite cache flag");    \
            /* ASSERTDD (((cFlags & cFlagConstantFBWrite) == 0 && (lop & (1<<5)) == 0x0), */    \
            /*          "SCF: Bad clear const fbwrite cache flag"); */    \
        }
    #else
        #define SET_CACHEFLAGS(p,x)((p)->cFlags = (x))
    #endif //VERIFY_SETFLAGS
    #define ADD_CACHEFLAGS(p,x) ((p)->cFlags |= (x))
#else
// Non-debug version of the cacheflags macros
//@@END_DDKSPLIT
#define CHECK_CACHEFLAGS(p,x)((p)->cFlags & (x))    // Cache flag macros
#define SET_CACHEFLAGS(p,x)((p)->cFlags = (x))
#define ADD_CACHEFLAGS(p,x) ((p)->cFlags |= (x))
//@@BEGIN_DDKSPLIT
#endif  // DBG && 0
//@@END_DDKSPLIT

// These Dbg prototypes are thunks for debugging:

ULONG   DbgGetModes(HANDLE, ULONG, DEVMODEW*);
DHPDEV  DbgEnablePDEV(DEVMODEW*, PWSTR, ULONG, HSURF*, ULONG, ULONG*,
                      ULONG, DEVINFO*, HDEV, PWSTR, HANDLE);
VOID    DbgCompletePDEV(DHPDEV, HDEV);
HSURF   DbgEnableSurface(DHPDEV);
BOOL    DbgStrokePath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, XFORMOBJ*, BRUSHOBJ*,
                      POINTL*, LINEATTRS*, MIX);
BOOL    DbgLineTo(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, LONG, LONG, LONG,
                  LONG, RECTL*, MIX);
BOOL    DbgFillPath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*,
                    MIX, FLONG);
BOOL    DbgBitBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                  RECTL*, POINTL*, POINTL*, BRUSHOBJ*, POINTL*, ROP4);
VOID    DbgDisablePDEV(DHPDEV);
VOID    DbgSynchronize(DHPDEV, RECTL*);
VOID    DbgDisableSurface(DHPDEV);
BOOL    DbgAssertMode(DHPDEV, BOOL);
VOID    DbgMovePointer(SURFOBJ*, LONG, LONG, RECTL*);
ULONG   DbgSetPointerShape(SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*, LONG,
                           LONG, LONG, LONG, RECTL*, FLONG);
ULONG   DbgDitherColor(DHPDEV, ULONG, ULONG, ULONG*);
BOOL    DbgSetPalette(DHPDEV, PALOBJ*, FLONG, ULONG, ULONG);
BOOL    DbgCopyBits(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*, POINTL*);
BOOL    DbgTextOut(SURFOBJ*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*, RECTL*,
                   BRUSHOBJ*, BRUSHOBJ*, POINTL*, MIX);
VOID    DbgDestroyFont(FONTOBJ*);
BOOL    DbgPaint(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*, MIX);
BOOL    DbgRealizeBrush(BRUSHOBJ*, SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*,
                        ULONG);
HBITMAP DbgCreateDeviceBitmap(DHPDEV, SIZEL, ULONG);
VOID    DbgDeleteDeviceBitmap(DHSURF);
BOOL    DbgStretchBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                      COLORADJUSTMENT*, POINTL*, RECTL*, RECTL*, POINTL*,
                      ULONG);
ULONG   DbgDrawEscape(SURFOBJ *, ULONG, CLIPOBJ *, RECTL *, ULONG, VOID *);
ULONG   DbgEscape(SURFOBJ *, ULONG, ULONG, VOID *, ULONG, VOID *);
BOOL    DbgResetPDEV(DHPDEV, DHPDEV);


#if WNT_DDRAW
BOOL    DbgGetDirectDrawInfo(DHPDEV, DD_HALINFO*, DWORD*, VIDEOMEMORY*,
                             DWORD*, DWORD*);
BOOL    DbgEnableDirectDraw(DHPDEV, DD_CALLBACKS*, DD_SURFACECALLBACKS*,
                            DD_PALETTECALLBACKS*);
VOID    DbgDisableDirectDraw(DHPDEV);
#endif // WNT_DDRAW


#if (_WIN32_WINNT >= 0x500)
BOOL DbgIcmSetDeviceGammaRamp(DHPDEV dhpdev, ULONG iFormat, LPVOID lpRamp);
BOOL DbgGradientFill(SURFOBJ *, CLIPOBJ *, XLATEOBJ *, TRIVERTEX *, ULONG, PVOID, ULONG, RECTL *, 
                     POINTL *, ULONG);
BOOL DbgAlphaBlend(SURFOBJ *, SURFOBJ *, CLIPOBJ *, XLATEOBJ *, RECTL *, RECTL *, BLENDOBJ *);
BOOL DbgTransparentBlt(SURFOBJ *, SURFOBJ *, CLIPOBJ *, XLATEOBJ *, RECTL *, RECTL *, ULONG, ULONG);
VOID DbgNotify(IN SURFOBJ *, IN ULONG, IN PVOID);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\ereg.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: ereg.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifdef __EREG
#pragma message ("FILE : "__FILE__" : Multiple inclusion")
#endif

#define __EREG

#ifndef _MSDOS 
typedef unsigned long unsigned32;
typedef signed long signed32;
#else
typedef unsigned long unsigned32;
typedef signed long signed32;
#endif

#define TAGBITS         12
#define CONTEXTBITS     1
#define ADDRBITS        (32 - TAGBITS - CONTEXTBITS)

#define ENABLE_BLOCK    1
#define DISABLE_BLOCK   0

#define X_FIELD_MAX     0x7FFF      /* signed 16 bits */
#define Y_FIELD_MAX     X_FIELD_MAX

typedef unsigned32     __GlintUnsignedIntFmat;
typedef signed32       __GlintSignedIntFmat;
typedef unsigned32     __GlintDataFmat;
typedef signed32       __Glint16FixPt16Fmat;
typedef signed32       __Glint16BitIntFmat;
typedef unsigned32     __GlintBitMaskPatternFmat;
typedef unsigned32     __GlintPointTableFmat;
typedef unsigned32     __GlintAreaStipplePatternFmat;
typedef unsigned32     __GlintSaveLineStippleStateFmat;
typedef unsigned32     __GlintUpdateLineStippleStateFmat;
typedef signed32       __GlintABGRFmat;
typedef signed32       __GlintLBSourceOffsetFmat;
typedef unsigned32     __GlintLBWindowBaseFmat;
typedef unsigned32     __GlintLBDepthFmat;
typedef unsigned32     __GlintDepthFmat;
typedef signed32       __GlintUZFmat;
typedef unsigned32     __GlintLZFmat;
typedef signed32       __GlintFastClearDepthFmat;
typedef signed32       __GlintFBPixelOffsetFmat;
typedef signed32       __GlintFBSourceOffsetFmat;
typedef unsigned32     __GlintFBWindowBaseFmat;
typedef unsigned32     __GlintFBRDataFmat;
typedef unsigned32     __GlintFBSoftwareWriteMaskFmat;
typedef unsigned32     __GlintFBHardwareWriteMaskFmat;
typedef unsigned32     __GlintFBModifiedDataFmat;
typedef unsigned32     __GlintFBPixelWriteMaskFmat;
typedef unsigned32     __GlintFBBlockColorFmat;
typedef unsigned32     __GlintFBBlockColorUFmat;
typedef unsigned32     __GlintFBBlockColorLFmat;
typedef signed32       __Glint1x8InterpFmat;
typedef signed32       __GlintFogFmat;
typedef unsigned char  __GlintStencilValFmat;
typedef unsigned32     __GlintAddress;

typedef unsigned32     __GlintWaitForCompletionFmat;

typedef unsigned32     __GlintCoverageValueFmat;
typedef unsigned32     __GlintSpanMaskFmat;

typedef unsigned32     __GlintFBSourceDataFmat;
typedef unsigned32     __GlintFBDataFmat;

typedef struct {
  unsigned32 lo;
  unsigned32 hi;
} __GlintLBRawDataFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:          27;
  unsigned32 Sign:           1;
  unsigned32 Magnitude:      4;
} __GlintSubPixelCorrectionFmat;
#else
//@@BEGIN_DDKSPLIT
// TMP HACK TO GET NT GOING
//@@END_DDKSPLIT
typedef unsigned32 __GlintSubPixelCorrectionFmat;
/*
typedef struct {
  unsigned32 Magnitude:      4;
  unsigned32 Sign:           1;
  unsigned32 pad0:          27;
} __GlintSubPixelCorrectionFmat;
*/
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 XRight:     16;
  unsigned32 XLeft:      16;
} __GlintFastBlockLimitsFmat;
#else
typedef struct {
  unsigned32 XLeft:      16;
  unsigned32 XRight:     16;
} __GlintFastBlockLimitsFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Depth:      32; 
  unsigned32 pad:        12;
  unsigned32 GID:         4; 
  unsigned32 FrameCount:  8; 
  unsigned32 Stencil:     8; 
} __GlintLBDataFmat;
#else
typedef struct {
  unsigned32 Depth:      32; 
  unsigned32 Stencil:     8; 
  unsigned32 FrameCount:  8; 
  unsigned32 GID:         4; 
  unsigned32 pad:        12;
} __GlintLBDataFmat;
#endif


#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 V:                12; /* 12@20 */
  unsigned32 U:                20; /* 20@0  */
  unsigned32 pad0:             24; /* 24@8  */
  unsigned32 V_u:              8;  /* 8@0   */
} __GlintTexelCoordUVFmat;
#else
/* CHECK THIS */
typedef struct {
  unsigned32 V_u:              8;  /* 8@0   */
  unsigned32 pad0:             24; /* 24@8  */
  unsigned32 U:                20; /* 20@0  */
  unsigned32 V:                12; /* 12@20 */
} __GlintTexelCoordUVFmat;
#endif


#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:          25;
  unsigned32 Present0:       1;
  unsigned32 BorderColor0:   1;
  unsigned32 Depth0:         5;
} __GlintTexelDataFmat;
#else
typedef struct {
  unsigned32 Depth0:         5;
  unsigned32 BorderColor0:   1;
  unsigned32 Present0:       1;
  unsigned32 pad0:          25;
} __GlintTexelDataFmat;
#endif

// SuspendUntilFrameBlank tag has two formats dependant on sync_mode and
// defined by the Hardware FB Arbiter
//

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 sync_mode:           2;
  unsigned32 pad2:                3;
  unsigned32 ext_index:          11;
  unsigned32 pad1:                8;
  unsigned32 ext_data:            8;
} __GlintSuspendUntilFrameBlankExtFmat;
#else
typedef struct {
  unsigned32 ext_data:            8;
  unsigned32 pad1:                8;
  unsigned32 ext_index:          11;
  unsigned32 pad2:                3;
  unsigned32 sync_mode:           2;
} __GlintSuspendUntilFrameBlankExtFmat;
#endif


#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 sync_mode:           2;
  unsigned32 pad:                20;
  unsigned32 vtg_sclk:            1;
  unsigned32 vtg_data:            9;
} __GlintSuspendUntilFrameBlankVtgFmat;
#else
typedef struct {
  unsigned32 vtg_data:            9;
  unsigned32 vtg_sclk:            1;
  unsigned32 pad:                20;
  unsigned32 sync_mode:           2;
} __GlintSuspendUntilFrameBlankVtgFmat;
#endif


typedef struct {
  unsigned32 UnitEnable: 32; 
} __GlintEnableFmat;

#if BIG_ENDIAN == 1
typedef struct {
  signed32 Y:  16;
  signed32 X:  16;
} __GlintXYFmat;
#else
typedef struct {
  signed32 X:  16;
  signed32 Y:  16;
} __GlintXYFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  signed32 top:  16;
  signed32 left:  16;
} __GlintRectOrigin;
#else
typedef struct {
  signed32 left:  16;
  signed32 top:  16;
} __GlintRectOrigin;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  signed32 cy:  16;
  signed32 cx:  16;
} __GlintRectSize;
#else
typedef struct {
  signed32 cx:  16;
  signed32 cy:  16;
} __GlintRectSize;
#endif

typedef __GlintXYFmat __GlintStepFmat;

#if BIG_ENDIAN == 1
typedef struct {
  signed32 Y:             16;
  signed32 X:             16; /* 16@0 */
  unsigned32 pad0:        30;
  unsigned32 WriteMode:    2; /* 2@0 */
} __GlintLBStepFmat;
#else 
typedef struct {
  signed32 X:             16; /* 16@0 */
  signed32 Y:             16;
  unsigned32 WriteMode:    2; /* 2@0 */
  unsigned32 pad0:        30;
} __GlintLBStepFmat;
#endif


#if BIG_ENDIAN == 1
typedef struct {
 unsigned32 pad0:         16;
 unsigned32 Val:          16;
} __GlintCountFmat;
#else
//@@BEGIN_DDKSPLIT
// TMP HACK TO GET NT GOING
//@@END_DDKSPLIT
typedef unsigned32 __GlintCountFmat;
/*
typedef struct {
 unsigned32 Val:          16;
 unsigned32 pad0:         16;
} __GlintCountFmat;
*/
#endif

#if BIG_ENDIAN == 1
typedef struct {
  signed32 YOrigin:  16;
  signed32 XOrigin:  16;
} __GlintGIDTableFmat;
#else
typedef struct {
  signed32 XOrigin:  16;
  signed32 YOrigin:  16;
} __GlintGIDTableFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                 30;
  unsigned32 ScreenScissorEnable:  1; 
  unsigned32 UserScissorEnable:    1;
} __GlintScissorEnableFmat;
#else
typedef struct {
  unsigned32 UserScissorEnable:    1;
  unsigned32 ScreenScissorEnable:  1; 
  unsigned32 pad:                 30;
} __GlintScissorEnableFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:                     13;
  unsigned32 SpanOperation:             1;
  unsigned32 pad0:                      1;
  unsigned32 SubPixelCorrectionEnable:  1;
  unsigned32 CoverageEnable:            1;
  unsigned32 FogEnable:                 1;
  unsigned32 TextureEnable:             1;
  unsigned32 SyncOnHostData:            1;
  unsigned32 SyncOnBitMask:             1;
  unsigned32 UsePointTable:             1;
  unsigned32 AntialiasingQuality:       1;
  unsigned32 AntialiasEnable:           1;
  unsigned32 PrimitiveType:             2;
  unsigned32 FastFillIncrement:         2; /* unused on TX */
  unsigned32 FastFillEnable:            1;
  unsigned32 ResetLineStipple:          1;
  unsigned32 LineStippleEnable:         1;
  unsigned32 AreaStippleEnable:         1;
} __GlintRenderFmat;
#else
typedef struct {
  unsigned32 AreaStippleEnable:         1;
  unsigned32 LineStippleEnable:         1;
  unsigned32 ResetLineStipple:          1;
  unsigned32 FastFillEnable:            1;
  unsigned32 FastFillIncrement:         2; /* unused on TX */
  unsigned32 PrimitiveType:             2;
  unsigned32 AntialiasEnable:           1;
  unsigned32 AntialiasingQuality:       1;
  unsigned32 UsePointTable:             1;
  unsigned32 SyncOnBitMask:             1;
  unsigned32 SyncOnHostData:            1;
  unsigned32 TextureEnable:             1;
  unsigned32 FogEnable:                 1;
  unsigned32 CoverageEnable:            1;
  unsigned32 SubPixelCorrectionEnable:  1;
  unsigned32 pad0:                      1;
  unsigned32 SpanOperation:             1;
  unsigned32 pad1:                     13;
} __GlintRenderFmat;
#endif

typedef __GlintRenderFmat __GlintPrepareToRenderFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:                13;
  unsigned32 YLimitsEnable:        1;
  unsigned32 MultiGLINT:           1;
  unsigned32 HostDataByteSwapMode: 2;
  unsigned32 BitMaskOffset:        5;
  unsigned32 BitMaskPacking:       1;
  unsigned32 BitMaskByteSwapMode:  2;
  unsigned32 pad0:                 1;
  unsigned32 BiasCoordinates:      2;
  unsigned32 FractionAdjust:       2;
  unsigned32 InvertBitMask:        1;
  unsigned32 MirrorBitMask:        1;
} __GlintRasterizerModeFmat;
#else
typedef struct {
  unsigned32 MirrorBitMask:        1;
  unsigned32 InvertBitMask:        1;
  unsigned32 FractionAdjust:       2;
  unsigned32 BiasCoordinates:      2;
  unsigned32 pad0:                 1;
  unsigned32 BitMaskByteSwapMode:  2;
  unsigned32 BitMaskPacking:       1;
  unsigned32 BitMaskOffset:        5;
  unsigned32 HostDataByteSwapMode: 2;
  unsigned32 MultiGLINT:           1;
  unsigned32 YLimitsEnable:        1;
  unsigned32 pad1:                13;
} __GlintRasterizerModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                5;
  unsigned32 MirrorStippleMask:  1;
  unsigned32 StippleMask:       16;
  unsigned32 RepeatFactor:       9;
  unsigned32 UnitEnable:         1;
} __GlintLineStippleModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:         1;
  unsigned32 RepeatFactor:       9;
  unsigned32 StippleMask:       16;
  unsigned32 MirrorStippleMask:  1;
  unsigned32 pad:         5;
} __GlintLineStippleModeFmat;
#endif

typedef __GlintXYFmat __GlintScreenRegionFmat;
typedef __GlintXYFmat __GlintScissorMinXYFmat;
typedef __GlintXYFmat __GlintScissorMaxXYFmat;
typedef __GlintXYFmat __GlintWindowOriginFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                   6;
  unsigned32 SegmentRepeatCounter:  9;
  unsigned32 SegmentBitCounter:     4;
  unsigned32 LiveRepeatCounter:     9;
  unsigned32 LiveBitCounter:        4;
} __GlintLineStippleCountersFmat;
#else
typedef struct {
  unsigned32 LiveBitCounter:        4;
  unsigned32 LiveRepeatCounter:     9;
  unsigned32 SegmentBitCounter:     4;
  unsigned32 SegmentRepeatCounter:  9;
  unsigned32 pad:                   6;
} __GlintLineStippleCountersFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                 12;
  unsigned32 MirrorY:              1;
  unsigned32 MirrorX:              1;
  unsigned32 InvertStipplePattern: 1;
  unsigned32 YOffset:              5;
  unsigned32 XOffset:              5;
  unsigned32 YAddressSelect:       3;
  unsigned32 XAddressSelect:       3;
  unsigned32 UnitEnable:           1;
} __GlintAreaStippleModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:           1;
  unsigned32 XAddressSelect:       3;
  unsigned32 YAddressSelect:       3;
  unsigned32 XOffset:              5;
  unsigned32 YOffset:              5;
  unsigned32 InvertStipplePattern: 1;
  unsigned32 MirrorX:              1;
  unsigned32 MirrorY:              1;
  unsigned32 pad:                 12;
} __GlintAreaStippleModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                31;
  unsigned32 Order:                1;
} __GlintRouterModeFmat;
#else 
typedef struct {
  unsigned32 Order:                1;
  unsigned32 pad0:                31;
} __GlintRouterModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:        30;
  unsigned32 ShadeMode:   1;
  unsigned32 UnitEnable:  1;
} __GlintColorDDAModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:  1;
  unsigned32 ShadeMode:   1;
  unsigned32 pad:        30;
} __GlintColorDDAModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Alpha:            8;
  unsigned32 Blue:             8;
  unsigned32 Green:            8;
  unsigned32 Red:              8;
} __GlintColorFmat;
#else
//@@BEGIN_DDKSPLIT
// TMP HACK TO GET NT GOING
//@@END_DDKSPLIT
typedef unsigned32 __GlintColorFmat;
/*
typedef struct {
  unsigned32 Red:              8;
  unsigned32 Green:            8;
  unsigned32 Blue:             8;
  unsigned32 Alpha:            8;
} __GlintColorFmat;
*/
#endif

typedef __GlintColorFmat __GlintConstantColorFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         9;
  unsigned32 Fraction:     15;
} __GlintCStartFmat;
#else
typedef struct {
  unsigned32 Fraction:     15;
  signed32 Integer:         9;
  unsigned32 pad2:          8;
} __GlintCStartFmat;
#endif

typedef __GlintCStartFmat __GlintRStartFmat;
typedef __GlintCStartFmat __GlintGStartFmat;
typedef __GlintCStartFmat __GlintBStartFmat;
typedef __GlintCStartFmat __GlintAStartFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         9;
  unsigned32 Fraction:     15;
} __GlintdCdxFmat;
#else
typedef struct {
  unsigned32 Fraction:     15;
  signed32 Integer:         9;
  unsigned32 pad2:          8;
} __GlintdCdxFmat;
#endif

typedef __GlintdCdxFmat __GlintdRdxFmat;
typedef __GlintdCdxFmat __GlintdGdxFmat;
typedef __GlintdCdxFmat __GlintdBdxFmat;
typedef __GlintdCdxFmat __GlintdAdxFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         9;
  unsigned32 Fraction:     15;
} __GlintdCdyDomFmat;
#else
typedef struct {
  unsigned32 Fraction:     15;
  signed32 Integer:         9;
  unsigned32 pad2:          8;
} __GlintdCdyDomFmat;
#endif

typedef __GlintdCdyDomFmat __GlintdRdyDomFmat;
typedef __GlintdCdyDomFmat __GlintdGdyDomFmat;
typedef __GlintdCdyDomFmat __GlintdBdyDomFmat;
typedef __GlintdCdyDomFmat __GlintdAdyDomFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Alpha:  8;
  unsigned32 Blue:   8;
  unsigned32 Green:  8;
  unsigned32 Red:    8;
} __GlintColorFmat_s;
#else
typedef struct {
  unsigned32 Red:    8;
  unsigned32 Green:  8;
  unsigned32 Blue:   8;
  unsigned32 Alpha:  8;
} __GlintColorFmat_s;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:         20;
  unsigned32 Reference:    8;
  unsigned32 Compare:      3;
  unsigned32 UnitEnable:   1;
} __GlintAlphaTestModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:   1;
  unsigned32 Compare:      3;
  unsigned32 Reference:    8;
  unsigned32 pad:         20;
} __GlintAlphaTestModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:        12;
  unsigned32 GID:         4;
  unsigned32 FrameCount:  8;
  unsigned32 Stencil:     8;
} __GlintLBStencilFmat;
#else
typedef struct {
  unsigned32 Stencil:     8;
  unsigned32 FrameCount:  8;
  unsigned32 GID:         4;
  unsigned32 pad:        12;
} __GlintLBStencilFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:            12;
  unsigned32 WriteOverride:   1;
  unsigned32 DepthFCP:        1;
  unsigned32 StencilFCP:      1;
  unsigned32 FrameCount:      8;
  unsigned32 GID:             4;
  unsigned32 LBUpdateSource:  1;
  unsigned32 ForceLBUpdate:   1;
  unsigned32 CompareMode:     2;
  unsigned32 UnitEnable:      1;
} __GlintWindowFmat;
#else
typedef struct {
  unsigned32 UnitEnable:      1;
  unsigned32 CompareMode:     2;
  unsigned32 ForceLBUpdate:   1;
  unsigned32 LBUpdateSource:  1;
  unsigned32 GID:             4;
  unsigned32 FrameCount:      8;
  unsigned32 StencilFCP:      1;
  unsigned32 DepthFCP:        1;
  unsigned32 WriteOverride:   1;
  unsigned32 pad:            12;
} __GlintWindowFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 FastClearValue:  8;
  unsigned32 WriteMask:       8;
  unsigned32 CompareMask:     8;
  unsigned32 ReferenceValue:  8;
} __GlintStencilDataFmat;
#else
typedef struct {
  unsigned32 ReferenceValue:  8;
  unsigned32 CompareMask:     8;
  unsigned32 WriteMask:       8;
  unsigned32 FastClearValue:  8;
} __GlintStencilDataFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:            15;
  unsigned32 Width:           2;
  unsigned32 StencilSource:   2;
  unsigned32 CompareFunction: 3;
  unsigned32 SFail:           3;
  unsigned32 DPFail:          3;
  unsigned32 DPPass:          3;
  unsigned32 UnitEnable:      1;
} __GlintStencilModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:       1;
  unsigned32 DPPass:           3;
  unsigned32 DPFail:           3;
  unsigned32 SFail:            3;
  unsigned32 CompareFunction:  3;
  unsigned32 StencilSource:    2;
  unsigned32 Width:            2;
  unsigned32 pad:             15;
} __GlintStencilModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:      24; 
  unsigned32 Stencil:   8;  
} __GlintStencilFmat;
#else
typedef struct {
  unsigned32 Stencil:   8;  
  unsigned32 pad:      24; 
} __GlintStencilFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:            25;
  unsigned32 CompareMode:     3;
  unsigned32 NewDepthSource:  2;
  unsigned32 WriteMask:       1;
  unsigned32 UnitEnable:      1;
} __GlintDepthModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:      1;
  unsigned32 WriteMask:       1;
  unsigned32 NewDepthSource:  2;
  unsigned32 CompareMode:     3;
  unsigned32 pad:            25;
} __GlintDepthModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:            29;
  unsigned32 UpLoadData:      2;
  unsigned32 WriteEnable:     1;
} __GlintLBWriteModeFmat;
#else
typedef struct {
  unsigned32 WriteEnable:     1;
  unsigned32 UpLoadData:      2;
  unsigned32 pad:            29;
} __GlintLBWriteModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                  7;
  unsigned32 PatchCode:             3;
  unsigned32 ScanlineInterval:      2;
  unsigned32 Patch:                 1;
  unsigned32 WindowOrigin:          1;
  unsigned32 DataType:              2;
  unsigned32 spare:                 5;
  unsigned32 ReadDestinationEnable: 1;
  unsigned32 ReadSourceEnable:      1;
  unsigned32 PP2:                   3;
  unsigned32 PP1:                   3;
  unsigned32 PP0:                   3;
} __GlintLBReadModeFmat;
#else
typedef struct {
  unsigned32 PP0:                   3;
  unsigned32 PP1:                   3;
  unsigned32 PP2:                   3;
  unsigned32 ReadSourceEnable:      1;
  unsigned32 ReadDestinationEnable: 1;
  unsigned32 spare:                 5;
  unsigned32 DataType:              2;
  unsigned32 WindowOrigin:          1;
  unsigned32 Patch:                 1;
  unsigned32 ScanlineInterval:      2;
  unsigned32 PatchCode:             3;
  unsigned32 pad0:                  7;
} __GlintLBReadModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                 14;
  unsigned32 Compact32:            1;
  unsigned32 GIDPosition:          4;
  unsigned32 GIDWidth:             1;
  unsigned32 FrameCountPosition:   3;
  unsigned32 FrameCountWidth:      2;
  unsigned32 StencilPosition:      3;
  unsigned32 StencilWidth:         2;
  unsigned32 DepthWidth:           2;
} __GlintLBFormatFmat;
#else
typedef struct {
  unsigned32 DepthWidth:           2;
  unsigned32 StencilWidth:         2;
  unsigned32 StencilPosition:      3;
  unsigned32 FrameCountWidth:      2;
  unsigned32 FrameCountPosition:   3;
  unsigned32 GIDWidth:             1;
  unsigned32 GIDPosition:          4;
  unsigned32 Compact32:            1;
  unsigned32 pad:                 14;
} __GlintLBFormatFmat;
#endif

typedef __GlintLBFormatFmat __GlintLBReadFormatFmat;
typedef __GlintLBFormatFmat __GlintLBWriteFormatFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:                  5;
  unsigned32 PatchMode:             2;
  unsigned32 ScanlineInterval:      2;
  signed32 RelativeOffset:          3;
  unsigned32 PackedData:            1;
  unsigned32 PatchEnable:           1;
  unsigned32 TexelInhibit:          1;
  unsigned32 WindowOrigin:          1;
  unsigned32 DataType:              1;
  unsigned32 pad0:                  4;
  unsigned32 ReadDestinationEnable: 1;
  unsigned32 ReadSourceEnable:      1;
  unsigned32 PP2:                   3;
  unsigned32 PP1:                   3;
  unsigned32 PP0:                   3;
} __GlintFBReadModeFmat;
#else
typedef struct {
  unsigned32 PP0:                   3;
  unsigned32 PP1:                   3;
  unsigned32 PP2:                   3;
  unsigned32 ReadSourceEnable:      1;
  unsigned32 ReadDestinationEnable: 1;
  unsigned32 pad0:                  4;
  unsigned32 DataType:              1;
  unsigned32 WindowOrigin:          1;
  unsigned32 TexelInhibit:          1;
  unsigned32 PatchEnable:           1;
  unsigned32 PackedData:            1;
  signed32 RelativeOffset:          3;
  unsigned32 ScanlineInterval:      2;
  unsigned32 PatchMode:             2;
  unsigned32 pad2:                  5;
} __GlintFBReadModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:        28;
  unsigned32 UpLoadData:   1;
  unsigned32 BlockWidth:   2; /* BACKWARDS COMPATABILITY */
  unsigned32 UnitEnable:   1;
} __GlintFBWriteModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:   1;
  unsigned32 BlockWidth:   2; /* BACKWARDS COMPATABILITY */
  unsigned32 UpLoadData:   1;
  unsigned32 pad1:        28;
} __GlintFBWriteModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:         30;
  unsigned32 ColorMode:    1;
  unsigned32 UnitEnable:   1;
} __GlintAntialiasModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:   1;
  unsigned32 ColorMode:    1;
  unsigned32 pad:         30;
} __GlintAntialiasModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                   15;
  unsigned32 ColorFormatExtension:  1;
  unsigned32 AlphaDst:          1;
  unsigned32 BlendType:         1;
  unsigned32 ColorOrder:        1;
  unsigned32 NoAlphaBuffer:     1;
  unsigned32 ColorFormat:       4;
  unsigned32 DestinationBlend:  3;
  unsigned32 SourceBlend:       4;
  unsigned32 UnitEnable:        1;
} __PermediaAlphaBlendModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:        1;
  unsigned32 SourceBlend:       4;
  unsigned32 DestinationBlend:  3;
  unsigned32 ColorFormat:       4;
  unsigned32 NoAlphaBuffer:     1;
  unsigned32 ColorOrder:        1;
  unsigned32 BlendType:         1;
  unsigned32 AlphaDst:          1;
  unsigned32 ColorFormatExtension:  1;
  unsigned32 pad:                   15;
} __PermediaAlphaBlendModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:               14;
  unsigned32 AlphaConversion:   1;
  unsigned32 ColorConversion:   1;
  unsigned32 AlphaDst:          1;
  unsigned32 BlendType:         1;
  unsigned32 ColorOrder:        1;
  unsigned32 NoAlphaBuffer:     1;
  unsigned32 ColorFormat:       4;
  unsigned32 DestinationBlend:  3;
  unsigned32 SourceBlend:       4;
  unsigned32 UnitEnable:        1;
} __GlintAlphaBlendModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:        1;
  unsigned32 SourceBlend:       4;
  unsigned32 DestinationBlend:  3;
  unsigned32 ColorFormat:       4;
  unsigned32 NoAlphaBuffer:     1;
  unsigned32 ColorOrder:        1;
  unsigned32 BlendType:         1;
  unsigned32 AlphaDst:          1;
  unsigned32 ColorConversion:   1;
  unsigned32 AlphaConversion:   1;
  unsigned32 pad:               14;
} __GlintAlphaBlendModeFmat;
#endif


#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                  15;
  unsigned32 ColorFormatExtension:  1;
  unsigned32 RoundingMode:    1;
  unsigned32 AlphaDither:     1;
  unsigned32 ForceAlpha:            2;
  unsigned32 DitherMethod:          1;
  unsigned32 ColorOrder:      1;
  unsigned32 YOffset:         2;
  unsigned32 XOffset:         2;
  unsigned32 ColorFormat:     4;
  unsigned32 DitherEnable:    1;
  unsigned32 UnitEnable:      1;
} __GlintDitherModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:      1;
  unsigned32 DitherEnable:    1;
  unsigned32 ColorFormat:     4;
  unsigned32 XOffset:         2;
  unsigned32 YOffset:         2;
  unsigned32 ColorOrder:      1;
  unsigned32 DitherMethod:          1;
  unsigned32 ForceAlpha:            2;
  unsigned32 AlphaDither:     1;
  unsigned32 RoundingMode:    1;
  unsigned32 ColorFormatExtension:  1;
  unsigned32 pad0:                  15;
} __GlintDitherModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                    26;
  unsigned32 UseConstantFBWriteData:  1;
  unsigned32 LogicalOp:               4;
  unsigned32 LogicalOpEnable:         1;
} __GlintLogicalOpModeFmat;
#else
typedef struct {
  unsigned32 LogicalOpEnable:         1;
  unsigned32 LogicalOp:               4;
  unsigned32 UseConstantFBWriteData:  1;
  unsigned32 pad:                    26;
} __GlintLogicalOpModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:            10;
  unsigned32 ExternalDMA :    1;
  unsigned32 RLEHostOut:      1;
  unsigned32 Context:         2;
  unsigned32 ByteSwapMode:    2;
  unsigned32 Remainder:       2;
  unsigned32 Statistics:      2;
  unsigned32 Synchronization: 2;
  unsigned32 Color:           2;
  unsigned32 Stencil :        2;
  unsigned32 Depth:           2;
  unsigned32 Passive:         2;
  unsigned32 Active:          2;
} __GlintFilterModeFmat;
#else
typedef struct {
  unsigned32 Active:          2;
  unsigned32 Passive:         2;
  unsigned32 Depth:           2;
  unsigned32 Stencil :        2;
  unsigned32 Color:           2;
  unsigned32 Synchronization: 2;
  unsigned32 Statistics:      2;
  unsigned32 Remainder:       2;
  unsigned32 ByteSwapMode:    2;
  unsigned32 Context:         2;
  unsigned32 RLEHostOut:      1;
  unsigned32 ExternalDMA :    1;
  unsigned32 pad:            10;
} __GlintFilterModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:              26;
  unsigned32 Spans:             1;
  unsigned32 CompareFunction:   1;
  unsigned32 PassiveSteps:      1;
  unsigned32 ActiveSteps:       1;
  unsigned32 StatType:          1;
  unsigned32 Enable:            1;
} __GlintStatisticModeFmat;
#else
typedef struct {
  unsigned32 Enable:            1;
  unsigned32 StatType:          1;
  unsigned32 ActiveSteps:       1;
  unsigned32 PassiveSteps:      1;
  unsigned32 CompareFunction:   1;
  unsigned32 Spans:             1;
  unsigned32 pad:              26;
} __GlintStatisticModeFmat;
#endif

typedef __GlintXYFmat __GlintMinRegionFmat;
typedef __GlintXYFmat __GlintMaxRegionFmat;
typedef __GlintXYFmat __GlintMinHitRegionFmat;
typedef __GlintXYFmat __GlintMaxHitRegionFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 InterruptEnable: 1;
  unsigned32 pad:            31;
} __GlintSyncFmat;
#else
typedef struct {
  unsigned32 pad:            31;
  unsigned32 InterruptEnable: 1;
} __GlintSyncFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Count:      16;
  unsigned32 Mode:        2;
  unsigned32 unused:      4;
  unsigned32 Context:     1;
  unsigned32 MajorGroup:  5;
  unsigned32 Offset:      4;
} __GlintDMATag;
#else
typedef struct {
  unsigned32 Offset:      4;
  unsigned32 MajorGroup:  5;
  unsigned32 Context:     1;
  unsigned32 unused:      4;
  unsigned32 Mode:        2;
  unsigned32 Count:      16;
} __GlintDMATag;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:             20;
  unsigned32 ColorLoadMode:       2;
  unsigned32 BaseFormat:       3;
  unsigned32 KsDDA:            1;
  unsigned32 KdDDA:            1;
  unsigned32 TextureType:      1;
  unsigned32 ApplicationMode:  3;
  unsigned32 UnitEnable:       1;
} __GlintTextureColorModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:       1;
  unsigned32 ApplicationMode:  3;
  unsigned32 TextureType:      1;
  unsigned32 KdDDA:            1;
  unsigned32 KsDDA:            1;
  unsigned32 BaseFormat:       3;
  unsigned32 ColorLoadMode:       2;
  unsigned32 pad:             20;
} __GlintTextureColorModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:             28;
  unsigned32 Sense:               1;
  unsigned32 Source:           2;
  unsigned32 UnitEnable:       1;
} __GlintChromaTestModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:        1;
  unsigned32 Source:            2;
  unsigned32 Sense:             1;
  unsigned32 pad:               25;
} __GlintChromaTestModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:      29;
  unsigned32 Filter:    3;
} __GlintTextureFilterFmat;
#else
typedef struct {
  unsigned32 Filter:    3;
  unsigned32 pad:      29;
} __GlintTextureFilterFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Alpha:   8;
  unsigned32 Blue:    8;
  unsigned32 Green:   8;
  unsigned32 Red:     8;
} __GlintTexelFmat;
#else
typedef struct {
  unsigned32 Red:     8;
  unsigned32 Green:   8;
  unsigned32 Blue:    8;
  unsigned32 Alpha:   8;
} __GlintTexelFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:         30;
  unsigned32 ColorMode:    1;
  unsigned32 UnitEnable:   1;
} __GlintFogModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:   1;
  unsigned32 ColorMode:    1;
  unsigned32 pad:         30;
} __GlintFogModeFmat;
#endif



#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:             14;
  unsigned32 TextureMapType:   1;
  unsigned32 Height:           4;
  unsigned32 Width:               4;
  unsigned32 EnableDY:           1;
  unsigned32 EnableLOD:        1;
  unsigned32 InhibitDDA:       1;
  unsigned32 Mode:             1;
  unsigned32 TWrap:            2; 
  unsigned32 SWrap:            2; 
  unsigned32 UnitEnable:       1; 
} __GlintTextureAddressModeFmat;
#else 
typedef struct { 
  unsigned32 UnitEnable:       1; 
  unsigned32 SWrap:            2; 
  unsigned32 TWrap:            2; 
  unsigned32 Mode:             1;
  unsigned32 InhibitDDA:       1;
  unsigned32 EnableLOD:           1;
  unsigned32 EnableDY:           1;
  unsigned32 Width:               4;
  unsigned32 Height:           4;
  unsigned32 TextureMapType:   1;
  unsigned32 pad:             14;
} __GlintTextureAddressModeFmat;
#endif

typedef signed32 __GlintSStartFmat;
typedef signed32 __GlintTStartFmat;
typedef signed32 __GlintQStartFmat;
typedef signed32 __GlintdSdxFmat;
typedef signed32 __GlintdTdxFmat;
typedef signed32 __GlintdQdxFmat;
typedef signed32 __GlintdSdyDomFmat;
typedef signed32 __GlintdTdyDomFmat;
typedef signed32 __GlintdQdyDomFmat;


#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:             12;
  unsigned32 U:                20;
} __GlintTexelCoordUFmat;
#else
typedef struct {
  unsigned32 U:                20;
  unsigned32 pad0:             12;
} __GlintTexelCoordUFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:             12;
  unsigned32 V:                20;
} __GlintTexelCoordVFmat;
#else
typedef struct {
  unsigned32 V:                20;
  unsigned32 pad0:             12;
} __GlintTexelCoordVFmat;
#endif


#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           4;
  unsigned32 BorderClamp:     1;
  unsigned32 FBSourceAddr:     2;
  unsigned32 PrimaryCache:     1;
  unsigned32 MipMap:         1;
  unsigned32 Mode:           1;
  unsigned32 VWrap:          2;
  unsigned32 UWrap:          2;
  unsigned32 MinFilter:      3;
  unsigned32 MagFilter:      1;
  unsigned32 Patch:          1;
  unsigned32 Border:         1;
  unsigned32 Depth:          3;
  unsigned32 Height:         4;
  unsigned32 Width:          4;
  unsigned32 UnitEnable:     1;
} __GlintTextureReadModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:     1;
  unsigned32 Width:          4;
  unsigned32 Height:         4;
  unsigned32 Depth:          3;
  unsigned32 Border:         1;
  unsigned32 Patch:          1;
  unsigned32 MagFilter:      1;
  unsigned32 MinFilter:      3;
  unsigned32 UWrap:          2;
  unsigned32 VWrap:          2;
  unsigned32 Mode:           1;
  unsigned32 MipMap:         1;
  unsigned32 PrimaryCache:     1;
  unsigned32 FBSourceAddr:     2;
  unsigned32 BorderClamp:     1;
  unsigned32 pad0:           4;
} __GlintTextureReadModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Pad0:             29;
  unsigned32 AlphaMapSense:  1;
  unsigned32 AlphaMapEnable: 1;
  unsigned32 UnitEnable:     1;
} __GlintTextureFilterModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:     1;
  unsigned32 AlphaMapEnable: 1;
  unsigned32 AlphaMapSense:  1;
  unsigned32 Pad0:             29;
} __GlintTextureFilterModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           12;
  unsigned32 OneCompFormat:      2;
  unsigned32 LUTOffset:          8;
  unsigned32 ByteSwapBitMask: 1;
  unsigned32 InvertBitMask:   1;
  unsigned32 MirrorBitMask:   1;
  unsigned32 OutputFormat:    2;
  unsigned32 NumberComps:     2;
  unsigned32 ColorOrder:      1;
  unsigned32 Format:          1;
  unsigned32 Endian:          1;
} __GlintTextureFormatFmat;
#else
typedef struct {
  unsigned32 Endian:          1;
  unsigned32 Format:          1;
  unsigned32 ColorOrder:      1;
  unsigned32 NumberComps:     2;
  unsigned32 OutputFormat:    2;
  unsigned32 MirrorBitMask:   1;
  unsigned32 InvertBitMask:   1;
  unsigned32 ByteSwapBitMask: 1;
  unsigned32 LUTOffset:          8;
  unsigned32 OneCompFormat:      2;
  unsigned32 pad0:           12;
} __GlintTextureFormatFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:          3;
  unsigned32 Addr:        29;
} __GlintTextureAddressFmat;
#else
typedef struct {
  unsigned32 Addr:        29;
  unsigned32 pad:          3;
} __GlintTextureAddressFmat;
#endif

typedef __GlintTextureAddressFmat __GlintTextureBaseAddressFmat;
typedef __GlintTextureAddressFmat __GlintTextureBaseAddressLRFmat;
typedef __GlintTexelFmat __GlintTexelLUTFmat;
typedef __GlintTexelFmat __GlintBorderColorFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:              5;
  unsigned32 Blue:             9;
  unsigned32 Green:            9;
  unsigned32 Red:              9;
} __GlintTextureKFmat;
#else
typedef struct {
  unsigned32 Red:              9;
  unsigned32 Green:            9;
  unsigned32 Blue:             9;
  unsigned32 pad:              5;
} __GlintTextureKFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         2;
  unsigned32 Fraction:     22;
} __GlintKStartFmat;
#else
typedef struct {
  unsigned32 Fraction:     22;
  signed32 Integer:         2;
  unsigned32 pad2:          8;
} __GlintKStartFmat;
#endif

typedef __GlintKStartFmat __GlintKsStartFmat;
typedef __GlintKStartFmat __GlintKdStartFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         2;
  unsigned32 Fraction:     22;
} __GlintdKdxFmat;
#else
typedef struct {
  unsigned32 Fraction:     22;
  signed32 Integer:         2;
  unsigned32 pad2:          8;
} __GlintdKdxFmat;
#endif

typedef __GlintdKdxFmat __GlintdKsdxFmat;
typedef __GlintdKdxFmat __GlintdKddxFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         2;
  unsigned32 Fraction:     22;
} __GlintdKdyDomFmat;
#else
typedef struct {
  unsigned32 Fraction:     22;
  signed32 Integer:         2;
  unsigned32 pad2:          8;
} __GlintdKdyDomFmat;
#endif

typedef __GlintdKdyDomFmat __GlintdKsdyDomFmat;
typedef __GlintdKdyDomFmat __GlintdKddyDomFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:              30;
  unsigned32 Mode:              1;
  unsigned32 Invalidate:        1;
} __GlintTextureCacheControlFmat;
#else
typedef struct {
  unsigned32 Invalidate:        1;
  unsigned32 Mode:              1;
  unsigned32 pad:              30;
} __GlintTextureCacheControlFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:              18;
  unsigned32 XMask:             5;
  unsigned32 YShift:            3;
  unsigned32 YMask:             5;
  unsigned32 PatternEnable:     1;
} __GlintPatternRAMModeFmat;
#else
typedef struct {
  unsigned32 PatternEnable:     1;
  unsigned32 YMask:             5;
  unsigned32 YShift:            3;
  unsigned32 XMask:             5;
  unsigned32 pad:              18;
} __GlintPatternRAMModeFmat;
#endif

typedef __GlintUnsignedIntFmat __GlintPatternRAMDataFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:              30;
  unsigned32 Size:              2;
} __GlintPixelSizeFmat;
#else
typedef struct {
  unsigned32 Size:              2;
  unsigned32 pad:              30;
} __GlintPixelSizeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                27;
  unsigned32 Scanline:            3;
  unsigned32 ScanlineInterval:    2;
} __GlintScanlineOwnershipFmat;
#else
typedef struct {
  unsigned32 ScanlineInterval:    2;
  unsigned32 Scanline:            3;
  unsigned32 pad:                27;
} __GlintScanlineOwnershipFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  signed32 YMax:                 16;
  signed32 YMin:                 16;
} __GlintYLimitsFmat;
#else
typedef struct {
  signed32 YMin:                 16;
  signed32 YMax:                 16;
} __GlintYLimitsFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  signed32 XMax:                 16;
  signed32 XMin:                 16;
} __GlintXLimitsFmat;
#else
typedef struct {
  signed32 XMin:                 16;
  signed32 XMax:                 16;
} __GlintXLimitsFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                 8;
  unsigned32 Offset:             24;
} __GlintTextureDownloadOffsetFmat;
#else
typedef struct {
  unsigned32 Offset:             24;
  unsigned32 pad:                 8;
} __GlintTextureDownloadOffsetFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned int TargetChip:                2;
  unsigned int DepthFormat:               2;
  unsigned int FogEnable:                 1;
  unsigned int TextureEnable:             1;
  unsigned int SmoothShadingEnable:       1;
  unsigned int DepthEnable:               1;
  unsigned int SpecularTextureEnable:     1;
  unsigned int DiffuseTextureEnable:      1;
  unsigned int SubPixelCorrectionEnable:  1;
  unsigned int DiamondExit:               1;
  unsigned int NoDraw:                    1;
  unsigned int ClampEnable:               1;
  unsigned int TextureParameterMode:      2;
  unsigned int FillDirection:             1;
  unsigned int pad:                      15;
} __GambitDeltaModeFmat;

#else

typedef struct {
  unsigned int TargetChip:                2;
  unsigned int DepthFormat:               2;
  unsigned int FogEnable:                 1;
  unsigned int TextureEnable:             1;
  unsigned int SmoothShadingEnable:       1;
  unsigned int DepthEnable:               1;
  unsigned int SpecularTextureEnable:     1;
  unsigned int DiffuseTextureEnable:      1;
  unsigned int SubPixelCorrectionEnable:  1;
  unsigned int DiamondExit:               1;
  unsigned int NoDraw:                    1;
  unsigned int ClampEnable:               1;
  unsigned int TextureParameterMode:      2;
  unsigned int FillDirection:             1;
  unsigned int pad:                      15;
} __GambitDeltaModeFmat;

#endif
typedef unsigned32 __GlintTextureDataFmat;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\debug.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           *   SAMPLE CODE   *
*                           *******************
*
* Module Name: debug.h
*
* Content: Debugging support macros and structures
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef __DEBUG_H
#define __DEBUG_H

//-----------------------------------------------------------------------------
//
// **************************** DISPDBG LEVELS ********************************
//
//-----------------------------------------------------------------------------

// Global warning levels. We can easily modify any source file to dump all of
// its debug messages by undef'ing and redefining this symbols.
#define DBGLVL 4
#define WRNLVL 2
#define ERRLVL 0

//-----------------------------------------------------------------------------
//
// ************************* DEBUG SUPPORT SWITCHES **************************
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
//                      FUNCTION ENTRY/EXIT TRACKING
//
// In order to activate function entry/exit tracking , you need to define 
// DBG_TRACK_FUNCS to 1, and (unfortunately) instrument your code so that it
// uses DBG_ENTRY and DBG_EXIT right after entry and right before exit from
// the functions you are interested in.
//
// DBG_EXIT can also be supplied a DWORD result which can be tracked in order
// to know the result of different calls (but the mechanism already tracks 
// function returns happening in different lines of code for you).
//
// After gathering results, Debug_Func_Report_And_Reset has to be called in 
// order to dump them into the remote debugger output. This is done in this 
// sample driver within the DrvEscape GDI callback and using the dispdbg.exe 
// program to send the right escape codes. You can modify this to suit your
// needs.
//
// After Debug_Func_Report_And_Reset is done reporting results, it will reset 
// all of its counters in order to retstart another cycle.
//
// Be aware that DEBUG_MAX_FUNC_COUNT and DEBUG_MAX_RETVALS govern how many
// function calls and function return results can be stored as a maximum. They
// may be adjusted too to suit your own needs. Any data that doesn't fit
// within those maximums will be thrown away.
//
//-----------------------------------------------------------------------------
#define DBG_TRACK_FUNCS 0

//-----------------------------------------------------------------------------
//
//                          CODE COVERAGE TRACKING
//
// In order to do code coverage tracking, you need to define DBG_TRACK_CODE to 1
// NO CODE INSTRUMENTATION IS NECESSARY!. This will track all if and while
// statements executed in the code and which branch (TRUE or FALSE) was taken,
// and how many times it was taken.
//
// Be aware that the below defined DBG_TRACK_CODE is just a default for all 
// files that include debug.h. If you want to exclude (or include) a file
// manually, you can define DBG_TRACK_CODE inside it just before including
// debug.h . You cannot activate/deactivate code tracking for individual
// functions or sections of code, just on a per-file basis.
//
// After gathering results, Debug_Code_Report_And_Reset has to be called in 
// order to dump them into the remote debugger output. This is done in this 
// sample driver within the DrvEscape GDI callback and using the dispdbg.exe 
// program to send the right escape codes. You can modify this to suit your
// needs.
//
// After Debug_Code_Report_And_Reset is done reporting results, it will reset 
// all of its counters in order to retstart another cycle.
//
// If DBG_TRACK_CODE_REPORT_PROBLEMS_ONLY is set to 1, only branch statements
// that are potential trouble makers (like if branches that might have been
// never taken or while bodies never entered into) will be reported. If set to
// 0, all gathered data will be dumped (this is quite a lot of data!)
//
// Be aware that DEBUG_MAX_CODE_COUNT governs how many statements (branches)
// can be stored as a maximum. It may be adjusted too to suit your own needs. 
// Any data that doesn't fit within the maximum will be thrown away.
//
//-----------------------------------------------------------------------------
#ifndef DBG_TRACK_CODE
#define DBG_TRACK_CODE  0
#define DBG_DEFAULT_TRACK_CODE DBG_TRACK_CODE
#endif

#if (DBG_DEFAULT_TRACK_CODE == DBG_TRACK_CODE)
#define DBG_TRACK_CODE_NON_DEFAULT 0
#else
// some source file is already using non-default code tracking!
#define DBG_TRACK_CODE_NON_DEFAULT 1
#endif

#define DBG_TRACK_CODE_REPORT_PROBLEMS_ONLY 0

//-----------------------------------------------------------------------------
// Escapes for reporting debugging results through 
// the remote debugger using dbgdisp.exe
//-----------------------------------------------------------------------------
#define ESCAPE_TRACK_FUNCTION_COVERAGE  1100
#define ESCAPE_TRACK_CODE_COVERAGE      1101
#define ESCAPE_TRACK_MEMORY_ALLOCATION  1102

//-----------------------------------------------------------------------------
//
// ****************** FUNCTION COVERAGE DEBUGGING SUPPORT ********************
//
//-----------------------------------------------------------------------------
#if (DBG_TRACK_FUNCS && DBG)
VOID Debug_Func_Entry(VOID *pFuncAddr,
                      char *pszFuncName, 
                      DWORD dwLine , 
                      char *pszFileName); 
                      
VOID Debug_Func_Exit(VOID *pFuncAddr,
                     DWORD dwRetVal,                       
                     DWORD dwLine);

VOID Debug_Func_Report_And_Reset(void);

            
#define DBG_ENTRY(pszFuncName)                      \
            Debug_Func_Entry((VOID *)pszFuncName,   \
                                    #pszFuncName,   \
                                    __LINE__ ,      \
                                    __FILE__ )
                                    
#define DBG_EXIT(pszFuncName,dwRetVal)              \
            Debug_Func_Exit((VOID *)pszFuncName,    \
                                   dwRetVal,        \
                                   __LINE__)
                                                                      
#define DBG_CB_ENTRY   DBG_ENTRY
#define DBG_CB_EXIT    DBG_EXIT
#else // DBG_TRACK_FUNCS
#define Debug_Func_Report_And_Reset()

#define DBG_ENTRY(pszFuncName)                                        \
        DISPDBG((DBGLVL,"Entering %s",#pszFuncName))
#define DBG_EXIT(pszFuncName,dwRetVal)                                \
        DISPDBG((DBGLVL,"Exiting  %s dwRetVal = %d",#pszFuncName,dwRetVal))

#define DBG_CB_ENTRY   DBG_ENTRY
#define DBG_CB_EXIT    DBG_EXIT

#endif // DBG_TRACK_FUNCS

//-----------------------------------------------------------------------------
//
// ******************** STATEMENT COVERAGE DEBUGGING SUPPORT ******************
//
//-----------------------------------------------------------------------------

#if (DBG_TRACK_CODE && _X86_ && DBG)

// Never change these values!
#define DBG_IF_CODE     1
#define DBG_WHILE_CODE  2
#define DBG_SWITCH_CODE 3
#define DBG_FOR_CODE    4

BOOL 
Debug_Code_Coverage(
    DWORD dwCodeType, 
    DWORD dwLine , 
    char *pszFileName,
    BOOL bCodeResult);

VOID Debug_Code_Report_And_Reset(void);

#define if(b) \
        if(Debug_Code_Coverage(DBG_IF_CODE,__LINE__,__FILE__,(BOOL)(b)))
#define while(b) \
        while(Debug_Code_Coverage(DBG_WHILE_CODE,__LINE__,__FILE__,(BOOL)(b)))
#define switch(val) \
        switch(Debug_Code_Coverage(DBG_SWITCH_CODE,__LINE__,__FILE__,(val)))

#endif // DBG_TRACK_CODE && _X86_

#if ((DBG_TRACK_CODE || DBG_TRACK_CODE_NON_DEFAULT) && _X86_ && DBG)
VOID Debug_Code_Report_And_Reset(void);
#else
#define Debug_Code_Report_And_Reset()
#endif

//-----------------------------------------------------------------------------
//
// ************************ MEMORY ALLOCATION SUPPORT *************************
//
//-----------------------------------------------------------------------------

#define ENGALLOCMEM(Flags, Size, Tag)  EngAllocMem(Flags, Size, Tag)
#define ENGFREEMEM(Pointer)            EngFreeMem(Pointer)


//-----------------------------------------------------------------------------
//
//  ******************** PUBLIC DATA STRUCTURE DUMPING ************************
//
//-----------------------------------------------------------------------------

extern char *pcSimpleCapsString(DWORD dwCaps);

#if DBG && defined(LPDDRAWI_DDRAWSURFACE_LCL)

extern void DumpD3DBlend(int Level, DWORD i );
extern void DumpD3DMatrix(int Level, D3DMATRIX* pMatrix);
extern void DumpD3DMaterial(int Level, D3DMATERIAL7* pMaterial);
extern void DumpD3DLight(int DebugLevel, D3DLIGHT7* pLight);
extern void DumpDDSurface(int Level, LPDDRAWI_DDRAWSURFACE_LCL lpDDSurface);
extern void DumpDDSurfaceDesc(int DebugLevel, DDSURFACEDESC* pDesc);
extern void DumpDP2Flags( DWORD lvl, DWORD flags );

#define DBGDUMP_DDRAWSURFACE_LCL(a, b) DumpDDSurface(a, b);
#define DBGDUMP_DDSURFACEDESC(a, b)    DumpDDSurfaceDesc(a, b); 
#define DBGDUMP_D3DMATRIX(a, b)        DumpD3DMatrix(a, b);
#define DBGDUMP_D3DMATERIAL7(a, b)     DumpD3DMaterial(a, b);
#define DBGDUMP_D3DLIGHT7(a, b)        DumpD3DLight(a, b);
#define DBGDUMP_D3DBLEND(a, b)         DumpD3DBlend(a, b);
#define DBGDUMP_D3DDP2FLAGS(a, b)      DumpDP2Flags(a, b)

// If we are not in a debug environment, we want all of the debug
// information to be stripped out.

#else  // DBG

#define DBGDUMP_DDRAWSURFACE_LCL(a, b)
#define DBGDUMP_D3DMATRIX(a, b)
#define DBGDUMP_D3DMATERIAL7(a, b)
#define DBGDUMP_D3DLIGHT7(a, b)
#define DBGDUMP_DDSURFACEDESC(a, b)
#define DBGDUMP_D3DBLEND(a, b)
#define DBGDUMP_D3DDP2FLAGS(a, b)   

#endif // DBG

//-----------------------------------------------------------------------------
//
//  ********************** LOW LEVEL DEBUGGING SUPPORT ************************
//
//-----------------------------------------------------------------------------
#if DBG

extern LONG  P3R3DX_DebugLevel;

#ifdef WNT_DDRAW
extern VOID __cdecl DebugPrintNT(LONG DebugPrintLevel, PCHAR DebugMessage, ...);
#define DebugPrint DebugPrintNT
#else
extern VOID __cdecl DebugPrint(LONG DebugPrintLevel, PCHAR DebugMessage, ...);
#endif // WNT_DDRAW

#define DISPDBG(arg) DebugPrint arg

#if WNT_DDRAW
#define DebugRIP    EngDebugBreak
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}
#else
extern VOID DebugRIP();
#ifdef FULLDEBUG
// Use an int1 per ASSERT, so that we can zap them individually.
#define RIP(x) { DebugPrint(-1000, x); _asm int 1 }
#else
// If only on DEBUG, we don't want to break compiler optimisations.
#define RIP(x) { DebugPrint(-1000, x); DebugRIP();}
#endif // FULLDEBUG
#endif // WNT_DDRAW

#define ASSERTDD(x, y) if (0 == (x))  RIP (y) 

#define ASSERTDBG(x, y) do { if( !(x) ) { DebugPrint y; DebugBreak(); }; } while(0)

// If we are not in a debug environment, we want all of the debug
// information to be stripped out.

#else  // DBG

#define DISPDBG(arg)
#define RIP(x)
#define ASSERTDD(x, y)
#define ASSERTDBG(x, y) do { ; } while(0)

#endif // DBG

// Makes a label that is only there in the debug build -
// very useful for putting instant named breakpoints at.
#if DBG
#define MAKE_DEBUG_LABEL(label_name)                                \
{                                                                   \
    goto label_name;                                                \
    label_name:                                                     \
    ;                                                               \
}
#else
#define MAKE_DEBUG_LABEL(label_name) NULL
#endif

//-----------------------------------------------------------------------------
//
//  ****************** HARDWARE DEPENDENT DEBUGGING SUPPORT *******************
//
//-----------------------------------------------------------------------------

#if DBG

extern BOOL g_bDetectedFIFOError;
extern BOOL CheckFIFOEntries(DWORD a);
extern void ColorArea(ULONG_PTR pBuffer, DWORD dwWidth, DWORD dwHeight, 
                      DWORD dwPitch, int iBitDepth, DWORD dwValue);
extern void CheckChipErrorFlags();
#ifndef WNT_DDRAW
typedef void *GlintDataPtr;
#endif
extern const char *getTagString(GlintDataPtr glintInfo,ULONG tag);
const char *p3r3TagString( ULONG tag );

#define CHECK_ERROR()   CheckChipErrorFlags()
#define COLORAREA(a, b, c, d, e, f) ColorArea(a, b, c, d, e, f);
#define CHECK_FIFO(a)                                    \
    if (CheckFIFOEntries(a))                             \
    {                                                    \
        DISPDBG((ERRLVL,"Out of FIFO/DMA space %s: %d",  \
                    __FILE__, __LINE__));                \
        DebugRIP();                                      \
    }
#define GET_TAG_STR(tag)    getTagString(glintInfo, tag)

// If we are not in a debug environment, we want all of the debug
// information to be stripped out.

#else  // DBG

#define CHECK_ERROR()
#define COLORAREA(a,b,c,d,e,f)
#define CHECK_FIFO(a)
#define GET_TAG_STR(tag)

#endif // DBG

#endif // __DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\bitmac2.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: bitmac2.h
*
* Content: Permedia3 macros to set bits in hw registers
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// The macros in this file are used from the 2D side to correctly shift values
// into the correct place in the register.  The values passed to these macros
// are in glintdef.h and pmdef.h, and p3rxdef.h

#ifndef __BITMAC2
#define __BITMAC2

// *******************************************************************
// Permedia Bit Field Macros

// FBReadMode 
#define PM_FBREADMODE_PARTIAL(a)                            (a << 0)
#define PM_FBREADMODE_READSOURCE(a)                         (a << 9)
#define PM_FBREADMODE_READDEST(a)                           (a << 10)
#define PM_FBREADMODE_DATATYPE(a)                           (a << 15)
#define PM_FBREADMODE_WINDOWORIGIN(a)                       (a << 16)
#define PM_FBREADMODE_TEXELINHIBIT(a)                       (a << 17)
#define PM_FBREADMODE_PATCHENABLE(a)                        (a << 18)
#define PM_FBREADMODE_PACKEDDATA(a)                         (a << 19)
#define PM_FBREADMODE_RELATIVEOFFSET(a)                     (a << 20)
#define PM_FBREADMODE_SCANLINEINTERVAL(a)                   (a << 23)
#define PM_FBREADMODE_PARTIAL3(a)                           (a << 25)
#define PM_FBREADMODE_PATCHMODE(a)                          (a << 25)
#define PM_FBREADMODE_SOURCEADDRESS(a)                      (a << 28)

// FBWriteMode
#define PM_FBWRITEMODE_ENABLE(a)                            (a << 0)
#define PM_FBWRITEMODE_UPLOADDATA(a)                        (a << 3)

// Texture Address mode
#define PM_TEXADDRESSMODE_ENABLE(a)                         (a << 0)
#define PM_TEXADDRESSMODE_PERSPECTIVE(a)                    (a << 1)

// Texture read mode
#define PM_TEXREADMODE_ENABLE(a)                            (a << 0)
#define PM_TEXREADMODE_SWRAP(a)                             (a << 1)
#define PM_TEXREADMODE_TWRAP(a)                             (a << 3)
#define PM_TEXREADMODE_WIDTH(a)                             (a << 9)
#define PM_TEXREADMODE_HEIGHT(a)                            (a << 13)
#define PM_TEXREADMODE_FILTER(a)                            (a << 17)
#define PM_TEXREADMODE_PACKEDDATA(a)                        (a << 24)

// TextureColorMode
#define PM_TEXCOLORMODE_ENABLE(a)                           (a << 0)
#define PM_TEXCOLORMODE_APPLICATIONMODE(a)                  (a << 1)
#define PM_TEXCOLORMODE_TEXTURETYPE(a)                      (a << 4)
#define PM_TEXCOLORMODE_KDDDA(a)                            (a << 5)
#define PM_TEXCOLORMODE_KSDDA(a)                            (a << 6)

// TextureDataFormat
#define PM_TEXDATAFORMAT_FORMAT(a)                          (a << 0)
#define PM_TEXDATAFORMAT_NOALPHABUFFER(a)                   (a << 4)
#define PM_TEXDATAFORMAT_COLORORDER(a)                      (a << 5)
#define PM_TEXDATAFORMAT_FORMATEXTENSION(a)                 (a << 6)
#define PM_TEXDATAFORMAT_ALPHAMAP(a)                        (a << 7)
#define PM_TEXDATAFORMAT_SPANFORMAT(a)                      (a << 9)

// PackedDataLimits
#define PM_PACKEDDATALIMITS_OFFSET(a)                       (a << 29)
#define PM_PACKEDDATALIMITS_XSTART(a)                       (a << 0)
#define PM_PACKEDDATALIMITS_XEND(a)                         (a << 16)

// Window Register
#define PM_WINDOW_FORCELBUPDATE(a)                          (a << 3)
#define PM_WINDOW_LBUPDATESOURCE(a)                         (a << 4)
#define PM_WINDOW_DISABLELBUPDATE(a)                        (a << 18)

// Colors
#define PM_BYTE_COLOR(a)                                    (a << 15);

// VideoPort Registers

// Video Signal Config
#define PM_VSCONFIG_UNITMODE(a)                             ((a) << 0)
#define PM_VSCONFIG_GPMODE_A(a)                             ((a) << 3)
#define PM_VSCONFIG_ROMPULSE(a)                             ((a) << 4)
// Stream A
#define PM_VSCONFIG_HREF_POL_A(a)                           ((a) << 9)
#define PM_VSCONFIG_VREF_POL_A(a)                           ((a) << 10)
#define PM_VSCONFIG_VACTIVE_POLA(a)                         ((a) << 11)
#define PM_VSCONFIG_USEFIELD_A(a)                           ((a) << 12)
#define PM_VSCONFIG_FIELD_POL_A(a)                          ((a) << 13)
#define PM_VSCONFIG_FIELD_EDGE_A(a)                         ((a) << 14)
#define PM_VSCONFIG_VACTIVE_VBI_A(a)                        ((a) << 15)
#define PM_VSCONFIG_INTERLACE_A(a)                          ((a) << 16)
#define PM_VSCONFIG_REVERSEDATA_A(a)                        ((a) << 17)
// Stream B
#define PM_VSCONFIG_HREF_POL_B(a)                           ((a) << 18)
#define PM_VSCONFIG_VREF_POL_B(a)                           ((a) << 19)
#define PM_VSCONFIG_VACTIVE_POLB(a)                         ((a) << 20)
#define PM_VSCONFIG_USEFIELD_B(a)                           ((a) << 21)
#define PM_VSCONFIG_FIELD_POL_B(a)                          ((a) << 22)
#define PM_VSCONFIG_FIELD_EDGE_B(a)                         ((a) << 23)
#define PM_VSCONFIG_VACTIVE_VBI_B(a)                        ((a) << 24)
#define PM_VSCONFIG_INTERLACE_B(a)                          ((a) << 25)
#define PM_VSCONFIG_COLORSPACE_B(a)                         ((a) << 26)
#define PM_VSCONFIG_REVERSEDATA_B(a)                        ((a) << 27)
#define PM_VSCONFIG_DOUBLEEDGE_B(a)                         ((a) << 28)

// Video Signal Status
// Macros for getting individual states
#define PM_GET_VSSTATUS_GPBUSTIMEOUT(a)           ((a & (1 << 0)) >> 0)
#define PM_GET_VSSTATUS_FIFOOVERFLOW_A(a)         ((a & (1 << 8)) >> 8)
#define PM_GET_VSSTATUS_FIELDONE0_A(a)            ((a & (1 << 9)) >> 9)
#define PM_GET_VSSTATUS_FIELDONE1_A(a)            ((a & (1 << 10)) >> 10)
#define PM_GET_VSSTATUS_FIELDONE2_A(a)            ((a & (1 << 11)) >> 11)
#define PM_GET_VSSTATUS_INVALIDINTERLACE_A(a)     ((a & (1 << 12)) >> 12)
#define PM_GET_VSSTATUS_FIFOUNDERFLOW_B(a)        ((a & (1 << 16)) >> 16)
#define PM_GET_VSSTATUS_FIELDONE0_B(a)            ((a & (1 << 17)) >> 17)
#define PM_GET_VSSTATUS_FIELDONE1_B(a)            ((a & (1 << 18)) >> 18)
#define PM_GET_VSSTATUS_FIELDONE2_B(a)            ((a & (1 << 19)) >> 19)
#define PM_GET_VSSTATUS_INVALIDINTERLACE_B(a)     ((a & (1 << 20)) >> 20)
// Macros for setting individual states
#define PM_SET_VSSTATUS_GPBUSTIMEOUT(a)                     (a << 0)
#define PM_SET_VSSTATUS_FIFOOVERFLOW_A(a)                   (a << 8)
#define PM_SET_VSSTATUS_FIFOUNDERFLOW_B(a)                  (a << 16)

// Serial Bus Control
// Get state
#define PM_GET_VSSERIALBUS_DATAIN(a)                ((a & (1 << 0)) >> 0)
#define PM_GET_VSSERIALBUS_CLKIN(a)                 ((a & (1 << 1)) >> 1)
#define PM_GET_VSSERIALBUS_DATAOUT(a)               ((a & (1 << 2)) >> 2)
#define PM_GET_VSSERIALBUS_CLKOUT(a)                ((a & (1 << 3)) >> 3)
#define PM_GET_VSSERIALBUS_LATCHEDDATA(a)           ((a & (1 << 4)) >> 4)
#define PM_GET_VSSERIALBUS_DATAVALID(a)             ((a & (1 << 5)) >> 5)
#define PM_GET_VSSERIALBUS_START(a)                 ((a & (1 << 6)) >> 6)
#define PM_GET_VSSERIALBUS_STOP(a)                  ((a & (1 << 7)) >> 7)
#define PM_GET_VSSERIALBUS_WAIT(a)                  ((a & (1 << 8)) >> 8)
// Set State
#define PM_SET_VSSERIALBUS_DATAOUT(a)                       (a << 2)
#define PM_SET_VSSERIALBUS_CLKOUT(a)                        (a << 3)
#define PM_SET_VSSERIALBUS_LATCHEDDATA(a)                   (a << 4)
#define PM_SET_VSSERIALBUS_DATAVALID(a)                     (a << 5)
#define PM_SET_VSSERIALBUS_START(a)                         (a << 6)
#define PM_SET_VSSERIALBUS_STOP(a)                          (a << 7)
#define PM_SET_VSSERIALBUS_WAIT(a)                          (a << 8)

// Video Stream A Control
#define PM_VSACONTROL_VIDEO(a)                              ((a) << 0)
#define PM_VSACONTROL_VBI(a)                                ((a) << 1)
#define PM_VSACONTROL_BUFFER(a)                             ((a) << 2)
#define PM_VSACONTROL_SCALEX(a)                             ((a) << 3)
#define PM_VSACONTROL_SCALEY(a)                             ((a) << 5)
#define PM_VSACONTROL_MIRRORX(a)                            ((a) << 7)
#define PM_VSACONTROL_MIRRORY(a)                            ((a) << 8)
#define PM_VSACONTROL_DISCARD(a)                            ((a) << 9)
#define PM_VSACONTROL_COMBINE(a)                            ((a) << 11)
#define PM_VSACONTROL_LOCKTOB(a)                            ((a) << 12)

// Video Stream B Control
#define PM_VSBCONTROL_VIDEO(a)                              ((a) << 0)
#define PM_VSBCONTROL_VBI(a)                                ((a) << 1)
#define PM_VSBCONTROL_BUFFER(a)                             ((a) << 2)
#define PM_VSBCONTROL_COMBINE(a)                            ((a) << 3)
#define PM_VSBCONTROL_FORMAT(a)                             ((a) << 4)
#define PM_VSBCONTROL_PIXELSIZE(a)                          ((a) << 9)
#define PM_VSBCONTROL_RGB(a)                                ((a) << 11)
#define PM_VSBCONTROL_GAMMA(a)                              ((a) << 12)
#define PM_VSBCONTROL_LOCKTOA(a)                            ((a) << 13)

// *******************************************************************
// Permedia3 Bit Field Macros

// Dither unit
#define P3RX_DITHERMODE_ENABLE(a)                           ((a) << 0)
#define P3RX_DITHERMODE_DITHERENABLE(a)                     ((a) << 1)
#define P3RX_DITHERMODE_COLORFORMAT(a)                      ((a) << 2)
#define P3RX_DITHERMODE_XOFFSET(a)                          ((a) << 6)
#define P3RX_DITHERMODE_YOFFSET(a)                          ((a) << 8)
#define P3RX_DITHERMODE_COLORORDER(a)                       ((a) << 10)
#define P3RX_DITHERMODE_ALPHADITHER(a)                      ((a) << 14)
#define P3RX_DITHERMODE_ROUNDINGMODE(a)                     ((a) << 15)

// Render2D
#define P3RX_RENDER2D_WIDTH(a)                              ((a) << 0)
#define P3RX_RENDER2D_OPERATION(a)                          ((a) << 12)
#define P3RX_RENDER2D_FBREADSOURCEENABLE(a)                 ((a) << 14)
#define P3RX_RENDER2D_SPANOPERATION(a)                      ((a) << 15)
#define P3RX_RENDER2D_HEIGHT(a)                             ((a) << 16)
#define P3RX_RENDER2D_INCREASINGX(a)                        ((a) << 28)
#define P3RX_RENDER2D_INCREASINGY(a)                        ((a) << 29)
#define P3RX_RENDER2D_AREASTIPPLEENABLE(a)                  ((a) << 30)
#define P3RX_RENDER2D_TEXTUREENABLE(a)                      ((a) << 31)

// RectanglePosition
#define P3RX_RECTANGLEPOSITION_X(a)                         ((a) << 0)
#define P3RX_RECTANGLEPOSITION_Y(a)                         ((a) << 16)

// Alpha blend unit.
#define P3RX_ALPHABLENDCOLORMODE_ENABLE(a)                  ((a) << 0)
#define P3RX_ALPHABLENDCOLORMODE_SRCBLEND(a)                ((a) << 1)
#define P3RX_ALPHABLENDCOLORMODE_DSTBLEND(a)                ((a) << 5)
#define P3RX_ALPHABLENDCOLORMODE_SRCTIMES2(a)               ((a) << 8)
#define P3RX_ALPHABLENDCOLORMODE_DSTTIMES2(a)               ((a) << 9)
#define P3RX_ALPHABLENDCOLORMODE_INVSRC(a)                  ((a) << 10)
#define P3RX_ALPHABLENDCOLORMODE_INVDST(a)                  ((a) << 11)
#define P3RX_ALPHABLENDCOLORMODE_COLORFORMAT(a)             ((a) << 12)
#define P3RX_ALPHABLENDCOLORMODE_COLORORDER(a)              ((a) << 16)
#define P3RX_ALPHABLENDCOLORMODE_COLORCONVERSION(a)         ((a) << 17)
#define P3RX_ALPHABLENDCOLORMODE_CONSTANTSRC(a)             ((a) << 18)
#define P3RX_ALPHABLENDCOLORMODE_CONSTANTDST(a)             ((a) << 19)
#define P3RX_ALPHABLENDCOLORMODE_OPERATION(a)               ((a) << 20)
#define P3RX_ALPHABLENDCOLORMODE_SWAPSD(a)                  ((a) << 24)

#define P3RX_ALPHABLENDALPHAMODE_ENABLE(a)                  ((a) << 0)
#define P3RX_ALPHABLENDALPHAMODE_SRCBLEND(a)                ((a) << 1)
#define P3RX_ALPHABLENDALPHAMODE_DSTBLEND(a)                ((a) << 5)
#define P3RX_ALPHABLENDALPHAMODE_SRCTIMES2(a)               ((a) << 8)
#define P3RX_ALPHABLENDALPHAMODE_DSTTIMES2(a)               ((a) << 9)
#define P3RX_ALPHABLENDALPHAMODE_INVSRC(a)                  ((a) << 10)
#define P3RX_ALPHABLENDALPHAMODE_INVDST(a)                  ((a) << 11)
#define P3RX_ALPHABLENDALPHAMODE_NOALPHABUFFER(a)           ((a) << 12)
#define P3RX_ALPHABLENDALPHAMODE_ALPHATYPE(a)               ((a) << 13)
#define P3RX_ALPHABLENDALPHAMODE_ALPHACONVERSION(a)         ((a) << 14)
#define P3RX_ALPHABLENDALPHAMODE_CONSTANTSRC(a)             ((a) << 15)
#define P3RX_ALPHABLENDALPHAMODE_CONSTANTDST(a)             ((a) << 16)
#define P3RX_ALPHABLENDALPHAMODE_OPERATION(a)               ((a) << 17)

#define P3RX_CHROMATESTMODE_ENABLE(a)                       ((a) << 0)
#define P3RX_CHROMATESTMODE_SOURCE(a)                       ((a) << 1)
#define P3RX_CHROMATESTMODE_PASSACTION(a)                   ((a) << 3)
#define P3RX_CHROMATESTMODE_FAILACTION(a)                   ((a) << 5)

// Framebuffer
// FBDestRead
#define P3RX_FBDESTREAD_READENABLE(a)                       ((a) << 0)
#define P3RX_FBDESTREAD_LAYOUT0(a)                          ((a) << 12)
#define P3RX_FBDESTREAD_LAYOUT1(a)                          ((a) << 14)
#define P3RX_FBDESTREAD_LAYOUT2(a)                          ((a) << 16)
#define P3RX_FBDESTREAD_LAYOUT3(a)                          ((a) << 18)

#define P3RX_FBDESTREAD_ENABLE0(a)                          ((a) << 8)
#define P3RX_FBDESTREAD_ENABLE1(a)                          ((a) << 9)
#define P3RX_FBDESTREAD_ENABLE2(a)                          ((a) << 10)
#define P3RX_FBDESTREAD_ENABLE3(a)                          ((a) << 11)

// FBWrite
#define P3RX_FBWRITEMODE_WRITEENABLE(a)                     ((a) << 0)
#define P3RX_FBWRITEMODE_RESERVED(a)                        ((a) << 1)
#define P3RX_FBWRITEMODE_REPLICATE(a)                       ((a) << 4)
#define P3RX_FBWRITEMODE_OPAQUESPAN(a)                      ((a) << 5)
#define P3RX_FBWRITEMODE_STRIPEPITCH(a)                     ((a) << 6)
#define P3RX_FBWRITEMODE_STRIPEHEIGHT(a)                    ((a) << 9)
#define P3RX_FBWRITEMODE_ENABLE0(a)                         ((a) << 12)
#define P3RX_FBWRITEMODE_ENABLE1(a)                         ((a) << 13)
#define P3RX_FBWRITEMODE_ENABLE2(a)                         ((a) << 14)
#define P3RX_FBWRITEMODE_ENABLE3(a)                         ((a) << 15)
#define P3RX_FBWRITEMODE_LAYOUT0(a)                         ((a) << 16)
#define P3RX_FBWRITEMODE_LAYOUT1(a)                         ((a) << 18)
#define P3RX_FBWRITEMODE_LAYOUT2(a)                         ((a) << 20)
#define P3RX_FBWRITEMODE_LAYOUT3(a)                         ((a) << 22)
#define P3RX_FBWRITEMODE_ORIGIN0(a)                         ((a) << 24)
#define P3RX_FBWRITEMODE_ORIGIN1(a)                         ((a) << 25)
#define P3RX_FBWRITEMODE_ORIGIN2(a)                         ((a) << 26)
#define P3RX_FBWRITEMODE_ORIGIN3(a)                         ((a) << 27)

// FBSourceRead
#define P3RX_FBSOURCEREAD_READENABLE(a)                     ((a) << 0)
#define P3RX_FBSOURCEREAD_PREFETCHENABLE(a)                 ((a) << 1)
#define P3RX_FBSOURCEREAD_STRIPEPITCH(a)                    ((a) << 2)
#define P3RX_FBSOURCEREAD_STRIPEHEIGHT(a)                   ((a) << 5)
#define P3RX_FBSOURCEREAD_LAYOUT(a)                         ((a) << 8)
#define P3RX_FBSOURCEREAD_ORIGIN(a)                         ((a) << 10)
#define P3RX_FBSOURCEREAD_BLOCKING(a)                       ((a) << 11)

// Render
#define P3RX_RENDER_AREASTIPPLEENABLE(a)                    ((a) << 0)
#define P3RX_RENDER_LINESTIPPLEENABLE(a)                    ((a) << 1)
#define P3RX_RENDER_RESETLINESTIPPLE(a)                     ((a) << 2)
#define P3RX_RENDER_FASTFILLENABLE(a)                       ((a) << 3)
#define P3RX_RENDER_PRIMITIVETYPE(a)                        ((a) << 6)
#define P3RX_RENDER_ANTIALIASENABLE(a)                      ((a) << 8)
#define P3RX_RENDER_ANTIALIASINGQUALITY(a)                  ((a) << 9)
#define P3RX_RENDER_USEPOINTTABLE(a)                        ((a) << 10)
#define P3RX_RENDER_SYNCONBITMASK(a)                        ((a) << 11)
#define P3RX_RENDER_SYNCONHOSTDATA(a)                       ((a) << 12)
#define P3RX_RENDER_TEXTUREENABLE(a)                        ((a) << 13)
#define P3RX_RENDER_FOGENABLE(a)                            ((a) << 14)
#define P3RX_RENDER_COVERAGEENABLE(a)                       ((a) << 15)
#define P3RX_RENDER_SUBPIXELCORRECTIONENABLE(a)             ((a) << 16)
#define P3RX_RENDER_SPANOPERATION(a)                        ((a) << 18)
#define P3RX_RENDER_DERR(a)                                 ((a) << 20)
#define P3RX_RENDER_FBSOURCEREADENABLE(a)                   ((a) << 27)

// TextureFilterMode - texture filter unit
#define P3RX_TEXFILTERMODE_ENABLE(a)                        ((a) << 0)
#define P3RX_TEXFILTERMODE_FORMAT0(a)                       ((a) << 1)
#define P3RX_TEXFILTERMODE_COLORORDER0(a)                   ((a) << 5)
#define P3RX_TEXFILTERMODE_ALPHAMAPENABLE0(a)               ((a) << 6)
#define P3RX_TEXFILTERMODE_ALPHAMAPSENSE0(a)                ((a) << 7)
#define P3RX_TEXFILTERMODE_COMBINECACHES(a)                 ((a) << 8)
#define P3RX_TEXFILTERMODE_FORMAT1(a)                       ((a) << 9)
#define P3RX_TEXFILTERMODE_COLORORDER1(a)                   ((a) << 13)
#define P3RX_TEXFILTERMODE_ALPHAMAPENABLE1(a)               ((a) << 14)
#define P3RX_TEXFILTERMODE_ALPHAMAPSENSE1(a)                ((a) << 15)
#define P3RX_TEXFILTERMODE_ALPHAMAPFILTERING(a)             ((a) << 16)
#define P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT0(a)          ((a) << 17)
#define P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT1(a)          ((a) << 20)
#define P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT01(a)         ((a) << 23)
#define P3RX_TEXFILTERMODE_MULTITEXTURE(a)                  ((a) << 27)
#define P3RX_TEXFILTERMODE_FORCEALPHATOONE0(a)              ((a) << 28)
#define P3RX_TEXFILTERMODE_FORCEALPHATOONE1(a)              ((a) << 29)
#define P3RX_TEXFILTERMODE_SHIFT0(a)                        ((a) << 30)
#define P3RX_TEXFILTERMODE_SHIFT1(a)                        ((a) << 31)
// Shortcuts - both textures the same (i.e. combined)
#define P3RX_TEXFILTERMODE_FORMATBOTH(a)            \
    ( P3RX_TEXFILTERMODE_FORMAT0(a)            | P3RX_TEXFILTERMODE_FORMAT1(a) )
#define P3RX_TEXFILTERMODE_COLORORDERBOTH(a)        \
    ( P3RX_TEXFILTERMODE_COLORORDER0(a)        | P3RX_TEXFILTERMODE_COLORORDER1(a) )
#define P3RX_TEXFILTERMODE_ALPHAMAPENABLEBOTH(a)    \
    ( P3RX_TEXFILTERMODE_ALPHAMAPENABLE0(a)    | P3RX_TEXFILTERMODE_ALPHAMAPENABLE1(a) )
#define P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMITBOTH(a) \
    ( P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT0(a)    | P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT1(a) )
#define P3RX_TEXFILTERMODE_ALPHAMAPSENSEBOTH(a)     \
    ( P3RX_TEXFILTERMODE_ALPHAMAPSENSE0(a)    | P3RX_TEXFILTERMODE_ALPHAMAPSENSE1(a) )
#define P3RX_TEXFILTERMODE_FORCEALPHATOONEBOTH(a)   \
    ( P3RX_TEXFILTERMODE_FORCEALPHATOONE0(a)| P3RX_TEXFILTERMODE_FORCEALPHATOONE1(a) )
#define P3RX_TEXFILTERMODE_SHIFTBOTH(a)             \
    ( P3RX_TEXFILTERMODE_SHIFT0(a)            | P3RX_TEXFILTERMODE_SHIFT1(a) )

// Texture Coordinate Unit.
#define P3RX_TEXCOORDMODE_ENABLE(a)                         ((a) << 0)
#define P3RX_TEXCOORDMODE_WRAPS(a)                          ((a) << 1)
#define P3RX_TEXCOORDMODE_WRAPT(a)                          ((a) << 3)
#define P3RX_TEXCOORDMODE_OPERATION(a)                      ((a) << 5)
#define P3RX_TEXCOORDMODE_INHIBITDDAINIT(a)                 ((a) << 6)
#define P3RX_TEXCOORDMODE_ENABLELOD(a)                      ((a) << 7)
#define P3RX_TEXCOORDMODE_ENABLEDY(a)                       ((a) << 8)
#define P3RX_TEXCOORDMODE_WIDTH(a)                          ((a) << 9)
#define P3RX_TEXCOORDMODE_HEIGHT(a)                         ((a) << 13)
#define P3RX_TEXCOORDMODE_TEXTUREMAPTYPE(a)                 ((a) << 17)
#define P3RX_TEXCOORDMODE_WRAPS1(a)                         ((a) << 18)
#define P3RX_TEXCOORDMODE_WRAPT1(a)                         ((a) << 20)
#define P3RX_TEXCOORDMODE_DUPLICATECOORDS(a)                ((a) << 22)

// Alpha test unit.
#define P3RX_ANTIALIASMODE_ENABLE(a)                        ((a) << 0)
#define P3RX_ANTIALIASMODE_COLORMODE(a)                     ((a) << 1)
#define P3RX_ANTIALIASMODE_SCALECOLOR(a)                    ((a) << 2)

#define P3RX_ALPHATESTMODE_ENABLE(a)                        ((a) << 0)
#define P3RX_ALPHATESTMODE_COMPARE(a)                       ((a) << 1)
#define P3RX_ALPHATESTMODE_REFERENCE(a)                     ((a) << 4)

// Texture application unit.
#define P3RX_TEXAPPMODE_ENABLE(a)                           ((a) << 0)
#define P3RX_TEXAPPMODE_COLORA(a)                           ((a) << 1)
#define P3RX_TEXAPPMODE_COLORB(a)                           ((a) << 3)
#define P3RX_TEXAPPMODE_COLORI(a)                           ((a) << 5)
#define P3RX_TEXAPPMODE_COLORINVI(a)                        ((a) << 7)
#define P3RX_TEXAPPMODE_COLOROP(a)                          ((a) << 8)
#define P3RX_TEXAPPMODE_ALPHAA(a)                           ((a) << 11)
#define P3RX_TEXAPPMODE_ALPHAB(a)                           ((a) << 13)
#define P3RX_TEXAPPMODE_ALPHAI(a)                           ((a) << 15)
#define P3RX_TEXAPPMODE_ALPHAINVI(a)                        ((a) << 17)
#define P3RX_TEXAPPMODE_ALPHAOP(a)                          ((a) << 18)
#define P3RX_TEXAPPMODE_KDENABLE(a)                         ((a) << 21)
#define P3RX_TEXAPPMODE_KSENABLE(a)                         ((a) << 22)
#define P3RX_TEXAPPMODE_MOTIONCOMPENABLE(a)                 ((a) << 23)
// Short-cuts - passing xxxC to alpha channel equates to xxxA
#define P3RX_TEXAPPMODE_BOTHA(a)        \
            ( P3RX_TEXAPPMODE_COLORA(a)    | P3RX_TEXAPPMODE_ALPHAA(a) )
#define P3RX_TEXAPPMODE_BOTHB(a)        \
            ( P3RX_TEXAPPMODE_COLORB(a)    | P3RX_TEXAPPMODE_ALPHAB(a) )
#define P3RX_TEXAPPMODE_BOTHI(a)        \
            ( P3RX_TEXAPPMODE_COLORI(a)    | P3RX_TEXAPPMODE_ALPHAI(a) )
#define P3RX_TEXAPPMODE_BOTHINVI(a)     \
            ( P3RX_TEXAPPMODE_COLORINVI(a) | P3RX_TEXAPPMODE_ALPHAINVI(a) )
#define P3RX_TEXAPPMODE_BOTHOP(a)       \
            ( P3RX_TEXAPPMODE_COLOROP(a)   | P3RX_TEXAPPMODE_ALPHAOP(a) )

// Texture composite mode.
#define P3RX_TEXCOMPMODE_ENABLE(a)                          ((a) << 0)
// These are used for TextureComposite(Colour|Alpha)Mode(0|1)
// Use the P3RX_TEXAPP_* defines.
#define P3RX_TEXCOMPCAMODE01_ENABLE(a)                      ((a) << 0)
#define P3RX_TEXCOMPCAMODE01_ARG1(a)                        ((a) << 1)
#define P3RX_TEXCOMPCAMODE01_INVARG1(a)                     ((a) << 5)
#define P3RX_TEXCOMPCAMODE01_ARG2(a)                        ((a) << 6)
#define P3RX_TEXCOMPCAMODE01_INVARG2(a)                     ((a) << 10)
#define P3RX_TEXCOMPCAMODE01_I(a)                           ((a) << 11)
#define P3RX_TEXCOMPCAMODE01_INVI(a)                        ((a) << 14)
#define P3RX_TEXCOMPCAMODE01_A(a)                           ((a) << 15)
#define P3RX_TEXCOMPCAMODE01_B(a)                           ((a) << 16)
#define P3RX_TEXCOMPCAMODE01_OPERATION(a)                   ((a) << 17)
#define P3RX_TEXCOMPCAMODE01_SCALE(a)                       ((a) << 21)

// Texture index mode
#define P3RX_TEXINDEXMODE_ENABLE(a)                         ((a) << 0)
#define P3RX_TEXINDEXMODE_WIDTH(a)                          ((a) << 1)
#define P3RX_TEXINDEXMODE_HEIGHT(a)                         ((a) << 5)
#define P3RX_TEXINDEXMODE_BORDER(a)                         ((a) << 9)
#define P3RX_TEXINDEXMODE_WRAPU(a)                          ((a) << 10)
#define P3RX_TEXINDEXMODE_WRAPV(a)                          ((a) << 12)
#define P3RX_TEXINDEXMODE_MAPTYPE(a)                        ((a) << 14)
#define P3RX_TEXINDEXMODE_MAGFILTER(a)                      ((a) << 15)
#define P3RX_TEXINDEXMODE_MINFILTER(a)                      ((a) << 16)
#define P3RX_TEXINDEXMODE_TEX3DENABLE(a)                    ((a) << 19)
#define P3RX_TEXINDEXMODE_MIPMAPENABLE(a)                   ((a) << 20)
#define P3RX_TEXINDEXMODE_NEARESTBIAS(a)                    ((a) << 21)
#define P3RX_TEXINDEXMODE_LINEARBIAS(a)                     ((a) << 23)
#define P3RX_TEXINDEXMODE_SOURCETEXELENABLE(a)              ((a) << 25)

// Texture read unit.
#define P3RX_TEXREADMODE_ENABLE(a)                          ((a) << 0)
#define P3RX_TEXREADMODE_WIDTH(a)                           ((a) << 1)
#define P3RX_TEXREADMODE_HEIGHT(a)                          ((a) << 5)
#define P3RX_TEXREADMODE_TEXELSIZE(a)                       ((a) << 9)
#define P3RX_TEXREADMODE_TEXTURE3D(a)                       ((a) << 11)
#define P3RX_TEXREADMODE_COMBINECACHES(a)                   ((a) << 12)
#define P3RX_TEXREADMODE_MAPBASELEVEL(a)                    ((a) << 13)
#define P3RX_TEXREADMODE_MAPMAXLEVEL(a)                     ((a) << 17)
#define P3RX_TEXREADMODE_LOGICALTEXTURE(a)                  ((a) << 21)
#define P3RX_TEXREADMODE_ORIGIN(a)                          ((a) << 22)
#define P3RX_TEXREADMODE_TEXTURETYPE(a)                     ((a) << 23)
#define P3RX_TEXREADMODE_BYTESWAP(a)                        ((a) << 25)
#define P3RX_TEXREADMODE_MIRROR(a)                          ((a) << 28)
#define P3RX_TEXREADMODE_INVERT(a)                          ((a) << 29)
#define P3RX_TEXREADMODE_OPAQUESPAN(a)                      ((a) << 30)

#define P3RX_TEXMAPWIDTH_WIDTH(a)                           ((a) << 0)
#define P3RX_TEXMAPWIDTH_BORDER(a)                          ((a) << 12)
#define P3RX_TEXMAPWIDTH_LAYOUT(a)                          ((a) << 13)
#define P3RX_TEXMAPWIDTH_HOSTTEXTURE(a)                     ((a) << 15)

#define P3RX_TEXCACHEREPLACEMODE_KEEPOLDEST0(a)             ((a) << 0)
#define P3RX_TEXCACHEREPLACEMODE_SCRATCHLINES0(a)           ((a) << 1)
#define P3RX_TEXCACHEREPLACEMODE_KEEPOLDEST1(a)             ((a) << 6)
#define P3RX_TEXCACHEREPLACEMODE_SCRATCHLINES1(a)           ((a) << 7)
#define P3RX_TEXCACHEREPLACEMODE_SHOWCACHEINFO(a)           ((a) << 12)

#define P3RX_TEXINVALIDATECACHE_BANK0(a)                    ((a) << 0)
#define P3RX_TEXINVALIDATECACHE_BANK1(a)                    ((a) << 1)
#define P3RX_TEXINVALIDATECACHE_TLB(a)                      ((a) << 2)

#define P3RX_INVALIDATECACHE(a, b)                                        \
do                                                                        \
{                                                                         \
    SEND_P3_DATA(InvalidateCache, P3RX_TEXINVALIDATECACHE_BANK0((a)) |    \
                                  P3RX_TEXINVALIDATECACHE_BANK1((a)) |    \
                                  P3RX_TEXINVALIDATECACHE_TLB((b)));      \
    SEND_P3_DATA(FogModeOr, 0);                                           \
    SEND_P3_DATA(TextureReadMode0Or, 0);                                  \
} while (0)

// Logical op unit
#define P3RX_LOGICALOPMODE_ENABLE(a)                        ((a) << 0)
#define P3RX_LOGICALOPMODE_LOGICOP(a)                       ((a) << 1)
#define P3RX_LOGICALOPMODE_USECONSTANTFBWRITEDATA(a)        ((a) << 5)
#define P3RX_LOGICALOPMODE_BACKGROUNDENABLE(a)              ((a) << 6)
#define P3RX_LOGICALOPMODE_BACKGROUNDLOGICALOP(a)           ((a) << 7)
#define P3RX_LOGICALOPMODE_USECONSTANTSOURCE(a)             ((a) << 11)
#define P3RX_LOGICALOPMODE_OPAQUESPAN(a)                    ((a) << 12)

// LUT
#define P3RX_LUTMODE_ENABLE(a)                              ((a) << 0)
#define P3RX_LUTMODE_INCOLORORDER(a)                        ((a) << 1)
#define P3RX_LUTMODE_LOADFORMAT(a)                          ((a) << 2)
#define P3RX_LUTMODE_LOADCOLORORDER(a)                      ((a) << 4)
#define P3RX_LUTMODE_FRAGMENTOP(a)                          ((a) << 5)
#define P3RX_LUTMODE_SPANOP(a)                              ((a) << 8)
#define P3RX_LUTMODE_MOTIONCOMP8BITS(a)                     ((a) << 11)
#define P3RX_LUTMODE_XOFFSET(a)                             ((a) << 12)
#define P3RX_LUTMODE_YOFFSET(a)                             ((a) << 15)
#define P3RX_LUTMODE_PATTERNBASE(a)                         ((a) << 18)
#define P3RX_LUTMODE_SPANCCXALIGN(a)                        ((a) << 26)
#define P3RX_LUTMODE_SPANVCXALIGN(a)                        ((a) << 27)

// YUV unit.
#define P3RX_YUVMODE_ENABLE(a)                              ((a) << 0)

// Color DDA Unit
#define P3RX_COLORDDA_ENABLE(a)                             ((a) << 0)
#define P3RX_COLORDDA_SHADING(a)                            ((a) << 1)

// Scissor
#define P3RX_SCISSORMODE_USER(a)                            ((a) << 0)
#define P3RX_SCISSORMODE_SCREEN(a)                          ((a) << 1)
#define P3RX_SCISSOR_X_Y(a, b)            ((b) << 16 | ((a) & 0xFFFF))

#endif // __BITMAC2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\gigiregl.h ===
#ifndef GIGIREG_H
#define GIGIREG_H
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: gigiregl.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/


#if (defined(_MSDOS) || (defined(__cplusplus) && !defined(_WIN32)))
typedef unsigned long unsigned32;
typedef signed long   signed32;
#else
typedef unsigned long unsigned32;
typedef signed long signed32;
#endif

typedef unsigned short unsigned16;
typedef signed short   signed16;

typedef unsigned char unsigned8;
typedef signed char   signed8;

typedef long __GigiSignedIntegerFmat;
typedef unsigned32 __GigiUnsignedIntegerFmat;

/*
** Generic signed 16 + signed 16 format
*/

#if BIG_ENDIAN == 1 
typedef struct {
  signed32 hi:             16;
  signed32 lo:             16;
} __GigiS16S16Fmat;
#else
typedef struct {
  signed32 lo:             16;
  signed32 hi:             16;
} __GigiS16S16Fmat;
#endif 

/*
** Delta Registers
*/

#ifdef BIG_ENDIAN
typedef struct {
  unsigned32 pad:                      13;
  unsigned32 ColorOrder:                1;
  unsigned32 BackfaceCull:              1;
  unsigned32 FillDirection:             1;
  unsigned32 TextureParameterMode:      2;
  unsigned32 ClampEnable:               1;
  unsigned32 NoDraw:                    1;
  unsigned32 DiamondExit:               1;
  unsigned32 SubPixelCorrectionEnable:  1;
  unsigned32 DiffuseTextureEnable:      1;
  unsigned32 SpecularTextureEnable:     1;
  unsigned32 DepthEnable:               1;
  unsigned32 SmoothShadingEnable:       1;
  unsigned32 TextureEnable:             1;
  unsigned32 FogEnable:                 1;
  unsigned32 DepthFormat:               2;
  unsigned32 TargetChip:                2;
} __GigiDeltaModeFmat;
#else
typedef struct {
  unsigned32 TargetChip:                2;
  unsigned32 DepthFormat:               2;
  unsigned32 FogEnable:                 1;
  unsigned32 TextureEnable:             1;
  unsigned32 SmoothShadingEnable:       1;
  unsigned32 DepthEnable:               1;
  unsigned32 SpecularTextureEnable:     1;
  unsigned32 DiffuseTextureEnable:      1;
  unsigned32 SubPixelCorrectionEnable:  1;
  unsigned32 DiamondExit:               1;
  unsigned32 NoDraw:                    1;
  unsigned32 ClampEnable:               1;
  unsigned32 TextureParameterMode:      2;
  unsigned32 FillDirection:             1;
  unsigned32 BackfaceCull:              1;
  unsigned32 ColorOrder:                1;
  unsigned32 pad:                      13;
} __GigiDeltaModeFmat;
#endif

#ifdef BIG_ENDIAN
typedef struct {
  unsigned32 pad2:                     11;
  unsigned32 RejectNegativeFace:        1;
  unsigned32 pad1:                      1;
  unsigned32 SpanOperation:             1;
  unsigned32 pad0:                      1;
  unsigned32 SubPixelCorrectionEnable:  1;
  unsigned32 CoverageEnable:            1;
  unsigned32 FogEnable:                 1;
  unsigned32 TextureEnable:             1;
  unsigned32 SyncOnHostData:            1;
  unsigned32 SyncOnBitMask:             1;
  unsigned32 UsePointTable:             1;
  unsigned32 AntialiasingQuality:       1;
  unsigned32 AntialiasEnable:           1;
  unsigned32 PrimitiveType:             2;
  unsigned32 reserved:                  2;
  unsigned32 FastFillEnable:            1;
  unsigned32 ResetLineStipple:          1;
  unsigned32 LineStippleEnable:         1;
  unsigned32 AreaStippleEnable:         1;
} __GigiDeltaDrawFmat;
#else
typedef struct {
  unsigned32 AreaStippleEnable:         1;
  unsigned32 LineStippleEnable:         1;
  unsigned32 ResetLineStipple:          1;
  unsigned32 FastFillEnable:            1;
  unsigned32 reserved:                  2;
  unsigned32 PrimitiveType:             2;
  unsigned32 AntialiasEnable:           1;
  unsigned32 AntialiasingQuality:       1;
  unsigned32 UsePointTable:             1;
  unsigned32 SyncOnBitMask:             1;
  unsigned32 SyncOnHostData:            1;
  unsigned32 TextureEnable:             1;
  unsigned32 FogEnable:                 1;
  unsigned32 CoverageEnable:            1;
  unsigned32 SubPixelCorrectionEnable:  1;
  unsigned32 pad0:                      1;
  unsigned32 SpanOperation:             1;
  unsigned32 pad1:                      1;
  unsigned32 RejectNegativeFace:        1;
  unsigned32 pad2:                     11;
} __GigiDeltaDrawFmat;
#endif

#ifdef BIG_ENDIAN
typedef union {
  struct {
    signed32 Val:                      32; /* 2.30s or 16.16s */
  } STQ;
  struct {
    unsigned32 pad:                     8;
    unsigned32 Val:                    24; /* 2.22s */
  } K;
  struct {
    unsigned32 pad:                     1;
    unsigned32 Val:                    31; /* 1.30us */
  } RGBA;
  struct {
    signed32 Val:                      32; /* 10.22s */
  } F;
  struct {
    signed32 Val:                      32; /* 16.16s */
  } XY;
  struct {
    unsigned32 pad:                     1;
    unsigned32 Val:                    31; /* 1.31us */
  } Z;
} __GigiDeltaFixedFmat;
#else 
typedef union {
  struct {
    signed32 Val:                      32; /* 2.30s or 16.16s */
  } STQ;
  struct {
    unsigned32 Val:                    24; /* 2.22s */
    unsigned32 pad:                     8;
  } K;
  struct {
    unsigned32 Val:                    31; /* 1.30us */
    unsigned32 pad:                     1;
  } RGBA;
  struct {
    signed32 Val:                      32; /* 10.22s */
  } F;
  struct {
    signed32 Val:                      32; /* 16.16s */
  } XY;
  struct {
    unsigned32 Val:                    31; /* 1.31us */
    unsigned32 pad:                     1;
  } Z;
} __GigiDeltaFixedFmat;
#endif

#define N_GIGI_DELTA_BROADCAST_MASK_BITS 4 

#ifdef BIG_ENDIAN
typedef struct {
  unsigned32 pad:                      32 - N_GIGI_DELTA_BROADCAST_MASK_BITS;
  unsigned32 Mask:                   N_GIGI_DELTA_BROADCAST_MASK_BITS ;
} __GigiDeltaBroadcastMaskFmat;
#else
typedef struct {
  unsigned32 Mask:                     N_GIGI_DELTA_BROADCAST_MASK_BITS ;
  unsigned32 pad:                      32 - N_GIGI_DELTA_BROADCAST_MASK_BITS ;
} __GigiDeltaBroadcastMaskFmat;
#endif

/*
** GIGI Host In Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Mask:         16;
  unsigned32 Mode:          2;
  unsigned32 pad0:          5;
  unsigned32 MajorGroup:    5;
  unsigned32 Offset:        4;
} __GigiDMADataFmat;
#else
typedef struct {
  unsigned32 Offset:        4;
  unsigned32 MajorGroup:    5;
  unsigned32 pad0:          5;
  unsigned32 Mode:          2;
  unsigned32 Mask:         16;
} __GigiDMADataFmat;
#endif

/*
**  GIGI Rasterizer Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:          4;
  signed32 Integer:        12;
  unsigned32 Fraction:     15;
  unsigned32 pad0:          1;
} __GigiStartXDomFmat,
  __GigidXDomFmat,
  __GigiStartXSubFmat,
  __GigidXSubFmat;
#else
typedef struct {
  unsigned32 pad0:          1;
  unsigned32 Fraction:     15;
  signed32 Integer:        12;
  unsigned32 pad1:          4;
} __GigiStartXDomFmat,
  __GigidXDomFmat,
  __GigiStartXSubFmat,
  __GigidXSubFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:          4;
  signed32 Integer:        12;
  unsigned32 Fraction:     15;
  unsigned32 pad0:          1;
} __GigiStartYFmat,
  __GigidYFmat;
#else
typedef struct {
  unsigned32 pad0:          1;
  unsigned32 Fraction:     15;
  signed32 Integer:        12;
  unsigned32 pad1:          4;
} __GigiStartYFmat,
  __GigidYFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:         20;
  unsigned32 Val:          12;
} __GigiCountFmat,
  __GigiContinueNewLineFmat,
  __GigiContinueNewDomFmat,
  __GigiContinueNewSubFmat,
  __GigiContinueFmat;
#else
typedef struct {
  unsigned32 Val:          12;
  unsigned32 pad0:         20;
} __GigiCountFmat,
  __GigiContinueNewLineFmat,
  __GigiContinueNewDomFmat,
  __GigiContinueNewSubFmat,
  __GigiContinueFmat;
#endif 

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad5:                     9;
  unsigned32 IncreaseY:                1;
  unsigned32 IncreaseX:                1;
  unsigned32 RejectNegativeFace:       1;
  unsigned32 pad4:                     2;
  unsigned32 ReuseBitMask:             1;
  unsigned32 SubPixelCorrectionEnable: 1;
  unsigned32 pad3:                     1;
  unsigned32 FogEnable:                1;
  unsigned32 TextureEnable:            1;
  unsigned32 SyncOnHostData:           1;
  unsigned32 SyncOnBitMask:            1;
  unsigned32 pad2:                     3;
  unsigned32 PrimitiveType:            2;
  unsigned32 pad1:                     2;
  unsigned32 FastFillEnable:           1;
  unsigned32 pad0:                     2;
  unsigned32 AreaStippleEnable:        1;
} __GigiRenderFmat,
  __GigiPrepareToRenderFmat;
#else
typedef struct {
  unsigned32 AreaStippleEnable:        1;
  unsigned32 pad0:                     2;
  unsigned32 FastFillEnable:           1;
  unsigned32 pad1:                     2;
  unsigned32 PrimitiveType:            2;
  unsigned32 pad2:                     3;
  unsigned32 SyncOnBitMask:            1;
  unsigned32 SyncOnHostData:           1;
  unsigned32 TextureEnable:            1;
  unsigned32 FogEnable:                1;
  unsigned32 pad3:                     1;
  unsigned32 SubPixelCorrectionEnable: 1;
  unsigned32 ReuseBitMask:             1;
  unsigned32 pad4:                     2;
  unsigned32 RejectNegativeFace:       1;
  unsigned32 IncreaseX:                1;
  unsigned32 IncreaseY:                1;
  unsigned32 pad5:                     9;
} __GigiRenderFmat,
  __GigiPrepareToRenderFmat;
#endif 

typedef __GigiUnsignedIntegerFmat __GigiBitMaskPatternFmat;

#if BIG_ENDIAN == 1 
typedef struct {
  unsigned32 pad1:                12;
  unsigned32 BitMaskRelative:      1;
  unsigned32 LimitsEnable:         1;
  unsigned32 pad0:                 1;
  unsigned32 HostDataByteSwapMode: 2;
  unsigned32 BitMaskOffset:        5;
  unsigned32 BitMaskPacking:       1;
  unsigned32 BitMaskByteSwapMode:  2;
  unsigned32 ForceBackgroundColor: 1;
  unsigned32 BiasCoordinates:      2;
  unsigned32 FractionAdjust:       2;
  unsigned32 InvertBitMask:        1;
  unsigned32 MirrorBitMask:        1;
} __GigiRasterizerModeFmat;
#else
typedef struct {
  unsigned32 MirrorBitMask:        1;
  unsigned32 InvertBitMask:        1;
  unsigned32 FractionAdjust:       2;
  unsigned32 BiasCoordinates:      2;
  unsigned32 ForceBackgroundColor: 1;
  unsigned32 BitMaskByteSwapMode:  2;
  unsigned32 BitMaskPacking:       1;
  unsigned32 BitMaskOffset:        5;
  unsigned32 HostDataByteSwapMode: 2;
  unsigned32 pad0:                 1;
  unsigned32 LimitsEnable:         1;
  unsigned32 BitMaskRelative:      1;
  unsigned32 pad1:                12;
} __GigiRasterizerModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           4;
  signed32 Max:             12;
  unsigned32 pad0:           4;
  signed32 Min:             12;
} __GigiYLimitsFmat, __GigiXLimitsFmat;
#else
typedef struct {
  signed32 Min:             12;
  unsigned32 pad0:           4;
  signed32 Max:             12;
  unsigned32 pad1:           4;
} __GigiYLimitsFmat, __GigiXLimitsFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           4;
  signed32 Y:               12;
  unsigned32 pad0:           4;
  signed32 X:               12;
} __GigiStepFmat;
#else
typedef struct {
  signed32 X:               12;
  unsigned32 pad0:           4;
  signed32 Y:               12;
  unsigned32 pad1:           4;
} __GigiStepFmat;
#endif

typedef __GigiStepFmat __GigiActiveStepXFmat;
typedef __GigiStepFmat __GigiActiveStepYDomEdgeFmat;
typedef __GigiStepFmat __GigiPassiveStepXFmat;
typedef __GigiStepFmat __GigiPassiveStepYDomEdgeFmat;
typedef __GigiStepFmat __GigiFastBlockFillFmat;
typedef __GigiStepFmat __GigiRectangleOriginFmat;
typedef __GigiStepFmat __GigiRectangleSizeFmat;
typedef __GigiStepFmat __GigiFBSourceDeltaFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           5;
  unsigned32 Y:             11;
  unsigned32 pad0:           5;
  unsigned32 X:             11;
} __GigiUnsignedStepFmat;
#else
typedef struct {
  unsigned32 X:             11;
  unsigned32 pad0:           5;
  unsigned32 Y:             11;
  unsigned32 pad1:           5;
} __GigiUnsignedStepFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:          4;
  signed32 XRight:         12;
  unsigned32 pad0:          4;
  signed32 XLeft:          12;
} __GigiFastBlockLimitsFmat;
#else
typedef struct {
  signed32 XLeft:          12;
  unsigned32 pad0:          4;
  signed32 XRight:         12;
  unsigned32 pad1:          4;
} __GigiFastBlockLimitsFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:          27;
  unsigned32 Sign:           1;
  unsigned32 Magnitude:      4;
} __GigiSubPixelCorrectionFmat;
#else
typedef struct {
  unsigned32 Magnitude:      4;
  unsigned32 Sign:           1;
  unsigned32 pad0:          27;
} __GigiSubPixelCorrectionFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  signed32 RelativeOffset:  3;
  unsigned32 pad1:          1;
  signed32 XStart:         12;
  unsigned32 pad0:          4;
  signed32 XEnd:           12;
} __GigiPackedDataLimitsFmat;
#else
typedef struct {
  signed32 XEnd:           12;
  unsigned32 pad0:          4;
  signed32 XStart:         12;
  unsigned32 pad1:          1;
  signed32 RelativeOffset:  3;
} __GigiPackedDataLimitsFmat;
#endif

typedef __GigiUnsignedIntegerFmat __GigiSpanMaskFmat;

/*
**  GIGI Scissor and Stipple Registers
*/
#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                30;
  unsigned32 ScreenScissorEnable:  1;
  unsigned32 UserScissorEnable:    1;
} __GigiScissorModeFmat;
#else
typedef struct {
  unsigned32 UserScissorEnable:    1;
  unsigned32 ScreenScissorEnable:  1;
  unsigned32 pad0:                30;
} __GigiScissorModeFmat;
#endif 

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad3:                 11;
  unsigned32 ForceBackgroundColor:  1;
  unsigned32 MirrorY:               1;
  unsigned32 MirrorX:               1;
  unsigned32 InvertStipplePattern:  1;
  unsigned32 pad2:                  2;
  unsigned32 YOffset:               3;
  unsigned32 pad1:                  2;
  unsigned32 XOffset:               3;
  unsigned32 pad0:                  6;
  unsigned32 UnitEnable:            1;
} __GigiAreaStippleModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:            1;
  unsigned32 pad0:                  6;
  unsigned32 XOffset:               3;
  unsigned32 pad1:                  2;
  unsigned32 YOffset:               3;
  unsigned32 pad2:                  2;
  unsigned32 InvertStipplePattern:  1;
  unsigned32 MirrorX:               1;
  unsigned32 MirrorY:               1;
  unsigned32 ForceBackgroundColor:  1;
  unsigned32 pad3:                 11;
} __GigiAreaStippleModeFmat;
#endif

typedef __GigiStepFmat __GigiScreenRegionFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           4;
  signed32 Y:               12;
  unsigned32 pad0:           4;
  signed32 X:               12;
} __GigiScissorMinXYFmat, __GigiScissorMaxXYFmat;
#else
typedef struct {
  signed32 X:               12;
  unsigned32 pad0:           4;
  signed32 Y:               12;
  unsigned32 pad1:           4;
} __GigiScissorMinXYFmat, __GigiScissorMaxXYFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           4;
  signed32 Y:               12;
  unsigned32 pad0:           4;
  signed32 X:               12;
} __GigiWindowOriginFmat;
#else
typedef struct {
  signed32 X:               12;
  unsigned32 pad0:           4;
  signed32 Y:               12;
  unsigned32 pad1:           4;
} __GigiWindowOriginFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           5;
  unsigned32 Y:             11;
  unsigned32 pad0:           5;
  unsigned32 X:             11;
} __GigiScreenSizeFmat;
#else
typedef struct {
  unsigned32 X:             11;
  unsigned32 pad0:           5;
  unsigned32 Y:             11;
  unsigned32 pad1:           5;
} __GigiScreenSizeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:         24;
  unsigned32 Pattern:       8;
} __GigiAreaStipplePatternFmat;
#else
typedef struct {
  unsigned32 Pattern:       8;
  unsigned32 pad0:         24;
} __GigiAreaStipplePatternFmat;
#endif

/*
**  GIGI Color DDA Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         9;
  unsigned32 Fraction:     11;
  unsigned32 pad0:          4;
} __GigiCStartFmat;
#else
typedef struct {
  unsigned32 pad0:          4;
  unsigned32 Fraction:     11;
  signed32 Integer:         9;
  unsigned32 pad2:          8;
} __GigiCStartFmat;
#endif

typedef __GigiCStartFmat __GigiRStartFmat;
typedef __GigiCStartFmat __GigiGStartFmat;
typedef __GigiCStartFmat __GigiBStartFmat;
typedef __GigiCStartFmat __GigiAStartFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         9;
  unsigned32 Fraction:     11;
  unsigned32 pad0:          4;
} __GigidCdxFmat;
#else
typedef struct {
  unsigned32 pad0:          4;
  unsigned32 Fraction:     11;
  signed32 Integer:         9;
  unsigned32 pad2:          8;
} __GigidCdxFmat;
#endif

typedef __GigidCdxFmat __GigidRdxFmat;
typedef __GigidCdxFmat __GigidGdxFmat;
typedef __GigidCdxFmat __GigidBdxFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         9;
  unsigned32 Fraction:     11;
  unsigned32 pad0:          4;
} __GigidCdyDomFmat;
#else
typedef struct {
  unsigned32 pad0:          4;
  unsigned32 Fraction:     11;
  signed32 Integer:         9;
  unsigned32 pad2:          8;
} __GigidCdyDomFmat;
#endif

typedef __GigidCdyDomFmat __GigidRdyDomFmat;
typedef __GigidCdyDomFmat __GigidGdyDomFmat;
typedef __GigidCdyDomFmat __GigidBdyDomFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Alpha:            8;
  unsigned32 Blue:             8;
  unsigned32 Green:            8;
  unsigned32 Red:              8;
} __GigiColorFmat;
#else
typedef struct {
  unsigned32 Red:              8;
  unsigned32 Green:            8;
  unsigned32 Blue:             8;
  unsigned32 Alpha:            8;
} __GigiColorFmat;
#endif

typedef __GigiColorFmat __GigiConstantColorFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 AlphaInteger:     5;
  unsigned32 AlphaFraction:    3;
  unsigned32 BlueInteger:      5;
  unsigned32 BlueFraction:     3;
  unsigned32 GreenInteger:     5;
  unsigned32 GreenFraction:    3;
  unsigned32 RedInteger:       5;
  unsigned32 RedFraction:      3;
} __GigiFractionalColorFmat;
#else
typedef struct {
  unsigned32 RedFraction:      3;
  unsigned32 RedInteger:       5;
  unsigned32 GreenFraction:    3;
  unsigned32 GreenInteger:     5;
  unsigned32 BlueFraction:     3;
  unsigned32 BlueInteger:      5;
  unsigned32 AlphaFraction:    3;
  unsigned32 AlphaInteger:     5;
} __GigiFractionalColorFmat;
#endif 

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:             30;
  unsigned32 ShadeMode:         1;
  unsigned32 UnitEnable:        1;
} __GigiColorDDAModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:        1;
  unsigned32 ShadeMode:         1;
  unsigned32 pad0:             30;
} __GigiColorDDAModeFmat;
#endif

/*
**  GIGI Texture Application, Fog and 
**       Alpha Blend Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:          8;  
  signed32 Integer:         2;
  unsigned32 Fraction:     19;
  unsigned32 pad0:          3;           
} __GigiFogFmat;
#else
typedef struct {
  unsigned32 pad0:          3;           
  unsigned32 Fraction:     19;
  signed32 Integer:         2;
  unsigned32 pad1:          8;  
} __GigiFogFmat;
#endif

typedef __GigiFogFmat __GigiFStartFmat;
typedef __GigiFogFmat __GigidFdxFmat;
typedef __GigiFogFmat __GigidFdyDomFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:            29;
  unsigned32 FogTest:          1;
  unsigned32 pad0:             1;
  unsigned32 FogEnable:        1;
} __GigiFogModeFmat;
#else
typedef struct {
  unsigned32 FogEnable:        1;
  unsigned32 pad0:             1;
  unsigned32 FogTest:          1;
  unsigned32 pad1:            29;
} __GigiFogModeFmat;
#endif

typedef __GigiColorFmat __GigiFogColorFmat;
typedef __GigiColorFmat __GigiTexelFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:            25;
  unsigned32 KsDDA:            1;
  unsigned32 KdDDA:            1;
  unsigned32 TextureType:      1;
  unsigned32 ApplicationMode:  3;
  unsigned32 TextureEnable:    1;
} __GigiTextureColorModeFmat;
#else
typedef struct {
  unsigned32 TextureEnable:    1;
  unsigned32 ApplicationMode:  3;
  unsigned32 TextureType:      1;
  unsigned32 KdDDA:            1;
  unsigned32 KsDDA:            1;
  unsigned32 pad0:            25;
} __GigiTextureColorModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:                13;
  unsigned32 AlphaConversion:      1;
  unsigned32 ColorConversion:      1;
  unsigned32 ColorFormatExtension: 1;
  unsigned32 pad1:                 1;
  unsigned32 BlendType:            1;
  unsigned32 ColorOrder:           1;
  unsigned32 NoAlphaBuffer:        1;
  unsigned32 ColorFormat:          4;
  unsigned32 DestinationBlend:       3;
  unsigned32 SourceBlend:           4;
  unsigned32 AlphaBlendEnable:     1;
} __GigiAlphaBlendModeFmat;
#else
typedef struct {
  unsigned32 AlphaBlendEnable:     1;
  unsigned32 SourceBlend:          4;
  unsigned32 DestinationBlend:       3;
  unsigned32 ColorFormat:          4;
  unsigned32 NoAlphaBuffer:        1;
  unsigned32 ColorOrder:           1;
  unsigned32 BlendType:            1;
  unsigned32 pad1:                 1;
  unsigned32 ColorFormatExtension: 1; 
  unsigned32 ColorConversion:      1;
  unsigned32 AlphaConversion:      1;
  unsigned32 pad2:                13;
} __GigiAlphaBlendModeFmat;
#endif

/*
**  GIGI Texture Address Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  signed32 Integer:         12;
  unsigned32 Fraction:      18;
  unsigned32 pad1:           2;
} __GigiSTFmat;
#else
typedef struct {
  unsigned32 pad1:           2;
  unsigned32 Fraction:      18;
  signed32 Integer:         12;
} __GigiSTFmat;
#endif

typedef __GigiSTFmat __GigiSStartFmat;
typedef __GigiSTFmat __GigiTStartFmat;
typedef __GigiSTFmat __GigidSdxFmat;
typedef __GigiSTFmat __GigidTdxFmat;
typedef __GigiSTFmat __GigidSdyDomFmat;
typedef __GigiSTFmat __GigidTdyDomFmat;

#if BIG_ENDIAN == 1
typedef struct {
  signed32 Integer:          2;
  unsigned32 Fraction:      27;
  unsigned32 pad0:           3;
} __GigiQFmat;
#else
typedef struct {
  unsigned32 pad0:           3;
  unsigned32 Fraction:      27;
  signed32 Integer:          2;
} __GigiQFmat;
#endif

typedef __GigiQFmat __GigiQStartFmat;
typedef __GigiQFmat __GigidQdxFmat;
typedef __GigiQFmat __GigidQdyDomFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 TLoMagnitude:    12;
  unsigned32 SSign:            1;
  unsigned32 SMagnitude:      19;
} __GigiTextureAddressFmat0;
#else
typedef struct {
  unsigned32 SMagnitude:      19;
  unsigned32 SSign:            1;
  unsigned32 TLoMagnitude:    12;
} __GigiTextureAddressFmat0;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:            24;
  unsigned32 TSign:            1;
  unsigned32 THiMagnitude:     7;
} __GigiTextureAddressFmat1;
#else
typedef struct {
  unsigned32 THiMagnitude:     7;
  unsigned32 TSign:            1;
  unsigned32 pad0:            24;
} __GigiTextureAddressFmat1;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                    28;
  unsigned32 DeltaFormat:              1;
  unsigned32 Fast:                     1;
  unsigned32 PerspectiveCorrection:    1;
  unsigned32 Enable:                   1;
} __GigiTextureAddrModeFmat;
#else
typedef struct {
  unsigned32 Enable:                   1;
  unsigned32 PerspectiveCorrection:    1;
  unsigned32 Fast:                     1;
  unsigned32 DeltaFormat:              1;
  unsigned32 pad0:                    28;
} __GigiTextureAddrModeFmat;
#endif

/*
**  GIGI Texture Read Registers
*/

typedef struct {
#if BIG_ENDIAN == 1
    unsigned32 TCoeff :      8;
    unsigned32 Pad1 :        7;
    unsigned32 SwapT :       1;
    unsigned32 SCoeff :      8;
    unsigned32 Pad0 :        7;
    unsigned32 SwapS :       1;
#else
    unsigned32 SwapS :       1;
    unsigned32 Pad0 :        7;
    unsigned32 SCoeff :      8;
    unsigned32 SwapT :       1;
    unsigned32 Pad1 :        7;
    unsigned32 TCoeff :      8;
#endif
} __GigiTextureReadPadFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:                7;
  unsigned32 PackedData:          1;
  unsigned32 pad1:                6;
  unsigned32 FilterMode:          1;
  unsigned32 Height:              4;
  unsigned32 Width:               4;
  unsigned32 pad0:                4;
  unsigned32 TWrapMode:           2;
  unsigned32 SWrapMode:           2;
  unsigned32 Enable:              1;
} __GigiTextureReadModeFmat;
#else
typedef struct {
  unsigned32 Enable:              1;
  unsigned32 SWrapMode:           2;
  unsigned32 TWrapMode:           2;
  unsigned32 pad0:                4;
  unsigned32 Width:               4;
  unsigned32 Height:              4;
  unsigned32 FilterMode:          1;
  unsigned32 pad1:                6;
  unsigned32 PackedData:          1;
  unsigned32 pad2:                7;
} __GigiTextureReadModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:             10;
  unsigned32 TexelSize:         3;
  unsigned32 pad1:              1;
  unsigned32 SubPatchMode:      1;
  unsigned32 WindowOrigin:      1;
  unsigned32 pad0:              7;
  unsigned32 PP2:               3;
  unsigned32 PP1:               3;
  unsigned32 PP0:               3;
} __GigiTextureMapFormatFmat;
#else
typedef struct {
  unsigned32 PP0:               3;
  unsigned32 PP1:               3;
  unsigned32 PP2:               3;
  unsigned32 pad0:              7;
  unsigned32 WindowOrigin:      1;
  unsigned32 SubPatchMode:      1;
  unsigned32 pad1:              1;
  unsigned32 TexelSize:         3;
  unsigned32 pad2:             10;
} __GigiTextureMapFormatFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                   22;
  unsigned32 SpanFormat:              1;
  unsigned32 AlphaMap:                2;
  unsigned32 TextureFormatExtension:  1;
  unsigned32 ColorOrder:              1;
  unsigned32 NoAlphaBuffer:           1;
  unsigned32 TextureFormat:           4;
} __GigiTextureDataFormatFmat;
#else
typedef struct {
  unsigned32 TextureFormat:           4;
  unsigned32 NoAlphaBuffer:           1;
  unsigned32 ColorOrder:              1;
  unsigned32 TextureFormatExtension:  1;
  unsigned32 AlphaMap:                2;
  unsigned32 SpanFormat:              1;
  unsigned32 pad0:                   22;
} __GigiTextureDataFormatFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              8;
  unsigned32 Addr:             24;
} __GigiTexelLUTAddressFmat, __GigiTexelLUTID;
#else
typedef struct {
  unsigned32 Addr:             24;
  unsigned32 pad0:              8;
} __GigiTexelLUTAddressFmat, __GigiTexelLUTID;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              1;
  unsigned32 Access:            1;
  unsigned32 pad1:              6;
  unsigned32 Addr:             24;
} __GigiTextureBaseAddressFmat;
#else
typedef struct {
  unsigned32 Addr:             24;
  unsigned32 pad1:              6;
  unsigned32 Access:            1;
  unsigned32 pad0:              1;
} __GigiTextureBaseAddressFmat;
#endif

typedef __GigiUnsignedIntegerFmat __GigiRawDataFmat[2];

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Alpha:             8;
  unsigned32 V:                 8;
  unsigned32 U:                 8;
  unsigned32 Y:                 8;
} __GigiTexelYUVFmat;
#else
typedef struct {
  unsigned32 Y:                 8;
  unsigned32 U:                 8;
  unsigned32 V:                 8;
  unsigned32 Alpha:             8;
} __GigiTexelYUVFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           20;
  unsigned32 PixelsPerEntry:  2;
  unsigned32 LUTOffset:       8;
  unsigned32 DirectIndex:     1;
  unsigned32 Enable:          1;
} __GigiTexelLUTModeFmat;
#else
typedef struct {
  unsigned32 Enable:          1;
  unsigned32 DirectIndex:     1;
  unsigned32 LUTOffset:       8;
  unsigned32 PixelsPerEntry:  2;
  unsigned32 pad0:           20;
} __GigiTexelLUTModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 TCoeff:            8;
  unsigned32 pad1:              7;
  unsigned32 SwapT:             1;
  unsigned32 SCoeff:            8;
  unsigned32 pad0:              7;
  unsigned32 SwapS:             1;
} __GigiInterp0Fmat;
#else
typedef struct {
  unsigned32 SwapS:             1;
  unsigned32 pad0:              7;
  unsigned32 SCoeff:            8;
  unsigned32 SwapT:             1;
  unsigned32 pad1:              7;
  unsigned32 TCoeff:            8;
} __GigiInterp0Fmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:             24;
  unsigned32 Offset:            8;
} __GigiTexelLUTIndexFmat;
#else
typedef struct {
  unsigned32 Offset:            8;
  unsigned32 pad0:             24;
} __GigiTexelLUTIndexFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:             15;
  unsigned32 Count:             9;
  unsigned32 Index:             8;
} __GigiTexelLUTTransferFmat;
#else
typedef struct {
  unsigned32 Index:             8;
  unsigned32 Count:             9;
  unsigned32 pad0:             15;
} __GigiTexelLUTTransferFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Valid:             1;
  unsigned32 pad0:              7;
  unsigned32 Address:          24;
} __GigiTextureIDFmat;
#else
typedef struct {
  unsigned32 Address:          24;
  unsigned32 pad0:              7;
  unsigned32 Valid:             1;
} __GigiTextureIDFmat;
#endif

typedef __GigiColorFmat __GigiAlphaMapUpperBoundFmat;
typedef __GigiColorFmat __GigiAlphaMapLowerBoundFmat;

/*
**  GIGI YUV-REG Registers
*/

typedef __GigiColorFmat __GigiChromaUpperBoundFmat;
typedef __GigiColorFmat __GigiChromaLowerBoundFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           26;
  unsigned32 TexelDisableUpdate:1;
  unsigned32 RejectTexel:     1;
  unsigned32 TestData:        1;
  unsigned32 TestMode:        2;
  unsigned32 Enable:          1;
} __GigiYUVModeFmat;
#else
typedef struct {
  unsigned32 Enable:          1;
  unsigned32 TestMode:        2;
  unsigned32 TestData:        1;
  unsigned32 RejectTexel:     1;
  unsigned32 TexelDisableUpdate:1;
  unsigned32 pad0:           26;
} __GigiYUVModeFmat;
#endif

/*
**  GIGI Localbuffer Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           15;
  unsigned32 Stencil:         1;
  unsigned32 Depth:          16;
} __GigiLBDataFmat;
#else
typedef struct {
  unsigned32 Depth:          16;
  unsigned32 Stencil:         1;
  unsigned32 pad0:           15;
} __GigiLBDataFmat;
#endif

typedef __GigiLBDataFmat __GigiLBWriteDataFmat;
typedef __GigiLBDataFmat __GigiLBSourceDataFmat;
typedef __GigiLBDataFmat __GigiLBCancelWriteFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           28;
  unsigned32 StencilWidth:    2;
  unsigned32 DepthWidth:      2;
} __GigiLBFormatFmat;
#else
typedef struct {
  unsigned32 DepthWidth:      2;
  unsigned32 StencilWidth:    2;
  unsigned32 pad0:           28;
} __GigiLBFormatFmat;
#endif

typedef __GigiLBFormatFmat __GigiLBReadFormatFmat;
typedef __GigiLBFormatFmat __GigiLBWriteFormatFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:                 12;
  unsigned32 PatchMode:             1;
  unsigned32 WindowOrigin:          1;
  unsigned32 DataType:              2;
  unsigned32 pad0:                  5;
  unsigned32 ReadDestinationEnable: 1;
  unsigned32 ReadSourceEnable:      1;
  unsigned32 PP2:                   3;
  unsigned32 PP1:                   3;
  unsigned32 PP0:                   3;
} __GigiLBReadModeFmat;
#else
typedef struct {
  unsigned32 PP0:                   3;
  unsigned32 PP1:                   3;
  unsigned32 PP2:                   3;
  unsigned32 ReadSourceEnable:      1;
  unsigned32 ReadDestinationEnable: 1;
  unsigned32 pad0:                  5;
  unsigned32 DataType:              2;
  unsigned32 WindowOrigin:          1;
  unsigned32 PatchMode:             1;
  unsigned32 pad1:                 12;
} __GigiLBReadModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           12;
  unsigned32 PatchMode:       1;
  unsigned32 WindowOrigin:    1;
  unsigned32 pad0:            9;
  unsigned32 PP2:             3;
  unsigned32 PP1:             3;
  unsigned32 PP0:             3;
} __GigiLBWriteConfigFmat;
#else
typedef struct {
  unsigned32 PP0:             3;
  unsigned32 PP1:             3;
  unsigned32 PP2:             3;
  unsigned32 pad0:            9;
  unsigned32 WindowOrigin:    1;
  unsigned32 PatchMode:       1;
  unsigned32 pad1:           12;
} __GigiLBWriteConfigFmat;
#endif

typedef __GigiUnsignedIntegerFmat __GigiLBReadPadFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           31;
  unsigned32 WriteEnable:     1;
} __GigiLBWriteModeFmat;
#else
typedef struct {
  unsigned32 WriteEnable:     1;
  unsigned32 pad0:           31;
} __GigiLBWriteModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:            8;
  unsigned32 Addr:           24;
} __GigiLBAddressFmat;
#else
typedef struct {
  unsigned32 Addr:           24;
  unsigned32 pad0:            8;
} __GigiLBAddressFmat;
#endif

typedef __GigiLBAddressFmat __GigiLBWindowBaseFmat;
typedef __GigiLBAddressFmat __GigiLBSourceOffsetFmat;
typedef __GigiLBAddressFmat __GigiLBWriteBaseFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           31;
  unsigned32 Stencil:         1;
} __GigiLBStencilFmat;
#else
typedef struct {
  unsigned32 Stencil:         1;
  unsigned32 pad0:           31;
} __GigiLBStencilFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           16;
  unsigned32 Depth:          16;
} __GigiLBDepthFmat;
#else
typedef struct {
  unsigned32 Depth:          16;
  unsigned32 pad0:           16;
} __GigiLBDepthFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              31;
  unsigned32 Data:               1;
} __GigiStencilFmat;
#else
typedef struct {
  unsigned32 Data:               1;
  unsigned32 pad0:              31;
} __GigiStencilFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              16;
  unsigned32 Data:              16;
} __GigiDepthFmat;
#else
typedef struct {
  unsigned32 Data:              16;
  unsigned32 pad0:              16;
} __GigiDepthFmat;
#endif

/*
**  GIGI Depth and Stencil Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:                 13;
  unsigned32 DisableLBUpdate:       1;
  unsigned32 pad1:                 13;
  unsigned32 LBUpdateSource:        1;
  unsigned32 ForceLBUpdate:         1;
  unsigned32 pad0:                  3;
} __GigiWindowFmat;
#else
typedef struct {
  unsigned32 pad0:                  3;
  unsigned32 ForceLBUpdate:         1;
  unsigned32 LBUpdateSource:        1;
  unsigned32 pad1:                 13;
  unsigned32 DisableLBUpdate:       1;
  unsigned32 pad2:                 13;
} __GigiWindowFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:                 15;
  unsigned32 WriteMask:             1;
  unsigned32 pad1:                  7;
  unsigned32 CompareMask:           1;
  unsigned32 pad0:                  7;
  unsigned32 ReferenceValue:        1;
} __GigiStencilDataFmat;
#else
typedef struct {
  unsigned32 ReferenceValue:        1;
  unsigned32 pad0:                  7;
  unsigned32 CompareMask:           1;
  unsigned32 pad1:                  7;
  unsigned32 WriteMask:             1;
  unsigned32 pad2:                 15;
} __GigiStencilDataFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                17;
  unsigned32 StencilSource:        2;
  unsigned32 CompareFunction:      3;
  unsigned32 SFail:                3;
  unsigned32 DPFail:               3;
  unsigned32 DPPass:               3;
  unsigned32 UnitEnable:           1;
} __GigiStencilModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:           1;
  unsigned32 DPPass:               3;
  unsigned32 DPFail:               3;
  unsigned32 SFail:                3;
  unsigned32 CompareFunction:      3;
  unsigned32 StencilSource:        2;
  unsigned32 pad0:                17;
} __GigiStencilModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              25;
  unsigned32 CompareMode:        3;
  unsigned32 NewDepthSource:     2;
  unsigned32 WriteMask:          1;
  unsigned32 UnitEnable:         1;
} __GigiDepthModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:         1;
  unsigned32 WriteMask:          1;
  unsigned32 NewDepthSource:     2;
  unsigned32 CompareMode:        3;
  unsigned32 pad0:              25;
} __GigiDepthModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              15;
  signed32 Z:                   17;
} __GigiZUFmat;
#else
typedef struct {
  signed32 Z:                   17;
  unsigned32 pad0:              15;
} __GigiZUFmat;
#endif

typedef __GigiZUFmat __GigiZStartUFmat;
typedef __GigiZUFmat __GigidZdxUFmat;
typedef __GigiZUFmat __GigidZdyDomUFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Z:                 11;
  unsigned32 pad0:              21;
} __GigiZLFmat;
#else
typedef struct {
  unsigned32 pad0:              21;
  unsigned32 Z:                 11;
} __GigiZLFmat;
#endif

typedef __GigiZLFmat __GigiZStartLFmat;
typedef __GigiZLFmat __GigidZdxLFmat;
typedef __GigiZLFmat __GigidZdyDomLFmat;

/*
**  GIGI Framebuffer Registers
*/

#if BIG_ENDIAN == 1 
typedef struct {
  unsigned32 pad0:              8;
  unsigned32 Addr:             24;
} __GigiFBAddressFmat;
#else
typedef struct {
  unsigned32 Addr:             24;
  unsigned32 pad0:              8;
} __GigiFBAddressFmat;
#endif

typedef __GigiFBAddressFmat __GigiFBBaseAddressFmat;
typedef __GigiFBAddressFmat __GigiFBPixelOffsetFmat;
typedef __GigiFBAddressFmat __GigiFBSourceOffsetFmat;
typedef __GigiFBAddressFmat __GigiFBWindowBaseFmat;
typedef __GigiFBAddressFmat __GigiFBWriteBaseFmat;
typedef __GigiFBAddressFmat __GigiFBSourceBaseFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad3:                   5;
  unsigned32 PatchMode:              2;
  unsigned32 pad2:                   2;
  signed32 RelativeOffset:           3;
  unsigned32 PackedData:             1;
  unsigned32 PatchEnable:            1;
  unsigned32 TexelInhibit:           1;
  unsigned32 WindowOrigin:           1;
  unsigned32 MessageType:            1;
  unsigned32 pad0:                   4;
  unsigned32 ReadDestinationEnable:  1;
  unsigned32 ReadSourceEnable:       1;
  unsigned32 PP2:                    3;
  unsigned32 PP1:                    3;
  unsigned32 PP0:                    3;
} __GigiFBReadModeFmat;
#else
typedef struct {
  unsigned32 PP0:                    3;
  unsigned32 PP1:                    3;
  unsigned32 PP2:                    3;
  unsigned32 ReadSourceEnable:       1;
  unsigned32 ReadDestinationEnable:  1;
  unsigned32 pad0:                   4;
  unsigned32 MessageType:            1;
  unsigned32 WindowOrigin:           1;
  unsigned32 TexelInhibit:           1;
  unsigned32 PatchEnable:            1;
  unsigned32 PackedData:             1;
  signed32 RelativeOffset:           3;
  unsigned32 pad2:                   2;
  unsigned32 PatchMode:              2;
  unsigned32 pad3:                   5;
} __GigiFBReadModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct { 
  unsigned32 pad3:                   5;
  unsigned32 PatchMode:              2;
  unsigned32 pad2:                   2;
  signed32 RelativeOffset:           3;
  unsigned32 PackedData:             1;
  unsigned32 PatchEnable:            1;
  unsigned32 pad1:                   1;
  unsigned32 WindowOrigin:           1;
  unsigned32 pad0:                   7;
  unsigned32 PP2:                    3;
  unsigned32 PP1:                    3;
  unsigned32 PP0:                    3;
} __GigiFBWriteConfigFmat;
#else
typedef struct { 
  unsigned32 PP0:                    3;
  unsigned32 PP1:                    3;
  unsigned32 PP2:                    3;
  unsigned32 pad0:                   7;
  unsigned32 WindowOrigin:           1;
  unsigned32 pad1:                   1;
  unsigned32 PatchEnable:            1;
  unsigned32 PackedData:             1;
  signed32 RelativeOffset:           3;
  unsigned32 pad2:                   2;
  unsigned32 PatchMode:              2;
  unsigned32 pad3:                   5;
} __GigiFBWriteConfigFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:             29;
  unsigned32 PixelSize:         3;
} __GigiFBPixelFmat;
#else
typedef struct {
  unsigned32 PixelSize:         3;
  unsigned32 pad1:             29;
} __GigiFBPixelFmat;
#endif

typedef __GigiFBPixelFmat __GigiFBReadPixelFmat;
typedef __GigiFBPixelFmat __GigiFBWritePixelFmat;

typedef __GigiUnsignedIntegerFmat __GigiFBReadPadFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:             28;
  unsigned32 UpLoadData:        1;
  unsigned32 pad0:              2;
  unsigned32 WriteEnable:       1;
} __GigiFBWriteModeFmat;
#else
typedef struct {
  unsigned32 WriteEnable:       1;
  unsigned32 pad0:              2;
  unsigned32 UpLoadData:        1;
  unsigned32 pad1:             28;
} __GigiFBWriteModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:             28;
  signed32 RelativeOffset:      3;
  unsigned32 DataPacking:       1;
} __GigiFBPackedDataModeFmat;
#else
typedef struct {
  unsigned32 DataPacking:       1;
  signed32 RelativeOffset:      3;
  unsigned32 pad0:             28;
} __GigiFBPackedDataModeFmat;
#endif

typedef __GigiUnsignedIntegerFmat __GigiFBFmat;

typedef __GigiFBFmat __GigiFBColorFmat;
typedef __GigiFBFmat __GigiFBDataFmat;
typedef __GigiFBFmat __GigiFBSourceDataFmat;

typedef __GigiUnsignedIntegerFmat __GigiFBHardwareWriteMaskFmat;
typedef __GigiUnsignedIntegerFmat __GigiFBBlockColorFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                 10;
  unsigned32 Offset:               22;
} __GigiTextureDownloadOffsetFmat;
#else
typedef struct {
  unsigned32 Offset:               22;
  unsigned32 pad0:                 10;
} __GigiTextureDownloadOffsetFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                         22;
  unsigned32 LogicOpLogicOp:              4;
  unsigned32 LogicOpEnable:               1;
  unsigned32 ColorDDAModeEnable:          1;
  unsigned32 FBWriteModeEnable:           1;
  unsigned32 FBReadModePackedData:        1;
  unsigned32 FBReadModeReadDestination:   1;
  unsigned32 FBReadModeReadSource:        1;
} __GigiConfigFmat;
#else
typedef struct {
  unsigned32 FBReadModeReadSource:        1;
  unsigned32 FBReadModeReadDestination:   1;
  unsigned32 FBReadModePackedData:        1;
  unsigned32 FBWriteModeEnable:           1;
  unsigned32 ColorDDAModeEnable:          1;
  unsigned32 LogicOpEnable:               1;
  unsigned32 LogicOpLogicOp:              4;
  unsigned32 pad:                         22;
} __GigiConfigFmat;
#endif

/*
**  GIGI Dither Registers
*/
#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:                 15;
  unsigned32 ColorFormatExtension:  1;
  unsigned32 pad0:                  2;
  unsigned32 ForceAlpha:            2;
  unsigned32 DitherMethod:          1;
  unsigned32 ColorOrder:            1;
  unsigned32 YOffset:               2;
  unsigned32 XOffset:               2;
  unsigned32 ColorFormat:           4;
  unsigned32 DitherEnable:          1;
  unsigned32 UnitEnable:            1;
} __GigiDitherModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:            1;
  unsigned32 DitherEnable:          1;
  unsigned32 ColorFormat:           4;
  unsigned32 XOffset:               2;
  unsigned32 YOffset:               2;
  unsigned32 ColorOrder:            1;
  unsigned32 DitherMethod:          1;
  unsigned32 ForceAlpha:            2;
  unsigned32 pad0:                  2;
  unsigned32 ColorFormatExtension:  1;
  unsigned32 pad1:                 15;
} __GigiDitherModeFmat;
#endif

/*
**  GIGI Logic Ops and WriteMask Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                   26;
  unsigned32 UseConstantFBWriteData:  1;
  unsigned32 LogicalOp:               4;
  unsigned32 LogicalOpEnable:         1;
} __GigiLogicalOpModeFmat;
#else
typedef struct {
  unsigned32 LogicalOpEnable:         1;
  unsigned32 LogicalOp:               4;
  unsigned32 UseConstantFBWriteData:  1;
  unsigned32 pad0:                   26;
} __GigiLogicalOpModeFmat;
#endif

typedef __GigiFBFmat __GigiFBWriteDataFmat;
typedef __GigiFBFmat __GigiFBSoftwareWriteMaskFmat;

/*
**  GIGI Host Out Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                16;
  unsigned32 Remainder:            2;
  unsigned32 Statistics:           2;
  unsigned32 Synchronization:      2;
  unsigned32 Color:                2;
  unsigned32 Stencil:              2;
  unsigned32 Depth:                2;
  unsigned32 Passive:              2;
  unsigned32 Active:               2;
} __GigiFilterModeFmat;
#else
typedef struct {
  unsigned32 Active:               2;
  unsigned32 Passive:              2;
  unsigned32 Depth:                2;
  unsigned32 Stencil:              2;
  unsigned32 Color:                2;
  unsigned32 Synchronization:      2;
  unsigned32 Statistics:           2;
  unsigned32 Remainder:            2;
  unsigned32 pad0:                16;
} __GigiFilterModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                26;
  unsigned32 Spans:                1;
  unsigned32 CompareFunction:      1;
  unsigned32 PassiveSteps:         1;
  unsigned32 ActiveSteps:          1;
  unsigned32 StatType:             1;
  unsigned32 Enable:               1;
} __GigiStatisticModeFmat;
#else
typedef struct {
  unsigned32 Enable:               1;
  unsigned32 StatType:             1;
  unsigned32 ActiveSteps:          1;
  unsigned32 PassiveSteps:         1;
  unsigned32 CompareFunction:      1;
  unsigned32 Spans:                1;
  unsigned32 pad0:                26;
} __GigiStatisticModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 InterruptEnable:      1;
  unsigned32 pad0:                31;
} __GigiSyncFmat;
#else
typedef struct {
  unsigned32 pad0:                31;
  unsigned32 InterruptEnable:      1;
} __GigiSyncFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           4;
  signed32 Y:               12;
  unsigned32 pad0:           4;
  signed32 X:               12;
} __GigiMinRegionFmat,
  __GigiMaxRegionFmat,
  __GigiMinHitRegionFmat,
  __GigiMaxHitRegionFmat;
#else
typedef struct {
  signed32 X:               12;
  unsigned32 pad0:           4;
  signed32 Y:               12;
  unsigned32 pad1:           4;
} __GigiMinRegionFmat,
  __GigiMaxRegionFmat,
  __GigiMinHitRegionFmat,
  __GigiMaxHitRegionFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                 30;
  unsigned32 BusyFlag:              1;
  unsigned32 PickFlag:              1;
} __GigiPickResultFmat;
#else
typedef struct {
  unsigned32 PickFlag:              1;
  unsigned32 BusyFlag:              1;
  unsigned32 pad0:                 30;
} __GigiPickResultFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                 12;
  unsigned32 screenbase:           20;
} __GigiSuspendUntilFrameBlankFmat;
#else
typedef struct {
  unsigned32 screenbase:           20;
  unsigned32 pad0:                 12;
} __GigiSuspendUntilFrameBlankFmat;
#endif

typedef __GigiUnsignedIntegerFmat __GigiResetPickResultFmat;

#if BIG_ENDIAN == 1
typedef struct {
    unsigned32 pad:                31;
    unsigned32 value:               1;
} __GigiPCITextureCacheFmat;
#else
typedef struct {
    unsigned32 value:               1;
    unsigned32 pad:                31;
} __GigiPCITextureCacheFmat;
#endif

typedef __GigiPCITextureCacheFmat __GigiPCIReadTextureCacheFmat;
typedef __GigiPCITextureCacheFmat __GigiPCIWriteTextureCacheFmat;

#endif /* GIGIREG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\glglobal.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: glglobal.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

//
// glglobal.h
//
// Common shared area for all components
#ifdef __GLGLOBAL
#pragma message ("FILE : "__FILE__" : Multiple inclusion")
#endif

#define __GLGLOBAL

// Registry locations
#define REGKEYROOT "SOFTWARE\\"
#define REGKEYDIRECTXSUFFIX "\\DirectX"
#define REGKEYDISPLAYSUFFIX "\\Display"
#define REGKEYVFWSUFFIX "\\VFW"

#define MAXCONTEXT      128
#define MAX_SUBBUFFERS  32 

// Max no of letters in the device name.
#define MAX_DEVICENAME_SIZE 32

// This many dwords to resend the bad regs every DMAA buffer
#define PERMEDIA_REV1_BAD_READBACK_REGISTER_SPACE       12      

#define GLINT_DMA 1
#define GLINT_NON_DMA 2
#define GLINT_FAKE_DMA 8
#define GLINT_UNKNOWN_INTERFACE 0xFF

// Definitions for the various chip types. 
#define VENDOR_ID_3DLABS    0x3D3D
#define VENDOR_ID_TI        0x104C

// Allof these ID's are guaranteed to fit into 16 bits
#define NOCHIP_ID           0x0
#define GLINT300SX_ID       0x1
#define GLINT500TX_ID       0x2
#define DELTA_ID            0x3
#define PERMEDIA_ID         0x4
#define TIPERMEDIA_ID       0x3d04      
#define GLINTMX_ID          0x6
#define TIPERMEDIA2_ID      0x3d07      // also known as P2C or P2A as of july 98
#define GAMMA_ID            0x8
#define PERMEDIA2_ID        0x9         // also known as P2V
#define PERMEDIA3_ID        0xa
#define GLINTR3_ID          0xb
#define PERMEDIA4_ID        0xc
#define GLINTR4_ID          0xd
#define GAMMA2_ID           0xe
#define GAMMA3_ID           0xf
#define GIGI_ID             0x8000
#define UNKNOWN_DEVICE_ID   0xffff

#define GLINTRX_ID          GLINTR3_ID

#define GLINT_ID            GLINT300SX_ID
#define P3R3_ID             PERMEDIA3_ID

#define PERMEDIA_SUBSYSTEM_ID       0x96
#define PERMEDIA_NT_SUBSYSTEM_ID    0x98
#define PERMEDIA_LC_SUBSYSTEM_ID    0x99
#define PERMEDIA2_SUBSYSTEM_ID      0xa0

// Pointer types - used in mini\pointer.c 
#define SOFTWARECURSOR 0
#define HARDWARECURSOR 1

#define GLINT300SX_REV1     (0      | (GLINT300SX_ID    << 16))
#define GLINT300SX_REV2     (2      | (GLINT300SX_ID    << 16))
#define GLINT500TX_REV1     (1      | (GLINT500TX_ID    << 16))
#define GLINTMX_REV1        (1      | (GLINTMX_ID          << 16))
#define DELTA_REV1          (1      | (DELTA_ID         << 16))
#define PERMEDIA_REV1       (1      | (PERMEDIA_ID      << 16))
#define TI_PERMEDIA_REV1    (1      | (TIPERMEDIA_ID    << 16))
#define PERMEDIA2_REV0      (0      | (PERMEDIA2_ID     << 16))
#define PERMEDIA2_REV1      (1      | (PERMEDIA2_ID     << 16))
#define TIPERMEDIA2_REV1    (1      | (TIPERMEDIA2_ID   << 16))
#define TIPERMEDIA2_REV2    (0x11   | (TIPERMEDIA2_ID   << 16))

#define PERMEDIA3_REV1      (1      | (PERMEDIA3_ID     << 16))
#define GLINTR3_REV1        (1      | (GLINTR3_ID       << 16))
#define PERMEDIA4_REV1      (1      | (PERMEDIA4_ID     << 16))
#define GLINTR4_REV1        (1      | (GLINTR4_ID       << 16))

#define GLINT_GETVERSION                1
#define GLINT_IOCTL_ADD_CONTEXT_MEMORY  2
#define GLINT_MEMORY_REQUEST            3
#define GLINT_16TO32_POINTER            4
#define GLINT_I2C                       5
#define GLINT_VMI_COMMAND               6
#define GLINT_FILE_IO                   7
// defined in demondef.h
//#define GLINT_DEMON_COMMAND           8
#define GLINT_SIMULATOR                 9
#define GLINT_GET_SOFT_ENGINE_INFO      6009

#define IOCTL_REGISTER_TEXTURE_HANDLER  0x20
#define IOCTL_REMOVE_TEXTURE_HANDLER    0x21

typedef struct {
    unsigned long   dwDevNode;
    unsigned long   Ring0EventHandle;   // Ring zero event handle to signal. Free'd by IOCTL on failure
}   REGISTERTEXTUREHANDLERIN, *PREGISTERTEXTUREHANDLERIN;

typedef struct {
    unsigned long   Handle;             // Returned handle
    unsigned long   Index;
}   REGISTERTEXTUREHANDLEROUT, *PREGISTERTEXTUREHANDLEROUT;

typedef struct {
    unsigned long   dwDevNode;
    unsigned long   Handle;             // Handle returned from IOCTL_REGISTER_TEXTURE_HANDLER
}   REMOVETEXTUREHANDLERIN, *PREMOVETEXTUREHANDLERIN;

typedef struct {
    unsigned long   Unused;
}   REMOVETEXTUREHANDLEROUT, *PREMOVETEXTUREHANDLEROUT;


// What is this request for?
#define GLINT_MEMORY_ALLOCATE           1
#define GLINT_MEMORY_FREE               2

typedef struct tagALLOCREQUEST
{
    unsigned long dwSize;
    unsigned long dwDevNode;
    unsigned long dwFlags;
    unsigned long dwBytes;
    unsigned long ptr16;    // in/out
    unsigned long ptr32;    // in/out
} ALLOCREQUEST, *LPALLOCREQUEST;

#define GLINT_I2C_READ                  0
#define GLINT_I2C_WRITE                 1
#define GLINT_I2C_RESET                 2
#define GLINT_I2C_DEVICE_PRESENT        3
#define GLINT_I2C_DETECT_DATA_LOW       4
#define GLINT_I2C_READ_NOBASEADDR       5
typedef struct tagI2CREQUEST
{
    unsigned long dwSize;
    unsigned long dwDevNode;
    unsigned long dwOperation;        // What do we want to do
    unsigned short wSlaveAddress;        // Slave we are talking to
    unsigned char NumItems;            // Number of items to send/receive
    unsigned char Data[256];            // Data to send/receive
    unsigned long dwReserved1;        // A reserved DWORD
    unsigned long dwReserved2;        // A reserved DWORD
    unsigned long dwReserved3;        // A reserved DWORD
    unsigned long dwReserved4;        // A reserved DWORD
} I2CREQUEST, *LPI2CREQUEST;

#define GLINT_VMI_READ                  0
#define GLINT_VMI_WRITE                 1
#define GLINT_VMI_GETMUTEX_A            2
#define GLINT_VMI_RELEASEMUTEX_A        3
typedef struct tagVMIREQUEST
{
    unsigned long dwSize;
    unsigned long dwDevNode;
    unsigned long dwOperation;        // What do we want to do
    unsigned long dwRegister;        // Register to talk to
    unsigned long dwCommand;        // Command to send
    unsigned long dwMutex;            // A reserved DWORD
    unsigned long dwReserved2;        // A reserved DWORD
    unsigned long dwReserved3;        // A reserved DWORD
    unsigned long dwReserved4;        // A reserved DWORD
} VMIREQUEST, *LPVMIREQUEST;

#define _UNKNOWN_STREAM_CARD                    0
#define _3DLBROOKTREE_DAUGHTER_INRESET          1
#define _3DLBROOKTREE_DAUGHTER                  2
#define _3DLRESERVED                            3
#define _GENERIC_BROOKTREE868_DAUGHTER_8BITS    4
#define _GENERIC_BROOKTREE868_DAUGHTER_16BITS   5
#define _3DLCHRONTEL_BROOKTREE_DAUGHTER         6
#define _3DLCHRONTEL_SAMSUNG_DAUGHTER           7
#define _GENERIC_CHRONTEL_DAUGHTER_8BITS        8
#define _GENERIC_CHRONTEL_DAUGHTER_16BITS       9


#define GLINT_TVOUT_ENABLED             0
#define GLINT_TVOUT_UPDATE_QUALITY      1
#define GLINT_TVOUT_UPDATE_MODE         2
#define GLINT_TVOUT_UPDATE_POSITION     3

typedef struct tagTVOUTREQUEST
{
    unsigned long dwSize;
    unsigned long dwDevNode;
    unsigned long dwOperation;        // What do we want to do
    unsigned long dwReturnVal;        // Returned value
    unsigned long dwSendVal;        // A sent value
    unsigned long dwReserved1;        // A reserved DWORD
    unsigned long dwReserved2;        // A reserved DWORD
    unsigned long dwReserved3;        // A reserved DWORD
    unsigned long dwReserved4;        // A reserved DWORD
} TVOUTREQUEST, *LPTVOUTREQUEST;


// Initialize VFW (turn off DisplayDriver heap, enable DDRAW, etc)
#define GLINT_VFW_INIT                          1

// De-Initialize VFW (re-enable DisplayDriver heap, etc)
#define GLINT_VFW_CLOSE                         2

// Setup the Streaming capture buffers
// Takes a width and height, returns the stride and locations of the buffers
#define GLINT_VFW_BUFFER_SETUP                  3

// Capture the current buffer
// Takes src and dest rects and a bitmap to upload to.
// Returns the time at which it was captured relative to the clock reset
#define GLINT_VFW_BUFFER_CAPTURE                4

// No longer used
#define GLINT_VFW_RESERVED1                     5
#define GLINT_VFW_RESERVED2                     6

// Starts the streaming capture by initializing interrupts
#define GLINT_VFW_STREAM_START                  7

// Stops the streaming capture by stopping interrupts
#define GLINT_VFW_STREAM_STOP                   8

// Resets the clock.  This is used at the start of the streaming.
// Takes a flag to say wether the clock is timed on PAL or NTSC
#define GLINT_VFW_RESETCLOCK                    9

// Gets the current elapsed time
#define GLINT_VFW_GETTIME                       10

// Sets up the stretch buffer - this doesn't have to succeed for the capture
// to work.  Performance is helped if is does succeed.
#define GLINT_VFW_STRETCHBUFFER_SETUP           11

// Starts and stops the video run (will cause interrupts to be turned on/off)
#define GLINT_VFW_START_VIDEO               12
#define GLINT_VFW_STOP_VIDEO                    13

// Gets the IRQ that the VFW driver should use
#define GLINT_VFW_GET_IRQ                       14

typedef struct tagVFWREQUEST
{
    // Sent values
    unsigned long dwSize;
    unsigned long dwDevNode;
    unsigned long dwOperation;        // What do we want to do

    // For buffer allocations
    unsigned long dwWidth;            // Width of the requested buffer
    unsigned long dwHeight;            // Height of the requested buffer

    // For the upload operations
    unsigned long dwBitmapWidth;    // Width of the bitmap used when uploading
    unsigned long fpBuffer;            // Buffer to copy into
    unsigned long dwSrcLeft;        // Source Rect for the operation
    unsigned long dwSrcRight;
    unsigned long dwSrcTop;
    unsigned long dwSrcBottom;

    unsigned long dwDestLeft;        // Dest Rect for the operation
    unsigned long dwDestRight;
    unsigned long dwDestTop;
    unsigned long dwDestBottom;

    unsigned long dwSrcBPP;            // Source BPP
    unsigned long dwDestBPP;        // Destination BPP
    unsigned long bSrcYUV;            // Source is YUV?  No need for dest as VFW only know YVU9
                                    // and we don't do that format
    // Various config settings
    unsigned long bEurope;            // Is this PAL or NTSC?
    unsigned long bFilterVideo;        // Should we filter the video?
    unsigned long bBobVideo;        // Should we try to bob on the upload?
            
    // Return values
    unsigned long dwStride;            // Stride of the setup buffers
    unsigned long dwAddress0;        // Address of buffer 0
    unsigned long dwAddress1;        // Address of buffer 0
    unsigned long dwAddress2;        // Address of buffer 0
    unsigned long dwCurrentTime;    // The current time in milliseconds (0 based) from the reset of the clock
    unsigned long dwIRQ;            // The current IRQ to use
    unsigned long dwVFWCallback;    // Callback function for interrupt
} VFWREQUEST, *LPVFWREQUEST;

// File IO VxD requests

#define GLINT_FIO_OPEN      0
#define GLINT_FIO_READ      1
#define GLINT_FIO_WRITE     2
#define GLINT_FIO_SIZE      3
#define GLINT_FIO_CLOSE     4

typedef struct tagFIOREQUEST
{
    unsigned long dwSize;
    unsigned long dwDevNode;
    unsigned long dwOperation;        // What do we want to do
    unsigned long dwHandle;
    unsigned long dwBuff;
    unsigned long dwBuffLen;
    unsigned long dwOffset;
} FIOREQUEST, *LPFIOREQUEST;

// P3 Csim requests

#define GLINT_SSD_STARTDMA                  0
#define GLINT_SSD_READBACK                  1
#define GLINT_SSD_GETOUTPUTDWORDS           2
#define GLINT_SSD_SETOUTPUTFIFO             3
#define GLINT_SSD_SETLOGFILENAME            4
#define GLINT_SSD_WRITETOLOGFILE            5
#define GLINT_SSD_WRITEFIFO                 6
#define GLINT_SSD_OPENLOGFILE               7
#define GLINT_SSD_CLOSELOGFILE              8
#define GLINT_SSD_WRITETOLOGFILEMULTIPLE    9

typedef struct tagSIMREQUEST
{
    unsigned long dwSize;
    unsigned long dwOperation;        // What do we want to do
    unsigned long dwAddr;
    unsigned long dwTagCount;
    unsigned long dwData;
} SIMREQUEST, *LPSIMREQUEST;


// Defines for texture semaphore signalling.
// Usage: Semaphore index = ((Logical Address) >> TEXTURE_SEMAPHORE_SHIFT) & TEXTURE_SEMAPHORE_MASK
// Currently 6 bits of semaphore, 14 bits of texture handle
#define MAX_TEXTUREHANDLERS     64
#define TEXTURE_HANDLER_SHIFT   26
#define TEXTURE_HANDLER_MASK    0x3f
typedef struct {
    unsigned long ThreadHandle;
    unsigned long ThreadEvent;
    unsigned long ThreadFlags;
    unsigned long ThreadTime;
}   TEXTUREHANDLER, *PTEXTUREHANDLER;



#define CONTEXT_GENERIC         0
#define CONTEXT_GLINT300SX      1
#define CONTEXT_GLINT500TX      2
#define CONTEXT_DELTA           3
#define CONTEXT_PERMEDIA        4
#define CONTEXT_GLINTMX         6
#define CONTEXT_PERMEDIA2       7
#define CONTEXT_PERMEDIA3       8
#define CONTEXT_GLINT_FAMILY    0x4000
#define CONTEXT_PERMEDIA_FAMILY 0x4001
#define CONTEXT_GIGI            0x8000
#define CONTEXT_ENDOFBLOCK      0xffff

// Some well known context and template handles.
#define CONTEXT_TEMPLATE_DISPLAY_HANDLE      0
#define CONTEXT_TEMPLATE_DIRECTDRAW_HANDLE   1
#define CONTEXT_TEMPLATE_ALLREADABLE_HANDLE  2
#define CONTEXT_TEMPLATE_DIRECT3D_HANDLE     3
#define CONTEXT_DISPLAY_HANDLE             4  
#define CONTEXT_DIRECTX_HANDLE               5
#define CONTEXT_NONE                         0xffff

#define P3RX_CONTEXT_MASK   0xfffeffff  // Everything except TextureManagement
#define P3_CONTEXTDUMP_SIZE 744         // 744 regisiters for above mask.

// #define P3RX_CONTEXT_MASK    0xffffffff  // Everything except TextureManagement
// #define P3_CONTEXTDUMP_SIZE  753         // 744 regisiters for above mask.

#define INVALID_D3D_HANDLE 0

#define MAX_CONTEXTS_IN_BLOCK 32
#define NPAGES_IN_CONTEXT_BLOCK 6
#define SIZE_OF_CONTEXT_BLOCK (NPAGES_IN_CONTEXT_BLOCK * PAGESIZE)

#define SIZE_CONFIGURATIONBASE 32
#define MAX_QUEUE_SIZE (MAX_SUBBUFFERS + 2)

// commands to the interrupt controller on the next VBLANK
typedef enum {
    NO_COMMAND = 0,
    COLOR_SPACE_BUFFER_0,
    COLOR_SPACE_BUFFER_1,
    GLINT_RACER_BUFFER_0,
    GLINT_RACER_BUFFER_1
} VBLANK_CONTROL_COMMAND;

// interrupt status bits
typedef enum {
    DMA_INTERRUPT_AVAILABLE     = 0x1, // can use DMA interrupts
    VBLANK_INTERRUPT_AVAILABLE  = 0x02, // can use VBLANK interrupts
    SUSPEND_DMA_TILL_VBLANK     = 0x04, // Stop doing DMA till after next VBLANK
} INTERRUPT_CONTROL;

typedef enum {
    DIRECTX_LASTOP_UNKNOWN = 0,
    DIRECTX_LASTOP_2D,
} DIRECTX_STATE;

// bit definitions for the status words in GlintBoardStatus[]:
// Currently used to indicate sync and DMA status. We have the following rules:
// synced means no outstanding DMA as well as synced. DMA_COMPLETE means n
// outstanding DMA but not necessarily synced. Thus when we do a wait on DMA
// complete we turn off the synced bit.
// XXX for the moment we don't use the synced bit as it's awkward to see where
// to unset it - doing so for every access to the chip is too expensive. We
// probably need a "I'm about to start downloading to the FIFO" macro which
// gets put at the start of any routine which writes to the FIFO.
//
#define GLINT_SYNCED                0x01
#define GLINT_DMA_COMPLETE          0x02    // set when there is no outstanding DMA
#define GLINT_INTR_COMPLETE         0x04
#define GLINT_INTR_CONTEXT          0x08    // set if the current context is interrupt enabled
#define GLINT_2D_CHANGING           0x10    // set if 2D context is modifying pending fields

typedef struct __ContextTable {
    unsigned long   pNextContext;
    unsigned short  pNextContext16;
    unsigned short  nInBlock;
    unsigned short  nUsed;
    unsigned short  FirstFree;
    unsigned short  nFree;
    unsigned short  COffset[MAX_CONTEXTS_IN_BLOCK];
    signed short    CSize[MAX_CONTEXTS_IN_BLOCK];
    unsigned short  CTemplate[MAX_CONTEXTS_IN_BLOCK];
    unsigned short  CEndIndex[MAX_CONTEXTS_IN_BLOCK];
    unsigned short  CType[MAX_CONTEXTS_IN_BLOCK];
    unsigned short  CD3DHandle[MAX_CONTEXTS_IN_BLOCK];
}   CONTEXTTABLE, *PCONTEXTTABLE;


// For holding information about a single DMA Buffer
typedef struct tagDMAPartition
{
    unsigned long PhysAddr;        // Physical ddress of this sub-buffer
#ifndef WIN32
    //int              pad1;
#endif
    ULONG * VirtAddr;        // Virtual address of this sub-buffer
#ifndef WIN32
    //int              pad2;
#endif
    ULONG_PTR MaxAddress;    // Maximum address of this sub-buffer
#ifndef WIN32
    //int              pad3;
#endif
    unsigned short Locked;
    unsigned short bStampedDMA;    // Has the VXD Stamped the DMA buffer?
} P3_DMAPartition;

typedef struct _att21505off
{
    unsigned char WriteAddr1;       // 0000
    unsigned char PixelColRam;      // 0001
    unsigned char PixelRdMask;      // 0010
    unsigned char ReadAdd1;         // 0011
    unsigned char WriteAddr2;       // 0100
    unsigned char CursorColRam;     // 0101
    unsigned char Ctrl0;            // 0110
    unsigned char ReadAdd2;         // 0111
    unsigned char Ctrl1;            // 1000
    unsigned char Ctrl2;            // 1001
    unsigned char Status;           // 1010
    unsigned char CursorPattern;    // 1011
    unsigned char CursorXLow;       // 1100
    unsigned char CursorXHigh;      // 1101
    unsigned char CursorYLow;       // 1110
    unsigned char CursorYHigh;      // 1111
} ATT21505OFF;

typedef struct _DMAQueue
{
    unsigned long       dwContext;      // context for fragment
    unsigned long       dwSize;         // size of it (DWORDs)
    unsigned long       dwPhys;         // physical address
    unsigned long       dwEvent;        // event if required
} DMAQUEUE;

typedef struct _ContextRegs
{
    unsigned short      wNumRegs;
    unsigned short      wFirstReg[1];
} CONTEXTREGS;

typedef struct _VDDDISPLAYINFO {
    unsigned short ddiHdrSize;
    unsigned short ddiInfoFlags;        
    unsigned long  ddiDevNodeHandle;
    unsigned char  ddiDriverName[16];
    unsigned short ddiXRes;            
    unsigned short ddiYRes;            
    unsigned short ddiDPI;            
    unsigned char  ddiPlanes;    
    unsigned char  ddiBpp;    
    unsigned short ddiRefreshRateMax;    
    unsigned short ddiRefreshRateMin;    
    unsigned short ddiLowHorz;        
    unsigned short ddiHighHorz;        
    unsigned short ddiLowVert;        
    unsigned short ddiHighVert;        
    unsigned long  ddiMonitorDevNodeHandle;
    unsigned char  ddiHorzSyncPolarity;    
    unsigned char  ddiVertSyncPolarity;

    //
    // new 4.1 stuff
    //
    unsigned long  diUnitNumber;             // device unit number
    unsigned long  diDisplayFlags;           // mode specific flags
    unsigned long  diXDesktopPos;            // position of desktop
    unsigned long  diYDesktopPos;            // ...
    unsigned long  diXDesktopSize;           // size of desktop (for panning)
    unsigned long  diYDesktopSize;           // ...

} VDDDISPLAYINFO;

typedef struct _GlintInfo
{
#ifndef  WNT_DDRAW
    unsigned long           dwDevNode;            // The VXD's DevNode

    // Pointers
    unsigned long           dwDSBase;           // 32 bit base of data seg

    unsigned long           dwpRegisters;      
    unsigned long           dwpFrameBuffer;    
    unsigned long           dwpLocalBuffer;      

    // Chip Information
    unsigned long           dwRamDacType; 
#endif  // WNT_DDRAW

    volatile unsigned long  dwFlags;        
    unsigned long           ddFBSize;            // frame buffer size
    unsigned long           dwScreenBase;       // Screen base value for the screen
    unsigned long           dwOffscreenBase;    // Start of Offscreen heap   

    // TV Out support
    unsigned long           bTVEnabled;
    unsigned long           bTVPresent;
    unsigned long           dwStreamCardType;
    unsigned long           dwVSBLastAddressIndex;
    unsigned long           dwBaseOffset;
    unsigned long           dwMacroVision;

    // Driver information
#ifndef  WNT_DDRAW
    unsigned long           dwVideoMemorySize;
#endif  // WNT_DDRAW
    unsigned long           dwScreenWidth;
    unsigned long           dwScreenHeight;
    unsigned long           dwVideoWidth;
    unsigned long           dwVideoHeight;
    unsigned long           dwBpp;
    unsigned long           dwScreenWidthBytes;
    unsigned char           bPixelToBytesShift;
#ifdef W95_DDRAW
    unsigned char           bPad1[3];
#endif
    ULONG_PTR               pRegs;
    unsigned long           PixelClockFrequency;
    unsigned long           MClkFrequency;

    // Chip information. This should be filled out as much as
    // possible. We may not know all the information though.
    unsigned long           dwRenderChipID;
    unsigned long           dwRenderChipRev;   
    unsigned long           dwRenderFamily;
    unsigned long           dwGammaRev;
    unsigned long           dwTLChipID;
    unsigned long           dwTLFamily;
#ifndef  WNT_DDRAW
    unsigned long           dwSupportChipID;  
    unsigned long           dwSupportChipRev;  
    unsigned long           dwBoardID;        
    unsigned long           dwBoardRev;       
#endif  // WNT_DDRAW

    unsigned short          DisabledByGLDD;
#ifdef W95_DDRAW
    unsigned short          wPad2;
#endif
    unsigned long           bDXDriverEnabled;
    unsigned long           bDRAMBoard;

    // DirectDraw and Direct3D DMA state
    unsigned long           InterfaceType;
    unsigned long           CurrentPartition;
    unsigned long           NumberOfSubBuffers;
    P3_DMAPartition         DMAPartition[MAX_SUBBUFFERS];
    ULONG * volatile      CurrentBuffer;                    // Current BufferPointer
    ULONG_PTR               dwDirectXState;
    unsigned long           dwDMAFlushCount;

    // DMA information
    unsigned long           dw3DDMABufferSize;                // size of dma buffer
    unsigned long           dw3DDMABufferPhys;                // physical addresses of buffer
    ULONG_PTR               dw3DDMABufferVirt;                // virtual ring 0 address

    // index offsets into the queue for the front, back and end. Using separate
    // front and back offsets allows the display driver to add and the interrupt
    // controller to remove entries without a need for locking code.
    volatile unsigned long  frontIndex;
    volatile unsigned long  backIndex;
    unsigned long           endIndex;
    unsigned long           maximumIndex;

    // Debugging info. Spots possible memory leaks.
    unsigned long           iSurfaceInfoBlocksAllocated;

#ifndef  WNT_DDRAW
    unsigned long           dwVideoControl;
    unsigned long           dwDeviceHandle;
    char                    szDeviceName[16];
    unsigned long           dwCurrentContext;
    unsigned long           GlintBoardStatus;

    //
    // Some overlay related variable which should be shared with mini port
    //

    volatile ULONG          bOverlayEnabled;                // TRUE if the overlay is on at all
    volatile ULONG          bVBLANKUpdateOverlay;           // TRUE if the overlay needs to be updated by the VBLANK routine.
    volatile ULONG          VBLANKUpdateOverlayWidth;       // overlay width (updated in vblank)
    volatile ULONG          VBLANKUpdateOverlayHeight;      // overlay height (updated in vblank)

#endif  // WNT_DDRAW

} GlintInfo, *LPGLINTINFO;


// Config register
#define PM_CHIPCONFIG_AGPSIDEBAND  (1 << 8)
#define PM_CHIPCONFIG_AGP1XCAPABLE (1 << 9)
#define PM_CHIPCONFIG_AGP2XCAPABLE (1 << 10)
#define PM_CHIPCONFIG_AGP4XCAPABLE (1 << 11)

// Gamma config
#define G1_CHIPCONFIG_AGPSIDEBAND  (1 << 1)
#define G1_CHIPCONFIG_AGP1XCAPABLE (1 << 0)

// DAC types

#define RamDacRGB525    1           // value for RGB525
#define RamDacATT       2           // value for AT&T 21505
#define RamDacTVP3026   3           // TI TVP 3026 (Accel board)

// Board types

#define BID_MONTSERRAT  0
#define BID_RACER       1
#define BID_ACCEL       2

// definitions for dwFlags
// Glint Interrupt Control Bits
//
// InterruptEnable register
#define INTR_DISABLE_ALL                0x00
#define INTR_ENABLE_DMA                 0x01
#define INTR_ENABLE_SYNC                0x02
#define INTR_ENABLE_EXTERNAL            0x04
#define INTR_ENABLE_ERROR               0x08
#define INTR_ENABLE_VBLANK              0x10
#define INTR_ENABLE_SCANLINE            0x20
#define INTR_TEXTURE_DOWNLOAD           0x40
#define INTR_ENABLE_BYDMA               0x80
#define INTR_ENABLE_VIDSTREAM_B         0x100
#define INTR_ENABLE_VIDSTREAM_A         0x200

// InterruptFlags register
#define INTR_DMA_SET                    0x01
#define INTR_SYNC_SET                   0x02
#define INTR_EXTERNAL_SET               0x04
#define INTR_ERROR_SET                  0x08
#define INTR_VBLANK_SET                 0x10
#define INTR_SCANLINE_SET               0x20
#define INTR_BYDMA_SET                  0x80
#define INTR_VIDSTREAM_B_SET            0x100
#define INTR_VIDSTREAM_A_SET            0x200

#define INTR_CLEAR_ALL                  0x1f
#define INTR_CLEAR_DMA                  0x01
#define INTR_CLEAR_SYNC                 0x02
#define INTR_CLEAR_EXTERNAL             0x04
#define INTR_CLEAR_ERROR                0x08
#define INTR_CLEAR_VBLANK               0x10
#define INTR_CLEAR_SCANLINE             0x20
#define INTR_CLEAR_BYDMA                0x80
#define INTR_CLEAR_VIDSTREAM_B          0x100
#define INTR_CLEAR_VIDSTREAM_A          0x200

#define GMVF_REV2                     0x00000001 // chip is rev 2
#define GMVF_FFON                     0x00000002 // fast fill enabled
#define GMVF_NOIRQ                    0x00000004 // IRQ disabled
#define GMVF_SETUP                    0x00000008 // primitive setup in progress
#define GMVF_GCOP                     0x00000010 // something is using 4K area (affects mouse)
#define GMVF_DMAIP                    0x00000020 // DMA started

#define GMVF_565                      0x00000080 // Run in 565 mode
#define GMVF_DELTA                    0x00000100 // using delta
#define GMVF_8BPPRGB                  0x00000200 // use 322 RGB at 8bpp
#define GMVF_DISABLE_OVERLAY          0x00000400 // Disable overlay on P4
#define GMVF_SWCURSOR                 0x00000800 // Never use a hardware cursor
#define GMVF_INTCPTGDI                0x00001000 // Intercept GDI mode
#define GMVF_OFFSCRNBM                0x00002000 // Offscreen BitMaps mode
#define GMVF_HWWRITEMASK              0x00004000 // Offscreen BitMaps mode
#define GMVF_ALLOWP2VLUT              0x00008000 // Driver says P2V LUTs will work
#define GMVF_VBLANK_OCCURED           0x00010000 // VBlank has occured
#define GMVF_VBLANK_ENABLED           0x00020000 // VBlank interrupt is enabled
#define GMVF_VSA_INTERRUPT_OCCURED    0x00040000 // VPort interrupt has occured
#define GMVF_FRAME_BUFFER_IS_WC       0x00080000 // Frame buffer is write-combined
#define GMVF_CAN_USE_AGP_DMA          0x00100000 // DMA buffers allocated with WC
#define GMVF_32BIT_SPANS_ALIGNED      0x00200000 // Must align 32bpp spans.
#define GMVF_DFP_DISPLAY              0x00400000 // DFP is connected
#define GMVF_QDMA                     0x00800000 // 2D using QDMA system
#define GMVF_GAMMA                    0x01000000 // using gamma chip
#define GMVF_NODMA                    0x02000000 // DMA disabled
#define GMVF_COLORTRANSLATE           0x04000000 // Set if Chip can translate colors
#define GMVF_MMX_AVAILABLE            0x08000000 // Set if processor has MMX
#define GMVF_EXPORT24BPP              0x10000000 // Set if we should export 24bpp modes
#define GMVF_DONOTRESET               0x20000000 
#define GMVF_TRYTOVIRTUALISE4PLANEVGA 0x40000000 // Set if we should try to virtualise 4 plane VGA
#define GMVF_VIRTUALISE4PLANEVGA      0x80000000 // Set if we are virtualising 4 plane VGA modes.


// Cap for the maximum FIFO entries read back on a P3/R3 chip
#define MAX_P3_FIFO_ENTRIES 120

#ifndef MINIVDD
extern unsigned long CreateContext(struct tagThunkedData* pThisDisplay,
                                            LPGLINTINFO, unsigned long, unsigned short, unsigned short );
extern void _cdecl ChangeContext(struct tagThunkedData* pThisDisplay, LPGLINTINFO, unsigned long);
extern void DeleteContext(struct tagThunkedData* pThisDisplay, LPGLINTINFO, unsigned long);
extern void _cdecl SetEndIndex(LPGLINTINFO, unsigned long, unsigned short);
extern void StartDMAProper( struct tagThunkedData*, LPGLINTINFO, unsigned long, unsigned long, unsigned long );
#endif

#define MINIVDD_REGISTERDISPLAYDRIVER_BASE  0x1000
// Definitions for RegisterDisplayDriver options
#define MINIVDD_SHAREGLINFO         MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x00
#define MINIVDD_INITIALISEMODE      MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x01
#define MINIVDD_GETGLINFO           MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x02

#define MINIVDD_ALLOCATEMEMORY      MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x10
#define MINIVDD_FREEMEMORY          MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x11

#define MINIVDD_GETREGISTRYKEY      MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x20

// For free and allocating memory and selectors for use on the
// 16 bit side.
#define MINIVDD_MEMORYREQUEST       MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x30

// For sending I2C data across the bus
#define MINIVDD_I2CREQUEST          MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x40

// For sending VMI data to the VideoPort
#define MINIVDD_VMIREQUEST          MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x41

// For talking to the video demon
#define MINIVDD_DEMONREQUEST        MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x42

// For sending Video For Windows commands
#define MINIVDD_VFWREQUEST          MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x43

// For Multi-monitor support
#define MINIVDD_ENABLEINTERRUPTS    MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x50
#define MINIVDD_DISABLEINTERRUPTS   MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x51

#define MINIVDD_TVOUTREQUEST        MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x60

//#ifdef P3_CSIMULATOR
#define MINIVDD_SENDDMABUFFER       MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x100
#define MINIVDD_SETDMABUFFEROUT     MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x101
#define MINIVDD_GETOUTDMACOUNT      MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x102
#define MINIVDD_SETTESTNAME         MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x103
#define MINIVDD_WRITETAGDATATOFIFO  MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x104
#define MINIVDD_READBACKDMAADDR     MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x105
#define MINIVDD_SETDMAADDR          MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x106
//#endif

#define REG_HKLM_PREFIX             0x01
#define REG_HKU_PREFIX              0x02
#define REG_HKCU_PREFIX             0x03
#define REG_HKCR_PREFIX             0x04
#define REG_HKCC_PREFIX             0x05
#define REG_HKDD_PREFIX             0x06
#define REG_DEVNODEDEFAULTPREFIX    0x07
#define REG_DEVNODEPREFIX           0x08

#define REGTYPE_STRING              0x100
#define REGTYPE_BINARY              0x300
#define REGTYPE_DWORD               0x400

// Defines for the offsets of regions within the Data Segment:
#define DATA_SEGMENT_OFFSET         0x0
#define GLINT_REGISTERS_OFFSET      0x10000
#define DMA_UPLOAD_2D               0x30000
#define DMA_BUFFER_3D               0x38000
#define FONT_CACHE_OFFSET           0x180000
#define FINAL_DATA_SEGMENT_SIZE     0x280000

// Defines the maximum size of the regions
#define DATA_SEGMENT_SIZE           GLINT_REGISTERS_OFFSET - DATA_SEGMENT_OFFSET
#define GLINT_REGISTERS_SIZE        DMA_UPLOAD_2D - GLINT_REGISTERS_OFFSET
#define DMA_UPLOAD_2D_SIZE          DMA_BUFFER_3D - DMA_UPLOAD_2D
#define DMA_BUFFER_3D_SIZE          FONT_CACHE_OFFSET - DMA_BUFFER_3D
#define FONT_CACHE_SIZE             FINAL_DATA_SEGMENT_SIZE - FONT_CACHE_OFFSET

// How much will we allow for 2D when it's using the 3D DMA buffer? And
// how much can we send in one DMA? Increasing this gives a small 
// performance improvement on a P2.

#define MAX_2D_DMA_USE              DMA_BUFFER_3D_SIZE
#define MAX_DMA_COUNT               0xffff
#define MIN_2D_DMA_BUFFER_SIZE      0x10000
#define MAX_2D_DMA_BUFFER_SIZE      0x60000

// Various independant things that can disable the offscreen bitmap heap.
#define D3D_DISABLED    1
#define DRIVER_DISABLED 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\glintdef.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: glintdef.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

//************************************************************************
// *
// * DESCRIPTION  : Register Field Values for Permedia 3
// *
// ***********************************************************************

#define __PERMEDIA_ENABLE                                       1
#define __PERMEDIA_DISABLE                                      0

// From FBReadMode
#define __GLINT_8BITPIXEL                                       0
#define __GLINT_16BITPIXEL                                      1 
#define __GLINT_32BITPIXEL                                      2
#define __GLINT_4BITPIXEL                                       3
#define __GLINT_24BITPIXEL                                      4

/* Host out (Filter) options. */
#define __GLINT_FILTER_TAG                                    0x1 
#define __GLINT_FILTER_DATA                                   0x2
#define __GLINT_FILTER_TAG_AND_DATA                           0x3

/* Rasterization */
#define __GLINT_LINE_PRIMITIVE                                  0
#define __GLINT_TRAPEZOID_PRIMITIVE                             1
#define __GLINT_POINT_PRIMITIVE                                 2

#define __GLINT_FLAT_SHADE_MODE                                 0
#define __GLINT_GOURAUD_SHADE_MODE                              1

#define __GLINT_START_BIAS_ZERO                                 0
#define __GLINT_START_BIAS_HALF                                 1
#define __GLINT_START_BIAS_ALMOST_HALF                          2

/* Stipple */
#define __GLINT_AREA_STIPPLE_2_PIXEL_PATTERN                    0
#define __GLINT_AREA_STIPPLE_4_PIXEL_PATTERN                    1
#define __GLINT_AREA_STIPPLE_8_PIXEL_PATTERN                    2
#define __GLINT_AREA_STIPPLE_16_PIXEL_PATTERN                   3
#define __GLINT_AREA_STIPPLE_32_PIXEL_PATTERN                   4

/* Alpha Test */
#define __GLINT_ALPHA_COMPARE_MODE_NEVER                        0
#define __GLINT_ALPHA_COMPARE_MODE_LESS                         1
#define __GLINT_ALPHA_COMPARE_MODE_EQUAL                        2
#define __GLINT_ALPHA_COMPARE_MODE_LESS_OR_EQUAL                3
#define __GLINT_ALPHA_COMPARE_MODE_GREATER                      4
#define __GLINT_ALPHA_COMPARE_MODE_NOT_EQUAL                    5
#define __GLINT_ALPHA_COMPARE_MODE_GREATER_OR_EQUAL             6
#define __GLINT_ALPHA_COMPARE_MODE_ALWAYS                       7

/* Chroma Test Mode */
#define __GLINT_CHROMA_FBSOURCE                                 0
#define __GLINT_CHROMA_FBDATA                                   1
#define __GLINT_CHROMA_INPUT_COLOR                              2
#define __GLINT_CHROMA_OUTPUT_COLOR                             3
#define __GLINT_CHROMA_INCLUDE                                  0
#define __GLINT_CHROMA_EXCLUDE                                  1

/* Texture Filter Mode */
#define __GLINT_TEXTUREFILTER_ALPHAMAPSENSE_INCLUDE             0
#define __GLINT_TEXTUREFILTER_ALPHAMAPSENSE_EXCLUDE             1

/* Local buffer read */ 
#define __GLINT_LBDEFAULT                                       0
#define __GLINT_LBSTENCIL                                       1
#define __GLINT_LBDEPTH                                         2

#define __GLINT_TOP_LEFT_WINDOW_ORIGIN                          0
#define __GLINT_BOTTOM_LEFT_WINDOW_ORIGIN                       1

#define __GLINT_DEPTH_WIDTH_16                                  0
#define __GLINT_DEPTH_WIDTH_24                                  1
#define __GLINT_DEPTH_WIDTH_32                                  2
#define __GLINT_DEPTH_WIDTH_15                                  3

/* Stencil Test */
#define __GLINT_STENCIL_COMPARE_MODE_NEVER                      0
#define __GLINT_STENCIL_COMPARE_MODE_LESS                       1
#define __GLINT_STENCIL_COMPARE_MODE_EQUAL                      2
#define __GLINT_STENCIL_COMPARE_MODE_LESS_OR_EQUAL              3
#define __GLINT_STENCIL_COMPARE_MODE_GREATER                    4
#define __GLINT_STENCIL_COMPARE_MODE_NOT_EQUAL                  5
#define __GLINT_STENCIL_COMPARE_MODE_GREATER_OR_EQUAL           6
#define __GLINT_STENCIL_COMPARE_MODE_ALWAYS                     7

#define __GLINT_STENCIL_METHOD_KEEP                             0
#define __GLINT_STENCIL_METHOD_ZERO                             1
#define __GLINT_STENCIL_METHOD_REPLACE                          2
#define __GLINT_STENCIL_METHOD_INCR                             3
#define __GLINT_STENCIL_METHOD_DECR                             4
#define __GLINT_STENCIL_METHOD_INVERT                           5
#define __GLINT_STENCIL_METHOD_INCR_WRAP                        6
#define __GLINT_STENCIL_METHOD_DECR_WRAP                        7

/* Depth Test */
#define __GLINT_DEPTH_SOURCE_DDA                                0
#define __GLINT_DEPTH_SOURCE_SOURCE_DEPTH                       1
#define __GLINT_DEPTH_SOURCE_DEPTH_MSG                          2
#define __GLINT_DEPTH_SOURCE_LBSOURCEDATA_MSG                   3

#define __GLINT_DEPTH_COMPARE_MODE_NEVER                        0
#define __GLINT_DEPTH_COMPARE_MODE_LESS                         1
#define __GLINT_DEPTH_COMPARE_MODE_EQUAL                        2
#define __GLINT_DEPTH_COMPARE_MODE_LESS_OR_EQUAL                3
#define __GLINT_DEPTH_COMPARE_MODE_GREATER                      4
#define __GLINT_DEPTH_COMPARE_MODE_NOT_EQUAL                    5
#define __GLINT_DEPTH_COMPARE_MODE_GREATER_OR_EQUAL             6
#define __GLINT_DEPTH_COMPARE_MODE_ALWAYS                       7

/* Texture AddressMode */
#define __GLINT_TEXADDRESS_WRAP_CLAMP                           0
#define __GLINT_TEXADDRESS_WRAP_REPEAT                          1
#define __GLINT_TEXADDRESS_WRAP_MIRROR                          2
#define __GLINT_TEXADDRESS_OPERATION_2D                         0
#define __GLINT_TEXADDRESS_OPERATION_3D                         1
#define __GLINT_TEXADDRESS_TEXMAP_1D                            0
#define __GLINT_TEXADDRESS_TEXMAP_2D                            1

/* Texture ReadMode */
#define __GLINT_TEXTUREREAD_FILTER_NEAREST                      0
#define __GLINT_TEXTUREREAD_FILTER_LINEAR                       1
#define __GLINT_TEXTUREREAD_FILTER_NEARMIPNEAREST               2
#define __GLINT_TEXTUREREAD_FILTER_NEARMIPLINEAR                3
#define __GLINT_TEXTUREREAD_FILTER_LINEARMIPNEAREST             4
#define __GLINT_TEXTUREREAD_FILTER_LINEARMIPLINEAR              5

/* Texture Color Mode */
#define __GLINT_TEXCOLORMODE_APPLICATION_MODULATE               0
#define __GLINT_TEXCOLORMODE_APPLICATION_DECAL                  1
#define __GLINT_TEXCOLORMODE_APPLICATION_BLEND                  2
#define __GLINT_TEXCOLORMODE_APPLICATION_COPY                   3

/* Alpha Blend */
#define __GLINT_BLEND_FUNC_ZERO                                 0
#define __GLINT_BLEND_FUNC_ONE                                  1
#define __GLINT_BLEND_FUNC_SRC_COLOR                            2
#define __GLINT_BLEND_FUNC_DST_COLOR                            2
#define __GLINT_BLEND_FUNC_ONE_MINUS_SRC_COLOR                  3
#define __GLINT_BLEND_FUNC_ONE_MINUS_DST_COLOR                  3
#define __GLINT_BLEND_FUNC_SRC_ALPHA                            4
#define __GLINT_BLEND_FUNC_ONE_MINUS_SRC_ALPHA                  5
#define __GLINT_BLEND_FUNC_DST_ALPHA                            6
#define __GLINT_BLEND_FUNC_ONE_MINUS_DST_ALPHA                  7
#define __GLINT_BLEND_FUNC_SRC_ALPHA_SATURATE                   8

/* Dither */
#define __GLINT_COLOR_FORMAT_RGBA_8888                          0
#define __GLINT_COLOR_FORMAT_RGBA_5555                          1
#define __GLINT_COLOR_FORMAT_RGBA_5551_FRONT                    1
#define __GLINT_COLOR_FORMAT_RGBA_4444                          2
#define __GLINT_COLOR_FORMAT_RGBA_4444_FRONT                    3
#define __GLINT_COLOR_FORMAT_RGBA_4444_BACK                     4
#define __GLINT_COLOR_FORMAT_RGB_332_FRONT                      5
#define __GLINT_COLOR_FORMAT_RGB_332_BACK                       6
#define __GLINT_COLOR_FORMAT_RGB_121_FRONT                      7
#define __GLINT_COLOR_FORMAT_RGB_121_BACK                       8

#define __GLINT_COLOR_FORMAT_CI_8                              14
#define __GLINT_COLOR_FORMAT_CI_4                              15


/* Logical Ops/Write mask */
#define __GLINT_LOGICOP_CLEAR                                   0
#define __GLINT_LOGICOP_AND                                     1
#define __GLINT_LOGICOP_AND_REVERSE                             2
#define __GLINT_LOGICOP_COPY                                    3
#define __GLINT_LOGICOP_AND_INVERTED                            4
#define __GLINT_LOGICOP_NOOP                                    5
#define __GLINT_LOGICOP_XOR                                     6
#define __GLINT_LOGICOP_OR                                      7
#define __GLINT_LOGICOP_NOR                                     8
#define __GLINT_LOGICOP_EQUIV                                   9
#define __GLINT_LOGICOP_INVERT                                 10
#define __GLINT_LOGICOP_OR_REVERSE                             11
#define __GLINT_LOGICOP_COPY_INVERT                            12
#define __GLINT_LOGICOP_OR_INVERT                              13
#define __GLINT_LOGICOP_NAND                                   14
#define __GLINT_LOGICOP_SET                                    15

#define __GLINT_ALL_WRITEMASKS_SET                     0xFFFFFFFF

/*-----------------------------------------------------*/

#define COLOR_MODE   /* 0=BGR, 1=RGB */                         1 
#define INV_COLOR_MODE                                          0

#define DITHER_XOFFSET                                          0
#define DITHER_YOFFSET                                          0

// Config - combined mode register for P2
#define __GLINT_CONFIG_FBREAD_SRC                               1
#define __GLINT_CONFIG_FBREAD_DST                               2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\glddtk.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: glddtk.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef __DDSAMPTK_INCLUDED__ 
#define __DDSAMPTK_INCLUDED__

#pragma warning( disable: 4704)

#define P3R3DX_DLLNAME "p3r3dx.dll"
#define MAX_TEXTURE_FORMAT 35

// The Maximum possible screen widths for the cards
#define MAX_GLINT_PP_WIDTH 8192
#define MAX_PERMEDIA_PP_WIDTH 2048

// For comparing runtime versions
#define DX5_RUNTIME      0x00000500l
#define DX6_RUNTIME      0x00000600l
#define DX7_RUNTIME      0x00000700l

#ifdef  W95_DDRAW

// Videoport needs to live in pThisDisplay, it may
// be on a second display card, etc.
#define MAX_AUTOFLIP_SURFACES 3
typedef struct tagPERMEDIA_VIDEOPORT
{
    // The ID of this video port
    DWORD dwPortID;

    // Permedia VideoPort supports up to
    // 3 autoflipping surfaces
    DWORD dwNumSurfaces;
    
    LPDDRAWI_DDRAWSURFACE_LCL lpSurf[MAX_AUTOFLIP_SURFACES];
    DWORD dwSurfacePointer[MAX_AUTOFLIP_SURFACES];

    // How are the signals setup?
    DWORD dwStreamAFlags;
    DWORD dwStreamBFlags;

    // Height of the VideoBlanking interval
    DWORD dwVBIHeight;

    DWORD dwFieldHeight;
    DWORD dwFieldWidth;

    // Where are we currently reading from?
    DWORD dwCurrentHostFrame;

    // Is the video playing?
    DWORD bActive;

    // A mutex to take ownership of the videoport.
    DWORD dwMutexA;

    // For VP error checking
    DWORD bResetStatus;
    DWORD dwStartLine;
    DWORD dwStartIndex;
    DWORD dwStartLineTime;
    DWORD dwErrorCount;

    // Is the VideoPort active?
    DWORD bCreated;

} PERMEDIA_VIDEOPORT;
#endif  //  W95_DDRAW

// Enumerated type for the style of buffer that is being used.
typedef enum tageBufferType
{
    COMMAND_BUFFER = 0,
    VERTEX_BUFFER = 1,
    FORCE_DWORD_BUFFERTYPE_SIZE = 0xFFFFFFFF
} eBufferType;

typedef struct tagDRVRECT
{
#ifndef WIN32
    DWORD left;
    DWORD top;
    DWORD right;
    DWORD bottom;
#else
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
#endif
} DRVRECT;

typedef struct tagOVERLAYDATA
{
    DRVRECT rcSrc;
    DRVRECT rcDest;

#ifndef WIN32
    DWORD dwOverlayPointer;
#else
    FLATPTR pCurrentOverlay;
#endif  

    DWORD dwCurrentVideoBuffer;
    DWORD dwVisibleOverlays;

} OVERLAYDATA;

typedef struct tagP3VERTEXBUFFERINFO
{
    DWORD dwSequenceID;
    DWORD bInUse;
    eBufferType BufferType;
    DWORD dwSize;
    struct tagP3VERTEXBUFFERINFO* pNext;
    struct tagP3VERTEXBUFFERINFO* pPrev;
} P3_VERTEXBUFFERINFO;

typedef struct
{
    // Where we flipped from
    FLATPTR fpFlipFrom;

    // An ID for the flip
    DWORD   dwFlipID;

} FLIPRECORD;
typedef FLIPRECORD FAR *LPFLIPRECORD;

typedef struct _GlintDMABuffer
{
    DWORD       dwBuffSize;
    DWORD       dwBuffPhys;
    ULONG_PTR   dwBuffVirt;
    DWORD       dwSubBuff;
} GLDMABUFF, *LPGLDMABUFF;

// Function prototype to fire off a DMA operation
typedef DWORD (WINAPI *__StartDMA)(struct tagThunkedData* pThisDisplay, 
                                   DWORD dwContext, DWORD dwSize, 
                                   DWORD dwPhys, ULONG_PTR dwVirt, 
                                   DWORD dwEvent);

typedef struct tagThunkedData
{
    ULONG_PTR control;
    DWORD ramdac;
    DWORD lpMMReg;

    // The Mini VDD's DevNode
    DWORD dwDevNode;

    // Virt. Address of the start of screen memory
    DWORD dwScreenFlatAddr;

    // Virt. Address of the start of LB memory
    DWORD dwLocalBuffer;

    // Screen settings
    DWORD dwScreenWidth;
    DWORD dwScreenHeight;
    DWORD cxMemory;
    DWORD cyMemory;

    // A lookup table for all the Partial Products
    DWORD PPCodes[(MAX_GLINT_PP_WIDTH / 32) + 1];    

    // Memory to remove from the card (for debugging)
    DWORD dwSubMemory;

    // Virtual address of start of screen
    DWORD dwScreenStart;
    DWORD bPixShift;
    DWORD bBppShift;
    DWORD dwBppMask;

    // Reset flag
    DWORD bResetMode;            // Has the mode been changed?
    DWORD bStartOfDay;            // Has the driver just been initialised?

    DWORD bVFWEnabled;            // Is Video For windows currently enabled?

    DWORD bDDHeapManager;        // Using the Linear Heap manager?

    DWORD dwSetupThisDisplay;    // Has this display been intialised (a ref count)?

    DWORD dwBackBufferCount;    // How many back buffers have we handed out on TX at 640x400?
    DWORD EntriesLeft;            // Number of entries left in FIFO (for debugging)
    DWORD DMAEntriesLeft;        // Number of entries left in DMA buffer (for debugging)

    DWORD bFlippedSurface;                // Has this card had a page flip?
    DWORD ModeChangeCount;

    // Current pixel format of display
    DDPIXELFORMAT   ddpfDisplay;

    // Shared Display driver memory pointer
    LPGLINTINFO     pGLInfo;

#ifndef WIN32
    DWORD pGlint;
#else
    // Pointer to the actual glint registers.
    FPGLREG         pGlint;
#endif

    // Is this card capable of AGP texturing?
    DWORD bCanAGP;

    // Flag to tell stretchblits whether to filter. 
    DWORD bFilterStretches;

    // Overlay data
    // This data has to be available at any times, because we are emulating it.
    // Only one overlay at a time supported

    DWORD   bOverlayVisible;                // TRUE if the overlay is visible.
    DWORD   OverlayDstRectL;
    DWORD   OverlayDstRectR;
    DWORD   OverlayDstRectT;
    DWORD   OverlayDstRectB;                // where the overlay is on screen
    DWORD   OverlaySrcRectL;
    DWORD   OverlaySrcRectR;
    DWORD   OverlaySrcRectT;
    DWORD   OverlaySrcRectB;                // which bit of the overlay is visible
    ULONG_PTR OverlayDstSurfLcl;                // the surface overlaid (usually the primary)
    ULONG_PTR OverlaySrcSurfLcl;                // the overlay surface
    DWORD   OverlayDstColourKey;            // the overlaid surface's written-to colour key
    DWORD   OverlaySrcColourKey;            // the overlay's transparent colour key
    ULONG_PTR OverlayClipRgnMem;                // buffer to hold a temporary clip region
    DWORD   OverlayClipRgnMemSize;            // ...the size of the buffer
    DWORD   OverlayUpdateCountdown;            // how many flips/unlocks before an update is done.
    DWORD   bOverlayFlippedThisVbl;            // TRUE if overlay was flipped this VBL.
    DWORD   bOverlayUpdatedThisVbl;            // TRUE if overlay was updated (not including flips) this VBL.
    struct {
        ULONG_PTR   VidMem;
        DWORD       Pitch;
    } OverlayTempSurf;                        // The temporary video buffer used by the overlay.

    OVERLAYDATA P3Overlay;
    DWORD   dwOverlayFiltering;                // TRUE if the overlay is filtering.
    DWORD   bOverlayPixelDouble;            // TRUE if the screen is pixel-doubled.

#if W95_DDRAW
    // Colour control variables.
    DWORD   ColConBrightness;                // Brightness 0->10000, default 0 (ish)
    DWORD   ColConContrast;                    // Contrast 0->20000, default 10000
    DWORD   ColConGamma;                    // Gamma 1->500, default 100
#endif // W95_DDRAW

#if DX7_VIDMEM_VB
    // DrawPrim temporary index buffer.
    ULONG_PTR   DrawPrimIndexBufferMem;            // Pointer to the buffer.
    DWORD       DrawPrimIndexBufferMemSize;        // Size of the buffer.
    // DrawPrim temporary vertex buffer.
    ULONG_PTR   DrawPrimVertexBufferMem;        // Pointer to the buffer.
    DWORD       DrawPrimVertexBufferMemSize;    // Size of the buffer.
#endif // DX7_VIDMEM_VB

    // Current RenderID.
    DWORD   dwRenderID;
    // TRUE if the chip's render ID is valid.
    DWORD   bRenderIDValid;
    // The RenderIDs of the last two Flips to be
    // put into the DMA/FIFO/pipeline. See Flip32 for further info.
    DWORD   dwLastFlipRenderID;
    DWORD   dwLastFlipRenderID2;

    // DirectDraw DMA variables
    __StartDMA      StartDMA;                        // Pointer to the StartDMA function
    DWORD           PartitionSize;
    DWORD           BufferLocked;
    GLDMABUFF       DMAInfo;
    DWORD           b2D_FIFOS;                // DDRAW using FIFO's?
    
    // These buffers hold counts that the driver is using
    // to keep track of operations in the chip

#ifdef WIN32
    P3_VERTEXBUFFERINFO* pRootCommandBuffer;
    P3_VERTEXBUFFERINFO* pRootVertexBuffer;
#else
    DWORD           pRootCommandBuffer;
    DWORD           pRootVertexBuffer;
#endif

    DWORD           dwCurrentSequenceID;

    // HINSTANCE of p3r3dx.dll
    HINSTANCE       hInstance;

    // DirectDraw callbacks
    DDHAL_DDCALLBACKS               DDHALCallbacks;
    DDHAL_DDSURFACECALLBACKS        DDSurfCallbacks;

    // D3D Callbacks
    ULONG_PTR                       lpD3DGlobalDriverData;
    ULONG_PTR                       lpD3DHALCallbacks;
    ULONG_PTR                       lpD3DBufCallbacks;
#if W95_DDRAW
    DDHAL_DDEXEBUFCALLBACKS         DDExeBufCallbacks;
#endif

    DWORD dwNumTextureFormats;
    DDSURFACEDESC TextureFormats[MAX_TEXTURE_FORMAT];

    DWORD dwDXVersion;

    // These have to live here, as we could be running on 2 different cards
    // on two different displays...!
    DWORD pD3DDriverData16;
    DWORD pD3DHALCallbacks16;
    DWORD pD3DHALExecuteCallbacks16;
    
    ULONG_PTR pD3DDriverData32;
    ULONG_PTR pD3DHALCallbacks32;
    ULONG_PTR pD3DHALExecuteCallbacks32;

    // A linear allocator block for the local video heap
    LinearAllocatorInfo LocalVideoHeap0Info;
    LinearAllocatorInfo CachedCommandHeapInfo;
    LinearAllocatorInfo CachedVertexHeapInfo;

    DWORD dwGARTLin;                // Linear address of Base of AGP Memory
    DWORD dwGARTDev;                // High Linear address of Base of AGP Memory

    DWORD dwGARTLinBase;            // The base address passed into the updatenonlocalvidmem call
    DWORD dwGARTDevBase;            // The base address passsed in
#if W95_DDRAW
    // The Videoport for this display
    PERMEDIA_VIDEOPORT  VidPort;

#endif

#if WNT_DDRAW 
    
#if (_WIN32_WINNT >= 0x500)
    PFND3DPARSEUNKNOWNCOMMAND pD3DParseUnknownCommand;
#else
    DWORD pD3DParseUnknownCommand;
#endif
#else // WNT_DDRAW
    // DirectX 6 Support
#ifdef WIN32
    //pointer to vertex buffer unknown command processing function
    PFND3DPARSEUNKNOWNCOMMAND pD3DParseUnknownCommand; 
#else
    DWORD pD3DParseUnknownCommand; // ? Safe ?
#endif // WIN32
#endif // WNT_DDRAW

#if WNT_DDRAW
    PPDEV   ppdev;                                // Pointer to the NT globals
    volatile DWORD * VBlankStatusPtr;            // Pointer to VBlank status word (shared with miniport)
    volatile DWORD * bOverlayEnabled;            // Pointer to overlay enabled flag (shared with miniport)
    volatile DWORD * bVBLANKUpdateOverlay;        // Pointer to overlay update flag
    volatile DWORD * VBLANKUpdateOverlayWidth;    // Pointer to overlay width (shared with miniport)
    volatile DWORD * VBLANKUpdateOverlayHeight;    // Pointer to overlay height (shared with miniport)

#endif  // WNT_DDRAW

#ifdef WIN32
    HashTable* pDirectDrawLocalsHashTable;
    HashTable* pMocompHashTable;
#else
    DWORD pDirectDrawLocalsHashTable;
    DWORD pMocompHashTable;
#endif

#ifdef WNT_DDRAW
    DWORD       pAGPHeap;
#else
#ifdef WIN32
    // Pointer to AGP heap, used for logical texturing 
    LPVIDMEM    pAGPHeap;
#endif
#endif

    FLIPRECORD flipRecord;

    DWORD dwFlushLogfile;

    // HAL info structure. THIS MUST BE THE LAST THING IN THIS STRUCTURE
    DDHALINFO       ddhi32;

} P3_THUNKEDDATA;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\glintfx.h ===
/******************************Module*Header*******************************\
* Module Name: GlintFX.h
*
* Header definition specific to Permedia chip
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
*
\**************************************************************************/

typedef struct {
    HMEMREGION  texmem;
} FX_BRUSH, *PFX_BRUSH;

#define __FX_FB_PACKED                         (1 << 19)
#define __FX_FBOFFSETSHIFT                  20

#define __FX_FORCE_BACKGROUND_COLOR         (1 << 6)
#define __FX_BITMASK_PACKING                   (1 << 9)
#define __FX_BITMASK_OFFSET                 10
#define __FX_LIMITS_ENABLE                     (1 << 18) 

#define __FX_STIPPLE_FORCE_BACKGROUND_COLOR (1 << 20)

#define __RENDER_TEXTURE_ENABLE              (1 << 13)

#define __FX_TEXREADMODE_SWRAP_REPEAT       (1 << 1)
#define __FX_TEXREADMODE_TWRAP_REPEAT       (1 << 3)
#define __FX_TEXREADMODE_8HIGH              (3 << 13)
#define __FX_TEXREADMODE_8WIDE              (3 << 9)
#define __FX_TEXREADMODE_2048HIGH           (11 << 13)
#define __FX_TEXREADMODE_2048WIDE           (11 << 9)

#define __FX_TEXTUREREADMODE_PACKED_DATA    (1 << 24)

#define __FX_8x8REPEAT_TEXTUREREADMODE      ( __PERMEDIA_ENABLE                      \
                                            | __FX_TEXREADMODE_TWRAP_REPEAT       \
                                            | __FX_TEXREADMODE_SWRAP_REPEAT       \
                                            | __FX_TEXREADMODE_8HIGH              \
                                            | __FX_TEXREADMODE_8WIDE)

#define __FX_2048x2048REPEAT_TEXTUREREADMODE ( __PERMEDIA_ENABLE                     \
                                            | __FX_TEXREADMODE_TWRAP_REPEAT       \
                                            | __FX_TEXREADMODE_SWRAP_REPEAT       \
                                            | __FX_TEXREADMODE_2048HIGH           \
                                            | __FX_TEXREADMODE_2048WIDE)

#define __FX_4BPPDOWNLOAD_TEXTUREREADMODE   ( __PERMEDIA_ENABLE                      \
                                            | __FX_TEXREADMODE_2048HIGH           \
                                            | __FX_TEXREADMODE_2048WIDE)

#define __FX_TEXAPPLICATIONCOPY             (3 << 1)

#define __FX_TEXELSIZE_SHIFT                19
#define __FX_8BIT_TEXELS                    (0 << __FX_TEXELSIZE_SHIFT)
#define __FX_16BIT_TEXELS                   (1 << __FX_TEXELSIZE_SHIFT)
#define __FX_32BIT_TEXELS                   (2 << __FX_TEXELSIZE_SHIFT)
#define __FX_4BIT_TEXELS                    (3 << __FX_TEXELSIZE_SHIFT)
#define __P2_24BIT_TEXELS                   (4 << __FX_TEXELSIZE_SHIFT)

#define __FX_TEXTUREMAPFORMAT_32WIDE        1

#define __FX_TEXTUREDATAFORMAT_32BIT_RGBA   0x00
#define __FX_TEXTUREDATAFORMAT_32BIT        0x10 
#define __FX_TEXTUREDATAFORMAT_8BIT         0xe
#define __FX_TEXTUREDATAFORMAT_16BIT        0x11
#define __FX_TEXTUREDATAFORMAT_4BIT         0xf

#define __P2_TEXTURE_DATAFORMAT_FLIP        (1 << 9)

#define __FX_TEXLUTMODE_DIRECT_ENTRY        (1 << 1)
#define __FX_TEXLUTMODE_4PIXELS_PER_ENTRY   (2 << 10)    //log2
#define __FX_TEXLUTMODE_2PIXELS_PER_ENTRY   (1 << 10)    //log2
#define __FX_TEXLUTMODE_1PIXEL_PER_ENTRY    0           //log2

#define __FX_DITHERMODE_16BIT               (1<<2) | __PERMEDIA_ENABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\glintreg.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: glintreg.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

/*
 * GLINT register window definition
 */

#define DWFILL unsigned long :32
#define WFILL unsigned short :16

typedef unsigned long DWORD;

typedef struct GlintReg {
/*      0h */

    volatile DWORD  ResetStatus           ; DWFILL; // 0x0000
    volatile DWORD  IntEnable             ; DWFILL; // 0x0008
    volatile DWORD  IntFlags              ; DWFILL; // 0x0010
    volatile DWORD  InFIFOSpace           ; DWFILL; // 0x0018
    volatile DWORD  OutFIFOWords          ; DWFILL; // 0x0020
    volatile DWORD  DMAAddress            ; DWFILL; // 0x0028
    volatile DWORD  DMACount              ; DWFILL; // 0x0030
    volatile DWORD  ErrorFlags            ; DWFILL; // 0x0038
    volatile DWORD  VClkCtl               ; DWFILL; // 0x0040
    volatile DWORD  TestRegister          ; DWFILL; // 0x0048
    union {
        volatile DWORD   Aperture0        ;         // SX/TX control register
        volatile DWORD   ApertureOne      ;         // Permedia control register
    };                                      DWFILL; // 0x0050
    union {
        volatile DWORD   Aperture1        ;         // SX/TX control register
        volatile DWORD   ApertureTwo      ;         // Permedia control register
    };                                      DWFILL; // 0x0058
    union {
        volatile DWORD  DMAControl        ; // 0x0060 P2
        volatile DWORD  ControlDMAControl ; // 0x0060 P3 version of same register
    };                                      DWFILL; 
    volatile DWORD  FIFODiscon            ; DWFILL; // 0x0068 SX Rev 2, TX and Permedia
    volatile DWORD  ChipConfig            ; DWFILL; // 0x0070 Permedia
    volatile DWORD  AGPControl            ; DWFILL; // 0x0078 P3 R3
    volatile DWORD  OutDMAAddress         ; DWFILL; // 0x0080 Output DMA controller address
    union {
        volatile DWORD  OutDMACount       ;         // 0x0088 P2 Output DMA controller count
        volatile DWORD  PCIFeedbackCount  ;         // 0x0088 P3R3
    };                                      DWFILL;
    union {
        volatile DWORD  AGPTexBaseAddress ;         // 0x0090 P2
        volatile DWORD  PCIAbortStatus    ;         // 0x0090 P3R3
    };                                      DWFILL;
    volatile DWORD  PCIAbortAddress       ; DWFILL; // 0x0098 P3R3


/* Bypass DMA Registers P2 */
    volatile DWORD  ByDMAAddress;           DWFILL; // 0x00A0 Bypass DMA host address
    DWFILL; DWFILL;                                 // 0x00A8 Not used.
    DWFILL; DWFILL;                                 // 0x00B0 Not used.
    volatile DWORD  ByDMAStride;            DWFILL; // 0x00B8 Host stride in bytes.
    volatile DWORD  ByDMAMemAddr;           DWFILL; // 0x00C0 Chip base address in texels.
    volatile DWORD  ByDMASize;              DWFILL; // 0x00C8 Height and width in texels.
    volatile DWORD  ByDMAByteMask;          DWFILL; // 0x00D0 Right and left byte masks.
    volatile DWORD  ByDMAControl;           DWFILL; // 0x00D8 General bypass DMA control.
    DWFILL; DWFILL;                                 // 0x00E0 Not used.
    volatile DWORD  ByDMAComplete;          DWFILL; // 0x00E8 Manual GP restart.
    volatile DWORD  PCIPLLstatus;           DWFILL; // 0x00F0 P3R3
    DWFILL; DWFILL;                                 // 0x00F8 Not Used 

    volatile DWORD  HostTextureAddress;     DWFILL; // 0x0100 P3R3
    volatile DWORD  TextureDownloadControl; DWFILL; // 0x0108 P3R3
    volatile DWORD  TextureOperation;       DWFILL; // 0x0110 P3R3
    volatile DWORD  LogicalTexturePage;     DWFILL; // 0x0118 P3R3
    volatile DWORD  TexDMAAddress;          DWFILL; // 0x0120 P3R3
    volatile DWORD  TexFifoSpace;           DWFILL; // 0x0128 P3R3



    volatile DWORD  Fill0a[0x200/4 - 0x130/4];

    volatile DWORD  TestInputControl;       DWFILL; // 0x0200 P3R3
    volatile DWORD  TestInputRdy;           DWFILL; // 0x0208 P3R3
    volatile DWORD  TestOutputControl;      DWFILL; // 0x0210 P3R3
    volatile DWORD  TestOutputRdy;          DWFILL; // 0x0218 P3R3

    volatile DWORD  TestWriteSelect;        DWFILL; // 0x0220 P3R3
    volatile DWORD  TestWriteData;          DWFILL; // 0x0228 P3R3
    volatile DWORD  TestReadSelect;         DWFILL; // 0x0230 P3R3
    volatile DWORD  TestReadData;           DWFILL; // 0x0238 P3R3
    volatile DWORD  PClkInvertA0;           DWFILL; // 0x0240 P3R3
    volatile DWORD  PClkInvertB0;           DWFILL; // 0x0248 P3R3
    volatile DWORD  PClkProfMaskA0;         DWFILL; // 0x0250 P3R3
    volatile DWORD  PClkProfMaskB0;         DWFILL; // 0x0258 P3R3
    volatile DWORD  PClkProfCount0;         DWFILL; // 0x0260 P3R3
    volatile DWORD  PClkInvertA1;           DWFILL; // 0x0268 P3R3
    volatile DWORD  PClkInvertB1;           DWFILL; // 0x0270 P3R3
    volatile DWORD  PClkProfMaskA1;         DWFILL; // 0x0278 P3R3
    volatile DWORD  PClkProfMaskB1;         DWFILL; // 0x0280 P3R3
    volatile DWORD  PClkProfCount1;         DWFILL; // 0x0288 P3R3

    volatile DWORD  Fill0b[0x300/4 - 0x290/4];

// P3 R3 Bypass register configuration
    volatile DWORD  ByAperture1Mode;      DWFILL;  // 0x0300
    volatile DWORD  ByAperture1Stride;    DWFILL;  // 0x0308
    volatile DWORD  ByAperture1YStart;    DWFILL;  // 0x0310
    volatile DWORD  ByAperture1UStart;    DWFILL;  // 0x0318
    volatile DWORD  ByAperture1VStart;    DWFILL;  // 0x0320
    volatile DWORD  ByAperture2Mode;      DWFILL;  // 0x0328
    volatile DWORD  ByAperture2Stride;    DWFILL;  // 0x0330
    volatile DWORD  ByAperture2YStart;    DWFILL;  // 0x0338
    volatile DWORD  ByAperture2UStart;    DWFILL;  // 0x0340
    volatile DWORD  ByAperture2VStart;    DWFILL;  // 0x0348
    volatile DWORD  ByDMAReadMode;        DWFILL;  // 0x0350
    volatile DWORD  ByDMAReadStride;      DWFILL;  // 0x0358
    volatile DWORD  ByDMAReadYStart;      DWFILL;  // 0x0360
    volatile DWORD  ByDMAReadUStart;      DWFILL;  // 0x0368
    volatile DWORD  ByDMAReadVStart;      DWFILL;  // 0x0370
    volatile DWORD  ByDMAReadCommandBase; DWFILL;  // 0x0378
    volatile DWORD  ByDMAReadCommandCount;DWFILL;  // 0x0380
    volatile DWORD  ByDMAWriteMode;       DWFILL;  // 0x0388
    volatile DWORD  ByDMAWriteStride;     DWFILL;  // 0x0390
    volatile DWORD  ByDMAWriteYStart;     DWFILL;  // 0x0398
    volatile DWORD  ByDMAWriteUStart;     DWFILL;  // 0x03A0
    volatile DWORD  ByDMAWriteVStart;     DWFILL;  // 0x03A8
    volatile DWORD  ByDMAWriteCommandBase;DWFILL;  // 0x03B0
    volatile DWORD  ByDMAWriteCommandCount;DWFILL; // 0x03B8
    volatile DWORD  Fill0c[0x800/4 - 0x3C0/4];

/*       Delta Registers       */

    volatile DWORD  DeltaReset;            DWFILL;
    volatile DWORD  DeltaIntEnable;        DWFILL;
    volatile DWORD  DeltaIntFlags;         DWFILL;
    volatile DWORD  DeltaInFIFOSpace;      DWFILL;
    volatile DWORD  DeltaOutFIFOWords;     DWFILL;
    volatile DWORD  DeltaDMAAddress;       DWFILL;
    volatile DWORD  DeltaDMACount;         DWFILL;
    volatile DWORD  DeltaErrorFlags;       DWFILL;
    volatile DWORD  DeltaVClkCtl;          DWFILL;
    volatile DWORD  DeltaTestRegister;     DWFILL;
    volatile DWORD  DeltaAperture0;        DWFILL;
    volatile DWORD  DeltaAperture1;        DWFILL;
    volatile DWORD  DeltaDMAControl;       DWFILL;
    volatile DWORD  DeltaDisconnectControl;DWFILL;
    
/*       Localbuffer Registers */

    volatile DWORD  Fill1[0xC40/4 - 0x870/4];

    volatile DWORD  CommandMode;            DWFILL;    // 0xC40
    volatile DWORD  CommandIntEnable;       DWFILL;    // 0xC48
    volatile DWORD  CommandIntFlags;        DWFILL;    // 0xC50
    volatile DWORD  CommandErrorFlags;      DWFILL;    // 0xC58
    volatile DWORD  CommandStatus;          DWFILL;    // 0xC60
    volatile DWORD  CommandFaultingAddr;    DWFILL;    // 0xC68
    volatile DWORD  VertexFaultingAddr;     DWFILL;    // 0xC70
    DWFILL; DWFILL;                                    // 0xC78
    DWFILL; DWFILL;                                    // 0xC80
    volatile DWORD  WriteFaultingAddr;      DWFILL;    // 0xC88
    DWFILL; DWFILL;                                    // 0xC90
    volatile DWORD  FeedbackSelectCount;    DWFILL;    // 0xC98
    DWFILL; DWFILL;                                    // 0xCA0
    DWFILL; DWFILL;                                    // 0xCA8
    DWFILL; DWFILL;                                    // 0xCB0
    volatile DWORD  GammaProcessorMode;     DWFILL;    // 0xCB8


    volatile DWORD  Fill1a[0x1000/4 - 0xCC0/4];

/*      1000h */

    union {
        volatile DWORD  LBMemoryCtl      ;              // SX/TX 
        volatile DWORD  Reboot           ;              // Permedia SGRAM control register
        volatile DWORD  MemCounter       ;              // P3R3
    };                                     DWFILL;      // 0x1000
    union {
        volatile DWORD  LBMemoryEDO      ;              // SX/TX
        volatile DWORD  MemBypassWriteMask;             // P3R3 
    };                                     DWFILL;      // 0x1008
    volatile DWORD   MemScratch          ; DWFILL;      // 0x1010 P3R3
    volatile DWORD   LocalMemCaps        ; DWFILL;      // 0x1018 P3R3 
    volatile DWORD   LocalMemTiming      ; DWFILL;      // 0x1020 P3R3 
    volatile DWORD   LocalMemControl     ; DWFILL;      // 0x1028 P3R3 
    volatile DWORD   LocalMemRefresh     ; DWFILL;      // 0x1030 P3R3 
    volatile DWORD   LocalMemPowerdown   ; DWFILL;      // 0x1038 P3R3 
    volatile DWORD   MemControl          ; DWFILL;      // 0x1040 Permedia
    DWFILL; DWFILL;                                     // 0x1048
    DWFILL; DWFILL;                                     // 0x1050
    DWFILL; DWFILL;                                     // 0x1058
    DWFILL; DWFILL;                                     // 0x1060
    DWFILL; DWFILL;                                     // 0x1068
    DWFILL; DWFILL;                                     // 0x1070
    DWFILL; DWFILL;                                     // 0x1078
    volatile DWORD   BootAddress         ; DWFILL;      // 0x1080 Permedia
    DWFILL; DWFILL;                                     // 0x1088
    DWFILL; DWFILL;                                     // 0x1090
    DWFILL; DWFILL;                                     // 0x1098
    DWFILL; DWFILL;                                     // 0x10a0
    DWFILL; DWFILL;                                     // 0x10a8
    DWFILL; DWFILL;                                     // 0x10b0
    DWFILL; DWFILL;                                     // 0x10b8
    volatile DWORD   MemConfig           ; DWFILL;      // 0x10c0 Permedia
    DWFILL; DWFILL;                                     // 0x10c8
    DWFILL; DWFILL;                                     // 0x10d0
    DWFILL; DWFILL;                                     // 0x10d8
    DWFILL; DWFILL;                                     // 0x10e0
    DWFILL; DWFILL;                                     // 0x10e8
    DWFILL; DWFILL;                                     // 0x10f0
    DWFILL; DWFILL;                                     // 0x10f8
    union {
        volatile DWORD  BypassWriteMask  ;              // Permedia
        volatile DWORD  RemoteMemControl ;              // P3R3
    };                                     DWFILL;      // 0x1100 
    DWFILL; DWFILL;                                     // 0x1108
    DWFILL; DWFILL;                                     // 0x1110
    DWFILL; DWFILL;                                     // 0x1118
    DWFILL; DWFILL;                                     // 0x1120
    DWFILL; DWFILL;                                     // 0x1128
    DWFILL; DWFILL;                                     // 0x1130
    DWFILL; DWFILL;                                     // 0x1138
    volatile DWORD   FramebufferWriteMask; DWFILL;      // 0x1140 Permedia
    DWFILL; DWFILL;                                     // 0x1148
    DWFILL; DWFILL;                                     // 0x1150
    DWFILL; DWFILL;                                     // 0x1158
    DWFILL; DWFILL;                                     // 0x1160
    DWFILL; DWFILL;                                     // 0x1168
    DWFILL; DWFILL;                                     // 0x1170
    DWFILL; DWFILL;                                     // 0x1178
    volatile DWORD   MClkCount           ; DWFILL;      // 0x1180 Permedia


/*       Framebuffer Registers */

    volatile DWORD   Fill2[0x1800/4 - 0x1188/4];
    
/*      1800h */

    volatile DWORD   FBMemoryCtl          ; DWFILL;
    volatile DWORD   FBModeSel            ; DWFILL;
    volatile DWORD   FBGPWrMask           ; DWFILL;
    volatile DWORD   FBGPColorMask        ; DWFILL;


/*       GP Fifo Interface */
    
    volatile DWORD       Fill3[0x2000/4 - 0x1820/4];

/*      2000h */

    volatile DWORD   GPFifo[1024];


/*       Internal Video Registers */

/*      3000h */

    union {
        volatile DWORD   VTGHLimit            ;         // 0x3000 SX/TX VTG Register
        volatile DWORD   ScreenBase           ;         // 0x3000 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGHSyncStart        ;         // 0x3008 SX/TX VTG Register
        volatile DWORD   ScreenStride         ;         // 0x3008 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGHSyncEnd          ;         // 0x3010 SX/TX VTG Register
        volatile DWORD   HTotal               ;         // 0x3010 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGHBlankEnd         ;         // 0x3018 SX/TX VTG Register
        volatile DWORD   HgEnd                ;         // 0x3018 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGVLimit            ;         // 0x3020 SX/TX VTG Register
        volatile DWORD   HbEnd                ;         // 0x3020 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGVSyncStart        ;         // 0x3028 SX/TX VTG Register
        volatile DWORD   HsStart              ;         // 0x3028 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGVSyncEnd          ;         // 0x3030 SX/TX VTG Register
        volatile DWORD   HsEnd                ;         // 0x3030 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGVBlankEnd         ;         // 0x3038 SX/TX VTG Register
        volatile DWORD   VTotal               ;         // 0x3038 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGHGateStart        ;         // 0x3040 SX/TX VTG Register
        volatile DWORD   VbEnd                ;         // 0x3040 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGHGateEnd          ;         // 0x3048 SX/TX VTG Register
        volatile DWORD   VsStart              ;         // 0x3048 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGVGateStart        ;         // 0x3050 SX/TX VTG Register
        volatile DWORD   VsEnd                ;         // 0x3050 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGVGateEnd          ;         // 0x3058 SX/TX VTG Register
        volatile DWORD   VideoControl         ;         // 0x3058 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGPolarity          ;         // 0x3060 SX/TX VTG Register
        volatile DWORD   InterruptLine        ;         // 0x3060 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGFrameRowAddr      ;         // 0x3068 SX/TX VTG Register
        volatile DWORD   DDCData              ;         // 0x3068 Permedia VTG Register
        volatile DWORD   DisplayData          ;         // 0x3068 P2 VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGVLineNumber       ;         // 0x3070 SX/TX VTG Register
        volatile DWORD   LineCount            ;         // 0x3070 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGSerialClk         ;         // 0x3078 SX/TX VTG Register
        volatile DWORD   FifoControl          ;         // 0x3078 P2 VTG Register
    };                                      DWFILL;
    volatile DWORD   ScreenBaseRight      ; DWFILL;     // 0x3080 P2 VTG Register
    volatile DWORD   MiscControl          ; DWFILL;     // 0x3088 P3R3 VTG Register
                                    
/*    Video Overlay Control */

    volatile DWORD  Fill3a[0x3100/4 - 0x3090/4];
    
/*      3100h */

    volatile DWORD  VideoOverlayUpdate          ; DWFILL;   // 0x3100
    volatile DWORD  VideoOverlayMode            ; DWFILL;   // 0x3108
    volatile DWORD  VideoOverlayFifoControl     ; DWFILL;   // 0x3110
    volatile DWORD  VideoOverlayIndex           ; DWFILL;   // 0x3118
    volatile DWORD  VideoOverlayBase0           ; DWFILL;   // 0x3120
    volatile DWORD  VideoOverlayBase1           ; DWFILL;   // 0x3128
    volatile DWORD  VideoOverlayBase2           ; DWFILL;   // 0x3130
    volatile DWORD  VideoOverlayStride          ; DWFILL;   // 0x3138
    volatile DWORD  VideoOverlayWidth           ; DWFILL;   // 0x3140
    volatile DWORD  VideoOverlayHeight          ; DWFILL;   // 0x3148
    volatile DWORD  VideoOverlayOrigin          ; DWFILL;   // 0x3150
    volatile DWORD  VideoOverlayShrinkXDelta    ; DWFILL;   // 0x3158
    volatile DWORD  VideoOverlayZoomXDelta      ; DWFILL;   // 0x3160
    volatile DWORD  VideoOverlayYDelta          ; DWFILL;   // 0x3168
    volatile DWORD  VideoOverlayFieldOffset     ; DWFILL;   // 0x3170
    volatile DWORD  VideoOverlayStatus          ; DWFILL;   // 0x3178


/*    External Video Control */

    volatile DWORD  Fill4[0x4000/4 - 0x3180/4];
    
/*      4000h */

    volatile DWORD  ExtVCReg                    ; DWFILL;   // Dac registers

    volatile DWORD  Fill5[0x5000/4 - 0x4008/4];

    union {
        volatile DWORD   RacerProDWAndStatus  ;         // 0x5000 Racer Pro Config
        volatile DWORD   P2ExtVCReg           ;         // 0x5000 P2 External Dac
    };                                      DWFILL;

    volatile DWORD  Fill5a[0x5800/4 - 0x5008/4];

/*      5800h (Video Streams Interface) */
    volatile DWORD  VSConfiguration             ; DWFILL;   // 0x5800 PM VidStream Register
    volatile DWORD  VSStatus                    ; DWFILL;   // 0x5808 PM VidStream Register
    volatile DWORD  VSSerialBusControl          ; DWFILL;   // 0x5810 PM I2C Register

    volatile DWORD  Fill6[0x5900/4 - 0x5818/4];

    // Video Stream A Video Data
    volatile DWORD  VSAControl                  ; DWFILL;   // 0x5900 PM VidStream A Register
    volatile DWORD  VSAInterruptLine            ; DWFILL;   // 0x5908 PM VidStream A Register
    volatile DWORD  VSACurrentLine              ; DWFILL;   // 0x5910 PM VidStream A Register
    volatile DWORD  VSAVideoAddressHost         ; DWFILL;   // 0x5918 PM VidStream A Register
    volatile DWORD  VSAVideoAddressIndex        ; DWFILL;   // 0x5920 PM VidStream A Register
    volatile DWORD  VSAVideoAddress0            ; DWFILL;   // 0x5928 PM VidStream A Register
    volatile DWORD  VSAVideoAddress1            ; DWFILL;   // 0x5930 PM VidStream A Register
    volatile DWORD  VSAVideoAddress2            ; DWFILL;   // 0x5938 PM VidStream A Register
    volatile DWORD  VSAVideoStride              ; DWFILL;   // 0x5940 PM VidStream A Register
    volatile DWORD  VSAVideoStartLine           ; DWFILL;   // 0x5948 PM VidStream A Register
    volatile DWORD  VSAVideoEndLine             ; DWFILL;   // 0x5950 PM VidStream A Register
    volatile DWORD  VSAVideoStartData           ; DWFILL;   // 0x5958 PM VidStream A Register
    volatile DWORD  VSAVideoEndData             ; DWFILL;   // 0x5960 PM VidStream A Register

    // Video Stream A VBI Data
    volatile DWORD  VSAVBIAddressHost           ; DWFILL;   // 0x5968 PM VidStream A Register
    volatile DWORD  VSAVBIAddressIndex          ; DWFILL;   // 0x5970 PM VidStream A Register
    volatile DWORD  VSAVBIAddress0              ; DWFILL;   // 0x5978 PM VidStream A Register
    volatile DWORD  VSAVBIAddress1              ; DWFILL;   // 0x5980 PM VidStream A Register
    volatile DWORD  VSAVBIAddress2              ; DWFILL;   // 0x5988 PM VidStream A Register
    volatile DWORD  VSAVBIStride                ; DWFILL;   // 0x5990 PM VidStream A Register
    volatile DWORD  VSAVBIStartLine             ; DWFILL;   // 0x5998 PM VidStream A Register
    volatile DWORD  VSAVBIEndLine               ; DWFILL;   // 0x59A0 PM VidStream A Register
    volatile DWORD  VSAVBIStartData             ; DWFILL;   // 0x59A8 PM VidStream A Register
    volatile DWORD  VSAVBIEndData               ; DWFILL;   // 0x59B0 PM VidStream A Register
    volatile DWORD  VSAFIFOControl              ; DWFILL;   // 0x59B8 PM VidStream A Register

    // P3 R3 specific VSA registers
    volatile DWORD  VSATimeStamp0               ; DWFILL;   // 0x59C0 P3R3 PM VidStream A Register
    volatile DWORD  VSATimeStamp1               ; DWFILL;   // 0x59C8 P3R3 PM VidStream A Register
    volatile DWORD  VSATimeStamp2               ; DWFILL;   // 0x59D0 P3R3 PM VidStream A Register
    volatile DWORD  VSADroppedFrames            ; DWFILL;   // 0x59D8 P3R3 PM VidStream A Register

    volatile DWORD  Fill7[0x5A00/4 - 0x59E0/4];

    // Video Stream B Video Data
    volatile DWORD  VSBControl                  ; DWFILL;   // 0x5A00 PM VidStream B Register
    volatile DWORD  VSBInterruptLine            ; DWFILL;   // 0x5A08 PM VidStream B Register
    volatile DWORD  VSBCurrentLine              ; DWFILL;   // 0x5A10 PM VidStream B Register
    volatile DWORD  VSBVideoAddressHost         ; DWFILL;   // 0x5A18 PM VidStream B Register
    volatile DWORD  VSBVideoAddressIndex        ; DWFILL;   // 0x5A20 PM VidStream B Register
    volatile DWORD  VSBVideoAddress0            ; DWFILL;   // 0x5A28 PM VidStream B Register
    volatile DWORD  VSBVideoAddress1            ; DWFILL;   // 0x5A30 PM VidStream B Register
    volatile DWORD  VSBVideoAddress2            ; DWFILL;   // 0x5A38 PM VidStream B Register
    volatile DWORD  VSBVideoStride              ; DWFILL;   // 0x5A40 PM VidStream B Register
    volatile DWORD  VSBVideoStartLine           ; DWFILL;   // 0x5A48 PM VidStream B Register
    volatile DWORD  VSBVideoEndLine             ; DWFILL;   // 0x5A50 PM VidStream B Register
    volatile DWORD  VSBVideoStartData           ; DWFILL;   // 0x5A58 PM VidStream B Register
    volatile DWORD  VSBVideoEndData             ; DWFILL;   // 0x5A60 PM VidStream B Register

    volatile DWORD  VSBVBIAddressHost           ; DWFILL;   // 0x5A68 PM VidStream B Register
    volatile DWORD  VSBVBIAddressIndex          ; DWFILL;   // 0x5A70 PM VidStream B Register
    volatile DWORD  VSBVBIAddress0              ; DWFILL;   // 0x5A78 PM VidStream B Register
    volatile DWORD  VSBVBIAddress1              ; DWFILL;   // 0x5A80 PM VidStream B Register
    volatile DWORD  VSBVBIAddress2              ; DWFILL;   // 0x5A88 PM VidStream B Register
    volatile DWORD  VSBVBIStride                ; DWFILL;   // 0x5A90 PM VidStream B Register
    volatile DWORD  VSBVBIStartLine             ; DWFILL;   // 0x5A98 PM VidStream B Register
    volatile DWORD  VSBVBIEndLine               ; DWFILL;   // 0x5AA0 PM VidStream B Register
    volatile DWORD  VSBVBIStartData             ; DWFILL;   // 0x5AA8 PM VidStream B Register
    volatile DWORD  VSBVBIEndData               ; DWFILL;   // 0x5AB0 PM VidStream B Register
    volatile DWORD  VSBFIFOControl              ; DWFILL;   // 0x5AB8 PM VidStream B Register

    // P3 R3 specific VS registers
    volatile DWORD  VSDMAMode                   ; DWFILL;   // 0x5AC0 P3R3 PM VidStream A Register
    volatile DWORD  VSDMACommandBase            ; DWFILL;   // 0x5AC8 P3R3 PM VidStream A Register
    volatile DWORD  VSDMACommandCount           ; DWFILL;   // 0x5AD0 P3R3 PM VidStream A Register

    volatile DWORD  Fill8[0x6000/4 - 0x5AD8/4];

/*      6000h */
    volatile DWORD  ExtBrdReg                   ; DWFILL;
    volatile DWORD  VRAMBankSwitch              ; DWFILL;

    volatile DWORD  Fill9[0x63C0/4 - 0x6010/4]  ;
                                                  WFILL;    // 0x63c0 
    volatile BYTE   WriteMiscOutputReg          ;           // 0x63c2
    volatile BYTE   Fill9a                      ;           // 0x63c3
    union {
        volatile WORD   VGASequencerReg         ;           // 0x63c4
        struct {
            volatile BYTE   VGASequencerIndexReg    ;       // 0x63c4
            volatile BYTE   VGASequencerDataReg     ;       // 0x63c5
        };
    };
                                                  WFILL;    // 0x63c6
                                                  DWFILL;   // 0x63c8 
    volatile BYTE   ReadMiscOutputReg           ;           // 0x63cc 
    volatile BYTE   Fill9b                      ; WFILL;    // 0x63cd 
    
    volatile DWORD  Fill10[0x7000/4 - 0x63D0/4] ;

    volatile DWORD  RacerProUBufB               ; DWFILL;    // 0x7000 Racer Pro config

    volatile DWORD  Fill10a[0x8000/4 - 0x7008/4];

/*    Graphics Processor */
/*      8000h */
    volatile DWORD   StartXDom                  ; DWFILL;  /*           0 */
    volatile DWORD   dXDom                      ; DWFILL;  /*           1 */
    volatile DWORD   StartXSub                  ; DWFILL;  /*           2 */
    volatile DWORD   dXSub                      ; DWFILL;  /*           3 */
    volatile DWORD   StartY                     ; DWFILL;  /*           4 */
    volatile DWORD   dY                         ; DWFILL;  /*           5 */
    volatile DWORD   Count                      ; DWFILL;  /*           6 */
    volatile DWORD   Render                     ; DWFILL;  /*           7 */
    volatile DWORD   ContinueNewLine            ; DWFILL;  /*           8 */
    volatile DWORD   ContinueNewDom             ; DWFILL;  /*           9 */
    volatile DWORD   ContinueNewSub             ; DWFILL;  /*           A */
    volatile DWORD   Continue                   ; DWFILL;  /*           B */
    volatile DWORD   FlushSpan                  ; DWFILL;  /*           C */
    volatile DWORD   BitMaskPattern             ; DWFILL;  /*           D */
    DWFILL; DWFILL; DWFILL; DWFILL;                        /*         e-f */
    
/*      8000h+16*8 */
    volatile DWORD   PointTable0                ; DWFILL;  /*           10 */
    volatile DWORD   PointTable1                ; DWFILL;  /*           11 */
    volatile DWORD   PointTable2                ; DWFILL;  /*           12 */
    volatile DWORD   PointTable3                ; DWFILL;  /*           13 */
    volatile DWORD   RasterizerMode             ; DWFILL;  /*           14 */
    volatile DWORD   YLimits                    ; DWFILL;  /*           15 */
    volatile DWORD   ScanlineOwnership          ; DWFILL;  /*           16 */
    volatile DWORD   WaitForCompletion          ; DWFILL;  /*           17 */
    volatile DWORD   PixelSize                  ; DWFILL;  /*           18 */
    volatile DWORD   XLimits                    ; DWFILL;  /*           19 */
    volatile DWORD   RectangleOrigin            ; DWFILL;  /*           1a */
    volatile DWORD   RectangleSize              ; DWFILL;  /*           1b */
    volatile DWORD   Fill11[4*2];                          /*        1c-1f */
    
/*      8000h+32*8 */
    volatile DWORD   CoverageValue              ; DWFILL;  /*           20 */
    volatile DWORD   PrepareToRender            ; DWFILL;  /*           21 */
    volatile DWORD   ActiveStepX                ; DWFILL;  /*           22 */
    volatile DWORD   PassiveStepX               ; DWFILL;  /*           23 */
    volatile DWORD   ActiveStepYDomEdge         ; DWFILL;  /*           24 */
    volatile DWORD   PassiveStepYDomEdge        ; DWFILL;  /*           25 */
    volatile DWORD   FastBlockLimits            ; DWFILL;  /*           26 */
    volatile DWORD   FastBlockFill              ; DWFILL;  /*           27 */
    volatile DWORD   SubPixelCorrection         ; DWFILL;  /*           28 */
    volatile DWORD   ForceBackgroundColor       ; DWFILL;  /*           29 */
    volatile DWORD   PackedDataLimits           ; DWFILL;  /*           2a */
    volatile DWORD   SpanStepX                  ; DWFILL;  /*           2b */
    volatile DWORD   SpanStepYDomEdge           ; DWFILL;  /*           2c */
    volatile DWORD   SpanMask                   ; DWFILL;  /*           2d */
    volatile DWORD   SuspendReads               ; DWFILL;  /*           2e */
    volatile DWORD   Fill12[1*2];                          /*           2f */
    
/*      8000h+48*8 */
    volatile DWORD   ScissorMode                ; DWFILL;  /*           30 */
    volatile DWORD   ScissorMinXY               ; DWFILL;  /*           31 */
    volatile DWORD   ScissorMaxXY               ; DWFILL;  /*           32 */
    volatile DWORD   ScreenSize                 ; DWFILL;  /*           33 */
    volatile DWORD   AreaStippleMode            ; DWFILL;  /*           34 */
    volatile DWORD   LineStippleMode            ; DWFILL;  /*           35 */
    volatile DWORD   LoadLineStippleCounters    ; DWFILL;  /*           36 */
    volatile DWORD   UpdateLineStippleCounters  ; DWFILL;  /*           37 */
    volatile DWORD   SaveLineStippleCounters    ; DWFILL;  /*           38 */
    volatile DWORD   WindowOrigin               ; DWFILL;  /*           39 */
    volatile DWORD   Fill13[6*2];                          /*        3a-3f */
    
/*      8000h+64*8 */
    volatile DWORD   AreaStipplePattern0        ; DWFILL;  /*           40 */
    volatile DWORD   AreaStipplePattern1        ; DWFILL;  /*           41 */
    volatile DWORD   AreaStipplePattern2        ; DWFILL;  /*           42 */
    volatile DWORD   AreaStipplePattern3        ; DWFILL;  /*           43 */
    volatile DWORD   AreaStipplePattern4        ; DWFILL;  /*           44 */
    volatile DWORD   AreaStipplePattern5        ; DWFILL;  /*           45 */
    volatile DWORD   AreaStipplePattern6        ; DWFILL;  /*           46 */
    volatile DWORD   AreaStipplePattern7        ; DWFILL;  /*           47 */
    volatile DWORD   AreaStipplePattern8        ; DWFILL;  /*           48 */
    volatile DWORD   AreaStipplePattern9        ; DWFILL;  /*           49 */
    volatile DWORD   AreaStipplePattern10       ; DWFILL;  /*           4a */
    volatile DWORD   AreaStipplePattern11       ; DWFILL;  /*           4b */
    volatile DWORD   AreaStipplePattern12       ; DWFILL;  /*           4c */
    volatile DWORD   AreaStipplePattern13       ; DWFILL;  /*           4d */
    volatile DWORD   AreaStipplePattern14       ; DWFILL;  /*           4e */
    volatile DWORD   AreaStipplePattern15       ; DWFILL;  /*           4f */
    volatile DWORD   AreaStipplePattern16       ; DWFILL;  /*           50 */
    volatile DWORD   AreaStipplePattern17       ; DWFILL;  /*           51 */
    volatile DWORD   AreaStipplePattern18       ; DWFILL;  /*           52 */
    volatile DWORD   AreaStipplePattern19       ; DWFILL;  /*           53 */
    volatile DWORD   AreaStipplePattern20       ; DWFILL;  /*           54 */
    volatile DWORD   AreaStipplePattern21       ; DWFILL;  /*           55 */
    volatile DWORD   AreaStipplePattern22       ; DWFILL;  /*           56 */
    volatile DWORD   AreaStipplePattern23       ; DWFILL;  /*           57 */
    volatile DWORD   AreaStipplePattern24       ; DWFILL;  /*           58 */
    volatile DWORD   AreaStipplePattern25       ; DWFILL;  /*           59 */
    volatile DWORD   AreaStipplePattern26       ; DWFILL;  /*           5a */
    volatile DWORD   AreaStipplePattern27       ; DWFILL;  /*           5b */
    volatile DWORD   AreaStipplePattern28       ; DWFILL;  /*           5c */
    volatile DWORD   AreaStipplePattern29       ; DWFILL;  /*           5d */
    volatile DWORD   AreaStipplePattern30       ; DWFILL;  /*           5e */
    volatile DWORD   AreaStipplePattern31       ; DWFILL;  /*           5f */

    volatile DWORD   Fill14[16*2];                         /*        60-6f */
    
    volatile DWORD   TextureAddressMode         ; DWFILL;  /*           70 */
    volatile DWORD   SStart                     ; DWFILL;  /*           71 */
    volatile DWORD   dSdx                       ; DWFILL;  /*           72 */
    volatile DWORD   dSdyDom                    ; DWFILL;  /*           73 */
    volatile DWORD   TStart                     ; DWFILL;  /*           74 */
    volatile DWORD   dTdx                       ; DWFILL;  /*           75 */
    volatile DWORD   dTdyDom                    ; DWFILL;  /*           76 */
    volatile DWORD   QStart                     ; DWFILL;  /*           77 */
    volatile DWORD   dQdx                       ; DWFILL;  /*           78 */
    volatile DWORD   dQdyDom                    ; DWFILL;  /*           79 */
    volatile DWORD   LOD                        ; DWFILL;  /*           7a */
    volatile DWORD   dSdy                       ; DWFILL;  /*           7b */
    volatile DWORD   dTdy                       ; DWFILL;  /*           7c */
    volatile DWORD   dQdy                       ; DWFILL;  /*           7d */

    volatile DWORD   Fill15[2*2];                          /*        7e-7f */

    union {
        volatile DWORD   TextureAddress             ;
        volatile DWORD   S1Start                    ;
    };                                          DWFILL;  /*           80 */
    union {
        volatile DWORD   TexelCoordUV               ;
        volatile DWORD   dS1dx               ;
    };                                          DWFILL;  /*           81 */
    union {
        volatile DWORD   TexelCoordU                ;
        volatile DWORD   dS1dyDom                ;
    };                                          DWFILL;  /*           82 */
    union {
        volatile DWORD   TexelCoordV                ;
        volatile DWORD   T1Start                ;
    };                                          DWFILL;  /*           83 */
    
    volatile DWORD   dT1dx                          ; DWFILL;        // [0x084]
    volatile DWORD   dT1dyDom                       ; DWFILL;          // [0x085]
    volatile DWORD   Q1Start                        ; DWFILL;          // [0x086]
    volatile DWORD   dQ1dx                          ; DWFILL;          // [0x087]
    volatile DWORD   dQ1dyDom                       ; DWFILL;         // [0x088]
    volatile DWORD   LOD1                           ; DWFILL;          // [0x089]
    volatile DWORD   TextureLODBiasS                ; DWFILL;         // [0x08A]
    volatile DWORD   TextureLODBiasT                ; DWFILL;         // [0x08B]

    volatile DWORD   Fill16[4*2];                         /*        8b-8f */

    volatile DWORD   TxTextureReadMode          ; DWFILL;  /*           90 */
    volatile DWORD   TextureFormat              ; DWFILL;  /*           91 */
    volatile DWORD   TextureCacheControl        ; DWFILL;  /*           92 */
    volatile DWORD   TexelData0                 ; DWFILL;  /*           93 */
    volatile DWORD   TexelData1                 ; DWFILL;  /*           94 */
    volatile DWORD   BorderColor                ; DWFILL;  /*           95 */
    volatile DWORD   LUTData                    ; DWFILL;  /*           96 */
    volatile DWORD   LUTDataDirect              ; DWFILL;  /*           97 */
    volatile DWORD   TexelLUTIndex              ; DWFILL;  /*           98 */
    volatile DWORD   TexelLUTData               ; DWFILL;  /*           99 */
    volatile DWORD   TexelLUTAddress            ; DWFILL;  /*           9a */
    volatile DWORD   TexelLUTTransfer           ; DWFILL;  /*           9b */
    volatile DWORD   TextureFilterMode          ; DWFILL;  /*           9c */
    volatile DWORD   TextureChromaUpper         ; DWFILL;  /*           9d */
    volatile DWORD   TextureChromaLower         ; DWFILL;  /*           9e */

    volatile DWORD   BorderColor1               ; DWFILL;  /*           9f */

    volatile DWORD   TxBaseAddr0                ; DWFILL;  /*           a0 */
    volatile DWORD   TxBaseAddr1                ; DWFILL;  /*           a1 */
    volatile DWORD   TxBaseAddr2                ; DWFILL;  /*           a2 */
    volatile DWORD   TxBaseAddr3                ; DWFILL;  /*           a3 */
    volatile DWORD   TxBaseAddr4                ; DWFILL;  /*           a4 */
    volatile DWORD   TxBaseAddr5                ; DWFILL;  /*           a5 */
    volatile DWORD   TxBaseAddr6                ; DWFILL;  /*           a6 */
    volatile DWORD   TxBaseAddr7                ; DWFILL;  /*           a7 */
    volatile DWORD   TxBaseAddr8                ; DWFILL;  /*           a8 */
    volatile DWORD   TxBaseAddr9                ; DWFILL;  /*           a9 */
    volatile DWORD   TxBaseAddr10               ; DWFILL;  /*           aa */
    volatile DWORD   TxBaseAddr11               ; DWFILL;  /*           ab */
    volatile DWORD   TxBaseAddr12               ; DWFILL;  /*           ac */
    volatile DWORD   TxBaseAddr13               ; DWFILL;  /*           ad */
    volatile DWORD   TxBaseAddr14               ; DWFILL;  /*           ae */
    volatile DWORD   TxBaseAddr15               ; DWFILL;  /*           af */

    // volatile DWORD   Fill17[4*2];                          /*        ac-af */

    volatile DWORD   TextureBaseAddress         ; DWFILL;  /*           b0 Permedia */
    volatile DWORD   TextureMapFormat           ; DWFILL;  /*           b1 Permedia */
    volatile DWORD   TextureDataFormat          ; DWFILL;  /*           b2 Permedia */
    volatile DWORD   TextureMapWidth3           ; DWFILL;                  // [0x0B3]
    volatile DWORD   TextureMapWidth4           ; DWFILL;                  // [0x0B4]
    volatile DWORD   TextureReadPad             ; DWFILL;  /*           b5 Permedia */
    volatile DWORD   TextureMapWidth6           ; DWFILL;                  // [0x0B6]
    volatile DWORD   TextureMapWidth7           ; DWFILL;                  // [0x0B7]
    volatile DWORD   TextureMapWidth8           ; DWFILL;                  // [0x0B8]
    volatile DWORD   TextureMapWidth9           ; DWFILL;                  // [0x0B9]
    volatile DWORD   TextureMapWidth10          ; DWFILL;              // [0x0BA]
    volatile DWORD   TextureMapWidth11          ; DWFILL;              // [0x0BB]
    volatile DWORD   TextureMapWidth12          ; DWFILL;              // [0x0BC]
    volatile DWORD   TextureMapWidth13          ; DWFILL;              // [0x0BD]
    volatile DWORD   TextureMapWidth14          ; DWFILL;             // [0x0BE]
    volatile DWORD   TextureMapWidth15          ; DWFILL;              // [0x0BF]

/*      8000+192*8 */
    union {
        volatile DWORD   Texel0              ;
        volatile DWORD   TextureChromaUpper1 ;
    };                                          DWFILL;  /*             c0 */
    union {
        volatile DWORD   Texel1              ;
        volatile DWORD   TextureChromaLower1 ;
    };                                          DWFILL;  /*             c1 */
    volatile DWORD   Texel2                     ; DWFILL;  /*           c2 */
    volatile DWORD   Texel3                     ; DWFILL;  /*           c3 */
    volatile DWORD   Texel4                     ; DWFILL;  /*           c4 */
    volatile DWORD   Texel5                     ; DWFILL;  /*           c5 */
    volatile DWORD   Texel6                     ; DWFILL;  /*           c6 */
    volatile DWORD   Texel7                     ; DWFILL;  /*           c7 */
    volatile DWORD   Interp0                    ; DWFILL;  /*           c8 */
    volatile DWORD   Interp1                    ; DWFILL;  /*           c9 */
    volatile DWORD   Interp2                    ; DWFILL;  /*           ca */
    volatile DWORD   Interp3                    ; DWFILL;  /*           cb */
    volatile DWORD   Interp4                    ; DWFILL;  /*           cc */
    volatile DWORD   TextureFilter              ; DWFILL;  /*           cd */
    volatile DWORD   FxTextureReadMode          ; DWFILL;  /*           ce */
    volatile DWORD   TextureLUTMode             ; DWFILL;  /*           cf */
    
/*      8000h+208*8 */
    volatile DWORD   TextureColorMode           ; DWFILL;  /*           d0 */
    volatile DWORD   TextureEnvColor            ; DWFILL;  /*           d1 */
    volatile DWORD   FogMode                    ; DWFILL;  /*           d2 */
    volatile DWORD   FogColor                   ; DWFILL;  /*           d3 */
    volatile DWORD   FStart                     ; DWFILL;  /*           d4 */
    volatile DWORD   dFdx                       ; DWFILL;  /*           d5 */
    volatile DWORD   dFdyDom                    ; DWFILL;  /*           d6 */
    union {
        volatile DWORD   TextureKd                  ;
        volatile DWORD   ZFogBias                   ;
    };                                              DWFILL;  /*           d7 */
    volatile DWORD   TextureKs                  ; DWFILL;  /*           d8 */
    volatile DWORD   KsStart                    ; DWFILL;  /*           d9 */
    volatile DWORD   dKsdx                      ; DWFILL;  /*           da */
    volatile DWORD   dKsdyDom                   ; DWFILL;  /*           db */
    volatile DWORD   KdStart                    ; DWFILL;  /*           dc */
    volatile DWORD   dKddx                      ; DWFILL;  /*           dd */
    volatile DWORD   dKddyDom                   ; DWFILL;  /*           de */
    DWFILL; DWFILL;                                        /*           df */

    volatile DWORD   Fill20[16*2];                         /*        e0-ef */


/*      8000h+240*8 */
    volatile DWORD   RStart                     ; DWFILL;  /*           f0 */
    volatile DWORD   dRdx                       ; DWFILL;  /*           f1 */
    volatile DWORD   dRdyDom                    ; DWFILL;  /*           f2 */
    volatile DWORD   GStart                     ; DWFILL;  /*           f3 */
    volatile DWORD   dGdx                       ; DWFILL;  /*           f4 */
    volatile DWORD   dGdyDom                    ; DWFILL;  /*           f5 */
    volatile DWORD   BStart                     ; DWFILL;  /*           f6 */
    volatile DWORD   dBdx                       ; DWFILL;  /*           f7 */
    volatile DWORD   dBdyDom                    ; DWFILL;  /*           f8 */
    volatile DWORD   AStart                     ; DWFILL;  /*           f9 */
    volatile DWORD   dAdx                       ; DWFILL;  /*           fa */
    volatile DWORD   dAdyDom                    ; DWFILL;  /*           fb */
    volatile DWORD   ColorDDAMode               ; DWFILL;  /*           fc */
    volatile DWORD   ConstantColor              ; DWFILL;  /*           fd */
    volatile DWORD   Color                      ; DWFILL;  /*           fe */
    DWFILL; DWFILL;                                        /*           ff */
    
/*      8000h+256*8 */
    volatile DWORD   AlphaTestMode              ; DWFILL;  /*           100 */
    volatile DWORD   AntialiasMode              ; DWFILL;  /*           101 */
    volatile DWORD   AlphaBlendMode             ; DWFILL;  /*           102 */
    volatile DWORD   DitherMode                 ; DWFILL;  /*           103 */
    volatile DWORD   FBSoftwareWriteMask        ; DWFILL;  /*           104 */
    volatile DWORD   LogicalOpMode              ; DWFILL;  /*           105 */
    volatile DWORD   FBWriteData                ; DWFILL;  /*           105 */
    volatile DWORD   FBCancelWrite              ; DWFILL;  /*           107 */
    union {
        volatile DWORD   ActiveColorStepX       ;          /*           108 */
        volatile DWORD   RouterMode             ;          /*           108 */
    };                                            DWFILL;
    volatile DWORD   ActiveColorStepYDomEdge    ; DWFILL;  /*           109 */
    volatile DWORD   Fill21[6*2];                          /*       10a-10f */
    
/*      8000h+272*8 */
    volatile DWORD   LBReadMode                 ; DWFILL;  /*           110 */
    volatile DWORD   LBReadFormat               ; DWFILL;  /*           111 */
    volatile DWORD   LBSourceOffset             ; DWFILL;  /*           112 */
    volatile DWORD   LBData                     ; DWFILL;  /*           113 */
    volatile DWORD   LBSourceData               ; DWFILL;  /*           114 */
    volatile DWORD   LBStencil                  ; DWFILL;  /*           115 */
    volatile DWORD   LBDepth                    ; DWFILL;  /*           116 */
    volatile DWORD   LBWindowBase               ; DWFILL;  /*           117 */
    volatile DWORD   LBWriteMode                ; DWFILL;  /*           118 */
    volatile DWORD   LBWriteFormat              ; DWFILL;  /*           119 */
    volatile DWORD   LBWriteBase                ; DWFILL;  /*           11a */
    volatile DWORD   LBWriteConfig              ; DWFILL;  /*           11b */
    volatile DWORD   LBReadPad                  ; DWFILL;  /*           11c */
    volatile DWORD   TextureData                ; DWFILL;  /*           11d */
    volatile DWORD   TextureDownloadOffset      ; DWFILL;  /*           11e */
    volatile DWORD   LBWindowOffset             ; DWFILL;  /*           11f */

    volatile DWORD   HostInID                   ; DWFILL;  /*           120 */
    volatile DWORD   Security                   ; DWFILL;  /*           121 */
    volatile DWORD   FlushWriteCombining        ; DWFILL;  /*           122 */
    volatile DWORD   HostInState                ; DWFILL;  /*           123 */
    volatile DWORD   HostInIndex0               ; DWFILL;  /*           124 */
    volatile DWORD   HostInIndex1               ; DWFILL;  /*           125 */
    volatile DWORD   HostInIndex2               ; DWFILL;  /*           126 */
    volatile DWORD   HostInDMAAddress           ; DWFILL;  /*           127 */
    volatile DWORD   HostInState2               ; DWFILL;  /*           128 */
    volatile DWORD   Fill22[7*2];                          /*       129-12f */

/*      8000h+304*8 */
    volatile DWORD   Window                     ; DWFILL;  /*           130 */
    volatile DWORD   StencilMode                ; DWFILL;  /*           131 */
    volatile DWORD   StencilData                ; DWFILL;  /*           132 */
    volatile DWORD   Stencil                    ; DWFILL;  /*           133 */
    volatile DWORD   DepthMode                  ; DWFILL;  /*           134 */
    volatile DWORD   Depth                      ; DWFILL;  /*           135 */
    volatile DWORD   ZStartU                    ; DWFILL;  /*           136 */
    volatile DWORD   ZStartL                    ; DWFILL;  /*           137 */
    volatile DWORD   dZdxU                      ; DWFILL;  /*           138 */
    volatile DWORD   dZdxL                      ; DWFILL;  /*           139 */
    volatile DWORD   dZdyDomU                   ; DWFILL;  /*           13a */
    volatile DWORD   dZdyDomL                   ; DWFILL;  /*           13b */
    volatile DWORD   FastClearDepth             ; DWFILL;  /*           13c */
    volatile DWORD   LBCancelWrite              ; DWFILL;  /*           13d */
    volatile DWORD   LBWriteData                ; DWFILL;  /*           13e */
    DWFILL; DWFILL;                                        /*           13f */
    
    volatile DWORD   Fill23[16*2];                         /*       140-14f */

/*      8000h+336*8 */
    volatile DWORD   FBReadMode                 ; DWFILL;  /*           150 */
    volatile DWORD   FBSourceOffset             ; DWFILL;  /*           151 */
    volatile DWORD   FBPixelOffset              ; DWFILL;  /*           152 */
    volatile DWORD   FBColor                    ; DWFILL;  /*           153 */
    volatile DWORD   FBData                     ; DWFILL;  /*           154 */
    volatile DWORD   FBSourceData               ; DWFILL;  /*           155 */
    volatile DWORD   FBWindowBase               ; DWFILL;  /*           156 */
    volatile DWORD   FBWriteMode                ; DWFILL;  /*           157 */
    volatile DWORD   FBHardwareWriteMask        ; DWFILL;  /*           158 */
    volatile DWORD   FBBlockColor               ; DWFILL;  /*           159 */
    volatile DWORD   FBReadPixel                ; DWFILL;  /*           15a */
    volatile DWORD   FBWritePixel               ; DWFILL;  /*           15b */
    volatile DWORD   FBWriteBase                ; DWFILL;  /*           15c */
    volatile DWORD   FBWriteConfig              ; DWFILL;  /*           15d */
    volatile DWORD   FBReadPad                  ; DWFILL;  /*           15e */
    volatile DWORD   PatternRAMMode             ; DWFILL;  /*           15f */

    volatile DWORD   PatternRamData0            ; DWFILL;  /*           160 */
    volatile DWORD   PatternRamData1            ; DWFILL;  /*           161 */
    volatile DWORD   PatternRamData2            ; DWFILL;  /*           162 */
    volatile DWORD   PatternRamData3            ; DWFILL;  /*           163 */
    volatile DWORD   PatternRamData4            ; DWFILL;  /*           164 */
    volatile DWORD   PatternRamData5            ; DWFILL;  /*           165 */
    volatile DWORD   PatternRamData6            ; DWFILL;  /*           166 */
    volatile DWORD   PatternRamData7            ; DWFILL;  /*           167 */
    volatile DWORD   PatternRamData8            ; DWFILL;  /*           168 */
    volatile DWORD   PatternRamData9            ; DWFILL;  /*           169 */
    volatile DWORD   PatternRamData10           ; DWFILL;  /*           16a */
    volatile DWORD   PatternRamData11           ; DWFILL;  /*           16b */
    volatile DWORD   PatternRamData12           ; DWFILL;  /*           16c */
    volatile DWORD   PatternRamData13           ; DWFILL;  /*           16d */
    volatile DWORD   PatternRamData14           ; DWFILL;  /*           16e */
    volatile DWORD   PatternRamData15           ; DWFILL;  /*           16f */
    volatile DWORD   PatternRamData16           ; DWFILL;  /*           170 */
    volatile DWORD   PatternRamData17           ; DWFILL;  /*           171 */
    volatile DWORD   PatternRamData18           ; DWFILL;  /*           172 */
    volatile DWORD   PatternRamData19           ; DWFILL;  /*           173 */
    volatile DWORD   PatternRamData20           ; DWFILL;  /*           174 */
    volatile DWORD   PatternRamData21           ; DWFILL;  /*           175 */
    volatile DWORD   PatternRamData22           ; DWFILL;  /*           176 */
    volatile DWORD   PatternRamData23           ; DWFILL;  /*           177 */
    volatile DWORD   PatternRamData24           ; DWFILL;  /*           178 */
    volatile DWORD   PatternRamData25           ; DWFILL;  /*           179 */
    volatile DWORD   PatternRamData26           ; DWFILL;  /*           17a */
    volatile DWORD   PatternRamData27           ; DWFILL;  /*           17b */
    volatile DWORD   PatternRamData28           ; DWFILL;  /*           17c */
    volatile DWORD   PatternRamData29           ; DWFILL;  /*           17d */
    volatile DWORD   PatternRamData30           ; DWFILL;  /*           17e */
    volatile DWORD   PatternRamData31           ; DWFILL;  /*           17f */
    
/*      8000h+384*8 */
    volatile DWORD   FilterMode                 ; DWFILL;  /*           180 */
    volatile DWORD   StatisticMode              ; DWFILL;  /*           181 */
    volatile DWORD   MinRegion                  ; DWFILL;  /*           182 */
    volatile DWORD   MaxRegion                  ; DWFILL;  /*           183 */
    volatile DWORD   ResetPickResult            ; DWFILL;  /*           184 */
    volatile DWORD   MinHitRegion               ; DWFILL;  /*           185 */
    volatile DWORD   MaxHitRegion               ; DWFILL;  /*           186 */
    volatile DWORD   PickResult                 ; DWFILL;  /*           187 */
    volatile DWORD   Sync                       ; DWFILL;  /*           188 */
    volatile DWORD   RLEMask                    ; DWFILL;  // [0x189]
    DWFILL; DWFILL;                                        /*           18a */
    volatile DWORD   FBBlockColorBackU          ; DWFILL;  // [0x18B]
    volatile DWORD   FBBlockColorBackL          ; DWFILL;  // [0x18C]
    volatile DWORD   FBBlockColorUpper          ; DWFILL;  /*           18d */
    volatile DWORD   FBBlockColorLower          ; DWFILL;  /*           18e */
    volatile DWORD   SuspendUntilFrameBlank     ; DWFILL;  /*           18f */

    volatile DWORD   KsRStart                   ; DWFILL;  /*           190 */
    volatile DWORD   dKsRdx                     ; DWFILL;  /*           191 */
    volatile DWORD   dKsRdyDom                  ; DWFILL;  /*           192 */
    volatile DWORD   KsGStart                   ; DWFILL;  /*           193 */
    volatile DWORD   dKsGdx                     ; DWFILL;  /*           194 */
    volatile DWORD   dKsGdyDom                  ; DWFILL;  /*           195 */
    volatile DWORD   KsBStart                   ; DWFILL;  /*           196 */
    volatile DWORD   dKsBdx                     ; DWFILL;  /*           197 */
    volatile DWORD   dKsBdyDom                  ; DWFILL;  /*           198 */

    volatile DWORD   Fill24[7*2];                          /*       199-19f */

    volatile DWORD   KdRStart                   ; DWFILL;  /*           1a0 */
    volatile DWORD   dKdRdx                     ; DWFILL;  /*           1a1 */
    volatile DWORD   dKdRdyDom                  ; DWFILL;  /*           1a2 */
    volatile DWORD   KdGStart                   ; DWFILL;  /*           1a3 */
    volatile DWORD   dKdGdx                     ; DWFILL;  /*           1a4 */
    volatile DWORD   dKdGdyDom                  ; DWFILL;  /*           1a5 */
    volatile DWORD   KdBStart                   ; DWFILL;  /*           1a6 */
    volatile DWORD   dKdBdx                     ; DWFILL;  /*           1a7 */
    volatile DWORD   dKdBdyDom                  ; DWFILL;  /*           1a8 */

    volatile DWORD   Fill25[15*2];                         /*       1a9-1b7 */

    volatile DWORD   ContextDump                ; DWFILL;    //  0x1b8
    volatile DWORD   ContextRestore             ; DWFILL;    //  0x1b9
    volatile DWORD   ContextData                ; DWFILL;    //  0x1ba

    volatile DWORD   Fill25a[21*2];                         /*       1bb-1cf */

    volatile DWORD   TexelLUT0                  ; DWFILL;  /*           1d0 */
    volatile DWORD   TexelLUT1                  ; DWFILL;  /*           1d1 */
    volatile DWORD   TexelLUT2                  ; DWFILL;  /*           1d2 */
    volatile DWORD   TexelLUT3                  ; DWFILL;  /*           1d3 */
    volatile DWORD   TexelLUT4                  ; DWFILL;  /*           1d4 */
    volatile DWORD   TexelLUT5                  ; DWFILL;  /*           1d5 */
    volatile DWORD   TexelLUT6                  ; DWFILL;  /*           1d6 */
    volatile DWORD   TexelLUT7                  ; DWFILL;  /*           1d7 */
    volatile DWORD   TexelLUT8                  ; DWFILL;  /*           1d8 */
    volatile DWORD   TexelLUT9                  ; DWFILL;  /*           1d9 */
    volatile DWORD   TexelLUT10                 ; DWFILL;  /*           1da */
    volatile DWORD   TexelLUT11                 ; DWFILL;  /*           1db */
    volatile DWORD   TexelLUT12                 ; DWFILL;  /*           1dc */
    volatile DWORD   TexelLUT13                 ; DWFILL;  /*           1dd */
    volatile DWORD   TexelLUT14                 ; DWFILL;  /*           1de */
    volatile DWORD   TexelLUT15                 ; DWFILL;  /*           1df */

    volatile DWORD   YUVMode                    ; DWFILL;  /*           1e0 */
    volatile DWORD   ChromaUpperBound           ; DWFILL;  /*           1e1 */
    volatile DWORD   ChromaLowerBound           ; DWFILL;  /*           1e2 */
    volatile DWORD   ChromaTestMode             ; DWFILL;  /*           1e3 */

    volatile DWORD   Fill26[28*2];                         /*       1e4-1ff */

/*      8000h+512*8 DELTA specific */

    union {
        volatile DWORD   V0Fixed0    ;            // Glint Delta
        volatile DWORD   V0FloatS1   ;  };        // Permedia3 Delta
                                                  DWFILL;  /* 0x200 */
    union {
        volatile DWORD   V0Fixed1    ;
        volatile DWORD   V0FloatT1   ;  };
                                                  DWFILL;  /* 0x201 */
    union {
        volatile DWORD   V0Fixed2    ;
        volatile DWORD   V0FloatQ1   ;  };
                                                  DWFILL;  /* 0x202 */
    volatile DWORD   V0Fixed3                   ; DWFILL;  /* 0x203 */
    volatile DWORD   V0Fixed4                   ; DWFILL;  /* 0x204 */
    volatile DWORD   V0Fixed5                   ; DWFILL;  /* 0x205 */
    volatile DWORD   V0Fixed6                   ; DWFILL;  /* 0x206 */
    volatile DWORD   V0Fixed7                   ; DWFILL;  /* 0x207 */
    volatile DWORD   V0Fixed8                   ; DWFILL;  /* 0x208 */
    volatile DWORD   V0Fixed9                   ; DWFILL;  /* 0x209 */
    
    union {
        volatile DWORD   V0FixedA   ;            // Glint Delta
        volatile DWORD   V0FloatKsR ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x20A */
    union {
        volatile DWORD   V0FixedB   ;            // Glint Delta
        volatile DWORD   V0FloatKsG ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x20B */
    union {
        volatile DWORD   V0FixedC   ;            // Glint Delta
        volatile DWORD   V0FloatKsB ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x20C */

    volatile DWORD   V0FloatKdR                  ; DWFILL;  // [0x20D]
    volatile DWORD   V0FloatKdG                  ; DWFILL;  // [0x20E]
    volatile DWORD   V0FloatKdB                  ; DWFILL;  // [0x20F]

    // volatile DWORD   Fill27[3*2];

    union {
        volatile DWORD   V1Fixed0    ;
        volatile DWORD   V1FloatS1   ;  };
                                                  DWFILL;  /* 0x210 */
    union {
        volatile DWORD   V1Fixed1    ;
        volatile DWORD   V1FloatT1   ;  };
                                                  DWFILL;  /* 0x211 */
    union {
        volatile DWORD   V1Fixed2    ;
        volatile DWORD   V1FloatQ1   ;  };
                                                  DWFILL;  /* 0x212 */
    volatile DWORD   V1Fixed3                   ; DWFILL;  /* 0x213 */
    volatile DWORD   V1Fixed4                   ; DWFILL;  /* 0x214 */
    volatile DWORD   V1Fixed5                   ; DWFILL;  /* 0x215 */
    volatile DWORD   V1Fixed6                   ; DWFILL;  /* 0x216 */
    volatile DWORD   V1Fixed7                   ; DWFILL;  /* 0x217 */
    volatile DWORD   V1Fixed8                   ; DWFILL;  /* 0x218 */
    volatile DWORD   V1Fixed9                   ; DWFILL;  /* 0x219 */
        union {
        volatile DWORD   V1FixedA   ;            // Glint Delta
        volatile DWORD   V1FloatKsR ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x21A */
    union {
        volatile DWORD   V1FixedB   ;            // Glint Delta
        volatile DWORD   V1FloatKsG ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x21B */
    union {
        volatile DWORD   V1FixedC   ;            // Glint Delta
        volatile DWORD   V1FloatKsB ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x21C */

    volatile DWORD   V1FloatKdR                  ; DWFILL;  // [0x21D]
    volatile DWORD   V1FloatKdG                  ; DWFILL;  // [0x21E]
    volatile DWORD   V1FloatKdB                  ; DWFILL;  // [0x21F]

    // volatile DWORD   Fill28[3*2];

    union {
        volatile DWORD   V2Fixed0    ;
        volatile DWORD   V2FloatS1   ;  };
                                                  DWFILL;  /* 0x220 */
    union {
        volatile DWORD   V2Fixed1    ;
        volatile DWORD   V2FloatT1   ;  };
                                                  DWFILL;  /* 0x221 */
    union {
        volatile DWORD   V2Fixed2    ;
        volatile DWORD   V2FloatQ1   ;  };
                                                  DWFILL;  /* 0x222 */
    volatile DWORD   V2Fixed3                   ; DWFILL;  /* 0x223 */
    volatile DWORD   V2Fixed4                   ; DWFILL;  /* 0x224 */
    volatile DWORD   V2Fixed5                   ; DWFILL;  /* 0x225 */
    volatile DWORD   V2Fixed6                   ; DWFILL;  /* 0x226 */
    volatile DWORD   V2Fixed7                   ; DWFILL;  /* 0x227 */
    volatile DWORD   V2Fixed8                   ; DWFILL;  /* 0x228 */
    volatile DWORD   V2Fixed9                   ; DWFILL;  /* 0x229 */
    
    union {
        volatile DWORD   V2FixedA   ;            // Glint Delta
        volatile DWORD   V2FloatKsR ;   };        // Permedia3 Delta
                                                   DWFILL;  /* 0x22A */
    union {
        volatile DWORD   V2FixedB   ;            // Glint Delta
        volatile DWORD   V2FloatKsG ;   };        // Permedia3 Delta
                                                   DWFILL;  /* 0x22B */
    union {
        volatile DWORD   V2FixedC   ;            // Glint Delta
        volatile DWORD   V2FloatKsB ;   };        // Permedia3 Delta
                                                   DWFILL;  /* 0x22C */

    volatile DWORD   V2FloatKdR                  ; DWFILL;  // [0x22D]
    volatile DWORD   V2FloatKdG                  ; DWFILL;  // [0x22E]
    volatile DWORD   V2FloatKdB                  ; DWFILL;  // [0x22F]

    // volatile DWORD   Fill29[3*2];

    union {
        volatile DWORD   V0Float0   ;            // Glint Delta
        volatile DWORD   V0FloatS   ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x230 */
    union {
        volatile DWORD   V0Float1   ;            // Glint Delta
        volatile DWORD   V0FloatT   ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x231 */
    union {
        volatile DWORD   V0Float2   ;            // Glint Delta
        volatile DWORD   V0FloatQ   ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x232 */
    volatile DWORD   V0Float3                   ; DWFILL;  /* 0x233 */
    volatile DWORD   V0Float4                   ; DWFILL;  /* 0x234 */
    union {
        volatile DWORD   V0Float5   ;
        volatile DWORD   V0FloatR   ;   };
                                                  DWFILL;  /* 0x235 */
    union {
        volatile DWORD   V0Float6   ;
        volatile DWORD   V0FloatG   ;   };
                                                  DWFILL;  /* 0x236 */
    union {
        volatile DWORD   V0Float7   ;
        volatile DWORD   V0FloatBlue   ;   };
                                                  DWFILL;  /* 0x237 */
    union {
        volatile DWORD   V0Float8   ;
        volatile DWORD   V0FloatAlpha   ;   };
                                                  DWFILL;  /* 0x238 */
    union {
        volatile DWORD   V0Float9   ;
        volatile DWORD   V0FloatF   ;   };
                                                  DWFILL;  /* 0x239 */
    union {
        volatile DWORD   V0FloatA   ;
        volatile DWORD   V0FloatX   ;   };
                                                  DWFILL;  /* 0x23a */
    union {
        volatile DWORD   V0FloatB   ;
        volatile DWORD   V0FloatY   ;   };
                                                  DWFILL;  /* 0x23b */
    union {
        volatile DWORD   V0FloatC   ;
        volatile DWORD   V0FloatZ   ;   };
                                                  DWFILL;  /* 0x23c */
    volatile DWORD   V0FloatW                   ; DWFILL; // [0x23D]
    volatile DWORD   V0FloatPackedColour        ; DWFILL; // [0x23E]
    volatile DWORD   V0FloatPackedSpecularFog   ; DWFILL; // [0x23F]

    // volatile DWORD   Fill30[3*2];

    union {
        volatile DWORD   V1Float0   ;            // Glint Delta
        volatile DWORD   V1FloatS   ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x240 */
    union {
        volatile DWORD   V1Float1   ;            // Glint Delta
        volatile DWORD   V1FloatT   ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x241 */
    union {
        volatile DWORD   V1Float2   ;            // Glint Delta
        volatile DWORD   V1FloatQ   ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x242 */
    volatile DWORD   V1Float3                   ; DWFILL;  /* 0x243 */
    volatile DWORD   V1Float4                   ; DWFILL;  /* 0x244 */
    union {
        volatile DWORD   V1Float5   ;
        volatile DWORD   V1FloatR   ;   };
                                                  DWFILL;  /* 0x245 */
    union {
        volatile DWORD   V1Float6   ;
        volatile DWORD   V1FloatG   ;   };
                                                  DWFILL;  /* 0x246 */
    union {
        volatile DWORD   V1Float7   ;
        volatile DWORD   V1FloatBlue   ;   };
                                                  DWFILL;  /* 0x247 */
    union {
        volatile DWORD   V1Float8   ;
        volatile DWORD   V1FloatAlpha   ;   };
                                                  DWFILL;  /* 0x248 */
    union {
        volatile DWORD   V1Float9   ;
        volatile DWORD   V1FloatF   ;   };
                                                  DWFILL;  /* 0x249 */
    union {
        volatile DWORD   V1FloatA   ;
        volatile DWORD   V1FloatX   ;   };
                                                  DWFILL;  /* 0x24a */
    union {
        volatile DWORD   V1FloatB   ;
        volatile DWORD   V1FloatY   ;   };
                                                  DWFILL;  /* 0x24b */
    union {
        volatile DWORD   V1FloatC   ;
        volatile DWORD   V1FloatZ   ;   };
                                                  DWFILL;  /* 0x24c */
    volatile DWORD   V1FloatW                   ; DWFILL; // [0x24D]
    volatile DWORD   V1FloatPackedColour        ; DWFILL; // [0x24E]
    volatile DWORD   V1FloatPackedSpecularFog   ; DWFILL; // [0x24F]

    // volatile DWORD   Fill31[3*2];

    union {
        volatile DWORD   V2Float0   ;            // Glint Delta
        volatile DWORD   V2FloatS   ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x250 */
    union {
        volatile DWORD   V2Float1   ;            // Glint Delta
        volatile DWORD   V2FloatT   ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x251 */
    union {
        volatile DWORD   V2Float2   ;            // Glint Delta
        volatile DWORD   V2FloatQ   ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x252 */
    volatile DWORD   V2Float3                   ; DWFILL;  /* 0x253 */
    volatile DWORD   V2Float4                   ; DWFILL;  /* 0x254 */
    union {
        volatile DWORD   V2Float5   ;
        volatile DWORD   V2FloatR   ;   };
                                                  DWFILL;  /* 0x255 */
    union {
        volatile DWORD   V2Float6   ;
        volatile DWORD   V2FloatG   ;   };
                                                  DWFILL;  /* 0x256 */
    union {
        volatile DWORD   V2Float7   ;
        volatile DWORD   V2FloatBlue   ;   };
                                                  DWFILL;  /* 0x257 */
    union {
        volatile DWORD   V2Float8   ;
        volatile DWORD   V2FloatAlpha   ;   };
                                                  DWFILL;  /* 0x258 */
    union {
        volatile DWORD   V2Float9   ;
        volatile DWORD   V2FloatF   ;   };
                                                  DWFILL;  /* 0x259 */
    union {
        volatile DWORD   V2FloatA   ;
        volatile DWORD   V2FloatX   ;   };
                                                  DWFILL;  /* 0x25a */
    union {
        volatile DWORD   V2FloatB   ;
        volatile DWORD   V2FloatY   ;   };
                                                  DWFILL;  /* 0x25b */
    union {
        volatile DWORD   V2FloatC   ;
        volatile DWORD   V2FloatZ   ;   };
                                                  DWFILL;  /* 0x25c */
    volatile DWORD   V2FloatW                   ; DWFILL; // [0x25D]
    volatile DWORD   V2FloatPackedColour        ; DWFILL; // [0x25E]
    volatile DWORD   V2FloatPackedSpecularFog   ; DWFILL; // [0x25F]

    // volatile DWORD   Fill32[3*2];

    volatile DWORD   DeltaMode                  ; DWFILL;  /* 0x260 */
    volatile DWORD   DrawTriangle               ; DWFILL;  /* 0x261 */
    volatile DWORD   RepeatTriangle             ; DWFILL;  /* 0x262 */
    volatile DWORD   DrawLine01                 ; DWFILL;  /* 0x263 */
    volatile DWORD   DrawLine10                 ; DWFILL;  /* 0x264 */
    volatile DWORD   RepeatLine                 ; DWFILL;  /* 0x265 */

    DWFILL; DWFILL;                                            // 0x266

    volatile DWORD   ProvokingVertex            ; DWFILL;  // [0x267]
    volatile DWORD   TextureLODScale            ; DWFILL;  // [0x268]
    volatile DWORD   TextureLODScale1           ; DWFILL;  // [0x269]
    volatile DWORD   DeltaControl               ; DWFILL;  // [0x26A]
    volatile DWORD   ProvokingVertexMask        ; DWFILL;  // [0x26B]

    volatile DWORD   Fill33[3*2];
    volatile DWORD   BroadcastMask              ; DWFILL;  /* 0x26F */

    volatile DWORD   Fill34[(0x530-0x270)*2];

    volatile DWORD   QDMAAddress                ; DWFILL;  /* 0x530 */
    volatile DWORD   QDMACount                  ; DWFILL;  /* 0x531 */
    volatile DWORD   Fill35[(0x53f-0x532)*2];
    volatile DWORD   QDMAContinue               ; DWFILL;  /* 0x53f */

    // PERMEDIA 3 Registers - Added Jan99 Mark Cresswell

    volatile DWORD   Fill36[(0x5d0-0x540)*2];

    volatile DWORD   FBDestReadBufferAddr0      ; DWFILL;             // [0x5D0]
    volatile DWORD   FBDestReadBufferAddr1      ; DWFILL;             // [0x5D1]
    volatile DWORD   FBDestReadBufferAddr2      ; DWFILL;             // [0x5D2]
    volatile DWORD   FBDestReadBufferAddr3      ; DWFILL;             // [0x5D3]
    volatile DWORD   FBDestReadBufferOffset0    ; DWFILL;           // [0x5D4]
    volatile DWORD   FBDestReadBufferOffset1    ; DWFILL;           // [0x5D5]
    volatile DWORD   FBDestReadBufferOffset2    ; DWFILL;           // [0x5D6]
    volatile DWORD   FBDestReadBufferOffset3    ; DWFILL;           // [0x5D7]
    volatile DWORD   FBDestReadBufferWidth0     ; DWFILL;            // [0x5D8]
    volatile DWORD   FBDestReadBufferWidth1     ; DWFILL;            // [0x5D9]
    volatile DWORD   FBDestReadBufferWidth2     ; DWFILL;            // [0x5DA]
    volatile DWORD   FBDestReadBufferWidth3     ; DWFILL;            // [0x5DB]
    volatile DWORD   FBDestReadMode               ; DWFILL;           // [0x5DC]
    volatile DWORD   FBDestReadEnables          ; DWFILL;           // [0x5DD]

    volatile DWORD   Fill37[(0x5e0-0x5de)*2];

    volatile DWORD   FBSourceReadMode           ; DWFILL;           // [0x5E0]
    volatile DWORD   FBSourceReadBufferAddr     ; DWFILL;            // [0x5E1]
    volatile DWORD   FBSourceReadBufferOffset   ; DWFILL;              // [0x5E2]
    volatile DWORD   FBSourceReadBufferWidth    ; DWFILL;           // [0x5E3]

    volatile DWORD   Fill38[(0x5e8-0x5e4)*2];

    volatile DWORD   PCIWindowBase0             ; DWFILL;                    // [0x5E8]
    volatile DWORD   PCIWindowBase1             ; DWFILL;                    // [0x5E9]
    volatile DWORD   PCIWindowBase2             ; DWFILL;                    // [0x5EA]
    volatile DWORD   PCIWindowBase3             ; DWFILL;                    // [0x5EB]
    volatile DWORD   PCIWindowBase4             ; DWFILL;                    // [0x5EC]
    volatile DWORD   PCIWindowBase5             ; DWFILL;                    // [0x5ED]
    volatile DWORD   PCIWindowBase6             ; DWFILL;                    // [0x5EE]
    volatile DWORD   PCIWindowBase7             ; DWFILL;                    // [0x5EF]
    volatile DWORD   AlphaSourceColor           ; DWFILL;                  // [0x5F0]
    volatile DWORD   AlphaDestColor             ; DWFILL;                    // [0x5F1]
    volatile DWORD   ChromaPassColor            ; DWFILL;                   // [0x5F2]
    volatile DWORD   ChromaFailColor            ; DWFILL;                   // [0x5F3]
    volatile DWORD   AlphaBlendColorMode        ; DWFILL;               // [0x5F4]
    volatile DWORD   AlphaBlendAlphaMode        ; DWFILL;               // [0x5F5]

    volatile DWORD   Fill39[(0x600-0x5f6)*2];

    volatile DWORD   FBWriteBufferAddr0         ; DWFILL;                // [0x600]
    volatile DWORD   FBWriteBufferAddr1         ; DWFILL;                // [0x601]
    volatile DWORD   FBWriteBufferAddr2         ; DWFILL;                // [0x602]
    volatile DWORD   FBWriteBufferAddr3         ; DWFILL;                // [0x603]
    volatile DWORD   FBWriteBufferOffset0       ; DWFILL;              // [0x604]
    volatile DWORD   FBWriteBufferOffset1       ; DWFILL;              // [0x605]
    volatile DWORD   FBWriteBufferOffset2       ; DWFILL;              // [0x606]
    volatile DWORD   FBWriteBufferOffset3       ; DWFILL;              // [0x607]
    volatile DWORD   FBWriteBufferWidth0        ; DWFILL;               // [0x608]
    volatile DWORD   FBWriteBufferWidth1        ; DWFILL;               // [0x609]
    volatile DWORD   FBWriteBufferWidth2        ; DWFILL;               // [0x60A]
    volatile DWORD   FBWriteBufferWidth3        ; DWFILL;               // [0x60B]
    
    volatile DWORD   Fill40[(0x614-0x60c)*2];

    volatile DWORD   FBBlockColorBack           ; DWFILL;                  // [0x614]
    
    volatile DWORD   Fill41[(0x660-0x615)*2];

    volatile DWORD   TextureCompositeMode       ; DWFILL;              // [0x660]
    volatile DWORD   TextureCompositeColorMode0 ; DWFILL;        // [0x661]
    volatile DWORD   TextureCompositeAlphaMode0 ; DWFILL;        // [0x662]
    volatile DWORD   TextureCompositeColorMode1 ; DWFILL;        // [0x663]
    volatile DWORD   TextureCompositeAlphaMode1 ; DWFILL;        // [0x664]
    volatile DWORD   TextureCompositeFactor0    ; DWFILL;           // [0x665]
    volatile DWORD   TextureCompositeFactor1    ; DWFILL;           // [0x666]
    volatile DWORD   TextureIndexMode0          ; DWFILL;             // [0x667]
    volatile DWORD   TextureIndexMode1          ; DWFILL;             // [0x668]
    volatile DWORD   LodRange0                  ; DWFILL;             // [0x669]
    volatile DWORD   LodRange1                  ; DWFILL;             // [0x66A]
    
    volatile DWORD   Fill42[(0x66f-0x66b)*2];

    volatile DWORD   LUTMode                    ; DWFILL;               // [0x66F]
        
    volatile DWORD   Fill43[(0x680-0x670)*2];

    volatile DWORD   TextureReadMode0           ; DWFILL;                  // [0x680]
    volatile DWORD   TextureReadMode1           ; DWFILL;                  // [0x681]

    volatile DWORD   Fill44[(0x685-0x682)*2];

    volatile DWORD   TextureMapSize             ; DWFILL;               // [0x685]

    volatile DWORD   Fill45[(0x690-0x686)*2];

    volatile DWORD   HeadPhysicalPageAllocation0; DWFILL;               // [0x690]
    volatile DWORD   HeadPhysicalPageAllocation1; DWFILL;               // [0x691]
    volatile DWORD   HeadPhysicalPageAllocation2; DWFILL;               // [0x692]
    volatile DWORD   HeadPhysicalPageAllocation3; DWFILL;               // [0x693]
    volatile DWORD   TailPhysicalPageAllocation0; DWFILL;               // [0x694]
    volatile DWORD   TailPhysicalPageAllocation1; DWFILL;               // [0x695]
    volatile DWORD   TailPhysicalPageAllocation2; DWFILL;               // [0x696]
    volatile DWORD   TailPhysicalPageAllocation3; DWFILL;               // [0x697]

    volatile DWORD   PhysicalPageAllocationTableAddr;   DWFILL;            // [0x698]
    volatile DWORD   BasePageOfWorkingSet;              DWFILL;            // [0x699]
    volatile DWORD   LogicalTexturePageTableAddr;       DWFILL;            // [0x69a]
    volatile DWORD   LogicalTexturePageTableLength;     DWFILL;            // [0x69b]
    volatile DWORD   BasePageOfWorkingSetHost;          DWFILL;            // [0x69c]

    volatile DWORD   Fill46[(0x6A0-0x69d)*2];

    volatile DWORD   LBDestReadMode             ; DWFILL;               // [0x6A0]
    volatile DWORD   LBDestReadEnables          ; DWFILL;                 // [0x6A1]
    volatile DWORD   LBDestReadBufferAddr       ; DWFILL;                  // [0x6A2]
    volatile DWORD   LBDestReadBufferOffset     ; DWFILL;                // [0x6A3]
    volatile DWORD   LBSourceReadMode           ; DWFILL;                  // [0x6A4]
    volatile DWORD   LBSourceReadBufferAddr     ; DWFILL;                // [0x6A5]
    volatile DWORD   LBSourceReadBufferOffset   ; DWFILL;                  // [0x6A6]
    volatile DWORD   GIDMode                    ; DWFILL;               // [0x6A7]
    volatile DWORD   LBWriteBufferAddr          ; DWFILL;                 // [0x6A8]
    volatile DWORD   LBWriteBufferOffset        ; DWFILL;               // [0x6A9]
    volatile DWORD   LBClearDataL               ; DWFILL;               // [0x6AA]
    volatile DWORD   LBClearDataU               ; DWFILL;               // [0x6AB]

    volatile DWORD   Fill47[(0x6c0-0x6ac)*2];

    volatile DWORD   RectanglePosition          ; DWFILL;                 // [0x6C0]

    volatile DWORD   Fill48[(0x6c2-0x6c1)*2];

    volatile DWORD   RenderPatchOffset          ; DWFILL;                 // [0x6C2]

    volatile DWORD   Fill49[(0x6ca-0x6c3)*2];

    volatile DWORD   DownloadTarget             ; DWFILL;               // [0x6CA]

    volatile DWORD   Fill50[(0x6F0-0x6CB)*2];

    volatile DWORD   QDMAMemoryControl          ; DWFILL;               // [0x6F0]



} GLREG, *PGLREG, far *FPGLREG;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\gtag.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: gtag.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef glinttag_h
#define glinttag_h

enum __GlintTagList {
    __GlintTagStartXDom = 0,                // 0x000
    __GlintTagdXDom,                        // 0x001
    __GlintTagStartXSub,                    // 0x002
    __GlintTagdXSub,                        // 0x003
    __GlintTagStartY,                       // 0x004
    __GlintTagdY,                           // 0x005
    __GlintTagCount,                        // 0x006
    __GlintTagRender,                       // 0x007
    __GlintTagContinueNewLine,              // 0x008
    __GlintTagContinueNewDom,               // 0x009
    __GlintTagContinueNewSub,               // 0x00A
    __GlintTagContinue,                     // 0x00B
    __GlintTagFlushSpan,                    // 0x00C
    __GlintTagBitMaskPattern,               // 0x00D
    __GlintTagReserved00e,
    __GlintTagReserved00f,
    __GlintTagPointTable0,                  // 0x010
    __GlintTagPointTable1,                  // 0x011
    __GlintTagPointTable2,                  // 0x012
    __GlintTagPointTable3,                  // 0x013
    __GlintTagRasterizerMode,               // 0x014
    __GlintTagYLimits,                      // 0x015
    __GlintTagScanlineOwnership,            // 0x016
    __GlintTagWaitForCompletion,            // 0x017
    __GlintTagPixelSize,                    // 0x018
    __PermediaTagXLimits,                   // 0x019
    __PermediaTagRectangleOrigin,           // 0x01A
    __PermediaTagRectangleSize,             // 0x01B
    __GlintTagReserved01c,
    __GlintTagReserved01d,
    __GlintTagReserved01e,
    __GlintTagReserved01f,
    __GlintTagCoverageValue,                // 0x020
    __GlintTagPrepareToRender,              // 0x021
    __GlintTagActiveStepX,                  // 0x022
    __GlintTagPassiveStepX,                 // 0x023
    __GlintTagActiveStepYDomEdge,           // 0x024
    __GlintTagPassiveStepYDomEdge,          // 0x025
    __GlintTagFastBlockLimits,              // 0x026
    __GlintTagFastBlockFill,                // 0x027
    __GlintTagSubPixelCorrection,           // 0x028
    __GlintTagReserved029,
    __PermediaTagPackedDataLimits,          // 0x02A
    __GlintTagReserved02b,
    __GlintTagReserved02c,
    __GlintTagReserved02d,
    __GlintTagReserved02e,
    __GlintTagReserved02f,
    __GlintTagScissorMode,                  // 0x030
    __GlintTagScissorMinXY,                 // 0x031
    __GlintTagScissorMaxXY,                 // 0x032
    __GlintTagScreenSize,                   // 0x033
    __GlintTagAreaStippleMode,              // 0x034
    __GlintTagLineStippleMode,              // 0x035
    __GlintTagLoadLineStippleCounters,      // 0x036
    __GlintTagUpdateLineStippleCounters,    // 0x037
    __GlintTagSaveLineStippleCounters,      // 0x038
    __GlintTagWindowOrigin,                 // 0x039
    __GlintTagReserved03a,
    __GlintTagReserved03b,
    __GlintTagReserved03c,
    __GlintTagReserved03d,
    __GlintTagReserved03e,
    __GlintTagReserved03f,
    __GlintTagAreaStipplePattern0,          // 0x040
    __GlintTagAreaStipplePattern1,          // 0x041
    __GlintTagAreaStipplePattern2,          // 0x042
    __GlintTagAreaStipplePattern3,          // 0x043
    __GlintTagAreaStipplePattern4,          // 0x044
    __GlintTagAreaStipplePattern5,          // 0x045
    __GlintTagAreaStipplePattern6,          // 0x046
    __GlintTagAreaStipplePattern7,          // 0x047
    __GlintTagAreaStipplePattern8,          // 0x048
    __GlintTagAreaStipplePattern9,          // 0x049
    __GlintTagAreaStipplePattern10,         // 0x04A
    __GlintTagAreaStipplePattern11,         // 0x04B
    __GlintTagAreaStipplePattern12,         // 0x04C
    __GlintTagAreaStipplePattern13,         // 0x04D
    __GlintTagAreaStipplePattern14,         // 0x04E
    __GlintTagAreaStipplePattern15,         // 0x04F
    __GlintTagAreaStipplePattern16,         // 0x050
    __GlintTagAreaStipplePattern17,         // 0x051
    __GlintTagAreaStipplePattern18,         // 0x052
    __GlintTagAreaStipplePattern19,         // 0x053
    __GlintTagAreaStipplePattern20,         // 0x054
    __GlintTagAreaStipplePattern21,         // 0x055
    __GlintTagAreaStipplePattern22,         // 0x056
    __GlintTagAreaStipplePattern23,         // 0x057
    __GlintTagAreaStipplePattern24,         // 0x058
    __GlintTagAreaStipplePattern25,         // 0x059
    __GlintTagAreaStipplePattern26,         // 0x05A
    __GlintTagAreaStipplePattern27,         // 0x05B
    __GlintTagAreaStipplePattern28,         // 0x05C
    __GlintTagAreaStipplePattern29,         // 0x05D
    __GlintTagAreaStipplePattern30,         // 0x05E
    __GlintTagAreaStipplePattern31,         // 0x05F
    __GlintTagFillFBWriteBufferAddr0,       // 0x060
    __GlintTagFillFBSourceReadBufferAddr,   // 0x061
    __GlintTagFillFBDestReadBufferAddr0,    // 0x062
    __GlintTagFillScissorMinXY,             // 0x063
    __GlintTagFillScissorMaxXY,             // 0x064
    __GlintTagFillForegroundColor0,         // 0x065
    __GlintTagFillBackgroundColor,          // 0x066
    __GlintTagFillConfig2D0,                // 0x067
    __GlintTagFillFBSourceReadBufferOffset, // 0x068
    __GlintTagFillRectanglePosition,        // 0x069
    __GlintTagFillRender2D,                 // 0x06A
    __GlintTagFillForegroundColor1,         // 0x06B
    __GlintTagFillConfig2D1,                // 0x06C
    __GlintTagFillGlyphPosition,            // 0x06D
    __GlintTagReserved06e,
    __GlintTagReserved06f,
    __GlintTagTextureAddressMode,           // 0x070
    __GlintTagSStart,                       // 0x071
    __GlintTagdSdx,                         // 0x072
    __GlintTagdSdyDom,                      // 0x073
    __GlintTagTStart,                       // 0x074
    __GlintTagdTdx,                         // 0x075
    __GlintTagdTdyDom,                      // 0x076
    __GlintTagQStart,                       // 0x077
    __GlintTagdQdx,                         // 0x078
    __GlintTagdQdyDom,                      // 0x079
    __GlintTagLOD,                          // 0x07A 
    __GlintTagdSdy,                         // 0x07B 
    __GlintTagdTdy,                         // 0x07C 
    __GlintTagdQdy,                         // 0x07D 
    __GlintTagReserved07e,
    __GlintTagReserved07f,
    __GlintTagReserved080,                  // 0x080
    __GlintTagReserved081,                  // 0x081
    __GlintTagTexelCoordU,                  // 0x082
    __GlintTagTexelCoordV,                  // 0x083
    __GlintTagReserved084,                  // 0x084
    __GlintTagReserved085,                  // 0x085
    __GlintTagReserved086,                  // 0x086
    __GlintTagReserved087,                  // 0x087
    __GlintTagReserved088,                  // 0x088
    __GlintTagLOD1,                         // 0x089
    __GlintTagTextureLODBiasS,              // 0x08A
    __GlintTagTextureLODBiasT,              // 0x08B
    __GlintTagReserved08c,
    __GlintTagReserved08d,
    __GlintTagReserved08e,
    __GlintTagReserved08f,
    __GlintTagTextureReadMode,              // 0x090
    __GlintTagTextureFormat,                // 0x091
    __GlintTagTextureCacheControl,          // 0x092
    __GlintTagReserved093,
    __GlintTagReserved094,
    __GlintTagBorderColor,                  // 0x095
    __GlintTagReserved096,
    __GlintTagReserved097,
    __GlintTagTexelLUTIndex,                // 0x098
    __GlintTagTexelLUTData,                 // 0x099
    __GlintTagTexelLUTAddress,              // 0x09A
    __GlintTagTexelLUTTransfer,             // 0x09B
    __GlintTagTextureFilterMode,            // 0x09C
    __GlintTagTextureChromaUpper,           // 0x09D
    __GlintTagTextureChromaLower,           // 0x09E
    __GlintTagBorderColor1,                 // 0x09F
    __GlintTagTextureBaseAddress,           // 0x0A0
    __GlintTagTextureBaseAddressLR,         // 0x0A1
    __GlintTagTextureBaseAddress2,          // 0x0A2
    __GlintTagTextureBaseAddress3,          // 0x0A3
    __GlintTagTextureBaseAddress4,          // 0x0A4
    __GlintTagTextureBaseAddress5,          // 0x0A5
    __GlintTagTextureBaseAddress6,          // 0x0A6
    __GlintTagTextureBaseAddress7,          // 0x0A7
    __GlintTagTextureBaseAddress8,          // 0x0A8
    __GlintTagTextureBaseAddress9,          // 0x0A9
    __GlintTagTextureBaseAddress10,         // 0x0AA
    __GlintTagTextureBaseAddress11,         // 0x0AB
    __GlintTagTextureBaseAddress12,         // 0x0AC
    __GlintTagTextureBaseAddress13,         // 0x0AD
    __GlintTagTextureBaseAddress14,         // 0x0AE
    __GlintTagTextureBaseAddress15,         // 0x0AF
    __PermediaTagTextureBaseAddress,        // 0x0B0
    __PermediaTagTextureMapFormat,          // 0x0B1
    __PermediaTagTextureDataFormat,         // 0x0B2
    __GlintTagReserved0b3,
    __GlintTagReserved0b4,
    __GlintTagReserved0b5,
    __GlintTagReserved0b6,
    __GlintTagReserved0b7,
    __GlintTagReserved0b8,
    __GlintTagReserved0b9,
    __GlintTagReserved0ba,
    __GlintTagReserved0bb,
    __GlintTagReserved0bc,
    __GlintTagReserved0bd,
    __GlintTagReserved0be,
    __GlintTagReserved0bf,
    __GlintTagTexel0,                       // 0x0C0
    __GlintTagTexel1,                       // 0x0C1
    __GlintTagTexel2,                       // 0x0C2
    __GlintTagTexel3,                       // 0x0C3
    __GlintTagTexel4,                       // 0x0C4
    __GlintTagTexel5,                       // 0x0C5
    __GlintTagTexel6,                       // 0x0C6
    __GlintTagTexel7,                       // 0x0C7
    __GlintTagInterp0,                      // 0x0C8
    __GlintTagInterp1,                      // 0x0C9
    __GlintTagInterp2,                      // 0x0CA
    __GlintTagInterp3,                      // 0x0CB
    __GlintTagInterp4,                      // 0x0CC
    __GlintTagTextureFilter,                // 0x0CD
    __PermediaTagTextureReadMode,           // 0x0CE
    __PermediaTagTexelLUTMode,              // 0x0CF
    __GlintTagTextureColorMode,             // 0x0D0
    __GlintTagTextureEnvColor,              // 0x0D1
    __GlintTagFogMode,                      // 0x0D2
    __GlintTagFogColor,                     // 0x0D3
    __GlintTagFStart,                       // 0x0D4
    __GlintTagdFdx,                         // 0x0D5
    __GlintTagdFdyDom,                      // 0x0D6
    __GlintTagZFogBias,                     // 0x0D7
    __GlintTagReserved0d8,
    __GlintTagKsStart,                      // 0x0D9
    __GlintTagdKsdx,                        // 0x0DA
    __GlintTagdKsdyDom,                     // 0x0DB
    __GlintTagKdStart,                      // 0x0DC
    __GlintTagdKddx,                        // 0x0DD
    __GlintTagdKddyDom,                     // 0x0DE
    __GlintTagReserved0df,
    __GlintTagTextTGlyphAddr0,              // 0x0E0
    __GlintTagTextRender2DGlyph0,           // 0x0E1
    __GlintTagTextTGlyphAddr1,              // 0x0E2
    __GlintTagTextRender2DGlyph1,           // 0x0E3
    __GlintTagTextTGlyphAddr2,              // 0x0E4
    __GlintTagTextRender2DGlyph2,           // 0x0E5
    __GlintTagTextTGlyphAddr3,              // 0x0E6
    __GlintTagTextRender2DGlyph3,           // 0x0E7
    __GlintTagTextTGlyphAddr4,              // 0x0E8
    __GlintTagTextRender2DGlyph4,           // 0x0E9
    __GlintTagTextTGlyphAddr5,              // 0x0EA
    __GlintTagTextRender2DGlyph5,           // 0x0EB
    __GlintTagTextTGlyphAddr6,              // 0x0EC
    __GlintTagTextRender2DGlyph6,           // 0x0ED
    __GlintTagTextTGlyphAddr7,              // 0x0EE
    __GlintTagTextRender2DGlyph7,           // 0x0EF
    __GlintTagRStart,                       // 0x0F0
    __GlintTagdRdx,                         // 0x0F1
    __GlintTagdRdyDom,                      // 0x0F2
    __GlintTagGStart,                       // 0x0F3
    __GlintTagdGdx,                         // 0x0F4
    __GlintTagdGdyDom,                      // 0x0F5
    __GlintTagBStart,                       // 0x0F6
    __GlintTagdBdx,                         // 0x0F7
    __GlintTagdBdyDom,                      // 0x0F8
    __GlintTagAStart,                       // 0x0F9
    __GlintTagdAdx,                         // 0x0FA
    __GlintTagdAdyDom,                      // 0x0FB
    __GlintTagColorDDAMode,                 // 0x0FC
    __GlintTagConstantColor,                // 0x0FD
    __GlintTagColor,                        // 0x0FE
    __GlintTagReserved0ff,
    __GlintTagAlphaTestMode,                // 0x100
    __GlintTagAntialiasMode,                // 0x101
    __GlintTagAlphaBlendMode,               // 0x102
    __GlintTagDitherMode,                   // 0x103
    __GlintTagFBSoftwareWriteMask,          // 0x104
    __GlintTagLogicalOpMode,                // 0x105
    __GlintTagFBWriteData,                  // 0x106
    __GlintTagMXSynchronize,                // 0x107
    __GlintTagRouterMode,                   // 0x108
    __GlintTagReserved109,
    __GlintTagReserved101,
    __GlintTagReserved10b,
    __GlintTagReserved10c,
    __GlintTagReserved10d,
    __GlintTagReserved10e,
    __GlintTagReserved10f,
    __GlintTagLBReadMode,                   // 0x110
    __GlintTagLBReadFormat,                 // 0x111
    __GlintTagLBSourceOffset,               // 0x112
    __GlintTagReserved113,
    __GlintTagLBSourceData,                 // 0x114
    __GlintTagLBStencil,                    // 0x115
    __GlintTagLBDepth,                      // 0x116
    __GlintTagLBWindowBase,                 // 0x117
    __GlintTagLBWriteMode,                  // 0x118
    __GlintTagLBWriteFormat,                // 0x119
    __GlintTagReserved11a,
    __GlintTagReserved11b,
    __GlintTagReserved11c,
    __GlintTagTextureData,                  // 0x11D
    __GlintTagTextureDownloadOffset,        // 0x11E
    __GlintTagLBWindowOffset,               // 0x11F
    __GlintTagHostInID,                     // 0x120
    __GlintTagSecurity,                     // 0x121
    __GlintTagFlushWriteCombining,          // 0x122
    __GlintTagHostInState,                  // 0x123
    __GlintTagReserved124,
    __GlintTagReserved125,
    __GlintTagReserved126,
    __GlintTagHostInDMAAddress,             // 0x127
    __GlintTagHostInState2,                 // 0x128
    __GlintTagReserved129,
    __GlintTagReserved12a,
    __GlintTagReserved12b,
    __GlintTagReserved12c,
    __GlintTagReserved12d,
    __GlintTagReserved12e,
    __GlintTagVertexRename,                 // 0x12F
    __GlintTagWindow,                       // 0x130
    __GlintTagStencilMode,                  // 0x131
    __GlintTagStencilData,                  // 0x132
    __GlintTagStencil,                      // 0x133
    __GlintTagDepthMode,                    // 0x134
    __GlintTagDepth,                        // 0x135
    __GlintTagZStartU,                      // 0x136
    __GlintTagZStartL,                      // 0x137
    __GlintTagdZdxU,                        // 0x138
    __GlintTagdZdxL,                        // 0x139
    __GlintTagdZdyDomU,                     // 0x13A
    __GlintTagdZdyDomL,                     // 0x13B
    __GlintTagFastClearDepth,               // 0x13C
    __GlintTagLBCancelWrite,                // 0x13D
    __GlintTagReserved13e,
    __GlintTagReserved13f,
    __GlintTagReserved140,
    __GlintTagReserved141,
    __GlintTagReserved142,
    __GlintTagReserved143,
    __GlintTagReserved144,
    __GlintTagReserved145,
    __GlintTagReserved146,
    __GlintTagReserved147,
    __GlintTagReserved148,
    __GlintTagReserved149,
    __GlintTagReserved14a,
    __GlintTagReserved14b,
    __GlintTagReserved14c,
    __GlintTagReserved14d,
    __GlintTagReserved14e,
    __GlintTagReserved14f,
    __GlintTagFBReadMode,                   // 0x150
    __GlintTagFBSourceOffset,               // 0x151
    __GlintTagFBPixelOffset,                // 0x152
    __GlintTagFBColor,                      // 0x153
    __GlintTagFBData,                       // 0x154
    __GlintTagFBSourceData,                 // 0x155
    __GlintTagFBWindowBase,                 // 0x156
    __GlintTagFBWriteMode,                  // 0x157
    __GlintTagFBHardwareWriteMask,          // 0x158
    __GlintTagFBBlockColor,                 // 0x159
    __PermediaTagFBReadPixel,               // 0x15A
    __PermediaTagFBWritePixel,              // 0x15B
    __GlintTagReserved15c,
    __PermediaTagFBWriteConfig,             // 0x15D
    __GlintTagReserved15e,
    __GlintTagPatternRAMMode,               // 0x15F
    __GlintTagPatternRAMData0,              // 0x160
    __GlintTagPatternRAMData1,              // 0x161
    __GlintTagPatternRAMData2,              // 0x162
    __GlintTagPatternRAMData3,              // 0x163
    __GlintTagPatternRAMData4,              // 0x164
    __GlintTagPatternRAMData5,              // 0x165
    __GlintTagPatternRAMData6,              // 0x166
    __GlintTagPatternRAMData7,              // 0x167
    __GlintTagPatternRAMData8,              // 0x168
    __GlintTagPatternRAMData9,              // 0x169
    __GlintTagPatternRAMData10,             // 0x16A
    __GlintTagPatternRAMData11,             // 0x16B
    __GlintTagPatternRAMData12,             // 0x16C
    __GlintTagPatternRAMData13,             // 0x16D
    __GlintTagPatternRAMData14,             // 0x16E
    __GlintTagPatternRAMData15,             // 0x16F
    __GlintTagPatternRAMData16,             // 0x170
    __GlintTagPatternRAMData17,             // 0x171
    __GlintTagPatternRAMData18,             // 0x172
    __GlintTagPatternRAMData19,             // 0x173
    __GlintTagPatternRAMData20,             // 0x174
    __GlintTagPatternRAMData21,             // 0x175
    __GlintTagPatternRAMData22,             // 0x176
    __GlintTagPatternRAMData23,             // 0x177
    __GlintTagPatternRAMData24,             // 0x178
    __GlintTagPatternRAMData25,             // 0x179
    __GlintTagPatternRAMData26,             // 0x17A
    __GlintTagPatternRAMData27,             // 0x17B
    __GlintTagPatternRAMData28,             // 0x17C
    __GlintTagPatternRAMData29,             // 0x17D
    __GlintTagPatternRAMData30,             // 0x17E
    __GlintTagPatternRAMData31,             // 0x17F
    __GlintTagFilterMode,                   // 0x180
    __GlintTagStatisticMode,                // 0x181
    __GlintTagMinRegion,                    // 0x182
    __GlintTagMaxRegion,                    // 0x183
    __GlintTagResetPickResult,              // 0x184
    __GlintTagMinHitRegion,                 // 0x185
    __GlintTagMaxHitRegion,                 // 0x186
    __GlintTagPickResult,                   // 0x187
    __GlintTagSync,                         // 0x188
    __GlintTagRLEMask,                      // 0x189
    __GlintTagReserved18a,
    __GlintTagFBBlockColorBackU,            // 0x18B
    __GlintTagFBBlockColorBackL,            // 0x18C
    __GlintTagFBBlockColorU,                // 0x18D
    __GlintTagFBBlockColorL,                // 0x18E
    __GlintTagSuspendUntilFrameBlank,       // 0x18F
    __GlintTagKsRStart,                     // 0x190
    __GlintTagdKsRdx,                       // 0x191
    __GlintTagdKsRdyDom,                    // 0x192
    __GlintTagKsGStart,                     // 0x193
    __GlintTagdKsGdx,                       // 0x194
    __GlintTagdKsGdyDom,                    // 0x195
    __GlintTagKsBStart,                     // 0x196
    __GlintTagdKsBdx,                       // 0x197
    __GlintTagdKsBdyDom,                    // 0x198
    __GlintTagReserved199,
    __GlintTagReserved19a,
    __GlintTagReserved19b,
    __GlintTagReserved19c,
    __GlintTagReserved19d,
    __GlintTagReserved19e,
    __GlintTagReserved19f,
    __GlintTagKdRStart,                     // 0x1A0
    __GlintTagdKdRdx,                       // 0x1A1
    __GlintTagdKdRdyDom,                    // 0x1A2
    __GlintTagKdGStart,                     // 0x1A3
    __GlintTagdKdGdx,                       // 0x1A4
    __GlintTagdKdGdyDom,                    // 0x1A5
    __GlintTagKdBStart,                     // 0x1A6
    __GlintTagdKdBdx,                       // 0x1A7
    __GlintTagdKdBdyDom,                    // 0x1A8
    __GlintTagReserved1a9,
    __GlintTagReserved1aa,
    __GlintTagReserved1ab,
    __GlintTagReserved1ac,
    __GlintTagReserved1ad,
    __GlintTagReserved1ae,
    __GlintTagReserved1af,
    __PermediaTagFBSourceBase,              // 0x1B0
    __PermediaTagFBSourceDelta,             // 0x1B1
    __PermediaTagConfig,                    // 0x1B2
    __GlintTagReserved1b3,
    __GlintTagReserved1b4,
    __GlintTagReserved1b5,
    __GlintTagReserved1b6,
    __GlintTagReserved1b7,
    __GlintTagContextDump,                  // 0x1B8
    __GlintTagContextRestore,               // 0x1B9
    __GlintTagContextData,                  // 0x1BA
    __GlintTagReserved1bb,
    __GlintTagReserved1bc,
    __GlintTagReserved1bd,
    __GlintTagReserved1be,
    __GlintTagReserved1bf,
    __GlintTagReserved1c0,
    __GlintTagReserved1c1,
    __GlintTagReserved1c2,
    __GlintTagReserved1c3,
    __GlintTagReserved1c4,
    __GlintTagReserved1c5,
    __GlintTagReserved1c6,
    __GlintTagReserved1c7,
    __GlintTagReserved1c8,
    __GlintTagReserved1c9,
    __GlintTagReserved1ca,
    __GlintTagReserved1cb,
    __GlintTagReserved1cc,
    __GlintTagReserved1cd,
    __GlintTagReserved1ce,
    __GlintTagReserved1cf,
    __GlintTagTexelLUT0,                    // 0x1D0
    __GlintTagTexelLUT1,                    // 0x1D1
    __GlintTagTexelLUT2,                    // 0x1D2
    __GlintTagTexelLUT3,                    // 0x1D3
    __GlintTagTexelLUT4,                    // 0x1D4
    __GlintTagTexelLUT5,                    // 0x1D5
    __GlintTagTexelLUT6,                    // 0x1D6
    __GlintTagTexelLUT7,                    // 0x1D7
    __GlintTagTexelLUT8,                    // 0x1D8
    __GlintTagTexelLUT9,                    // 0x1D9
    __GlintTagTexelLUT10,                   // 0x1DA
    __GlintTagTexelLUT11,                   // 0x1DB
    __GlintTagTexelLUT12,                   // 0x1DC
    __GlintTagTexelLUT13,                   // 0x1DD
    __GlintTagTexelLUT14,                   // 0x1DE
    __GlintTagTexelLUT15,                   // 0x1DF
    __PermediaTagYUVMode,                   // 0x1E0
    __PermediaTagChromaUpperBound,          // 0x1E1
    __PermediaTagChromaLowerBound,          // 0x1E2
    __GlintTagChromaTestMode,               // 0x1E3
    __GlintTagReserved1e4,
    __GlintTagReserved1e5,
    __GlintTagReserved1e6,
    __GlintTagReserved1e7,
    __GlintTagReserved1e8,
    __GlintTagReserved1e9,
    __GlintTagReserved1ea,
    __GlintTagReserved1eb,
    __GlintTagReserved1ec,
    __GlintTagReserved1ed,
    __GlintTagReserved1ee,
    __GlintTagReserved1ef,
    __GlintTagReserved1f0,
    __GlintTagFeedbackX,                    // 0x1F1
    __GlintTagFeedbackY,                    // 0x1F2
    __GlintTagReserved1f3,
    __GlintTagReserved1f4,
    __GlintTagReserved1f5,
    __GlintTagReserved1f6,
    __GlintTagReserved1f7,
    __GlintTagReserved1f8,
    __GlintTagReserved1f9,
    __GlintTagReserved1fa,
    __GlintTagReserved1fb,
    __GlintTagReserved1fc,
    __GlintTagReserved1fd,
    __GlintTagReserved1fe,
    __GlintTagEndOfFeedback,                // 0x1FF
    __DeltaTagV0Fixed0,                     // 0x200
    __DeltaTagV0Fixed1,                     // 0x201
    __DeltaTagV0Fixed2,                     // 0x202
    __DeltaTagV0Fixed3,                     // 0x203
    __DeltaTagV0Fixed4,                     // 0x204
    __DeltaTagV0Fixed5,                     // 0x205
    __DeltaTagV0Fixed6,                     // 0x206
    __DeltaTagV0Fixed7,                     // 0x207
    __DeltaTagV0Fixed8,                     // 0x208
    __DeltaTagV0Fixed9,                     // 0x209
    __DeltaTagV0FixedA,                     // 0x20A
    __DeltaTagV0FixedB,                     // 0x20B
    __DeltaTagV0FixedC,                     // 0x20C
    __GlintTagReserved20d,
    __GlintTagReserved20e,
    __GlintTagReserved20f,
    __DeltaTagV1Fixed0,                     // 0x210
    __DeltaTagV1Fixed1,                     // 0x211
    __DeltaTagV1Fixed2,                     // 0x212
    __DeltaTagV1Fixed3,                     // 0x213
    __DeltaTagV1Fixed4,                     // 0x214
    __DeltaTagV1Fixed5,                     // 0x215
    __DeltaTagV1Fixed6,                     // 0x216
    __DeltaTagV1Fixed7,                     // 0x217
    __DeltaTagV1Fixed8,                     // 0x218
    __DeltaTagV1Fixed9,                     // 0x219
    __DeltaTagV1FixedA,                     // 0x21A
    __DeltaTagV1FixedB,                     // 0x21B
    __DeltaTagV1FixedC,                     // 0x21C
    __GlintTagReserved21d,
    __GlintTagReserved21e,
    __GlintTagReserved21f,
    __DeltaTagV2Fixed0,                     // 0x220
    __DeltaTagV2Fixed1,                     // 0x221
    __DeltaTagV2Fixed2,                     // 0x222
    __DeltaTagV2Fixed3,                     // 0x223
    __DeltaTagV2Fixed4,                     // 0x224
    __DeltaTagV2Fixed5,                     // 0x225
    __DeltaTagV2Fixed6,                     // 0x226
    __DeltaTagV2Fixed7,                     // 0x227
    __DeltaTagV2Fixed8,                     // 0x228
    __DeltaTagV2Fixed9,                     // 0x229
    __DeltaTagV2FixedA,                     // 0x22A
    __DeltaTagV2FixedB,                     // 0x22B
    __DeltaTagV2FixedC,                     // 0x22C
    __GlintTagReserved22d,
    __GlintTagReserved22e,
    __GlintTagReserved22f,
    __DeltaTagV0Float0,                     // 0x230
    __DeltaTagV0Float1,                     // 0x231
    __DeltaTagV0Float2,                     // 0x232
    __DeltaTagV0Float3,                     // 0x233
    __DeltaTagV0Float4,                     // 0x234
    __DeltaTagV0Float5,                     // 0x235
    __DeltaTagV0Float6,                     // 0x236
    __DeltaTagV0Float7,                     // 0x237
    __DeltaTagV0Float8,                     // 0x238
    __DeltaTagV0Float9,                     // 0x239
    __DeltaTagV0FloatA,                     // 0x23A
    __DeltaTagV0FloatB,                     // 0x23B
    __DeltaTagV0FloatC,                     // 0x23C
    __GlintTagReserved23d,
    __GlintTagReserved23e,
    __GlintTagReserved23f,
    __DeltaTagV1Float0,                     // 0x240
    __DeltaTagV1Float1,                     // 0x241
    __DeltaTagV1Float2,                     // 0x242
    __DeltaTagV1Float3,                     // 0x243
    __DeltaTagV1Float4,                     // 0x244
    __DeltaTagV1Float5,                     // 0x245
    __DeltaTagV1Float6,                     // 0x246
    __DeltaTagV1Float7,                     // 0x247
    __DeltaTagV1Float8,                     // 0x248
    __DeltaTagV1Float9,                     // 0x249
    __DeltaTagV1FloatA,                     // 0x24A
    __DeltaTagV1FloatB,                     // 0x24B
    __DeltaTagV1FloatC,                     // 0x24C
    __GlintTagReserved24d,
    __GlintTagReserved24e,
    __GlintTagReserved24f,
    __DeltaTagV2Float0,                     // 0x250
    __DeltaTagV2Float1,                     // 0x251
    __DeltaTagV2Float2,                     // 0x252
    __DeltaTagV2Float3,                     // 0x253
    __DeltaTagV2Float4,                     // 0x254
    __DeltaTagV2Float5,                     // 0x255
    __DeltaTagV2Float6,                     // 0x256
    __DeltaTagV2Float7,                     // 0x257
    __DeltaTagV2Float8,                     // 0x258
    __DeltaTagV2Float9,                     // 0x259
    __DeltaTagV2FloatA,                     // 0x25A
    __DeltaTagV2FloatB,                     // 0x25B
    __DeltaTagV2FloatC,                     // 0x25C
    __GlintTagReserved25d,
    __GlintTagReserved25e,
    __GlintTagReserved25f,
    __DeltaTagDeltaMode,                    // 0x260
    __DeltaTagDrawTriangle,                 // 0x261
    __DeltaTagRepeatTriangle,               // 0x262
    __DeltaTagDrawLine01,                   // 0x263
    __DeltaTagDrawLine10,                   // 0x264
    __DeltaTagRepeatLine,                   // 0x265
    __DeltaTagDrawPoint,                    // 0x266
    __DeltaTagProvokingVertex,              // 0x267
    __DeltaTagTextureLODScale,              // 0x268
    __DeltaTagTextureLODScale1,             // 0x269
    __DeltaTagDeltaControl,                 // 0x26A
    __DeltaTagProvokingVertexMask,          // 0x26B
    __DeltaTagReserved26C,
    __DeltaTagReserved26D,
    __DeltaTagReserved26E,
    __DeltaTagBroadcastMask,                // 0x26F
    __DeltaTagXBias = 0x290,                // 0x290
    __DeltaTagYBias,                        // 0x291
    __DeltaTagZBias,                        // 0x29F
    __DeltaTagLineCoord0 = 0x2EC,           // 0x2EC
    __DeltaTagDrawLine2D10,                 // 0x2ED
    __DeltaTagLineCoord1,                   // 0x2EE
    __DeltaTagDrawLine2D01,                 // 0x2EF

    // Some duplicated tags:
    __PXRXTagStripeOffsetY = 0x019,         // 0x019 = __PermediaTagXLimits
    __PXRXTagTextureCoordMode = 0x070,      // 0x070 = __GlintTagTextureAddressMode

    __PXRXTagS1Start = 0x080,               // 0x080
    __PXRXTagdS1dx,                         // 0x081
    __PXRXTagdS1dyDom,                      // 0x082 = __GlintTagTexelCoordU
    __PXRXTagT1Start,                       // 0x083 = __GlintTagTexelCoordV
    __PXRXTagdT1dx,                         // 0x084
    __PXRXTagdT1dyDom,                      // 0x085
    __PXRXTagQ1Start,                       // 0x086
    __PXRXTagdQ1dx,                         // 0x087
    __PXRXTagdQ1dyDom,                      // 0x088

    __PXRXTagLUTIndex = 0x098,              // 0x098 = __GlintTagTextureLUTIndex
    __PXRXTagLUTData,                       // 0x099 = __GlintTagTextureLUTData
    __PXRXTagLUTAddress,                    // 0x09A = __GlintTagTextureLUTAddress
    __PXRXTagLUTTransfer,                   // 0x09B = __GlintTagTextureLUTTransfer

    __PXRXTagTextureMapWidth0 = 0xB0,       // 0x0B0 = __PermediaTagTextureBaseAddress
    __PXRXTagTextureMapWidth1,              // 0x0B1 = __PermediaTagTextureMapFormat
    __PXRXTagTextureMapWidth2,              // 0x0B2 = __PermediaTagTextureDataFormat
    __PXRXTagTextureMapWidth3,              // 0x0B3
    __PXRXTagTextureMapWidth4,              // 0x0B4
    __PXRXTagTextureMapWidth5,              // 0x0B5
    __PXRXTagTextureMapWidth6,              // 0x0B6
    __PXRXTagTextureMapWidth7,              // 0x0B7
    __PXRXTagTextureMapWidth8,              // 0x0B8
    __PXRXTagTextureMapWidth9,              // 0x0B9
    __PXRXTagTextureMapWidth10,             // 0x0BA
    __PXRXTagTextureMapWidth11,             // 0x0BB
    __PXRXTagTextureMapWidth12,             // 0x0BC
    __PXRXTagTextureMapWidth13,             // 0x0BD
    __PXRXTagTextureMapWidth14,             // 0x0BE
    __PXRXTagTextureMapWidth15,             // 0x0BF

    __PXRXTagTextureChromaUpper1 = 0x0c0,   // 0x0C0
    __PXRXTagTextureChromaLower1,           // 0x0C1

    __PXRXTagTextureApplicationMode = 0x0d0,// 0x0D0 = __GlintTagTextureColorMode

    __PXRXTagYUVMode = 0x1E0,               // 0x1E0 = __PermediaTagYUVMode
    __PXRXTagChromaUpper,                   // 0x1E1 = __PermediaTagChromaUpperBound
    __PXRXTagChromaLower,                   // 0x1E2 = __PermediaTagChromaLowerBound

    __PXRXTagV0FloatS1 = 0x200,             // 0x200
    __PXRXTagV0FloatT1,                     // 0x201
    __PXRXTagV0FloatQ1,                     // 0x202

    __PXRXTagV0FloatKsR = 0x20A,            // 0x20A
    __PXRXTagV0FloatKsG,                    // 0x20B
    __PXRXTagV0FloatKsB,                    // 0x20C
    __PXRXTagV0FloatKdR,                    // 0x20D
    __PXRXTagV0FloatKdG,                    // 0x20E
    __PXRXTagV0FloatKdB,                    // 0x20F
    __PXRXTagV1FloatS1,                     // 0x210
    __PXRXTagV1FloatT1,                     // 0x211
    __PXRXTagV1FloatQ1,                     // 0x212

    __PXRXTagV1FloatKsR = 0x21A,            // 0x21A
    __PXRXTagV1FloatKsG,                    // 0x21B
    __PXRXTagV1FloatKsB,                    // 0x21C
    __PXRXTagV1FloatKdR,                    // 0x21D
    __PXRXTagV1FloatKdG,                    // 0x21E
    __PXRXTagV1FloatKdB,                    // 0x21F
    __PXRXTagV2FloatS1,                     // 0x220
    __PXRXTagV2FloatT1,                     // 0x221
    __PXRXTagV2FloatQ1,                     // 0x222

    __PXRXTagV2FloatKsR = 0x22A,            // 0x22A
    __PXRXTagV2FloatKsG,                    // 0x22B
    __PXRXTagV2FloatKsB,                    // 0x22C
    __PXRXTagV2FloatKdR,                    // 0x22D
    __PXRXTagV2FloatKdG,                    // 0x22E
    __PXRXTagV2FloatKdB,                    // 0x22F
    __PXRXTagV0FloatS,                      // 0x230
    __PXRXTagV0FloatT,                      // 0x231
    __PXRXTagV0FloatQ,                      // 0x232

    __PXRXTagV0FloatR = 0x235,              // 0x235
    __PXRXTagV0FloatG,                      // 0x236
    __PXRXTagV0FloatB,                      // 0x237
    __PXRXTagV0FloatA,                      // 0x238
    __PXRXTagV0FloatF,                      // 0x239
    __PXRXTagV0FloatX,                      // 0x23A
    __PXRXTagV0FloatY,                      // 0x23B
    __PXRXTagV0FloatZ,                      // 0x23C
    __PXRXTagV0FloatW,                      // 0x23D
    __PXRXTagV0FloatPackedColour,           // 0x23E
    __PXRXTagV0FloatPackedSpecularFog,      // 0x23F
    __RXRXTagV1FloatS,                      // 0x240
    __RXRXTagV1FloatT,                      // 0x241
    __RXRXTagV1FloatQ,                      // 0x242

    __RXRXTagV1FloatR = 0x245,              // 0x245
    __RXRXTagV1FloatG,                      // 0x246
    __RXRXTagV1FloatB,                      // 0x247
    __RXRXTagV1FloatA,                      // 0x248
    __RXRXTagV1FloatF,                      // 0x249
    __RXRXTagV1FloatX,                      // 0x24A
    __RXRXTagV1FloatY,                      // 0x24B
    __RXRXTagV1FloatZ,                      // 0x24C
    __RXRXTagV1FloatW,                      // 0x24D
    __RXRXTagV1FloatPackedColour,           // 0x24E
    __RXRXTagV1FloatPackedSpecularFog,      // 0x24F
    __RXRXTagV2FloatS,                      // 0x250
    __RXRXTagV2FloatT,                      // 0x251
    __RXRXTagV2FloatQ,                      // 0x252

    __RXRXTagV2FloatR = 0x255,              // 0x255
    __RXRXTagV2FloatG,                      // 0x256
    __RXRXTagV2FloatB,                      // 0x257
    __RXRXTagV2FloatA,                      // 0x258
    __RXRXTagV2FloatF,                      // 0x259
    __RXRXTagV2FloatX,                      // 0x25A
    __RXRXTagV2FloatY,                      // 0x25B
    __RXRXTagV2FloatZ,                      // 0x25C
    __RXRXTagV2FloatW,                      // 0x25D
    __RXRXTagV2FloatPackedColour,           // 0x25E
    __RXRXTagV2FloatPackedSpecularFog,      // 0x25F

    __GlintTagDMAAddr = 0x530,              // 0x530
    __GlintTagDMACount,                     // 0x531
    __GlintTagCommandInterrupt,             // 0x532
    __GlintTagReserved533,
    __GlintTagReserved534,
    __GlintTagDMARectangleRead,             // 0x535
    __GlintTagDMARectangleReadAddress,      // 0x536
    __GlintTagDMARectangleReadLinePitch,    // 0x537
    __GlintTagDMARectangleReadTarget,       // 0x538
    __GlintTagDMARectangleWrite,            // 0x539
    __GlintTagDMARectangleWriteAddress,     // 0x53A
    __GlintTagDMARectangleWriteLinePitch,   // 0x53B
    __GlintTagDMAOutputAddress,             // 0x53C
    __GlintTagDMAOutputCount,               // 0x53D
    __GlintTagReserved53E,
    __GlintTagDMAContinue,                  // 0x53F
    __GlintTagReserved540,
    __GlintTagReserved541,
    __GlintTagDMAFeedback                   // 0x542
};

// Apparently MSVC can't handle large enums so lets split it in half!
enum __GlintTagList2 {
    __GlintTagDeltaModeAnd = 0x55A,         // 0x55A
    __GlintTagDeltaModeOr,                  // 0x55B
    __GlintTagReserved55C,
    __GlintTagReserved55D,
    __GlintTagReserved55E,
    __GlintTagReserved55F,
    __GlintTagReserved560,
    __GlintTagReserved561,
    __GlintTagReserved562,
    __GlintTagReserved563,
    __GlintTagDeltaControlAnd,              // 0x564
    __GlintTagDeltaControlOr,               // 0x565
    __GlintTagReserved566,
    __GlintTagReserved567,
    __GlintTagReserved568,
    __GlintTagReserved569,
    __GlintTagReserved56A,
    __GlintTagReserved56B,
    __GlintTagReserved56C,
    __GlintTagReserved56D,
    __GlintTagReserved56E,
    __GlintTagReserved56F,
    __GlintTagWindowAnd,                    // 0x570
    __GlintTagWindowOr,                     // 0x571
    __GlintTagLBReadModeAnd,                // 0x572
    __GlintTagLBReadModeOr,                 // 0x573
    __GlintTagRasterizerModeAnd,            // 0x574
    __GlintTagRasterizerModeOr,             // 0x575
    __GlintTagScissorModeAnd,               // 0x576
    __GlintTagScissorModeOr,                // 0x577
    __GlintTagLineStippleModeAnd,           // 0x578
    __GlintTagLineStippleModeOr,            // 0x579
    __GlintTagAreaStippleModeAnd,           // 0x57A
    __GlintTagAreaStippleModeOr,            // 0x57B
    __GlintTagColorDDAModeAnd,              // 0x57C
    __GlintTagColorDDAModeOr,               // 0x57D
    __GlintTagAlphaTestModeAnd,             // 0x57E
    __GlintTagAlphaTestModeOr,              // 0x57F
    __GlintTagAntialiasModeAnd,             // 0x580
    __GlintTagAntialiasModeOr,              // 0x581
    __GlintTagFogModeAnd,                   // 0x582
    __GlintTagFogModeOr,                    // 0x583
    __GlintTagTextureCoordModeAnd,          // 0x584
    __GlintTagTextureCoordModeOr,           // 0x585
    __GlintTagTextureReadMode0And,          // 0x586
    __GlintTagTextureReadMode0Or,           // 0x587
    __GlintTagTextureFormatAnd,             // 0x588
    __GlintTagTextureFormatOr,              // 0x589
    __GlintTagTextureApplicationModeAnd,    // 0x58A
    __GlintTagTextureApplicationModeOr,     // 0x58B
    __GlintTagStencilModeAnd,               // 0x58C
    __GlintTagStencilModeOr,                // 0x58D
    __GlintTagDepthModeAnd,                 // 0x58E
    __GlintTagDepthModeOr,                  // 0x58F
    __GlintTagLBWriteModeAnd,               // 0x590
    __GlintTagLBWriteModeOr,                // 0x591
    __GlintTagFBDestReadModeAnd,            // 0x592
    __GlintTagFBDestReadModeOr,             // 0x593
    __GlintTagFBSourceReadModeAnd,          // 0x594
    __GlintTagFBSourceReadModeOr,           // 0x595
    __GlintTagAlphaBlendColorModeAnd,       // 0x596
    __GlintTagAlphaBlendColorModeOr,        // 0x597
    __GlintTagChromaTestModeAnd,            // 0x598
    __GlintTagChromaTestModeOr,             // 0x599
    __GlintTagDitherModeAnd,                // 0x59A
    __GlintTagDitherModeOr,                 // 0x59B
    __GlintTagLogicalOpModeAnd,             // 0x59C
    __GlintTagLogicalOpModeOr,              // 0x59D
    __GlintTagFBWriteModeAnd,               // 0x59E
    __GlintTagFBWriteModeOr,                // 0x59F
    __GlintTagFilterModeAnd,                // 0x5A0
    __GlintTagFilterModeOr,                 // 0x5A1
    __GlintTagStatisticModeAnd,             // 0x5A2
    __GlintTagStatisticModeOr,              // 0x5A3
    __GlintTagFBDestReadEnablesAnd,         // 0x5A4
    __GlintTagFBDestReadEnablesOr,          // 0x5A5
    __GlintTagAlphaBlendAlphaModeAnd,       // 0x5A6
    __GlintTagAlphaBlendAlphaModeOr,        // 0x5A7
    __GlintTagTextureReadMode1And,          // 0x5A8
    __GlintTagTextureReadMode1Or,           // 0x5A9
    __GlintTagTextureFilterModeAnd,         // 0x5AA
    __GlintTagTextureFilterModeOr,          // 0x5AB
    __GlintTagReserved5AC,
    __GlintTagReserved5AD,
    __GlintTagLUTModeAnd,                   // 0x5AE
    __GlintTagLUTModeOr,                    // 0x5AF
    __GlintTagReserved5B0,
    __GlintTagReserved5B1,
    __GlintTagReserved5B2,
    __GlintTagReserved5B3,
    __GlintTagReserved5B4,
    __GlintTagReserved5B5,
    __GlintTagReserved5B6,
    __GlintTagReserved5B7,
    __GlintTagReserved5B8,
    __GlintTagReserved5B9,
    __GlintTagReserved5BA,
    __GlintTagReserved5BB,
    __GlintTagReserved5BC,
    __GlintTagReserved5BD,
    __GlintTagReserved5BE,
    __GlintTagReserved5BF,
    __GlintTagReserved5C0,
    __GlintTagReserved5C1,
    __GlintTagReserved5C2,
    __GlintTagReserved5C3,
    __GlintTagReserved5C4,
    __GlintTagReserved5C5,
    __GlintTagReserved5C6,
    __GlintTagReserved5C7,
    __GlintTagReserved5C8,
    __GlintTagReserved5C9,
    __GlintTagReserved5CA,
    __GlintTagReserved5CB,
    __GlintTagReserved5CC,
    __GlintTagReserved5CD,
    __GlintTagReserved5CE,
    __GlintTagReserved5CF,
    __GlintTagFBDestReadBufferAddr0,        // 0x5D0
    __GlintTagFBDestReadBufferAddr1,        // 0x5D1
    __GlintTagFBDestReadBufferAddr2,        // 0x5D2
    __GlintTagFBDestReadBufferAddr3,        // 0x5D3
    __GlintTagFBDestReadBufferOffset0,      // 0x5D4
    __GlintTagFBDestReadBufferOffset1,      // 0x5D5
    __GlintTagFBDestReadBufferOffset2,      // 0x5D6
    __GlintTagFBDestReadBufferOffset3,      // 0x5D7
    __GlintTagFBDestReadBufferWidth0,       // 0x5D8
    __GlintTagFBDestReadBufferWidth1,       // 0x5D9
    __GlintTagFBDestReadBufferWidth2,       // 0x5DA
    __GlintTagFBDestReadBufferWidth3,       // 0x5DB
    __GlintTagFBDestReadMode,               // 0x5DC
    __GlintTagFBDestReadEnables,            // 0x5DD
    __GlintTagReserved5DE,
    __GlintTagReserved5DF,
    __GlintTagFBSourceReadMode,             // 0x5E0
    __GlintTagFBSourceReadBufferAddr,       // 0x5E1
    __GlintTagFBSourceReadBufferOffset,     // 0x5E2
    __GlintTagFBSourceReadBufferWidth,      // 0x5E3
    __GlintTagReserved5E4,
    __GlintTagReserved5E5,
    __GlintTagReserved5E6,
    __GlintTagMergeSpanData,                // 0x5E7
    __GlintTagPCIWindowBase0,               // 0x5E8
    __GlintTagPCIWindowBase1,               // 0x5E9
    __GlintTagPCIWindowBase2,               // 0x5EA
    __GlintTagPCIWindowBase3,               // 0x5EB
    __GlintTagPCIWindowBase4,               // 0x5EC
    __GlintTagPCIWindowBase5,               // 0x5ED
    __GlintTagPCIWindowBase6,               // 0x5EE
    __GlintTagPCIWindowBase7,               // 0x5EF
    __GlintTagAlphaSourceColor,             // 0x5F0
    __GlintTagAlphaDestColor,               // 0x5F1
    __GlintTagChromaPassColor,              // 0x5F2
    __GlintTagChromaFailColor,              // 0x5F3
    __GlintTagAlphaBlendColorMode,          // 0x5F4
    __GlintTagAlphaBlendAlphaMode,          // 0x5F5
    __GlintTagConstantColorDDA,             // 0x5F6
    __GlintTagReserved5F7,
    __GlintTagD3DAlphaTestMode,             // 0x5F8
    __GlintTagReserved5F9,
    __GlintTagReserved5FA,
    __GlintTagReserved5FB,
    __GlintTagReserved5FC,
    __GlintTagReserved5FD,
    __GlintTagReserved5FE,
    __GlintTagReserved5FF,
    __GlintTagFBWriteBufferAddr0,           // 0x600
    __GlintTagFBWriteBufferAddr1,           // 0x601
    __GlintTagFBWriteBufferAddr2,           // 0x602
    __GlintTagFBWriteBufferAddr3,           // 0x603
    __GlintTagFBWriteBufferOffset0,         // 0x604
    __GlintTagFBWriteBufferOffset1,         // 0x605
    __GlintTagFBWriteBufferOffset2,         // 0x606
    __GlintTagFBWriteBufferOffset3,         // 0x607
    __GlintTagFBWriteBufferWidth0,          // 0x608
    __GlintTagFBWriteBufferWidth1,          // 0x609
    __GlintTagFBWriteBufferWidth2,          // 0x60A
    __GlintTagFBWriteBufferWidth3,          // 0x60B
    __GlintTagFBBlockColor0,                // 0x60C
    __GlintTagFBBlockColor1,                // 0x60D
    __GlintTagFBBlockColor2,                // 0x60E
    __GlintTagFBBlockColor3,                // 0x60F
    __GlintTagFBBlockColorBack0,            // 0x610
    __GlintTagFBBlockColorBack1,            // 0x611
    __GlintTagFBBlockColorBack2,            // 0x612
    __GlintTagFBBlockColorBack3,            // 0x613
    __GlintTagFBBlockColorBack,             // 0x614
    __GlintTagSizeOfFramebuffer,            // 0x615
    __GlintTagVTGAddress,                   // 0x616
    __GlintTagVTGData,                      // 0x617
    __GlintTagForegroundColor,              // 0x618
    __GlintTagBackgroundColor,              // 0x619
    __GlintTagDownloadAddress,              // 0x61A
    __GlintTagDownloadData,                 // 0x61B
    __GlintTagFBBlockColorExt,              // 0x61C
    __GlintTagFBBlockColorBackExt,          // 0x61D
    __GlintTagFBWriteMaskExt,               // 0x61E
    __GlintTagReserved61F,
    __GlintTagFogTable0,                    // 0x620
    __GlintTagFogTable1,                    // 0x621
    __GlintTagFogTable2,                    // 0x622
    __GlintTagFogTable3,                    // 0x623
    __GlintTagFogTable4,                    // 0x624
    __GlintTagFogTable5,                    // 0x625
    __GlintTagFogTable6,                    // 0x626
    __GlintTagFogTable7,                    // 0x627
    __GlintTagFogTable8,                    // 0x628
    __GlintTagFogTable9,                    // 0x629
    __GlintTagFogTable10,                   // 0x62A
    __GlintTagFogTable11,                   // 0x62B
    __GlintTagFogTable12,                   // 0x62C
    __GlintTagFogTable13,                   // 0x62D
    __GlintTagFogTable14,                   // 0x62E
    __GlintTagFogTable15,                   // 0x62F
    __GlintTagFogTable16,                   // 0x630
    __GlintTagFogTable17,                   // 0x631
    __GlintTagFogTable18,                   // 0x632
    __GlintTagFogTable19,                   // 0x633
    __GlintTagFogTable20,                   // 0x634
    __GlintTagFogTable21,                   // 0x635
    __GlintTagFogTable22,                   // 0x636
    __GlintTagFogTable23,                   // 0x637
    __GlintTagFogTable24,                   // 0x638
    __GlintTagFogTable25,                   // 0x639
    __GlintTagFogTable26,                   // 0x63A
    __GlintTagFogTable27,                   // 0x63B
    __GlintTagFogTable28,                   // 0x63C
    __GlintTagFogTable29,                   // 0x63D
    __GlintTagFogTable30,                   // 0x63E
    __GlintTagFogTable31,                   // 0x63F
    __GlintTagFogTable32,                   // 0x640
    __GlintTagFogTable33,                   // 0x641
    __GlintTagFogTable34,                   // 0x642
    __GlintTagFogTable35,                   // 0x643
    __GlintTagFogTable36,                   // 0x644
    __GlintTagFogTable37,                   // 0x645
    __GlintTagFogTable38,                   // 0x646
    __GlintTagFogTable39,                   // 0x647
    __GlintTagFogTable40,                   // 0x648
    __GlintTagFogTable41,                   // 0x649
    __GlintTagFogTable42,                   // 0x64A
    __GlintTagFogTable43,                   // 0x64B
    __GlintTagFogTable44,                   // 0x64C
    __GlintTagFogTable45,                   // 0x64D
    __GlintTagFogTable46,                   // 0x64E
    __GlintTagFogTable47,                   // 0x64F
    __GlintTagFogTable48,                   // 0x650
    __GlintTagFogTable49,                   // 0x651
    __GlintTagFogTable50,                   // 0x652
    __GlintTagFogTable51,                   // 0x653
    __GlintTagFogTable52,                   // 0x654
    __GlintTagFogTable53,                   // 0x655
    __GlintTagFogTable54,                   // 0x656
    __GlintTagFogTable55,                   // 0x657
    __GlintTagFogTable56,                   // 0x658
    __GlintTagFogTable57,                   // 0x659
    __GlintTagFogTable58,                   // 0x65A
    __GlintTagFogTable59,                   // 0x65B
    __GlintTagFogTable60,                   // 0x65C
    __GlintTagFogTable61,                   // 0x65D
    __GlintTagFogTable62,                   // 0x65E
    __GlintTagFogTable63,                   // 0x65F
    __GlintTagTextureCompositeMode,         // 0x660
    __GlintTagTextureCompositeColorMode0,   // 0x661
    __GlintTagTextureCompositeAlphaMode0,   // 0x662
    __GlintTagTextureCompositeColorMode1,   // 0x663
    __GlintTagTextureCompositeAlphaMode1,   // 0x664
    __GlintTagTextureCompositeFactor0,      // 0x665
    __GlintTagTextureCompositeFactor1,      // 0x666
    __GlintTagTextureIndexMode0,            // 0x667
    __GlintTagTextureIndexMode1,            // 0x668
    __GlintTagLodRange0,                    // 0x669
    __GlintTagLodRange1,                    // 0x66A
    __GlintTagInvalidateCache,              // 0x66B
    __GlintTagSetLogicalTexturePage,        // 0x66C
    __GlintTagUpdateLogicalTextureInfo,     // 0x66D
    __GlintTagTouchLogicalPage,             // 0x66E
    __GlintTagLUTMode,                      // 0x66F
    __GlintTagTextureCompositeColorMode0And,// 0x670
    __GlintTagTextureCompositeColorMode0Or, // 0x671
    __GlintTagTextureCompositeAlphaMode0And,// 0x672
    __GlintTagTextureCompositeAlphaMode0Or, // 0x673
    __GlintTagTextureCompositeColorMode1And,// 0x674
    __GlintTagTextureCompositeColorMode1Or, // 0x675
    __GlintTagTextureCompositeAlphaMode1And,// 0x676
    __GlintTagTextureCompositeAlphaMode1Or, // 0x677
    __GlintTagTextureIndexMode0And,         // 0x678
    __GlintTagTextureIndexMode0Or,          // 0x679
    __GlintTagTextureIndexMode1And,         // 0x67A
    __GlintTagTextureIndexMode1Or,          // 0x67B
    __GlintTagStencilDataAnd,               // 0x67C
    __GlintTagReserved67D,
    __GlintTagReserved67E,
    __GlintTagReserved67F,
    __GlintTagTextureReadMode0,             // 0x680
    __GlintTagTextureReadMode1,             // 0x681
    __GlintTagReserved682,
    __GlintTagReserved683,
    __GlintTagReserved684,
    __GlintTagTextureMapSize,               // 0x685
    __GlintTagTextureCacheReplacementMode,  // 0x686
    __GlintTagReserved687,
    __GlintTagReserved688,
    __GlintTagReserved689,
    __GlintTagReserved68A,
    __GlintTagReserved68B,
    __GlintTagReserved68C,
    __GlintTagStencilDataOr,                // 0x68D
    __GlintTagReserved68E,
    __GlintTagReserved68F,
    __GlintTagHeadPhysicalPageAllocation0,  // 0x690
    __GlintTagHeadPhysicalPageAllocation1,  // 0x691
    __GlintTagHeadPhysicalPageAllocation2,  // 0x692
    __GlintTagHeadPhysicalPageAllocation3,  // 0x693
    __GlintTagTailPhysicalPageAllocation0,  // 0x694
    __GlintTagTailPhysicalPageAllocation1,  // 0x695
    __GlintTagTailPhysicalPageAllocation2,  // 0x696
    __GlintTagTailPhysicalPageAllocation3,  // 0x697
    __GlintTagPhysicalPageAllocationTableAddr,
    __GlintTagBasePageOfWorkingSet,         // 0x699
    __GlintTagLogicalTexturePageTableAddr,  // 0x69A
    __GlintTagLogicalTexturePageTableLength,// 0x69B
    __GlintTagBasePageOfWorkingSetHost,     // 0x69C
    __GlintTagReserved69D,
    __GlintTagReserved69E,
    __GlintTagReserved69F,
    __GlintTagLBDestReadMode,               // 0x6A0
    __GlintTagLBDestReadEnables,            // 0x6A1
    __GlintTagLBDestReadBufferAddr,         // 0x6A2
    __GlintTagLBDestReadBufferOffset,       // 0x6A3
    __GlintTagLBSourceReadMode,             // 0x6A4
    __GlintTagLBSourceReadBufferAddr,       // 0x6A5
    __GlintTagLBSourceReadBufferOffset,     // 0x6A6
    __GlintTagGIDMode,                      // 0x6A7
    __GlintTagLBWriteBufferAddr,            // 0x6A8
    __GlintTagLBWriteBufferOffset,          // 0x6A9
    __GlintTagLBClearDataL,                 // 0x6AA
    __GlintTagLBClearDataU,                 // 0x6AB
    __GlintTagReserved6AC,
    __GlintTagReserved6AD,
    __GlintTagReserved6AE,
    __GlintTagReserved6AF,
    __GlintTagLBDestReadModeAnd,            // 0x6B0
    __GlintTagLBDestReadModeOr,             // 0x6B1
    __GlintTagLBDestReadEnablesAnd,         // 0x6B2
    __GlintTagLBDestReadEnablesOr,          // 0x6B3
    __GlintTagLBSourceReadModeAnd,          // 0x6B4
    __GlintTagLBSourceReadModeOr,           // 0x6B5
    __GlintTagGIDModeAnd,                   // 0x6B6
    __GlintTagGIDModeOr,                    // 0x6B7
    __GlintTagReserved6B8,
    __GlintTagReserved6B9,
    __GlintTagReserved6BA,
    __GlintTagReserved6BB,
    __GlintTagReserved6BC,
    __GlintTagReserved6BD,
    __GlintTagReserved6BE,
    __GlintTagReserved6BF,
    __GlintTagRectanglePosition,            // 0x6C0
    __GlintTagGlyphPosition,                // 0x6C1
    __GlintTagRenderPatchOffset,            // 0x6C2
    __GlintTagConfig2D,                     // 0x6C3
    __GlintTagReserved6C4,
    __GlintTagReserved6C5,
    __GlintTagPacked8Pixels,                // 0x6C6
    __GlintTagPacked16Pixels,               // 0x6C7
    __GlintTagRender2D,                     // 0x6C8
    __GlintTagRender2DGlyph,                // 0x6C9
    __GlintTagDownloadTarget,               // 0x6CA
    __GlintTagDownloadGlyphWidth,           // 0x6CB
    __GlintTagGlyphData,                    // 0x6CC
    __GlintTagPacked4Pixels,                // 0x6CD
    __GlintTagRLData,                       // 0x6CE
    __GlintTagRLCount,                      // 0x6CF
    __GlintTagSClkProfileMask0,             // 0x6D0
    __GlintTagSClkProfileMask1,             // 0x6D1
    __GlintTagSClkProfileCount0,            // 0x6D2
    __GlintTagSClkProfileCount1,            // 0x6D3
    __GlintTagKClkProfileMask0,             // 0x6D4
    __GlintTagKClkProfileMask1,             // 0x6D5
    __GlintTagKClkProfileMask2,             // 0x6D6
    __GlintTagKClkProfileMask3,             // 0x6D7
    __GlintTagKClkProfileCount0,            // 0x6D8
    __GlintTagKClkProfileCount1,            // 0x6D9
    __GlintTagKClkProfileCount2,            // 0x6DA
    __GlintTagKClkProfileCount3,            // 0x6DB
    __GlintTagReserved6DC,
    __GlintTagReserved6DD,
    __GlintTagReserved6DE,
    __GlintTagReserved6DF,
    __GlintTagIndexBaseAddress,             // 0x6E0
    __GlintTagVertexBaseAddress,            // 0x6E1
    __GlintTagIndexedTriangleList,          // 0x6E2
    __GlintTagIndexedTriangleFan,           // 0x6E3
    __GlintTagIndexedTriangleStrip,         // 0x6E4
    __GlintTagIndexedLineList,              // 0x6E5
    __GlintTagIndexedLineStrip,             // 0x6E6
    __GlintTagIndexedPointList,             // 0x6E7
    __GlintTagIndexedPolygon,               // 0x6E8
    __GlintTagVertexTriangleList,           // 0x6E9
    __GlintTagVertexTriangleFan,            // 0x6EA
    __GlintTagVertexTriangleStrip,          // 0x6EB
    __GlintTagVertexLineList,               // 0x6EC
    __GlintTagVertexLineStrip,              // 0x6ED
    __GlintTagVertexPointList,              // 0x6EE
    __GlintTagVertexPolygon,                // 0x6EF
    __GlintTagDMAMemoryControl,             // 0x6F0
    __GlintTagVertexValid,                  // 0x6F1
    __GlintTagVertexFormat,                 // 0x6F2
    __GlintTagVertexControl,                // 0x6F3
    __GlintTagRetainedRender,               // 0x6F4
    __GlintTagIndexedVertex,                // 0x6F5
    __GlintTagIndexedDoubleVertex,          // 0x6F6
    __GlintTagVertex0,                      // 0x6F7
    __GlintTagVertex1,                      // 0x6F8
    __GlintTagVertex2,                      // 0x6F9
    __GlintTagVertexData0,                  // 0x6FA
    __GlintTagVertexData1,                  // 0x6FB
    __GlintTagVertexData2,                  // 0x6FC
    __GlintTagVertexData,                   // 0x6FD
    __GlintTagVertexTagList0,               // 0x700
    __GlintTagVertexTagList1,               // 0x701
    __GlintTagVertexTagList2,               // 0x702
    __GlintTagVertexTagList3,               // 0x703
    __GlintTagVertexTagList4,               // 0x704
    __GlintTagVertexTagList5,               // 0x705
    __GlintTagVertexTagList6,               // 0x706
    __GlintTagVertexTagList7,               // 0x707
    __GlintTagVertexTagList8,               // 0x708
    __GlintTagVertexTagList9,               // 0x709
    __GlintTagVertexTagList10,              // 0x70A
    __GlintTagVertexTagList11,              // 0x70B
    __GlintTagVertexTagList12,              // 0x70C
    __GlintTagVertexTagList13,              // 0x70D
    __GlintTagVertexTagList14,              // 0x70E
    __GlintTagVertexTagList15,              // 0x70F
    __GlintTagVertexTagList16,              // 0x710
    __GlintTagVertexTagList17,              // 0x711
    __GlintTagVertexTagList18,              // 0x712
    __GlintTagVertexTagList19,              // 0x713
    __GlintTagVertexTagList20,              // 0x714
    __GlintTagVertexTagList21,              // 0x715
    __GlintTagVertexTagList22,              // 0x716
    __GlintTagVertexTagList23,              // 0x717
    __GlintTagVertexTagList24,              // 0x718
    __GlintTagVertexTagList25,              // 0x719
    __GlintTagVertexTagList26,              // 0x71A
    __GlintTagVertexTagList27,              // 0x71B
    __GlintTagVertexTagList28,              // 0x71C
    __GlintTagVertexTagList29,              // 0x71D
    __GlintTagVertexTagList30,              // 0x71E
    __GlintTagVertexTagList31               // 0x71F
};

#define NAreaStipplePattern 32
#define __GlintTagAreaStipplePattern(i)         (0x040+(i))
#define IsAreaStipplePattern(t)        (((t)&0x1e0)==0x040)
#define __NGlintTag  (1 << 9)

#define __MaximumGlintTagValue  0x071E

typedef long __GlintTag ;

#endif /* glinttag_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\linalloc.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: linalloc.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef __LINALLOC_H_
#define __LINALLOC_H_


// Result values from calls to videomem allocator functions
#define GLDD_FAILED             ((DWORD)(-1))
#define GLDD_SUCCESS            0
#define GLDD_NOMEM              1
#define GLDD_INVALIDARGS        2
#define GLDD_FREE_REFERENCE     3

typedef struct tagMEMREQUEST
{
    DWORD dwSize;     // Size of this structure
    DWORD dwFlags;    // Flags for this allocation
    DWORD dwAlign;    // Alignment (minimum 4 Bytes)
    DWORD dwBytes;    // Bytes to allocated (aligned up to DWORD multiples)
    DWORD pMem;       // Pointer to the start of the memory returned

} P3_MEMREQUEST, *LPMEMREQUEST;

// P3_MEMREQUEST.dwFlags values for memory allocation
// Favour which end of memory?
#define MEM3DL_FRONT                    1
#define MEM3DL_BACK                     2
// Allocation strategy
#define MEM3DL_FIRST_FIT                8

typedef struct LinearAllocatorInfo;
typedef void (*LinearAllocatorCallbackFn)( DWORD, DWORD );

// Video local memory allocation functions
BOOL _DX_LIN_InitialiseHeapManager(LinearAllocatorInfo* pAlloc,
                                   DWORD dwMemStar, DWORD dwMemEnd);
void _DX_LIN_UnInitialiseHeapManager(LinearAllocatorInfo* pAlloc);
DWORD _DX_LIN_GetFreeMemInHeap(LinearAllocatorInfo* pAlloc);
DWORD _DX_LIN_AllocateLinearMemory(LinearAllocatorInfo* pAlloc,
                                   LPMEMREQUEST lpmmrq);
DWORD _DX_LIN_FreeLinearMemory(LinearAllocatorInfo* pAlloc, 
                               DWORD dwPointer);

// We will use a bitwise memory map to keep track of used & free memory
// (The size of this structure will be for now 32K , which will give us
// a total of 256K chunks, which for a 32MB heap means each chunk 
// controls 128 bytes)
#define MEMORY_MAP_SIZE (32*1024)/sizeof(DWORD)

typedef DWORD MemoryMap[MEMORY_MAP_SIZE]; // Chunks memory map 

typedef struct tagHashTable HashTable; // Forward decl when referenced from GDI

typedef struct tagLinearAllocatorInfo
{
    BOOL  bResetLinAllocator;         // Bool to signal us the allocators
                                      //  have been reset from the 16 bit side
    DWORD dwMemStart;                 // Start of the managed memory
    DWORD dwMemEnd;                   // End of the managed memory
    DWORD dwMaxChunks;                // Max # of chunks (can't exceed 
                                      //  MEMORY_MAP_SIZE*CHUNKS_PER_ELEM)
    DWORD dwMemPerChunk;              // How much heap memory each chunk
                                      //  controls
    MemoryMap *pMMap;                 // Ptr to allocations memory map
    MemoryMap *pLenMap;               // Ptr to lenghts memory map so we don't
                                      // have to keep the sizes allocated to 
                                      // each request 
} LinearAllocatorInfo;


#endif // __LINALLOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\p3rd.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: p3rd.h
*
* Content: This module contains the definitions for the P2ST internal RAMDAC.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// structure with all the direct access registers
typedef struct _P3RD_regs
{
    RAMDAC_REG  RDPaletteWriteAddress;
    RAMDAC_REG  RDPaletteData;
    RAMDAC_REG  RDPixelMask;
    RAMDAC_REG  RDPaletteAddressRead;
    RAMDAC_REG  RDIndexLow;
    RAMDAC_REG  RDIndexHigh;
    RAMDAC_REG  RDIndexedData;
    RAMDAC_REG  RDIndexControl;
}
P3RDRAMDAC, pP3RDRAMDAC;

// macro declared by any function wishing to use the RGB525 RAMDAC. MUST be declared
// after GLINT_DECL.
//
#if MINIVDD
#define P3RD_DECL \
    P3RDRAMDAC   *pP3RDRegs = (P3RDRAMDAC *)&(pDev->pRegisters->Glint.ExtVCReg)
#else
#define P3RD_DECL \
    P3RDRAMDAC   *pP3RDRegs = (P3RDRAMDAC *)&(pRegisters->Glint.ExtVCReg)
#define P3RX_RD_DECL    \
    P3RDRAMDAC   *pP3RDRegs = (P3RDRAMDAC *)&(pThisDisplay->pGlint->ExtVCReg)
#endif

#if P3R3DX_VIDEO 
#define VideoDebugPrint(arg)
#endif

// use the following macros as the address to pass to the
// VideoPortWriteRegisterUlong function
//
#define P3RD_PAL_WR_ADDR              ((PULONG)&(pP3RDRegs->RDPaletteWriteAddress.reg))
#define P3RD_PAL_RD_ADDR              ((PULONG)&(pP3RDRegs->RDPaletteAddressRead.reg))
#define P3RD_PAL_DATA                 ((PULONG)&(pP3RDRegs->RDPaletteData.reg))
#define P3RD_PIXEL_MASK               ((PULONG)&(pP3RDRegs->RDPixelMask.reg))
#define P3RD_INDEX_ADDR_LO            ((PULONG)&(pP3RDRegs->RDIndexLow.reg))
#define P3RD_INDEX_ADDR_HI            ((PULONG)&(pP3RDRegs->RDIndexHigh.reg))
#define P3RD_INDEX_DATA               ((PULONG)&(pP3RDRegs->RDIndexedData.reg))
#define P3RD_INDEX_CONTROL            ((PULONG)&(pP3RDRegs->RDIndexControl.reg))

// bit field definitions for the direct access registers
#define P3RD_IDX_CTL_AUTOINCREMENT_ENABLED  0x01

// indexed register definitions accessed via P3RD_LOAD_INDEX_REG() and P3RD_READ_INDEX_REG()
#define P3RD_MISC_CONTROL               0x0000
#define P3RD_SYNC_CONTROL               0x0001
#define P3RD_DAC_CONTROL                0x0002
#define P3RD_PIXEL_SIZE                 0x0003
#define P3RD_COLOR_FORMAT               0x0004
#define P3RD_CURSOR_MODE                0x0005
#define P3RD_CURSOR_CONTROL             0x0006
#define P3RD_CURSOR_X_LOW               0x0007
#define P3RD_CURSOR_X_HIGH              0x0008
#define P3RD_CURSOR_Y_LOW               0x0009
#define P3RD_CURSOR_Y_HIGH              0x000a
#define P3RD_CURSOR_HOTSPOT_X           0x000b
#define P3RD_CURSOR_HOTSPOT_Y           0x000c
#define P3RD_OVERLAY_KEY                0x000d
#define P3RD_PAN                        0x000e
#define P3RD_SENSE                      0x000f
#define P3RD_CHECK_CONTROL              0x0018
#define P3RD_CHECK_PIXEL_RED            0x0019
#define P3RD_CHECK_PIXEL_GREEN          0x001a
#define P3RD_CHECK_PIXEL_BLUE           0x001b
#define P3RD_CHECK_LUT_RED              0x001c
#define P3RD_CHECK_LUT_GREEN            0x001d
#define P3RD_CHECK_LUT_BLUE             0x001e
#define P3RD_SCRATCH                    0x001f
#define P3RD_VIDEO_OVERLAY_CONTROL      0x0020
#define P3RD_VIDEO_OVERLAY_XSTARTLOW    0x0021
#define P3RD_VIDEO_OVERLAY_XSTARTHIGH   0x0022
#define P3RD_VIDEO_OVERLAY_YSTARTLOW    0x0023
#define P3RD_VIDEO_OVERLAY_YSTARTHIGH   0x0024
#define P3RD_VIDEO_OVERLAY_XENDLOW      0x0025
#define P3RD_VIDEO_OVERLAY_XENDHIGH     0x0026
#define P3RD_VIDEO_OVERLAY_YENDLOW      0x0027
#define P3RD_VIDEO_OVERLAY_YENDHIGH     0x0028
#define P3RD_VIDEO_OVERLAY_KEYR         0x0029
#define P3RD_VIDEO_OVERLAY_KEYG         0x002a
#define P3RD_VIDEO_OVERLAY_KEYB         0x002b
#define P3RD_VIDEO_OVERLAY_BLEND        0x002c

#define P3RD_DCLK_SETUP_1               0x01f0
#define P3RD_DCLK_SETUP_2               0x01f1
#define P3RD_KCLK_SETUP_1               0x01f2
#define P3RD_KCLK_SETUP_2               0x01f3
#define P3RD_DCLK_CONTROL               0x0200
#define P3RD_DCLK0_PRE_SCALE            0x0201
#define P3RD_DCLK0_FEEDBACK_SCALE       0x0202
#define P3RD_DCLK0_POST_SCALE           0x0203
#define P3RD_DCLK1_PRE_SCALE            0x0204
#define P3RD_DCLK1_FEEDBACK_SCALE       0x0205
#define P3RD_DCLK1_POST_SCALE           0x0206
#define P3RD_DCLK2_PRE_SCALE            0x0207
#define P3RD_DCLK2_FEEDBACK_SCALE       0x0208
#define P3RD_DCLK2_POST_SCALE           0x0209
#define P3RD_DCLK3_PRE_SCALE            0x020a
#define P3RD_DCLK3_FEEDBACK_SCALE       0x020b
#define P3RD_DCLK3_POST_SCALE           0x020c
#define P3RD_KCLK_CONTROL               0x020d
#define P3RD_KCLK_PRE_SCALE             0x020e
#define P3RD_KCLK_FEEDBACK_SCALE        0x020f
#define P3RD_KCLK_POST_SCALE            0x0210
#define P3RD_MCLK_CONTROL               0x0211
#define P3RD_SCLK_CONTROL               0x0215
#define P3RD_CURSOR_PALETTE_START       0x0303      // 303..32f
#define P3RD_CURSOR_PATTERN_START       0x0400      // 400..7ff

// bit field definitions for the indexed registers
#define P3RD_MISC_CONTROL_STEREODOUBLEBUFFER    0x80
#define P3RD_MISC_CONTROL_VSBOUTPUT             0x40
#define P3RD_MISC_CONTROL_PIXELDOUBLEBUFFER     0x20
#define P3RD_MISC_CONTROL_OVERLAYS_ENABLED      0x10
#define P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED  0x08
#define P3RD_MISC_CONTROL_HIGHCOLORRES          0x01

#define P3RD_SYNC_CONTROL_VSYNC_ACTIVE_LOW  0x00
#define P3RD_SYNC_CONTROL_VSYNC_ACTIVE_HIGH 0x08
#define P3RD_SYNC_CONTROL_VSYNC_OFF         0x20
#define P3RD_SYNC_CONTROL_HSYNC_ACTIVE_LOW  0x00
#define P3RD_SYNC_CONTROL_HSYNC_ACTIVE_HIGH 0x01
#define P3RD_SYNC_CONTROL_HSYNC_OFF         0x04

#define P3RD_DAC_CONTROL_LOW_POWER      0x01
#define P3RD_DAC_CONTROL_SYNC_ON_GREEN  0x08
#define P3RD_DAC_CONTROL_BLANK_RED      0x10
#define P3RD_DAC_CONTROL_BLANK_GREEN    0x20
#define P3RD_DAC_CONTROL_BLANK_BLUE     0x40
#define P3RD_DAC_CONTROL_BLANK_PEDESTAL_ENABLED 0x80

#define P3RD_PIXEL_SIZE_8BPP            0x00
#define P3RD_PIXEL_SIZE_16BPP           0x01
#define P3RD_PIXEL_SIZE_24_BPP          0x04
#define P3RD_PIXEL_SIZE_32BPP           0x02

#define P3RD_COLOR_FORMAT_CI8           0x0e
#define P3RD_COLOR_FORMAT_8BPP          0x25
#define P3RD_COLOR_FORMAT_15BPP         0x21
#define P3RD_COLOR_FORMAT_16BPP         0x30
#define P3RD_COLOR_FORMAT_32BPP         0x20
#define P3RD_COLOR_FORMAT_LINEAR_EXT    0x40

#define P3RD_CURSOR_MODE_REVERSE        0x40
#define P3RD_CURSOR_MODE_WINDOWS        0x00
#define P3RD_CURSOR_MODE_X              0x10
#define P3RD_CURSOR_MODE_3COLOR         0x20
#define P3RD_CURSOR_MODE_15COLOR        0x30
#define P3RD_CURSOR_MODE_64x64          0x00
#define P3RD_CURSOR_MODE_P0_32x32x2     0x02
#define P3RD_CURSOR_MODE_P1_32x32x2     0x04
#define P3RD_CURSOR_MODE_P2_32x32x2     0x06
#define P3RD_CURSOR_MODE_P3_32x32x2     0x08
#define P3RD_CURSOR_MODE_P01_32x32x4    0x0a
#define P3RD_CURSOR_MODE_P23_32x32x4    0x0c
#define P3RD_CURSOR_MODE_ENABLED        0x01
#define P3RD_CURSOR_MODE_OFF            0x00

#define P3RD_CURSOR_CONTROL_RPOS_ENABLED    0x04
#define P3RD_CURSOR_CONTROL_DOUBLE_Y        0x02
#define P3RD_CURSOR_CONTROL_DOUBLE_X        0x01

// Windows format byte-packed cursor data: each byte represents 4 consecutive pixels
#define P3RD_CURSOR_2_COLOR_BLACK           0x00
#define P3RD_CURSOR_2_COLOR_WHITE           0x55
#define P3RD_CURSOR_2_COLOR_TRANSPARENT     0xAA
#define P3RD_CURSOR_2_COLOR_HIGHLIGHT       0xFF

// cursor sizes
#define P3RD_CURSOR_SIZE_64_MONO    0
#define P3RD_CURSOR_SIZE_32_MONO    1
#define P3RD_CURSOR_SIZE_32_3COLOR  5
#define P3RD_CURSOR_SEL(cursorSize, cursorIndex) (((cursorSize + cursorIndex) & 7) << 1)

#define P3RD_DCLK_CONTROL_LOCKED    0x02    // read-only
#define P3RD_DCLK_CONTROL_ENABLED   0x01
#define P3RD_DCLK_CONTROL_RUN       0x08
#define P3RD_DCLK_SOURCE_PLL        0x00
#define P3RD_DCLK_SOURCE_VSA        0x01
#define P3RD_DCLK_SOURCE_VSB        0x02
#define P3RD_DCLK_SOURCE_EXTERNAL   0x03

#define P3RD_MCLK_CONTROL_ENABLED   0x01
#define P3RD_MCLK_CONTROL_RUN       0x08
#define P3RD_MCLK_SOURCE_PCLK       0x00
#define P3RD_MCLK_SOURCE_HALFPCLK   0x10
#define P3RD_MCLK_SOURCE_HALFEXTMCLK 0x30
#define P3RD_MCLK_SOURCE_EXTMCLK    0x40
#define P3RD_MCLK_SOURCE_HALFKCLK   0x50
#define P3RD_MCLK_SOURCE_KCLK       0x60

#define P3RD_KCLK_CONTROL_LOCKED    0x02    // read-only
#define P3RD_KCLK_CONTROL_ENABLED   0x01
#define P3RD_KCLK_CONTROL_RUN       0x08
#define P3RD_KCLK_SOURCE_PCLK       0x00
#define P3RD_KCLK_SOURCE_HALFPCLK   0x10
#define P3RD_KCLK_SOURCE_PLL        0x20

#define P3RD_SCLK_CONTROL_LOCKED    0x02    // read-only
#define P3RD_SCLK_CONTROL_ENABLED   0x01
#define P3RD_SCLK_CONTROL_RUN       0x08
#define P3RD_SCLK_SOURCE_PCLK       0x00
#define P3RD_SCLK_SOURCE_HALFPCLK   0x10
#define P3RD_SCLK_SOURCE_HALFEXTSCLK 0x30
#define P3RD_SCLK_SOURCE_EXTSCLK    0x40
#define P3RD_SCLK_SOURCE_HALFKCLK   0x50
#define P3RD_SCLK_SOURCE_KCLK       0x60

// Palette entries are reversed from P2
#define P3RD_CURSOR_PALETTE_CURSOR_RGB(RGBIndex, Red, Green, Blue) \
{ \
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_PALETTE_START+3*(int)(14 - RGBIndex)+0, Red); \
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_PALETTE_START+3*(int)(14 - RGBIndex)+1, Green); \
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_PALETTE_START+3*(int)(14 - RGBIndex)+2, Blue); \
}


#if 0
// need a delay between each write to the P3RD. The only way to guarantee
// that the write has completed is to read from a GLINT control register.
// Reading forces any posted writes to be flushed out. PPC needs 2 reads
// to give us enough time.
#define P3RD_DELAY \
{ \
    volatile LONG __junk; \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
}
#else
#define P3RD_DELAY
#endif

// macro to load a given data value into an internal P3RD register. The
// second macro loads an internal index register assuming that we have
// already zeroed the high address register.
//
#define P3RD_INDEX_REG(index) \
{ \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", P3RD_INDEX_ADDR_LO, (index) & 0xff)); \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_LO, (ULONG)((index) & 0xff)); \
    P3RD_DELAY; \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", P3RD_INDEX_ADDR_HI, (index) >> 8)); \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_HI, (ULONG)((index) >> 8)); \
    P3RD_DELAY; \
}

#define P3RD_LOAD_DATA(data) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
    P3RD_DELAY; \
}

#define P3RD_LOAD_INDEX_REG(index, data) \
{ \
    P3RD_INDEX_REG(index);                            \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", P3RD_INDEX_DATA, (data) & 0xff)); \
    VideoPortWriteRegisterUlong(P3RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
    P3RD_DELAY; \
}

#define P3RD_READ_INDEX_REG(index, data) \
{ \
    P3RD_INDEX_REG(index);                            \
    data = (BYTE) (VideoPortReadRegisterUlong(P3RD_INDEX_DATA) & 0xff);   \
    P3RD_DELAY; \
    VideoDebugPrint(("0x%x <-- *(0x%x)\n", data, P3RD_INDEX_DATA)); \
}

#define P3RD_LOAD_INDEX_REG_LO(index, data) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_LO, (ULONG)(index));  \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_INDEX_DATA,    (ULONG)(data));   \
    P3RD_DELAY; \
}

// macros to load a given RGB triple into the P3RD palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use P3RD_PALETTE_START and multiple P3RD_LOAD_PALETTE calls to load
// a contiguous set of entries. Use P3RD_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//
#define P3RD_PALETTE_START_WR(index) \
{ \
    VideoPortWriteRegisterUlong(P3RD_PAL_WR_ADDR,     (ULONG)(index));    \
    P3RD_DELAY; \
}

#define P3RD_PALETTE_START_RD(index) \
{ \
    VideoPortWriteRegisterUlong(P3RD_PAL_RD_ADDR,     (ULONG)(index));    \
    P3RD_DELAY; \
}

#define P3RD_LOAD_PALETTE(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(red));      \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(green));    \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(blue));     \
    P3RD_DELAY; \
}

#define P3RD_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(P3RD_PAL_WR_ADDR, (ULONG)(index));    \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(red));      \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(green));    \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(blue));     \
    P3RD_DELAY; \
}

// macro to read back a given RGB triple from the P3RD palette. Use after
// a call to P3RD_PALETTE_START_RD
//
#define P3RD_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR)(VideoPortReadRegisterUlong(P3RD_PAL_DATA) & 0xff);        \
    P3RD_DELAY; \
    green = (UCHAR)(VideoPortReadRegisterUlong(P3RD_PAL_DATA) & 0xff);        \
    P3RD_DELAY; \
    blue  = (UCHAR)(VideoPortReadRegisterUlong(P3RD_PAL_DATA) & 0xff);        \
    P3RD_DELAY; \
}

#define P3RD_SET_INDEX_CONTROL(mask) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_CONTROL, (ULONG)(mask)); \
    P3RD_DELAY; \
}

// macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//
#define P3RD_SET_PIXEL_READMASK(mask) \
{ \
    VideoPortWriteRegisterUlong(P3RD_PIXEL_MASK,  (ULONG)(mask)); \
    P3RD_DELAY; \
}

#define P3RD_READ_PIXEL_READMASK(mask) \
{ \
    mask = VideoPortReadRegisterUlong(P3RD_PIXEL_MASK) & 0xff; \
}

// macros to load values into the cursor array usage is P3RD_CURSOR_ARRAR_START() followed by 
// n iterations of P3RD_LOAD_CURSOR_ARRAY() or P3RD_READ_CURSOR_ARRAY()
//
#define P3RD_CURSOR_ARRAY_START(offset) \
{ \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_LO,   (ULONG)(((offset)+P3RD_CURSOR_PATTERN_START) & 0xff));  \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_HI,   (ULONG)(((offset)+P3RD_CURSOR_PATTERN_START) >> 8));    \
    P3RD_DELAY; \
}

#define P3RD_LOAD_CURSOR_ARRAY(data) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_DATA, (ULONG)(data)); \
    P3RD_DELAY; \
}

#define P3RD_READ_CURSOR_ARRAY(data) \
{ \
    data = VideoPortReadRegisterUlong(P3RD_INDEX_DATA) & 0xff; \
    P3RD_DELAY; \
}

// macro to move the cursor
//
#define P3RD_MOVE_CURSOR(x, y) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_HI, (ULONG)0);              \
    P3RD_DELAY; \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_X_LOW,       (ULONG)((x) & 0xff));   \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_X_HIGH,      (ULONG)((x) >> 8));     \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_Y_LOW,       (ULONG)((y) & 0xff));   \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_Y_HIGH,      (ULONG)((y) >> 8));     \
}

// macro to change the cursor hotspot
//
#define P3RD_CURSOR_HOTSPOT(x, y) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_HI,   (ULONG)(0)); \
    P3RD_DELAY; \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_HOTSPOT_X,  (ULONG)(x));    \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_HOTSPOT_Y,  (ULONG)(y));    \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\p3rxdef.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: p3rxdef.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// This file containes defines for values that are filled into fields on P3/RX
// The file glintdef.h is the equivalent for glint chips.

// These defines are typically used in conjunction with the macros in bitmac2.h, 
// which shift the values to their correct locations.

#ifdef __P3RXDEF
#pragma message ("FILE : "__FILE__" : Multiple Inclusion")
#endif

#define __P3RXDEF


// Dither unit.
// these COLORFORMATs are used in various other places too,
// e.g. the alpha blend unit.
#define P3RX_DITHERMODE_COLORFORMAT_8888                0
#define P3RX_DITHERMODE_COLORFORMAT_4444                1
#define P3RX_DITHERMODE_COLORFORMAT_5551                2
#define P3RX_DITHERMODE_COLORFORMAT_565                 3
#define P3RX_DITHERMODE_COLORFORMAT_332                 4
#define P3RX_DITHERMODE_COLORFORMAT_CI                  15
#define P3RX_DITHERMODE_COLORFORMAT_ILLEGAL             -1
// Usually use the COLOR_MODE macro for the default order.
#define P3RX_DITHERMODE_COLORORDER_BGR                  0
#define P3RX_DITHERMODE_COLORORDER_RGB                  1
// Careful! These are not the way round you would expect.
#define P3RX_DITHERMODE_ALPHADITHER_DITHER              0
#define P3RX_DITHERMODE_ALPHADITHER_ROUND               1
#define P3RX_DITHERMODE_ROUNDINGMODE_TRUNCATE           0
#define P3RX_DITHERMODE_ROUNDINGMODE_ROUNDUP            1
#define P3RX_DITHERMODE_ROUNDINGMODE_ROUNDDOWN          2

// Texture unit bit fields

// Texture Read Mode
#define P3RX_TEXREADMODE_TEXELSIZE_8                    0
#define P3RX_TEXREADMODE_TEXELSIZE_16                   1
#define P3RX_TEXREADMODE_TEXELSIZE_32                   2
#define P3RX_TEXREADMODE_TEXELSIZE_64                   3
#define P3RX_TEXREADMODE_TEXTURETYPE_NORMAL             0
#define P3RX_TEXREADMODE_TEXTURETYPE_8BITINDEXED        1
#define P3RX_TEXREADMODE_TEXTURETYPE_422_YVYU           2
#define P3RX_TEXREADMODE_TEXTURETYPE_422_VYUY           3

// Texture index mode
#define P3RX_TEXINDEXMODE_WRAP_CLAMP                    0
#define P3RX_TEXINDEXMODE_WRAP_REPEAT                   1
#define P3RX_TEXINDEXMODE_WRAP_MIRROR                   2
#define P3RX_TEXINDEXMODE_WRAP_CLAMPEDGE                3
#define P3RX_TEXINDEXMODE_MAPTYPE_1D                    0
#define P3RX_TEXINDEXMODE_MAPTYPE_2D                    1
#define P3RX_TEXINDEXMODE_FILTER_NEAREST                0
#define P3RX_TEXINDEXMODE_FILTER_LINEAR                 1
#define P3RX_TEXINDEXMODE_FILTER_NEARESTMIPNEAREST      2
#define P3RX_TEXINDEXMODE_FILTER_NEARESTMIPLINEAR       3
#define P3RX_TEXINDEXMODE_FILTER_LINEARMIPNEAREST       4
#define P3RX_TEXINDEXMODE_FILTER_LINEARMIPLINEAR        5
#define P3RX_TEXINDEXMODE_BIAS_MINUSHALF                0
#define P3RX_TEXINDEXMODE_BIAS_ZERO                     1
#define P3RX_TEXINDEXMODE_BIAS_PLUSHALF                 2

// Texture read unit
#define P3RX_TEXREADMODE_TEXELSIZE_8                    0
#define P3RX_TEXREADMODE_TEXELSIZE_16                   1
#define P3RX_TEXREADMODE_TEXELSIZE_32                   2
#define P3RX_TEXREADMODE_TEXELSIZE_64SPAN               3
#define P3RX_TEXREADMODE_ORIGIN_TOPLEFT                 0
#define P3RX_TEXREADMODE_ORIGIN_BOTTOMLEFT              1
#define P3RX_TEXREADMODE_TEXTURETYPE_NORMAL             0
#define P3RX_TEXREADMODE_TEXTURETYPE_8BITINDEXED        1
#define P3RX_TEXREADMODE_TEXTURETYPE_YVYU422            2
#define P3RX_TEXREADMODE_TEXTURETYPE_VYUY422            3
#define P3RX_TEXREADMODE_BYTESWAP_NONE                  0
#define P3RX_TEXREADMODE_BYTESWAP_ABCDEFGH              0
#define P3RX_TEXREADMODE_BYTESWAP_BADCFEHG              1
#define P3RX_TEXREADMODE_BYTESWAP_CDABGHEF              2
#define P3RX_TEXREADMODE_BYTESWAP_DCBAHGFE              3
#define P3RX_TEXREADMODE_BYTESWAP_EFGHABCD              4
#define P3RX_TEXREADMODE_BYTESWAP_FEHGBADC              5
#define P3RX_TEXREADMODE_BYTESWAP_GHEFCDAB              6
#define P3RX_TEXREADMODE_BYTESWAP_HGFEDCBA              7

// Texture Application
#define P3RX_TEXAPP_A_CC                            0
#define P3RX_TEXAPP_A_CA                            1
#define P3RX_TEXAPP_A_KC                            2
#define P3RX_TEXAPP_A_KA                            3

#define P3RX_TEXAPP_B_TC                            0
#define P3RX_TEXAPP_B_TA                            1
#define P3RX_TEXAPP_B_KC                            2
#define P3RX_TEXAPP_B_KA                            3

#define P3RX_TEXAPP_I_CA                            0
#define P3RX_TEXAPP_I_KA                            1
#define P3RX_TEXAPP_I_TC                            2
#define P3RX_TEXAPP_I_TA                            3

#define P3RX_TEXAPP_OPERATION_PASS_A                0
#define P3RX_TEXAPP_OPERATION_PASS_B                1
#define P3RX_TEXAPP_OPERATION_ADD_AB                2
#define P3RX_TEXAPP_OPERATION_MODULATE_AB           3
#define P3RX_TEXAPP_OPERATION_LERP_ABI              4
#define P3RX_TEXAPP_OPERATION_MODULATE_AB_ADD_I     5
#define P3RX_TEXAPP_OPERATION_MODULATE_AI_ADD_B     6
#define P3RX_TEXAPP_OPERATION_MODULATE_BI_ADD_A     7

// Texture composite
// 0 and 1 are the current colour on the second stage,
// and the heightfield emboss mode on the first.
// Note that HEIGHTC=HEIGHTA
#define P3RX_TEXCOMP_OC                         0
#define P3RX_TEXCOMP_OA                         1
#define P3RX_TEXCOMP_HEIGHTC                    0
#define P3RX_TEXCOMP_HEIGHTA                    1
#define P3RX_TEXCOMP_CC                         2
#define P3RX_TEXCOMP_CA                         3
#define P3RX_TEXCOMP_FC                         4
#define P3RX_TEXCOMP_FA                         5
#define P3RX_TEXCOMP_T0C                        6
#define P3RX_TEXCOMP_T0A                        7
#define P3RX_TEXCOMP_T1C                        8
#define P3RX_TEXCOMP_T1A                        9
#define P3RX_TEXCOMP_SUM                        10

// HA = height. Same as output.a on first stage.
#define P3RX_TEXCOMP_I_OA                           0
#define P3RX_TEXCOMP_I_HA                           0
#define P3RX_TEXCOMP_I_CA                           1
#define P3RX_TEXCOMP_I_FA                           2
#define P3RX_TEXCOMP_I_T0A                          3
#define P3RX_TEXCOMP_I_T1A                          4

// These need to be renamed to P3RX_TEXCOMP_AB_ARGx for consistency.
#define P3RX_TEXCOMP_ARG1                           0
#define P3RX_TEXCOMP_ARG2                           1

#define P3RX_TEXCOMP_OPERATION_PASS_A                   0
#define P3RX_TEXCOMP_OPERATION_ADD_AB                   1
#define P3RX_TEXCOMP_OPERATION_ADDSIGNED_AB             2
#define P3RX_TEXCOMP_OPERATION_SUBTRACT_AB              3
#define P3RX_TEXCOMP_OPERATION_MODULATE_AB              4
#define P3RX_TEXCOMP_OPERATION_LERP_ABI                 5
#define P3RX_TEXCOMP_OPERATION_MODULATE_AB_ADD_I        6
#define P3RX_TEXCOMP_OPERATION_MODULATE_AI_ADD_B        7
#define P3RX_TEXCOMP_OPERATION_ADD_AB_SUB_MODULATE_AB   8
#define P3RX_TEXCOMP_OPERATION_MODULATE_SIGNED_AB       9

// These need to be renamed P3RX_TEXCOMP_SCALE_xxx
#define P3RX_TEXCOMP_OPERATION_SCALE_HALF               0
#define P3RX_TEXCOMP_OPERATION_SCALE_ONE                1
#define P3RX_TEXCOMP_OPERATION_SCALE_TWO                2
#define P3RX_TEXCOMP_OPERATION_SCALE_FOUR               3

// Render
#define P3RX_RENDER_PRIMITIVETYPE_LINE                  0
#define P3RX_RENDER_PRIMITIVETYPE_TRAPEZOID             1
#define P3RX_RENDER_PRIMITIVETYPE_POINT                 2
#define P3RX_RENDER_ANTIALIASINGQUALITY_4X4             0
#define P3RX_RENDER_ANTIALIASINGQUALITY_8X8             1

// 2D Render operations.
#define P3RX_RENDER2D_OPERATION_NORMAL                  0
#define P3RX_RENDER2D_OPERATION_SYNC_ON_HOST_DATA       1
#define P3RX_RENDER2D_OPERATION_SYNC_ON_BIT_MASK        2
#define P3RX_RENDER2D_OPERATION_PATCH_ORDER_RENDERING   3
#define P3RX_RENDER2D_SPAN_CONSTANT                     0
#define P3RX_RENDER2D_SPAN_VARIABLE                     1

// For P3RX_ALPHABLENDxxxMODE
#define P3RX_ALPHABLENDMODE_SRCBLEND_ZERO           0
#define P3RX_ALPHABLENDMODE_SRCBLEND_ONE            1
#define P3RX_ALPHABLENDMODE_SRCBLEND_DSTCOLOR       2
#define P3RX_ALPHABLENDMODE_SRCBLEND_INVDSTCOLOR    3
#define P3RX_ALPHABLENDMODE_SRCBLEND_SRCALPHA       4
#define P3RX_ALPHABLENDMODE_SRCBLEND_INVSRCALPHA    5
#define P3RX_ALPHABLENDMODE_SRCBLEND_DSTALPHA       6
#define P3RX_ALPHABLENDMODE_SRCBLEND_INVDSTALPHA    7
#define P3RX_ALPHABLENDMODE_SRCBLEND_SRCALPHASAT    8

#define P3RX_ALPHABLENDMODE_DSTBLEND_ZERO           0
#define P3RX_ALPHABLENDMODE_DSTBLEND_ONE            1
#define P3RX_ALPHABLENDMODE_DSTBLEND_SRCCOLOR       2
#define P3RX_ALPHABLENDMODE_DSTBLEND_INVSRCCOLOR    3
#define P3RX_ALPHABLENDMODE_DSTBLEND_SRCALPHA       4
#define P3RX_ALPHABLENDMODE_DSTBLEND_INVSRCALPHA    5
#define P3RX_ALPHABLENDMODE_DSTBLEND_DSTALPHA       6
#define P3RX_ALPHABLENDMODE_DSTBLEND_INVDSTALPHA    7

#define P3RX_ALPHABLENDMODE_COLORORDER_BGR          0
#define P3RX_ALPHABLENDMODE_COLORORDER_RGB          1
#define P3RX_ALPHABLENDMODE_ALPHATYPE_OGL           0
#define P3RX_ALPHABLENDMODE_ALPHATYPE_APPLE         1
// Both colour and alpha channels.
#define P3RX_ALPHABLENDMODE_CONVERT_SCALE           0
#define P3RX_ALPHABLENDMODE_CONVERT_SHIFT           1
#define P3RX_ALPHABLENDMODE_OPERATION_ADD           0
#define P3RX_ALPHABLENDMODE_OPERATION_SSUBD         1
#define P3RX_ALPHABLENDMODE_OPERATION_DSUBS         2
#define P3RX_ALPHABLENDMODE_OPERATION_MIN           3
#define P3RX_ALPHABLENDMODE_OPERATION_MAX           4

// Alpha Blending
#define P3RX_ALPHABLENDMODE_COLORFORMAT_8888        P3RX_DITHERMODE_COLORFORMAT_8888
#define P3RX_ALPHABLENDMODE_COLORFORMAT_4444        P3RX_DITHERMODE_COLORFORMAT_4444
#define P3RX_ALPHABLENDMODE_COLORFORMAT_5551        P3RX_DITHERMODE_COLORFORMAT_5551
#define P3RX_ALPHABLENDMODE_COLORFORMAT_565         P3RX_DITHERMODE_COLORFORMAT_565
#define P3RX_ALPHABLENDMODE_COLORFORMAT_332         P3RX_DITHERMODE_COLORFORMAT_332
#define P3RX_ALPHABLENDMODE_COLORFORMAT_CI          P3RX_DITHERMODE_COLORFORMAT_CI
#define P3RX_ALPHABLENDMODE_COLORFORMAT_ILLEGAL     P3RX_DITHERMODE_COLORFORMAT_ILLEGAL

// For P3RX_CHROMATESTMODE_SOURCE
#define P3RX_CHROMATESTMODE_SOURCE_FBSOURCEDATA     0
#define P3RX_CHROMATESTMODE_SOURCE_FBDATA           1
#define P3RX_CHROMATESTMODE_SOURCE_INPUTCOLOR       2
#define P3RX_CHROMATESTMODE_SOURCE_OUTPUTCOLOR      3
// For P3RX_CHROMATESTMODE_FAILACTION and P3_CHROMATESTMODE_PASSACTION
#define P3RX_CHROMATESTMODE_ACTION_PASS                         0
#define P3RX_CHROMATESTMODE_ACTION_REJECT                       1
#define P3RX_CHROMATESTMODE_ACTION_SUBSTITUTEPASSCOLOR          2
#define P3RX_CHROMATESTMODE_ACTION_SUBSTITUTEFAILCOLOR          3

// For P3RX_TEXFILTERMODE_ALPHAMAPSENSEx
#define P3RX_ALPHAMAPSENSE_OUTOFRANGE               0
#define P3RX_ALPHAMAPSENSE_INRANGE                  1

// For P3RX_TEXCOORDMODE_ WRAPS, WRAPT, WRAPS1, WRAPT1
#define P3RX_TEXCOORDMODE_WRAP_CLAMP                0
#define P3RX_TEXCOORDMODE_WRAP_REPEAT               1
#define P3RX_TEXCOORDMODE_WRAP_MIRROR               2

#define P3RX_TEXCOORDMODE_OPERATION_2D              0
#define P3RX_TEXCOORDMODE_OPERATION_3D              1

#define P3RX_TEXCOORDMODE_TEXTUREMAPTYPE_1D         0
#define P3RX_TEXCOORDMODE_TEXTUREMAPTYPE_2D         1

// LUT Mode
#define P3RX_LUTMODE_INCOLORORDER_BGR               0
#define P3RX_LUTMODE_INCOLORORDER_RGB               1

#define P3RX_LUTMODE_LOADFORMAT_COPY                0
#define P3RX_LUTMODE_LOADFORMAT_565REPLICATE        1
#define P3RX_LUTMODE_LOADFORMAT_5551REPLICATE       2

#define P3RX_LUTMODE_LOADCOLORORDER_BGR             0
#define P3RX_LUTMODE_LOADCOLORORDER_RGB             1

#define P3RX_LUTMODE_FRAGMENTOP_NONE                0
#define P3RX_LUTMODE_FRAGMENTOP_INDEXEDTEXTURE      1
#define P3RX_LUTMODE_FRAGMENTOP_TRANSLATE8TO32      2
#define P3RX_LUTMODE_FRAGMENTOP_TRANSLATE32TO32     3
#define P3RX_LUTMODE_FRAGMENTOP_MOTIONCOMP          4
#define P3RX_LUTMODE_FRAGMENTOP_PATTERN             5

#define P3RX_LUTMODE_SPANOP_NONE                    0
#define P3RX_LUTMODE_SPANOP_SPANPATTERN             1
#define P3RX_LUTMODE_SPANOP_TRANSLATE8TO8           2
#define P3RX_LUTMODE_SPANOP_TRANSLATE8TO16          3
#define P3RX_LUTMODE_SPANOP_TRANSLATE8TO32          4
#define P3RX_LUTMODE_SPANOP_TRANSLATE32TO32         5

// Used for P3RX_LUTMODE_SPAN[V|C]CXALIGN
#define P3RX_LUTMODE_ALIGNMENT_ABSOLOUTE            0
#define P3RX_LUTMODE_ALIGNMENT_RELATIVE             1


// Alpha test unit
#define P3RX_ANTIALIASMODE_COLORMODE_RGBA           0
#define P3RX_ANTIALIASMODE_COLORMODE_CI             1

#define P3RX_ALPHATESTMODE_COMPARE_NEVER            0
#define P3RX_ALPHATESTMODE_COMPARE_LESS             1
#define P3RX_ALPHATESTMODE_COMPARE_EQUAL            2
#define P3RX_ALPHATESTMODE_COMPARE_LESSEQUAL        3
#define P3RX_ALPHATESTMODE_COMPARE_GREATER          4
#define P3RX_ALPHATESTMODE_COMPARE_NOTEQUAL         5
#define P3RX_ALPHATESTMODE_COMPARE_GREATEREQUAL     6
#define P3RX_ALPHATESTMODE_COMPARE_ALWAYS           7

// Fogging
#define P3RX_FOGMODE_COLORMODE_RGB                  0
#define P3RX_FOGMODE_COLORMODE_CI                   1

// Framebuffer write mode
#define P3RX_FBWRITEMODE_ORIGIN_TOPLEFT             0
#define P3RX_FBWRITEMODE_ORIGIN_BOTTOMLEFT          1

// Shared
#define P3RX_STRIPE_1                               0
#define P3RX_STRIPE_2                               1
#define P3RX_STRIPE_4                               2
#define P3RX_STRIPE_8                               3
#define P3RX_STRIPE_16                              4
#define P3RX_STRIPE_32                              5
#define P3RX_STRIPE_64                              6
#define P3RX_STRIPE_128                             7

#define P3RX_LAYOUT_LINEAR                          0
#define P3RX_LAYOUT_PATCH64                         1
#define P3RX_LAYOUT_PATCH32_2                       2
#define P3RX_LAYOUT_PATCH2                          3

// Color DDA fields
#define P3RX_COLORDDA_FLATSHADE                     0
#define P3RX_COLORDDA_GOURAUDSHADE                  1

#define P3RX_DEPTH_WIDTH_16                         0
#define P3RX_DEPTH_WIDTH_24                         1
#define P3RX_DEPTH_WIDTH_32                         2
#define P3RX_DEPTH_WIDTH_15                         3

#define P3RX_STENCIL_WIDTH_0                        0
#define P3RX_STENCIL_WIDTH_1                        1
#define P3RX_STENCIL_WIDTH_2                        2
#define P3RX_STENCIL_WIDTH_3                        3
#define P3RX_STENCIL_WIDTH_4                        4
#define P3RX_STENCIL_WIDTH_5                        5
#define P3RX_STENCIL_WIDTH_6                        6
#define P3RX_STENCIL_WIDTH_7                        7
#define P3RX_STENCIL_WIDTH_8                        8

#define P3RX_STENCIL_POSITION_16                    0
#define P3RX_STENCIL_POSITION_17                    1
#define P3RX_STENCIL_POSITION_18                    2
#define P3RX_STENCIL_POSITION_19                    3
#define P3RX_STENCIL_POSITION_20                    4
#define P3RX_STENCIL_POSITION_21                    5
#define P3RX_STENCIL_POSITION_22                    6
#define P3RX_STENCIL_POSITION_23                    7
#define P3RX_STENCIL_POSITION_24                    8
#define P3RX_STENCIL_POSITION_25                    9
#define P3RX_STENCIL_POSITION_26                    10
#define P3RX_STENCIL_POSITION_27                    11
#define P3RX_STENCIL_POSITION_28                    12
#define P3RX_STENCIL_POSITION_29                    13
#define P3RX_STENCIL_POSITION_30                    14
#define P3RX_STENCIL_POSITION_31                    15
#define P3RX_STENCIL_POSITION_32                    16
#define P3RX_STENCIL_POSITION_33                    17
#define P3RX_STENCIL_POSITION_34                    18
#define P3RX_STENCIL_POSITION_35                    19
#define P3RX_STENCIL_POSITION_36                    20
#define P3RX_STENCIL_POSITION_37                    21
#define P3RX_STENCIL_POSITION_38                    22
#define P3RX_STENCIL_POSITION_39                    23

// FilterMode
#define P3RX_FILTERMODE_BYTESWAP_ABCD               0
#define P3RX_FILTERMODE_BYTESWAP_BADC               1
#define P3RX_FILTERMODE_BYTESWAP_CDAB               2
#define P3RX_FILTERMODE_BYTESWAP_DCBA               3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\pmdef.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: pmdef.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// This file containes defines for values that are filled into fields on Permedia
// The file glintdef.h is the equivalent for glint chips.

// These defines are typically used in conjunction with the macros in bitmac2.h, 
// which shift the values to their correct locations.

#ifndef __PMDEF_H
#define __PMDEF_H

// Texture unit bit fields
#define PM_TEXMAPFORMAT_TEXELSIZE 19

// Dither unit bit fields
#define PM_DITHERMODE_ENABLE 0
#define PM_DITHERMODE_DITHERENABLE 1
#define PM_DITHERMODE_COLORFORMAT 2
#define PM_DITHERMODE_XOFFSET 6
#define PM_DITHERMODE_YOFFSET 8
#define PM_DITHERMODE_COLORORDER 10
#define PM_DITHERMODE_DITHERMETHOD 11
#define PM_DITHERMODE_FORCEALPHA 12
#define PM_DITHERMODE_COLORFORMATEXTENSION 16

// VSA Control
#define PM_VSACONTROL_DISCARD_1             1
#define PM_VSACONTROL_DISCARD_2             2

#endif // __PMDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\ramdac.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: ramdac.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// RAMDAC registers live on 64 bit boundaries. Leave it up to individual
// RAMDAC definitions to determine what registers are available and how
// many bits wide the registers really are.
//
typedef struct {
    volatile unsigned long   reg;
    volatile unsigned long   pad;
} RAMDAC_REG;



#include "rgb525.h"
#include "tvp3026.h"
#include "tvp4020.h"
#include "p2rd.h"
#include "p3rd.h"

//
// Supported RAMDAC definitions.
//

#define     RGB525_RAMDAC       0
#define     RGB526_RAMDAC       1
#define     RGB526DB_RAMDAC     2
#define     RGB528_RAMDAC       3
#define     RGB528A_RAMDAC      4
#define     RGB524_RAMDAC       6
#define     RGB524A_RAMDAC      7

#define     TVP3026_RAMDAC      50
#define     TVP3030_RAMDAC      51

#define     TVP4020_RAMDAC      100

#define     P2RD_RAMDAC         200
#define     P3RD_RAMDAC         201

// P3R3DX_VIDEO is defined in video.c (gldd dir)
#if MINIVDD || (P3R3DX_VIDEO == 1)
#define VideoPortWriteRegisterUlong(dst, value) (*((volatile unsigned long *) dst)) = value
#else

// Use emits to turn 16 bit instructions into 32 bit instructions.
// _asm  _emit 66h  _asm xor   bx,bx    ->  xor ebx, ebx
#define VideoPortWriteRegisterUlong(dst, value) {   \
    DWORD lVal = value, *lDst = dst;                \
    _asm  _emit 66h  _asm xor   bx,bx               \
                     _asm les   bx, lDst            \
    _asm  _emit 66h  _asm mov   ax, WORD PTR lVal   \
    _asm  _emit 66h  _asm mov   es:[bx], ax         \
}

#endif
#define VideoPortReadRegisterUlong(dst) *((volatile unsigned long *)dst)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\p2rd.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: p2rd.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// structure with all the direct access registers
typedef struct _p2rd_regs
{
    RAMDAC_REG  RDPaletteWriteAddress;
    RAMDAC_REG  RDPaletteData;
    RAMDAC_REG  RDPixelMask;
    RAMDAC_REG  RDPaletteAddressRead;
    RAMDAC_REG  RDIndexLow;
    RAMDAC_REG  RDIndexHigh;
    RAMDAC_REG  RDIndexedData;
    RAMDAC_REG  RDIndexControl;
}
P2RDRAMDAC, pP2RDRAMDAC;

// macro declared by any function wishing to use the RGB525 RAMDAC. MUST be declared
// after GLINT_DECL.
//
#if MINIVDD
#define P2RD_DECL \
    P2RDRAMDAC   *pP2RDRegs = (P2RDRAMDAC *)&(pDev->pRegisters->Glint.ExtVCReg)
#else
#define P2RD_DECL \
    P2RDRAMDAC   *pP2RDRegs = (P2RDRAMDAC *)&(pRegisters->Glint.ExtVCReg)
#endif

#if P3R3DX_VIDEO
#define VideoDebugPrint(arg)
#endif

// use the following macros as the address to pass to the
// VideoPortWriteRegisterUlong function
//
#define P2RD_PAL_WR_ADDR              ((PULONG)&(pP2RDRegs->RDPaletteWriteAddress.reg))
#define P2RD_PAL_RD_ADDR              ((PULONG)&(pP2RDRegs->RDPaletteAddressRead.reg))
#define P2RD_PAL_DATA                 ((PULONG)&(pP2RDRegs->RDPaletteData.reg))
#define P2RD_PIXEL_MASK               ((PULONG)&(pP2RDRegs->RDPixelMask.reg))
#define P2RD_INDEX_ADDR_LO            ((PULONG)&(pP2RDRegs->RDIndexLow.reg))
#define P2RD_INDEX_ADDR_HI            ((PULONG)&(pP2RDRegs->RDIndexHigh.reg))
#define P2RD_INDEX_DATA               ((PULONG)&(pP2RDRegs->RDIndexedData.reg))
#define P2RD_INDEX_CONTROL            ((PULONG)&(pP2RDRegs->RDIndexControl.reg))

// bit field definitions for the direct access registers
#define P2RD_IDX_CTL_AUTOINCREMENT_ENABLED  0x01

// indexed register definitions accessed via P2RD_LOAD_INDEX_REG() and P2RD_READ_INDEX_REG()
#define P2RD_MISC_CONTROL               0x0000
#define P2RD_SYNC_CONTROL               0x0001
#define P2RD_DAC_CONTROL                0x0002
#define P2RD_PIXEL_SIZE                 0x0003
#define P2RD_COLOR_FORMAT               0x0004
#define P2RD_CURSOR_MODE                0x0005
#define P2RD_CURSOR_CONTROL             0x0006
#define P2RD_CURSOR_X_LOW               0x0007
#define P2RD_CURSOR_X_HIGH              0x0008
#define P2RD_CURSOR_Y_LOW               0x0009
#define P2RD_CURSOR_Y_HIGH              0x000a
#define P2RD_CURSOR_HOTSPOT_X           0x000b
#define P2RD_CURSOR_HOTSPOT_Y           0x000c
#define P2RD_OVERLAY_KEY                0x000d
#define P2RD_PAN                        0x000e
#define P2RD_SENSE                      0x000f
#define P2RD_CHECK_CONTROL              0x0018
#define P2RD_CHECK_PIXEL_RED            0x0019
#define P2RD_CHECK_PIXEL_GREEN          0x001a
#define P2RD_CHECK_PIXEL_BLUE           0x001b
#define P2RD_CHECK_LUT_RED              0x001c
#define P2RD_CHECK_LUT_GREEN            0x001d
#define P2RD_CHECK_LUT_BLUE             0x001e
#define P2RD_DCLK_SETUP_1               0x01f0
#define P2RD_DCLK_SETUP_2               0x01f1
#define P2RD_MCLK_SETUP_1               0x01f2
#define P2RD_MCLK_SETUP_2               0x01f3
#define P2RD_DCLK_CONTROL               0x0200
#define P2RD_DCLK0_PRE_SCALE            0x0201
#define P2RD_DCLK0_FEEDBACK_SCALE       0x0202
#define P2RD_DCLK0_POST_SCALE           0x0203
#define P2RD_DCLK1_PRE_SCALE            0x0204
#define P2RD_DCLK1_FEEDBACK_SCALE       0x0205
#define P2RD_DCLK1_POST_SCALE           0x0206
#define P2RD_DCLK2_PRE_SCALE            0x0207
#define P2RD_DCLK2_FEEDBACK_SCALE       0x0208
#define P2RD_DCLK2_POST_SCALE           0x0209
#define P2RD_DCLK3_PRE_SCALE            0x020a
#define P2RD_DCLK3_FEEDBACK_SCALE       0x020b
#define P2RD_DCLK3_POST_SCALE           0x020c
#define P2RD_MCLK_CONTROL               0x020d
#define P2RD_MCLK_PRE_SCALE             0x020e
#define P2RD_MCLK_FEEDBACK_SCALE        0x020f
#define P2RD_MCLK_POST_SCALE            0x0210
#define P2RD_CURSOR_PALETTE_START       0x0303      // 303..32f
#define P2RD_CURSOR_PATTERN_START       0x0400      // 400..7ff

// bit field definitions for the indexed registers
#define P2RD_MISC_CONTROL_OVERLAYS_ENABLED      0x10
#define P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED  0x08
#define P2RD_MISC_CONTROL_HIGHCOLORRES          0x01

#define P2RD_SYNC_CONTROL_VSYNC_ACTIVE_LOW  0x00
#define P2RD_SYNC_CONTROL_VSYNC_ACTIVE_HIGH 0x08
#define P2RD_SYNC_CONTROL_VSYNC_OFF         0x20
#define P2RD_SYNC_CONTROL_HSYNC_ACTIVE_LOW  0x00
#define P2RD_SYNC_CONTROL_HSYNC_ACTIVE_HIGH 0x01
#define P2RD_SYNC_CONTROL_HSYNC_OFF         0x04

#define P2RD_DAC_CONTROL_LOW_POWER      0x01
#define P2RD_DAC_CONTROL_SYNC_ON_GREEN  0x08
#define P2RD_DAC_CONTROL_BLANK_RED      0x10
#define P2RD_DAC_CONTROL_BLANK_GREEN    0x20
#define P2RD_DAC_CONTROL_BLANK_BLUE     0x40
#define P2RD_DAC_CONTROL_BLANK_PEDESTAL_ENABLED 0x80

#define P2RD_PIXEL_SIZE_8BPP            0x00
#define P2RD_PIXEL_SIZE_16BPP           0x01
#define P2RD_PIXEL_SIZE_24_BPP          0x04
#define P2RD_PIXEL_SIZE_32BPP           0x02

#define P2RD_COLOR_FORMAT_CI8           0x0e
#define P2RD_COLOR_FORMAT_8BPP          0x25
#define P2RD_COLOR_FORMAT_15BPP         0x21
#define P2RD_COLOR_FORMAT_16BPP         0x30
#define P2RD_COLOR_FORMAT_32BPP         0x20
#define P2RD_COLOR_FORMAT_LINEAR_EXT    0x40

#define P2RD_CURSOR_MODE_REVERSE        0x40
#define P2RD_CURSOR_MODE_WINDOWS        0x00
#define P2RD_CURSOR_MODE_X              0x10
#define P2RD_CURSOR_MODE_3COLOR         0x20
#define P2RD_CURSOR_MODE_15COLOR        0x30
#define P2RD_CURSOR_MODE_64x64          0x00
#define P2RD_CURSOR_MODE_P0_32x32x2     0x02
#define P2RD_CURSOR_MODE_P1_32x32x2     0x04
#define P2RD_CURSOR_MODE_P2_32x32x2     0x06
#define P2RD_CURSOR_MODE_P3_32x32x2     0x08
#define P2RD_CURSOR_MODE_P01_32x32x4    0x0a
#define P2RD_CURSOR_MODE_P23_32x32x4    0x0c
#define P2RD_CURSOR_MODE_ENABLED        0x01
#define P2RD_CURSOR_MODE_OFF            0x00

#define P2RD_CURSOR_CONTROL_RPOS_ENABLED    0x04
#define P2RD_CURSOR_CONTROL_DOUBLE_Y        0x02
#define P2RD_CURSOR_CONTROL_DOUBLE_X        0x01

// Windows format byte-packed cursor data: each byte represents 4 consecutive pixels
#define P2RD_CURSOR_2_COLOR_BLACK           0x00
#define P2RD_CURSOR_2_COLOR_WHITE           0x55
#define P2RD_CURSOR_2_COLOR_TRANSPARENT     0xAA
#define P2RD_CURSOR_2_COLOR_HIGHLIGHT       0xFF

// cursor sizes
#define P2RD_CURSOR_SIZE_64_MONO    0
#define P2RD_CURSOR_SIZE_32_MONO    1
#define P2RD_CURSOR_SIZE_32_3COLOR  5
#define P2RD_CURSOR_SEL(cursorSize, cursorIndex) (((cursorSize + cursorIndex) & 7) << 1)

#define P2RD_DCLK_CONTROL_LOCKED    0x02    // read-only
#define P2RD_DCLK_CONTROL_ENABLED   0x01
#define P2RD_DCLK_CONTROL_RUN       0x08

#define P2RD_MCLK_CONTROL_LOCKED    0x02    // read-only
#define P2RD_MCLK_CONTROL_ENABLED   0x01
#define P2RD_MCLK_CONTROL_RUN       0x08

#define P2RD_CURSOR_PALETTE_CURSOR_RGB(RGBIndex, Red, Green, Blue) \
{ \
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_PALETTE_START+3*(int)RGBIndex+0, Red); \
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_PALETTE_START+3*(int)RGBIndex+1, Green); \
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_PALETTE_START+3*(int)RGBIndex+2, Blue); \
}


#if 0
// need a delay between each write to the P2RD. The only way to guarantee
// that the write has completed is to read from a GLINT control register.
// Reading forces any posted writes to be flushed out. PPC needs 2 reads
// to give us enough time.
#define P2RD_DELAY \
{ \
    volatile LONG __junk; \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
}
#else
#define P2RD_DELAY
#endif

// macro to load a given data value into an internal P2RD register. The
// second macro loads an internal index register assuming that we have
// already zeroed the high address register.
//
#define P2RD_INDEX_REG(index) \
{ \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", P2RD_INDEX_ADDR_LO, (index) & 0xff)); \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_LO, (ULONG)((index) & 0xff)); \
    P2RD_DELAY; \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", P2RD_INDEX_ADDR_HI, (index) >> 8)); \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_HI, (ULONG)((index) >> 8)); \
    P2RD_DELAY; \
}

#define P2RD_LOAD_DATA(data) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
    P2RD_DELAY; \
}

#define P2RD_LOAD_INDEX_REG(index, data) \
{ \
    P2RD_INDEX_REG(index);                            \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", P2RD_INDEX_DATA, (data) & 0xff)); \
    VideoPortWriteRegisterUlong(P2RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
    P2RD_DELAY; \
}

#define P2RD_READ_INDEX_REG(index, data) \
{ \
    P2RD_INDEX_REG(index);                            \
    data = (BYTE) (VideoPortReadRegisterUlong(P2RD_INDEX_DATA) & 0xff);   \
    P2RD_DELAY; \
    VideoDebugPrint(("0x%x <-- *(0x%x)\n", data, P2RD_INDEX_DATA)); \
}

#define P2RD_LOAD_INDEX_REG_LO(index, data) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_LO, (ULONG)(index));  \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_INDEX_DATA,    (ULONG)(data));   \
    P2RD_DELAY; \
}

// macros to load a given RGB triple into the P2RD palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use P2RD_PALETTE_START and multiple P2RD_LOAD_PALETTE calls to load
// a contiguous set of entries. Use P2RD_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//
#define P2RD_PALETTE_START_WR(index) \
{ \
    VideoPortWriteRegisterUlong(P2RD_PAL_WR_ADDR,     (ULONG)(index));    \
    P2RD_DELAY; \
}

#define P2RD_PALETTE_START_RD(index) \
{ \
    VideoPortWriteRegisterUlong(P2RD_PAL_RD_ADDR,     (ULONG)(index));    \
    P2RD_DELAY; \
}

#define P2RD_LOAD_PALETTE(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(red));      \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(green));    \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(blue));     \
    P2RD_DELAY; \
}

#define P2RD_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(P2RD_PAL_WR_ADDR, (ULONG)(index));    \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(red));      \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(green));    \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(blue));     \
    P2RD_DELAY; \
}

// macro to read back a given RGB triple from the P2RD palette. Use after
// a call to P2RD_PALETTE_START_RD
//
#define P2RD_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR)(VideoPortReadRegisterUlong(P2RD_PAL_DATA) & 0xff);        \
    P2RD_DELAY; \
    green = (UCHAR)(VideoPortReadRegisterUlong(P2RD_PAL_DATA) & 0xff);        \
    P2RD_DELAY; \
    blue  = (UCHAR)(VideoPortReadRegisterUlong(P2RD_PAL_DATA) & 0xff);        \
    P2RD_DELAY; \
}

#define P2RD_SET_INDEX_CONTROL(mask) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_CONTROL, (ULONG)(mask)); \
    P2RD_DELAY; \
}

// macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//
#define P2RD_SET_PIXEL_READMASK(mask) \
{ \
    VideoPortWriteRegisterUlong(P2RD_PIXEL_MASK,  (ULONG)(mask)); \
    P2RD_DELAY; \
}

#define P2RD_READ_PIXEL_READMASK(mask) \
{ \
    mask = VideoPortReadRegisterUlong(P2RD_PIXEL_MASK) & 0xff; \
}

// macros to load values into the cursor array usage is P2RD_CURSOR_ARRAR_START() followed by 
// n iterations of P2RD_LOAD_CURSOR_ARRAY() or P2RD_READ_CURSOR_ARRAY()
//
#define P2RD_CURSOR_ARRAY_START(offset) \
{ \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_LO,   (ULONG)(((offset)+P2RD_CURSOR_PATTERN_START) & 0xff));  \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_HI,   (ULONG)(((offset)+P2RD_CURSOR_PATTERN_START) >> 8));    \
    P2RD_DELAY; \
}

#define P2RD_LOAD_CURSOR_ARRAY(data) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_DATA, (ULONG)(data)); \
    P2RD_DELAY; \
}

#define P2RD_READ_CURSOR_ARRAY(data) \
{ \
    data = VideoPortReadRegisterUlong(P2RD_INDEX_DATA) & 0xff; \
    P2RD_DELAY; \
}

// macro to move the cursor
//
#define P2RD_MOVE_CURSOR(x, y) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_HI, (ULONG)0);              \
    P2RD_DELAY; \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_X_LOW,       (ULONG)((x) & 0xff));   \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_X_HIGH,      (ULONG)((x) >> 8));     \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_Y_LOW,       (ULONG)((y) & 0xff));   \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_Y_HIGH,      (ULONG)((y) >> 8));     \
}

// macro to change the cursor hotspot
//
#define P2RD_CURSOR_HOTSPOT(x, y) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_HI,   (ULONG)(0)); \
    P2RD_DELAY; \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_HOTSPOT_X,  (ULONG)(x));    \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_HOTSPOT_Y,  (ULONG)(y));    \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\rgb525.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: rgb525.h
*
* Content: This module contains the definitions for the IBM RGB525 RAMDAC.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "rgb526.h"
#include "rgb528.h"

//
// IBM RGB525 RAMDAC definitions
// This set of registers resides at &(pCtrlRegs->ExternalVideo)
//
typedef struct _rgb525_regs {
    RAMDAC_REG  palAddrWr;      // loads internal register for palette writes
    RAMDAC_REG  palData;        // read/write to get/set palette data
    RAMDAC_REG  pixelMask;      // mask to AND with input pixel data
    RAMDAC_REG  palAddrRd;      // loads internal register for palette reads
    RAMDAC_REG  indexLow;       // low byte of internal control/cursor register
    RAMDAC_REG  indexHigh;      // high byte of internal control/cursor register
    RAMDAC_REG  indexData;      // read/write to get/set control/cursor data
    RAMDAC_REG  indexCtl;       // controls auto-increment of internal addresses
} RGB525RAMDAC, FAR *pRGB525RAMDAC;

// macro declared by any function wishing to use the RGB525 RAMDAC. MUST be declared
// after GLINT_DECL.
//
#if MINIVDD
#define RGB525_DECL                                                         \
    pRGB525RAMDAC   pRGB525Regs;                                            \
    if (pDev->ChipID == PERMEDIA2_ID || pDev->ChipID == TIPERMEDIA2_ID) {   \
        pRGB525Regs = (pRGB525RAMDAC)&(pDev->pRegisters->Glint.P2ExtVCReg); \
    } else {                                                                \
        pRGB525Regs = (pRGB525RAMDAC)&(pDev->pRegisters->Glint.ExtVCReg);   \
    }
#else
#define RGB525_DECL \
    pRGB525RAMDAC   pRGB525Regs;                                            \
    if (pGLInfo->dwRenderChipID == PERMEDIA2_ID || pGLInfo->dwRenderChipID == TIPERMEDIA2_ID) {   \
        pRGB525Regs = (pRGB525RAMDAC)&(pRegisters->Glint.P2ExtVCReg);       \
    } else {                                                                \
        pRGB525Regs = (pRGB525RAMDAC)&(pRegisters->Glint.ExtVCReg);         \
    }
#endif

// use the following macros as the address to pass to the
// VideoPortWriteRegisterUlong function
//
#define RGB525_PAL_WR_ADDR              ((PULONG)&(pRGB525Regs->palAddrWr.reg))
#define RGB525_PAL_RD_ADDR              ((PULONG)&(pRGB525Regs->palAddrRd.reg))
#define RGB525_PAL_DATA                 ((PULONG)&(pRGB525Regs->palData.reg))
#define RGB525_PIXEL_MASK               ((PULONG)&(pRGB525Regs->pixelMask.reg))
#define RGB525_INDEX_ADDR_LO            ((PULONG)&(pRGB525Regs->indexLow.reg))
#define RGB525_INDEX_ADDR_HI            ((PULONG)&(pRGB525Regs->indexHigh.reg))
#define RGB525_INDEX_DATA               ((PULONG)&(pRGB525Regs->indexData.reg))
#define RGB525_INDEX_CONTROL            ((PULONG)&(pRGB525Regs->indexCtl.reg))

// need a delay between each write to the 525. The only way to guarantee
// that the write has completed is to read from a GLINT control register.
// Reading forces any posted writes to be flushed out. 
#if INCLUDE_DELAY
#if MINIVDD
#define RGB525_DELAY \
{ \
    volatile LONG __junk525; \
    __junk525 = pDev->pRegisters->Glint.LineCount; \
}
#else
#define RGB525_DELAY \
{ \
    volatile LONG __junk525; \
    __junk525 = pRegisters->Glint.LineCount; \
}
#endif
#else
#define RGB525_DELAY
#endif

//
// On rev 1 chips we need to SYNC with GLINT while accessing the 525. This
// is because accesses to the RAMDAC can be corrupted by localbuffer
// activity. Put this macro before accesses that can co-exist with GLINT
// 3D activity, Must have initialized glintInfo before using this.
//
#define RGB525_SYNC_WITH_GLINT \
{ \
    if (GLInfo.wRenderChipRev == GLINT300SX_REV1) \
        SYNC_WITH_GLINT; \
}


// macro to load a given data value into an internal RGB525 register. The
// second macro loads an internal index register assuming that we have
// already zeroed the high address register.
//
#define RGB525_INDEX_REG(index) \
{ \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", RGB525_INDEX_ADDR_LO, (index) & 0xff)); \
    VideoPortWriteRegisterUlong(RGB525_INDEX_ADDR_LO, (ULONG)((index) & 0xff)); \
    RGB525_DELAY; \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", RGB525_INDEX_ADDR_HI, (index) >> 8)); \
    VideoPortWriteRegisterUlong(RGB525_INDEX_ADDR_HI, (ULONG)((index) >> 8)); \
    RGB525_DELAY; \
}

#define RGB525_LOAD_DATA(data) \
{ \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", RGB525_INDEX_DATA, (data) & 0xff)); \
    VideoPortWriteRegisterUlong (RGB525_INDEX_DATA, (ULONG)(data));    \
    RGB525_DELAY;                                               \
}

#define RGB525_LOAD_INDEX_REG(index, data) \
{ \
    RGB525_INDEX_REG(index);                            \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", RGB525_INDEX_DATA, (data) & 0xff)); \
    VideoPortWriteRegisterUlong(RGB525_INDEX_DATA, (ULONG)((data) & 0xff)); \
    RGB525_DELAY; \
}

#define RGB525_READ_INDEX_REG(index, data) \
{ \
    RGB525_INDEX_REG(index);                            \
    data = VideoPortReadRegisterUlong(RGB525_INDEX_DATA) & 0xff;   \
    RGB525_DELAY; \
    VideoDebugPrint(("0x%x <-- *(0x%x)\n", data, RGB525_INDEX_DATA)); \
}

#define RGB525_LOAD_INDEX_REG_LO(index, data) \
{ \
    VideoPortWriteRegisterUlong(RGB525_INDEX_ADDR_LO, (ULONG)(index));  \
    RGB525_DELAY; \
    VideoPortWriteRegisterUlong(RGB525_INDEX_DATA,    (ULONG)(data));   \
    RGB525_DELAY; \
}

// macros to load a given RGB triple into the RGB525 palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use RGB525_PALETTE_START and multiple RGB525_LOAD_PALETTE calls to load
// a contiguous set of entries. Use RGB525_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//
#define RGB525_PALETTE_START_WR(index) \
{ \
    VideoPortWriteRegisterUlong(RGB525_PAL_WR_ADDR,     (ULONG)(index));    \
    RGB525_DELAY; \
}

#define RGB525_PALETTE_START_RD(index) \
{ \
    VideoPortWriteRegisterUlong(RGB525_PAL_RD_ADDR,     (ULONG)(index));    \
    RGB525_DELAY; \
}

#define RGB525_LOAD_PALETTE(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(RGB525_PAL_DATA,    (ULONG)(red));      \
    RGB525_DELAY; \
    VideoPortWriteRegisterUlong(RGB525_PAL_DATA,    (ULONG)(green));    \
    RGB525_DELAY; \
    VideoPortWriteRegisterUlong(RGB525_PAL_DATA,    (ULONG)(blue));     \
    RGB525_DELAY; \
}

#define RGB525_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(RGB525_PAL_WR_ADDR, (ULONG)(index));    \
    RGB525_DELAY; \
    VideoPortWriteRegisterUlong(RGB525_PAL_DATA,    (ULONG)(red));      \
    RGB525_DELAY; \
    VideoPortWriteRegisterUlong(RGB525_PAL_DATA,    (ULONG)(green));    \
    RGB525_DELAY; \
    VideoPortWriteRegisterUlong(RGB525_PAL_DATA,    (ULONG)(blue));     \
    RGB525_DELAY; \
}

// macro to read back a given RGB triple from the RGB525 palette. Use after
// a call to RGB525_PALETTE_START_RD
//
#define RGB525_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR) (VideoPortReadRegisterUlong(RGB525_PAL_DATA) & 0xff);        \
    RGB525_DELAY; \
    green = (UCHAR) (VideoPortReadRegisterUlong(RGB525_PAL_DATA) & 0xff);        \
    RGB525_DELAY; \
    blue  = (UCHAR) (VideoPortReadRegisterUlong(RGB525_PAL_DATA) & 0xff);        \
    RGB525_DELAY; \
}

// macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//
#define RGB525_SET_PIXEL_READMASK(mask) \
{ \
    VideoPortWriteRegisterUlong(RGB525_PIXEL_MASK,  (ULONG)(mask)); \
    RGB525_DELAY; \
}

#define RGB525_READ_PIXEL_READMASK(mask) \
{ \
    mask = VideoPortReadRegisterUlong(RGB525_PIXEL_MASK) & 0xff; \
}

// macros to load values into the cursor array
//
#define RGB525_CURSOR_ARRAY_START(offset) \
{ \
    VideoPortWriteRegisterUlong(RGB525_INDEX_CONTROL,   (ULONG)(0x1));                      \
    RGB525_DELAY; \
    VideoPortWriteRegisterUlong(RGB525_INDEX_ADDR_LO,   (ULONG)(((offset)+0x100) & 0xff));  \
    RGB525_DELAY; \
    VideoPortWriteRegisterUlong(RGB525_INDEX_ADDR_HI,   (ULONG)(((offset)+0x100) >> 8));    \
    RGB525_DELAY; \
}

#define RGB525_LOAD_CURSOR_ARRAY(data) \
{ \
    VideoPortWriteRegisterUlong(RGB525_INDEX_DATA, (ULONG)(data)); \
    RGB525_DELAY; \
}

#define RGB525_READ_CURSOR_ARRAY(data) \
{ \
    data = VideoPortReadRegisterUlong(RGB525_INDEX_DATA) & 0xff; \
    RGB525_DELAY; \
}

// macro to move the cursor
//
#define RGB525_MOVE_CURSOR(x, y) \
{ \
    VideoPortWriteRegisterUlong(RGB525_INDEX_ADDR_HI,   (ULONG)0);              \
    RGB525_DELAY; \
    RGB525_LOAD_INDEX_REG_LO(RGB525_CURSOR_X_LOW,       (ULONG)((x) & 0xff));   \
    RGB525_LOAD_INDEX_REG_LO(RGB525_CURSOR_X_HIGH,      (ULONG)((x) >> 8));     \
    RGB525_LOAD_INDEX_REG_LO(RGB525_CURSOR_Y_LOW,       (ULONG)((y) & 0xff));   \
    RGB525_LOAD_INDEX_REG_LO(RGB525_CURSOR_Y_HIGH,      (ULONG)((y) >> 8));     \
}

// macro to change the cursor hotspot
//
#define RGB525_CURSOR_HOTSPOT(x, y) \
{ \
    VideoPortWriteRegisterUlong(RGB525_INDEX_ADDR_HI,   (ULONG)(0));    \
    RGB525_DELAY; \
    RGB525_LOAD_INDEX_REG_LO(RGB525_CURSOR_X_HOT_SPOT,  (ULONG)(x));    \
    RGB525_LOAD_INDEX_REG_LO(RGB525_CURSOR_Y_HOT_SPOT,  (ULONG)(y));    \
}    

//
// RGB525 internal register indexes
//
#define RGB525_REVISION_LEVEL           0x0000
#define RGB525_ID                       0x0001

#define RGB525_MISC_CLK_CTRL            0x0002
#define RGB525_SYNC_CTRL                0x0003
#define RGB525_HSYNC_CTRL               0x0004
#define RGB525_POWER_MANAGEMENT         0x0005
#define RGB525_DAC_OPERATION            0x0006
#define RGB525_PALETTE_CTRL             0x0007
#define RGB525_PIXEL_FORMAT             0x000A
#define RGB525_8BPP_CTRL                0x000B
#define RGB525_16BPP_CTRL               0x000C
#define RGB525_24BPP_CTRL               0x000D
#define RGB525_32BPP_CTRL               0x000E

#define RGB525_PLL_CTRL_1               0x0010
#define RGB525_PLL_CTRL_2               0x0011
#define RGB525_PLL_REF_DIV_COUNT        0x0014
#define RGB525_F0                       0x0020
#define RGB525_F1                       0x0021
#define RGB525_F2                       0x0022
#define RGB525_F3                       0x0023
#define RGB525_F4                       0x0024
#define RGB525_F5                       0x0025
#define RGB525_F6                       0x0026
#define RGB525_F7                       0x0027
#define RGB525_F8                       0x0028
#define RGB525_F9                       0x0029
#define RGB525_F10                      0x002A
#define RGB525_F11                      0x002B
#define RGB525_F12                      0x002C
#define RGB525_F13                      0x002D
#define RGB525_F14                      0x002E
#define RGB525_F15                      0x002F

// RGB525 Internal Cursor Registers
#define RGB525_CURSOR_CONTROL           0x0030
#define RGB525_CURSOR_X_LOW             0x0031
#define RGB525_CURSOR_X_HIGH            0x0032
#define RGB525_CURSOR_Y_LOW             0x0033
#define RGB525_CURSOR_Y_HIGH            0x0034
#define RGB525_CURSOR_X_HOT_SPOT        0x0035
#define RGB525_CURSOR_Y_HOT_SPOT        0x0036
#define RGB525_CURSOR_COLOR_1_RED       0x0040
#define RGB525_CURSOR_COLOR_1_GREEN     0x0041
#define RGB525_CURSOR_COLOR_1_BLUE      0x0042
#define RGB525_CURSOR_COLOR_2_RED       0x0043
#define RGB525_CURSOR_COLOR_2_GREEN     0x0044
#define RGB525_CURSOR_COLOR_2_BLUE      0x0045
#define RGB525_CURSOR_COLOR_3_RED       0x0046
#define RGB525_CURSOR_COLOR_3_GREEN     0x0047
#define RGB525_CURSOR_COLOR_3_BLUE      0x0048
#define RGB525_BORDER_COLOR_RED         0x0060
#define RGB525_BORDER_COLOR_GREEN       0x0061
#define RGB525_BORDER_COLOR_BLUE        0x0062

#define RGB525_MISC_CTRL_1              0x0070
#define RGB525_MISC_CTRL_2              0x0071
#define RGB525_MISC_CTRL_3              0x0072
// M0-M7, N0-N7 need defining

#define RGB525_DAC_SENSE                0x0082
#define RGB525_MISR_RED                 0x0084
#define RGB525_MISR_GREEN               0x0086
#define RGB525_MISR_BLUE                0x0088

#define RGB525_PLL_VCO_DIV_INPUT        0x008E
#define RGB525_PLL_REF_DIV_INPUT        0x008F

#define RGB525_VRAM_MASK_LOW            0x0090
#define RGB525_VRAM_MASK_HIGH           0x0091


//
// Bit definitions for individual internal RGB525 registers
//

// RGB525_REVISION_LEVEL
#define RGB525_PRODUCT_REV_LEVEL        0xf0

// RGB525_ID
#define RGB525_PRODUCT_ID               0x01

// RGB525_MISC_CTRL_1
#define MISR_CNTL_ENABLE                0x80
#define VMSK_CNTL_ENABLE                0x40
#define PADR_RDMT_RDADDR                0x0
#define PADR_RDMT_PAL_STATE             0x20
#define SENS_DSAB_DISABLE               0x10
#define SENS_SEL_BIT3                   0x0
#define SENS_SEL_BIT7                   0x08
#define VRAM_SIZE_32                    0x0
#define VRAM_SIZE_64                    0x01

// RGB525_MISC_CTRL_2
#define PCLK_SEL_LCLK                   0x0
#define PCLK_SEL_PLL                    0x40
#define PCLK_SEL_EXT                    0x80
#define INTL_MODE_ENABLE                0x20
#define BLANK_CNTL_ENABLE               0x10
#define COL_RES_6BIT                    0x0
#define COL_RES_8BIT                    0x04
#define PORT_SEL_VGA                    0x0
#define PORT_SEL_VRAM                   0x01

// RGB525_MISC_CTRL_3
#define SWAP_RB                         0x80
#define SWAP_WORD_LOHI                  0x0
#define SWAP_WORD_HILO                  0x10
#define SWAP_NIB_HILO                   0x0
#define SWAP_NIB_LOHI                   0x02

// RGB525_MISC_CLK_CTRL
#define DDOT_CLK_ENABLE                 0x0
#define DDOT_CLK_DISABLE                0x80
#define SCLK_ENABLE                     0x0
#define SCLK_DISABLE                    0x40
#define B24P_DDOT_PLL                   0x0
#define B24P_DDOT_SCLK                  0x20
#define DDOT_DIV_PLL_1                  0x0
#define DDOT_DIV_PLL_2                  0x02
#define DDOT_DIV_PLL_4                  0x04
#define DDOT_DIV_PLL_8                  0x06
#define DDOT_DIV_PLL_16                 0x08
#define PLL_DISABLE                     0x0
#define PLL_ENABLE                      0x01

// RGB525_SYNC_CTRL
#define DLY_CNTL_ADD                    0x0
#define DLY_SYNC_NOADD                  0x80
#define CSYN_INVT_DISABLE               0x0
#define CSYN_INVT_ENABLE                0x40
#define VSYN_INVT_DISABLE               0x0
#define VSYN_INVT_ENABLE                0x20
#define HSYN_INVT_DISABLE               0x0
#define HSYN_INVT_ENABLE                0x10
#define VSYN_CNTL_NORMAL                0x0
#define VSYN_CNTL_HIGH                  0x04
#define VSYN_CNTL_LOW                   0x08
#define VSYN_CNTL_DISABLE               0x0C
#define HSYN_CNTL_NORMAL                0x0
#define HSYN_CNTL_HIGH                  0x01
#define HSYN_CNTL_LOW                   0x02
#define HSYN_CNTL_DISABLE               0x03

// RGB525_HSYNC_CTRL
#define HSYN_POS(n)                     (n)

// RGB525_POWER_MANAGEMENT
#define SCLK_PWR_NORMAL                 0x0
#define SCLK_PWR_DISABLE                0x10
#define DDOT_PWR_NORMAL                 0x0
#define DDOT_PWR_DISABLE                0x08
#define SYNC_PWR_NORMAL                 0x0
#define SYNC_PWR_DISABLE                0x04
#define ICLK_PWR_NORMAL                 0x0
#define ICLK_PWR_DISABLE                0x02
#define DAC_PWR_NORMAL                  0x0
#define DAC_PWR_DISABLE                 0x01

// RGB525_DAC_OPERATION
#define SOG_DISABLE                     0x0
#define SOG_ENABLE                      0x08
#define BRB_NORMAL                      0x0
#define BRB_ALWAYS                      0x04
#define DSR_DAC_SLOW                    0x0
#define DSR_DAC_FAST                    0x02
#define DPE_DISABLE                     0x0
#define DPE_ENABLE                      0x01

// RGB525_PALETTE_CTRL
#define SIXBIT_LINEAR_ENABLE            0x0
#define SIXBIT_LINEAR_DISABLE           0x80
#define PALETTE_PARITION(n)             (n)

// RGB525_PIXEL_FORMAT
#define PIXEL_FORMAT_4BPP               0x02
#define PIXEL_FORMAT_8BPP               0x03
#define PIXEL_FORMAT_16BPP              0x04
#define PIXEL_FORMAT_24BPP              0x05
#define PIXEL_FORMAT_32BPP              0x06

// RGB525_8BPP_CTRL
#define B8_DCOL_INDIRECT                0x0
#define B8_DCOL_DIRECT                  0x01

// RGB525_16BPP_CTRL
#define B16_DCOL_INDIRECT               0x0
#define B16_DCOL_DYNAMIC                0x40
#define B16_DCOL_DIRECT                 0xC0
#define B16_POL_FORCE_BYPASS            0x0
#define B16_POL_FORCE_LOOKUP            0x20
#define B16_ZIB                         0x0
#define B16_LINEAR                      0x04
#define B16_555                         0x0
#define B16_565                         0x02
#define B16_SPARSE                      0x0
#define B16_CONTIGUOUS                  0x01

// RGB525_24BPP_CTRL
#define B24_DCOL_INDIRECT               0x0
#define B24_DCOL_DIRECT                 0x01

// RGB525_32BPP_CTRL
#define B32_POL_FORCE_BYPASS            0x0
#define B32_POL_FORCE_LOOKUP            0x04
#define B32_DCOL_INDIRECT               0x0
#define B32_DCOL_DYNAMIC                0x01
#define B32_DCOL_DIRECT                 0x03

// RGB525_PLL_CTRL_1
#define REF_SRC_REFCLK                  0x0
#define REF_SRC_EXTCLK                  0x10
#define PLL_EXT_FS_3_0                  0x0
#define PLL_EXT_FS_2_0                  0x01
#define PLL_CNTL2_3_0                   0x02
#define PLL_CNTL2_2_0                   0x03

// RGB525_PLL_CTRL_2
#define PLL_INT_FS_3_0(n)               (n)
#define PLL_INT_FS_2_0(n)               (n)

// RGB525_PLL_REF_DIV_COUNT
#define REF_DIV_COUNT(n)                (n)

// RGB525_F0 - RGB525_F15
#define VCO_DIV_COUNT(n)                (n)

// RGB525_PLL_REFCLK values
#define RGB525_PLL_REFCLK_MHz(n)        ((n)/2)

// RGB525_CURSOR_CONTROL
#define SMLC_PART_0                     0x0
#define SMLC_PART_1                     0x40
#define SMLC_PART_2                     0x80
#define SMLC_PART_3                     0xC0

#define RGBCINDEX_TO_VALUE(whichRGBCursor) (whichRGBCursor << 6)

#define PIX_ORDER_RL                    0x0
#define PIX_ORDER_LR                    0x20
#define LOC_READ_LAST                   0x0
#define LOC_READ_ACTUAL                 0x10
#define UPDT_CNTL_DELAYED               0x0
#define UPDT_CNTL_IMMEDIATE             0x08
#define CURSOR_SIZE_32                  0x0
#define CURSOR_SIZE_64                  0x40
#define CURSOR_MODE_OFF                 0x0
#define CURSOR_MODE_3_COLOR             0x01
#define CURSOR_MODE_2_COLOR_HL          0x02
#define CURSOR_MODE_2_COLOR             0x03

// RGB525_REVISION_LEVEL
#define REVISION_LEVEL                  0xF0    // predefined

// RGB525_ID
#define ID_CODE                         0x01    // predefined
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\rgb528.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: rgb528.h
*
* Content: This module contains the definitions for the IBM RGB528 RAMDAC.
*          The 528 is a superset of the 525 so only define things which have 
*          changed.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// RGB528_REVISION_LEVEL
#define RGB528_PRODUCT_REV_LEVEL        0xf0
#define RGB528A_PRODUCT_REV_LEVEL       0xe0

// RGB528_ID
#define RGB528_PRODUCT_ID               0x02


// RGB525_MISC_CTRL_1 extra value
#define VRAM_SIZE_128                   0x03

// RGB524_REVISION_LEVEL
#define RGB524_PRODUCT_REV_LEVEL        0xf0
#define RGB524A_PRODUCT_REV_LEVEL       0xe0

// RGB524_ID
#define RGB524_PRODUCT_ID               0x02
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\rgb526.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: rgb526.h
*
* Content: This module contains the definitions for the IBM RGB526 RAMDAC.
*          The 526 is a superset of the 525 so only define things which have 
*          changed.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// RGB526_REVISION_LEVEL
#define RGB526_PRODUCT_REV_LEVEL        0xc0
#define RGB526DB_PRODUCT_REV_LEVEL      0x80

// RGB526_ID
#define RGB526_PRODUCT_ID               0x02

//
// Key Support
//
#define RGB526_KEY_VALUE                0x68
#define RGB526_KEY_MASK                 0x6c
#define RGB526_KEY_CONTROL              0x78

// RGB526_32BPP_CTRL in addition to those on the RGB525
#define B32_DCOL_B8_INDIRECT            0x00    // overlay goes thru palette
#define B32_DCOL_B8_DIRECT              0x40    // overlay bypasses palette

#define RGB526_SYSTEM_CLOCK_CTRL        0x0008

#define RGB526_SYSCLK_REFDIVCOUNT       0x0015
#define RGB526_SYSCLK_VCODIVIDER        0x0016

#define RGB526_SYSCLK_N                 0x0015
#define RGB526_SYSCLK_M                 0x0016
#define RGB526_SYSCLK_P                 0x0017
#define RGB526_SYSCLK_C                 0x0018
#define RGB526_M0                       0x0020
#define RGB526_N0                       0x0021
#define RGB526_P0                       0x0022
#define RGB526_C0                       0x0023
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\reg.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: reg.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef __REG_H
#define __REG_H

#ifndef _REG_H_
#define _REG_H_

typedef signed long signed32;
typedef unsigned long unsigned32;

struct DMATag {
#if BIG_ENDIAN == 1
  unsigned32 Mask                                :16;
  unsigned32 Mode                                :2;
  unsigned32                                     :1;
  unsigned32 MajorGroup                          :9;
  unsigned32 Offset                              :4;
#else
  unsigned32 Offset                              :4;
  unsigned32 MajorGroup                          :9;
  unsigned32                                     :1;
  unsigned32 Mode                                :2;
  unsigned32 Mask                                :16;
#endif
#ifdef __cplusplus
  DMATag(void) { }
  DMATag(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DMATag& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DMATag& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DMATag& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffff<<16|0x3<<14|0x1ff<<4|0xf<<0)); }
#endif /* __cplusplus */
};

struct Render {
#if BIG_ENDIAN == 1
  unsigned32                                     :4;
  unsigned32 FBSourceReadEnable                  :1;
  unsigned32 dErr                                :7;
  unsigned32                                     :1;
  unsigned32 SpanOperation                       :1;
  unsigned32                                     :1;
  unsigned32 SubpixelCorrectionEnable            :1;
  unsigned32 CoverageEnable                      :1;
  unsigned32 FogEnable                           :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 SyncOnHostData                      :1;
  unsigned32 SyncOnBitMask                       :1;
  unsigned32 UsePointTable                       :1;
  unsigned32 AntialiasingQuality                 :1;
  unsigned32 AntialiasEnable                     :1;
  unsigned32 PrimitiveType                       :2;
  unsigned32                                     :2;
  unsigned32 FastFillEnable                      :1;
  unsigned32 ResetLineStipple                    :1;
  unsigned32 LineStippleEnable                   :1;
  unsigned32 AreaStippleEnable                   :1;
#else
  unsigned32 AreaStippleEnable                   :1;
  unsigned32 LineStippleEnable                   :1;
  unsigned32 ResetLineStipple                    :1;
  unsigned32 FastFillEnable                      :1;
  unsigned32                                     :2;
  unsigned32 PrimitiveType                       :2;
  unsigned32 AntialiasEnable                     :1;
  unsigned32 AntialiasingQuality                 :1;
  unsigned32 UsePointTable                       :1;
  unsigned32 SyncOnBitMask                       :1;
  unsigned32 SyncOnHostData                      :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 FogEnable                           :1;
  unsigned32 CoverageEnable                      :1;
  unsigned32 SubpixelCorrectionEnable            :1;
  unsigned32                                     :1;
  unsigned32 SpanOperation                       :1;
  unsigned32                                     :1;
  unsigned32 dErr                                :7;
  unsigned32 FBSourceReadEnable                  :1;
  unsigned32                                     :4;
#endif
#ifdef __cplusplus
  Render(void) { }
  Render(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Render& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Render& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Render& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<27|0x7f<<20|0x1<<18|0x1<<16|0x1<<15|0x1<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x3<<6|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct RasterizerMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :4;
  unsigned32 UseSuspendReads                     :1;
  unsigned32 D3DRules                            :1;
  unsigned32 MultiRXBlit                         :1;
  unsigned32 OpaqueSpan                          :1;
  unsigned32 WordPacking                         :1;
  unsigned32 StripeHeight                        :3;
  unsigned32 BitMaskRelative                     :1;
  unsigned32 YLimitsEnable                       :1;
  unsigned32 MultiGLINT                          :1;
  unsigned32 HostDataByteSwapMode                :2;
  unsigned32 BitMaskOffset                       :5;
  unsigned32 BitMaskPacking                      :1;
  unsigned32 BitMaskByteSwapMode                 :2;
  unsigned32 ForceBackgroundColor                :1;
  unsigned32 BiasCoordinates                     :2;
  unsigned32 FractionAdjust                      :2;
  unsigned32 InvertBitMask                       :1;
  unsigned32 MirrorBitMask                       :1;
#else
  unsigned32 MirrorBitMask                       :1;
  unsigned32 InvertBitMask                       :1;
  unsigned32 FractionAdjust                      :2;
  unsigned32 BiasCoordinates                     :2;
  unsigned32 ForceBackgroundColor                :1;
  unsigned32 BitMaskByteSwapMode                 :2;
  unsigned32 BitMaskPacking                      :1;
  unsigned32 BitMaskOffset                       :5;
  unsigned32 HostDataByteSwapMode                :2;
  unsigned32 MultiGLINT                          :1;
  unsigned32 YLimitsEnable                       :1;
  unsigned32 BitMaskRelative                     :1;
  unsigned32 StripeHeight                        :3;
  unsigned32 WordPacking                         :1;
  unsigned32 OpaqueSpan                          :1;
  unsigned32 MultiRXBlit                         :1;
  unsigned32 D3DRules                            :1;
  unsigned32 UseSuspendReads                     :1;
  unsigned32                                     :4;
#endif
#ifdef __cplusplus
  RasterizerMode(void) { }
  RasterizerMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  RasterizerMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  RasterizerMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  RasterizerMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<27|0x1<<26|0x1<<25|0x1<<24|0x1<<23|0x7<<20|0x1<<19|0x1<<18|0x1<<17|0x3<<15|0x1f<<10|0x1<<9|0x3<<7|0x1<<6|0x3<<4|0x3<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct YLimits {
#if BIG_ENDIAN == 1
  signed32   MaxY                                :16;
  signed32   MinY                                :16;
#else
  signed32   MinY                                :16;
  signed32   MaxY                                :16;
#endif
#ifdef __cplusplus
  YLimits(void) { }
  YLimits(const unsigned32 i) { *((unsigned32 *)this) = i; }
  YLimits& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  YLimits& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  YLimits& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffff<<16|0xffff<<0)); }
#endif /* __cplusplus */
};

struct GlintScanlineOwnership {
#if BIG_ENDIAN == 1
  unsigned32                                     :27;
  unsigned32 Scanline                            :3;
  unsigned32 ScanlineInterval                    :2;
#else
  unsigned32 ScanlineInterval                    :2;
  unsigned32 Scanline                            :3;
  unsigned32                                     :27;
#endif
#ifdef __cplusplus
  GlintScanlineOwnership(void) { }
  GlintScanlineOwnership(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GlintScanlineOwnership& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GlintScanlineOwnership& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GlintScanlineOwnership& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct ScanlineOwnership {
#if BIG_ENDIAN == 1
  unsigned32                                     :26;
  unsigned32 MyId                                :3;
  unsigned32 Mask                                :3;
#else
  unsigned32 Mask                                :3;
  unsigned32 MyId                                :3;
  unsigned32                                     :26;
#endif
#ifdef __cplusplus
  ScanlineOwnership(void) { }
  ScanlineOwnership(const unsigned32 i) { *((unsigned32 *)this) = i; }
  ScanlineOwnership& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  ScanlineOwnership& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  ScanlineOwnership& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<3|0x7<<0)); }
#endif /* __cplusplus */
};

struct GlintPixelSize {
#if BIG_ENDIAN == 1
  unsigned32                                     :30;
  unsigned32 Size                                :2;
#else
  unsigned32 Size                                :2;
  unsigned32                                     :30;
#endif
#ifdef __cplusplus
  GlintPixelSize(void) { }
  GlintPixelSize(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GlintPixelSize& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GlintPixelSize& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GlintPixelSize& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<0)); }
#endif /* __cplusplus */
};

struct PixelSize {
#if BIG_ENDIAN == 1
  unsigned32 Setting                             :1;
  unsigned32                                     :13;
  unsigned32 TwoDSetupUnit                       :2;
  unsigned32 FBWriteUnit                         :2;
  unsigned32 LogicalOpsUnit                      :2;
  unsigned32 FBReadUnit                          :2;
  unsigned32 LUTUnit                             :2;
  unsigned32 TextureUnit                         :2;
  unsigned32 ScissorUnit                         :2;
  unsigned32 RasterizerUnit                      :2;
  unsigned32 AllUnits                            :2;
#else
  unsigned32 AllUnits                            :2;
  unsigned32 RasterizerUnit                      :2;
  unsigned32 ScissorUnit                         :2;
  unsigned32 TextureUnit                         :2;
  unsigned32 LUTUnit                             :2;
  unsigned32 FBReadUnit                          :2;
  unsigned32 LogicalOpsUnit                      :2;
  unsigned32 FBWriteUnit                         :2;
  unsigned32 TwoDSetupUnit                       :2;
  unsigned32                                     :13;
  unsigned32 Setting                             :1;
#endif
#ifdef __cplusplus
  PixelSize(void) { }
  PixelSize(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PixelSize& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PixelSize& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PixelSize& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x3<<16|0x3<<14|0x3<<12|0x3<<10|0x3<<8|0x3<<6|0x3<<4|0x3<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct StripeOffsetY {
#if BIG_ENDIAN == 1
  unsigned32                                     :16;
  unsigned32 Offset                              :16;
#else
  unsigned32 Offset                              :16;
  unsigned32                                     :16;
#endif
#ifdef __cplusplus
  StripeOffsetY(void) { }
  StripeOffsetY(const unsigned32 i) { *((unsigned32 *)this) = i; }
  StripeOffsetY& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  StripeOffsetY& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  StripeOffsetY& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffff<<0)); }
#endif /* __cplusplus */
};

struct ReadMonitorMode {
#if BIG_ENDIAN == 1
  signed32   StripeOffset                        :16;
  unsigned32                                     :8;
  unsigned32 HashFunction                        :1;
  unsigned32 StripeHeight                        :3;
  unsigned32 StripePitch                         :3;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 StripePitch                         :3;
  unsigned32 StripeHeight                        :3;
  unsigned32 HashFunction                        :1;
  unsigned32                                     :8;
  signed32   StripeOffset                        :16;
#endif
#ifdef __cplusplus
  ReadMonitorMode(void) { }
  ReadMonitorMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  ReadMonitorMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  ReadMonitorMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  ReadMonitorMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffff<<16|0x1<<7|0x7<<4|0x7<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct XY {
#if BIG_ENDIAN == 1
  signed32   Y                                   :16;
  signed32   X                                   :16;
#else
  signed32   X                                   :16;
  signed32   Y                                   :16;
#endif
#ifdef __cplusplus
  XY(void) { }
  XY(const unsigned32 i) { *((unsigned32 *)this) = i; }
  XY& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  XY& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  XY& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffff<<16|0xffff<<0)); }
#endif /* __cplusplus */
};

struct UXY {
#if BIG_ENDIAN == 1
  unsigned32 Y                                   :16;
  unsigned32 X                                   :16;
#else
  unsigned32 X                                   :16;
  unsigned32 Y                                   :16;
#endif
#ifdef __cplusplus
  UXY(void) { }
  UXY(const unsigned32 i) { *((unsigned32 *)this) = i; }
  UXY& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  UXY& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  UXY& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffff<<16|0xffff<<0)); }
#endif /* __cplusplus */
};

struct ScissorMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :30;
  unsigned32 ScreenScissorEnable                 :1;
  unsigned32 UserScissorEnable                   :1;
#else
  unsigned32 UserScissorEnable                   :1;
  unsigned32 ScreenScissorEnable                 :1;
  unsigned32                                     :30;
#endif
#ifdef __cplusplus
  ScissorMode(void) { }
  ScissorMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  ScissorMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  ScissorMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  ScissorMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct AreaStippleMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :1;
  unsigned32 YTableOffset                        :5;
  unsigned32 XTableOffset                        :5;
  unsigned32 OpaqueSpan                          :1;
  unsigned32 MirrorY                             :1;
  unsigned32 MirrorX                             :1;
  unsigned32 InvertStipplePattern                :1;
  unsigned32 YOffset                             :5;
  unsigned32 XOffset                             :5;
  unsigned32 YAddressSelect                      :3;
  unsigned32 XAddressSelect                      :3;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 XAddressSelect                      :3;
  unsigned32 YAddressSelect                      :3;
  unsigned32 XOffset                             :5;
  unsigned32 YOffset                             :5;
  unsigned32 InvertStipplePattern                :1;
  unsigned32 MirrorX                             :1;
  unsigned32 MirrorY                             :1;
  unsigned32 OpaqueSpan                          :1;
  unsigned32 XTableOffset                        :5;
  unsigned32 YTableOffset                        :5;
  unsigned32                                     :1;
#endif
#ifdef __cplusplus
  AreaStippleMode(void) { }
  AreaStippleMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  AreaStippleMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  AreaStippleMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  AreaStippleMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1f<<26|0x1f<<21|0x1<<20|0x1<<19|0x1<<18|0x1<<17|0x1f<<12|0x1f<<7|0x7<<4|0x7<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct LineStippleMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :5;
  unsigned32 Mirror                              :1;
  unsigned32 StippleMask                         :16;
  unsigned32 RepeatFactor                        :9;
  unsigned32 StippleEnable                       :1;
#else
  unsigned32 StippleEnable                       :1;
  unsigned32 RepeatFactor                        :9;
  unsigned32 StippleMask                         :16;
  unsigned32 Mirror                              :1;
  unsigned32                                     :5;
#endif
#ifdef __cplusplus
  LineStippleMode(void) { }
  LineStippleMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LineStippleMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LineStippleMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LineStippleMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<26|0xffff<<10|0x1ff<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct Line {
#if BIG_ENDIAN == 1
  unsigned32                                     :6;
  unsigned32 SegmentRepeatCounter                :9;
  unsigned32 SegmentBitCounter                   :4;
  unsigned32 LiveRepeatCounter                   :9;
  unsigned32 LiveBitCounter                      :4;
#else
  unsigned32 LiveBitCounter                      :4;
  unsigned32 LiveRepeatCounter                   :9;
  unsigned32 SegmentBitCounter                   :4;
  unsigned32 SegmentRepeatCounter                :9;
  unsigned32                                     :6;
#endif
#ifdef __cplusplus
  Line(void) { }
  Line(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Line& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Line& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Line& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1ff<<17|0xf<<13|0x1ff<<4|0xf<<0)); }
#endif /* __cplusplus */
};

struct GlintTextureAddressMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :14;
  unsigned32 TextureMapType                      :1;
  unsigned32 Height                              :4;
  unsigned32 Width                               :4;
  unsigned32 EnableDY                            :1;
  unsigned32 EnableLOD                           :1;
  unsigned32 InhibitDDAInitialization            :1;
  unsigned32 Operation                           :1;
  unsigned32 TWrap                               :2;
  unsigned32 SWrap                               :2;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 SWrap                               :2;
  unsigned32 TWrap                               :2;
  unsigned32 Operation                           :1;
  unsigned32 InhibitDDAInitialization            :1;
  unsigned32 EnableLOD                           :1;
  unsigned32 EnableDY                            :1;
  unsigned32 Width                               :4;
  unsigned32 Height                              :4;
  unsigned32 TextureMapType                      :1;
  unsigned32                                     :14;
#endif
#ifdef __cplusplus
  GlintTextureAddressMode(void) { }
  GlintTextureAddressMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GlintTextureAddressMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GlintTextureAddressMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GlintTextureAddressMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<17|0xf<<13|0xf<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x3<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct PermediaTextureAddressMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :30;
  unsigned32 PerspectiveCorrection               :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 PerspectiveCorrection               :1;
  unsigned32                                     :30;
#endif
#ifdef __cplusplus
  PermediaTextureAddressMode(void) { }
  PermediaTextureAddressMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PermediaTextureAddressMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PermediaTextureAddressMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PermediaTextureAddressMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureCoordMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :9;
  unsigned32 DuplicateCoord                      :1;
  unsigned32 WrapT1                              :2;
  unsigned32 WrapS1                              :2;
  unsigned32 TextureMapType                      :1;
  unsigned32 Height                              :4;
  unsigned32 Width                               :4;
  unsigned32 EnableDY                            :1;
  unsigned32 EnableLOD                           :1;
  unsigned32 InhibitDDAInitialisation            :1;
  unsigned32 Operation                           :1;
  unsigned32 WrapT                               :2;
  unsigned32 WrapS                               :2;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 WrapS                               :2;
  unsigned32 WrapT                               :2;
  unsigned32 Operation                           :1;
  unsigned32 InhibitDDAInitialisation            :1;
  unsigned32 EnableLOD                           :1;
  unsigned32 EnableDY                            :1;
  unsigned32 Width                               :4;
  unsigned32 Height                              :4;
  unsigned32 TextureMapType                      :1;
  unsigned32 WrapS1                              :2;
  unsigned32 WrapT1                              :2;
  unsigned32 DuplicateCoord                      :1;
  unsigned32                                     :9;
#endif
#ifdef __cplusplus
  TextureCoordMode(void) { }
  TextureCoordMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureCoordMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureCoordMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureCoordMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<22|0x3<<20|0x3<<18|0x1<<17|0xf<<13|0xf<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x3<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct GlintLOD {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 Integer                             :4;
  unsigned32 Fraction                            :8;
#else
  unsigned32 Fraction                            :8;
  unsigned32 Integer                             :4;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  GlintLOD(void) { }
  GlintLOD(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GlintLOD& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GlintLOD& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GlintLOD& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xf<<8|0xff<<0)); }
#endif /* __cplusplus */
};

struct LOD {
#if BIG_ENDIAN == 1
  unsigned32                                     :28;
  unsigned32 Value                               :4;
#else
  unsigned32 Value                               :4;
  unsigned32                                     :28;
#endif
#ifdef __cplusplus
  LOD(void) { }
  LOD(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LOD& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LOD& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LOD& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xf<<0)); }
#endif /* __cplusplus */
};

struct LOD1 {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 LOD                                 :12;
#else
  unsigned32 LOD                                 :12;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  LOD1(void) { }
  LOD1(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LOD1& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LOD1& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LOD1& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xfff<<0)); }
#endif /* __cplusplus */
};

struct TextureLODBias {
#if BIG_ENDIAN == 1
  unsigned32                                     :19;
  signed32   Integer                             :5;
  unsigned32 Fraction                            :8;
#else
  unsigned32 Fraction                            :8;
  signed32   Integer                             :5;
  unsigned32                                     :19;
#endif
#ifdef __cplusplus
  TextureLODBias(void) { }
  TextureLODBias(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureLODBias& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureLODBias& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureLODBias& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1f<<8|0xff<<0)); }
#endif /* __cplusplus */
};

struct GlintTextureReadMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :4;
  unsigned32 BorderClamp                         :1;
  unsigned32 FBSourceAddr                        :2;
  unsigned32 PrimaryCache                        :1;
  unsigned32 MipMap                              :1;
  unsigned32 TextureMapType                      :1;
  unsigned32 VWrap                               :2;
  unsigned32 UWrap                               :2;
  unsigned32 MinFilter                           :3;
  unsigned32 MagFilter                           :1;
  unsigned32 Patch                               :1;
  unsigned32 Border                              :1;
  unsigned32 Depth                               :3;
  unsigned32 Height                              :4;
  unsigned32 Width                               :4;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 Width                               :4;
  unsigned32 Height                              :4;
  unsigned32 Depth                               :3;
  unsigned32 Border                              :1;
  unsigned32 Patch                               :1;
  unsigned32 MagFilter                           :1;
  unsigned32 MinFilter                           :3;
  unsigned32 UWrap                               :2;
  unsigned32 VWrap                               :2;
  unsigned32 TextureMapType                      :1;
  unsigned32 MipMap                              :1;
  unsigned32 PrimaryCache                        :1;
  unsigned32 FBSourceAddr                        :2;
  unsigned32 BorderClamp                         :1;
  unsigned32                                     :4;
#endif
#ifdef __cplusplus
  GlintTextureReadMode(void) { }
  GlintTextureReadMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GlintTextureReadMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GlintTextureReadMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GlintTextureReadMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<27|0x3<<25|0x1<<24|0x1<<23|0x1<<22|0x3<<20|0x3<<18|0x7<<15|0x1<<14|0x1<<13|0x1<<12|0x7<<9|0xf<<5|0xf<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureReadMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :1;
  unsigned32 OpaqueSpan                          :1;
  unsigned32 Invert                              :1;
  unsigned32 Mirror                              :1;
  unsigned32 ByteSwap                            :3;
  unsigned32 TextureType                         :2;
  unsigned32 Origin                              :1;
  unsigned32 LogicalTexture                      :1;
  unsigned32 MapMaxLevel                         :4;
  unsigned32 MapBaseLevel                        :4;
  unsigned32 CombineCaches                       :1;
  unsigned32 Texture3D                           :1;
  unsigned32 TexelSize                           :2;
  unsigned32 Height                              :4;
  unsigned32 Width                               :4;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 Width                               :4;
  unsigned32 Height                              :4;
  unsigned32 TexelSize                           :2;
  unsigned32 Texture3D                           :1;
  unsigned32 CombineCaches                       :1;
  unsigned32 MapBaseLevel                        :4;
  unsigned32 MapMaxLevel                         :4;
  unsigned32 LogicalTexture                      :1;
  unsigned32 Origin                              :1;
  unsigned32 TextureType                         :2;
  unsigned32 ByteSwap                            :3;
  unsigned32 Mirror                              :1;
  unsigned32 Invert                              :1;
  unsigned32 OpaqueSpan                          :1;
  unsigned32                                     :1;
#endif
#ifdef __cplusplus
  TextureReadMode(void) { }
  TextureReadMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureReadMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureReadMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureReadMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<30|0x1<<29|0x1<<28|0x7<<25|0x3<<23|0x1<<22|0x1<<21|0xf<<17|0xf<<13|0x1<<12|0x1<<11|0x3<<9|0xf<<5|0xf<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureFormat {
#if BIG_ENDIAN == 1
  unsigned32                                     :12;
  unsigned32 OneCompFormat                       :2;
  unsigned32 LUTOffset                           :8;
  unsigned32 ByteSwapBitMask                     :1;
  unsigned32 InvertBitMask                       :1;
  unsigned32 MirrorBitMask                       :1;
  unsigned32 OutputFormat                        :2;
  unsigned32 NumberComps                         :2;
  unsigned32 ColorOrder                          :1;
  unsigned32 Format                              :1;
  unsigned32 Order                               :1;
#else
  unsigned32 Order                               :1;
  unsigned32 Format                              :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 NumberComps                         :2;
  unsigned32 OutputFormat                        :2;
  unsigned32 MirrorBitMask                       :1;
  unsigned32 InvertBitMask                       :1;
  unsigned32 ByteSwapBitMask                     :1;
  unsigned32 LUTOffset                           :8;
  unsigned32 OneCompFormat                       :2;
  unsigned32                                     :12;
#endif
#ifdef __cplusplus
  TextureFormat(void) { }
  TextureFormat(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureFormat& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureFormat& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureFormat& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<18|0xff<<10|0x1<<9|0x1<<8|0x1<<7|0x3<<5|0x3<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TexelLUTIndex {
#if BIG_ENDIAN == 1
  unsigned32                                     :24;
  unsigned32 Index                               :8;
#else
  unsigned32 Index                               :8;
  unsigned32                                     :24;
#endif
#ifdef __cplusplus
  TexelLUTIndex(void) { }
  TexelLUTIndex(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TexelLUTIndex& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TexelLUTIndex& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TexelLUTIndex& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<0)); }
#endif /* __cplusplus */
};

struct LUTIndex {
#if BIG_ENDIAN == 1
  unsigned32                                     :24;
  unsigned32 Index                               :8;
#else
  unsigned32 Index                               :8;
  unsigned32                                     :24;
#endif
#ifdef __cplusplus
  LUTIndex(void) { }
  LUTIndex(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LUTIndex& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LUTIndex& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LUTIndex& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<0)); }
#endif /* __cplusplus */
};

struct TexelLUTTransfer {
#if BIG_ENDIAN == 1
  unsigned32                                     :15;
  unsigned32 Count                               :9;
  unsigned32 Index                               :8;
#else
  unsigned32 Index                               :8;
  unsigned32 Count                               :9;
  unsigned32                                     :15;
#endif
#ifdef __cplusplus
  TexelLUTTransfer(void) { }
  TexelLUTTransfer(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TexelLUTTransfer& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TexelLUTTransfer& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TexelLUTTransfer& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1ff<<8|0xff<<0)); }
#endif /* __cplusplus */
};

struct LUTTransfer {
#if BIG_ENDIAN == 1
  unsigned32                                     :17;
  unsigned32 Count                               :7;
  unsigned32 Index                               :8;
#else
  unsigned32 Index                               :8;
  unsigned32 Count                               :7;
  unsigned32                                     :17;
#endif
#ifdef __cplusplus
  LUTTransfer(void) { }
  LUTTransfer(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LUTTransfer& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LUTTransfer& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LUTTransfer& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7f<<8|0xff<<0)); }
#endif /* __cplusplus */
};

struct GlintTextureFilterMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :29;
  unsigned32 AlphaMapSense                       :1;
  unsigned32 AlphaMapEnable                      :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 AlphaMapEnable                      :1;
  unsigned32 AlphaMapSense                       :1;
  unsigned32                                     :29;
#endif
#ifdef __cplusplus
  GlintTextureFilterMode(void) { }
  GlintTextureFilterMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GlintTextureFilterMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GlintTextureFilterMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GlintTextureFilterMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureFilterMode {
#if BIG_ENDIAN == 1
  unsigned32 Shift1                              :1;
  unsigned32 Shift0                              :1;
  unsigned32 ForceAlphaToOne1                    :1;
  unsigned32 ForceAlphaToOne0                    :1;
  unsigned32 MultiTexture                        :1;
  unsigned32 AlphaMapFilterLimit01               :4;
  unsigned32 AlphaMapFilterLimit1                :3;
  unsigned32 AlphaMapFilterLimit0                :3;
  unsigned32 AlphaMapFiltering                   :1;
  unsigned32 AlphaMapSense1                      :1;
  unsigned32 AlphaMapEnable1                     :1;
  unsigned32 ColorOrder1                         :1;
  unsigned32 Format1                             :4;
  unsigned32 CombineCaches                       :1;
  unsigned32 AlphaMapSense0                      :1;
  unsigned32 AlphaMapEnable0                     :1;
  unsigned32 ColorOrder0                         :1;
  unsigned32 Format0                             :4;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 Format0                             :4;
  unsigned32 ColorOrder0                         :1;
  unsigned32 AlphaMapEnable0                     :1;
  unsigned32 AlphaMapSense0                      :1;
  unsigned32 CombineCaches                       :1;
  unsigned32 Format1                             :4;
  unsigned32 ColorOrder1                         :1;
  unsigned32 AlphaMapEnable1                     :1;
  unsigned32 AlphaMapSense1                      :1;
  unsigned32 AlphaMapFiltering                   :1;
  unsigned32 AlphaMapFilterLimit0                :3;
  unsigned32 AlphaMapFilterLimit1                :3;
  unsigned32 AlphaMapFilterLimit01               :4;
  unsigned32 MultiTexture                        :1;
  unsigned32 ForceAlphaToOne0                    :1;
  unsigned32 ForceAlphaToOne1                    :1;
  unsigned32 Shift0                              :1;
  unsigned32 Shift1                              :1;
#endif
#ifdef __cplusplus
  TextureFilterMode(void) { }
  TextureFilterMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureFilterMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureFilterMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureFilterMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x1<<30|0x1<<29|0x1<<28|0x1<<27|0xf<<23|0x7<<20|0x7<<17|0x1<<16|0x1<<15|0x1<<14|0x1<<13|0xf<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0xf<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureMapFormat {
#if BIG_ENDIAN == 1
  unsigned32                                     :10;
  unsigned32 TexelSize                           :3;
  unsigned32                                     :1;
  unsigned32 SubPatchMode                        :1;
  unsigned32 WindowOrigin                        :1;
  unsigned32                                     :7;
  unsigned32 PP2                                 :3;
  unsigned32 PP1                                 :3;
  unsigned32 PP0                                 :3;
#else
  unsigned32 PP0                                 :3;
  unsigned32 PP1                                 :3;
  unsigned32 PP2                                 :3;
  unsigned32                                     :7;
  unsigned32 WindowOrigin                        :1;
  unsigned32 SubPatchMode                        :1;
  unsigned32                                     :1;
  unsigned32 TexelSize                           :3;
  unsigned32                                     :10;
#endif
#ifdef __cplusplus
  TextureMapFormat(void) { }
  TextureMapFormat(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureMapFormat& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureMapFormat& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureMapFormat& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<19|0x1<<17|0x1<<16|0x7<<6|0x7<<3|0x7<<0)); }
#endif /* __cplusplus */
};

struct TextureDataFormat {
#if BIG_ENDIAN == 1
  unsigned32                                     :23;
  unsigned32 SpanFormat                          :1;
  unsigned32 AlphaMap                            :1;
  unsigned32 TextureFormatExtension              :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 NoAlphaBuffer                       :1;
  unsigned32 TextureFormat                       :4;
#else
  unsigned32 TextureFormat                       :4;
  unsigned32 NoAlphaBuffer                       :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 TextureFormatExtension              :1;
  unsigned32 AlphaMap                            :1;
  unsigned32 SpanFormat                          :1;
  unsigned32                                     :23;
#endif
#ifdef __cplusplus
  TextureDataFormat(void) { }
  TextureDataFormat(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureDataFormat& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureDataFormat& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureDataFormat& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0xf<<0)); }
#endif /* __cplusplus */
};

struct PermediaTextureReadMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :7;
  unsigned32 PackedData                          :1;
  unsigned32                                     :6;
  unsigned32 FilterMode                          :1;
  unsigned32 Height                              :4;
  unsigned32 Width                               :4;
  unsigned32                                     :4;
  unsigned32 TWrap                               :2;
  unsigned32 SWrap                               :2;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 SWrap                               :2;
  unsigned32 TWrap                               :2;
  unsigned32                                     :4;
  unsigned32 Width                               :4;
  unsigned32 Height                              :4;
  unsigned32 FilterMode                          :1;
  unsigned32                                     :6;
  unsigned32 PackedData                          :1;
  unsigned32                                     :7;
#endif
#ifdef __cplusplus
  PermediaTextureReadMode(void) { }
  PermediaTextureReadMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PermediaTextureReadMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PermediaTextureReadMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PermediaTextureReadMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<24|0x1<<17|0xf<<13|0xf<<9|0x3<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TexelLUTMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 PixelsPerEntry                      :2;
  unsigned32 Offset                              :8;
  unsigned32 DirectIndex                         :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 DirectIndex                         :1;
  unsigned32 Offset                              :8;
  unsigned32 PixelsPerEntry                      :2;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  TexelLUTMode(void) { }
  TexelLUTMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TexelLUTMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TexelLUTMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TexelLUTMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<10|0xff<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureColorMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 ColorLoadMode                       :2;
  unsigned32 BaseFormat                          :3;
  unsigned32 KsDDA                               :1;
  unsigned32 KdDDA                               :1;
  unsigned32 TextureType                         :1;
  unsigned32 ApplicationMode                     :3;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 ApplicationMode                     :3;
  unsigned32 TextureType                         :1;
  unsigned32 KdDDA                               :1;
  unsigned32 KsDDA                               :1;
  unsigned32 BaseFormat                          :3;
  unsigned32 ColorLoadMode                       :2;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  TextureColorMode(void) { }
  TextureColorMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureColorMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureColorMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureColorMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<10|0x7<<7|0x1<<6|0x1<<5|0x1<<4|0x7<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureApplicationMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :8;
  unsigned32 MotionCompEnable                    :1;
  unsigned32 EnableKs                            :1;
  unsigned32 EnableKd                            :1;
  unsigned32 AlphaOperation                      :3;
  unsigned32 AlphaInvertI                        :1;
  unsigned32 AlphaI                              :2;
  unsigned32 AlphaB                              :2;
  unsigned32 AlphaA                              :2;
  unsigned32 ColorOperation                      :3;
  unsigned32 ColorInvertI                        :1;
  unsigned32 ColorI                              :2;
  unsigned32 ColorB                              :2;
  unsigned32 ColorA                              :2;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 ColorA                              :2;
  unsigned32 ColorB                              :2;
  unsigned32 ColorI                              :2;
  unsigned32 ColorInvertI                        :1;
  unsigned32 ColorOperation                      :3;
  unsigned32 AlphaA                              :2;
  unsigned32 AlphaB                              :2;
  unsigned32 AlphaI                              :2;
  unsigned32 AlphaInvertI                        :1;
  unsigned32 AlphaOperation                      :3;
  unsigned32 EnableKd                            :1;
  unsigned32 EnableKs                            :1;
  unsigned32 MotionCompEnable                    :1;
  unsigned32                                     :8;
#endif
#ifdef __cplusplus
  TextureApplicationMode(void) { }
  TextureApplicationMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureApplicationMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureApplicationMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureApplicationMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<23|0x1<<22|0x1<<21|0x7<<18|0x1<<17|0x3<<15|0x3<<13|0x3<<11|0x7<<8|0x1<<7|0x3<<5|0x3<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct FogMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :22;
  unsigned32 InvertFI                            :1;
  unsigned32 ZShift                              :5;
  unsigned32 UseZ                                :1;
  unsigned32 Table                               :1;
  unsigned32 ColorMode                           :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 ColorMode                           :1;
  unsigned32 Table                               :1;
  unsigned32 UseZ                                :1;
  unsigned32 ZShift                              :5;
  unsigned32 InvertFI                            :1;
  unsigned32                                     :22;
#endif
#ifdef __cplusplus
  FogMode(void) { }
  FogMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FogMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FogMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FogMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<9|0x1f<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct ColorDDAMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :30;
  unsigned32 Shading                             :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 Shading                             :1;
  unsigned32                                     :30;
#endif
#ifdef __cplusplus
  ColorDDAMode(void) { }
  ColorDDAMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  ColorDDAMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  ColorDDAMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  ColorDDAMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct Color {
#if BIG_ENDIAN == 1
  unsigned32 Alpha                               :8;
  unsigned32 Blue                                :8;
  unsigned32 Green                               :8;
  unsigned32 Red                                 :8;
#else
  unsigned32 Red                                 :8;
  unsigned32 Green                               :8;
  unsigned32 Blue                                :8;
  unsigned32 Alpha                               :8;
#endif
#ifdef __cplusplus
  Color(void) { }
  Color(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Color& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Color& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Color& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<24|0xff<<16|0xff<<8|0xff<<0)); }
#endif /* __cplusplus */
};

struct AlphaTestMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 Reference                           :8;
  unsigned32 Compare                             :3;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 Compare                             :3;
  unsigned32 Reference                           :8;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  AlphaTestMode(void) { }
  AlphaTestMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  AlphaTestMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  AlphaTestMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  AlphaTestMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<4|0x7<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct AntialiasMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :29;
  unsigned32 ScaleColor                          :1;
  unsigned32 ColorMode                           :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 ColorMode                           :1;
  unsigned32 ScaleColor                          :1;
  unsigned32                                     :29;
#endif
#ifdef __cplusplus
  AntialiasMode(void) { }
  AntialiasMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  AntialiasMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  AntialiasMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  AntialiasMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct GlintAlphaBlendMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :14;
  unsigned32 AlphaConversion                     :1;
  unsigned32 ColorConversion                     :1;
  unsigned32 AlphaDestination                    :1;
  unsigned32 AlphaType                           :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 NoAlphaBuffer                       :1;
  unsigned32 ColorFormat                         :4;
  unsigned32 DestinationBlend                    :3;
  unsigned32 SourceBlend                         :4;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 SourceBlend                         :4;
  unsigned32 DestinationBlend                    :3;
  unsigned32 ColorFormat                         :4;
  unsigned32 NoAlphaBuffer                       :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 AlphaType                           :1;
  unsigned32 AlphaDestination                    :1;
  unsigned32 ColorConversion                     :1;
  unsigned32 AlphaConversion                     :1;
  unsigned32                                     :14;
#endif
#ifdef __cplusplus
  GlintAlphaBlendMode(void) { }
  GlintAlphaBlendMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GlintAlphaBlendMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GlintAlphaBlendMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GlintAlphaBlendMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<17|0x1<<16|0x1<<15|0x1<<14|0x1<<13|0x1<<12|0xf<<8|0x7<<5|0xf<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct PermediaAlphaBlendMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :13;
  unsigned32 AlphaConversion                     :1;
  unsigned32 ColorConversion                     :1;
  unsigned32 ColorFormatExtension                :1;
  unsigned32                                     :1;
  unsigned32 BlendType                           :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 NoAlphaBuffer                       :1;
  unsigned32 ColorFormat                         :4;
  unsigned32 Operation                           :7;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 Operation                           :7;
  unsigned32 ColorFormat                         :4;
  unsigned32 NoAlphaBuffer                       :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 BlendType                           :1;
  unsigned32                                     :1;
  unsigned32 ColorFormatExtension                :1;
  unsigned32 ColorConversion                     :1;
  unsigned32 AlphaConversion                     :1;
  unsigned32                                     :13;
#endif
#ifdef __cplusplus
  PermediaAlphaBlendMode(void) { }
  PermediaAlphaBlendMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PermediaAlphaBlendMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PermediaAlphaBlendMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PermediaAlphaBlendMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<18|0x1<<17|0x1<<16|0x1<<14|0x1<<13|0x1<<12|0xf<<8|0x7f<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct DitherMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :15;
  unsigned32 RoundingMode                        :2;
  unsigned32 AlphaDither                         :1;
  unsigned32                                     :3;
  unsigned32 ColorOrder                          :1;
  unsigned32 Yoffset                             :2;
  unsigned32 Xoffset                             :2;
  unsigned32 ColorFormat                         :4;
  unsigned32 DitherEnable                        :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 DitherEnable                        :1;
  unsigned32 ColorFormat                         :4;
  unsigned32 Xoffset                             :2;
  unsigned32 Yoffset                             :2;
  unsigned32 ColorOrder                          :1;
  unsigned32                                     :3;
  unsigned32 AlphaDither                         :1;
  unsigned32 RoundingMode                        :2;
  unsigned32                                     :15;
#endif
#ifdef __cplusplus
  DitherMode(void) { }
  DitherMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DitherMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DitherMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DitherMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<15|0x1<<14|0x1<<10|0x3<<8|0x3<<6|0xf<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct LogicalOpMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :19;
  unsigned32 OpaqueSpan                          :1;
  unsigned32 UseConstantSource                   :1;
  unsigned32 BackgroundLogicalOp                 :4;
  unsigned32 BackgroundEnable                    :1;
  unsigned32 UseConstantFBWriteData              :1;
  unsigned32 LogicOp                             :4;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 LogicOp                             :4;
  unsigned32 UseConstantFBWriteData              :1;
  unsigned32 BackgroundEnable                    :1;
  unsigned32 BackgroundLogicalOp                 :4;
  unsigned32 UseConstantSource                   :1;
  unsigned32 OpaqueSpan                          :1;
  unsigned32                                     :19;
#endif
#ifdef __cplusplus
  LogicalOpMode(void) { }
  LogicalOpMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LogicalOpMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LogicalOpMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LogicalOpMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<12|0x1<<11|0xf<<7|0x1<<6|0x1<<5|0xf<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct RouterMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :31;
  unsigned32 Order                               :1;
#else
  unsigned32 Order                               :1;
  unsigned32                                     :31;
#endif
#ifdef __cplusplus
  RouterMode(void) { }
  RouterMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  RouterMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  RouterMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  RouterMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<0)); }
#endif /* __cplusplus */
};

struct LBReadMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :4;
  unsigned32 PP3                                 :3;
  unsigned32 PatchCode                           :3;
  unsigned32 ScanlineInterval                    :2;
  unsigned32 Patch                               :1;
  unsigned32 WindowOrigin                        :1;
  unsigned32 DataType                            :2;
  unsigned32                                     :5;
  unsigned32 ReadDestinationEnable               :1;
  unsigned32 ReadSourceEnable                    :1;
  unsigned32 PP2                                 :3;
  unsigned32 PP1                                 :3;
  unsigned32 PP0                                 :3;
#else
  unsigned32 PP0                                 :3;
  unsigned32 PP1                                 :3;
  unsigned32 PP2                                 :3;
  unsigned32 ReadSourceEnable                    :1;
  unsigned32 ReadDestinationEnable               :1;
  unsigned32                                     :5;
  unsigned32 DataType                            :2;
  unsigned32 WindowOrigin                        :1;
  unsigned32 Patch                               :1;
  unsigned32 ScanlineInterval                    :2;
  unsigned32 PatchCode                           :3;
  unsigned32 PP3                                 :3;
  unsigned32                                     :4;
#endif
#ifdef __cplusplus
  LBReadMode(void) { }
  LBReadMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LBReadMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LBReadMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LBReadMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<25|0x7<<22|0x3<<20|0x1<<19|0x1<<18|0x3<<16|0x1<<10|0x1<<9|0x7<<6|0x7<<3|0x7<<0)); }
#endif /* __cplusplus */
};

struct GlintPermediaLBReadFormat {
#if BIG_ENDIAN == 1
  unsigned32                                     :14;
  unsigned32 Compact32                           :1;
  unsigned32 GIDPosition                         :4;
  unsigned32 GIDWidth                            :1;
  unsigned32 FrameCountPosition                  :3;
  unsigned32 FrameCountWidth                     :2;
  unsigned32 StencilPosition                     :3;
  unsigned32 StencilWidth                        :2;
  unsigned32 DepthWidth                          :2;
#else
  unsigned32 DepthWidth                          :2;
  unsigned32 StencilWidth                        :2;
  unsigned32 StencilPosition                     :3;
  unsigned32 FrameCountWidth                     :2;
  unsigned32 FrameCountPosition                  :3;
  unsigned32 GIDWidth                            :1;
  unsigned32 GIDPosition                         :4;
  unsigned32 Compact32                           :1;
  unsigned32                                     :14;
#endif
#ifdef __cplusplus
  GlintPermediaLBReadFormat(void) { }
  GlintPermediaLBReadFormat(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GlintPermediaLBReadFormat& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GlintPermediaLBReadFormat& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GlintPermediaLBReadFormat& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<17|0xf<<13|0x1<<12|0x7<<9|0x3<<7|0x7<<4|0x3<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct LBReadFormat {
#if BIG_ENDIAN == 1
  unsigned32                                     :4;
  unsigned32 GIDPosition                         :5;
  unsigned32 GIDWidth                            :3;
  unsigned32 FCPPosition                         :5;
  unsigned32 FCPWidth                            :4;
  unsigned32 StencilPosition                     :5;
  unsigned32 StencilWidth                        :4;
  unsigned32 DepthWidth                          :2;
#else
  unsigned32 DepthWidth                          :2;
  unsigned32 StencilWidth                        :4;
  unsigned32 StencilPosition                     :5;
  unsigned32 FCPWidth                            :4;
  unsigned32 FCPPosition                         :5;
  unsigned32 GIDWidth                            :3;
  unsigned32 GIDPosition                         :5;
  unsigned32                                     :4;
#endif
#ifdef __cplusplus
  LBReadFormat(void) { }
  LBReadFormat(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LBReadFormat& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LBReadFormat& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LBReadFormat& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1f<<23|0x7<<20|0x1f<<15|0xf<<11|0x1f<<6|0xf<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct LBSourceOffset {
#if BIG_ENDIAN == 1
  unsigned32                                     :8;
  unsigned32 Offset                              :24;
#else
  unsigned32 Offset                              :24;
  unsigned32                                     :8;
#endif
#ifdef __cplusplus
  LBSourceOffset(void) { }
  LBSourceOffset(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LBSourceOffset& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LBSourceOffset& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LBSourceOffset& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffffff<<0)); }
#endif /* __cplusplus */
};

struct LBWindowBase {
#if BIG_ENDIAN == 1
  unsigned32                                     :8;
  unsigned32 Base                                :24;
#else
  unsigned32 Base                                :24;
  unsigned32                                     :8;
#endif
#ifdef __cplusplus
  LBWindowBase(void) { }
  LBWindowBase(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LBWindowBase& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LBWindowBase& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LBWindowBase& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffffff<<0)); }
#endif /* __cplusplus */
};

struct P2MXLBWriteMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :29;
  unsigned32 UpLoadData                          :2;
  unsigned32 WriteEnable                         :1;
#else
  unsigned32 WriteEnable                         :1;
  unsigned32 UpLoadData                          :2;
  unsigned32                                     :29;
#endif
#ifdef __cplusplus
  P2MXLBWriteMode(void) { }
  P2MXLBWriteMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  P2MXLBWriteMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  P2MXLBWriteMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  P2MXLBWriteMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct LBWriteMode {
#if BIG_ENDIAN == 1
  unsigned32 Operation                           :3;
  unsigned32 ByteEnables                         :5;
  unsigned32 Width                               :12;
  unsigned32 Packed16                            :1;
  unsigned32 Origin                              :1;
  unsigned32 Layout                              :1;
  unsigned32 StripeHeight                        :3;
  unsigned32 StripePitch                         :3;
  unsigned32                                     :2;
  unsigned32 WriteEnable                         :1;
#else
  unsigned32 WriteEnable                         :1;
  unsigned32                                     :2;
  unsigned32 StripePitch                         :3;
  unsigned32 StripeHeight                        :3;
  unsigned32 Layout                              :1;
  unsigned32 Origin                              :1;
  unsigned32 Packed16                            :1;
  unsigned32 Width                               :12;
  unsigned32 ByteEnables                         :5;
  unsigned32 Operation                           :3;
#endif
#ifdef __cplusplus
  LBWriteMode(void) { }
  LBWriteMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LBWriteMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LBWriteMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LBWriteMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<29|0x1f<<24|0xfff<<12|0x1<<11|0x1<<10|0x1<<9|0x7<<6|0x7<<3|0x1<<0)); }
#endif /* __cplusplus */
};

struct LBWriteFormat {
#if BIG_ENDIAN == 1
  unsigned32                                     :4;
  unsigned32 GIDPosition                         :5;
  unsigned32 GIDWidth                            :3;
  unsigned32 FCPPosition                         :5;
  unsigned32 FCPWidth                            :4;
  unsigned32 StencilPosition                     :5;
  unsigned32 StencilWidth                        :4;
  unsigned32 DepthWidth                          :2;
#else
  unsigned32 DepthWidth                          :2;
  unsigned32 StencilWidth                        :4;
  unsigned32 StencilPosition                     :5;
  unsigned32 FCPWidth                            :4;
  unsigned32 FCPPosition                         :5;
  unsigned32 GIDWidth                            :3;
  unsigned32 GIDPosition                         :5;
  unsigned32                                     :4;
#endif
#ifdef __cplusplus
  LBWriteFormat(void) { }
  LBWriteFormat(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LBWriteFormat& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LBWriteFormat& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LBWriteFormat& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1f<<23|0x7<<20|0x1f<<15|0xf<<11|0x1f<<6|0xf<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct HostInState2 {
#if BIG_ENDIAN == 1
  unsigned32                                     :27;
  unsigned32 TagCount                            :5;
#else
  unsigned32 TagCount                            :5;
  unsigned32                                     :27;
#endif
#ifdef __cplusplus
  HostInState2(void) { }
  HostInState2(const unsigned32 i) { *((unsigned32 *)this) = i; }
  HostInState2& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  HostInState2& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  HostInState2& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1f<<0)); }
#endif /* __cplusplus */
};

struct VertexRename {
#if BIG_ENDIAN == 1
  unsigned32                                     :29;
  unsigned32 Rename                              :3;
#else
  unsigned32 Rename                              :3;
  unsigned32                                     :29;
#endif
#ifdef __cplusplus
  VertexRename(void) { }
  VertexRename(const unsigned32 i) { *((unsigned32 *)this) = i; }
  VertexRename& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  VertexRename& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  VertexRename& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<0)); }
#endif /* __cplusplus */
};

struct Window {
#if BIG_ENDIAN == 1
  unsigned32                                     :12;
  unsigned32 OverrideWriteFiltering              :1;
  unsigned32 DepthFCP                            :1;
  unsigned32 StencilFCP                          :1;
  unsigned32 FrameCount                          :8;
  unsigned32 GID                                 :4;
  unsigned32 LBUpdateSource                      :1;
  unsigned32 ForceLBUpdate                       :1;
  unsigned32 CompareMode                         :2;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 CompareMode                         :2;
  unsigned32 ForceLBUpdate                       :1;
  unsigned32 LBUpdateSource                      :1;
  unsigned32 GID                                 :4;
  unsigned32 FrameCount                          :8;
  unsigned32 StencilFCP                          :1;
  unsigned32 DepthFCP                            :1;
  unsigned32 OverrideWriteFiltering              :1;
  unsigned32                                     :12;
#endif
#ifdef __cplusplus
  Window(void) { }
  Window(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Window& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Window& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Window& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<19|0x1<<18|0x1<<17|0xff<<9|0xf<<5|0x1<<4|0x1<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct StencilMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :13;
  unsigned32 StencilWidth                        :4;
  unsigned32 StencilSource                       :2;
  unsigned32 CompareFunction                     :3;
  unsigned32 SFail                               :3;
  unsigned32 DPFail                              :3;
  unsigned32 DPPass                              :3;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 DPPass                              :3;
  unsigned32 DPFail                              :3;
  unsigned32 SFail                               :3;
  unsigned32 CompareFunction                     :3;
  unsigned32 StencilSource                       :2;
  unsigned32 StencilWidth                        :4;
  unsigned32                                     :13;
#endif
#ifdef __cplusplus
  StencilMode(void) { }
  StencilMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  StencilMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  StencilMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  StencilMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xf<<15|0x3<<13|0x7<<10|0x7<<7|0x7<<4|0x7<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct StencilData {
#if BIG_ENDIAN == 1
  unsigned32 FCStencil                           :8;
  unsigned32 StencilWriteMask                    :8;
  unsigned32 CompareMask                         :8;
  unsigned32 ReferenceValue                      :8;
#else
  unsigned32 ReferenceValue                      :8;
  unsigned32 CompareMask                         :8;
  unsigned32 StencilWriteMask                    :8;
  unsigned32 FCStencil                           :8;
#endif
#ifdef __cplusplus
  StencilData(void) { }
  StencilData(const unsigned32 i) { *((unsigned32 *)this) = i; }
  StencilData& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  StencilData& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  StencilData& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<24|0xff<<16|0xff<<8|0xff<<0)); }
#endif /* __cplusplus */
};

struct Stencil {
#if BIG_ENDIAN == 1
  unsigned32                                     :24;
  unsigned32 StencilValue                        :8;
#else
  unsigned32 StencilValue                        :8;
  unsigned32                                     :24;
#endif
#ifdef __cplusplus
  Stencil(void) { }
  Stencil(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Stencil& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Stencil& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Stencil& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<0)); }
#endif /* __cplusplus */
};

struct DepthMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :17;
  unsigned32 ExponentWidth                       :2;
  unsigned32 ExponentScale                       :2;
  unsigned32 NonLinearZ                          :1;
  unsigned32 Normalise                           :1;
  unsigned32 Width                               :2;
  unsigned32 CompareMode                         :3;
  unsigned32 NewDepthSource                      :2;
  unsigned32 WriteMask                           :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 WriteMask                           :1;
  unsigned32 NewDepthSource                      :2;
  unsigned32 CompareMode                         :3;
  unsigned32 Width                               :2;
  unsigned32 Normalise                           :1;
  unsigned32 NonLinearZ                          :1;
  unsigned32 ExponentScale                       :2;
  unsigned32 ExponentWidth                       :2;
  unsigned32                                     :17;
#endif
#ifdef __cplusplus
  DepthMode(void) { }
  DepthMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DepthMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DepthMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DepthMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<13|0x3<<11|0x1<<10|0x1<<9|0x3<<7|0x7<<4|0x3<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct GlintFBReadMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :2;
  unsigned32 SourceAddressFunction               :2;
  unsigned32 PP3                                 :3;
  unsigned32 ScanlineInterval                    :2;
  unsigned32                                     :6;
  unsigned32 WindowOrigin                        :1;
  unsigned32 DataType                            :1;
  unsigned32                                     :4;
  unsigned32 ReadDestinationEnable               :1;
  unsigned32 ReadSourceEnable                    :1;
  unsigned32 PP2                                 :3;
  unsigned32 PP1                                 :3;
  unsigned32 PP0                                 :3;
#else
  unsigned32 PP0                                 :3;
  unsigned32 PP1                                 :3;
  unsigned32 PP2                                 :3;
  unsigned32 ReadSourceEnable                    :1;
  unsigned32 ReadDestinationEnable               :1;
  unsigned32                                     :4;
  unsigned32 DataType                            :1;
  unsigned32 WindowOrigin                        :1;
  unsigned32                                     :6;
  unsigned32 ScanlineInterval                    :2;
  unsigned32 PP3                                 :3;
  unsigned32 SourceAddressFunction               :2;
  unsigned32                                     :2;
#endif
#ifdef __cplusplus
  GlintFBReadMode(void) { }
  GlintFBReadMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GlintFBReadMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GlintFBReadMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GlintFBReadMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<28|0x7<<25|0x3<<23|0x1<<16|0x1<<15|0x1<<10|0x1<<9|0x7<<6|0x7<<3|0x7<<0)); }
#endif /* __cplusplus */
};

struct PermediaFBReadMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :5;
  unsigned32 PatchMode                           :2;
  unsigned32                                     :2;
  unsigned32 RelativeOffset                      :3;
  unsigned32 PackedData                          :1;
  unsigned32 PatchEnable                         :1;
  unsigned32                                     :1;
  unsigned32 WindowOrigin                        :1;
  unsigned32 DataType                            :1;
  unsigned32                                     :4;
  unsigned32 ReadDestinationEnable               :1;
  unsigned32 ReadSourceEnable                    :1;
  unsigned32 PP2                                 :3;
  unsigned32 PP1                                 :3;
  unsigned32 PP0                                 :3;
#else
  unsigned32 PP0                                 :3;
  unsigned32 PP1                                 :3;
  unsigned32 PP2                                 :3;
  unsigned32 ReadSourceEnable                    :1;
  unsigned32 ReadDestinationEnable               :1;
  unsigned32                                     :4;
  unsigned32 DataType                            :1;
  unsigned32 WindowOrigin                        :1;
  unsigned32                                     :1;
  unsigned32 PatchEnable                         :1;
  unsigned32 PackedData                          :1;
  unsigned32 RelativeOffset                      :3;
  unsigned32                                     :2;
  unsigned32 PatchMode                           :2;
  unsigned32                                     :5;
#endif
#ifdef __cplusplus
  PermediaFBReadMode(void) { }
  PermediaFBReadMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PermediaFBReadMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PermediaFBReadMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PermediaFBReadMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<25|0x7<<20|0x1<<19|0x1<<18|0x1<<16|0x1<<15|0x1<<10|0x1<<9|0x7<<6|0x7<<3|0x7<<0)); }
#endif /* __cplusplus */
};

struct FBSourceOffset {
#if BIG_ENDIAN == 1
  unsigned32                                     :8;
  unsigned32 Offset                              :24;
#else
  unsigned32 Offset                              :24;
  unsigned32                                     :8;
#endif
#ifdef __cplusplus
  FBSourceOffset(void) { }
  FBSourceOffset(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBSourceOffset& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBSourceOffset& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBSourceOffset& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffffff<<0)); }
#endif /* __cplusplus */
};

struct FBPixelOffset {
#if BIG_ENDIAN == 1
  unsigned32                                     :8;
  unsigned32 Offset                              :24;
#else
  unsigned32 Offset                              :24;
  unsigned32                                     :8;
#endif
#ifdef __cplusplus
  FBPixelOffset(void) { }
  FBPixelOffset(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBPixelOffset& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBPixelOffset& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBPixelOffset& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffffff<<0)); }
#endif /* __cplusplus */
};

struct FBWindowBase {
#if BIG_ENDIAN == 1
  unsigned32                                     :8;
  unsigned32 Address                             :24;
#else
  unsigned32 Address                             :24;
  unsigned32                                     :8;
#endif
#ifdef __cplusplus
  FBWindowBase(void) { }
  FBWindowBase(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBWindowBase& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBWindowBase& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBWindowBase& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffffff<<0)); }
#endif /* __cplusplus */
};

struct FBWriteMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :4;
  unsigned32 Origin3                             :1;
  unsigned32 Origin2                             :1;
  unsigned32 Origin1                             :1;
  unsigned32 Origin0                             :1;
  unsigned32 Layout3                             :2;
  unsigned32 Layout2                             :2;
  unsigned32 Layout1                             :2;
  unsigned32 Layout0                             :2;
  unsigned32 Enable3                             :1;
  unsigned32 Enable2                             :1;
  unsigned32 Enable1                             :1;
  unsigned32 Enable0                             :1;
  unsigned32 StripeHeight                        :3;
  unsigned32 StripePitch                         :3;
  unsigned32 OpaqueSpan                          :1;
  unsigned32 Replicate                           :1;
  unsigned32 UpLoadData                          :1;
  unsigned32                                     :2;
  unsigned32 WriteEnable                         :1;
#else
  unsigned32 WriteEnable                         :1;
  unsigned32                                     :2;
  unsigned32 UpLoadData                          :1;
  unsigned32 Replicate                           :1;
  unsigned32 OpaqueSpan                          :1;
  unsigned32 StripePitch                         :3;
  unsigned32 StripeHeight                        :3;
  unsigned32 Enable0                             :1;
  unsigned32 Enable1                             :1;
  unsigned32 Enable2                             :1;
  unsigned32 Enable3                             :1;
  unsigned32 Layout0                             :2;
  unsigned32 Layout1                             :2;
  unsigned32 Layout2                             :2;
  unsigned32 Layout3                             :2;
  unsigned32 Origin0                             :1;
  unsigned32 Origin1                             :1;
  unsigned32 Origin2                             :1;
  unsigned32 Origin3                             :1;
  unsigned32                                     :4;
#endif
#ifdef __cplusplus
  FBWriteMode(void) { }
  FBWriteMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBWriteMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBWriteMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBWriteMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<27|0x1<<26|0x1<<25|0x1<<24|0x3<<22|0x3<<20|0x3<<18|0x3<<16|0x1<<15|0x1<<14|0x1<<13|0x1<<12|0x7<<9|0x7<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<0)); }
#endif /* __cplusplus */
};

struct FBReadPixel {
#if BIG_ENDIAN == 1
  unsigned32                                     :29;
  unsigned32 PixelSize                           :3;
#else
  unsigned32 PixelSize                           :3;
  unsigned32                                     :29;
#endif
#ifdef __cplusplus
  FBReadPixel(void) { }
  FBReadPixel(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBReadPixel& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBReadPixel& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBReadPixel& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<0)); }
#endif /* __cplusplus */
};

struct PatternRAMMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :18;
  unsigned32 XMask                               :5;
  unsigned32 YShift                              :3;
  unsigned32 YMask                               :5;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 YMask                               :5;
  unsigned32 YShift                              :3;
  unsigned32 XMask                               :5;
  unsigned32                                     :18;
#endif
#ifdef __cplusplus
  PatternRAMMode(void) { }
  PatternRAMMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PatternRAMMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PatternRAMMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PatternRAMMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1f<<9|0x7<<6|0x1f<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct FilterMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :10;
  unsigned32 ExternalDMAController               :1;
  unsigned32 RunLengthEncodeData                 :1;
  unsigned32 Context                             :2;
  unsigned32 ByteSwap                            :2;
  unsigned32 Remainder                           :2;
  unsigned32 Statistics                          :2;
  unsigned32 Sync                                :2;
  unsigned32 FBColor                             :2;
  unsigned32 Stencil                             :2;
  unsigned32 LBDepth                             :2;
  unsigned32 Passive                             :2;
  unsigned32 Active                              :2;
#else
  unsigned32 Active                              :2;
  unsigned32 Passive                             :2;
  unsigned32 LBDepth                             :2;
  unsigned32 Stencil                             :2;
  unsigned32 FBColor                             :2;
  unsigned32 Sync                                :2;
  unsigned32 Statistics                          :2;
  unsigned32 Remainder                           :2;
  unsigned32 ByteSwap                            :2;
  unsigned32 Context                             :2;
  unsigned32 RunLengthEncodeData                 :1;
  unsigned32 ExternalDMAController               :1;
  unsigned32                                     :10;
#endif
#ifdef __cplusplus
  FilterMode(void) { }
  FilterMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FilterMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FilterMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FilterMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<21|0x1<<20|0x3<<18|0x3<<16|0x3<<14|0x3<<12|0x3<<10|0x3<<8|0x3<<6|0x3<<4|0x3<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct StatisticMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :26;
  unsigned32 Spans                               :1;
  unsigned32 CompareFunction                     :1;
  unsigned32 PassiveSteps                        :1;
  unsigned32 ActiveSteps                         :1;
  unsigned32 StatsType                           :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 StatsType                           :1;
  unsigned32 ActiveSteps                         :1;
  unsigned32 PassiveSteps                        :1;
  unsigned32 CompareFunction                     :1;
  unsigned32 Spans                               :1;
  unsigned32                                     :26;
#endif
#ifdef __cplusplus
  StatisticMode(void) { }
  StatisticMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  StatisticMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  StatisticMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  StatisticMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct PickResult {
#if BIG_ENDIAN == 1
  unsigned32                                     :31;
  unsigned32 Result                              :1;
#else
  unsigned32 Result                              :1;
  unsigned32                                     :31;
#endif
#ifdef __cplusplus
  PickResult(void) { }
  PickResult(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PickResult& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PickResult& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PickResult& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<0)); }
#endif /* __cplusplus */
};

struct ContextMask {
#if BIG_ENDIAN == 1
  unsigned32                                     :12;
  unsigned32 MatrixStack                         :1;
  unsigned32 PipeControl                         :1;
  unsigned32 MultiTexture                        :1;
  unsigned32 TextureManagementState              :1;
  unsigned32 LUT                                 :1;
  unsigned32 FogTable                            :1;
  unsigned32 Ownership                           :1;
  unsigned32 DDA                                 :1;
  unsigned32 RasterizerState                     :1;
  unsigned32 Select                              :1;
  unsigned32 DMA                                 :1;
  unsigned32 TwoD                                :1;
  unsigned32 CurrentState                        :1;
  unsigned32 RasterPos                           :1;
  unsigned32 Lights8_15                          :1;
  unsigned32 Lights0_7                           :1;
  unsigned32 Material                            :1;
  unsigned32 Matrices                            :1;
  unsigned32 Geometry                            :1;
  unsigned32 GeneralControl                      :1;
#else
  unsigned32 GeneralControl                      :1;
  unsigned32 Geometry                            :1;
  unsigned32 Matrices                            :1;
  unsigned32 Material                            :1;
  unsigned32 Lights0_7                           :1;
  unsigned32 Lights8_15                          :1;
  unsigned32 RasterPos                           :1;
  unsigned32 CurrentState                        :1;
  unsigned32 TwoD                                :1;
  unsigned32 DMA                                 :1;
  unsigned32 Select                              :1;
  unsigned32 RasterizerState                     :1;
  unsigned32 DDA                                 :1;
  unsigned32 Ownership                           :1;
  unsigned32 FogTable                            :1;
  unsigned32 LUT                                 :1;
  unsigned32 TextureManagementState              :1;
  unsigned32 MultiTexture                        :1;
  unsigned32 PipeControl                         :1;
  unsigned32 MatrixStack                         :1;
  unsigned32                                     :12;
#endif
#ifdef __cplusplus
  ContextMask(void) { }
  ContextMask(const unsigned32 i) { *((unsigned32 *)this) = i; }
  ContextMask& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  ContextMask& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  ContextMask& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<19|0x1<<18|0x1<<17|0x1<<16|0x1<<15|0x1<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct YUVMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :26;
  unsigned32 TexelDisableUpdate                  :1;
  unsigned32 RejectTexel                         :1;
  unsigned32 TestData                            :1;
  unsigned32 TestMode                            :2;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 TestMode                            :2;
  unsigned32 TestData                            :1;
  unsigned32 RejectTexel                         :1;
  unsigned32 TexelDisableUpdate                  :1;
  unsigned32                                     :26;
#endif
#ifdef __cplusplus
  YUVMode(void) { }
  YUVMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  YUVMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  YUVMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  YUVMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<5|0x1<<4|0x1<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct GlintChromaTestMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :28;
  unsigned32 Sense                               :1;
  unsigned32 Source                              :2;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 Source                              :2;
  unsigned32 Sense                               :1;
  unsigned32                                     :28;
#endif
#ifdef __cplusplus
  GlintChromaTestMode(void) { }
  GlintChromaTestMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GlintChromaTestMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GlintChromaTestMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GlintChromaTestMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct ChromaTestMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :25;
  unsigned32 FailAction                          :2;
  unsigned32 PassAction                          :2;
  unsigned32 Source                              :2;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 Source                              :2;
  unsigned32 PassAction                          :2;
  unsigned32 FailAction                          :2;
  unsigned32                                     :25;
#endif
#ifdef __cplusplus
  ChromaTestMode(void) { }
  ChromaTestMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  ChromaTestMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  ChromaTestMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  ChromaTestMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<5|0x3<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct SelectRecord {
#if BIG_ENDIAN == 1
  unsigned32 StackOverflow                       :1;
  unsigned32 StackUnderflow                      :1;
  unsigned32 InvalidOperation                    :1;
  unsigned32                                     :22;
  unsigned32 Count                               :7;
#else
  unsigned32 Count                               :7;
  unsigned32                                     :22;
  unsigned32 InvalidOperation                    :1;
  unsigned32 StackUnderflow                      :1;
  unsigned32 StackOverflow                       :1;
#endif
#ifdef __cplusplus
  SelectRecord(void) { }
  SelectRecord(const unsigned32 i) { *((unsigned32 *)this) = i; }
  SelectRecord& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  SelectRecord& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  SelectRecord& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x1<<30|0x1<<29|0x7f<<0)); }
#endif /* __cplusplus */
};

struct GMDeltaMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :6;
  unsigned32 EpilogueCount                       :2;
  unsigned32 EpilogueEnable                      :1;
  unsigned32 FlatShadingMethod                   :1;
  unsigned32 ColorSpecular                       :1;
  unsigned32 ColorDiffuse                        :1;
  unsigned32 BiasCoordinates                     :1;
  unsigned32                                     :3;
  unsigned32 TextureParameterMode                :2;
  unsigned32 ClampEnable                         :1;
  unsigned32 NoDraw                              :1;
  unsigned32 DiamondExit                         :1;
  unsigned32 SubPixelCorrectionEnable            :1;
  unsigned32 DiffuseTextureEnable                :1;
  unsigned32 SpecularTextureEnable               :1;
  unsigned32 DepthEnable                         :1;
  unsigned32 SmoothShadingEnable                 :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 FogEnable                           :1;
  unsigned32 DepthFormat                         :2;
  unsigned32 TargetChip                          :2;
#else
  unsigned32 TargetChip                          :2;
  unsigned32 DepthFormat                         :2;
  unsigned32 FogEnable                           :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 SmoothShadingEnable                 :1;
  unsigned32 DepthEnable                         :1;
  unsigned32 SpecularTextureEnable               :1;
  unsigned32 DiffuseTextureEnable                :1;
  unsigned32 SubPixelCorrectionEnable            :1;
  unsigned32 DiamondExit                         :1;
  unsigned32 NoDraw                              :1;
  unsigned32 ClampEnable                         :1;
  unsigned32 TextureParameterMode                :2;
  unsigned32                                     :3;
  unsigned32 BiasCoordinates                     :1;
  unsigned32 ColorDiffuse                        :1;
  unsigned32 ColorSpecular                       :1;
  unsigned32 FlatShadingMethod                   :1;
  unsigned32 EpilogueEnable                      :1;
  unsigned32 EpilogueCount                       :2;
  unsigned32                                     :6;
#endif
#ifdef __cplusplus
  GMDeltaMode(void) { }
  GMDeltaMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GMDeltaMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GMDeltaMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GMDeltaMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<24|0x1<<23|0x1<<22|0x1<<21|0x1<<20|0x1<<19|0x3<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0x3<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct RXDeltaMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :5;
  unsigned32 TextureEnable1                      :1;
  unsigned32                                     :5;
  unsigned32 Texture3DEnable                     :1;
  unsigned32 BiasCoordinates                     :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 BackfaceCull                        :1;
  unsigned32 FillDirection                       :1;
  unsigned32 TextureParameterMode                :2;
  unsigned32 ClampEnable                         :1;
  unsigned32 NoDraw                              :1;
  unsigned32 DiamondExit                         :1;
  unsigned32 SubPixelCorrectionEnable            :1;
  unsigned32 DiffuseTextureEnable                :1;
  unsigned32 SpecularTextureEnable               :1;
  unsigned32 DepthEnable                         :1;
  unsigned32 SmoothShadingEnable                 :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 FogEnable                           :1;
  unsigned32 DepthFormat                         :2;
  unsigned32                                     :2;
#else
  unsigned32                                     :2;
  unsigned32 DepthFormat                         :2;
  unsigned32 FogEnable                           :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 SmoothShadingEnable                 :1;
  unsigned32 DepthEnable                         :1;
  unsigned32 SpecularTextureEnable               :1;
  unsigned32 DiffuseTextureEnable                :1;
  unsigned32 SubPixelCorrectionEnable            :1;
  unsigned32 DiamondExit                         :1;
  unsigned32 NoDraw                              :1;
  unsigned32 ClampEnable                         :1;
  unsigned32 TextureParameterMode                :2;
  unsigned32 FillDirection                       :1;
  unsigned32 BackfaceCull                        :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 BiasCoordinates                     :1;
  unsigned32 Texture3DEnable                     :1;
  unsigned32                                     :5;
  unsigned32 TextureEnable1                      :1;
  unsigned32                                     :5;
#endif
#ifdef __cplusplus
  RXDeltaMode(void) { }
  RXDeltaMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  RXDeltaMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  RXDeltaMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  RXDeltaMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<26|0x1<<20|0x1<<19|0x1<<18|0x1<<17|0x1<<16|0x3<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0x3<<2)); }
#endif /* __cplusplus */
};

struct P3DeltaMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :2;
  unsigned32 Texture3DEnable                     :1;
  unsigned32                                     :1;
  unsigned32                                     :1;
  unsigned32 TextureEnable1                      :1;
  unsigned32                                     :6;
  unsigned32 BiasCoordinates                     :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 BackfaceCull                        :1;
  unsigned32 FillDirection                       :1;
  unsigned32 TextureParameterMode                :2;
  unsigned32 ClampEnable                         :1;
  unsigned32 NoDraw                              :1;
  unsigned32 DiamondExit                         :1;
  unsigned32 SubPixelCorrectionEnable            :1;
  unsigned32 DiffuseTextureEnable                :1;
  unsigned32 SpecularTextureEnable               :1;
  unsigned32 DepthEnable                         :1;
  unsigned32 SmoothShadingEnable                 :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 FogEnable                           :1;
  unsigned32 DepthFormat                         :2;
  unsigned32 TargetChip                          :2;
#else
  unsigned32 TargetChip                          :2;
  unsigned32 DepthFormat                         :2;
  unsigned32 FogEnable                           :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 SmoothShadingEnable                 :1;
  unsigned32 DepthEnable                         :1;
  unsigned32 SpecularTextureEnable               :1;
  unsigned32 DiffuseTextureEnable                :1;
  unsigned32 SubPixelCorrectionEnable            :1;
  unsigned32 DiamondExit                         :1;
  unsigned32 NoDraw                              :1;
  unsigned32 ClampEnable                         :1;
  unsigned32 TextureParameterMode                :2;
  unsigned32 FillDirection                       :1;
  unsigned32 BackfaceCull                        :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 BiasCoordinates                     :1;
  unsigned32                                     :6;
  unsigned32 TextureEnable1                      :1;
  unsigned32                                     :1;
  unsigned32                                     :1;
  unsigned32 Texture3DEnable                     :1;
  unsigned32                                     :2;
#endif
#ifdef __cplusplus
  P3DeltaMode(void) { }
  P3DeltaMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  P3DeltaMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  P3DeltaMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  P3DeltaMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<29|0x1<<26|0x1<<19|0x1<<18|0x1<<17|0x1<<16|0x3<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0x3<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct DeltaDraw {
#if BIG_ENDIAN == 1
  unsigned32                                     :14;
  unsigned32 RejectNegativeFace                  :1;
  unsigned32 SubPixelCorrectionEnable            :1;
  unsigned32                                     :1;
  unsigned32 FogEnable                           :1;
  unsigned32 TextureEnable                       :1;
  unsigned32                                     :3;
  unsigned32 AntialiasingQuality                 :1;
  unsigned32 AntialiasEnable                     :1;
  unsigned32                                     :8;
#else
  unsigned32                                     :8;
  unsigned32 AntialiasEnable                     :1;
  unsigned32 AntialiasingQuality                 :1;
  unsigned32                                     :3;
  unsigned32 TextureEnable                       :1;
  unsigned32 FogEnable                           :1;
  unsigned32                                     :1;
  unsigned32 SubPixelCorrectionEnable            :1;
  unsigned32 RejectNegativeFace                  :1;
  unsigned32                                     :14;
#endif
#ifdef __cplusplus
  DeltaDraw(void) { }
  DeltaDraw(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DeltaDraw& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DeltaDraw& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DeltaDraw& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<17|0x1<<16|0x1<<14|0x1<<13|0x1<<9|0x1<<8)); }
#endif /* __cplusplus */
};

struct DeltaControl {
#if BIG_ENDIAN == 1
  unsigned32                                     :17;
  unsigned32 ShareColor                          :1;
  unsigned32 ShareT                              :1;
  unsigned32 ShareS                              :1;
  unsigned32 Line2D                              :1;
  unsigned32 ShareQ                              :1;
  unsigned32                                     :3;
  unsigned32 UseProvokingVertex                  :1;
  unsigned32                                     :1;
  unsigned32 ForceQ                              :1;
  unsigned32 DrawLineEndPoint                    :1;
  unsigned32 FullScreenAA                        :1;
  unsigned32                                     :2;
#else
  unsigned32                                     :2;
  unsigned32 FullScreenAA                        :1;
  unsigned32 DrawLineEndPoint                    :1;
  unsigned32 ForceQ                              :1;
  unsigned32                                     :1;
  unsigned32 UseProvokingVertex                  :1;
  unsigned32                                     :3;
  unsigned32 ShareQ                              :1;
  unsigned32 Line2D                              :1;
  unsigned32 ShareS                              :1;
  unsigned32 ShareT                              :1;
  unsigned32 ShareColor                          :1;
  unsigned32                                     :17;
#endif
#ifdef __cplusplus
  DeltaControl(void) { }
  DeltaControl(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DeltaControl& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DeltaControl& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DeltaControl& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<6|0x1<<4|0x1<<3|0x1<<2)); }
#endif /* __cplusplus */
};

struct DeltaProvokingVertexMask {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 KdB                                 :1;
  unsigned32 KdG                                 :1;
  unsigned32 KdR                                 :1;
  unsigned32                                     :1;
  unsigned32 KsB                                 :1;
  unsigned32 KsG                                 :1;
  unsigned32 KsR                                 :1;
  unsigned32                                     :1;
  unsigned32 A                                   :1;
  unsigned32 B                                   :1;
  unsigned32 G                                   :1;
  unsigned32 R                                   :1;
#else
  unsigned32 R                                   :1;
  unsigned32 G                                   :1;
  unsigned32 B                                   :1;
  unsigned32 A                                   :1;
  unsigned32                                     :1;
  unsigned32 KsR                                 :1;
  unsigned32 KsG                                 :1;
  unsigned32 KsB                                 :1;
  unsigned32                                     :1;
  unsigned32 KdR                                 :1;
  unsigned32 KdG                                 :1;
  unsigned32 KdB                                 :1;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  DeltaProvokingVertexMask(void) { }
  DeltaProvokingVertexMask(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DeltaProvokingVertexMask& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DeltaProvokingVertexMask& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DeltaProvokingVertexMask& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<11|0x1<<10|0x1<<9|0x1<<7|0x1<<6|0x1<<5|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct ProvokingVertex {
#if BIG_ENDIAN == 1
  unsigned32                                     :30;
  unsigned32 Vertex                              :2;
#else
  unsigned32 Vertex                              :2;
  unsigned32                                     :30;
#endif
#ifdef __cplusplus
  ProvokingVertex(void) { }
  ProvokingVertex(const unsigned32 i) { *((unsigned32 *)this) = i; }
  ProvokingVertex& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  ProvokingVertex& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  ProvokingVertex& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<0)); }
#endif /* __cplusplus */
};

struct EpilogTag {
#if BIG_ENDIAN == 1
  unsigned32                                     :21;
  unsigned32 Tag                                 :11;
#else
  unsigned32 Tag                                 :11;
  unsigned32                                     :21;
#endif
#ifdef __cplusplus
  EpilogTag(void) { }
  EpilogTag(const unsigned32 i) { *((unsigned32 *)this) = i; }
  EpilogTag& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  EpilogTag& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  EpilogTag& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7ff<<0)); }
#endif /* __cplusplus */
};

struct PointMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :30;
  unsigned32 AntialiasQuality                    :1;
  unsigned32 AntialiasEnable                     :1;
#else
  unsigned32 AntialiasEnable                     :1;
  unsigned32 AntialiasQuality                    :1;
  unsigned32                                     :30;
#endif
#ifdef __cplusplus
  PointMode(void) { }
  PointMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PointMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PointMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PointMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct PointSize {
#if BIG_ENDIAN == 1
  unsigned32                                     :24;
  unsigned32 Size                                :8;
#else
  unsigned32 Size                                :8;
  unsigned32                                     :24;
#endif
#ifdef __cplusplus
  PointSize(void) { }
  PointSize(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PointSize& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PointSize& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PointSize& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<0)); }
#endif /* __cplusplus */
};

struct LineMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :3;
  unsigned32 AntialiasQuality                    :1;
  unsigned32 AntialiasEnable                     :1;
  unsigned32 Mirror                              :1;
  unsigned32 StippleMask                         :16;
  unsigned32 RepeatFactor                        :9;
  unsigned32 StippleEnable                       :1;
#else
  unsigned32 StippleEnable                       :1;
  unsigned32 RepeatFactor                        :9;
  unsigned32 StippleMask                         :16;
  unsigned32 Mirror                              :1;
  unsigned32 AntialiasEnable                     :1;
  unsigned32 AntialiasQuality                    :1;
  unsigned32                                     :3;
#endif
#ifdef __cplusplus
  LineMode(void) { }
  LineMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LineMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LineMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LineMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<28|0x1<<27|0x1<<26|0xffff<<10|0x1ff<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct LineWidth {
#if BIG_ENDIAN == 1
  unsigned32                                     :24;
  unsigned32 Width                               :8;
#else
  unsigned32 Width                               :8;
  unsigned32                                     :24;
#endif
#ifdef __cplusplus
  LineWidth(void) { }
  LineWidth(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LineWidth& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LineWidth& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LineWidth& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<0)); }
#endif /* __cplusplus */
};

struct LineWidthOffset {
#if BIG_ENDIAN == 1
  unsigned32                                     :24;
  unsigned32 Offset                              :8;
#else
  unsigned32 Offset                              :8;
  unsigned32                                     :24;
#endif
#ifdef __cplusplus
  LineWidthOffset(void) { }
  LineWidthOffset(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LineWidthOffset& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LineWidthOffset& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LineWidthOffset& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<0)); }
#endif /* __cplusplus */
};

struct AALineWidth {
#if BIG_ENDIAN == 1
  unsigned32 Width                               :32;
#else
  unsigned32 Width                               :32;
#endif
#ifdef __cplusplus
  AALineWidth(void) { }
  AALineWidth(const unsigned32 i) { *((unsigned32 *)this) = i; }
  AALineWidth& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  AALineWidth& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  AALineWidth& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffffffff<<0)); }
#endif /* __cplusplus */
};

struct TriangleMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :29;
  unsigned32 UseTrianglePacketInterface          :1;
  unsigned32 AntialiasQuality                    :1;
  unsigned32 AntialiasEnable                     :1;
#else
  unsigned32 AntialiasEnable                     :1;
  unsigned32 AntialiasQuality                    :1;
  unsigned32 UseTrianglePacketInterface          :1;
  unsigned32                                     :29;
#endif
#ifdef __cplusplus
  TriangleMode(void) { }
  TriangleMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TriangleMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TriangleMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TriangleMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct Rectangle2DMode {
#if BIG_ENDIAN == 1
  unsigned32 VerticalDirection                   :1;
  unsigned32 HorizontalDirection                 :1;
  unsigned32 SpanOperation                       :1;
  unsigned32 FogEnable                           :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 SyncOnHostData                      :1;
  unsigned32 SyncOnBitmask                       :1;
  unsigned32 AreaStippleEnable                   :1;
  unsigned32 Height                              :12;
  unsigned32 Width                               :12;
#else
  unsigned32 Width                               :12;
  unsigned32 Height                              :12;
  unsigned32 AreaStippleEnable                   :1;
  unsigned32 SyncOnBitmask                       :1;
  unsigned32 SyncOnHostData                      :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 FogEnable                           :1;
  unsigned32 SpanOperation                       :1;
  unsigned32 HorizontalDirection                 :1;
  unsigned32 VerticalDirection                   :1;
#endif
#ifdef __cplusplus
  Rectangle2DMode(void) { }
  Rectangle2DMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Rectangle2DMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Rectangle2DMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Rectangle2DMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x1<<30|0x1<<29|0x1<<28|0x1<<27|0x1<<26|0x1<<25|0x1<<24|0xfff<<12|0xfff<<0)); }
#endif /* __cplusplus */
};

struct Rectangle2DControl {
#if BIG_ENDIAN == 1
  unsigned32                                     :31;
  unsigned32 WindowClipping                      :1;
#else
  unsigned32 WindowClipping                      :1;
  unsigned32                                     :31;
#endif
#ifdef __cplusplus
  Rectangle2DControl(void) { }
  Rectangle2DControl(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Rectangle2DControl& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Rectangle2DControl& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Rectangle2DControl& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<0)); }
#endif /* __cplusplus */
};

struct VertexMachineMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :29;
  unsigned32 D3DProvokingVertex                  :1;
  unsigned32 ObjectIDPerPrimitive                :1;
  unsigned32 ObjectTagEnable                     :1;
#else
  unsigned32 ObjectTagEnable                     :1;
  unsigned32 ObjectIDPerPrimitive                :1;
  unsigned32 D3DProvokingVertex                  :1;
  unsigned32                                     :29;
#endif
#ifdef __cplusplus
  VertexMachineMode(void) { }
  VertexMachineMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  VertexMachineMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  VertexMachineMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  VertexMachineMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TransformMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :14;
  unsigned32 BlendVertex                         :1;
  unsigned32 TexGenQ                             :1;
  unsigned32 TexGenR                             :1;
  unsigned32 TexGenT                             :1;
  unsigned32 TexGenS                             :1;
  unsigned32 TexGenModeQ                         :2;
  unsigned32 TexGenModeR                         :2;
  unsigned32 TexGenModeT                         :2;
  unsigned32 TexGenModeS                         :2;
  unsigned32 TransformTexture                    :1;
  unsigned32 TransformFaceNormal                 :1;
  unsigned32 TransformNormal                     :1;
  unsigned32 UseModelViewProjectionMatrix        :1;
  unsigned32 UseModelViewMatrix                  :1;
#else
  unsigned32 UseModelViewMatrix                  :1;
  unsigned32 UseModelViewProjectionMatrix        :1;
  unsigned32 TransformNormal                     :1;
  unsigned32 TransformFaceNormal                 :1;
  unsigned32 TransformTexture                    :1;
  unsigned32 TexGenModeS                         :2;
  unsigned32 TexGenModeT                         :2;
  unsigned32 TexGenModeR                         :2;
  unsigned32 TexGenModeQ                         :2;
  unsigned32 TexGenS                             :1;
  unsigned32 TexGenT                             :1;
  unsigned32 TexGenR                             :1;
  unsigned32 TexGenQ                             :1;
  unsigned32 BlendVertex                         :1;
  unsigned32                                     :14;
#endif
#ifdef __cplusplus
  TransformMode(void) { }
  TransformMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TransformMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TransformMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TransformMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<17|0x1<<16|0x1<<15|0x1<<14|0x1<<13|0x3<<11|0x3<<9|0x3<<7|0x3<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct GeometryMode {
#if BIG_ENDIAN == 1
  unsigned32 InvertFaceNormalCullDirection       :1;
  unsigned32 PolygonOffsetFill                   :1;
  unsigned32 PolygonOffsetLine                   :1;
  unsigned32 PolygonOffsetPoint                  :1;
  unsigned32 UserClipMask                        :6;
  unsigned32 FlatShading                         :1;
  unsigned32 AutoGenerateFaceNormal              :1;
  unsigned32 CullUsingFaceNormal                 :1;
  unsigned32 FeedbackType                        :3;
  unsigned32 RenderMode                          :2;
  unsigned32 ClipSmallTriangles                  :1;
  unsigned32 ClipShortLines                      :1;
  unsigned32 PolygonCullFace                     :2;
  unsigned32 PolygonCull                         :1;
  unsigned32 FrontFaceDirection                  :1;
  unsigned32 BackPolyMode                        :2;
  unsigned32 FrontPolyMode                       :2;
  unsigned32 FogFunction                         :2;
  unsigned32 FogEnable                           :1;
  unsigned32 TextureEnable                       :1;
#else
  unsigned32 TextureEnable                       :1;
  unsigned32 FogEnable                           :1;
  unsigned32 FogFunction                         :2;
  unsigned32 FrontPolyMode                       :2;
  unsigned32 BackPolyMode                        :2;
  unsigned32 FrontFaceDirection                  :1;
  unsigned32 PolygonCull                         :1;
  unsigned32 PolygonCullFace                     :2;
  unsigned32 ClipShortLines                      :1;
  unsigned32 ClipSmallTriangles                  :1;
  unsigned32 RenderMode                          :2;
  unsigned32 FeedbackType                        :3;
  unsigned32 CullUsingFaceNormal                 :1;
  unsigned32 AutoGenerateFaceNormal              :1;
  unsigned32 FlatShading                         :1;
  unsigned32 UserClipMask                        :6;
  unsigned32 PolygonOffsetPoint                  :1;
  unsigned32 PolygonOffsetLine                   :1;
  unsigned32 PolygonOffsetFill                   :1;
  unsigned32 InvertFaceNormalCullDirection       :1;
#endif
#ifdef __cplusplus
  GeometryMode(void) { }
  GeometryMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GeometryMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GeometryMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GeometryMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x1<<30|0x1<<29|0x1<<28|0x3f<<22|0x1<<21|0x1<<20|0x1<<19|0x7<<16|0x3<<14|0x1<<13|0x1<<12|0x3<<10|0x1<<9|0x1<<8|0x3<<6|0x3<<4|0x3<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct Gamma3GeometryMode {
#if BIG_ENDIAN == 1
  unsigned32 InvertFaceNormalCullDirection       :1;
  unsigned32 PolygonOffsetFill                   :1;
  unsigned32 PolygonOffsetLine                   :1;
  unsigned32 PolygonOffsetPoint                  :1;
  unsigned32 UserClipMask                        :6;
  unsigned32 FlatShading                         :1;
  unsigned32 DisableFustumCulling                :1;
  unsigned32 CullUsingFaceNormal                 :1;
  unsigned32 FeedbackType                        :3;
  unsigned32 RenderMode                          :2;
  unsigned32 ClipSmallTriangles                  :1;
  unsigned32 ClipShortLines                      :1;
  unsigned32 PolygonCullFace                     :2;
  unsigned32 PolygonCull                         :1;
  unsigned32 FrontFaceDirection                  :1;
  unsigned32 BackPolyMode                        :2;
  unsigned32 FrontPolyMode                       :2;
  unsigned32 OrthographicProjection              :1;
  unsigned32 UserInvW                            :1;
  unsigned32                                     :1;
  unsigned32 SendInvW                            :1;
#else
  unsigned32 SendInvW                            :1;
  unsigned32                                     :1;
  unsigned32 UserInvW                            :1;
  unsigned32 OrthographicProjection              :1;
  unsigned32 FrontPolyMode                       :2;
  unsigned32 BackPolyMode                        :2;
  unsigned32 FrontFaceDirection                  :1;
  unsigned32 PolygonCull                         :1;
  unsigned32 PolygonCullFace                     :2;
  unsigned32 ClipShortLines                      :1;
  unsigned32 ClipSmallTriangles                  :1;
  unsigned32 RenderMode                          :2;
  unsigned32 FeedbackType                        :3;
  unsigned32 CullUsingFaceNormal                 :1;
  unsigned32 DisableFustumCulling                :1;
  unsigned32 FlatShading                         :1;
  unsigned32 UserClipMask                        :6;
  unsigned32 PolygonOffsetPoint                  :1;
  unsigned32 PolygonOffsetLine                   :1;
  unsigned32 PolygonOffsetFill                   :1;
  unsigned32 InvertFaceNormalCullDirection       :1;
#endif
#ifdef __cplusplus
  Gamma3GeometryMode(void) { }
  Gamma3GeometryMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Gamma3GeometryMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Gamma3GeometryMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Gamma3GeometryMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x1<<30|0x1<<29|0x1<<28|0x3f<<22|0x1<<21|0x1<<20|0x1<<19|0x7<<16|0x3<<14|0x1<<13|0x1<<12|0x3<<10|0x1<<9|0x1<<8|0x3<<6|0x3<<4|0x1<<3|0x1<<2|0x1<<0)); }
#endif /* __cplusplus */
};

struct NormaliseMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :25;
  unsigned32 BlendNormal                         :1;
  unsigned32 NormaliseSpotDirection              :1;
  unsigned32 NormaliseLightPosition              :1;
  unsigned32 AntialiasLine                       :1;
  unsigned32 InvertAutoFaceNormal                :1;
  unsigned32 FaceNormalEnable                    :1;
  unsigned32 NormalEnable                        :1;
#else
  unsigned32 NormalEnable                        :1;
  unsigned32 FaceNormalEnable                    :1;
  unsigned32 InvertAutoFaceNormal                :1;
  unsigned32 AntialiasLine                       :1;
  unsigned32 NormaliseLightPosition              :1;
  unsigned32 NormaliseSpotDirection              :1;
  unsigned32 BlendNormal                         :1;
  unsigned32                                     :25;
#endif
#ifdef __cplusplus
  NormaliseMode(void) { }
  NormaliseMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  NormaliseMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  NormaliseMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  NormaliseMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct LightingMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :14;
  unsigned32 D3DEyeDirection                     :1;
  unsigned32 UseFaceNormal                       :1;
  unsigned32 SpecularLightingEnable              :1;
  unsigned32 NumberLights                        :9;
  unsigned32 AttenuationTest                     :1;
  unsigned32 FlipNormal                          :1;
  unsigned32 LocalViewer                         :1;
  unsigned32 TwoSidedLighting                    :2;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 TwoSidedLighting                    :2;
  unsigned32 LocalViewer                         :1;
  unsigned32 FlipNormal                          :1;
  unsigned32 AttenuationTest                     :1;
  unsigned32 NumberLights                        :9;
  unsigned32 SpecularLightingEnable              :1;
  unsigned32 UseFaceNormal                       :1;
  unsigned32 D3DEyeDirection                     :1;
  unsigned32                                     :14;
#endif
#ifdef __cplusplus
  LightingMode(void) { }
  LightingMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LightingMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LightingMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LightingMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<17|0x1<<16|0x1<<15|0x1ff<<6|0x1<<5|0x1<<4|0x1<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct ColorMaterialMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :6;
  unsigned32 BackAlphaSource                     :2;
  unsigned32 BackSpecularSource                  :2;
  unsigned32 BackDiffuseSource                   :2;
  unsigned32 BackAmbientSource                   :2;
  unsigned32 BackEmissiveSource                  :2;
  unsigned32 FrontAlphaSource                    :2;
  unsigned32 FrontSpecularSource                 :2;
  unsigned32 FrontDiffuseSource                  :2;
  unsigned32 FrontAmbientSource                  :2;
  unsigned32 FrontEmissiveSource                 :2;
  unsigned32 Parameter                           :3;
  unsigned32 Face                                :2;
  unsigned32 ColorMaterialEnable                 :1;
#else
  unsigned32 ColorMaterialEnable                 :1;
  unsigned32 Face                                :2;
  unsigned32 Parameter                           :3;
  unsigned32 FrontEmissiveSource                 :2;
  unsigned32 FrontAmbientSource                  :2;
  unsigned32 FrontDiffuseSource                  :2;
  unsigned32 FrontSpecularSource                 :2;
  unsigned32 FrontAlphaSource                    :2;
  unsigned32 BackEmissiveSource                  :2;
  unsigned32 BackAmbientSource                   :2;
  unsigned32 BackDiffuseSource                   :2;
  unsigned32 BackSpecularSource                  :2;
  unsigned32 BackAlphaSource                     :2;
  unsigned32                                     :6;
#endif
#ifdef __cplusplus
  ColorMaterialMode(void) { }
  ColorMaterialMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  ColorMaterialMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  ColorMaterialMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  ColorMaterialMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<24|0x3<<22|0x3<<20|0x3<<18|0x3<<16|0x3<<14|0x3<<12|0x3<<10|0x3<<8|0x3<<6|0x7<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct MaterialMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :9;
  unsigned32 ColorDisable                        :1;
  unsigned32 AlphaSource                         :2;
  unsigned32 SpecularTextureSource               :2;
  unsigned32 DiffuseTextureSource                :2;
  unsigned32 ColorSource2Bit                     :2;
  unsigned32 SendColorC                          :1;
  unsigned32 SendColorB                          :1;
  unsigned32 SendColorA                          :1;
  unsigned32 SendNormal                          :1;
  unsigned32 SpecularColor                       :1;
  unsigned32 TwoSidedLighting                    :2;
  unsigned32 ColorSource                         :1;
  unsigned32 PremultiplyAlpha                    :1;
  unsigned32 MonochromeSpecularTexture           :1;
  unsigned32 MonochromeDiffuseTexture            :1;
  unsigned32 SpecularTextureEnable               :1;
  unsigned32 DiffuseTextureEnable                :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 DiffuseTextureEnable                :1;
  unsigned32 SpecularTextureEnable               :1;
  unsigned32 MonochromeDiffuseTexture            :1;
  unsigned32 MonochromeSpecularTexture           :1;
  unsigned32 PremultiplyAlpha                    :1;
  unsigned32 ColorSource                         :1;
  unsigned32 TwoSidedLighting                    :2;
  unsigned32 SpecularColor                       :1;
  unsigned32 SendNormal                          :1;
  unsigned32 SendColorA                          :1;
  unsigned32 SendColorB                          :1;
  unsigned32 SendColorC                          :1;
  unsigned32 ColorSource2Bit                     :2;
  unsigned32 DiffuseTextureSource                :2;
  unsigned32 SpecularTextureSource               :2;
  unsigned32 AlphaSource                         :2;
  unsigned32 ColorDisable                        :1;
  unsigned32                                     :9;
#endif
#ifdef __cplusplus
  MaterialMode(void) { }
  MaterialMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  MaterialMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  MaterialMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  MaterialMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<22|0x3<<20|0x3<<18|0x3<<16|0x3<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x3<<7|0x1<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct FogVertexMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :26;
  unsigned32 Source                              :2;
  unsigned32 Function                            :2;
  unsigned32                                     :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32                                     :1;
  unsigned32 Function                            :2;
  unsigned32 Source                              :2;
  unsigned32                                     :26;
#endif
#ifdef __cplusplus
  FogVertexMode(void) { }
  FogVertexMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FogVertexMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FogVertexMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FogVertexMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<4|0x3<<2|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :3;
  unsigned32 UserInvW                            :1;
  unsigned32 R4D3DWrappingT                      :1;
  unsigned32 R4D3DWrappingS                      :1;
  unsigned32 R4Operation                         :2;
  unsigned32 FeedbackEnable                      :1;
  unsigned32 WhichMatrix                         :3;
  unsigned32 WhichTexGen                         :3;
  unsigned32 WhichCurrentTextureCoord            :3;
  unsigned32 TexGenQ                             :1;
  unsigned32 TexGenR                             :1;
  unsigned32 TexGenT                             :1;
  unsigned32 TexGenS                             :1;
  unsigned32 TexGenModeQ                         :2;
  unsigned32 TexGenModeR                         :2;
  unsigned32 TexGenModeT                         :2;
  unsigned32 TexGenModeS                         :2;
  unsigned32 TransformEnable                     :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 TransformEnable                     :1;
  unsigned32 TexGenModeS                         :2;
  unsigned32 TexGenModeT                         :2;
  unsigned32 TexGenModeR                         :2;
  unsigned32 TexGenModeQ                         :2;
  unsigned32 TexGenS                             :1;
  unsigned32 TexGenT                             :1;
  unsigned32 TexGenR                             :1;
  unsigned32 TexGenQ                             :1;
  unsigned32 WhichCurrentTextureCoord            :3;
  unsigned32 WhichTexGen                         :3;
  unsigned32 WhichMatrix                         :3;
  unsigned32 FeedbackEnable                      :1;
  unsigned32 R4Operation                         :2;
  unsigned32 R4D3DWrappingS                      :1;
  unsigned32 R4D3DWrappingT                      :1;
  unsigned32 UserInvW                            :1;
  unsigned32                                     :3;
#endif
#ifdef __cplusplus
  TextureMode(void) { }
  TextureMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<28|0x1<<27|0x1<<26|0x3<<24|0x1<<23|0x7<<20|0x7<<17|0x7<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x3<<8|0x3<<6|0x3<<4|0x3<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct StripeFilterMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :13;
  unsigned32 NumberRasterisers                   :2;
  unsigned32 StripeHeight                        :3;
  unsigned32 BiasCoordinates                     :1;
  unsigned32 RejectZeroHeightTriangles           :1;
  unsigned32 AATriangleQuality                   :1;
  unsigned32 AATriangleEnable                    :1;
  unsigned32 FilterAATriangles                   :1;
  unsigned32 FilterTriangles                     :1;
  unsigned32 AALineQuality                       :1;
  unsigned32 AALineEnable                        :1;
  unsigned32 FilterAALines                       :1;
  unsigned32 FilterLines                         :1;
  unsigned32 AAPointQuality                      :1;
  unsigned32 AAPointEnable                       :1;
  unsigned32 FilterAAPoints                      :1;
  unsigned32 FilterPoints                        :1;
#else
  unsigned32 FilterPoints                        :1;
  unsigned32 FilterAAPoints                      :1;
  unsigned32 AAPointEnable                       :1;
  unsigned32 AAPointQuality                      :1;
  unsigned32 FilterLines                         :1;
  unsigned32 FilterAALines                       :1;
  unsigned32 AALineEnable                        :1;
  unsigned32 AALineQuality                       :1;
  unsigned32 FilterTriangles                     :1;
  unsigned32 FilterAATriangles                   :1;
  unsigned32 AATriangleEnable                    :1;
  unsigned32 AATriangleQuality                   :1;
  unsigned32 RejectZeroHeightTriangles           :1;
  unsigned32 BiasCoordinates                     :1;
  unsigned32 StripeHeight                        :3;
  unsigned32 NumberRasterisers                   :2;
  unsigned32                                     :13;
#endif
#ifdef __cplusplus
  StripeFilterMode(void) { }
  StripeFilterMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  StripeFilterMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  StripeFilterMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  StripeFilterMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<17|0x7<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct MatrixMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :23;
  unsigned32 BoundingVolumeTestEnable            :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 BoundingBoxTestEnable               :1;
  unsigned32 TransformSpotLightDirection         :1;
  unsigned32 TransformLightPosition              :1;
  unsigned32 TransformUserClip                   :1;
  unsigned32 CalculateModelViewProjMatrix        :1;
  unsigned32 CalculateModelViewMatrix            :1;
  unsigned32 SeparateModelViewMatrices           :1;
#else
  unsigned32 SeparateModelViewMatrices           :1;
  unsigned32 CalculateModelViewMatrix            :1;
  unsigned32 CalculateModelViewProjMatrix        :1;
  unsigned32 TransformUserClip                   :1;
  unsigned32 TransformLightPosition              :1;
  unsigned32 TransformSpotLightDirection         :1;
  unsigned32 BoundingBoxTestEnable               :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 BoundingVolumeTestEnable            :1;
  unsigned32                                     :23;
#endif
#ifdef __cplusplus
  MatrixMode(void) { }
  MatrixMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  MatrixMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  MatrixMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  MatrixMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct RenderMode {
#if BIG_ENDIAN == 1
  unsigned32 Type                                :4;
  unsigned32 FBSourceReadEnable                  :1;
  unsigned32                                     :7;
  unsigned32 FrontFacing                         :1;
  unsigned32 SpanOperation                       :1;
  unsigned32 RejectNegativeFace                  :1;
  unsigned32 SubpixelCorrectionEnable            :1;
  unsigned32 CoverageEnable                      :1;
  unsigned32 FogEnable                           :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 SyncOnHostData                      :1;
  unsigned32 SyncOnBitMask                       :1;
  unsigned32 UsePointTable                       :1;
  unsigned32 AntialiasingQuality                 :1;
  unsigned32 AntialiasEnable                     :1;
  unsigned32 PrimitiveType                       :2;
  unsigned32                                     :2;
  unsigned32 FastFillEnable                      :1;
  unsigned32 ResetLineStipple                    :1;
  unsigned32 LineStippleEnable                   :1;
  unsigned32 AreaStippleEnable                   :1;
#else
  unsigned32 AreaStippleEnable                   :1;
  unsigned32 LineStippleEnable                   :1;
  unsigned32 ResetLineStipple                    :1;
  unsigned32 FastFillEnable                      :1;
  unsigned32                                     :2;
  unsigned32 PrimitiveType                       :2;
  unsigned32 AntialiasEnable                     :1;
  unsigned32 AntialiasingQuality                 :1;
  unsigned32 UsePointTable                       :1;
  unsigned32 SyncOnBitMask                       :1;
  unsigned32 SyncOnHostData                      :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 FogEnable                           :1;
  unsigned32 CoverageEnable                      :1;
  unsigned32 SubpixelCorrectionEnable            :1;
  unsigned32 RejectNegativeFace                  :1;
  unsigned32 SpanOperation                       :1;
  unsigned32 FrontFacing                         :1;
  unsigned32                                     :7;
  unsigned32 FBSourceReadEnable                  :1;
  unsigned32 Type                                :4;
#endif
#ifdef __cplusplus
  RenderMode(void) { }
  RenderMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  RenderMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  RenderMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  RenderMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xf<<28|0x1<<27|0x1<<19|0x1<<18|0x1<<17|0x1<<16|0x1<<15|0x1<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x3<<6|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct EdgeFlag {
#if BIG_ENDIAN == 1
  unsigned32                                     :31;
  unsigned32 Flag                                :1;
#else
  unsigned32 Flag                                :1;
  unsigned32                                     :31;
#endif
#ifdef __cplusplus
  EdgeFlag(void) { }
  EdgeFlag(const unsigned32 i) { *((unsigned32 *)this) = i; }
  EdgeFlag& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  EdgeFlag& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  EdgeFlag& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<0)); }
#endif /* __cplusplus */
};

struct TransformCurrent {
#if BIG_ENDIAN == 1
  unsigned32                                     :28;
  unsigned32 Color                               :1;
  unsigned32 Texture                             :1;
  unsigned32 FaceNormal                          :1;
  unsigned32 Normal                              :1;
#else
  unsigned32 Normal                              :1;
  unsigned32 FaceNormal                          :1;
  unsigned32 Texture                             :1;
  unsigned32 Color                               :1;
  unsigned32                                     :28;
#endif
#ifdef __cplusplus
  TransformCurrent(void) { }
  TransformCurrent(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TransformCurrent& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TransformCurrent& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TransformCurrent& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct PushName {
#if BIG_ENDIAN == 1
  unsigned32 StackOverflow                       :1;
  unsigned32 StackUnderflow                      :1;
  unsigned32 InvalidOperation                    :1;
  unsigned32                                     :22;
  unsigned32 Count                               :7;
#else
  unsigned32 Count                               :7;
  unsigned32                                     :22;
  unsigned32 InvalidOperation                    :1;
  unsigned32 StackUnderflow                      :1;
  unsigned32 StackOverflow                       :1;
#endif
#ifdef __cplusplus
  PushName(void) { }
  PushName(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PushName& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PushName& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PushName& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x1<<30|0x1<<29|0x7f<<0)); }
#endif /* __cplusplus */
};

struct PopName {
#if BIG_ENDIAN == 1
  unsigned32 StackOverflow                       :1;
  unsigned32 StackUnderflow                      :1;
  unsigned32 InvalidOperation                    :1;
  unsigned32                                     :22;
  unsigned32 Count                               :7;
#else
  unsigned32 Count                               :7;
  unsigned32                                     :22;
  unsigned32 InvalidOperation                    :1;
  unsigned32 StackUnderflow                      :1;
  unsigned32 StackOverflow                       :1;
#endif
#ifdef __cplusplus
  PopName(void) { }
  PopName(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PopName& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PopName& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PopName& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x1<<30|0x1<<29|0x7f<<0)); }
#endif /* __cplusplus */
};

struct LoadName {
#if BIG_ENDIAN == 1
  unsigned32 StackOverflow                       :1;
  unsigned32 StackUnderflow                      :1;
  unsigned32 InvalidOperation                    :1;
  unsigned32                                     :22;
  unsigned32 Count                               :7;
#else
  unsigned32 Count                               :7;
  unsigned32                                     :22;
  unsigned32 InvalidOperation                    :1;
  unsigned32 StackUnderflow                      :1;
  unsigned32 StackOverflow                       :1;
#endif
#ifdef __cplusplus
  LoadName(void) { }
  LoadName(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LoadName& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LoadName& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LoadName& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x1<<30|0x1<<29|0x7f<<0)); }
#endif /* __cplusplus */
};

struct GeomPoint {
#if BIG_ENDIAN == 1
  unsigned32                                     :23;
  unsigned32 EdgeA                               :1;
  unsigned32                                     :6;
  unsigned32 A                                   :2;
#else
  unsigned32 A                                   :2;
  unsigned32                                     :6;
  unsigned32 EdgeA                               :1;
  unsigned32                                     :23;
#endif
#ifdef __cplusplus
  GeomPoint(void) { }
  GeomPoint(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GeomPoint& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GeomPoint& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GeomPoint& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<8|0x3<<0)); }
#endif /* __cplusplus */
};

struct GeomLine {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 ResetLineStipple                    :1;
  unsigned32                                     :1;
  unsigned32 EdgeB                               :1;
  unsigned32 EdgeA                               :1;
  unsigned32 ProvokingVertex                     :2;
  unsigned32                                     :2;
  unsigned32 B                                   :2;
  unsigned32 A                                   :2;
#else
  unsigned32 A                                   :2;
  unsigned32 B                                   :2;
  unsigned32                                     :2;
  unsigned32 ProvokingVertex                     :2;
  unsigned32 EdgeA                               :1;
  unsigned32 EdgeB                               :1;
  unsigned32                                     :1;
  unsigned32 ResetLineStipple                    :1;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  GeomLine(void) { }
  GeomLine(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GeomLine& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GeomLine& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GeomLine& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<11|0x1<<9|0x1<<8|0x3<<6|0x3<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct GeomTriangle {
#if BIG_ENDIAN == 1
  unsigned32                                     :14;
  unsigned32 FrontFacing                         :1;
  unsigned32 SubstituteEdgeC                     :1;
  unsigned32 SubstituteEdgeB                     :1;
  unsigned32 SubstituteEdgeA                     :1;
  unsigned32 Last                                :1;
  unsigned32                                     :1;
  unsigned32 ResetLineStipple                    :1;
  unsigned32 EdgeC                               :1;
  unsigned32 EdgeB                               :1;
  unsigned32 EdgeA                               :1;
  unsigned32 ProvokingVertex                     :2;
  unsigned32 C                                   :2;
  unsigned32 B                                   :2;
  unsigned32 A                                   :2;
#else
  unsigned32 A                                   :2;
  unsigned32 B                                   :2;
  unsigned32 C                                   :2;
  unsigned32 ProvokingVertex                     :2;
  unsigned32 EdgeA                               :1;
  unsigned32 EdgeB                               :1;
  unsigned32 EdgeC                               :1;
  unsigned32 ResetLineStipple                    :1;
  unsigned32                                     :1;
  unsigned32 Last                                :1;
  unsigned32 SubstituteEdgeA                     :1;
  unsigned32 SubstituteEdgeB                     :1;
  unsigned32 SubstituteEdgeC                     :1;
  unsigned32 FrontFacing                         :1;
  unsigned32                                     :14;
#endif
#ifdef __cplusplus
  GeomTriangle(void) { }
  GeomTriangle(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GeomTriangle& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GeomTriangle& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GeomTriangle& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<17|0x1<<16|0x1<<15|0x1<<14|0x1<<13|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x3<<6|0x3<<4|0x3<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct GeomRectangle {
#if BIG_ENDIAN == 1
  unsigned32                                     :28;
  unsigned32 SelectEnable                        :1;
  unsigned32 OffsetEnable                        :1;
  unsigned32 Type                                :2;
#else
  unsigned32 Type                                :2;
  unsigned32 OffsetEnable                        :1;
  unsigned32 SelectEnable                        :1;
  unsigned32                                     :28;
#endif
#ifdef __cplusplus
  GeomRectangle(void) { }
  GeomRectangle(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GeomRectangle& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GeomRectangle& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GeomRectangle& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<3|0x1<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct ClippedColor {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 UseProvokingVertex                  :1;
  unsigned32 Destination                         :2;
  unsigned32 C                                   :2;
  unsigned32 B                                   :2;
  unsigned32 A                                   :2;
  unsigned32 ProvokingVertex                     :2;
  unsigned32 FrontFacing                         :1;
#else
  unsigned32 FrontFacing                         :1;
  unsigned32 ProvokingVertex                     :2;
  unsigned32 A                                   :2;
  unsigned32 B                                   :2;
  unsigned32 C                                   :2;
  unsigned32 Destination                         :2;
  unsigned32 UseProvokingVertex                  :1;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  ClippedColor(void) { }
  ClippedColor(const unsigned32 i) { *((unsigned32 *)this) = i; }
  ClippedColor& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  ClippedColor& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  ClippedColor& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<11|0x3<<9|0x3<<7|0x3<<5|0x3<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct RenderPrim {
#if BIG_ENDIAN == 1
  unsigned32                                     :21;
  unsigned32 UseProvokingVertex                  :1;
  unsigned32 FrontFacing                         :1;
  unsigned32 ResetLineStipple                    :1;
  unsigned32 ProvokingVertex                     :2;
  unsigned32 C                                   :2;
  unsigned32 B                                   :2;
  unsigned32 A                                   :2;
#else
  unsigned32 A                                   :2;
  unsigned32 B                                   :2;
  unsigned32 C                                   :2;
  unsigned32 ProvokingVertex                     :2;
  unsigned32 ResetLineStipple                    :1;
  unsigned32 FrontFacing                         :1;
  unsigned32 UseProvokingVertex                  :1;
  unsigned32                                     :21;
#endif
#ifdef __cplusplus
  RenderPrim(void) { }
  RenderPrim(const unsigned32 i) { *((unsigned32 *)this) = i; }
  RenderPrim& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  RenderPrim& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  RenderPrim& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<10|0x1<<9|0x1<<8|0x3<<6|0x3<<4|0x3<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct PackedNormal {
#if BIG_ENDIAN == 1
  unsigned32 Code                                :2;
  unsigned32 Z                                   :10;
  unsigned32 Y                                   :10;
  unsigned32 X                                   :10;
#else
  unsigned32 X                                   :10;
  unsigned32 Y                                   :10;
  unsigned32 Z                                   :10;
  unsigned32 Code                                :2;
#endif
#ifdef __cplusplus
  PackedNormal(void) { }
  PackedNormal(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PackedNormal& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PackedNormal& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PackedNormal& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<30|0x3ff<<20|0x3ff<<10|0x3ff<<0)); }
#endif /* __cplusplus */
};

struct LightMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :28;
  unsigned32 LocalLight                          :1;
  unsigned32 Attenuation                         :1;
  unsigned32 Spotlight                           :1;
  unsigned32 LightOn                             :1;
#else
  unsigned32 LightOn                             :1;
  unsigned32 Spotlight                           :1;
  unsigned32 Attenuation                         :1;
  unsigned32 LocalLight                          :1;
  unsigned32                                     :28;
#endif
#ifdef __cplusplus
  LightMode(void) { }
  LightMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LightMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LightMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LightMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct DMAAddr {
#if BIG_ENDIAN == 1
  unsigned32 Address                             :30;
  unsigned32                                     :2;
#else
  unsigned32                                     :2;
  unsigned32 Address                             :30;
#endif
#ifdef __cplusplus
  DMAAddr(void) { }
  DMAAddr(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DMAAddr& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DMAAddr& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DMAAddr& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3fffffff<<2)); }
#endif /* __cplusplus */
};

struct CommandInterrupt {
#if BIG_ENDIAN == 1
  unsigned32                                     :31;
  unsigned32 OutputDMA                           :1;
#else
  unsigned32 OutputDMA                           :1;
  unsigned32                                     :31;
#endif
#ifdef __cplusplus
  CommandInterrupt(void) { }
  CommandInterrupt(const unsigned32 i) { *((unsigned32 *)this) = i; }
  CommandInterrupt& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  CommandInterrupt& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  CommandInterrupt& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<0)); }
#endif /* __cplusplus */
};

struct DMARectangleRead {
#if BIG_ENDIAN == 1
  unsigned32 Alignment                           :2;
  unsigned32                                     :1;
  unsigned32 ByteSwap                            :2;
  unsigned32 PackOut                             :1;
  unsigned32 PixelSize                           :2;
  unsigned32 Height                              :12;
  unsigned32 Width                               :12;
#else
  unsigned32 Width                               :12;
  unsigned32 Height                              :12;
  unsigned32 PixelSize                           :2;
  unsigned32 PackOut                             :1;
  unsigned32 ByteSwap                            :2;
  unsigned32                                     :1;
  unsigned32 Alignment                           :2;
#endif
#ifdef __cplusplus
  DMARectangleRead(void) { }
  DMARectangleRead(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DMARectangleRead& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DMARectangleRead& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DMARectangleRead& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<30|0x3<<27|0x1<<26|0x3<<24|0xfff<<12|0xfff<<0)); }
#endif /* __cplusplus */
};

struct DMARectangleReadLinePitch {
#if BIG_ENDIAN == 1
  unsigned32 LinePitch                           :32;
#else
  unsigned32 LinePitch                           :32;
#endif
#ifdef __cplusplus
  DMARectangleReadLinePitch(void) { }
  DMARectangleReadLinePitch(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DMARectangleReadLinePitch& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DMARectangleReadLinePitch& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DMARectangleReadLinePitch& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffffffff<<0)); }
#endif /* __cplusplus */
};

struct DMARectangleReadTarget {
#if BIG_ENDIAN == 1
  unsigned32                                     :21;
  unsigned32 Tag                                 :11;
#else
  unsigned32 Tag                                 :11;
  unsigned32                                     :21;
#endif
#ifdef __cplusplus
  DMARectangleReadTarget(void) { }
  DMARectangleReadTarget(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DMARectangleReadTarget& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DMARectangleReadTarget& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DMARectangleReadTarget& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7ff<<0)); }
#endif /* __cplusplus */
};

struct DMARectangleWrite {
#if BIG_ENDIAN == 1
  unsigned32 Alignment                           :2;
  unsigned32                                     :1;
  unsigned32 ByteSwap                            :2;
  unsigned32 PackOut                             :1;
  unsigned32 PixelSize                           :2;
  unsigned32 Height                              :12;
  unsigned32 Width                               :12;
#else
  unsigned32 Width                               :12;
  unsigned32 Height                              :12;
  unsigned32 PixelSize                           :2;
  unsigned32 PackOut                             :1;
  unsigned32 ByteSwap                            :2;
  unsigned32                                     :1;
  unsigned32 Alignment                           :2;
#endif
#ifdef __cplusplus
  DMARectangleWrite(void) { }
  DMARectangleWrite(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DMARectangleWrite& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DMARectangleWrite& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DMARectangleWrite& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<30|0x3<<27|0x1<<26|0x3<<24|0xfff<<12|0xfff<<0)); }
#endif /* __cplusplus */
};

struct DMARectangleWriteLinePitch {
#if BIG_ENDIAN == 1
  unsigned32 LinePitch                           :32;
#else
  unsigned32 LinePitch                           :32;
#endif
#ifdef __cplusplus
  DMARectangleWriteLinePitch(void) { }
  DMARectangleWriteLinePitch(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DMARectangleWriteLinePitch& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DMARectangleWriteLinePitch& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DMARectangleWriteLinePitch& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffffffff<<0)); }
#endif /* __cplusplus */
};

struct DMAOutputAddress {
#if BIG_ENDIAN == 1
  unsigned32 Address                             :30;
  unsigned32                                     :2;
#else
  unsigned32                                     :2;
  unsigned32 Address                             :30;
#endif
#ifdef __cplusplus
  DMAOutputAddress(void) { }
  DMAOutputAddress(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DMAOutputAddress& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DMAOutputAddress& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DMAOutputAddress& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3fffffff<<2)); }
#endif /* __cplusplus */
};

struct VertexArray {
#if BIG_ENDIAN == 1
  unsigned32                                     :18;
  unsigned32 OpenGLProvokingVertex               :1;
  unsigned32 D3DTriangleEdgeFlags                :1;
  unsigned32 InlineFaceNormalData                :1;
  unsigned32 InlineVertexData                    :1;
  unsigned32 InlineIndices                       :1;
  unsigned32 FaceNormalPresent                   :1;
  unsigned32 EdgeFlagPresent                     :1;
  unsigned32 TextureFormat                       :2;
  unsigned32 ColorFormat                         :2;
  unsigned32 NormalPresent                       :1;
  unsigned32 CoordinateFormat                    :2;
#else
  unsigned32 CoordinateFormat                    :2;
  unsigned32 NormalPresent                       :1;
  unsigned32 ColorFormat                         :2;
  unsigned32 TextureFormat                       :2;
  unsigned32 EdgeFlagPresent                     :1;
  unsigned32 FaceNormalPresent                   :1;
  unsigned32 InlineIndices                       :1;
  unsigned32 InlineVertexData                    :1;
  unsigned32 InlineFaceNormalData                :1;
  unsigned32 D3DTriangleEdgeFlags                :1;
  unsigned32 OpenGLProvokingVertex               :1;
  unsigned32                                     :18;
#endif
#ifdef __cplusplus
  VertexArray(void) { }
  VertexArray(const unsigned32 i) { *((unsigned32 *)this) = i; }
  VertexArray& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  VertexArray& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  VertexArray& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x3<<5|0x3<<3|0x1<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct FBDestReadBufferWidth {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 Width                               :12;
#else
  unsigned32 Width                               :12;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  FBDestReadBufferWidth(void) { }
  FBDestReadBufferWidth(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBDestReadBufferWidth& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBDestReadBufferWidth& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBDestReadBufferWidth& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xfff<<0)); }
#endif /* __cplusplus */
};

struct FBDestReadMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :4;
  unsigned32 AlphaFiltering                      :1;
  unsigned32 UseReadEnables                      :1;
  unsigned32 PCIMappingEnable                    :1;
  unsigned32 Blocking                            :1;
  unsigned32 Origin3                             :1;
  unsigned32 Origin2                             :1;
  unsigned32 Origin1                             :1;
  unsigned32 Origin0                             :1;
  unsigned32 Layout3                             :2;
  unsigned32 Layout2                             :2;
  unsigned32 Layout1                             :2;
  unsigned32 Layout0                             :2;
  unsigned32 Enable3                             :1;
  unsigned32 Enable2                             :1;
  unsigned32 Enable1                             :1;
  unsigned32 Enable0                             :1;
  unsigned32 StripeHeight                        :3;
  unsigned32 StripePitch                         :3;
  unsigned32 PrefetchEnable                      :1;
  unsigned32 ReadEnable                          :1;
#else
  unsigned32 ReadEnable                          :1;
  unsigned32 PrefetchEnable                      :1;
  unsigned32 StripePitch                         :3;
  unsigned32 StripeHeight                        :3;
  unsigned32 Enable0                             :1;
  unsigned32 Enable1                             :1;
  unsigned32 Enable2                             :1;
  unsigned32 Enable3                             :1;
  unsigned32 Layout0                             :2;
  unsigned32 Layout1                             :2;
  unsigned32 Layout2                             :2;
  unsigned32 Layout3                             :2;
  unsigned32 Origin0                             :1;
  unsigned32 Origin1                             :1;
  unsigned32 Origin2                             :1;
  unsigned32 Origin3                             :1;
  unsigned32 Blocking                            :1;
  unsigned32 PCIMappingEnable                    :1;
  unsigned32 UseReadEnables                      :1;
  unsigned32 AlphaFiltering                      :1;
  unsigned32                                     :4;
#endif
#ifdef __cplusplus
  FBDestReadMode(void) { }
  FBDestReadMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBDestReadMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBDestReadMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBDestReadMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<27|0x1<<26|0x1<<25|0x1<<24|0x1<<23|0x1<<22|0x1<<21|0x1<<20|0x3<<18|0x3<<16|0x3<<14|0x3<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x7<<5|0x7<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct FBDestReadEnables {
#if BIG_ENDIAN == 1
  unsigned32 ReferenceAlpha                      :8;
  unsigned32                                     :8;
  unsigned32 R7                                  :1;
  unsigned32 R6                                  :1;
  unsigned32 R5                                  :1;
  unsigned32 R4                                  :1;
  unsigned32 R3                                  :1;
  unsigned32 R2                                  :1;
  unsigned32 R1                                  :1;
  unsigned32 R0                                  :1;
  unsigned32 E7                                  :1;
  unsigned32 E6                                  :1;
  unsigned32 E5                                  :1;
  unsigned32 E4                                  :1;
  unsigned32 E3                                  :1;
  unsigned32 E2                                  :1;
  unsigned32 E1                                  :1;
  unsigned32 E0                                  :1;
#else
  unsigned32 E0                                  :1;
  unsigned32 E1                                  :1;
  unsigned32 E2                                  :1;
  unsigned32 E3                                  :1;
  unsigned32 E4                                  :1;
  unsigned32 E5                                  :1;
  unsigned32 E6                                  :1;
  unsigned32 E7                                  :1;
  unsigned32 R0                                  :1;
  unsigned32 R1                                  :1;
  unsigned32 R2                                  :1;
  unsigned32 R3                                  :1;
  unsigned32 R4                                  :1;
  unsigned32 R5                                  :1;
  unsigned32 R6                                  :1;
  unsigned32 R7                                  :1;
  unsigned32                                     :8;
  unsigned32 ReferenceAlpha                      :8;
#endif
#ifdef __cplusplus
  FBDestReadEnables(void) { }
  FBDestReadEnables(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBDestReadEnables& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBDestReadEnables& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBDestReadEnables& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<24|0x1<<15|0x1<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct FBSourceReadMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :7;
  unsigned32 ExternalSourceData                  :1;
  unsigned32 WrapY                               :4;
  unsigned32 WrapX                               :4;
  unsigned32 WrapYEnable                         :1;
  unsigned32 WrapXEnable                         :1;
  unsigned32 UseTexelCoord                       :1;
  unsigned32 PCIMappingEnable                    :1;
  unsigned32 Blocking                            :1;
  unsigned32 Origin                              :1;
  unsigned32 Layout                              :2;
  unsigned32 StripeHeight                        :3;
  unsigned32 StripePitch                         :3;
  unsigned32 PrefetchEnable                      :1;
  unsigned32 ReadEnable                          :1;
#else
  unsigned32 ReadEnable                          :1;
  unsigned32 PrefetchEnable                      :1;
  unsigned32 StripePitch                         :3;
  unsigned32 StripeHeight                        :3;
  unsigned32 Layout                              :2;
  unsigned32 Origin                              :1;
  unsigned32 Blocking                            :1;
  unsigned32 PCIMappingEnable                    :1;
  unsigned32 UseTexelCoord                       :1;
  unsigned32 WrapXEnable                         :1;
  unsigned32 WrapYEnable                         :1;
  unsigned32 WrapX                               :4;
  unsigned32 WrapY                               :4;
  unsigned32 ExternalSourceData                  :1;
  unsigned32                                     :7;
#endif
#ifdef __cplusplus
  FBSourceReadMode(void) { }
  FBSourceReadMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBSourceReadMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBSourceReadMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBSourceReadMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<24|0xf<<20|0xf<<16|0x1<<15|0x1<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x3<<8|0x7<<5|0x7<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct FBSourceReadBufferWidth {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 Width                               :12;
#else
  unsigned32 Width                               :12;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  FBSourceReadBufferWidth(void) { }
  FBSourceReadBufferWidth(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBSourceReadBufferWidth& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBSourceReadBufferWidth& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBSourceReadBufferWidth& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xfff<<0)); }
#endif /* __cplusplus */
};

struct MergeSpanDataLower {
#if BIG_ENDIAN == 1
  unsigned32                                     :1;
  unsigned32 Addr                                :5;
  unsigned32 Buffer                              :3;
  unsigned32 Load                                :1;
  unsigned32 PostDest                            :3;
  unsigned32 PostLength                          :4;
  unsigned32 PostStart                           :4;
  unsigned32 PreDest                             :3;
  unsigned32 PreLength                           :4;
  unsigned32 PreStart                            :4;
#else
  unsigned32 PreStart                            :4;
  unsigned32 PreLength                           :4;
  unsigned32 PreDest                             :3;
  unsigned32 PostStart                           :4;
  unsigned32 PostLength                          :4;
  unsigned32 PostDest                            :3;
  unsigned32 Load                                :1;
  unsigned32 Buffer                              :3;
  unsigned32 Addr                                :5;
  unsigned32                                     :1;
#endif
#ifdef __cplusplus
  MergeSpanDataLower(void) { }
  MergeSpanDataLower(const unsigned32 i) { *((unsigned32 *)this) = i; }
  MergeSpanDataLower& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  MergeSpanDataLower& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  MergeSpanDataLower& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1f<<26|0x7<<23|0x1<<22|0x7<<19|0xf<<15|0xf<<11|0x7<<8|0xf<<4|0xf<<0)); }
#endif /* __cplusplus */
};

struct MergeSpanDataUpper {
#if BIG_ENDIAN == 1
  unsigned32                                     :29;
  unsigned32 Operation                           :3;
#else
  unsigned32 Operation                           :3;
  unsigned32                                     :29;
#endif
#ifdef __cplusplus
  MergeSpanDataUpper(void) { }
  MergeSpanDataUpper(const unsigned32 i) { *((unsigned32 *)this) = i; }
  MergeSpanDataUpper& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  MergeSpanDataUpper& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  MergeSpanDataUpper& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<0)); }
#endif /* __cplusplus */
};

struct AlphaBlendColorMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :7;
  unsigned32 SwapSD                              :1;
  unsigned32 Operation                           :4;
  unsigned32 ConstantDest                        :1;
  unsigned32 ConstantSource                      :1;
  unsigned32 ColorConversion                     :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 ColorFormat                         :4;
  unsigned32 InvertDest                          :1;
  unsigned32 InvertSource                        :1;
  unsigned32 DestTimesTwo                        :1;
  unsigned32 SourceTimesTwo                      :1;
  unsigned32 DestBlend                           :3;
  unsigned32 SourceBlend                         :4;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 SourceBlend                         :4;
  unsigned32 DestBlend                           :3;
  unsigned32 SourceTimesTwo                      :1;
  unsigned32 DestTimesTwo                        :1;
  unsigned32 InvertSource                        :1;
  unsigned32 InvertDest                          :1;
  unsigned32 ColorFormat                         :4;
  unsigned32 ColorOrder                          :1;
  unsigned32 ColorConversion                     :1;
  unsigned32 ConstantSource                      :1;
  unsigned32 ConstantDest                        :1;
  unsigned32 Operation                           :4;
  unsigned32 SwapSD                              :1;
  unsigned32                                     :7;
#endif
#ifdef __cplusplus
  AlphaBlendColorMode(void) { }
  AlphaBlendColorMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  AlphaBlendColorMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  AlphaBlendColorMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  AlphaBlendColorMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<24|0xf<<20|0x1<<19|0x1<<18|0x1<<17|0x1<<16|0xf<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x7<<5|0xf<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct AlphaBlendAlphaMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :12;
  unsigned32 Operation                           :3;
  unsigned32 ConstantDest                        :1;
  unsigned32 ConstantSource                      :1;
  unsigned32 AlphaConversion                     :1;
  unsigned32 AlphaType                           :1;
  unsigned32 NoAlphaBuffer                       :1;
  unsigned32 InvertDest                          :1;
  unsigned32 InvertSource                        :1;
  unsigned32 DestTimesTwo                        :1;
  unsigned32 SourceTimesTwo                      :1;
  unsigned32 DestBlend                           :3;
  unsigned32 SourceBlend                         :4;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 SourceBlend                         :4;
  unsigned32 DestBlend                           :3;
  unsigned32 SourceTimesTwo                      :1;
  unsigned32 DestTimesTwo                        :1;
  unsigned32 InvertSource                        :1;
  unsigned32 InvertDest                          :1;
  unsigned32 NoAlphaBuffer                       :1;
  unsigned32 AlphaType                           :1;
  unsigned32 AlphaConversion                     :1;
  unsigned32 ConstantSource                      :1;
  unsigned32 ConstantDest                        :1;
  unsigned32 Operation                           :3;
  unsigned32                                     :12;
#endif
#ifdef __cplusplus
  AlphaBlendAlphaMode(void) { }
  AlphaBlendAlphaMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  AlphaBlendAlphaMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  AlphaBlendAlphaMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  AlphaBlendAlphaMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<17|0x1<<16|0x1<<15|0x1<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x7<<5|0xf<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct FBWriteBufferWidth {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 Width                               :12;
#else
  unsigned32 Width                               :12;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  FBWriteBufferWidth(void) { }
  FBWriteBufferWidth(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBWriteBufferWidth& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBWriteBufferWidth& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBWriteBufferWidth& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xfff<<0)); }
#endif /* __cplusplus */
};

struct TextureCompositeMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :31;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32                                     :31;
#endif
#ifdef __cplusplus
  TextureCompositeMode(void) { }
  TextureCompositeMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureCompositeMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureCompositeMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureCompositeMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureCompositeRGBAMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :9;
  unsigned32 Scale                               :2;
  unsigned32 Operation                           :4;
  unsigned32 B                                   :1;
  unsigned32 A                                   :1;
  unsigned32 InvertI                             :1;
  unsigned32 I                                   :3;
  unsigned32 InvertArg2                          :1;
  unsigned32 Arg2                                :4;
  unsigned32 InvertArg1                          :1;
  unsigned32 Arg1                                :4;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 Arg1                                :4;
  unsigned32 InvertArg1                          :1;
  unsigned32 Arg2                                :4;
  unsigned32 InvertArg2                          :1;
  unsigned32 I                                   :3;
  unsigned32 InvertI                             :1;
  unsigned32 A                                   :1;
  unsigned32 B                                   :1;
  unsigned32 Operation                           :4;
  unsigned32 Scale                               :2;
  unsigned32                                     :9;
#endif
#ifdef __cplusplus
  TextureCompositeRGBAMode(void) { }
  TextureCompositeRGBAMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureCompositeRGBAMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureCompositeRGBAMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureCompositeRGBAMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<21|0xf<<17|0x1<<16|0x1<<15|0x1<<14|0x7<<11|0x1<<10|0xf<<6|0x1<<5|0xf<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureIndexMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :6;
  unsigned32 SourceTexelEnable                   :1;
  unsigned32 LinearBias                          :2;
  unsigned32 NearestBias                         :2;
  unsigned32 MipMapEnable                        :1;
  unsigned32 Texture3DEnable                     :1;
  unsigned32 MinificationFilter                  :3;
  unsigned32 MagnificationFilter                 :1;
  unsigned32 MapType                             :1;
  unsigned32 WrapV                               :2;
  unsigned32 WrapU                               :2;
  unsigned32 Border                              :1;
  unsigned32 Height                              :4;
  unsigned32 Width                               :4;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 Width                               :4;
  unsigned32 Height                              :4;
  unsigned32 Border                              :1;
  unsigned32 WrapU                               :2;
  unsigned32 WrapV                               :2;
  unsigned32 MapType                             :1;
  unsigned32 MagnificationFilter                 :1;
  unsigned32 MinificationFilter                  :3;
  unsigned32 Texture3DEnable                     :1;
  unsigned32 MipMapEnable                        :1;
  unsigned32 NearestBias                         :2;
  unsigned32 LinearBias                          :2;
  unsigned32 SourceTexelEnable                   :1;
  unsigned32                                     :6;
#endif
#ifdef __cplusplus
  TextureIndexMode(void) { }
  TextureIndexMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureIndexMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureIndexMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureIndexMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<25|0x3<<23|0x3<<21|0x1<<20|0x1<<19|0x7<<16|0x1<<15|0x1<<14|0x3<<12|0x3<<10|0x1<<9|0xf<<5|0xf<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct LodRange {
#if BIG_ENDIAN == 1
  unsigned32                                     :8;
  unsigned32 Max                                 :12;
  unsigned32 Min                                 :12;
#else
  unsigned32 Min                                 :12;
  unsigned32 Max                                 :12;
  unsigned32                                     :8;
#endif
#ifdef __cplusplus
  LodRange(void) { }
  LodRange(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LodRange& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LodRange& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LodRange& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xfff<<12|0xfff<<0)); }
#endif /* __cplusplus */
};

struct InvalidateCache {
#if BIG_ENDIAN == 1
  unsigned32                                     :29;
  unsigned32 InvalidateTLB                       :1;
  unsigned32 InvalidateBank1                     :1;
  unsigned32 InvalidateBank0                     :1;
#else
  unsigned32 InvalidateBank0                     :1;
  unsigned32 InvalidateBank1                     :1;
  unsigned32 InvalidateTLB                       :1;
  unsigned32                                     :29;
#endif
#ifdef __cplusplus
  InvalidateCache(void) { }
  InvalidateCache(const unsigned32 i) { *((unsigned32 *)this) = i; }
  InvalidateCache& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  InvalidateCache& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  InvalidateCache& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TouchLogicalPage {
#if BIG_ENDIAN == 1
  unsigned32 Mode                                :2;
  unsigned32 Count                               :14;
  unsigned32 LogicalPage                         :16;
#else
  unsigned32 LogicalPage                         :16;
  unsigned32 Count                               :14;
  unsigned32 Mode                                :2;
#endif
#ifdef __cplusplus
  TouchLogicalPage(void) { }
  TouchLogicalPage(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TouchLogicalPage& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TouchLogicalPage& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TouchLogicalPage& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<30|0x3fff<<16|0xffff<<0)); }
#endif /* __cplusplus */
};

struct LUTMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :4;
  unsigned32 SpanVCXAlignment                    :1;
  unsigned32 SpanCCXAlignment                    :1;
  unsigned32 PatternBase                         :8;
  unsigned32 YOffset                             :3;
  unsigned32 XOffset                             :3;
  unsigned32 MotionComp8Bits                     :1;
  unsigned32 SpanOperation                       :3;
  unsigned32 FragmentOperation                   :3;
  unsigned32 LoadColorOrder                      :1;
  unsigned32 LoadFormat                          :2;
  unsigned32 InColorOrder                        :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 InColorOrder                        :1;
  unsigned32 LoadFormat                          :2;
  unsigned32 LoadColorOrder                      :1;
  unsigned32 FragmentOperation                   :3;
  unsigned32 SpanOperation                       :3;
  unsigned32 MotionComp8Bits                     :1;
  unsigned32 XOffset                             :3;
  unsigned32 YOffset                             :3;
  unsigned32 PatternBase                         :8;
  unsigned32 SpanCCXAlignment                    :1;
  unsigned32 SpanVCXAlignment                    :1;
  unsigned32                                     :4;
#endif
#ifdef __cplusplus
  LUTMode(void) { }
  LUTMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LUTMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LUTMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LUTMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<27|0x1<<26|0xff<<18|0x7<<15|0x7<<12|0x1<<11|0x7<<8|0x7<<5|0x1<<4|0x3<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureLayoutMode {
#if BIG_ENDIAN == 1
  unsigned32 Layout15                            :2;
  unsigned32 Layout14                            :2;
  unsigned32 Layout13                            :2;
  unsigned32 Layout12                            :2;
  unsigned32 Layout11                            :2;
  unsigned32 Layout10                            :2;
  unsigned32 Layout9                             :2;
  unsigned32 Layout8                             :2;
  unsigned32 Layout7                             :2;
  unsigned32 Layout6                             :2;
  unsigned32 Layout5                             :2;
  unsigned32 Layout4                             :2;
  unsigned32 Layout3                             :2;
  unsigned32 Layout2                             :2;
  unsigned32 Layout1                             :2;
  unsigned32 Layout0                             :2;
#else
  unsigned32 Layout0                             :2;
  unsigned32 Layout1                             :2;
  unsigned32 Layout2                             :2;
  unsigned32 Layout3                             :2;
  unsigned32 Layout4                             :2;
  unsigned32 Layout5                             :2;
  unsigned32 Layout6                             :2;
  unsigned32 Layout7                             :2;
  unsigned32 Layout8                             :2;
  unsigned32 Layout9                             :2;
  unsigned32 Layout10                            :2;
  unsigned32 Layout11                            :2;
  unsigned32 Layout12                            :2;
  unsigned32 Layout13                            :2;
  unsigned32 Layout14                            :2;
  unsigned32 Layout15                            :2;
#endif
#ifdef __cplusplus
  TextureLayoutMode(void) { }
  TextureLayoutMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureLayoutMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureLayoutMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureLayoutMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<30|0x3<<28|0x3<<26|0x3<<24|0x3<<22|0x3<<20|0x3<<18|0x3<<16|0x3<<14|0x3<<12|0x3<<10|0x3<<8|0x3<<6|0x3<<4|0x3<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct TextureMapWidth {
#if BIG_ENDIAN == 1
  unsigned32                                     :16;
  unsigned32 HostTexture                         :1;
  unsigned32 Layout                              :2;
  unsigned32 Border                              :1;
  unsigned32 Width                               :12;
#else
  unsigned32 Width                               :12;
  unsigned32 Border                              :1;
  unsigned32 Layout                              :2;
  unsigned32 HostTexture                         :1;
  unsigned32                                     :16;
#endif
#ifdef __cplusplus
  TextureMapWidth(void) { }
  TextureMapWidth(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureMapWidth& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureMapWidth& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureMapWidth& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<15|0x3<<13|0x1<<12|0xfff<<0)); }
#endif /* __cplusplus */
};

struct TextureCacheReplacementMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :19;
  unsigned32 ShowCacheInfo                       :1;
  unsigned32 ScratchLines1                       :5;
  unsigned32 KeepOldest1                         :1;
  unsigned32 ScratchLines0                       :5;
  unsigned32 KeepOldest0                         :1;
#else
  unsigned32 KeepOldest0                         :1;
  unsigned32 ScratchLines0                       :5;
  unsigned32 KeepOldest1                         :1;
  unsigned32 ScratchLines1                       :5;
  unsigned32 ShowCacheInfo                       :1;
  unsigned32                                     :19;
#endif
#ifdef __cplusplus
  TextureCacheReplacementMode(void) { }
  TextureCacheReplacementMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureCacheReplacementMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureCacheReplacementMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureCacheReplacementMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<12|0x1f<<7|0x1<<6|0x1f<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct PhysicalPageAllocation {
#if BIG_ENDIAN == 1
  unsigned32                                     :16;
  unsigned32 Page                                :16;
#else
  unsigned32 Page                                :16;
  unsigned32                                     :16;
#endif
#ifdef __cplusplus
  PhysicalPageAllocation(void) { }
  PhysicalPageAllocation(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PhysicalPageAllocation& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PhysicalPageAllocation& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PhysicalPageAllocation& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffff<<0)); }
#endif /* __cplusplus */
};

struct PhysicalPageListEntry1 {
#if BIG_ENDIAN == 1
  unsigned32 PrevPage                            :16;
  unsigned32 NextPage                            :16;
#else
  unsigned32 NextPage                            :16;
  unsigned32 PrevPage                            :16;
#endif
#ifdef __cplusplus
  PhysicalPageListEntry1(void) { }
  PhysicalPageListEntry1(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PhysicalPageListEntry1& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PhysicalPageListEntry1& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PhysicalPageListEntry1& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffff<<16|0xffff<<0)); }
#endif /* __cplusplus */
};

struct LogicalPageTableEntry0 {
#if BIG_ENDIAN == 1
  unsigned32                                     :15;
  unsigned32 Resident                            :1;
  unsigned32 PhysicalPage                        :16;
#else
  unsigned32 PhysicalPage                        :16;
  unsigned32 Resident                            :1;
  unsigned32                                     :15;
#endif
#ifdef __cplusplus
  LogicalPageTableEntry0(void) { }
  LogicalPageTableEntry0(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LogicalPageTableEntry0& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LogicalPageTableEntry0& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LogicalPageTableEntry0& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<16|0xffff<<0)); }
#endif /* __cplusplus */
};

struct LogicalPageTableEntry1 {
#if BIG_ENDIAN == 1
  unsigned32 HostPage                            :20;
  unsigned32 VirtualHostPage                     :1;
  unsigned32 MemoryPool                          :2;
  unsigned32 Length                              :9;
#else
  unsigned32 Length                              :9;
  unsigned32 MemoryPool                          :2;
  unsigned32 VirtualHostPage                     :1;
  unsigned32 HostPage                            :20;
#endif
#ifdef __cplusplus
  LogicalPageTableEntry1(void) { }
  LogicalPageTableEntry1(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LogicalPageTableEntry1& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LogicalPageTableEntry1& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LogicalPageTableEntry1& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xfffff<<12|0x1<<11|0x3<<9|0x1ff<<0)); }
#endif /* __cplusplus */
};

struct LBDestReadMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :8;
  unsigned32 Width                               :12;
  unsigned32 Packed16                            :1;
  unsigned32 UseReadEnables                      :1;
  unsigned32 Origin                              :1;
  unsigned32 Layout                              :1;
  unsigned32 StripeHeight                        :3;
  unsigned32 StripePitch                         :3;
  unsigned32 PrefetchEnable                      :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 PrefetchEnable                      :1;
  unsigned32 StripePitch                         :3;
  unsigned32 StripeHeight                        :3;
  unsigned32 Layout                              :1;
  unsigned32 Origin                              :1;
  unsigned32 UseReadEnables                      :1;
  unsigned32 Packed16                            :1;
  unsigned32 Width                               :12;
  unsigned32                                     :8;
#endif
#ifdef __cplusplus
  LBDestReadMode(void) { }
  LBDestReadMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LBDestReadMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LBDestReadMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LBDestReadMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xfff<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x7<<5|0x7<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct LBDestReadEnables {
#if BIG_ENDIAN == 1
  unsigned32                                     :16;
  unsigned32 R                                   :8;
  unsigned32 E                                   :8;
#else
  unsigned32 E                                   :8;
  unsigned32 R                                   :8;
  unsigned32                                     :16;
#endif
#ifdef __cplusplus
  LBDestReadEnables(void) { }
  LBDestReadEnables(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LBDestReadEnables& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LBDestReadEnables& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LBDestReadEnables& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<8|0xff<<0)); }
#endif /* __cplusplus */
};

struct LBSourceReadMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :9;
  unsigned32 Width                               :12;
  unsigned32 Packed16                            :1;
  unsigned32 Origin                              :1;
  unsigned32 Layout                              :1;
  unsigned32 StripeHeight                        :3;
  unsigned32 StripePitch                         :3;
  unsigned32 PrefetchEnable                      :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 PrefetchEnable                      :1;
  unsigned32 StripePitch                         :3;
  unsigned32 StripeHeight                        :3;
  unsigned32 Layout                              :1;
  unsigned32 Origin                              :1;
  unsigned32 Packed16                            :1;
  unsigned32 Width                               :12;
  unsigned32                                     :9;
#endif
#ifdef __cplusplus
  LBSourceReadMode(void) { }
  LBSourceReadMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LBSourceReadMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LBSourceReadMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LBSourceReadMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xfff<<11|0x1<<10|0x1<<9|0x1<<8|0x7<<5|0x7<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct GIDMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :18;
  unsigned32 ReplaceValue                        :4;
  unsigned32 ReplaceMode                         :2;
  unsigned32 CompareMode                         :2;
  unsigned32 CompareValue                        :4;
  unsigned32 SpanEnable                          :1;
  unsigned32 FragmentEnable                      :1;
#else
  unsigned32 FragmentEnable                      :1;
  unsigned32 SpanEnable                          :1;
  unsigned32 CompareValue                        :4;
  unsigned32 CompareMode                         :2;
  unsigned32 ReplaceMode                         :2;
  unsigned32 ReplaceValue                        :4;
  unsigned32                                     :18;
#endif
#ifdef __cplusplus
  GIDMode(void) { }
  GIDMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GIDMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GIDMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GIDMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xf<<10|0x3<<8|0x3<<6|0xf<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct Config2D {
#if BIG_ENDIAN == 1
  unsigned32                                     :11;
  unsigned32 LUTModeEnable                       :1;
  unsigned32 FBSourceReadModeExternalSourceData  :1;
  unsigned32 FBSourceReadModeBlocking            :1;
  unsigned32 FBWriteModeWriteEnable              :1;
  unsigned32 LogicalOpModeUseConstantSource      :1;
  unsigned32 LogicalOpBackgroundLogicalOp        :4;
  unsigned32 LogicalOpBackgroundEnable           :1;
  unsigned32 LogicalOpForegroundLogicalOp        :4;
  unsigned32 LogicalOpForegroundEnable           :1;
  unsigned32 DitherModeEnable                    :1;
  unsigned32 AlphaBlendEnable                    :1;
  unsigned32 FBDestReadModeReadEnable            :1;
  unsigned32 ScissorModeUserScissorEnable        :1;
  unsigned32 RasterizerModeMultiRXBlit           :1;
  unsigned32 RasterizerModeOpaqueSpans           :1;
#else
  unsigned32 RasterizerModeOpaqueSpans           :1;
  unsigned32 RasterizerModeMultiRXBlit           :1;
  unsigned32 ScissorModeUserScissorEnable        :1;
  unsigned32 FBDestReadModeReadEnable            :1;
  unsigned32 AlphaBlendEnable                    :1;
  unsigned32 DitherModeEnable                    :1;
  unsigned32 LogicalOpForegroundEnable           :1;
  unsigned32 LogicalOpForegroundLogicalOp        :4;
  unsigned32 LogicalOpBackgroundEnable           :1;
  unsigned32 LogicalOpBackgroundLogicalOp        :4;
  unsigned32 LogicalOpModeUseConstantSource      :1;
  unsigned32 FBWriteModeWriteEnable              :1;
  unsigned32 FBSourceReadModeBlocking            :1;
  unsigned32 FBSourceReadModeExternalSourceData  :1;
  unsigned32 LUTModeEnable                       :1;
  unsigned32                                     :11;
#endif
#ifdef __cplusplus
  Config2D(void) { }
  Config2D(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Config2D& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Config2D& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Config2D& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<20|0x1<<19|0x1<<18|0x1<<17|0x1<<16|0xf<<12|0x1<<11|0xf<<7|0x1<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct Render2D {
#if BIG_ENDIAN == 1
  unsigned32 TextureEnable                       :1;
  unsigned32 AreaStippleEnable                   :1;
  unsigned32 IncreasingY                         :1;
  unsigned32 IncreasingX                         :1;
  unsigned32 Height                              :12;
  unsigned32 SpanOperation                       :1;
  unsigned32 FBReadSourceEnable                  :1;
  unsigned32 Operation                           :2;
  unsigned32 Width                               :12;
#else
  unsigned32 Width                               :12;
  unsigned32 Operation                           :2;
  unsigned32 FBReadSourceEnable                  :1;
  unsigned32 SpanOperation                       :1;
  unsigned32 Height                              :12;
  unsigned32 IncreasingX                         :1;
  unsigned32 IncreasingY                         :1;
  unsigned32 AreaStippleEnable                   :1;
  unsigned32 TextureEnable                       :1;
#endif
#ifdef __cplusplus
  Render2D(void) { }
  Render2D(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Render2D& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Render2D& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Render2D& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x1<<30|0x1<<29|0x1<<28|0xfff<<16|0x1<<15|0x1<<14|0x3<<12|0xfff<<0)); }
#endif /* __cplusplus */
};

struct Render2DGlyph {
#if BIG_ENDIAN == 1
  signed32   AdvanceY                            :9;
  signed32   AdvanceX                            :9;
  unsigned32 Height                              :7;
  unsigned32 Width                               :7;
#else
  unsigned32 Width                               :7;
  unsigned32 Height                              :7;
  signed32   AdvanceX                            :9;
  signed32   AdvanceY                            :9;
#endif
#ifdef __cplusplus
  Render2DGlyph(void) { }
  Render2DGlyph(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Render2DGlyph& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Render2DGlyph& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Render2DGlyph& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1ff<<23|0x1ff<<14|0x7f<<7|0x7f<<0)); }
#endif /* __cplusplus */
};

struct DMAMemoryControl {
#if BIG_ENDIAN == 1
  unsigned32 WriteDMAAlignment                   :1;
  unsigned32                                     :2;
  unsigned32 BurstSize                           :5;
  unsigned32                                     :12;
  unsigned32 ReadDMAAlignment                    :1;
  unsigned32                                     :1;
  unsigned32 ReadDMAMemory                       :1;
  unsigned32 VertexAlignment                     :1;
  unsigned32                                     :1;
  unsigned32 VertexMemory                        :1;
  unsigned32 IndexAlignment                      :1;
  unsigned32                                     :1;
  unsigned32 IndexMemory                         :1;
  unsigned32 InputDMAAlignment                   :1;
  unsigned32                                     :1;
  unsigned32 InputDMAMemory                      :1;
#else
  unsigned32 InputDMAMemory                      :1;
  unsigned32                                     :1;
  unsigned32 InputDMAAlignment                   :1;
  unsigned32 IndexMemory                         :1;
  unsigned32                                     :1;
  unsigned32 IndexAlignment                      :1;
  unsigned32 VertexMemory                        :1;
  unsigned32                                     :1;
  unsigned32 VertexAlignment                     :1;
  unsigned32 ReadDMAMemory                       :1;
  unsigned32                                     :1;
  unsigned32 ReadDMAAlignment                    :1;
  unsigned32                                     :12;
  unsigned32 BurstSize                           :5;
  unsigned32                                     :2;
  unsigned32 WriteDMAAlignment                   :1;
#endif
#ifdef __cplusplus
  DMAMemoryControl(void) { }
  DMAMemoryControl(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DMAMemoryControl& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DMAMemoryControl& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DMAMemoryControl& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x1f<<24|0x1<<11|0x1<<9|0x1<<8|0x1<<6|0x1<<5|0x1<<3|0x1<<2|0x1<<0)); }
#endif /* __cplusplus */
};

struct IndexBaseAddress {
#if BIG_ENDIAN == 1
  unsigned32 Address                             :31;
  unsigned32                                     :1;
#else
  unsigned32                                     :1;
  unsigned32 Address                             :31;
#endif
#ifdef __cplusplus
  IndexBaseAddress(void) { }
  IndexBaseAddress(const unsigned32 i) { *((unsigned32 *)this) = i; }
  IndexBaseAddress& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  IndexBaseAddress& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  IndexBaseAddress& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7fffffff<<1)); }
#endif /* __cplusplus */
};

struct VertexBaseAddress {
#if BIG_ENDIAN == 1
  unsigned32 Address                             :30;
  unsigned32                                     :2;
#else
  unsigned32                                     :2;
  unsigned32 Address                             :30;
#endif
#ifdef __cplusplus
  VertexBaseAddress(void) { }
  VertexBaseAddress(const unsigned32 i) { *((unsigned32 *)this) = i; }
  VertexBaseAddress& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  VertexBaseAddress& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  VertexBaseAddress& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3fffffff<<2)); }
#endif /* __cplusplus */
};

struct VertexControl {
#if BIG_ENDIAN == 1
  unsigned32                                     :21;
  unsigned32 Line2D                              :1;
  unsigned32 OGL                                 :1;
  unsigned32 SkipFlags                           :1;
  unsigned32 ReadAll                             :1;
  unsigned32 Flat                                :1;
  unsigned32 CacheEnable                         :1;
  unsigned32 Size                                :5;
#else
  unsigned32 Size                                :5;
  unsigned32 CacheEnable                         :1;
  unsigned32 Flat                                :1;
  unsigned32 ReadAll                             :1;
  unsigned32 SkipFlags                           :1;
  unsigned32 OGL                                 :1;
  unsigned32 Line2D                              :1;
  unsigned32                                     :21;
#endif
#ifdef __cplusplus
  VertexControl(void) { }
  VertexControl(const unsigned32 i) { *((unsigned32 *)this) = i; }
  VertexControl& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  VertexControl& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  VertexControl& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1f<<0)); }
#endif /* __cplusplus */
};

struct VertexTagList {
#if BIG_ENDIAN == 1
  unsigned32                                     :21;
  unsigned32 Tag                                 :11;
#else
  unsigned32 Tag                                 :11;
  unsigned32                                     :21;
#endif
#ifdef __cplusplus
  VertexTagList(void) { }
  VertexTagList(const unsigned32 i) { *((unsigned32 *)this) = i; }
  VertexTagList& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  VertexTagList& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  VertexTagList& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7ff<<0)); }
#endif /* __cplusplus */
};

struct IndexedDoubleVertex {
#if BIG_ENDIAN == 1
  unsigned32 Index1                              :16;
  unsigned32 Index0                              :16;
#else
  unsigned32 Index0                              :16;
  unsigned32 Index1                              :16;
#endif
#ifdef __cplusplus
  IndexedDoubleVertex(void) { }
  IndexedDoubleVertex(const unsigned32 i) { *((unsigned32 *)this) = i; }
  IndexedDoubleVertex& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  IndexedDoubleVertex& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  IndexedDoubleVertex& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffff<<16|0xffff<<0)); }
#endif /* __cplusplus */
};

struct HostInState {
#if BIG_ENDIAN == 1
  unsigned32                                     :1;
  unsigned32 ReadDMAPitch                        :2;
  unsigned32 ReadDMAAddress                      :2;
  unsigned32                                     :12;
  unsigned32 DataCount                           :6;
  unsigned32 ProvokingVertexSent                 :1;
  unsigned32 PrimitiveType                       :3;
  unsigned32 PrimitiveStarted                    :1;
  unsigned32 InvertBackfaceCull                  :1;
  unsigned32                                     :1;
  unsigned32 Vertex                              :2;
#else
  unsigned32 Vertex                              :2;
  unsigned32                                     :1;
  unsigned32 InvertBackfaceCull                  :1;
  unsigned32 PrimitiveStarted                    :1;
  unsigned32 PrimitiveType                       :3;
  unsigned32 ProvokingVertexSent                 :1;
  unsigned32 DataCount                           :6;
  unsigned32                                     :12;
  unsigned32 ReadDMAAddress                      :2;
  unsigned32 ReadDMAPitch                        :2;
  unsigned32                                     :1;
#endif
#ifdef __cplusplus
  HostInState(void) { }
  HostInState(const unsigned32 i) { *((unsigned32 *)this) = i; }
  HostInState& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  HostInState& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  HostInState& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<29|0x3<<27|0x3f<<9|0x1<<8|0x7<<5|0x1<<4|0x1<<3|0x3<<0)); }
#endif /* __cplusplus */
};

struct Security {
#if BIG_ENDIAN == 1
  unsigned32                                     :31;
  unsigned32 Secure                              :1;
#else
  unsigned32 Secure                              :1;
  unsigned32                                     :31;
#endif
#ifdef __cplusplus
  Security(void) { }
  Security(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Security& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Security& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Security& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<0)); }
#endif /* __cplusplus */
};

struct SClkProfileMask {
#if BIG_ENDIAN == 1
  unsigned32                                     :1;
  unsigned32 Mode                                :1;
  unsigned32                                     :7;
  unsigned32 SetupOutputFull                     :1;
  unsigned32 SetupInputEmpty                     :1;
  unsigned32 PCIReadCtrlFull                     :1;
  unsigned32 PCIDataEmpty                        :1;
  unsigned32 VertexAddressEmpty                  :1;
  unsigned32 IndexAddressEmpty                   :1;
  unsigned32 DMAAddressEmpty                     :1;
  unsigned32 VertexDataEmpty                     :1;
  unsigned32 OutputFull                          :1;
  unsigned32 VertexEmpty                         :1;
  unsigned32 IndexDataEmpty                      :1;
  unsigned32 VertexFull                          :1;
  unsigned32 VertexAddressFull                   :1;
  unsigned32 IndexEmpty                          :1;
  unsigned32 DMAWriteCtrlFull                    :1;
  unsigned32 DMADataEmpty                        :1;
  unsigned32 IndexFull                           :1;
  unsigned32 IndexAddressFull                    :1;
  unsigned32 DMAEmpty                            :1;
  unsigned32 DMAFull                             :1;
  unsigned32 DMAAddressFull                      :1;
  unsigned32 InputEmpty                          :1;
  unsigned32 Always                              :1;
#else
  unsigned32 Always                              :1;
  unsigned32 InputEmpty                          :1;
  unsigned32 DMAAddressFull                      :1;
  unsigned32 DMAFull                             :1;
  unsigned32 DMAEmpty                            :1;
  unsigned32 IndexAddressFull                    :1;
  unsigned32 IndexFull                           :1;
  unsigned32 DMADataEmpty                        :1;
  unsigned32 DMAWriteCtrlFull                    :1;
  unsigned32 IndexEmpty                          :1;
  unsigned32 VertexAddressFull                   :1;
  unsigned32 VertexFull                          :1;
  unsigned32 IndexDataEmpty                      :1;
  unsigned32 VertexEmpty                         :1;
  unsigned32 OutputFull                          :1;
  unsigned32 VertexDataEmpty                     :1;
  unsigned32 DMAAddressEmpty                     :1;
  unsigned32 IndexAddressEmpty                   :1;
  unsigned32 VertexAddressEmpty                  :1;
  unsigned32 PCIDataEmpty                        :1;
  unsigned32 PCIReadCtrlFull                     :1;
  unsigned32 SetupInputEmpty                     :1;
  unsigned32 SetupOutputFull                     :1;
  unsigned32                                     :7;
  unsigned32 Mode                                :1;
  unsigned32                                     :1;
#endif
#ifdef __cplusplus
  SClkProfileMask(void) { }
  SClkProfileMask(const unsigned32 i) { *((unsigned32 *)this) = i; }
  SClkProfileMask& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  SClkProfileMask& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  SClkProfileMask& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<30|0x1<<22|0x1<<21|0x1<<20|0x1<<19|0x1<<18|0x1<<17|0x1<<16|0x1<<15|0x1<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureDownloadControl {
#if BIG_ENDIAN == 1
  unsigned32                                     :18;
  unsigned32 SlavetextureDownload                :1;
  unsigned32 TextureThreshold                    :5;
  unsigned32 TextureGranularity                  :5;
  unsigned32 TextureMemType                      :1;
  unsigned32 TextureDownloadBusy                 :1;
  unsigned32 TextureDownloadEnable               :1;
#else
  unsigned32 TextureDownloadEnable               :1;
  unsigned32 TextureDownloadBusy                 :1;
  unsigned32 TextureMemType                      :1;
  unsigned32 TextureGranularity                  :5;
  unsigned32 TextureThreshold                    :5;
  unsigned32 SlavetextureDownload                :1;
  unsigned32                                     :18;
#endif
#ifdef __cplusplus
  TextureDownloadControl(void) { }
  TextureDownloadControl(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureDownloadControl& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureDownloadControl& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureDownloadControl& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<13|0x1f<<8|0x1f<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct DeltaFormatControl {
#if BIG_ENDIAN == 1
  unsigned32                                     :15;
  unsigned32 TextureShift1                       :1;
  unsigned32 BackfaceCull                        :1;
  unsigned32 PerPolyMipMap1                      :1;
  unsigned32 PerPolyMipMap                       :1;
  unsigned32 ShareQ                              :1;
  unsigned32 ShareT                              :1;
  unsigned32 ShareS                              :1;
  unsigned32 ForceQ                              :1;
  unsigned32 ScaleByQ1                           :1;
  unsigned32 ScaleByQ                            :1;
  unsigned32 TextureShift                        :1;
  unsigned32 WrapT1                              :1;
  unsigned32 WrapS1                              :1;
  unsigned32 WrapT                               :1;
  unsigned32 WrapS                               :1;
  unsigned32 EqualQ                              :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 EqualQ                              :1;
  unsigned32 WrapS                               :1;
  unsigned32 WrapT                               :1;
  unsigned32 WrapS1                              :1;
  unsigned32 WrapT1                              :1;
  unsigned32 TextureShift                        :1;
  unsigned32 ScaleByQ                            :1;
  unsigned32 ScaleByQ1                           :1;
  unsigned32 ForceQ                              :1;
  unsigned32 ShareS                              :1;
  unsigned32 ShareT                              :1;
  unsigned32 ShareQ                              :1;
  unsigned32 PerPolyMipMap                       :1;
  unsigned32 PerPolyMipMap1                      :1;
  unsigned32 BackfaceCull                        :1;
  unsigned32 TextureShift1                       :1;
  unsigned32                                     :15;
#endif
#ifdef __cplusplus
  DeltaFormatControl(void) { }
  DeltaFormatControl(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DeltaFormatControl& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DeltaFormatControl& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DeltaFormatControl& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<16|0x1<<15|0x1<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct DeltaFormatMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :2;
  unsigned32                                     :3;
  unsigned32 TextureEnable1                      :1;
  unsigned32                                     :20;
  unsigned32 TextureEnable                       :1;
  unsigned32                                     :5;
#else
  unsigned32                                     :5;
  unsigned32 TextureEnable                       :1;
  unsigned32                                     :20;
  unsigned32 TextureEnable1                      :1;
  unsigned32                                     :3;
  unsigned32                                     :2;
#endif
#ifdef __cplusplus
  DeltaFormatMode(void) { }
  DeltaFormatMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DeltaFormatMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DeltaFormatMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DeltaFormatMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<26|0x1<<5)); }
#endif /* __cplusplus */
};

struct StripeOwnership {
#if BIG_ENDIAN == 1
  unsigned32                                     :24;
  unsigned32 Stripe1                             :3;
  unsigned32 Stripe1Enable                       :1;
  unsigned32 Stripe0                             :3;
  unsigned32 Stripe0Enable                       :1;
#else
  unsigned32 Stripe0Enable                       :1;
  unsigned32 Stripe0                             :3;
  unsigned32 Stripe1Enable                       :1;
  unsigned32 Stripe1                             :3;
  unsigned32                                     :24;
#endif
#ifdef __cplusplus
  StripeOwnership(void) { }
  StripeOwnership(const unsigned32 i) { *((unsigned32 *)this) = i; }
  StripeOwnership& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  StripeOwnership& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  StripeOwnership& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<5|0x1<<4|0x7<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct Extend {
#if BIG_ENDIAN == 1
  unsigned32                                     :21;
  unsigned32 Integer                             :8;
  unsigned32 Fraction                            :3;
#else
  unsigned32 Fraction                            :3;
  unsigned32 Integer                             :8;
  unsigned32                                     :21;
#endif
#ifdef __cplusplus
  Extend(void) { }
  Extend(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Extend& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Extend& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Extend& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<3|0x7<<0)); }
#endif /* __cplusplus */
};

struct MatrixStatus {
#if BIG_ENDIAN == 1
  unsigned32                                     :29;
  unsigned32 BoundingBoxOverrun                  :1;
  unsigned32 StackUnderflow                      :1;
  unsigned32 StackOverflow                       :1;
#else
  unsigned32 StackOverflow                       :1;
  unsigned32 StackUnderflow                      :1;
  unsigned32 BoundingBoxOverrun                  :1;
  unsigned32                                     :29;
#endif
#ifdef __cplusplus
  MatrixStatus(void) { }
  MatrixStatus(const unsigned32 i) { *((unsigned32 *)this) = i; }
  MatrixStatus& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  MatrixStatus& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  MatrixStatus& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct GetMatrix {
#if BIG_ENDIAN == 1
  unsigned32                                     :22;
  unsigned32 Level                               :5;
  unsigned32 Select                              :4;
  unsigned32 AnyMatrix                           :1;
#else
  unsigned32 AnyMatrix                           :1;
  unsigned32 Select                              :4;
  unsigned32 Level                               :5;
  unsigned32                                     :22;
#endif
#ifdef __cplusplus
  GetMatrix(void) { }
  GetMatrix(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GetMatrix& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GetMatrix& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GetMatrix& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1f<<5|0xf<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureFogMiscGeneralContext {
#if BIG_ENDIAN == 1
  unsigned32                                     :17;
  unsigned32 TextureTexGenSelect                 :3;
  unsigned32 TextureMatrixSelect                 :3;
  unsigned32 TextureModeSelect                   :3;
  unsigned32 Vertex                              :2;
  unsigned32 ValidatedTextureFog                 :1;
  unsigned32 InPrimitive                         :1;
  unsigned32 FogEnable                           :1;
  unsigned32 TextureEnable                       :1;
#else
  unsigned32 TextureEnable                       :1;
  unsigned32 FogEnable                           :1;
  unsigned32 InPrimitive                         :1;
  unsigned32 ValidatedTextureFog                 :1;
  unsigned32 Vertex                              :2;
  unsigned32 TextureModeSelect                   :3;
  unsigned32 TextureMatrixSelect                 :3;
  unsigned32 TextureTexGenSelect                 :3;
  unsigned32                                     :17;
#endif
#ifdef __cplusplus
  TextureFogMiscGeneralContext(void) { }
  TextureFogMiscGeneralContext(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureFogMiscGeneralContext& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureFogMiscGeneralContext& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureFogMiscGeneralContext& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<12|0x7<<9|0x7<<6|0x3<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct PipeMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :10;
  unsigned32 ObjectIDPerPrimitive                :1;
  unsigned32 ObjectTagEnable                     :1;
  unsigned32 FifoBusyLevel                       :5;
  unsigned32 MaxPrimCount                        :7;
  unsigned32 MinPrimCount                        :5;
  unsigned32 NextPipe                            :1;
  unsigned32 SwitchPipe                          :1;
  unsigned32 UseOnePipeOnly                      :1;
#else
  unsigned32 UseOnePipeOnly                      :1;
  unsigned32 SwitchPipe                          :1;
  unsigned32 NextPipe                            :1;
  unsigned32 MinPrimCount                        :5;
  unsigned32 MaxPrimCount                        :7;
  unsigned32 FifoBusyLevel                       :5;
  unsigned32 ObjectTagEnable                     :1;
  unsigned32 ObjectIDPerPrimitive                :1;
  unsigned32                                     :10;
#endif
#ifdef __cplusplus
  PipeMode(void) { }
  PipeMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PipeMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PipeMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PipeMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<21|0x1<<20|0x1f<<15|0x7f<<8|0x1f<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct PipeLoad {
#if BIG_ENDIAN == 1
  unsigned32                                     :19;
  unsigned32 BlendEnable                         :1;
  unsigned32 FogEnable                           :1;
  unsigned32 SpecularEnable                      :1;
  unsigned32 DiffuseEnable                       :1;
  unsigned32 FaceNormalEnable                    :1;
  unsigned32 TextureEnable7                      :1;
  unsigned32 TextureEnable6                      :1;
  unsigned32 TextureEnable5                      :1;
  unsigned32 TextureEnable4                      :1;
  unsigned32 TextureEnable3                      :1;
  unsigned32 TextureEnable2                      :1;
  unsigned32 TextureEnable1                      :1;
  unsigned32 ForceReload                         :1;
#else
  unsigned32 ForceReload                         :1;
  unsigned32 TextureEnable1                      :1;
  unsigned32 TextureEnable2                      :1;
  unsigned32 TextureEnable3                      :1;
  unsigned32 TextureEnable4                      :1;
  unsigned32 TextureEnable5                      :1;
  unsigned32 TextureEnable6                      :1;
  unsigned32 TextureEnable7                      :1;
  unsigned32 FaceNormalEnable                    :1;
  unsigned32 DiffuseEnable                       :1;
  unsigned32 SpecularEnable                      :1;
  unsigned32 FogEnable                           :1;
  unsigned32 BlendEnable                         :1;
  unsigned32                                     :19;
#endif
#ifdef __cplusplus
  PipeLoad(void) { }
  PipeLoad(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PipeLoad& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PipeLoad& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PipeLoad& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct CommandDMAControl {
#if BIG_ENDIAN == 1
  unsigned32                                     :25;
  unsigned32 BurstSize                           :3;
  unsigned32 ByteSwap                            :2;
  unsigned32 Alignment                           :1;
  unsigned32 Protocol                            :1;
#else
  unsigned32 Protocol                            :1;
  unsigned32 Alignment                           :1;
  unsigned32 ByteSwap                            :2;
  unsigned32 BurstSize                           :3;
  unsigned32                                     :25;
#endif
#ifdef __cplusplus
  CommandDMAControl(void) { }
  CommandDMAControl(const unsigned32 i) { *((unsigned32 *)this) = i; }
  CommandDMAControl& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  CommandDMAControl& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  CommandDMAControl& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<4|0x3<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct CommandState {
#if BIG_ENDIAN == 1
  unsigned32                                     :28;
  unsigned32 Started                             :2;
  unsigned32 Result                              :1;
  unsigned32 Test                                :1;
#else
  unsigned32 Test                                :1;
  unsigned32 Result                              :1;
  unsigned32 Started                             :2;
  unsigned32                                     :28;
#endif
#ifdef __cplusplus
  CommandState(void) { }
  CommandState(const unsigned32 i) { *((unsigned32 *)this) = i; }
  CommandState& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  CommandState& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  CommandState& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};
#endif /* _REG_H_ */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\rgb640.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: rgb640.h
*
* Content: This module contains the definitions for the IBM RGB640 RAMDAC.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

//
// IBM RGB640 RAMDAC definitions
// This set of registers resides at &(pCtrlRegs->ExternalVideo)
//
typedef struct _rgb640_regs {
    RAMDAC_REG  palAddrWr;      // loads internal register for palette writes
    RAMDAC_REG  palData;        // read/write to get/set palette data
    RAMDAC_REG  pixelMask;      // mask to AND with input pixel data
    RAMDAC_REG  palAddrRd;      // loads internal register for palette reads
    RAMDAC_REG  indexLow;       // low byte of internal control/cursor register
    RAMDAC_REG  indexHigh;      // high byte of internal control/cursor register
    RAMDAC_REG  indexData;      // read/write to get/set control/cursor data
    RAMDAC_REG  Reserved;
} RGB640RAMDAC, *pRGB640RAMDAC;


// structure containing the mapped addresses for each of the RGB640 registers.
// We need this since some chips like the Alpha cannot be accessed by simply
// writing to the memory mapped register. So instead we set up the following
// struct of memory addresses at init time and use these instead. All these
// addresses must be passed to WRITE/READ_FAST_ULONG.
// We also keep software copies of various registers in here so we can turn
// on and off individual bits more easily.
//
typedef struct _rgb640_data {

    // register addresses

    ULONG *       palAddrWr;      // loads internal register for palette writes
    ULONG *       palData;        // read/write to get/set palette data
    ULONG *       pixelMask;      // mask to AND with input pixel data
    ULONG *       palAddrRd;      // loads internal register for palette reads
    ULONG *       indexLow;       // low byte of internal control/cursor register
    ULONG *       indexHigh;      // high byte of internal control/cursor register
    ULONG *       indexData;      // read/write to get/set control/cursor data
    ULONG *       indexCtl;       // controls auto-increment of internal addresses

    // register copies

    ULONG       cursorControl;  // controls enable/disable

} RGB640Data, *pRGB640Data;

// use the following macros as the address to pass to the
// VideoPortWriteRegisterUlong function
//
#define RGB640_PAL_WR_ADDR              pRGB640info->palAddrWr
#define RGB640_PAL_RD_ADDR              pRGB640info->palAddrRd
#define RGB640_PAL_DATA                 pRGB640info->palData
#define RGB640_PIXEL_MASK               pRGB640info->pixelMask
#define RGB640_INDEX_ADDR_LO            pRGB640info->indexLow
#define RGB640_INDEX_ADDR_HI            pRGB640info->indexHigh
#define RGB640_INDEX_DATA               pRGB640info->indexData
#define RGB640_INDEX_CONTROL            pRGB640info->indexCtl


//
// generic read/write routines for 640 registers
//
#define WRITE_640REG_ULONG(r, d) \
{ \
    WRITE_FAST_ULONG(r, (ULONG)(d)); \
    MEMORY_BARRIER(); \
}
    
#define READ_640REG_ULONG(r)    READ_FAST_ULONG(r)
    

// We have to have a delay between all accesses to the RGB640. A simple
// for loop delay is not good enough since writes to GLINT are posted
// and may still get batched together. The only sure way is to do a read
// from bypass space. Arbitrarily, we choose the FBModeSel register since
// we already have a macro to read it. PPC needs 2 reads to give us enough
// time.
//
#define RGB640_DELAY \
{ \
    volatile ULONG __junk;          \
    GLINT_GET_PACKING_MODE(__junk); \
    GLINT_GET_PACKING_MODE(__junk); \
}

// macro to load a given data value into an internal RGB640 register. The
// second macro loads an internal index register assuming that we have
// already zeroed the high address register.
//
#define RGB640_INDEX_INCREMENT(n) \
{ \
    /*WRITE_640REG_ULONG (RGB640_INDEX_CONTROL, (ULONG)(n));    */\
    RGB640_DELAY;                                               \
}

// macro to load a given data value into an internal RGB640 register. The
// second macro loads an internal index register assuming that we have
// already zeroed the high address register.
//
#define RGB640_INDEX_REG(index) \
{ \
    WRITE_640REG_ULONG(RGB640_INDEX_ADDR_LO, (ULONG)((index) & 0xff)); \
    RGB640_DELAY; \
    WRITE_640REG_ULONG(RGB640_INDEX_ADDR_HI, (ULONG)((index) >> 8)); \
    RGB640_DELAY; \
}

#define RGB640_LOAD_DATA(data) \
{ \
    WRITE_640REG_ULONG(RGB640_INDEX_DATA, (ULONG)((data) & 0xff)); \
    RGB640_DELAY; \
}

#define RGB640_LOAD_INDEX_REG(index, data) \
{ \
    RGB640_INDEX_REG(index);                            \
    WRITE_640REG_ULONG(RGB640_INDEX_DATA, (ULONG)((data) & 0xff)); \
    RGB640_DELAY; \
}

#define RGB640_READ_INDEX_REG(index, data) \
{ \
    RGB640_INDEX_REG(index);                            \
    data = (UCHAR) (READ_640REG_ULONG (RGB640_INDEX_DATA) & 0xff);   \
    RGB640_DELAY; \
}

#define RGB640_LOAD_INDEX_REG_LO(index, data) \
{ \
    WRITE_640REG_ULONG(RGB640_INDEX_ADDR_LO, (ULONG)(index));  \
    RGB640_DELAY; \
    WRITE_640REG_ULONG(RGB640_INDEX_DATA,    (ULONG)(data));   \
    RGB640_DELAY; \
}

// macros to load a given RGB triple into the RGB640 palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use RGB640_PALETTE_START and multiple RGB640_LOAD_PALETTE calls to load
// a contiguous set of entries. Use RGB640_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//
#define RGB640_PALETTE_START_WR(index) \
    RGB640_INDEX_REG((index) + 0x4000)

#define RGB640_PALETTE_START_RD(index) \
    RGB640_INDEX_REG((index) + 0x8000)

#define RGB640_LOAD_PALETTE(red, green, blue) \
{ \
    RGB640_LOAD_DATA(red);      \
    RGB640_LOAD_DATA(green);    \
    RGB640_LOAD_DATA(blue);     \
}

#define RGB640_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    RGB640_PALETTE_START_WR(index); \
    RGB640_LOAD_PALETTE(red, green, blue); \
}

// macro to read back a given RGB triple from the RGB640 palette. Use after
// a call to RGB640_PALETTE_START_RD
//
#define RGB640_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR)(READ_640REG_ULONG (RGB640_INDEX_DATA) & 0xff);        \
    RGB640_DELAY; \
    green = (UCHAR)(READ_640REG_ULONG (RGB640_INDEX_DATA) & 0xff);        \
    RGB640_DELAY; \
    blue  = (UCHAR)(READ_640REG_ULONG (RGB640_INDEX_DATA) & 0xff);        \
    RGB640_DELAY; \
}

// Accesses to 1024x30 palette using four accesses

#define RGB640_LOAD_PALETTE10(red, green, blue) \
{ \
    RGB640_LOAD_DATA ((red) >> 2);              \
    RGB640_LOAD_DATA ((green) >> 2);            \
    RGB640_LOAD_DATA ((blue) >> 2);             \
    RGB640_LOAD_DATA ((((red)   & 3) << 4) |    \
                      (((green) & 3) << 2) |    \
                      (((blue)  & 3)     ));    \
}

#define RGB640_LOAD_PALETTE10_INDEX(index, red, green, blue) \
{ \
    RGB640_PALETTE_START_WR(index); \
    RGB640_LOAD_PALETTE10(red, green, blue); \
}

// macro to read back a given RGB triple from the RGB640 palette. Use after
// a call to RGB640_PALETTE_START_RD
//
#define RGB640_READ_PALETTE10(red, green, blue) \
{ \
    USHORT  temp; \
    red   = (USHORT)(READ_640REG_ULONG (RGB640_INDEX_DATA) & 0xff) << 2;   \
    RGB640_DELAY; \
    green = (USHORT)(READ_640REG_ULONG (RGB640_INDEX_DATA) & 0xff) << 2;   \
    RGB640_DELAY; \
    blue  = (USHORT)(READ_640REG_ULONG (RGB640_INDEX_DATA) & 0xff) << 2;   \
    RGB640_DELAY; \
    temp  = (USHORT)(READ_640REG_ULONG (RGB640_INDEX_DATA) & 0xff);        \
    RGB640_DELAY; \
    red   |= (temp >> 4) & 0x3; \
    green |= (temp >> 2) & 0x3; \
    blue  |=  temp       & 0x3; \
}

// macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//
#define RGB640_SET_PIXEL_READMASK(mask) \
{ \
    WRITE_640REG_ULONG(RGB640_PIXEL_MASK,  (ULONG)(mask)); \
    RGB640_DELAY; \
}

#define RGB640_READ_PIXEL_READMASK(mask) \
{ \
    mask = (UCHAR)(READ_640REG_ULONG (RGB640_PIXEL_MASK) & 0xff); \
    RGB640_DELAY; \
}

// macros to load values into the cursor array
//
#define RGB640_CURSOR_ARRAY_START_WR(offset) \
{ \
    WRITE_640REG_ULONG(RGB640_INDEX_ADDR_LO,   (ULONG)(((offset)+0x1000) & 0xff));  \
    RGB640_DELAY; \
    WRITE_640REG_ULONG(RGB640_INDEX_ADDR_HI,   (ULONG)(((offset)+0x1000) >> 8));    \
    RGB640_DELAY; \
}

#define RGB640_CURSOR_ARRAY_START_RD(offset) \
{ \
    WRITE_640REG_ULONG(RGB640_INDEX_ADDR_LO,   (ULONG)(((offset)+0x2000) & 0xff));  \
    RGB640_DELAY; \
    WRITE_640REG_ULONG(RGB640_INDEX_ADDR_HI,   (ULONG)(((offset)+0x2000) >> 8));    \
    RGB640_DELAY; \
}

#define RGB640_LOAD_CURSOR_ARRAY(data) \
{ \
    WRITE_640REG_ULONG(RGB640_INDEX_DATA, (ULONG)(data)); \
    RGB640_DELAY; \
}

#define RGB640_READ_CURSOR_ARRAY(data) \
{ \
    data = (UCHAR)(READ_640REG_ULONG (RGB640_INDEX_DATA) & 0xff); \
    RGB640_DELAY; \
}

// macro to move the cursor
//
#define RGB640_MOVE_CURSOR(x, y) \
{ \
    RGB640_INDEX_REG (RGB640_CURSOR_X_LOW); \
    RGB640_LOAD_DATA ((ULONG)((x) & 0xff)); \
    RGB640_LOAD_DATA ((ULONG)((x) >> 8));   \
    RGB640_LOAD_DATA ((ULONG)((y) & 0xff)); \
    RGB640_LOAD_DATA ((ULONG)((y) >> 8));   \
}

// macro to change the cursor hotspot
//
#define RGB640_CURSOR_HOTSPOT(x, y) \
{ \
    RGB640_INDEX_REG (RGB640_CURSOR_X_HOT_SPOT); \
    RGB640_LOAD_DATA ((ULONG)(x));               \
    RGB640_LOAD_DATA ((ULONG)(y));               \
}
    
// macro to change the cursor color
//
#define RGB640_CURSOR_COLOR(red, green, blue) \
{ \
    WRITE_640REG_ULONG(RGB640_INDEX_ADDR_HI,   (ULONG)(0x4800 >> 8));    \
    RGB640_DELAY; \
    WRITE_640REG_ULONG(RGB640_INDEX_ADDR_LO,   (ULONG)(0x4800 & 0xff));    \
    RGB640_DELAY; \
    WRITE_640REG_ULONG(RGB640_INDEX_DATA, (ULONG)(red)); \
    RGB640_DELAY; \
    WRITE_640REG_ULONG(RGB640_INDEX_DATA, (ULONG)(data)); \
    RGB640_DELAY; \
    WRITE_640REG_ULONG(RGB640_INDEX_DATA, (ULONG)(green)); \
    RGB640_DELAY; \
}
    


//
// RGB640 internal register indexes
//

//
// These are the same as for the 525 so we use 525 definitions when getting
// RGBxxx Dac ids.
//
//#define RGB640_REVISION_LEVEL           0x0000
//#define RGB640_ID                       0x0001

#define RGB640_SERIALIZER_PIXEL_07_00   0x0002
#define RGB640_SERIALIZER_PIXEL_15_08   0x0003
#define RGB640_SERIALIZER_PIXEL_23_16   0x0004
#define RGB640_SERIALIZER_PIXEL_31_24   0x0005
#define RGB640_SERIALIZER_WID_03_00     0x0006
#define RGB640_SERIALIZER_WID_07_04     0x0007
#define RGB640_SERIALIZER_MODE          0x0008

#define RGB640_PIXEL_INTERLEAVE         0x0009
#define RGB640_MISC_CONFIG              0x000A
#define RGB640_VGA_CONTROL              0x000B
#define RGB640_DAC_COMPARE_MONITOR_ID   0x000C
#define RGB640_DAC_CONTROL              0x000D
#define RGB640_UPDATE_CONTROL           0x000E
#define RGB640_SYNC_CONTROL             0x000F
#define RGB640_VIDEO_PLL_REF_DIV        0x0010
#define RGB640_VIDEO_PLL_MULT           0x0011
#define RGB640_VIDEO_PLL_OUTPUT_DIV     0x0012
#define RGB640_VIDEO_PLL_CONTROL        0x0013
#define RGB640_VIDEO_AUX_REF_DIV        0x0014
#define RGB640_VIDEO_AUX_MULT           0x0015
#define RGB640_VIDEO_AUX_OUTPUT_DIV     0x0016
#define RGB640_VIDEO_AUX_CONTROL        0x0017

#define RGB640_CHROMA_KEY_0             0x0020
#define RGB640_CHROMA_KEY_MASK_0        0x0021
#define RGB640_CHROMA_KEY_1             0x0022
#define RGB640_CHROMA_KEY_MASK_1        0x0023
#define RGB640_CHROMA_KEY_0             0x0020
#define RGB640_CHROMA_KEY_0             0x0020

// RGB640 Internal Cursor Registers
#define RGB640_CURSOR_XHAIR_CONTROL     0x0030
#define RGB640_CURSOR_BLINK_RATE        0x0031
#define RGB640_CURSOR_BLINK_DUTY_CYCLE  0x0032
#define RGB640_CURSOR_X_LOW             0x0040
#define RGB640_CURSOR_X_HIGH            0x0041
#define RGB640_CURSOR_Y_LOW             0x0042
#define RGB640_CURSOR_Y_HIGH            0x0043
#define RGB640_CURSOR_X_HOT_SPOT        0x0044
#define RGB640_CURSOR_Y_HOT_SPOT        0x0045
#define RGB640_ADV_CURSOR_COLOR_0       0x0046
#define RGB640_ADV_CURSOR_COLOR_1       0x0047
#define RGB640_ADV_CURSOR_COLOR_2       0x0048
#define RGB640_ADV_CURSOR_COLOR_3       0x0049
#define RGB640_ADV_CURSOR_ATTR_TABLE    0x004A
#define RGB640_CURSOR_CONTROL           0x004B
#define RGB640_XHAIR_X_LOW              0x0050
#define RGB640_XHAIR_X_HIGH             0x0051
#define RGB640_XHAIR_Y_LOW              0x0052
#define RGB640_XHAIR_Y_HIGH             0x0053
#define RGB640_XHAIR_PATTERN_COLOR      0x0054
#define RGB640_XHAIR_HORZ_PATTERN       0x0055
#define RGB640_XHAIR_VERT_PATTERN       0x0056
#define RGB640_XHAIR_CONTROL_1          0x0057
#define RGB640_XHAIR_CONTROL_2          0x0058

#define RGB640_YUV_COEFFICIENT_K1       0x0070
#define RGB640_YUV_COEFFICIENT_K2       0x0071
#define RGB640_YUV_COEFFICIENT_K3       0x0072
#define RGB640_YUV_COEFFICIENT_K4       0x0073

#define RGB640_VRAM_MASK_REG_0          0x00F0
#define RGB640_VRAM_MASK_REG_1          0x00F1
#define RGB640_VRAM_MASK_REG_2          0x00F2

#define RGB640_DIAGNOSTICS              0x00FA
#define RGB640_MISR_CONTOL_STATUS       0x00FB
#define RGB640_MISR_SIGNATURE_0         0x00FC
#define RGB640_MISR_SIGNATURE_1         0x00FD
#define RGB640_MISR_SIGNATURE_2         0x00FE
#define RGB640_MISR_SIGNATURE_3         0x00FF

#define RGB640_FRAMEBUFFER_WAT(n)       (0x0100 + (n))
#define RGB640_OVERLAY_WAT(n)           (0x0200 + (n))
#define RGB640_CURSOR_PIXEL_MAP_WR(n)   (0x1000 + (n))
#define RGB640_CURSOR_PIXEL_MAP_RD(n)   (0x2000 + (n))

#define RGB640_MAIN_COLOR_PAL_WR(n)     (0x4000 + (n))

#define RGB640_CURSOR_COLOR_0_WR        0x4800
#define RGB640_CURSOR_COLOR_1_WR        0x4801
#define RGB640_CURSOR_COLOR_2_WR        0x4802
#define RGB640_CURSOR_COLOR_3_WR        0x4803
#define RGB640_ALT_CURSOR_COLOR_0_WR    0x4804
#define RGB640_ALT_CURSOR_COLOR_1_WR    0x4805
#define RGB640_ALT_CURSOR_COLOR_2_WR    0x4806
#define RGB640_ALT_CURSOR_COLOR_3_WR    0x4807
#define RGB640_XHAIR_COLOR_0_WR         0x4808
#define RGB640_XHAIR_COLOR_1_WR         0x4809
#define RGB640_XHAIR_COLOR_2_WR         0x480A
#define RGB640_XHAIR_COLOR_3_WR         0x480B
#define RGB640_ALT_XHAIR_COLOR_0_WR     0x480C
#define RGB640_ALT_XHAIR_COLOR_1_WR     0x480D
#define RGB640_ALT_XHAIR_COLOR_2_WR     0x480E
#define RGB640_ALT_XHAIR_COLOR_3_WR     0x480F

#define RGB640_MAIN_COLOR_PAL_RD(n)     (0x8000 + (n))

#define RGB640_CURSOR_COLOR_0_RD        0x8800
#define RGB640_CURSOR_COLOR_1_RD        0x8801
#define RGB640_CURSOR_COLOR_2_RD        0x8802
#define RGB640_CURSOR_COLOR_3_RD        0x8803
#define RGB640_ALT_CURSOR_COLOR_0_RD    0x8804
#define RGB640_ALT_CURSOR_COLOR_1_RD    0x8805
#define RGB640_ALT_CURSOR_COLOR_2_RD    0x8806
#define RGB640_ALT_CURSOR_COLOR_3_RD    0x8807
#define RGB640_XHAIR_COLOR_0_RD         0x8808
#define RGB640_XHAIR_COLOR_1_RD         0x8809
#define RGB640_XHAIR_COLOR_2_RD         0x880A
#define RGB640_XHAIR_COLOR_3_RD         0x880B
#define RGB640_ALT_XHAIR_COLOR_0_RD     0x880C
#define RGB640_ALT_XHAIR_COLOR_1_RD     0x880D
#define RGB640_ALT_XHAIR_COLOR_2_RD     0x880E
#define RGB640_ALT_XHAIR_COLOR_3_RD     0x880F


//
// Bit definitions for individual internal RGB640 registers
//

// RGB640_REVISION_LEVEL
#define RGB640_IDENTIFICATION_CODE      0x1c

// RGB640_ID
#define RGB640_ID_REVISION_LEVEL        (0x02 | (0x01 << 4))

// Cursor definitions
//

#define RGB640_CURSOR_PARTITION_0       0
#define RGB640_CURSOR_PARTITION_1       (1 << 6)
#define RGB640_CURSOR_PARTITION_2       (2 << 6)
#define RGB640_CURSOR_PARTITION_3       (3 << 6)
#define RGB640_CURSOR_SIZE_32           0x0
#define RGB640_CURSOR_SIZE_64           (1 << 3)
#define RGB640_CURSOR_BLINK_OFF         0
#define RGB640_CURSOR_BLINK_ON          (1 << 5)
#define RGB640_CURSOR_MODE_OFF          0
#define RGB640_CURSOR_MODE_0            1
#define RGB640_CURSOR_MODE_1            2
#define RGB640_CURSOR_MODE_2            3
#define RGB640_CURSOR_MODE_ADVANCED     4

// we only ever use a two color cursor so define registers and enable bits.
// for each 2 bit pixel that defines the cursor shape, bit 0x2 defines the
// foreground and bit 0x1 defines the background.
// NB: the transparent cursor pixel value depends on the cursor mode chosen.
//
#define RGB640_CURSOR_MODE_ON           RGB640_CURSOR_MODE_1
#define RGB640_CURSOR_TRANSPARENT_PEL   0xAA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\surf_fmt.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: surf_fmt.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef __SURF_FMAT
#define __SURF_FMAT


#define LOG_2_32 5
#define LOG_2_16 4
#define LOG_2_8 3
#define LOG_2_4 2
#define LOG_2_2 1
#define LOG_2_1 0

typedef enum tagTextureColorComponents
{
    RGB_COMPONENTS = 2,
    RGBA_COMPONENTS = 3,
    COMPONENTS_DONT_CARE = 100
} TextureColorComponents;

typedef enum tagSurfDeviceFormat
{
    SURF_8888 = 0,
    SURF_5551_FRONT = 1,
    SURF_4444 = 2,
    SURF_4444_FRONT = 3,
    SURF_4444_BACK = 4,
    SURF_332_FRONT = 5,
    SURF_332_BACK = 6,
    SURF_121_FRONT = 7,
    SURF_121_BACK = 8,
    SURF_2321_FRONT = 9,
    SURF_2321_BACK = 10,
    SURF_232_FRONTOFF = 11,
    SURF_232_BACKOFF = 12,
    SURF_5551_BACK = 13,
    SURF_CI8 = 14,
    SURF_CI4 = 15,
    SURF_565_FRONT = 16,
    SURF_565_BACK = 17,
    SURF_YUV444 = 18,
    SURF_YUV422 = 19,

    // NB: These surface formats are needed for the luminance
    // texturemap formats.  Note that you should never load the below
    // values into the blitter's, etc. because the texture filter unit
    // is the only one that knows about these formats.  This is why the 
    // formats start at 100
    SURF_L8 = 100,
    SURF_A8L8 = 101,
    SURF_A4L4 = 102,
    SURF_A8 = 103,

    // More fantasy formats.  This time they are for Mediamatics playback
    SURF_MVCA = 104,
    SURF_MVSU = 105,
    SURF_MVSB = 106,
    SURF_FORMAT_INVALID = 0xFFFFFFFF
} SurfDeviceFormat;

typedef enum tagSurfFilterDeviceFormat
{
    SURF_FILTER_A4L4 = 0,
    SURF_FILTER_L8 = 1,
    SURF_FILTER_I8 = 2,
    SURF_FILTER_A8 = 3,
    SURF_FILTER_332 = 4,
    SURF_FILTER_A8L8 = 5,
    SURF_FILTER_5551 = 6,
    SURF_FILTER_565 = 7,
    SURF_FILTER_4444 = 8,
    SURF_FILTER_888 = 9,
    SURF_FILTER_8888_OR_YUV = 10,
    SURF_FILTER_INVALID = 0xFFFFFFFF
} SurfFilterDeviceFormat;    

typedef enum tagSurfDitherDeviceFormat
{
    SURF_DITHER_8888    = P3RX_DITHERMODE_COLORFORMAT_8888,
    SURF_DITHER_4444    = P3RX_DITHERMODE_COLORFORMAT_4444,
    SURF_DITHER_5551    = P3RX_DITHERMODE_COLORFORMAT_5551,
    SURF_DITHER_565     = P3RX_DITHERMODE_COLORFORMAT_565,
    SURF_DITHER_332     = P3RX_DITHERMODE_COLORFORMAT_332,
    SURF_DITHER_I8      = P3RX_DITHERMODE_COLORFORMAT_CI,
    SURF_DITHER_INVALID = 0xFFFFFFFF
} SurfDitherDeviceFormat;

// A structure representing a particular surface format to use.
typedef const struct tagSURF_FORMAT
{
    SurfDeviceFormat            DeviceFormat;        // The number in the manual for this format
    DWORD                       dwBitsPerPixel;        // The bits per pixel
    DWORD                       dwChipPixelSize;    // The pixel size register on the chip
    TextureColorComponents      ColorComponents;    // The number of color components for this format
    DWORD                       dwLogPixelDepth;    // The log of the pixel depth (log2(16), etc)
    DWORD                       dwRedMask;            // The Red Mask
    DWORD                       dwGreenMask;        // The Green Mask
    DWORD                       dwBlueMask;            // The Blue Mask
    DWORD                       dwAlphaMask;        // The Alpha Mask
    BOOL                        bAlpha;                // Are we using the alpha in this format?
    SurfFilterDeviceFormat      FilterFormat;        // For feeding the P3RX filter unit.
    SurfDitherDeviceFormat      DitherFormat;        // For feeding the P3RX dither unit.
    char                        *pszStringFormat;    // Human-readable string for debugging.
} P3_SURF_FORMAT;

#define SURFFORMAT_FORMAT_BITS(pSurfFormat) (((DWORD)(pSurfFormat)->DeviceFormat) & 0xF)
#define SURFFORMAT_FORMATEXTENSION_BITS(pSurfFormat) (((DWORD)(pSurfFormat)->DeviceFormat & 0x10) >> 4)
#define SURFFORMAT_PIXELSIZE(pSurfFormat) ((pSurfFormat)->dwChipPixelSize)

#define MAX_SURFACE_FORMATS 50

#endif // __SURF_FMAT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\tag.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: tag.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef __TAG_H
#define __TAG_H

#ifndef _TAG_H_
#define _TAG_H_

#define StartXDom_Tag 0x0000
#define dXDom_Tag 0x0001
#define StartXSub_Tag 0x0002
#define dXSub_Tag 0x0003
#define StartY_Tag 0x0004
#define dY_Tag 0x0005
#define Count_Tag 0x0006
#define Render_Tag 0x0007
#define ContinueNewLine_Tag 0x0008
#define ContinueNewDom_Tag 0x0009
#define ContinueNewSub_Tag 0x000a
#define Continue_Tag 0x000b
#define FlushSpan_Tag 0x000c
#define BitMaskPattern_Tag 0x000d
#define PointTable0_Tag 0x0010
#define PointTable1_Tag 0x0011
#define PointTable2_Tag 0x0012
#define PointTable3_Tag 0x0013
#define RasterizerMode_Tag 0x0014
#define YLimits_Tag 0x0015
#define ScanlineOwnership_Tag 0x0016
#define WaitForCompletion_Tag 0x0017
#define PixelSize_Tag 0x0018
#define XLimits_Tag 0x0019
#define StripeOffsetY_Tag 0x0019
#define RectangleOrigin_Permedia_Tag 0x001a
#define RectangleSize_Tag 0x001b
#define ReadMonitorMode_Tag 0x001f
#define FastBlockLimits_Tag 0x0026
#define FastBlockFill_Tag 0x0027
#define ForceBackgroundColor_Tag 0x0029
#define PackedDataLimits_Tag 0x002a
#define ScissorMode_Tag 0x0030
#define ScissorMinXY_Tag 0x0031
#define ScissorMaxXY_Tag 0x0032
#define ScreenSize_Tag 0x0033
#define AreaStippleMode_Tag 0x0034
#define LineStippleMode_Tag 0x0035
#define LoadLineStippleCounters_Tag 0x0036
#define UpdateLineStippleCounters_Tag 0x0037
#define SaveLineStippleCounters_Tag 0x0038
#define SaveLineStippleState_Tag 0x0038
#define WindowOrigin_Tag 0x0039
#define AreaStipplePattern0_Tag 0x0040
#define AreaStipplePattern1_Tag 0x0041
#define AreaStipplePattern2_Tag 0x0042
#define AreaStipplePattern3_Tag 0x0043
#define AreaStipplePattern4_Tag 0x0044
#define AreaStipplePattern5_Tag 0x0045
#define AreaStipplePattern6_Tag 0x0046
#define AreaStipplePattern7_Tag 0x0047
#define AreaStipplePattern8_Tag 0x0048
#define AreaStipplePattern9_Tag 0x0049
#define AreaStipplePattern10_Tag 0x004a
#define AreaStipplePattern11_Tag 0x004b
#define AreaStipplePattern12_Tag 0x004c
#define AreaStipplePattern13_Tag 0x004d
#define AreaStipplePattern14_Tag 0x004e
#define AreaStipplePattern15_Tag 0x004f
#define AreaStipplePattern16_Tag 0x0050
#define AreaStipplePattern17_Tag 0x0051
#define AreaStipplePattern18_Tag 0x0052
#define AreaStipplePattern19_Tag 0x0053
#define AreaStipplePattern20_Tag 0x0054
#define AreaStipplePattern21_Tag 0x0055
#define AreaStipplePattern22_Tag 0x0056
#define AreaStipplePattern23_Tag 0x0057
#define AreaStipplePattern24_Tag 0x0058
#define AreaStipplePattern25_Tag 0x0059
#define AreaStipplePattern26_Tag 0x005a
#define AreaStipplePattern27_Tag 0x005b
#define AreaStipplePattern28_Tag 0x005c
#define AreaStipplePattern29_Tag 0x005d
#define AreaStipplePattern30_Tag 0x005e
#define AreaStipplePattern31_Tag 0x005f
#define FillFBWriteBufferAddr0_Tag 0x0060
#define FillFBSourceReadBufferAddr_Tag 0x0061
#define FillFBDestReadBufferAddr0_Tag 0x0062
#define FillScissorMinXY_Tag 0x0063
#define FillScissorMaxXY_Tag 0x0064
#define FillForegroundColor0_Tag 0x0065
#define FillBackgroundColor_Tag 0x0066
#define FillConfig2D0_Tag 0x0067
#define FillFBSourceReadBufferOffset_Tag 0x0068
#define FillRectanglePosition_Tag 0x0069
#define FillRender2D_Tag 0x006a
#define FillForegroundColor1_Tag 0x006b
#define FillConfig2D1_Tag 0x006c
#define FillGlyphPosition_Tag 0x006d
#define TextureAddressMode_Tag 0x0070
#define TextureCoordMode_Tag 0x0070
#define SStart_Tag 0x0071
#define dSdx_Tag 0x0072
#define dSdyDom_Tag 0x0073
#define TStart_Tag 0x0074
#define dTdx_Tag 0x0075
#define dTdyDom_Tag 0x0076
#define QStart_Tag 0x0077
#define dQdx_Tag 0x0078
#define dQdyDom_Tag 0x0079
#define LOD_Tag 0x007a
#define dSdy_Tag 0x007b
#define dTdy_Tag 0x007c
#define dQdy_Tag 0x007d
#define S1Start_Tag 0x0080
#define TexelCoordUV_Tag 0x0081
#define dS1dx_Tag 0x0081
#define TexelCoordU_Tag 0x0082
#define dS1dyDom_Tag 0x0082
#define TexelCoordV_Tag 0x0083
#define T1Start_Tag 0x0083
#define dT1dx_Tag 0x0084
#define dT1dyDom_Tag 0x0085
#define Q1Start_Tag 0x0086
#define dQ1dx_Tag 0x0087
#define dQ1dyDom_Tag 0x0088
#define LOD1_Tag 0x0089
#define TextureLODBiasS_Tag 0x008a
#define TextureLODBiasT_Tag 0x008b
#define TextureReadMode_Tag 0x0090
#define TextureFormat_Tag 0x0091
#define TextureCacheControl_Tag 0x0092
#define BorderColor_Tag 0x0095
#define BorderColor0_Tag 0x0095
#define TexelLUTIndex_Tag 0x0098
#define LUTIndex_Tag 0x0098
#define TexelLUTData_Tag 0x0099
#define LUTData_Tag 0x0099
#define TexelLUTAddress_Tag 0x009a
#define LUTAddress_Tag 0x009a
#define TexelLUTTransfer_Tag 0x009b
#define LUTTransfer_Tag 0x009b
#define TextureFilterMode_Tag 0x009c
#define TextureChromaUpper_Tag 0x009d
#define TextureChromaUpper0_Tag 0x009d
#define TextureChromaLower_Tag 0x009e
#define TextureChromaLower0_Tag 0x009e
#define BorderColor1_Tag 0x009f
#define TextureBaseAddress_Tag 0x00a0
#define TextureBaseAddr0_Tag 0x00a0
#define TextureBaseAddressLR_Tag 0x00a1
#define TextureBaseAddr1_Tag 0x00a1
#define TextureBaseAddr2_Tag 0x00a2
#define TextureBaseAddr3_Tag 0x00a3
#define TextureBaseAddr4_Tag 0x00a4
#define TextureBaseAddr5_Tag 0x00a5
#define TextureBaseAddr6_Tag 0x00a6
#define TextureBaseAddr7_Tag 0x00a7
#define TextureBaseAddr8_Tag 0x00a8
#define TextureBaseAddr9_Tag 0x00a9
#define TextureBaseAddr10_Tag 0x00aa
#define TextureBaseAddr11_Tag 0x00ab
#define TextureBaseAddr12_Tag 0x00ac
#define TextureBaseAddr13_Tag 0x00ad
#define TextureBaseAddr14_Tag 0x00ae
#define TextureBaseAddr15_Tag 0x00af
#define TextureBaseAddress_Permedia_Tag 0x00b0
#define TextureMapWidth0_Tag 0x00b0
#define TextureMapFormat_Tag 0x00b1
#define TextureMapWidth1_Tag 0x00b1
#define TextureDataFormat_Tag 0x00b2
#define TextureMapWidth2_Tag 0x00b2
#define TextureMapWidth3_Tag 0x00b3
#define TextureMapWidth4_Tag 0x00b4
#define TextureReadPad_Tag 0x00b5
#define TextureMapWidth5_Tag 0x00b5
#define TextureMapWidth6_Tag 0x00b6
#define TextureMapWidth7_Tag 0x00b7
#define TextureMapWidth8_Tag 0x00b8
#define TextureMapWidth9_Tag 0x00b9
#define TextureMapWidth10_Tag 0x00ba
#define TextureMapWidth11_Tag 0x00bb
#define TextureMapWidth12_Tag 0x00bc
#define TextureMapWidth13_Tag 0x00bd
#define TextureMapWidth14_Tag 0x00be
#define TextureMapWidth15_Tag 0x00bf
#define Texel0_Tag 0x00c0
#define TextureChromaUpper1_Tag 0x00c0
#define TextureChromaLower1_Tag 0x00c1
#define TextureFilter_Tag 0x00cd
#define TextureReadMode_Permedia_Tag 0x00ce
#define TexelLUTMode_Tag 0x00cf
#define TextureColorMode_Tag 0x00d0
#define TextureApplicationMode_Tag 0x00d0
#define TextureEnvColor_Tag 0x00d1
#define FogMode_Tag 0x00d2
#define FogColor_Tag 0x00d3
#define FStart_Tag 0x00d4
#define dFdx_Tag 0x00d5
#define dFdyDom_Tag 0x00d6
#define ZFogBias_Tag 0x00d7
#define KsStart_Tag 0x00d9
#define dKsdx_Tag 0x00da
#define dKsdyDom_Tag 0x00db
#define KdStart_Tag 0x00dc
#define dKddx_Tag 0x00dd
#define dKddyDom_Tag 0x00de
#define TextTGlyphAddr0_Tag 0x00e0
#define TextRender2DGlyph0_Tag 0x00e1
#define TextTGlyphAddr1_Tag 0x00e2
#define TextRender2DGlyph1_Tag 0x00e3
#define TextTGlyphAddr2_Tag 0x00e4
#define TextRender2DGlyph2_Tag 0x00e5
#define TextTGlyphAddr3_Tag 0x00e6
#define TextRender2DGlyph3_Tag 0x00e7
#define TextTGlyphAddr4_Tag 0x00e8
#define TextRender2DGlyph4_Tag 0x00e9
#define TextTGlyphAddr5_Tag 0x00ea
#define TextRender2DGlyph5_Tag 0x00eb
#define TextTGlyphAddr6_Tag 0x00ec
#define TextRender2DGlyph6_Tag 0x00ed
#define TextTGlyphAddr7_Tag 0x00ee
#define TextRender2DGlyph7_Tag 0x00ef
#define RStart_Tag 0x00f0
#define dRdx_Tag 0x00f1
#define dRdyDom_Tag 0x00f2
#define GStart_Tag 0x00f3
#define dGdx_Tag 0x00f4
#define dGdyDom_Tag 0x00f5
#define BStart_Tag 0x00f6
#define dBdx_Tag 0x00f7
#define dBdyDom_Tag 0x00f8
#define AStart_Tag 0x00f9
#define dAdx_Tag 0x00fa
#define dAdyDom_Tag 0x00fb
#define ColorDDAMode_Tag 0x00fc
#define ConstantColor_Tag 0x00fd
#define Color_Tag 0x00fe
#define AlphaTestMode_Tag 0x0100
#define AntialiasMode_Tag 0x0101
#define AlphaBlendMode_Tag 0x0102
#define DitherMode_Tag 0x0103
#define FBSoftwareWriteMask_Tag 0x0104
#define LogicalOpMode_Tag 0x0105
#define RouterMode_Tag 0x0108
#define LBReadMode_Tag 0x0110
#define LBReadFormat_Tag 0x0111
#define LBSourceOffset_Tag 0x0112
#define LBSourceData_Tag 0x0114
#define LBStencil_Tag 0x0115
#define LBDepth_Tag 0x0116
#define LBWindowBase_Tag 0x0117
#define LBWriteMode_Tag 0x0118
#define LBWriteFormat_Tag 0x0119
#define LBWriteBase_Tag 0x011a
#define LBWriteConfig_Tag 0x011b
#define TextureData_Tag 0x011d
#define TextureDownloadOffset_Tag 0x011e
#define LBWindowOffset_Tag 0x011f
#define HostInID_Tag 0x0120
#define Security_Tag 0x0121
#define FlushWriteCombining_Tag 0x0122
#define HostInState_Tag 0x0123
#define HostInDMAAddress_Tag 0x0127
#define HostInState2_Tag 0x0128
#define VertexRename_Tag 0x012f
#define Window_Tag 0x0130
#define StencilMode_Tag 0x0131
#define StencilData_Tag 0x0132
#define Stencil_Tag 0x0133
#define DepthMode_Tag 0x0134
#define Depth_Tag 0x0135
#define ZStartU_Tag 0x0136
#define ZStartL_Tag 0x0137
#define dZdxU_Tag 0x0138
#define dZdxL_Tag 0x0139
#define dZdyDomU_Tag 0x013a
#define dZdyDomL_Tag 0x013b
#define FastClearDepth_Tag 0x013c
#define LBCancelWrite_Tag 0x013d
#define LBWriteData_Tag 0x013e
#define FBReadMode_Tag 0x0150
#define FBSourceOffset_Tag 0x0151
#define FBPixelOffset_Tag 0x0152
#define FBColor_Tag 0x0153
#define FBData_Tag 0x0154
#define FBSourceData_Tag 0x0155
#define FBWindowBase_Tag 0x0156
#define FBWriteMode_Tag 0x0157
#define FBHardwareWriteMask_Tag 0x0158
#define FBBlockColor_Tag 0x0159
#define FBReadPixel_Tag 0x015a
#define FBWritePixel_Tag 0x015b
#define FBWriteBase_Tag 0x015c
#define FBWriteConfig_Tag 0x015d
#define FBReadPad_Tag 0x015e
#define PatternRAMMode_Tag 0x015f
#define PatternRAMData0_Tag 0x0160
#define PatternRAMData1_Tag 0x0161
#define PatternRAMData2_Tag 0x0162
#define PatternRAMData3_Tag 0x0163
#define PatternRAMData4_Tag 0x0164
#define PatternRAMData5_Tag 0x0165
#define PatternRAMData6_Tag 0x0166
#define PatternRAMData7_Tag 0x0167
#define PatternRAMData8_Tag 0x0168
#define PatternRAMData9_Tag 0x0169
#define PatternRAMData10_Tag 0x016a
#define PatternRAMData11_Tag 0x016b
#define PatternRAMData12_Tag 0x016c
#define PatternRAMData13_Tag 0x016d
#define PatternRAMData14_Tag 0x016e
#define PatternRAMData15_Tag 0x016f
#define PatternRAMData16_Tag 0x0170
#define PatternRAMData17_Tag 0x0171
#define PatternRAMData18_Tag 0x0172
#define PatternRAMData19_Tag 0x0173
#define PatternRAMData20_Tag 0x0174
#define PatternRAMData21_Tag 0x0175
#define PatternRAMData22_Tag 0x0176
#define PatternRAMData23_Tag 0x0177
#define PatternRAMData24_Tag 0x0178
#define PatternRAMData25_Tag 0x0179
#define PatternRAMData26_Tag 0x017a
#define PatternRAMData27_Tag 0x017b
#define PatternRAMData28_Tag 0x017c
#define PatternRAMData29_Tag 0x017d
#define PatternRAMData30_Tag 0x017e
#define PatternRAMData31_Tag 0x017f
#define FilterMode_Tag 0x0180
#define StatisticMode_Tag 0x0181
#define MinRegion_Tag 0x0182
#define MaxRegion_Tag 0x0183
#define ResetPickResult_Tag 0x0184
#define MinHitRegion_Tag 0x0185
#define MaxHitRegion_Tag 0x0186
#define PickResult_Tag 0x0187
#define Sync_Tag 0x0188
#define RLEMask_Tag 0x0189
#define FBBlockColorBackU_Tag 0x018b
#define FBBlockColorBackL_Tag 0x018c
#define FBBlockColorU_Tag 0x018d
#define FBBlockColorL_Tag 0x018e
#define SuspendUntilFrameBlank_Tag 0x018f
#define KsRStart_Tag 0x0190
#define dKsRdx_Tag 0x0191
#define dKsRdyDom_Tag 0x0192
#define KsGStart_Tag 0x0193
#define dKsGdx_Tag 0x0194
#define dKsGdyDom_Tag 0x0195
#define KsBStart_Tag 0x0196
#define dKsBdx_Tag 0x0197
#define dKsBdyDom_Tag 0x0198
#define KdRStart_Tag 0x01a0
#define dKdRdx_Tag 0x01a1
#define dKdRdyDom_Tag 0x01a2
#define KdGStart_Tag 0x01a3
#define dKdGdx_Tag 0x01a4
#define dKdGdyDom_Tag 0x01a5
#define KdBStart_Tag 0x01a6
#define dKdBdx_Tag 0x01a7
#define dKdBdyDom_Tag 0x01a8
#define FBSourceBase_Tag 0x01b0
#define FBSourceDelta_Tag 0x01b1
#define Config_Tag 0x01b2
#define ContextDump_Tag 0x01b8
#define ContextRestore_Tag 0x01b9
#define ContextData_Tag 0x01ba
#define TexelLUT0_Tag 0x01d0
#define TexelLUT1_Tag 0x01d1
#define TexelLUT2_Tag 0x01d2
#define TexelLUT3_Tag 0x01d3
#define TexelLUT4_Tag 0x01d4
#define TexelLUT5_Tag 0x01d5
#define TexelLUT6_Tag 0x01d6
#define TexelLUT7_Tag 0x01d7
#define TexelLUT8_Tag 0x01d8
#define TexelLUT9_Tag 0x01d9
#define TexelLUT10_Tag 0x01da
#define TexelLUT11_Tag 0x01db
#define TexelLUT12_Tag 0x01dc
#define TexelLUT13_Tag 0x01dd
#define TexelLUT14_Tag 0x01de
#define TexelLUT15_Tag 0x01df
#define LUT0_Tag 0x01d0
#define LUT1_Tag 0x01d1
#define LUT2_Tag 0x01d2
#define LUT3_Tag 0x01d3
#define LUT4_Tag 0x01d4
#define LUT5_Tag 0x01d5
#define LUT6_Tag 0x01d6
#define LUT7_Tag 0x01d7
#define LUT8_Tag 0x01d8
#define LUT9_Tag 0x01d9
#define LUT10_Tag 0x01da
#define LUT11_Tag 0x01db
#define LUT12_Tag 0x01dc
#define LUT13_Tag 0x01dd
#define LUT14_Tag 0x01de
#define LUT15_Tag 0x01df
#define YUVMode_Tag 0x01e0
#define ChromaUpperBound_Tag 0x01e1
#define ChromaUpper_Tag 0x01e1
#define ChromaLowerBound_Tag 0x01e2
#define ChromaLower_Tag 0x01e2
#define ChromaTestMode_Tag 0x01e3
#define AlphaMapUpperBound_Tag 0x01e3
#define AlphaMapLowerBound_Tag 0x01e4
#define TextureID_Tag 0x01ee
#define TexelLUTID_Tag 0x01ef
#define FeedbackToken_Tag 0x01f0
#define FeedbackX_Tag 0x01f1
#define FeedbackY_Tag 0x01f2
#define FeedbackZ_Tag 0x01f3
#define FeedbackW_Tag 0x01f4
#define FeedbackRed_Tag 0x01f5
#define FeedbackGreen_Tag 0x01f6
#define FeedbackBlue_Tag 0x01f7
#define FeedbackAlpha_Tag 0x01f8
#define FeedbackS_Tag 0x01f9
#define FeedbackT_Tag 0x01fa
#define FeedbackR_Tag 0x01fb
#define FeedbackQ_Tag 0x01fc
#define SelectRecord_Tag 0x01fd
#define PassThrough_Tag 0x01fe
#define EndOfFeedback_Tag 0x01ff
#define V0FixedS_Tag 0x0200
#define V0FloatS1_Tag 0x0200
#define V0FixedT_Tag 0x0201
#define V0FloatT1_Tag 0x0201
#define V0FixedQ_Tag 0x0202
#define V0FloatQ1_Tag 0x0202
#define V0FixedKs_Tag 0x0203
#define V0Reserved0_Tag 0x0203
#define V0FixedKd_Tag 0x0204
#define V0Reserved1_Tag 0x0204
#define V0FixedR_Tag 0x0205
#define V0Reserved2_Tag 0x0205
#define V0FixedG_Tag 0x0206
#define V0Reserved3_Tag 0x0206
#define V0FixedB_Tag 0x0207
#define V0Reserved4_Tag 0x0207
#define V0FixedA_Tag 0x0208
#define V0Reserved5_Tag 0x0208
#define V0FixedF_Tag 0x0209
#define V0FloatPackedDiffuse_Tag 0x0209
#define V0FixedX_Tag 0x020a
#define V0FloatKsR_Tag 0x020a
#define V0FixedY_Tag 0x020b
#define V0FloatKsG_Tag 0x020b
#define V0FixedZ_Tag 0x020c
#define V0FloatKsB_Tag 0x020c
#define V0FixedW_Tag 0x020d
#define V0FloatKdR_Tag 0x020d
#define V0FixedU1_Tag 0x020e
#define V0FixedPacked_Tag 0x020e
#define V0FloatKdG_Tag 0x020e
#define V0FixedU2_Tag 0x020f
#define V0FloatKdB_Tag 0x020f
#define V1FixedS_Tag 0x0210
#define V1FloatS1_Tag 0x0210
#define V1FixedT_Tag 0x0211
#define V1FloatT1_Tag 0x0211
#define V1FixedQ_Tag 0x0212
#define V1FloatQ1_Tag 0x0212
#define V1FixedKs_Tag 0x0213
#define V1Reserved0_Tag 0x0213
#define V1FixedKd_Tag 0x0214
#define V1Reserved1_Tag 0x0214
#define V1FixedR_Tag 0x0215
#define V1Reserved2_Tag 0x0215
#define V1FixedG_Tag 0x0216
#define V1Reserved3_Tag 0x0216
#define V1FixedB_Tag 0x0217
#define V1Reserved4_Tag 0x0217
#define V1FixedA_Tag 0x0218
#define V1Reserved5_Tag 0x0218
#define V1FixedF_Tag 0x0219
#define V1FloatPackedDiffuse_Tag 0x0219
#define V1FixedX_Tag 0x021a
#define V1FloatKsR_Tag 0x021a
#define V1FixedY_Tag 0x021b
#define V1FloatKsG_Tag 0x021b
#define V1FixedZ_Tag 0x021c
#define V1FloatKsB_Tag 0x021c
#define V1FixedW_Tag 0x021d
#define V1FloatKdR_Tag 0x021d
#define V1FixedU1_Tag 0x021e
#define V1FixedPacked_Tag 0x021e
#define V1FloatKdG_Tag 0x021e
#define V1FixedU2_Tag 0x021f
#define V1FloatKdB_Tag 0x021f
#define V2FixedS_Tag 0x0220
#define V2FloatS1_Tag 0x0220
#define V2FixedT_Tag 0x0221
#define V2FloatT1_Tag 0x0221
#define V2FixedQ_Tag 0x0222
#define V2FloatQ1_Tag 0x0222
#define V2FixedKs_Tag 0x0223
#define V2Reserved0_Tag 0x0223
#define V2FixedKd_Tag 0x0224
#define V2Reserved1_Tag 0x0224
#define V2FixedR_Tag 0x0225
#define V2Reserved2_Tag 0x0225
#define V2FixedG_Tag 0x0226
#define V2Reserved3_Tag 0x0226
#define V2FixedB_Tag 0x0227
#define V2Reserved4_Tag 0x0227
#define V2FixedA_Tag 0x0228
#define V2Reserved5_Tag 0x0228
#define V2FixedF_Tag 0x0229
#define V2FloatPackedDiffuse_Tag 0x0229
#define V2FixedX_Tag 0x022a
#define V2FloatKsR_Tag 0x022a
#define V2FixedY_Tag 0x022b
#define V2FloatKsG_Tag 0x022b
#define V2FixedZ_Tag 0x022c
#define V2FloatKsB_Tag 0x022c
#define V2FixedW_Tag 0x022d
#define V2FloatKdR_Tag 0x022d
#define V2FixedU1_Tag 0x022e
#define V2FixedPacked_Tag 0x022e
#define V2FloatKdG_Tag 0x022e
#define V2FixedU2_Tag 0x022f
#define V2FloatKdB_Tag 0x022f
#define V0FloatS_Tag 0x0230
#define V0FloatT_Tag 0x0231
#define V0FloatQ_Tag 0x0232
#define V0FloatKs_Tag 0x0233
#define V0Reserved7_Tag 0x0233
#define V0FloatKd_Tag 0x0234
#define V0Reserved8_Tag 0x0234
#define V0FloatR_Tag 0x0235
#define V0FloatG_Tag 0x0236
#define V0FloatB_Tag 0x0237
#define V0FloatA_Tag 0x0238
#define V0FloatF_Tag 0x0239
#define V0FloatX_Tag 0x023a
#define V0FloatY_Tag 0x023b
#define V0FloatZ_Tag 0x023c
#define V0FloatW_Tag 0x023d
#define V0FloatU1_Tag 0x023e
#define V0FloatPacked_Tag 0x023e
#define V0FloatPackedColour_Tag 0x023e
#define V0FloatU2_Tag 0x023f
#define V0FloatPackedSpecularFog_Tag 0x023f
#define V1FloatS_Tag 0x0240
#define V1FloatT_Tag 0x0241
#define V1FloatQ_Tag 0x0242
#define V1FloatKs_Tag 0x0243
#define V1Reserved7_Tag 0x0243
#define V1FloatKd_Tag 0x0244
#define V1Reserved8_Tag 0x0244
#define V1FloatR_Tag 0x0245
#define V1FloatG_Tag 0x0246
#define V1FloatB_Tag 0x0247
#define V1FloatA_Tag 0x0248
#define V1FloatF_Tag 0x0249
#define V1FloatX_Tag 0x024a
#define V1FloatY_Tag 0x024b
#define V1FloatZ_Tag 0x024c
#define V1FloatW_Tag 0x024d
#define V1FloatU1_Tag 0x024e
#define V1FloatPacked_Tag 0x024e
#define V1FloatPackedColour_Tag 0x024e
#define V1FloatU2_Tag 0x024f
#define V1FloatPackedSpecularFog_Tag 0x024f
#define V2FloatS_Tag 0x0250
#define V2FloatT_Tag 0x0251
#define V2FloatQ_Tag 0x0252
#define V2FloatKs_Tag 0x0253
#define V2Reserved7_Tag 0x0253
#define V2FloatKd_Tag 0x0254
#define V2Reserved8_Tag 0x0254
#define V2FloatR_Tag 0x0255
#define V2FloatG_Tag 0x0256
#define V2FloatB_Tag 0x0257
#define V2FloatA_Tag 0x0258
#define V2FloatF_Tag 0x0259
#define V2FloatX_Tag 0x025a
#define V2FloatY_Tag 0x025b
#define V2FloatZ_Tag 0x025c
#define V2FloatW_Tag 0x025d
#define V2FloatU1_Tag 0x025e
#define V2FloatPacked_Tag 0x025e
#define V2FloatPackedColour_Tag 0x025e
#define V2FloatU2_Tag 0x025f
#define V2FloatPackedSpecularFog_Tag 0x025f
#define DeltaMode_Tag 0x0260
#define DrawTriangle_Tag 0x0261
#define RepeatTriangle_Tag 0x0262
#define DrawLine01_Tag 0x0263
#define DrawLine10_Tag 0x0264
#define RepeatLine_Tag 0x0265
#define DrawPoint_Tag 0x0266
#define ProvokingVertex_Tag 0x0267
#define TextureLODScale_Tag 0x0268
#define TextureLODScale1_Tag 0x0269
#define DeltaControl_Tag 0x026a
#define ProvokingVertexMask_Tag 0x026b
#define RenderE_Tag 0x026c
#define EpilogTag_Tag 0x026d
#define EpilogData_Tag 0x026e
#define BroadcastMask_Tag 0x026f
#define DeltaCoord0_Tag 0x0270
#define DeltaCoord1_Tag 0x0271
#define DeltaCoord2_Tag 0x0272
#define DeltaCoord3_Tag 0x0273
#define DeltaColor0_Tag 0x0274
#define DeltaColor1_Tag 0x0275
#define DeltaColor2_Tag 0x0276
#define DeltaColor3_Tag 0x0277
#define DeltaTexture0_Tag 0x0278
#define DeltaTexture1_Tag 0x0279
#define DeltaTexture2_Tag 0x027a
#define DeltaTexture3_Tag 0x027b
#define DeltaTextureKs0_Tag 0x027c
#define DeltaTextureKs1_Tag 0x027d
#define DeltaTextureKs2_Tag 0x027e
#define DeltaTextureKs3_Tag 0x027f
#define DeltaTextureKd0_Tag 0x0280
#define DeltaTextureKd1_Tag 0x0281
#define DeltaTextureKd2_Tag 0x0282
#define DeltaTextureKd3_Tag 0x0283
#define DeltaCoordZ0_Tag 0x0284
#define DeltaCoordZ1_Tag 0x0285
#define DeltaCoordZ2_Tag 0x0286
#define DeltaCoordZ3_Tag 0x0287
#define V3FloatF_Tag 0x0288
#define V3FloatKs_Tag 0x0289
#define V3FloatKd_Tag 0x028a
#define DeltaTexture01_Tag 0x028b
#define Gw_Tag 0x028c
#define DeltaTexture11_Tag 0x028c
#define Gz_Tag 0x028d
#define DeltaTexture21_Tag 0x028d
#define Gy_Tag 0x028e
#define DeltaTexture31_Tag 0x028e
#define Gx_Tag 0x028f
#define XBias_Tag 0x0290
#define YBias_Tag 0x0291
#define PointMode_Tag 0x0292
#define PointSize_Tag 0x0293
#define AAPointSize_Tag 0x0294
#define LineMode_Tag 0x0295
#define LineWidth_Tag 0x0296
#define LineWidthOffset_Tag 0x0297
#define AALineWidth_Tag 0x0298
#define TriangleMode_Tag 0x0299
#define RectangleMode_Tag 0x029a
#define RectangleWidth_Tag 0x029b
#define RectangleHeight_Tag 0x029c
#define Rectangle2DMode_Tag 0x029d
#define Rectangle2DControl_Tag 0x029e
#define ZBias_Tag 0x029f
#define VertexMachineMode_Tag 0x02a0
#define TransformMode_Tag 0x02a1
#define GeometryMode_Tag 0x02a2
#define NormaliseMode_Tag 0x02a3
#define LightingMode_Tag 0x02a4
#define ColorMaterialMode_Tag 0x02a5
#define MaterialMode_Tag 0x02a6
#define FogVertexMode_Tag 0x02a7
#define TextureModeSelect_Tag 0x02a8
#define TextureMatrixSelect_Tag 0x02a9
#define TextureTexGenSelect_Tag 0x02aa
#define TextureMode_Tag 0x02ab
#define PipeMode_Tag 0x02ac
#define StripeFilterMode_Tag 0x02ad
#define MatrixMode_Tag 0x02ae
#define GammaFilter_Tag 0x02af
#define SelectResult_Tag 0x02b0
#define Begin_Tag 0x02b2
#define End_Tag 0x02b3
#define EdgeFlag_Tag 0x02b4
#define ObjectIDValue_Tag 0x02b5
#define IncrementObjectID_Tag 0x02b6
#define TransformCurrent_Tag 0x02b7
#define SendVector_Tag 0x02b8
#define SaveCurrent_Tag 0x02b9
#define RestoreCurrent_Tag 0x02ba
#define InitNames_Tag 0x02bb
#define PushName_Tag 0x02bc
#define PopName_Tag 0x02bd
#define LoadName_Tag 0x02be
#define Vertex_Tag 0x02c0
#define NextVertex_Tag 0x02d0
#define GeomPoint_Tag 0x02d1
#define GeomLine_Tag 0x02d2
#define GeomTriangle_Tag 0x02d3
#define GeomRectangle_Tag 0x02d4
#define ObjectID_Tag 0x02d5
#define UpdateRasterPos_Tag 0x02d6
#define ClippedColor_Tag 0x02d9
#define VertexColorFeedback_Tag 0x02da
#define ClippedColorFeedback_Tag 0x02db
#define Barycentric_Tag 0x02dc
#define DeltaFormatControl_Tag 0x02eb
#define LineCoord0_Tag 0x02ec
#define DrawLine2D10_Tag 0x02ed
#define LineCoord1_Tag 0x02ee
#define DrawLine2D01_Tag 0x02ef
#define RenderPoint_Tag 0x02f0
#define RenderLine_Tag 0x02f1
#define RenderTriangle_Tag 0x02f2
#define RenderRectangle_Tag 0x02f3
#define DrawRectangle2D_Tag 0x02f4
#define Nz_Tag 0x0300
#define Ny_Tag 0x0301
#define Nx_Tag 0x0302
#define Ca_Tag 0x0303
#define Cb_Tag 0x0304
#define Cg_Tag 0x0305
#define Cr3_Tag 0x0306
#define Cr4_Tag 0x0307
#define Tt2_Tag 0x0308
#define Ts2_Tag 0x0309
#define Vw_Tag 0x030a
#define Vz_Tag 0x030b
#define Vy_Tag 0x030c
#define Vx2_Tag 0x030d
#define Vx3_Tag 0x030e
#define Vx4_Tag 0x030f
#define FNz_Tag 0x0310
#define FNy_Tag 0x0311
#define FNx_Tag 0x0312
#define PackedColor3_Tag 0x0313
#define PackedColor4_Tag 0x0314
#define Tq4_Tag 0x0315
#define Tr4_Tag 0x0316
#define Tt4_Tag 0x0317
#define Ts4_Tag 0x0318
#define RPw_Tag 0x0319
#define RPz_Tag 0x031a
#define RPy_Tag 0x031b
#define RPx2_Tag 0x031c
#define RPx3_Tag 0x031d
#define RPx4_Tag 0x031e
#define Ts1_Tag 0x031f
#define ModelViewMatrix0_Tag 0x0320
#define ModelViewMatrix1_Tag 0x0321
#define ModelViewMatrix2_Tag 0x0322
#define ModelViewMatrix3_Tag 0x0323
#define ModelViewMatrix4_Tag 0x0324
#define ModelViewMatrix5_Tag 0x0325
#define ModelViewMatrix6_Tag 0x0326
#define ModelViewMatrix7_Tag 0x0327
#define ModelViewMatrix8_Tag 0x0328
#define ModelViewMatrix9_Tag 0x0329
#define ModelViewMatrix10_Tag 0x032a
#define ModelViewMatrix11_Tag 0x032b
#define ModelViewMatrix12_Tag 0x032c
#define ModelViewMatrix13_Tag 0x032d
#define ModelViewMatrix14_Tag 0x032e
#define ModelViewMatrix15_Tag 0x032f
#define ModelViewProjectionMatrix0_Tag 0x0330
#define ModelViewProjectionMatrix1_Tag 0x0331
#define ModelViewProjectionMatrix2_Tag 0x0332
#define ModelViewProjectionMatrix3_Tag 0x0333
#define ModelViewProjectionMatrix4_Tag 0x0334
#define ModelViewProjectionMatrix5_Tag 0x0335
#define ModelViewProjectionMatrix6_Tag 0x0336
#define ModelViewProjectionMatrix7_Tag 0x0337
#define ModelViewProjectionMatrix8_Tag 0x0338
#define ModelViewProjectionMatrix9_Tag 0x0339
#define ModelViewProjectionMatrix10_Tag 0x033a
#define ModelViewProjectionMatrix11_Tag 0x033b
#define ModelViewProjectionMatrix12_Tag 0x033c
#define ModelViewProjectionMatrix13_Tag 0x033d
#define ModelViewProjectionMatrix14_Tag 0x033e
#define ModelViewProjectionMatrix15_Tag 0x033f
#define NormalMatrix0_Tag 0x0340
#define NormalMatrix1_Tag 0x0341
#define NormalMatrix2_Tag 0x0342
#define NormalMatrix3_Tag 0x0343
#define NormalMatrix4_Tag 0x0344
#define NormalMatrix5_Tag 0x0345
#define NormalMatrix6_Tag 0x0346
#define NormalMatrix7_Tag 0x0347
#define NormalMatrix8_Tag 0x0348
#define UnusedNormalMatrix9_Tag 0x0349
#define UnusedNormalMatrix10_Tag 0x034a
#define UnusedNormalMatrix11_Tag 0x034b
#define UnusedNormalMatrix12_Tag 0x034c
#define UnusedNormalMatrix13_Tag 0x034d
#define UnusedNormalMatrix14_Tag 0x034e
#define UnusedNormalMatrix15_Tag 0x034f
#define TextureMatrix0_Tag 0x0350
#define TextureMatrix1_Tag 0x0351
#define TextureMatrix2_Tag 0x0352
#define TextureMatrix3_Tag 0x0353
#define TextureMatrix4_Tag 0x0354
#define TextureMatrix5_Tag 0x0355
#define TextureMatrix6_Tag 0x0356
#define TextureMatrix7_Tag 0x0357
#define TextureMatrix8_Tag 0x0358
#define TextureMatrix9_Tag 0x0359
#define TextureMatrix10_Tag 0x035a
#define TextureMatrix11_Tag 0x035b
#define TextureMatrix12_Tag 0x035c
#define TextureMatrix13_Tag 0x035d
#define TextureMatrix14_Tag 0x035e
#define TextureMatrix15_Tag 0x035f
#define TexGen0_Tag 0x0360
#define TexGen1_Tag 0x0361
#define TexGen2_Tag 0x0362
#define TexGen3_Tag 0x0363
#define TexGen4_Tag 0x0364
#define TexGen5_Tag 0x0365
#define TexGen6_Tag 0x0366
#define TexGen7_Tag 0x0367
#define TexGen8_Tag 0x0368
#define TexGen9_Tag 0x0369
#define TexGen10_Tag 0x036a
#define TexGen11_Tag 0x036b
#define TexGen12_Tag 0x036c
#define TexGen13_Tag 0x036d
#define TexGen14_Tag 0x036e
#define TexGen15_Tag 0x036f
#define ViewPortScaleX_Tag 0x0370
#define ViewPortScaleY_Tag 0x0371
#define ViewPortScaleZ_Tag 0x0372
#define ViewPortOffsetX_Tag 0x0373
#define ViewPortOffsetY_Tag 0x0374
#define ViewPortOffsetZ_Tag 0x0375
#define FogDensity_Tag 0x0376
#define FogScale_Tag 0x0377
#define FogEnd_Tag 0x0378
#define PolygonOffsetFactor_Tag 0x0379
#define PolygonOffsetBias_Tag 0x037a
#define LineClipLengthThreshold_Tag 0x037b
#define TriangleClipAreaThreshold_Tag 0x037c
#define RasterPosXIncrement_Tag 0x037d
#define RasterPosYIncrement_Tag 0x037e
#define UserClip0X_Tag 0x0380
#define UserClip0Y_Tag 0x0381
#define UserClip0Z_Tag 0x0382
#define UserClip0W_Tag 0x0383
#define UserClip1X_Tag 0x0384
#define UserClip1Y_Tag 0x0385
#define UserClip1Z_Tag 0x0386
#define UserClip1W_Tag 0x0387
#define UserClip2X_Tag 0x0388
#define UserClip2Y_Tag 0x0389
#define UserClip2Z_Tag 0x038a
#define UserClip2W_Tag 0x038b
#define UserClip3X_Tag 0x038c
#define UserClip3Y_Tag 0x038d
#define UserClip3Z_Tag 0x038e
#define UserClip3W_Tag 0x038f
#define UserClip4X_Tag 0x0390
#define UserClip4Y_Tag 0x0391
#define UserClip4Z_Tag 0x0392
#define UserClip4W_Tag 0x0393
#define UserClip5X_Tag 0x0394
#define UserClip5Y_Tag 0x0395
#define UserClip5Z_Tag 0x0396
#define UserClip5W_Tag 0x0397
#define PackedSpecular_Tag 0x0398
#define PackedDiffuse_Tag 0x0399
#define PackedNormal_Tag 0x039a
#define PackedFaceNormal_Tag 0x039b
#define RasterPosXOffset_Tag 0x039d
#define RasterPosYOffset_Tag 0x039e
#define AttenuationCutOff_Tag 0x039f
#define Light0Mode_Tag 0x03a0
#define Light0AmbientIntensityRed_Tag 0x03a1
#define Light0AmbientIntensityGreen_Tag 0x03a2
#define Light0AmbientIntensityBlue_Tag 0x03a3
#define Light0DiffuseIntensityRed_Tag 0x03a4
#define Light0DiffuseIntensityGreen_Tag 0x03a5
#define Light0DiffuseIntensityBlue_Tag 0x03a6
#define Light0SpecularIntensityRed_Tag 0x03a7
#define Light0SpecularIntensityGreen_Tag 0x03a8
#define Light0SpecularIntensityBlue_Tag 0x03a9
#define Light0PositionX_Tag 0x03aa
#define Light0PositionY_Tag 0x03ab
#define Light0PositionZ_Tag 0x03ac
#define Light0PositionW_Tag 0x03ad
#define Light0SpotlightDirectionX_Tag 0x03ae
#define Light0SpotlightDirectionY_Tag 0x03af
#define Light0SpotlightDirectionZ_Tag 0x03b0
#define Light0SpotlightExponent_Tag 0x03b1
#define Light0CosSpotlightCutoffAngle_Tag 0x03b2
#define Light0ConstantAttenuation_Tag 0x03b3
#define Light0LinearAttenuation_Tag 0x03b4
#define Light0QuadraticAttenuation_Tag 0x03b5
#define Light1Mode_Tag 0x03b6
#define Light1AmbientIntensityRed_Tag 0x03b7
#define Light1AmbientIntensityGreen_Tag 0x03b8
#define Light1AmbientIntensityBlue_Tag 0x03b9
#define Light1DiffuseIntensityRed_Tag 0x03ba
#define Light1DiffuseIntensityGreen_Tag 0x03bb
#define Light1DiffuseIntensityBlue_Tag 0x03bc
#define Light1SpecularIntensityRed_Tag 0x03bd
#define Light1SpecularIntensityGreen_Tag 0x03be
#define Light1SpecularIntensityBlue_Tag 0x03bf
#define Light1PositionX_Tag 0x03c0
#define Light1PositionY_Tag 0x03c1
#define Light1PositionZ_Tag 0x03c2
#define Light1PositionW_Tag 0x03c3
#define Light1SpotlightDirectionX_Tag 0x03c4
#define Light1SpotlightDirectionY_Tag 0x03c5
#define Light1SpotlightDirectionZ_Tag 0x03c6
#define Light1SpotlightExponent_Tag 0x03c7
#define Light1CosSpotlightCutoffAngle_Tag 0x03c8
#define Light1ConstantAttenuation_Tag 0x03c9
#define Light1LinearAttenuation_Tag 0x03ca
#define Light1QuadraticAttenuation_Tag 0x03cb
#define Light2Mode_Tag 0x03cc
#define Light2AmbientIntensityRed_Tag 0x03cd
#define Light2AmbientIntensityGreen_Tag 0x03ce
#define Light2AmbientIntensityBlue_Tag 0x03cf
#define Light2DiffuseIntensityRed_Tag 0x03d0
#define Light2DiffuseIntensityGreen_Tag 0x03d1
#define Light2DiffuseIntensityBlue_Tag 0x03d2
#define Light2SpecularIntensityRed_Tag 0x03d3
#define Light2SpecularIntensityGreen_Tag 0x03d4
#define Light2SpecularIntensityBlue_Tag 0x03d5
#define Light2PositionX_Tag 0x03d6
#define Light2PositionY_Tag 0x03d7
#define Light2PositionZ_Tag 0x03d8
#define Light2PositionW_Tag 0x03d9
#define Light2SpotlightDirectionX_Tag 0x03da
#define Light2SpotlightDirectionY_Tag 0x03db
#define Light2SpotlightDirectionZ_Tag 0x03dc
#define Light2SpotlightExponent_Tag 0x03dd
#define Light2CosSpotlightCutoffAngle_Tag 0x03de
#define Light2ConstantAttenuation_Tag 0x03df
#define Light2LinearAttenuation_Tag 0x03e0
#define Light2QuadraticAttenuation_Tag 0x03e1
#define Light3Mode_Tag 0x03e2
#define Light3AmbientIntensityRed_Tag 0x03e3
#define Light3AmbientIntensityGreen_Tag 0x03e4
#define Light3AmbientIntensityBlue_Tag 0x03e5
#define Light3DiffuseIntensityRed_Tag 0x03e6
#define Light3DiffuseIntensityGreen_Tag 0x03e7
#define Light3DiffuseIntensityBlue_Tag 0x03e8
#define Light3SpecularIntensityRed_Tag 0x03e9
#define Light3SpecularIntensityGreen_Tag 0x03ea
#define Light3SpecularIntensityBlue_Tag 0x03eb
#define Light3PositionX_Tag 0x03ec
#define Light3PositionY_Tag 0x03ed
#define Light3PositionZ_Tag 0x03ee
#define Light3PositionW_Tag 0x03ef
#define Light3SpotlightDirectionX_Tag 0x03f0
#define Light3SpotlightDirectionY_Tag 0x03f1
#define Light3SpotlightDirectionZ_Tag 0x03f2
#define Light3SpotlightExponent_Tag 0x03f3
#define Light3CosSpotlightCutoffAngle_Tag 0x03f4
#define Light3ConstantAttenuation_Tag 0x03f5
#define Light3LinearAttenuation_Tag 0x03f6
#define Light3QuadraticAttenuation_Tag 0x03f7
#define Light4Mode_Tag 0x03f8
#define Light4AmbientIntensityRed_Tag 0x03f9
#define Light4AmbientIntensityGreen_Tag 0x03fa
#define Light4AmbientIntensityBlue_Tag 0x03fb
#define Light4DiffuseIntensityRed_Tag 0x03fc
#define Light4DiffuseIntensityGreen_Tag 0x03fd
#define Light4DiffuseIntensityBlue_Tag 0x03fe
#define Light4SpecularIntensityRed_Tag 0x03ff
#define Light4SpecularIntensityGreen_Tag 0x0400
#define Light4SpecularIntensityBlue_Tag 0x0401
#define Light4PositionX_Tag 0x0402
#define Light4PositionY_Tag 0x0403
#define Light4PositionZ_Tag 0x0404
#define Light4PositionW_Tag 0x0405
#define Light4SpotlightDirectionX_Tag 0x0406
#define Light4SpotlightDirectionY_Tag 0x0407
#define Light4SpotlightDirectionZ_Tag 0x0408
#define Light4SpotlightExponent_Tag 0x0409
#define Light4CosSpotlightCutoffAngle_Tag 0x040a
#define Light4ConstantAttenuation_Tag 0x040b
#define Light4LinearAttenuation_Tag 0x040c
#define Light4QuadraticAttenuation_Tag 0x040d
#define Light5Mode_Tag 0x040e
#define Light5AmbientIntensityRed_Tag 0x040f
#define Light5AmbientIntensityGreen_Tag 0x0410
#define Light5AmbientIntensityBlue_Tag 0x0411
#define Light5DiffuseIntensityRed_Tag 0x0412
#define Light5DiffuseIntensityGreen_Tag 0x0413
#define Light5DiffuseIntensityBlue_Tag 0x0414
#define Light5SpecularIntensityRed_Tag 0x0415
#define Light5SpecularIntensityGreen_Tag 0x0416
#define Light5SpecularIntensityBlue_Tag 0x0417
#define Light5PositionX_Tag 0x0418
#define Light5PositionY_Tag 0x0419
#define Light5PositionZ_Tag 0x041a
#define Light5PositionW_Tag 0x041b
#define Light5SpotlightDirectionX_Tag 0x041c
#define Light5SpotlightDirectionY_Tag 0x041d
#define Light5SpotlightDirectionZ_Tag 0x041e
#define Light5SpotlightExponent_Tag 0x041f
#define Light5CosSpotlightCutoffAngle_Tag 0x0420
#define Light5ConstantAttenuation_Tag 0x0421
#define Light5LinearAttenuation_Tag 0x0422
#define Light5QuadraticAttenuation_Tag 0x0423
#define Light6Mode_Tag 0x0424
#define Light6AmbientIntensityRed_Tag 0x0425
#define Light6AmbientIntensityGreen_Tag 0x0426
#define Light6AmbientIntensityBlue_Tag 0x0427
#define Light6DiffuseIntensityRed_Tag 0x0428
#define Light6DiffuseIntensityGreen_Tag 0x0429
#define Light6DiffuseIntensityBlue_Tag 0x042a
#define Light6SpecularIntensityRed_Tag 0x042b
#define Light6SpecularIntensityGreen_Tag 0x042c
#define Light6SpecularIntensityBlue_Tag 0x042d
#define Light6PositionX_Tag 0x042e
#define Light6PositionY_Tag 0x042f
#define Light6PositionZ_Tag 0x0430
#define Light6PositionW_Tag 0x0431
#define Light6SpotlightDirectionX_Tag 0x0432
#define Light6SpotlightDirectionY_Tag 0x0433
#define Light6SpotlightDirectionZ_Tag 0x0434
#define Light6SpotlightExponent_Tag 0x0435
#define Light6CosSpotlightCutoffAngle_Tag 0x0436
#define Light6ConstantAttenuation_Tag 0x0437
#define Light6LinearAttenuation_Tag 0x0438
#define Light6QuadraticAttenuation_Tag 0x0439
#define Light7Mode_Tag 0x043a
#define Light7AmbientIntensityRed_Tag 0x043b
#define Light7AmbientIntensityGreen_Tag 0x043c
#define Light7AmbientIntensityBlue_Tag 0x043d
#define Light7DiffuseIntensityRed_Tag 0x043e
#define Light7DiffuseIntensityGreen_Tag 0x043f
#define Light7DiffuseIntensityBlue_Tag 0x0440
#define Light7SpecularIntensityRed_Tag 0x0441
#define Light7SpecularIntensityGreen_Tag 0x0442
#define Light7SpecularIntensityBlue_Tag 0x0443
#define Light7PositionX_Tag 0x0444
#define Light7PositionY_Tag 0x0445
#define Light7PositionZ_Tag 0x0446
#define Light7PositionW_Tag 0x0447
#define Light7SpotlightDirectionX_Tag 0x0448
#define Light7SpotlightDirectionY_Tag 0x0449
#define Light7SpotlightDirectionZ_Tag 0x044a
#define Light7SpotlightExponent_Tag 0x044b
#define Light7CosSpotlightCutoffAngle_Tag 0x044c
#define Light7ConstantAttenuation_Tag 0x044d
#define Light7LinearAttenuation_Tag 0x044e
#define Light7QuadraticAttenuation_Tag 0x044f
#define Light8Mode_Tag 0x0450
#define Light8AmbientIntensityRed_Tag 0x0451
#define Light8AmbientIntensityGreen_Tag 0x0452
#define Light8AmbientIntensityBlue_Tag 0x0453
#define Light8DiffuseIntensityRed_Tag 0x0454
#define Light8DiffuseIntensityGreen_Tag 0x0455
#define Light8DiffuseIntensityBlue_Tag 0x0456
#define Light8SpecularIntensityRed_Tag 0x0457
#define Light8SpecularIntensityGreen_Tag 0x0458
#define Light8SpecularIntensityBlue_Tag 0x0459
#define Light8PositionX_Tag 0x045a
#define Light8PositionY_Tag 0x045b
#define Light8PositionZ_Tag 0x045c
#define Light8PositionW_Tag 0x045d
#define Light8SpotlightDirectionX_Tag 0x045e
#define Light8SpotlightDirectionY_Tag 0x045f
#define Light8SpotlightDirectionZ_Tag 0x0460
#define Light8SpotlightExponent_Tag 0x0461
#define Light8CosSpotlightCutoffAngle_Tag 0x0462
#define Light8ConstantAttenuation_Tag 0x0463
#define Light8LinearAttenuation_Tag 0x0464
#define Light8QuadraticAttenuation_Tag 0x0465
#define Light9Mode_Tag 0x0466
#define Light9AmbientIntensityRed_Tag 0x0467
#define Light9AmbientIntensityGreen_Tag 0x0468
#define Light9AmbientIntensityBlue_Tag 0x0469
#define Light9DiffuseIntensityRed_Tag 0x046a
#define Light9DiffuseIntensityGreen_Tag 0x046b
#define Light9DiffuseIntensityBlue_Tag 0x046c
#define Light9SpecularIntensityRed_Tag 0x046d
#define Light9SpecularIntensityGreen_Tag 0x046e
#define Light9SpecularIntensityBlue_Tag 0x046f
#define Light9PositionX_Tag 0x0470
#define Light9PositionY_Tag 0x0471
#define Light9PositionZ_Tag 0x0472
#define Light9PositionW_Tag 0x0473
#define Light9SpotlightDirectionX_Tag 0x0474
#define Light9SpotlightDirectionY_Tag 0x0475
#define Light9SpotlightDirectionZ_Tag 0x0476
#define Light9SpotlightExponent_Tag 0x0477
#define Light9CosSpotlightCutoffAngle_Tag 0x0478
#define Light9ConstantAttenuation_Tag 0x0479
#define Light9LinearAttenuation_Tag 0x047a
#define Light9QuadraticAttenuation_Tag 0x047b
#define Light10Mode_Tag 0x047c
#define Light10AmbientIntensityRed_Tag 0x047d
#define Light10AmbientIntensityGreen_Tag 0x047e
#define Light10AmbientIntensityBlue_Tag 0x047f
#define Light10DiffuseIntensityRed_Tag 0x0480
#define Light10DiffuseIntensityGreen_Tag 0x0481
#define Light10DiffuseIntensityBlue_Tag 0x0482
#define Light10SpecularIntensityRed_Tag 0x0483
#define Light10SpecularIntensityGreen_Tag 0x0484
#define Light10SpecularIntensityBlue_Tag 0x0485
#define Light10PositionX_Tag 0x0486
#define Light10PositionY_Tag 0x0487
#define Light10PositionZ_Tag 0x0488
#define Light10PositionW_Tag 0x0489
#define Light10SpotlightDirectionX_Tag 0x048a
#define Light10SpotlightDirectionY_Tag 0x048b
#define Light10SpotlightDirectionZ_Tag 0x048c
#define Light10SpotlightExponent_Tag 0x048d
#define Light10CosSpotlightCutoffAngle_Tag 0x048e
#define Light10ConstantAttenuation_Tag 0x048f
#define Light10LinearAttenuation_Tag 0x0490
#define Light10QuadraticAttenuation_Tag 0x0491
#define Light11Mode_Tag 0x0492
#define Light11AmbientIntensityRed_Tag 0x0493
#define Light11AmbientIntensityGreen_Tag 0x0494
#define Light11AmbientIntensityBlue_Tag 0x0495
#define Light11DiffuseIntensityRed_Tag 0x0496
#define Light11DiffuseIntensityGreen_Tag 0x0497
#define Light11DiffuseIntensityBlue_Tag 0x0498
#define Light11SpecularIntensityRed_Tag 0x0499
#define Light11SpecularIntensityGreen_Tag 0x049a
#define Light11SpecularIntensityBlue_Tag 0x049b
#define Light11PositionX_Tag 0x049c
#define Light11PositionY_Tag 0x049d
#define Light11PositionZ_Tag 0x049e
#define Light11PositionW_Tag 0x049f
#define Light11SpotlightDirectionX_Tag 0x04a0
#define Light11SpotlightDirectionY_Tag 0x04a1
#define Light11SpotlightDirectionZ_Tag 0x04a2
#define Light11SpotlightExponent_Tag 0x04a3
#define Light11CosSpotlightCutoffAngle_Tag 0x04a4
#define Light11ConstantAttenuation_Tag 0x04a5
#define Light11LinearAttenuation_Tag 0x04a6
#define Light11QuadraticAttenuation_Tag 0x04a7
#define Light12Mode_Tag 0x04a8
#define Light12AmbientIntensityRed_Tag 0x04a9
#define Light12AmbientIntensityGreen_Tag 0x04aa
#define Light12AmbientIntensityBlue_Tag 0x04ab
#define Light12DiffuseIntensityRed_Tag 0x04ac
#define Light12DiffuseIntensityGreen_Tag 0x04ad
#define Light12DiffuseIntensityBlue_Tag 0x04ae
#define Light12SpecularIntensityRed_Tag 0x04af
#define Light12SpecularIntensityGreen_Tag 0x04b0
#define Light12SpecularIntensityBlue_Tag 0x04b1
#define Light12PositionX_Tag 0x04b2
#define Light12PositionY_Tag 0x04b3
#define Light12PositionZ_Tag 0x04b4
#define Light12PositionW_Tag 0x04b5
#define Light12SpotlightDirectionX_Tag 0x04b6
#define Light12SpotlightDirectionY_Tag 0x04b7
#define Light12SpotlightDirectionZ_Tag 0x04b8
#define Light12SpotlightExponent_Tag 0x04b9
#define Light12CosSpotlightCutoffAngle_Tag 0x04ba
#define Light12ConstantAttenuation_Tag 0x04bb
#define Light12LinearAttenuation_Tag 0x04bc
#define Light12QuadraticAttenuation_Tag 0x04bd
#define Light13Mode_Tag 0x04be
#define Light13AmbientIntensityRed_Tag 0x04bf
#define Light13AmbientIntensityGreen_Tag 0x04c0
#define Light13AmbientIntensityBlue_Tag 0x04c1
#define Light13DiffuseIntensityRed_Tag 0x04c2
#define Light13DiffuseIntensityGreen_Tag 0x04c3
#define Light13DiffuseIntensityBlue_Tag 0x04c4
#define Light13SpecularIntensityRed_Tag 0x04c5
#define Light13SpecularIntensityGreen_Tag 0x04c6
#define Light13SpecularIntensityBlue_Tag 0x04c7
#define Light13PositionX_Tag 0x04c8
#define Light13PositionY_Tag 0x04c9
#define Light13PositionZ_Tag 0x04ca
#define Light13PositionW_Tag 0x04cb
#define Light13SpotlightDirectionX_Tag 0x04cc
#define Light13SpotlightDirectionY_Tag 0x04cd
#define Light13SpotlightDirectionZ_Tag 0x04ce
#define Light13SpotlightExponent_Tag 0x04cf
#define Light13CosSpotlightCutoffAngle_Tag 0x04d0
#define Light13ConstantAttenuation_Tag 0x04d1
#define Light13LinearAttenuation_Tag 0x04d2
#define Light13QuadraticAttenuation_Tag 0x04d3
#define Light14Mode_Tag 0x04d4
#define Light14AmbientIntensityRed_Tag 0x04d5
#define Light14AmbientIntensityGreen_Tag 0x04d6
#define Light14AmbientIntensityBlue_Tag 0x04d7
#define Light14DiffuseIntensityRed_Tag 0x04d8
#define Light14DiffuseIntensityGreen_Tag 0x04d9
#define Light14DiffuseIntensityBlue_Tag 0x04da
#define Light14SpecularIntensityRed_Tag 0x04db
#define Light14SpecularIntensityGreen_Tag 0x04dc
#define Light14SpecularIntensityBlue_Tag 0x04dd
#define Light14PositionX_Tag 0x04de
#define Light14PositionY_Tag 0x04df
#define Light14PositionZ_Tag 0x04e0
#define Light14PositionW_Tag 0x04e1
#define Light14SpotlightDirectionX_Tag 0x04e2
#define Light14SpotlightDirectionY_Tag 0x04e3
#define Light14SpotlightDirectionZ_Tag 0x04e4
#define Light14SpotlightExponent_Tag 0x04e5
#define Light14CosSpotlightCutoffAngle_Tag 0x04e6
#define Light14ConstantAttenuation_Tag 0x04e7
#define Light14LinearAttenuation_Tag 0x04e8
#define Light14QuadraticAttenuation_Tag 0x04e9
#define Light15Mode_Tag 0x04ea
#define Light15AmbientIntensityRed_Tag 0x04eb
#define Light15AmbientIntensityGreen_Tag 0x04ec
#define Light15AmbientIntensityBlue_Tag 0x04ed
#define Light15DiffuseIntensityRed_Tag 0x04ee
#define Light15DiffuseIntensityGreen_Tag 0x04ef
#define Light15DiffuseIntensityBlue_Tag 0x04f0
#define Light15SpecularIntensityRed_Tag 0x04f1
#define Light15SpecularIntensityGreen_Tag 0x04f2
#define Light15SpecularIntensityBlue_Tag 0x04f3
#define Light15PositionX_Tag 0x04f4
#define Light15PositionY_Tag 0x04f5
#define Light15PositionZ_Tag 0x04f6
#define Light15PositionW_Tag 0x04f7
#define Light15SpotlightDirectionX_Tag 0x04f8
#define Light15SpotlightDirectionY_Tag 0x04f9
#define Light15SpotlightDirectionZ_Tag 0x04fa
#define Light15SpotlightExponent_Tag 0x04fb
#define Light15CosSpotlightCutoffAngle_Tag 0x04fc
#define Light15ConstantAttenuation_Tag 0x04fd
#define Light15LinearAttenuation_Tag 0x04fe
#define Light15QuadraticAttenuation_Tag 0x04ff
#define SceneAmbientColorRed_Tag 0x0500
#define SceneAmbientColorGreen_Tag 0x0501
#define SceneAmbientColorBlue_Tag 0x0502
#define FrontAmbientColorRed_Tag 0x0510
#define FrontAmbientColorGreen_Tag 0x0511
#define FrontAmbientColorBlue_Tag 0x0512
#define FrontDiffuseColorRed_Tag 0x0513
#define FrontDiffuseColorGreen_Tag 0x0514
#define FrontDiffuseColorBlue_Tag 0x0515
#define FrontAlpha_Tag 0x0516
#define FrontSpecularColorRed_Tag 0x0517
#define FrontSpecularColorGreen_Tag 0x0518
#define FrontSpecularColorBlue_Tag 0x0519
#define FrontEmissiveColorRed_Tag 0x051a
#define FrontEmissiveColorGreen_Tag 0x051b
#define FrontEmissiveColorBlue_Tag 0x051c
#define FrontSpecularExponent_Tag 0x051d
#define BackAmbientColorRed_Tag 0x0520
#define BackAmbientColorGreen_Tag 0x0521
#define BackAmbientColorBlue_Tag 0x0522
#define BackDiffuseColorRed_Tag 0x0523
#define BackDiffuseColorGreen_Tag 0x0524
#define BackDiffuseColorBlue_Tag 0x0525
#define BackAlpha_Tag 0x0526
#define BackSpecularColorRed_Tag 0x0527
#define BackSpecularColorGreen_Tag 0x0528
#define BackSpecularColorBlue_Tag 0x0529
#define BackEmissiveColorRed_Tag 0x052a
#define BackEmissiveColorGreen_Tag 0x052b
#define BackEmissiveColorBlue_Tag 0x052c
#define BackSpecularExponent_Tag 0x052d
#define DMAAddr_Tag 0x0530
#define DMACount_Tag 0x0531
#define CommandInterrupt_Tag 0x0532
#define DMACall_Tag 0x0533
#define DMAReturn_Tag 0x0534
#define DMARectangleRead_Tag 0x0535
#define DMARectangleReadAddress_Tag 0x0536
#define DMARectangleReadLinePitch_Tag 0x0537
#define DMARectangleReadTarget_Tag 0x0538
#define DMARectangleWrite_Tag 0x0539
#define DMARectangleWriteAddress_Tag 0x053a
#define DMARectangleWriteLinePitch_Tag 0x053b
#define DMAOutputAddress_Tag 0x053c
#define DMAOutputCount_Tag 0x053d
#define DMAReadGlintSource_Tag 0x053e
#define DMAContinue_Tag 0x053f
#define VertexArray_Tag 0x0540
#define VertexArrayIndexed_Tag 0x0541
#define DMAFeedback_Tag 0x0542
#define BeginContextFence_Tag 0x0543
#define EndContextFence_Tag 0x0544
#define CommandTest_Tag 0x0545
#define TransformModeAnd_Tag 0x0550
#define TransformModeOr_Tag 0x0551
#define GeometryModeAnd_Tag 0x0552
#define GeometryModeOr_Tag 0x0553
#define NormaliseModeAnd_Tag 0x0554
#define NormaliseModeOr_Tag 0x0555
#define LightingModeAnd_Tag 0x0556
#define LightingModeOr_Tag 0x0557
#define ColorMaterialModeAnd_Tag 0x0558
#define ColorMaterialModeOr_Tag 0x0559
#define DeltaModeAnd_Tag 0x055a
#define DeltaModeOr_Tag 0x055b
#define PointModeAnd_Tag 0x055c
#define PointModeOr_Tag 0x055d
#define LineModeAnd_Tag 0x055e
#define LineModeOr_Tag 0x055f
#define TriangleModeAnd_Tag 0x0560
#define TriangleModeOr_Tag 0x0561
#define MaterialModeAnd_Tag 0x0562
#define MaterialModeOr_Tag 0x0563
#define DeltaControlAnd_Tag 0x0564
#define DeltaControlOr_Tag 0x0565
#define DeltaFormatControlAnd_Tag 0x0566
#define DeltaFormatControlOr_Tag 0x0567
#define PipeModeAnd_Tag 0x0568
#define PipeModeOr_Tag 0x0569
#define FogVertexModeAnd_Tag 0x056a
#define FogVertexModeOr_Tag 0x056b
#define TextureModeAnd_Tag 0x056c
#define TextureModeOr_Tag 0x056d
#define StripeFilterModeAnd_Tag 0x056e
#define StripeFilterModeOr_Tag 0x056f
#define WindowAnd_Tag 0x0570
#define WindowOr_Tag 0x0571
#define LBReadModeAnd_Tag 0x0572
#define LBReadModeOr_Tag 0x0573
#define RasterizerModeAnd_Tag 0x0574
#define RasterizerModeOr_Tag 0x0575
#define ScissorModeAnd_Tag 0x0576
#define ScissorModeOr_Tag 0x0577
#define LineStippleModeAnd_Tag 0x0578
#define LineStippleModeOr_Tag 0x0579
#define AreaStippleModeAnd_Tag 0x057a
#define AreaStippleModeOr_Tag 0x057b
#define ColorDDAModeAnd_Tag 0x057c
#define ColorDDAModeOr_Tag 0x057d
#define AlphaTestModeAnd_Tag 0x057e
#define AlphaTestModeOr_Tag 0x057f
#define AntialiasModeAnd_Tag 0x0580
#define AntialiasModeOr_Tag 0x0581
#define FogModeAnd_Tag 0x0582
#define FogModeOr_Tag 0x0583
#define TextureCoordModeAnd_Tag 0x0584
#define TextureCoordModeOr_Tag 0x0585
#define TextureReadMode0And_Tag 0x0586
#define TextureReadMode0Or_Tag 0x0587
#define TextureFormatAnd_Tag 0x0588
#define TextureFormatOr_Tag 0x0589
#define TextureApplicationModeAnd_Tag 0x058a
#define TextureApplicationModeOr_Tag 0x058b
#define StencilModeAnd_Tag 0x058c
#define StencilModeOr_Tag 0x058d
#define DepthModeAnd_Tag 0x058e
#define DepthModeOr_Tag 0x058f
#define LBWriteModeAnd_Tag 0x0590
#define LBWriteModeOr_Tag 0x0591
#define FBDestReadModeAnd_Tag 0x0592
#define FBDestReadModeOr_Tag 0x0593
#define FBSourceReadModeAnd_Tag 0x0594
#define FBSourceReadModeOr_Tag 0x0595
#define AlphaBlendColorModeAnd_Tag 0x0596
#define AlphaBlendColorModeOr_Tag 0x0597
#define ChromaTestModeAnd_Tag 0x0598
#define ChromaTestModeOr_Tag 0x0599
#define DitherModeAnd_Tag 0x059a
#define DitherModeOr_Tag 0x059b
#define LogicalOpModeAnd_Tag 0x059c
#define LogicalOpModeOr_Tag 0x059d
#define FBWriteModeAnd_Tag 0x059e
#define FBWriteModeOr_Tag 0x059f
#define FilterModeAnd_Tag 0x05a0
#define FilterModeOr_Tag 0x05a1
#define StatisticModeAnd_Tag 0x05a2
#define StatisticModeOr_Tag 0x05a3
#define FBDestReadEnablesAnd_Tag 0x05a4
#define FBDestReadEnablesOr_Tag 0x05a5
#define AlphaBlendAlphaModeAnd_Tag 0x05a6
#define AlphaBlendAlphaModeOr_Tag 0x05a7
#define TextureReadMode1And_Tag 0x05a8
#define TextureReadMode1Or_Tag 0x05a9
#define TextureFilterModeAnd_Tag 0x05aa
#define TextureFilterModeOr_Tag 0x05ab
#define LUTModeAnd_Tag 0x05ae
#define LUTModeOr_Tag 0x05af
#define FBDestReadBufferAddr0_Tag 0x05d0
#define FBDestReadBufferAddr1_Tag 0x05d1
#define FBDestReadBufferAddr2_Tag 0x05d2
#define FBDestReadBufferAddr3_Tag 0x05d3
#define FBDestReadBufferOffset0_Tag 0x05d4
#define FBDestReadBufferOffset1_Tag 0x05d5
#define FBDestReadBufferOffset2_Tag 0x05d6
#define FBDestReadBufferOffset3_Tag 0x05d7
#define FBDestReadBufferWidth0_Tag 0x05d8
#define FBDestReadBufferWidth1_Tag 0x05d9
#define FBDestReadBufferWidth2_Tag 0x05da
#define FBDestReadBufferWidth3_Tag 0x05db
#define FBDestReadMode_Tag 0x05dc
#define FBDestReadEnables_Tag 0x05dd
#define FBSourceReadMode_Tag 0x05e0
#define FBSourceReadBufferAddr_Tag 0x05e1
#define FBSourceReadBufferOffset_Tag 0x05e2
#define FBSourceReadBufferWidth_Tag 0x05e3
#define MergeSpanData_Tag 0x05e7
#define PCIWindowBase0_Tag 0x05e8
#define PCIWindowBase1_Tag 0x05e9
#define PCIWindowBase2_Tag 0x05ea
#define PCIWindowBase3_Tag 0x05eb
#define PCIWindowBase4_Tag 0x05ec
#define PCIWindowBase5_Tag 0x05ed
#define PCIWindowBase6_Tag 0x05ee
#define PCIWindowBase7_Tag 0x05ef
#define AlphaSourceColor_Tag 0x05f0
#define AlphaDestColor_Tag 0x05f1
#define ChromaPassColor_Tag 0x05f2
#define ChromaFailColor_Tag 0x05f3
#define AlphaBlendColorMode_Tag 0x05f4
#define AlphaBlendAlphaMode_Tag 0x05f5
#define ConstantColorDDA_Tag 0x05f6
#define D3DAlphaTestMode_Tag 0x05f8
#define FBWriteBufferAddr0_Tag 0x0600
#define FBWriteBufferAddr1_Tag 0x0601
#define FBWriteBufferAddr2_Tag 0x0602
#define FBWriteBufferAddr3_Tag 0x0603
#define FBWriteBufferOffset0_Tag 0x0604
#define FBWriteBufferOffset1_Tag 0x0605
#define FBWriteBufferOffset2_Tag 0x0606
#define FBWriteBufferOffset3_Tag 0x0607
#define FBWriteBufferWidth0_Tag 0x0608
#define FBWriteBufferWidth1_Tag 0x0609
#define FBWriteBufferWidth2_Tag 0x060a
#define FBWriteBufferWidth3_Tag 0x060b
#define FBBlockColor0_Tag 0x060c
#define FBBlockColor1_Tag 0x060d
#define FBBlockColor2_Tag 0x060e
#define FBBlockColor3_Tag 0x060f
#define FBBlockColorBack0_Tag 0x0610
#define FBBlockColorBack1_Tag 0x0611
#define FBBlockColorBack2_Tag 0x0612
#define FBBlockColorBack3_Tag 0x0613
#define FBBlockColorBack_Tag 0x0614
#define SizeOfFramebuffer_Tag 0x0615
#define VTGAddress_Tag 0x0616
#define VTGData_Tag 0x0617
#define ForegroundColor_Tag 0x0618
#define BackgroundColor_Tag 0x0619
#define DownloadAddress_Tag 0x061a
#define DownloadData_Tag 0x061b
#define FBBlockColorExt_Tag 0x061c
#define FBBlockColorBackExt_Tag 0x061d
#define FBWriteMaskExt_Tag 0x061e
#define FogTable0_Tag 0x0620
#define FogTable1_Tag 0x0621
#define FogTable2_Tag 0x0622
#define FogTable3_Tag 0x0623
#define FogTable4_Tag 0x0624
#define FogTable5_Tag 0x0625
#define FogTable6_Tag 0x0626
#define FogTable7_Tag 0x0627
#define FogTable8_Tag 0x0628
#define FogTable9_Tag 0x0629
#define FogTable10_Tag 0x062a
#define FogTable11_Tag 0x062b
#define FogTable12_Tag 0x062c
#define FogTable13_Tag 0x062d
#define FogTable14_Tag 0x062e
#define FogTable15_Tag 0x062f
#define FogTable16_Tag 0x0630
#define FogTable17_Tag 0x0631
#define FogTable18_Tag 0x0632
#define FogTable19_Tag 0x0633
#define FogTable20_Tag 0x0634
#define FogTable21_Tag 0x0635
#define FogTable22_Tag 0x0636
#define FogTable23_Tag 0x0637
#define FogTable24_Tag 0x0638
#define FogTable25_Tag 0x0639
#define FogTable26_Tag 0x063a
#define FogTable27_Tag 0x063b
#define FogTable28_Tag 0x063c
#define FogTable29_Tag 0x063d
#define FogTable30_Tag 0x063e
#define FogTable31_Tag 0x063f
#define FogTable32_Tag 0x0640
#define FogTable33_Tag 0x0641
#define FogTable34_Tag 0x0642
#define FogTable35_Tag 0x0643
#define FogTable36_Tag 0x0644
#define FogTable37_Tag 0x0645
#define FogTable38_Tag 0x0646
#define FogTable39_Tag 0x0647
#define FogTable40_Tag 0x0648
#define FogTable41_Tag 0x0649
#define FogTable42_Tag 0x064a
#define FogTable43_Tag 0x064b
#define FogTable44_Tag 0x064c
#define FogTable45_Tag 0x064d
#define FogTable46_Tag 0x064e
#define FogTable47_Tag 0x064f
#define FogTable48_Tag 0x0650
#define FogTable49_Tag 0x0651
#define FogTable50_Tag 0x0652
#define FogTable51_Tag 0x0653
#define FogTable52_Tag 0x0654
#define FogTable53_Tag 0x0655
#define FogTable54_Tag 0x0656
#define FogTable55_Tag 0x0657
#define FogTable56_Tag 0x0658
#define FogTable57_Tag 0x0659
#define FogTable58_Tag 0x065a
#define FogTable59_Tag 0x065b
#define FogTable60_Tag 0x065c
#define FogTable61_Tag 0x065d
#define FogTable62_Tag 0x065e
#define FogTable63_Tag 0x065f
#define TextureCompositeMode_Tag 0x0660
#define TextureCompositeColorMode0_Tag 0x0661
#define TextureCompositeAlphaMode0_Tag 0x0662
#define TextureCompositeColorMode1_Tag 0x0663
#define TextureCompositeAlphaMode1_Tag 0x0664
#define TextureCompositeFactor0_Tag 0x0665
#define TextureCompositeFactor1_Tag 0x0666
#define TextureIndexMode0_Tag 0x0667
#define TextureIndexMode1_Tag 0x0668
#define LodRange0_Tag 0x0669
#define LodRange1_Tag 0x066a
#define InvalidateCache_Tag 0x066b
#define SetLogicalTexturePage_Tag 0x066c
#define UpdateLogicalTextureInfo_Tag 0x066d
#define TouchLogicalPage_Tag 0x066e
#define LUTMode_Tag 0x066f
#define TextureCompositeColorMode0And_Tag 0x0670
#define TextureCompositeColorMode0Or_Tag 0x0671
#define TextureCompositeAlphaMode0And_Tag 0x0672
#define TextureCompositeAlphaMode0Or_Tag 0x0673
#define TextureCompositeColorMode1And_Tag 0x0674
#define TextureCompositeColorMode1Or_Tag 0x0675
#define TextureCompositeAlphaMode1And_Tag 0x0676
#define TextureCompositeAlphaMode1Or_Tag 0x0677
#define TextureIndexMode0And_Tag 0x0678
#define TextureIndexMode0Or_Tag 0x0679
#define TextureIndexMode1And_Tag 0x067a
#define TextureIndexMode1Or_Tag 0x067b
#define StencilDataAnd_Tag 0x067c
#define TextureReadMode0_Tag 0x0680
#define TextureReadMode1_Tag 0x0681
#define TextureMapSize_Tag 0x0685
#define TextureCacheReplacementMode_Tag 0x0686
#define StencilDataOr_Tag 0x068d
#define HeadPhysicalPageAllocation0_Tag 0x0690
#define HeadPhysicalPageAllocation1_Tag 0x0691
#define HeadPhysicalPageAllocation2_Tag 0x0692
#define HeadPhysicalPageAllocation3_Tag 0x0693
#define TailPhysicalPageAllocation0_Tag 0x0694
#define TailPhysicalPageAllocation1_Tag 0x0695
#define TailPhysicalPageAllocation2_Tag 0x0696
#define TailPhysicalPageAllocation3_Tag 0x0697
#define PhysicalPageAllocationTableAddr_Tag 0x0698
#define BasePageOfWorkingSet_Tag 0x0699
#define LogicalTexturePageTableAddr_Tag 0x069a
#define LogicalTexturePageTableLength_Tag 0x069b
#define BasePageOfWorkingSetHost_Tag 0x069c
#define LBDestReadMode_Tag 0x06a0
#define LBDestReadEnables_Tag 0x06a1
#define LBDestReadBufferAddr_Tag 0x06a2
#define LBDestReadBufferOffset_Tag 0x06a3
#define LBSourceReadMode_Tag 0x06a4
#define LBSourceReadBufferAddr_Tag 0x06a5
#define LBSourceReadBufferOffset_Tag 0x06a6
#define GIDMode_Tag 0x06a7
#define LBWriteBufferAddr_Tag 0x06a8
#define LBWriteBufferOffset_Tag 0x06a9
#define LBClearDataL_Tag 0x06aa
#define LBClearDataU_Tag 0x06ab
#define LBDestReadModeAnd_Tag 0x06b0
#define LBDestReadModeOr_Tag 0x06b1
#define LBDestReadEnablesAnd_Tag 0x06b2
#define LBDestReadEnablesOr_Tag 0x06b3
#define LBSourceReadModeAnd_Tag 0x06b4
#define LBSourceReadModeOr_Tag 0x06b5
#define GIDModeAnd_Tag 0x06b6
#define GIDModeOr_Tag 0x06b7
#define ReadMonitorModeAnd_Tag 0x06b8
#define ReadMonitorModeOr_Tag 0x06b9
#define RectanglePosition_Tag 0x06c0
#define GlyphPosition_Tag 0x06c1
#define RenderPatchOffset_Tag 0x06c2
#define Config2D_Tag 0x06c3
#define Packed8Pixels_Tag 0x06c6
#define Packed16Pixels_Tag 0x06c7
#define Render2D_Tag 0x06c8
#define Render2DGlyph_Tag 0x06c9
#define DownloadTarget_Tag 0x06ca
#define DownloadGlyphWidth_Tag 0x06cb
#define GlyphData_Tag 0x06cc
#define Packed4Pixels_Tag 0x06cd
#define RLData_Tag 0x06ce
#define RLCount_Tag 0x06cf
#define SClkProfileMask0_Tag 0x06d0
#define SClkProfileMask1_Tag 0x06d1
#define SClkProfileCount0_Tag 0x06d2
#define SClkProfileCount1_Tag 0x06d3
#define KClkProfileMask0_Tag 0x06d4
#define KClkProfileMask1_Tag 0x06d5
#define KClkProfileMask2_Tag 0x06d6
#define KClkProfileMask3_Tag 0x06d7
#define KClkProfileCount0_Tag 0x06d8
#define KClkProfileCount1_Tag 0x06d9
#define KClkProfileCount2_Tag 0x06da
#define KClkProfileCount3_Tag 0x06db
#define IndexBaseAddress_Tag 0x06e0
#define VertexBaseAddress_Tag 0x06e1
#define IndexedTriangleList_Tag 0x06e2
#define IndexedTriangleFan_Tag 0x06e3
#define IndexedTriangleStrip_Tag 0x06e4
#define IndexedLineList_Tag 0x06e5
#define IndexedLineStrip_Tag 0x06e6
#define IndexedPointList_Tag 0x06e7
#define IndexedPolygon_Tag 0x06e8
#define VertexTriangleList_Tag 0x06e9
#define VertexTriangleFan_Tag 0x06ea
#define VertexTriangleStrip_Tag 0x06eb
#define VertexLineList_Tag 0x06ec
#define VertexLineStrip_Tag 0x06ed
#define VertexPointList_Tag 0x06ee
#define VertexPolygon_Tag 0x06ef
#define DMAMemoryControl_Tag 0x06f0
#define VertexValid_Tag 0x06f1
#define VertexFormat_Tag 0x06f2
#define VertexControl_Tag 0x06f3
#define RetainedRender_Tag 0x06f4
#define IndexedVertex_Tag 0x06f5
#define IndexedDoubleVertex_Tag 0x06f6
#define Vertex0_Tag 0x06f7
#define Vertex1_Tag 0x06f8
#define Vertex2_Tag 0x06f9
#define VertexData0_Tag 0x06fa
#define VertexData1_Tag 0x06fb
#define VertexData2_Tag 0x06fc
#define VertexData_Tag 0x06fd
#define VertexTagList0_Tag 0x0700
#define VertexTagList1_Tag 0x0701
#define VertexTagList2_Tag 0x0702
#define VertexTagList3_Tag 0x0703
#define VertexTagList4_Tag 0x0704
#define VertexTagList5_Tag 0x0705
#define VertexTagList6_Tag 0x0706
#define VertexTagList7_Tag 0x0707
#define VertexTagList8_Tag 0x0708
#define VertexTagList9_Tag 0x0709
#define VertexTagList10_Tag 0x070a
#define VertexTagList11_Tag 0x070b
#define VertexTagList12_Tag 0x070c
#define VertexTagList13_Tag 0x070d
#define VertexTagList14_Tag 0x070e
#define VertexTagList15_Tag 0x070f
#define VertexTagList16_Tag 0x0710
#define VertexTagList17_Tag 0x0711
#define VertexTagList18_Tag 0x0712
#define VertexTagList19_Tag 0x0713
#define VertexTagList20_Tag 0x0714
#define VertexTagList21_Tag 0x0715
#define VertexTagList22_Tag 0x0716
#define VertexTagList23_Tag 0x0717
#define VertexTagList24_Tag 0x0718
#define VertexTagList25_Tag 0x0719
#define VertexTagList26_Tag 0x071a
#define VertexTagList27_Tag 0x071b
#define VertexTagList28_Tag 0x071c
#define VertexTagList29_Tag 0x071d
#define VertexTagList30_Tag 0x071e
#define VertexTagList31_Tag 0x071f
#define SetPipe_Tag 0x0810
#define RestartPipe_Tag 0x0811
#define DeltaMultiTexture0A_Tag 0x0840
#define DeltaMultiTexture0B_Tag 0x0841
#define DeltaMultiTexture0C_Tag 0x0842
#define DeltaMultiTexture0D_Tag 0x0843
#define DeltaMultiTexture0E_Tag 0x0844
#define DeltaMultiTexture0F_Tag 0x0845
#define DeltaMultiTexture0G_Tag 0x0846
#define DeltaMultiTexture0H_Tag 0x0847
#define DeltaMultiTexture1A_Tag 0x0848
#define DeltaMultiTexture1B_Tag 0x0849
#define DeltaMultiTexture1C_Tag 0x084a
#define DeltaMultiTexture1D_Tag 0x084b
#define DeltaMultiTexture1E_Tag 0x084c
#define DeltaMultiTexture1F_Tag 0x084d
#define DeltaMultiTexture1G_Tag 0x084e
#define DeltaMultiTexture1H_Tag 0x084f
#define DeltaMultiTexture2A_Tag 0x0850
#define DeltaMultiTexture2B_Tag 0x0851
#define DeltaMultiTexture2C_Tag 0x0852
#define DeltaMultiTexture2D_Tag 0x0853
#define DeltaMultiTexture2E_Tag 0x0854
#define DeltaMultiTexture2F_Tag 0x0855
#define DeltaMultiTexture2G_Tag 0x0856
#define DeltaMultiTexture2H_Tag 0x0857
#define DeltaMultiTexture3A_Tag 0x0858
#define DeltaMultiTexture3B_Tag 0x0859
#define DeltaMultiTexture3C_Tag 0x085a
#define DeltaMultiTexture3D_Tag 0x085b
#define DeltaMultiTexture3E_Tag 0x085c
#define DeltaMultiTexture3F_Tag 0x085d
#define DeltaMultiTexture3G_Tag 0x085e
#define DeltaMultiTexture3H_Tag 0x085f
#define TAq_Tag 0x0870
#define TAr_Tag 0x0871
#define TAt_Tag 0x0872
#define TAs1_Tag 0x0873
#define TAs2_Tag 0x0874
#define TAs3_Tag 0x0875
#define TAs4_Tag 0x0876
#define TAs3q_Tag 0x0877
#define TBq_Tag 0x0878
#define TBr_Tag 0x0879
#define TBt_Tag 0x087a
#define TBs1_Tag 0x087b
#define TBs2_Tag 0x087c
#define TBs3_Tag 0x087d
#define TBs4_Tag 0x087e
#define TBs3q_Tag 0x087f
#define TCq_Tag 0x0880
#define TCr_Tag 0x0881
#define TCt_Tag 0x0882
#define TCs1_Tag 0x0883
#define TCs2_Tag 0x0884
#define TCs3_Tag 0x0885
#define TCs4_Tag 0x0886
#define TCs3q_Tag 0x0887
#define TDq_Tag 0x0888
#define TDr_Tag 0x0889
#define TDt_Tag 0x088a
#define TDs1_Tag 0x088b
#define TDs2_Tag 0x088c
#define TDs3_Tag 0x088d
#define TDs4_Tag 0x088e
#define TDs3q_Tag 0x088f
#define TEq_Tag 0x0890
#define TEr_Tag 0x0891
#define TEt_Tag 0x0892
#define TEs1_Tag 0x0893
#define TEs2_Tag 0x0894
#define TEs3_Tag 0x0895
#define TEs4_Tag 0x0896
#define TEs3q_Tag 0x0897
#define TFq_Tag 0x0898
#define TFr_Tag 0x0899
#define TFt_Tag 0x089a
#define TFs1_Tag 0x089b
#define TFs2_Tag 0x089c
#define TFs3_Tag 0x089d
#define TFs4_Tag 0x089e
#define TFs3q_Tag 0x089f
#define TGq_Tag 0x08a0
#define TGr_Tag 0x08a1
#define TGt_Tag 0x08a2
#define TGs1_Tag 0x08a3
#define TGs2_Tag 0x08a4
#define TGs3_Tag 0x08a5
#define TGs4_Tag 0x08a6
#define TGs3q_Tag 0x08a7
#define THq_Tag 0x08a8
#define THr_Tag 0x08a9
#define THt_Tag 0x08aa
#define THs1_Tag 0x08ab
#define THs2_Tag 0x08ac
#define THs3_Tag 0x08ad
#define THs4_Tag 0x08ae
#define THs3q_Tag 0x08af
#define StripeOwnership_Tag 0x08b0
#define StripeFilterYOffset_Tag 0x08b1
#define PointExtend_Tag 0x08b2
#define AAPointExtend_Tag 0x08b3
#define LineExtend_Tag 0x08b4
#define AALineExtend_Tag 0x08b5
#define TriangleExtend_Tag 0x08b6
#define AATriangleExtend_Tag 0x08b7
#define StripeYBias_Tag 0x08b8
#define VBFactor0_Tag 0x08bc
#define VBFactor1_Tag 0x08bd
#define NBFactor0_Tag 0x08be
#define NBFactor1_Tag 0x08bf
#define MatrixModeAnd_Tag 0x08c0
#define MatrixModeOr_Tag 0x08c1
#define PipeLoadAnd_Tag 0x08c2
#define PipeLoadOr_Tag 0x08c3
#define MatrixSelect_Tag 0x08d0
#define MatrixStatus_Tag 0x08d1
#define SetUnitMatrix_Tag 0x08d2
#define LoadMatrix_Tag 0x08d3
#define MultiplyMatrix_Tag 0x08d4
#define ResetMatrixStack_Tag 0x08d5
#define PushMatrix_Tag 0x08d6
#define PopMatrix_Tag 0x08d7
#define GetMatrix_Tag 0x08d8
#define InvertCurrentMatrix_Tag 0x08d9
#define ComputeMatrices_Tag 0x08da
#define PipeLoad_Tag 0x08dc
#define CurrentMatrix0_Tag 0x08e0
#define CurrentMatrix1_Tag 0x08e1
#define CurrentMatrix2_Tag 0x08e2
#define CurrentMatrix3_Tag 0x08e3
#define CurrentMatrix4_Tag 0x08e4
#define CurrentMatrix5_Tag 0x08e5
#define CurrentMatrix6_Tag 0x08e6
#define CurrentMatrix7_Tag 0x08e7
#define CurrentMatrix8_Tag 0x08e8
#define CurrentMatrix9_Tag 0x08e9
#define CurrentMatrix10_Tag 0x08ea
#define CurrentMatrix11_Tag 0x08eb
#define CurrentMatrix12_Tag 0x08ec
#define CurrentMatrix13_Tag 0x08ed
#define CurrentMatrix14_Tag 0x08ee
#define CurrentMatrix15_Tag 0x08ef
#define LightNumber_Tag 0x08f0
#define LightPositionX_Tag 0x08f1
#define LightPositionY_Tag 0x08f2
#define LightPositionZ_Tag 0x08f3
#define LightPositionW_Tag 0x08f4
#define SpotLightDirectionX_Tag 0x08f5
#define SpotLightDirectionY_Tag 0x08f6
#define SpotLightDirectionZ_Tag 0x08f7
#define BoundingBoxMinX_Tag 0x08fa
#define BoundingBoxMinY_Tag 0x08fb
#define BoundingBoxMinZ_Tag 0x08fc
#define BoundingBoxMaxX_Tag 0x08fd
#define BoundingBoxMaxY_Tag 0x08fe
#define BoundingBoxMaxZ_Tag 0x08ff
#define StartBoundingVolume_Tag 0x0910
#define BoundingVertexX_Tag 0x0913
#define BoundingVertexY_Tag 0x0914
#define BoundingVertexZ_Tag 0x0915
#define BNz_Tag 0x0920
#define BNy_Tag 0x0921
#define BNx_Tag 0x0922
#define BVw_Tag 0x0923
#define BVz_Tag 0x0924
#define BVy_Tag 0x0925
#define BVx2_Tag 0x0926
#define BVx3_Tag 0x0927
#define BVx4_Tag 0x0928
#define BlendVertex_Tag 0x0930
#define BlendNormal_Tag 0x0931

#define N_Tag 0x800

#endif // _TAG_H_

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\softcopy.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: softcopy.h
*
* Content:
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/


#ifdef __SOFTCOPY
#pragma message ("FILE : "__FILE__" : Multiple Inclusion");
#endif

#define __SOFTCOPY

#ifndef __EREG
#include "ereg.h"
#endif
// For the gigi specific registers.
#ifndef __GIGIREGL
#include "gigiregl.h"
#endif
#ifndef _REG_H_
#include "reg.h"
#endif

#define P3_LOD_LEVELS 16
#define G3_TEXTURE_STAGES 8

typedef struct {
    // Common Local Buffer Registers
    __GlintLBReadModeFmat               LBReadMode;
    __GlintLBReadFormatFmat             LBReadFormat;
    __GlintLBWriteModeFmat              LBWriteMode;

    // Common Frame Buffer Registers
    __GlintFBReadModeFmat               FBReadMode;
    __GlintFBWriteModeFmat              FBWriteMode;
    __GlintLogicalOpModeFmat            LogicalOpMode;
    __GlintDitherModeFmat               DitherMode;
    __GlintColorDDAModeFmat             ColorDDAMode;

    // Common Depth/Stencil/Window Registers
    __GlintDepthModeFmat                DepthMode;
    __GlintStencilModeFmat              StencilMode;
    __GlintStencilDataFmat              StencilData;
    __GigiWindowFmat                    PermediaWindow;

    // Alpha/Fog registers
    __GigiAlphaBlendModeFmat            PermediaAlphaBlendMode;

    // Fog unit
    __GlintFogModeFmat                  FogMode;

    // YUV Unit
    __GigiYUVModeFmat                   PermediaYUVMode;

    // Permedia Texture Registers
    __GigiTextureColorModeFmat          PermediaTextureColorMode;
    __GigiTextureAddrModeFmat           PermediaTextureAddressMode;
    __GigiTextureReadModeFmat           PermediaTextureReadMode;
    __GigiTextureDataFormatFmat         PermediaTextureDataFormat;
    __GigiTextureMapFormatFmat          PermediaTextureMapFormat;

    // Scissor/Stipple unit
    __GigiScissorMinXYFmat              ScissorMinXY;
    __GigiScissorMaxXYFmat              ScissorMaxXY;
    __GigiScreenSizeFmat                ScreenSize;

    // ****************

    // P3 Registers
    // Frame buffer
    struct FBWriteBufferWidth               P3RXFBWriteBufferWidth0;
    struct FBDestReadBufferWidth            P3RXFBDestReadBufferWidth0;                
    struct FBSourceReadBufferWidth          P3RXFBSourceReadBufferWidth;
    struct FBDestReadEnables                P3RXFBDestReadEnables;
    struct FBWriteMode                      P3RXFBWriteMode;
    struct ChromaTestMode                   P3RXChromaTestMode;

    // Local buffer
    struct LBSourceReadMode                 P3RXLBSourceReadMode;
    struct LBDestReadMode                   P3RXLBDestReadMode;
    struct LBWriteMode                      P3RXLBWriteMode;
    struct DepthMode                        P3RXDepthMode;
    struct LBReadFormat                     P3RXLBReadFormat;
    struct LBWriteFormat                    P3RXLBWriteFormat;
    
    // Textures
    struct TextureReadMode                  P3RXTextureReadMode0;
    struct TextureReadMode                  P3RXTextureReadMode1;
    struct TextureIndexMode                 P3RXTextureIndexMode0;
    struct TextureIndexMode                 P3RXTextureIndexMode1;
    struct TextureMapWidth                  P3RXTextureMapWidth[P3_LOD_LEVELS];
    struct TextureCoordMode                 P3RXTextureCoordMode;
    struct TextureApplicationMode           P3RXTextureApplicationMode;
    struct TextureFilterMode                P3RXTextureFilterMode;
    struct TextureCompositeRGBAMode         P3RXTextureCompositeColorMode0;
    struct TextureCompositeRGBAMode         P3RXTextureCompositeColorMode1;
    struct TextureCompositeRGBAMode         P3RXTextureCompositeAlphaMode0;
    struct TextureCompositeRGBAMode         P3RXTextureCompositeAlphaMode1;
    struct LUTMode                          P3RXLUTMode;
    struct TextureCacheReplacementMode      P3RXTextureCacheReplacementMode;

    // Stencil
    struct StencilMode                      P3RXStencilMode;
    struct StencilData                      P3RXStencilData;
    struct Window                           P3RXWindow;

    // Fog
    struct FogMode                          P3RXFogMode;

    // Alpha
    struct AlphaTestMode                    P3RXAlphaTestMode;
    struct AlphaBlendAlphaMode              P3RXAlphaBlendAlphaMode;
    struct AlphaBlendColorMode              P3RXAlphaBlendColorMode;

    // Framebuffer
    struct FBDestReadMode                   P3RXFBDestReadMode;
    struct FBSourceReadMode                 P3RXFBSourceReadMode;

    // Rasterizer
    struct RasterizerMode                   P3RXRasterizerMode;
    struct ScanlineOwnership                P3RXScanlineOwnership;

    // Scissor
    __GlintXYFmat                           P3RXScissorMinXY;
    __GlintXYFmat                           P3RXScissorMaxXY;

    // P3 Specific registers
    
    // Delta
    union
    {
        struct GMDeltaMode                  GammaDeltaMode;
        struct P3DeltaMode                  P3RX_P3DeltaMode;
        __GigiDeltaModeFmat                 DeltaMode;
    };

    struct DeltaControl                     P3RX_P3DeltaControl;
    struct VertexControl                    P3RX_P3VertexControl;

    // P4 Specific registers
    struct DeltaFormatControl               P4DeltaFormatControl;

    // GAMMA Registers
    struct Gamma3GeometryMode               G3GeometryMode;
    struct GeometryMode                     G1GeometryMode;
    struct TransformMode                    GammaTransformMode;
    struct NormaliseMode                    GammaNormaliseMode;
    struct LightingMode                     GammaLightingMode;
    struct MaterialMode                     GammaMaterialMode;
    struct ColorMaterialMode                GammaColorMaterialMode;
    struct StripeFilterMode                 GammaStripeFilterMode;
    struct MatrixMode                       GammaMatrixMode;
    struct PipeMode                         GammaPipeMode;
    struct PipeLoad                         GammaPipeLoad;
    struct VertexMachineMode                GammaVertexMachineMode;
    struct TextureMode                      GammaTextureMode[G3_TEXTURE_STAGES];
    struct FogVertexMode                    GammaFogVertexMode;

    // Total 30 DWORDS : 120 Bytes

    struct LineStippleMode                  PXRXLineStippleMode;
} P3_SOFTWARECOPY;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\tvp3026.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: tvp3026.h
*
* Content:  This module contains the definitions for the TI TVP3026 RAMDAC.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#define ADbgpf VideoDebugPrint

//
// TI TVP3026 RAMDAC definitions
// This set of registers resides at &(pCtrlRegs->ExternalVideo)
//
typedef struct _tvp3026_regs {
    volatile RAMDAC_REG  pciAddrWr;      // 0x00 - palette/cursor RAM write address, Index Register
    volatile RAMDAC_REG  palData;        // 0x01 - palette RAM data
    volatile RAMDAC_REG  pixelMask;      // 0x02 - pixel read mask
    volatile RAMDAC_REG  pcAddrRd;          // 0x03 - palette/cursor RAM read address
    
    volatile RAMDAC_REG  curAddrWr;      // 0x04 - cursor/overscan color write address
    volatile RAMDAC_REG  curData;          // 0x05 - cursor/overscan color data
    volatile RAMDAC_REG  Reserverd1;     // 0x06 - reserved
    volatile RAMDAC_REG  curAddrRd;         // 0x07 - cursor/overscan color read address

    volatile RAMDAC_REG  Reserverd2;     // 0x08 - reserved
    volatile RAMDAC_REG  curCtl;           // 0x09 - direct cursor control
    volatile RAMDAC_REG  indexData;      // 0x0A - indexed data
    volatile RAMDAC_REG  curRAMData;     // 0x0B - cursor RAM data
    
    volatile RAMDAC_REG  cursorXLow;     // 0x0C - cursor position X low byte 
    volatile RAMDAC_REG  cursorXHigh;    // 0x0D - cursor position X high byte 
    volatile RAMDAC_REG  cursorYLow;     // 0x0E - cursor position Y low byte 
    volatile RAMDAC_REG  cursorYHigh;    // 0x0F - cursor position Y high byte 
} TVP3026RAMDAC, *pTVP3026RAMDAC;

// macro declared by any function wishing to use the TI TVP3026 RAMDAC . MUST be declared
// after GLINT_DECL.
//
#if MINIVDD
#define TVP3026_DECL \
    pTVP3026RAMDAC   pTVP3026Regs = (pTVP3026RAMDAC)&(pDev->pRegisters->Glint.ExtVCReg)
#else
#define TVP3026_DECL \
    pTVP3026RAMDAC   pTVP3026Regs = (pTVP3026RAMDAC)&(pRegisters->Glint.ExtVCReg)
#endif

// use the following macros as the address to pass to the
// VideoPortWriteRegisterUlong function
//
//  Palette Access
#define __TVP3026_PAL_WR_ADDR                 ((PULONG)&(pTVP3026Regs->pciAddrWr.reg))
#define __TVP3026_PAL_RD_ADDR                 ((PULONG)&(pTVP3026Regs->palAddrRd.reg))
#define __TVP3026_PAL_DATA                    ((volatile PULONG)&(pTVP3026Regs->palData.reg))

// Pixel mask
#define __TVP3026_PIXEL_MASK                ((PULONG)&(pTVP3026Regs->pixelMask.reg))

// Access to the indexed registers
#define __TVP3026_INDEX_ADDR                ((PULONG)&(pTVP3026Regs->pciAddrWr.reg))
#define __TVP3026_INDEX_DATA                  ((PULONG)&(pTVP3026Regs->indexData.reg))

// Access to the Cursor
#define __TVP3026_CUR_RAM_WR_ADDR            ((PULONG)&(pTVP3026Regs->pciAddrWr.reg))
#define __TVP3026_CUR_RAM_RD_ADDR             ((PULONG)&(pTVP3026Regs->palAddrRd.reg))
#define __TVP3026_CUR_RAM_DATA                ((PULONG)&(pTVP3026Regs->curRAMData.reg))

#define __TVP3026_CUR_WR_ADDR                ((PULONG)&(pTVP3026Regs->curAddrWr.reg))
#define __TVP3026_CUR_RD_ADDR                 ((PULONG)&(pTVP3026Regs->curAddrRd.reg))
#define __TVP3026_CUR_DATA                    ((PULONG)&(pTVP3026Regs->curData.reg))

#define __TVP3026_CUR_CTL                   ((PULONG)&(pTVP3026Regs->curCtl.reg))

// Access to the overscan color
#define __TVP3026_OVRC_WR_ADDR                ((PULONG)&(pTVP3026Regs->curAddrWr.reg))
#define __TVP3026_OVRC_RD_ADDR                 ((PULONG)&(pTVP3026Regs->curAddrRd.reg))
#define __TVP3026_OVRC_DATA                    ((PULONG)&(pTVP3026Regs->curData.reg))

// Cursor position control
#define __TVP3026_CUR_X_LSB                    ((PULONG)&(pTVP3026Regs->cursorXLow.reg))
#define __TVP3026_CUR_X_MSB                 ((PULONG)&(pTVP3026Regs->cursorXHigh.reg))
#define __TVP3026_CUR_Y_LSB                    ((PULONG)&(pTVP3026Regs->cursorYLow.reg))
#define __TVP3026_CUR_Y_MSB                     ((PULONG)&(pTVP3026Regs->cursorYHigh.reg))



// ----------------------Values for some direct registers-----------------------

/********************************************************************************/
/*              DIRECT REGISTER - CURSOR AND OVERSCAN COLOR                     */
/********************************************************************************/
//  ** TVP3026_OVRC_WR_ADDR
//  ** TVP3026_OVRC_RD_ADDR 
//  ** TVP3026_CUR_WR_ADDR
//  ** TVP3026_CUR_RD_ADDR
//      Default - undefined
#define TVP3026_OVERSCAN_COLOR                  0x00
#define TVP3026_CURSOR_COLOR0                   0x01
#define TVP3026_CURSOR_COLOR1                   0x02
#define TVP3026_CURSOR_COLOR2                   0x03

/********************************************************************************/
/*              DIRECT REGISTER - CURSOR CONTROL                                */
/********************************************************************************/
//  ** TVP3026_CUR_CTL
//      Default - 0x00
#define TVP3026_CURSOR_OFF                      0x00    // Cursor off
#define TVP3026_CURSOR_COLOR                    0x01    // 2-bits select color
#define TVP3026_CURSOR_XGA                      0x02    // 2-bits select XOR
#define TVP3026_CURSOR_XWIN                     0x03    // 2-bits select transparency/color


/********************************************************************************/
/*              DIRECT REGISTER - CURSOR POSITION CONTROL                       */
/********************************************************************************/
//  ** TVP3026_CUR_X_LSB 
//  ** TVP3026_CUR_X_MSB 
//  ** TVP3026_CUR_Y_LSB 
//  ** TVP3026_CUR_Y_MSB 
//      Default - undefined
// Values written into those registers represent the BOTTOM-RIGHT corner
// of the cursor. If 0 is in X or Y position - the cursor is off the screen
// Only 12 bits are used, giving the range from 0 to 4095 ( 0x0000 - 0x0FFF)
// The size of the cursor is (64,64) (0x40, 0x40)
#define TVP3026_CURSOR_OFFSCREEN                0x00    // Cursor offscreen


// ------------------------Indirect indexed registers map--------------------------
/********************************************************************************/
/*              INDIRECT REGISTER - SILICON REVISION                            */
/********************************************************************************/
#define __TVP3026_SILICON_REVISION              0x01    // Chip revision: 
                                                        //  bits 4-7 - major number, 0-3 - minor number
// TVP3026_REVISION_LEVEL
#define TVP3026_REVISION_LEVEL                  0x01    // predefined

// TVP3030_REVISION_LEVEL
#define TVP3030_REVISION_LEVEL                  0x00    // predefined

/********************************************************************************/
/*              INDIRECT REGISTER - CHIP ID                                     */
/********************************************************************************/
#define __TVP3026_CHIP_ID                   0x3F    //  
//      Default - 0x26

#define TVP3026_ID_CODE                     0x26    // predefined
#define TVP3030_ID_CODE                     0x30    // predefined

/********************************************************************************/
/*              INDIRECT REGISTER - CURSOR CONTROL                              */
/********************************************************************************/
#define __TVP3026_CURSOR_CONTROL                    0x06    // Indirect cursor control - 
//      Default - 0x00
#define TVP3026_CURSOR_USE_DIRECT_CCR           (1 << 7)// Enable Direct Cursor Control Register
#define TVP3026_CURSOR_USE_INDEX_CCR            (0 << 7)// Disable Direct Cursor Control Register

#define TVP3026_CURSOR_INTERLACE_ODD            (1 << 6)// Detect odd field as 1
#define TVP3026_CURSOR_INTERLACE_EVEN           (0 << 6)// Detect even field as 1

#define TVP3026_CURSOR_INTERLACE_ON             (1 << 5)// Enable interlaced cursor
#define TVP3026_CURSOR_INTERLACE_OFF            (0 << 5)// Disable interlaced cursor

#define TVP3026_CURSOR_VBLANK_4096              (1 << 4)// Blank is detected after 4096
#define TVP3026_CURSOR_VBLANK_2048              (0 << 4)//      or 2048 dot clocks

#define TVP3026_CURSOR_RAM_ADDRESS(x)            (((x) & 0x03) << 2)// High bits of cursor RAM address
#define TVP3026_CURSOR_RAM_MASK                 ((0x03) << 2)       // Mask for high bits of cursor RAM address
// CURSOR_OFF                           0x00    // Cursor off
// CURSOR_COLOR                         0x01    // 2-bits select color
// CURSOR_XGA                           0x02    // 2-bits select XOR
// CURSOR_XWIN                          0x03    // 2-bits select transparency/color



/********************************************************************************/
/*              INDIRECT REGISTER - LATCH CONTROL                               */
/********************************************************************************/
#define __TVP3026_LATCH_CONTROL                 0x0F    //  Latch control register - 
//      Default - 0x06
#define TVP3026_LATCH_ALL_MODES                 0x06    // All modes except packed-24
#define TVP3026_LATCH_4_3                       0x07    // 4:3 or 8:3 packed-24 
#define TVP3026_LATCH_5_2                       0x20    // 5:2  packed-24 
#define TVP3026_LATCH_5_4_1                     0x1F    // 5:4  packed-24 x1 horz zoom
#define TVP3026_LATCH_5_4_2                     0x1E    // 5:4  packed-24 x2 horz zoom
#define TVP3026_LATCH_5_4_4                     0x1C    // 5:4  packed-24 x4 horz zoom
#define TVP3026_LATCH_5_4_8                     0x18    // 5:4  packed-24 x8 horz zoom


/********************************************************************************/
/*              INDIRECT REGISTER - TRUE COLOR CONTROL                          */
/********************************************************************************/
#define __TVP3026_TRUE_COLOR                    0x18    //  True Color control
//      Default - 0x80

/********************************************************************************/
/*              INDIRECT REGISTER - MULTIPLEX CONTROL                           */
/********************************************************************************/
#define __TVP3026_MULTIPLEX_CONTROL             0x19    //  Multiplex control
//      Default - 0x98

/********************************************************************************/
/*              INDIRECT REGISTER - CLOCK SELECTION                             */
/********************************************************************************/
#define __TVP3026_CLOCK                         0x1A    //  
//      Default - 0x07
#define TVP3026_SCLK_ENABLE                     (1 << 7)// Enable SCLK output
#define TVP3026_SCLK_DISABLE                    (0 << 7)// Disable SCLK output
#define TVP3026_VCLK_ZERO                       (7 << 4)// VCLK forced to Logical "0"
#define TVP3026_VCLK_DOTCLOCK                   (0 << 4)// VCLK is equal to Dot clock
#define TVP3026_VCLK_DOTCLOCK_DIV2              (1 << 4)// VCLK is equal to Dot clock/2
#define TVP3026_VCLK_DOTCLOCK_DIV4              (2 << 4)// VCLK is equal to Dot clock/4
#define TVP3026_VCLK_DOTCLOCK_DIV8              (3 << 4)// VCLK is equal to Dot clock/8
#define TVP3026_VCLK_DOTCLOCK_DIV16             (4 << 4)// VCLK is equal to Dot clock/16
#define TVP3026_VCLK_DOTCLOCK_DIV32             (5 << 4)// VCLK is equal to Dot clock/32
#define TVP3026_VCLK_DOTCLOCK_DIV64             (6 << 4)// VCLK is equal to Dot clock/64

#define TVP3026_CLK_CLK0                        (0 << 0)// Select CLK0 as clock source
#define TVP3026_CLK_CLK1                        (1 << 0)// Select CLK1 as clock source
#define TVP3026_CLK_CLK2_TTL                    (2 << 0)// Select CLK2 as clock source
#define TVP3026_CLK_CLK2N_TTL                   (3 << 0)// Select /CLK2 as clock source
#define TVP3026_CLK_CLK2_ECL                    (4 << 0)// Select CLK2 and /CLK2 as ECL clock source
#define TVP3026_CLK_PIXEL_PLL                   (5 << 0)// Select Pixel Clock PLL as clock source
#define TVP3026_CLK_DISABLE                     (6 << 0)// Disable clock source / Power-save mode
#define TVP3026_CLK_CLK0_VGA                    (7 << 0)// Select CLK0 as clock source with VGA latching

/********************************************************************************/
/*              INDIRECT REGISTER - PALETTE PAGE                                */
/********************************************************************************/
#define __TVP3026_PALETTE_PAGE                  0x1C    //  
//      Default - 0x00

/********************************************************************************/
/*              INDIRECT REGISTER - GENERAL CONTROL                             */
/********************************************************************************/
#define __TVP3026_GENERAL_CONTROL               0x1D    //  
//      Default - 0x00
#define TVP3026_OVERSCAN_ENABLE                 (1 << 6)// Enable overscan coloring
#define TVP3026_OVERSCAN_DISABLE                (0 << 6)// Disable overscan coloring
#define TVP3026_SYNC_ENABLE                     (1 << 5)// Enable SYNC signal on IOG
#define TVP3026_SYNC_DISABLE                    (0 << 5)// Disable SYNC signal on IOG
#define TVP3026_PEDESTAL_ON                     (1 << 4)// Enable 7.5 IRE blanking pedestal 
#define TVP3026_PEDESTAL_OFF                    (0 << 4)// Disable blanking pedestal
#define TVP3026_BIG_ENDIAN                      (1 << 3)// Big Endian format on pixel bus
#define TVP3026_LITTLE_ENDIAN                   (0 << 3)// Little Endian format on pixel bus
#define TVP3026_VSYNC_INVERT                    (1 << 1)// Invert VSYNC signal on VSYNCOUT
#define TVP3026_VSYNC_NORMAL                    (0 << 1)// Do not invert VSYNC signal on VSYNCOUT
#define TVP3026_HSYNC_INVERT                    (1 << 0)// Invert HSYNC signal on HSYNCOUT
#define TVP3026_HSYNC_NORMAL                    (0 << 0)// Do not invert HSYNC signal on HSYNCOUT

/********************************************************************************/
/*              INDIRECT REGISTER - MISC CONTROL                                */
/********************************************************************************/
#define __TVP3026_MISC_CONTROL                  0x1E    //  
//      Default - 0x00
#define TVP3026_PSEL_INVERT                     (1 << 5)// PSEL == 1 - Pseudo/True Color
#define TVP3026_PSEL_NORMAL                     (0 << 5)// PSEL == 1 - Direct Color
#define TVP3026_PSEL_ENABLE                     (1 << 4)// PSEL controls Color Switching
#define TVP3026_PSEL_DISABLE                    (0 << 4)// PSEL is disabled
#define TVP3026_DAC_8BIT                        (1 << 3)// DAC is in 8-bit mode
#define TVP3026_DAC_6BIT                        (0 << 3)// DAC is in 6-bit mode
#define TVP3026_DAC_6BITPIN_DISABLE             (1 << 2)// Disable 6/8 pin and use bit 3 of this register
#define TVP3026_DAC_6BITPIN_ENABLE              (0 << 2)// Use 6/8 pin and ignore bit 3 of this register
#define TVP3026_DAC_POWER_ON                    (0 << 0)// Turn DAC Power on 
#define TVP3026_DAC_POWER_OFF                   (1 << 0)// Turn DAC Power off 

/********************************************************************************/
/*              INDIRECT REGISTER - GP I/O CONTROL                              */
/********************************************************************************/
#define __TVP3026_GP_CONTROL                0x2A    //  
//      Default - 0x00

/********************************************************************************/
/*              INDIRECT REGISTER - GP I/O DATA                                 */
/********************************************************************************/
#define __TVP3026_GP_DATA                   0x2B    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - PLL ADDRESS                                 */
/********************************************************************************/
#define __TVP3026_PLL_ADDRESS               0x2C    //  
//      Default - undefined
#define TVP3026_PIXEL_CLOCK_START           0xFC// Start Pixel Clock Programming
#define TVP3026_MCLK_START                  0xF3// Start MCLK Programming
#define TVP3026_LOOP_CLOCK_START            0xCF// Start Loop Clock Programming

/********************************************************************************/
/*              INDIRECT REGISTER - PLL PIXEL DATA                              */
/********************************************************************************/
#define __TVP3026_PLL_PIX_DATA              0x2D    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - PLL MEMORY DATA                             */
/********************************************************************************/
#define __TVP3026_PLL_MEM_DATA              0x2E    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - PLL LOOP DATA                               */
/********************************************************************************/
#define __TVP3026_PLL_LOOP_DATA             0x2F    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY OVERLAY LOW                       */
/********************************************************************************/
#define __TVP3026_CCOVR_LOW                 0x30    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY OVERLAY HIGH                      */
/********************************************************************************/
#define __TVP3026_CCOVR_HIGH                0x31    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY RED LOW                           */
/********************************************************************************/
#define __TVP3026_CCRED_LOW                 0x32    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY RED HIGH                          */
/********************************************************************************/
#define __TVP3026_CCRED_HIGH                0x33    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY GREEN LOW                         */
/********************************************************************************/
#define __TVP3026_CCGREEN_LOW               0x34    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY RED HIGH                          */
/********************************************************************************/
#define __TVP3026_CCGREEN_HIGH              0x35    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY BLUE LOW                          */
/********************************************************************************/
#define __TVP3026_CCBLUE_LOW                0x36    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY BLUE HIGH                         */
/********************************************************************************/
#define __TVP3026_CCBLUE_HIGH               0x37    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY CONTROL                           */
/********************************************************************************/
#define __TVP3026_CC_CONTROL                0x38    //  
//      Default - 0x00

/********************************************************************************/
/*              INDIRECT REGISTER - MCLK/LOOP CONTROL                           */
/********************************************************************************/
#define __TVP3026_MCLK_CONTROL              0x39    //  
//      Default - 0x18
#define TVP3026_RCLK_LOOP                       (1 << 5)// RCLK is made from LCLK - all other modes
#define TVP3026_RCLK_PIXEL                      (0 << 5)// RCLK is clocked by Pixel Clock (VGA Mode)
#define TVP3026_MCLK_PLL                        (1 << 4)// MCLK from PLL - normal mode
#define TVP3026_MCLK_DOT                        (0 << 4)// MCLK from dot clock - during freq. change
#define TVP3026_MCLK_STROBE_HIGH                (1 << 3)// Strobe high for bit 4
#define TVP3026_MCLK_STROBE_LOW                 (0 << 3)// Strobe low for bit 4
#define TVP3026_LOOP_DIVIDE2                    (0 << 0)// Divide Loop clock by 2
#define TVP3026_LOOP_DIVIDE4                    (1 << 0)// Divide Loop clock by 4
#define TVP3026_LOOP_DIVIDE6                    (2 << 0)// Divide Loop clock by 6
#define TVP3026_LOOP_DIVIDE8                    (3 << 0)// Divide Loop clock by 8
#define TVP3026_LOOP_DIVIDE10                   (4 << 0)// Divide Loop clock by 10
#define TVP3026_LOOP_DIVIDE12                   (5 << 0)// Divide Loop clock by 12
#define TVP3026_LOOP_DIVIDE14                   (6 << 0)// Divide Loop clock by 14
#define TVP3026_LOOP_DIVIDE16                   (7 << 0)// Divide Loop clock by 16

/********************************************************************************/
/*              INDIRECT REGISTER - SENSE TEST                                  */
/********************************************************************************/
#define __TVP3026_SENSE_TEST                0x3A    //  
//      Default - 0x00

/********************************************************************************/
/*              INDIRECT REGISTER - TEST MODE DATA                                  */
/********************************************************************************/
#define __TVP3026_TEST_MODE                 0x3B    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - CRC REMAINDER LSB                           */
/********************************************************************************/
#define __TVP3026_CRC_LSB                   0x3C    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - CRC REMAINDER MSB                           */
/********************************************************************************/
#define __TVP3026_CRC_MSB                   0x3D    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - CRC BITS SELECT                             */
/********************************************************************************/
#define __TVP3026_CRC_SELECT                0x3E    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - SOFTWARE RESET                                      */
/********************************************************************************/
#define __TVP3026_SOFT_RESET                0xFF    //  
//      Default - undefined




//
// On rev 1 chips we need to SYNC with GLINT while accessing the RAMDAC. This
// is because accesses to the RAMDAC can be corrupted by localbuffer
// activity. Put this macro before accesses that can co-exist with GLINT
// 3D activity, Must have initialized glintInfo before using this.
//
#define TVP3026_SYNC_WITH_GLINT \
{ \
    if (GLInfo.wRenderChipRev == GLINT300SX_REV1) \
        SYNC_WITH_GLINT; \
}




/*
// We never need a delay between each write to the 3026. The only way to guarantee
// that the write has completed used to be to read from a GLINT control register.
// Reading forces any posted writes to be flushed out. PPC needs 2 reads
// to give us enough time.
//#define TVP3026_DELAY \
//{ \
//    volatile LONG __junk; \
//    __junk = pDev->pRegisters->Glint.FBModeSel; \
//}
//#else
*/
#define TVP3026_DELAY

// macro to load a given data value into an internal TVP3026 register.
//
#define TVP3026_WRITE_CURRENT_INDEX TVP3026_SET_INDEX_REG
#define TVP3026_SET_INDEX_REG(index) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_INDEX_ADDR, (ULONG)((index) & 0xff)); \
    TVP3026_DELAY; \
}

#define TVP3026_READ_CURRENT_INDEX(data) \
{ \
    data = VideoPortReadRegisterUlong(__TVP3026_INDEX_ADDR) & 0xff; \
    TVP3026_DELAY; \
}

#define TVP3026_WRITE_INDEX_REG(index, data) \
{ \
    TVP3026_SET_INDEX_REG(index);                            \
    ADbgpf(("*(0x%X) <-- 0x%X\n", __TVP3026_INDEX_DATA, (data) & 0xff)); \
    VideoPortWriteRegisterUlong(__TVP3026_INDEX_DATA, (ULONG)((data) & 0xff)); \
    TVP3026_DELAY; \
}

#define TVP3026_READ_INDEX_REG(index, data) \
{ \
    TVP3026_SET_INDEX_REG(index); \
    data = VideoPortReadRegisterUlong(__TVP3026_INDEX_DATA) & 0xff;   \
    TVP3026_DELAY; \
    ADbgpf(("0x%X <-- *(0x%X)\n", data, __TVP3026_INDEX_DATA)); \
}


// macros to write a given RGB triplet into cursors 0, 1 and 2
#define TVP3026_SET_CURSOR_COLOR0(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_WR_ADDR,   (ULONG)(TVP3026_CURSOR_COLOR0));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_DATA,    (ULONG)(red));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_DATA,    (ULONG)(green));  \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_DATA,    (ULONG)(blue));   \
    TVP3026_DELAY; \
}

#define TVP3026_SET_CURSOR_COLOR1(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_WR_ADDR,   (ULONG)(TVP3026_CURSOR_COLOR1));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_DATA,    (ULONG)(red));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_DATA,    (ULONG)(green));  \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_DATA,    (ULONG)(blue));   \
    TVP3026_DELAY; \
}

#define TVP3026_SET_CURSOR_COLOR2(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_WR_ADDR,   (ULONG)(TVP3026_CURSOR_COLOR2));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_DATA,    (ULONG)(red));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_DATA,    (ULONG)(green));  \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_DATA,    (ULONG)(blue));   \
    TVP3026_DELAY; \
}

#define TVP3026_SET_OVERSCAN_COLOR(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_OVRC_WR_ADDR,   (ULONG)(TVP3026_OVERSCAN_COLOR));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_OVRC_DATA,    (ULONG)(red));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_OVRC_DATA,    (ULONG)(green));  \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_OVRC_DATA,    (ULONG)(blue));   \
    TVP3026_DELAY; \
}



// macros to load a given RGB triple into the TVP3026 palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use TVP3026_PALETTE_START and multiple TVP3026_LOAD_PALETTE calls to load
// a contiguous set of entries. Use TVP3026_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//
#define TVP3026_PALETTE_START_WR(index) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_PAL_WR_ADDR,     (ULONG)(index));    \
    TVP3026_DELAY; \
}

#define TVP3026_PALETTE_START_RD(index) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_PAL_RD_ADDR,     (ULONG)(index));    \
    TVP3026_DELAY; \
}

#define TVP3026_LOAD_PALETTE(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_PAL_DATA,    (ULONG)(red));      \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_PAL_DATA,    (ULONG)(green));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_PAL_DATA,    (ULONG)(blue));     \
    TVP3026_DELAY; \
}

#define TVP3026_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_PAL_WR_ADDR, (ULONG)(index));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_PAL_DATA,    (ULONG)(red));      \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_PAL_DATA,    (ULONG)(green));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_PAL_DATA,    (ULONG)(blue));     \
    TVP3026_DELAY; \
}

// macro to read back a given RGB triple from the TVP3026 palette. Use after
// a call to TVP3026_PALETTE_START_RD
//
#define TVP3026_READ_PALETTE(red, green, blue) \
{ \
    red   = VideoPortReadRegisterUlong(__TVP3026_PAL_DATA) & 0xff;        \
    TVP3026_DELAY; \
    green = VideoPortReadRegisterUlong(__TVP3026_PAL_DATA) & 0xff;        \
    TVP3026_DELAY; \
    blue  = VideoPortReadRegisterUlong(__TVP3026_PAL_DATA) & 0xff;        \
    TVP3026_DELAY; \
}

// macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//
#define TVP3026_SET_PIXEL_READMASK(mask) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_PIXEL_MASK,  (ULONG)(mask)); \
    TVP3026_DELAY; \
}

#define TVP3026_READ_PIXEL_READMASK(mask) \
{ \
    mask = VideoPortReadRegisterUlong(__TVP3026_PIXEL_MASK) & 0xff; \
}

// macros to load values into the cursor array
//
#define TVP3026_CURSOR_ARRAY_START(offset) \
{ \
    volatile LONG   __temp;                                     \
    TVP3026_READ_INDEX_REG(__TVP3026_CURSOR_CONTROL, __temp);   \
    __temp &= ~TVP3026_CURSOR_RAM_MASK ;                        \
    __temp |= TVP3026_CURSOR_RAM_ADDRESS((offset)>> 8) ;        \
    TVP3026_WRITE_INDEX_REG(__TVP3026_CURSOR_CONTROL, __temp);  \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_RAM_WR_ADDR,   (ULONG)((offset)& 0xff));   \
    TVP3026_DELAY; \
}

#define TVP3026_LOAD_CURSOR_ARRAY(data) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_RAM_DATA, (ULONG)(data)); \
    TVP3026_DELAY; \
}

#define TVP3026_READ_CURSOR_ARRAY(data) \
{ \
    data = VideoPortReadRegisterUlong(__TVP3026_CUR_RAM_DATA) & 0xff; \
    TVP3026_DELAY; \
}

#define TVP3026_LOAD_CURSOR_CTRL(data) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_CTL, (ULONG)(data)); \
    TVP3026_DELAY; \
}

// macro to move the cursor
//
#define TVP3026_MOVE_CURSOR(x, y) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_X_LSB,     (ULONG)((x) & 0xff));   \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_X_MSB,     (ULONG)((x) >> 8));     \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_Y_LSB,      (ULONG)((y) & 0xff));   \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_Y_MSB,        (ULONG)((y) >> 8));     \
    TVP3026_DELAY; \
}

// macro to change the cursor hotspot
//
#define TVP3026_CURSOR_HOTSPOT(x, y) \
{ \
    TVP3026_DELAY; \
}
    
#define TVP3026_IS_FOUND(bFound)        \
{\
    volatile LONG   __revLevel;        \
    volatile LONG   __productID;    \
    volatile LONG   __oldValue;     \
    __oldValue = VideoPortReadRegisterUlong(__TVP3026_INDEX_ADDR);\
    TVP3026_DELAY; \
    TVP3026_READ_INDEX_REG (__TVP3026_SILICON_REVISION, __revLevel);\
    TVP3026_READ_INDEX_REG (__TVP3026_CHIP_ID,              __productID);    \
    bFound = (    (__revLevel >= TVP3026_REVISION_LEVEL) &&              \
                (__productID == TVP3026_ID_CODE)) ? TRUE : FALSE ;    \
    VideoPortWriteRegisterUlong(__TVP3026_INDEX_ADDR, __oldValue );    \
    TVP3026_DELAY; \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\inc\tvp4020.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: tvp4020.h
*
* Content:  This module contains the definitions for the P2 internal RAMDAC.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#define ADbgpf VideoDebugPrint

//
// TI TVP4020 RAMDAC definitions
// This set of registers resides at &(pCtrlRegs->ExternalVideo)
//
typedef struct _tvp4020_regs {
    RAMDAC_REG  pciAddrWr;      // 0x00 - palette/cursor RAM write address, Index Register
    RAMDAC_REG  palData;        // 0x01 - palette RAM data
    RAMDAC_REG  pixelMask;      // 0x02 - pixel read mask
    RAMDAC_REG  pciAddrRd;         // 0x03 - palette/cursor RAM read address
    
    RAMDAC_REG  curColAddr;     // 0x04 - cursor color address
    RAMDAC_REG  curColData;       // 0x05 - cursor color data
    RAMDAC_REG  Reserved1;      // 0x06 - reserved
    RAMDAC_REG  Reserved2;      // 0x07 - reserved

    RAMDAC_REG  Reserved3;      // 0x08 - reserved
    RAMDAC_REG  Reserved4;         // 0x09 - reserved
    RAMDAC_REG  indexData;      // 0x0A - indexed data
    RAMDAC_REG  curRAMData;     // 0x0B - cursor RAM data
    
    RAMDAC_REG  cursorXLow;     // 0x0C - cursor position X low byte 
    RAMDAC_REG  cursorXHigh;    // 0x0D - cursor position X high byte 
    RAMDAC_REG  cursorYLow;     // 0x0E - cursor position Y low byte 
    RAMDAC_REG  cursorYHigh;    // 0x0F - cursor position Y high byte 
} TVP4020RAMDAC, *pTVP4020RAMDAC;

// macro declared by any function wishing to use the P2 internal RAMDAC . MUST be declared
// after GLINT_DECL.
//
#if MINIVDD
#define TVP4020_DECL \
    pTVP4020RAMDAC   pTVP4020Regs = (pTVP4020RAMDAC)&(pDev->pRegisters->Glint.ExtVCReg)
#else
#define TVP4020_DECL \
    pTVP4020RAMDAC   pTVP4020Regs = (pTVP4020RAMDAC)&(pRegisters->Glint.ExtVCReg)
#endif

// use the following macros as the address to pass to the
// VideoPortWriteRegisterUlong function
//
//  Palette Access
#define __TVP4020_PAL_WR_ADDR                 ((PULONG)&(pTVP4020Regs->pciAddrWr.reg))
#define __TVP4020_PAL_RD_ADDR                 ((PULONG)&(pTVP4020Regs->pciAddrRd.reg))
#define __TVP4020_PAL_DATA                    ((PULONG)&(pTVP4020Regs->palData.reg))

// Pixel mask
#define __TVP4020_PIXEL_MASK                ((PULONG)&(pTVP4020Regs->pixelMask.reg))

// Access to the indexed registers
#define __TVP4020_INDEX_ADDR                ((PULONG)&(pTVP4020Regs->pciAddrWr.reg))
#define __TVP4020_INDEX_DATA                  ((PULONG)&(pTVP4020Regs->indexData.reg))

// Access to the Cursor
#define __TVP4020_CUR_RAM_WR_ADDR            ((PULONG)&(pTVP4020Regs->pciAddrWr.reg))
#define __TVP4020_CUR_RAM_RD_ADDR             ((PULONG)&(pTVP4020Regs->palAddrRd.reg))
#define __TVP4020_CUR_RAM_DATA                ((PULONG)&(pTVP4020Regs->curRAMData.reg))

#define __TVP4020_CUR_COL_ADDR                ((PULONG)&(pTVP4020Regs->curColAddr.reg))
#define __TVP4020_CUR_COL_DATA                 ((PULONG)&(pTVP4020Regs->curColData.reg))

// Cursor position control
#define __TVP4020_CUR_X_LSB                    ((PULONG)&(pTVP4020Regs->cursorXLow.reg))
#define __TVP4020_CUR_X_MSB                 ((PULONG)&(pTVP4020Regs->cursorXHigh.reg))
#define __TVP4020_CUR_Y_LSB                    ((PULONG)&(pTVP4020Regs->cursorYLow.reg))
#define __TVP4020_CUR_Y_MSB                     ((PULONG)&(pTVP4020Regs->cursorYHigh.reg))



// ----------------------Values for some direct registers-----------------------

/********************************************************************************/
/*              DIRECT REGISTER - CURSOR POSITION CONTROL                       */
/********************************************************************************/
//  ** TVP4020_CUR_X_LSB 
//  ** TVP4020_CUR_X_MSB 
//  ** TVP4020_CUR_Y_LSB 
//  ** TVP4020_CUR_Y_MSB 
//      Default - undefined
// Values written into those registers represent the BOTTOM-RIGHT corner
// of the cursor. If 0 is in X or Y position - the cursor is off the screen
// Only 12 bits are used, giving the range from 0 to 4095 ( 0x0000 - 0x0FFF)
// The size of the cursor is (64,64) (0x40, 0x40)
#define TVP4020_CURSOR_OFFSCREEN                0x00    // Cursor offscreen

/********************************************************************************/
/*              DIRECT REGISTER - CURSOR COLORS                                 */
/********************************************************************************/

#define TVP4020_CURSOR_COLOR0                   0x01
#define TVP4020_CURSOR_COLOR1                   0x02
#define TVP4020_CURSOR_COLOR2                   0x03

// ------------------------Indirect indexed registers map--------------------------

/********************************************************************************/
/*              INDIRECT REGISTER - CURSOR CONTROL                              */
/********************************************************************************/
#define __TVP4020_CURSOR_CONTROL                0x06    // Indirect cursor control - 
//      Default - 0x00

#define TVP4020_CURSOR_SIZE_32                  (0 << 6)// 32x32 cursor
#define TVP4020_CURSOR_SIZE_64                  (1 << 6)// 32x32 cursor

#define TVP4020_CURSOR_32_SEL(i)                   ((i) << 4)// one of 4 32x32 cursors  DABO: changed to << 4

#define TVP4020_CURSOR_RAM_ADDRESS(x)            (((x) & 0x03) << 2)// High bits of cursor RAM address
#define TVP4020_CURSOR_RAM_MASK                 ((0x03) << 2)       // Mask for high bits of cursor RAM address

// DABO: Added constants for cursor mode
#define TVP4020_CURSOR_OFF                      0x00    // Cursor off
#define TVP4020_CURSOR_COLOR                    0x01    // 2-bits select color
#define TVP4020_CURSOR_XGA                      0x02    // 2-bits select XOR
#define TVP4020_CURSOR_XWIN                     0x03    // 2-bits select transparency/color



/********************************************************************************/
/*              INDIRECT REGISTER - COLOR MODE REGISTER                         */
/********************************************************************************/
#define __TVP4020_COLOR_MODE                    0x18    //  Color Mode Register
//      Default - 0x00

#define TVP4020_TRUE_COLOR_ENABLE               (1 << 7)// True Color data accesses LUT
#define TVP4020_TRUE_COLOR_DISABLE              (0 << 7)// Non true color accesses LUT

#define TVP4020_RGB_MODE                        (1 << 5)// RGB mode  DABO: Swapped 0/1 (0=BGR, 1=RGB)
#define TVP4020_BGR_MODE                        (0 << 5)// BGR mode

#define TVP4020_VGA_SELECT                      (0 << 4)// select VGA mode
#define TVP4020_GRAPHICS_SELECT                 (1 << 4)// select graphics modes

#define TVP4020_PIXEL_MODE_CI8                  (0 << 0)// pseudo color or VGA mode
#define TVP4020_PIXEL_MODE_332                  (1 << 0)// 332 true color
#define TVP4020_PIXEL_MODE_2320                 (2 << 0)// 232 off
#define TVP4020_PIXEL_MODE_2321                 (3 << 0)//
#define TVP4020_PIXEL_MODE_5551                 (4 << 0)// 
#define TVP4020_PIXEL_MODE_4444                 (5 << 0)// 
#define TVP4020_PIXEL_MODE_565                  (6 << 0)// 
#define TVP4020_PIXEL_MODE_8888                 (8 << 0)// 
#define TVP4020_PIXEL_MODE_PACKED               (9 << 0)// 24 bit packed

/********************************************************************************/
/*              INDIRECT REGISTER - MODE CONTROL REGISTER                       */
/********************************************************************************/
#define __TVP4020_MODE_CONTROL                  0x19    //  Mode control
//      Default - 0x00

#define TVP4020_PRIMARY_INPUT                   (0 << 4)// Primary input throuh palette
#define TVP4020_SECONDARY_INPUT                 (1 << 4)// Secondary input throuh palette

#define TVP4020_5551_DBL_BUFFER                 (1 << 2)// Enable 5551 dbl buffer
#define TVP4020_5551_PACKED                     (0 << 2)// Packed 555 mode

#define TVP4020_ENABLE_STATIC_DBL_BUFFER        (1 << 1)// Static dbl buffer enabled
#define TVP4020_DISABLE_STATIC_DBL_BUFFER       (1 << 1)// Static dbl buffer disabled

#define TVP4020_SELECT_FRONT_MODE               (0 << 0)// Front mode
#define TVP4020_SELECT_BACK_MODE                (1 << 0)// Back mode

/********************************************************************************/
/*              INDIRECT REGISTER - PALETTE PAGE                                */
/********************************************************************************/
#define __TVP4020_PALETTE_PAGE                  0x1C    //  
//      Default - 0x00

/********************************************************************************/
/*              INDIRECT REGISTER - MISC CONTROL                                */
/********************************************************************************/
#define __TVP4020_MISC_CONTROL                  0x1E    //  
//      Default - 0x00
#define TVP4020_SYNC_ENABLE                     (1 << 5)// Output SYNC info onto IOG
#define TVP4020_SYNC_DISABLE                    (0 << 5)// No SYNC IOG output

#define TVP4020_PEDESTAL_0                      (0 << 4)// 0 IRE blanking pedestal
#define TVP4020_PEDESTAL_75                     (1 << 4)// 7.5 IRE blanking pedestal

#define TVP4020_VSYNC_INVERT                    (1 << 3)// invert VSYNC output polarity
#define TVP4020_VSYNC_NORMAL                    (0 << 3)// normal VSYNC output polarity

#define TVP4020_HSYNC_INVERT                    (1 << 2)// invert HSYNC output polarity
#define TVP4020_HSYNC_NORMAL                    (0 << 3)// normal HSYNC output polarity

#define TVP4020_DAC_8BIT                        (1 << 1)// DAC is in 8-bit mode
#define TVP4020_DAC_6BIT                        (0 << 1)// DAC is in 6-bit mode

#define TVP4020_DAC_POWER_ON                    (0 << 0)// Turn DAC Power on 
#define TVP4020_DAC_POWER_OFF                   (1 << 0)// Turn DAC Power off 

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY CONTROL                           */
/********************************************************************************/
#define __TVP4020_CK_CONTROL                0x40    //  
//      Default - 0x00

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY OVERLAY                           */
/********************************************************************************/
#define __TVP4020_CK_OVR_REG                0x41    //  
//      Default - 0x00

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY RED                               */
/********************************************************************************/
#define __TVP4020_CK_RED_REG                0x42    //  
//      Default - 0x00

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY GREEN                             */
/********************************************************************************/
#define __TVP4020_CK_GREEN_REG              0x43    //  
//      Default - 0x00

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY BLUE                              */
/********************************************************************************/
#define __TVP4020_CK_BLUE_REG               0x44    //  
//      Default - 0x00

/********************************************************************************/
/*              INDIRECT REGISTER - PIXEL CLOCK PLL                            */
/********************************************************************************/

#define __TVP4020_PIXCLK_REG_A1             0x20
#define __TVP4020_PIXCLK_REG_A2             0x21
#define __TVP4020_PIXCLK_REG_A3             0x22
#define __TVP4020_PIXCLK_REG_B1             0x23
#define __TVP4020_PIXCLK_REG_B2             0x24
#define __TVP4020_PIXCLK_REG_B3             0x25
#define __TVP4020_PIXCLK_REG_C1             0x26
#define __TVP4020_PIXCLK_REG_C2             0x27
#define __TVP4020_PIXCLK_REG_C3             0x28

#define __TVP4020_PIXCLK_STATUS             0x29

/********************************************************************************/
/*              INDIRECT REGISTER - MEMORU CLOCK PLL                            */
/********************************************************************************/

#define __TVP4020_MEMCLK_REG_1              0x30
#define __TVP4020_MEMCLK_REG_2              0x31
#define __TVP4020_MEMCLK_REG_3              0x32

#define __TVP4020_MEMCLK_STATUS             0x33



#if 0
// need a delay between each write to the 4020. The only way to guarantee
// that the write has completed is to read from a GLINT control register.
// Reading forces any posted writes to be flushed out. PPC needs 2 reads
// to give us enough time.
#define TVP4020_DELAY \
{ \
    volatile LONG __junk; \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
}
#else
#define TVP4020_DELAY
#endif

// macro to load a given data value into an internal TVP4020 register.
//
#define TVP4020_WRITE_CURRENT_INDEX TVP4020_SET_INDEX_REG
#define TVP4020_SET_INDEX_REG(index) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_INDEX_ADDR, (ULONG)((index) & 0xff)); \
    TVP4020_DELAY; \
}

#define TVP4020_READ_CURRENT_INDEX(data) \
{ \
    data = VideoPortReadRegisterUlong(__TVP4020_INDEX_ADDR) & 0xff; \
    TVP4020_DELAY; \
}

#define TVP4020_WRITE_INDEX_REG(index, data) \
{ \
    TVP4020_SET_INDEX_REG(index);                            \
    ADbgpf(("*(0x%X) <-- 0x%X\n", __TVP4020_INDEX_DATA, (data) & 0xff)); \
    VideoPortWriteRegisterUlong(__TVP4020_INDEX_DATA, (ULONG)((data) & 0xff)); \
    TVP4020_DELAY; \
}

#define TVP4020_READ_INDEX_REG(index, data) \
{ \
    TVP4020_SET_INDEX_REG(index); \
    data = VideoPortReadRegisterUlong(__TVP4020_INDEX_DATA) & 0xff;   \
    TVP4020_DELAY; \
    ADbgpf(("0x%X <-- *(0x%X)\n", data, __TVP4020_INDEX_DATA)); \
}

// DABO: For compatibility with TVP3026
#define TVP4020_LOAD_CURSOR_CTRL(data) \
{ \
    volatile LONG   __temp;                                    \
    TVP4020_READ_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp);  \
    __temp &= ~(0x03) ;                                        \
    __temp |= ((data) & 0x03) ;                                \
    TVP4020_WRITE_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp); \
}

// macros to write a given RGB triplet into cursors 0, 1 and 2
#define TVP4020_SET_CURSOR_COLOR0(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_ADDR,   (ULONG)(TVP4020_CURSOR_COLOR0));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA,   (ULONG)(red));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA,   (ULONG)(green));  \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA,   (ULONG)(blue));   \
    TVP4020_DELAY; \
}

#define TVP4020_SET_CURSOR_COLOR1(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_ADDR,   (ULONG)(TVP4020_CURSOR_COLOR1));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA,   (ULONG)(red));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA,   (ULONG)(green));  \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA,   (ULONG)(blue));   \
    TVP4020_DELAY; \
}

#define TVP4020_SET_CURSOR_COLOR2(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_ADDR,   (ULONG)(TVP4020_CURSOR_COLOR2));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA,   (ULONG)(red));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA,   (ULONG)(green));  \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA,   (ULONG)(blue));   \
    TVP4020_DELAY; \
}



// macros to load a given RGB triple into the TVP4020 palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use TVP4020_PALETTE_START and multiple TVP4020_LOAD_PALETTE calls to load
// a contiguous set of entries. Use TVP4020_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//
#define TVP4020_PALETTE_START_WR(index) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_WR_ADDR,     (ULONG)(index));    \
    TVP4020_DELAY; \
}

#define TVP4020_PALETTE_START_RD(index) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_RD_ADDR,     (ULONG)(index));    \
    TVP4020_DELAY; \
}

#define TVP4020_LOAD_PALETTE(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(red));      \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(green));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(blue));     \
    TVP4020_DELAY; \
}

#define TVP4020_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_WR_ADDR, (ULONG)(index));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(red));      \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(green));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(blue));     \
    TVP4020_DELAY; \
}

// macro to read back a given RGB triple from the TVP4020 palette. Use after
// a call to TVP4020_PALETTE_START_RD
//
#define TVP4020_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR)(VideoPortReadRegisterUlong(__TVP4020_PAL_DATA) & 0xff);        \
    TVP4020_DELAY; \
    green = (UCHAR)(VideoPortReadRegisterUlong(__TVP4020_PAL_DATA) & 0xff);        \
    TVP4020_DELAY; \
    blue  = (UCHAR)(VideoPortReadRegisterUlong(__TVP4020_PAL_DATA) & 0xff);        \
    TVP4020_DELAY; \
}

// macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//
#define TVP4020_SET_PIXEL_READMASK(mask) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_PIXEL_MASK,  (ULONG)(mask)); \
    TVP4020_DELAY; \
}

#define TVP4020_READ_PIXEL_READMASK(mask) \
{ \
    mask = VideoPortReadRegisterUlong(__TVP4020_PIXEL_MASK) & 0xff; \
}

// macros to load values into the cursor array
//
#define TVP4020_CURSOR_ARRAY_START(offset) \
{ \
    volatile LONG   __temp;                                     \
    TVP4020_READ_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp);   \
    __temp &= ~TVP4020_CURSOR_RAM_MASK ;                        \
    __temp |= TVP4020_CURSOR_RAM_ADDRESS((offset)>> 8) ;        \
    TVP4020_WRITE_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp);  \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_RAM_WR_ADDR,   (ULONG)((offset)& 0xff));   \
    TVP4020_DELAY; \
}
// DABO: Need a similar macro to set the read address for cursor RAM?

#define TVP4020_LOAD_CURSOR_ARRAY(data) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_RAM_DATA, (ULONG)(data)); \
    TVP4020_DELAY; \
}

#define TVP4020_READ_CURSOR_ARRAY(data) \
{ \
    data = VideoPortReadRegisterUlong(__TVP4020_CUR_RAM_DATA) & 0xff; \
    TVP4020_DELAY; \
}

// macro to move the cursor
//
#define TVP4020_MOVE_CURSOR(x, y) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_X_LSB,     (ULONG)((x) & 0xff));   \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_X_MSB,     (ULONG)((x) >> 8));     \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_Y_LSB,      (ULONG)((y) & 0xff));   \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_Y_MSB,        (ULONG)((y) >> 8));     \
    TVP4020_DELAY; \
}

// macro to change the cursor hotspot
//
#define TVP4020_CURSOR_HOTSPOT(x, y) \
{ \
    TVP4020_DELAY; \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\mini\i2c.h ===
/***************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
* 
*   i2c.h
* 
* Abstract:
* 
*   This module contains the code that implements the i2c interface feature
* 
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2001 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

#define STATUS_SUCCESS                   0x00000000
#define STATUS_UNSUCCESSFUL              0xC0000001

#define MAX_CLOCK_RATE 1000000

#define INITGUID
typedef ULONG NTSTATUS;

#include <i2cgpio.h>

BOOLEAN
GetCookie(
    PVOID DeviceObject,
    PULONG Cookie
    );

VP_STATUS
I2CBusOpenCRT(
    PVOID DeviceObject,
    BOOLEAN bOpen,
    PI2CControl I2CControl
    );

VP_STATUS
I2CBusOpenDFP(
    PVOID DeviceObject,
    BOOLEAN bOpen,
    PI2CControl I2CControl
    );

VP_STATUS
I2CBusAccessCRT(
    PVOID DeviceObject,
    PI2CControl I2CControl
    );

VP_STATUS
I2CBusAccessDFP(
    PVOID DeviceObject,
    PI2CControl I2CControl
    );

VOID
InterfaceReference(
    IN PVOID pContext
    );

VOID
InterfaceDereference(
    IN PVOID pContext
    );

ULONG
I2CNull(
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

ULONG
I2CRead(
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

ULONG
I2CWrite(
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

ULONG
I2CStop(
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

ULONG
I2CStart(
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

VP_STATUS
I2CBusOpen(
    PVOID DeviceObject,
    BOOLEAN bOpen,
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks
    );

VP_STATUS
I2CBusAccess(
    PVOID DeviceObject,
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\mini\interupt.h ===
/***************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
*
*   interupt.h
*
* Abstract:
*
*   This module contains the definitions for the shared memory used by
*   the interrupt control routines.
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2001 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

//
// we manage a queue of DMA buffers that are to be loaded under interrupt control.
// Each entry has a physical address and a count to be loaded into Permedia 3. 
// The command can be used to indicate other things to do in the DMA interrupt.
//

typedef struct _glint_dma_queue {
    ULONG   command;
    ULONG   address;
    ULONG   count;
} DMABufferQueue;


typedef struct PXRXdmaInfo_Tag {

    volatile ULONG   scheme;          // Used by the interrupt handler only

    volatile ULONG   hostInId;        // Current internal HostIn id, 
                                      // used by the HIid DMA scheme

    volatile ULONG   fifoCount;       // Current internal FIFO count, 
                                      // used by various DMA schemes

    volatile ULONG   NTbuff;          // Current buffer number (0 or 1)

    volatile ULONG   *NTptr;          // 32/64 bit ptr    
                                      // Last address written to by NT
                                      // (but not necesserily the end of
                                      // a completed buffer)

    volatile ULONG   *NTdone;         // 32/64 bit ptr    
                                      // Last address NT has finished with 
                                      // (end of  a buffer, but not
                                      //  necessarily sent to P3 yet)

    volatile ULONG   *P3at;           // 32/64 bit ptr  
                                      // Last address sent to the P3

    volatile BOOLEAN bFlushRequired;  // Is a flush required to empty 
                                      // the FBwrite unit's cache?

    ULONG            *DMAaddrL[2];    // 32/64 bit ptr 
                                      // Linear address of the start
                                      //  of each DMA buffer

    ULONG            *DMAaddrEndL[2]; // 32/64 bit ptr
                                      // Linear address of the end of 
                                      // each DMA buffer

    ULONG            DMAaddrP[2];     // 32 bit ptr 
                                      // Physical address of the start of 
                                      // each DMA buffer

    ULONG            DMAaddrEndP[2];  // 32 bit ptr
                                      // Physical address of the end of 
                                      // each DMA buffer

} PXRXdmaInfo;

// interrupt status bits
typedef enum {
    DMA_INTERRUPT_AVAILABLE     = 0x01, // can use DMA interrupts
    VBLANK_INTERRUPT_AVAILABLE  = 0x02, // can use VBLANK interrupts
    SUSPEND_DMA_TILL_VBLANK     = 0x04, // Stop doing DMA till after next VBLANK
    DIRECTDRAW_VBLANK_ENABLED   = 0x08, // Set flag for DirectDraw on VBLANK
    PXRX_SEND_ON_VBLANK_ENABLED = 0x10, // Set flag for PXRX DMA on VBLANK
    PXRX_CHECK_VFIFO_IN_VBLANK  = 0x20, // Set flag for VFIFO underrun checking on VBLANK
} INTERRUPT_CONTROL;

// commands to the interrupt controller on the next VBLANK
typedef enum {
    NO_COMMAND = 0,
    COLOR_SPACE_BUFFER_0,
    COLOR_SPACE_BUFFER_1,
} VBLANK_CONTROL_COMMAND;

// Display driver structure for 'general use'.
typedef struct _pointer_interrupt_control
{
    volatile ULONG bDisplayDriverHasAccess;
    volatile ULONG bMiniportHasAccess;
    volatile ULONG bInterruptPending;
    volatile ULONG bHidden;
    volatile ULONG CursorMode;
    volatile ULONG x, y;
} PTR_INTR_CTL;

// Display driver structure for 'pointer use'.
typedef struct _general_interrupt_control
{
    volatile ULONG    bDisplayDriverHasAccess;
    volatile ULONG    bMiniportHasAccess;
} GEN_INTR_CTL;

#define MAX_DMA_QUEUE_ENTRIES   10

typedef struct _glint_interrupt_control {

    // contains various status bits. ** MUST BE THE FIRST FIELD **
    volatile INTERRUPT_CONTROL   Control;

    // profiling counters for Permedia3 busy time
    ULONG   PerfCounterShift;    
    ULONG   BusyTime;   // at DMA interrupt add (TimeNow-StartTime) to this
    ULONG   StartTime;  // set this when DMACount is loaded
    ULONG   IdleTime;
    ULONG   IdleStart;

    // commands to perform on the next VBLANK
    volatile VBLANK_CONTROL_COMMAND   VBCommand;

    // flag to indicate whether we expect another DMA interrupt
    volatile ULONG InterruptPending;
    
    volatile ULONG    DDRAW_VBLANK;                // flag for DirectDraw to indicate that a VBLANK occured.
    volatile ULONG    bOverlayEnabled;             // TRUE if the overlay is on at all
    volatile ULONG    bVBLANKUpdateOverlay;        // TRUE if the overlay needs to be updated by the VBLANK routine.
    volatile ULONG    VBLANKUpdateOverlayWidth;    // overlay width (updated in vblank)
    volatile ULONG    VBLANKUpdateOverlayHeight;   // overlay height (updated in vblank)

    // Volatile structures are required to enforce single-threading
    // We need 1 for general display use and 1 for pointer use, because
    // the pointer is synchronous.
    volatile PTR_INTR_CTL    Pointer;
    volatile GEN_INTR_CTL    General;

    // dummy DMA buffer to cause an interrupt but transfer no data
    ULONG   dummyDMAAddress;
    ULONG   dummyDMACount;

    // index offsets into the queue for the front, back and end. Using separate
    // front and back offsets allows the display driver to add and the interrupt
    // controller to remove entries without a need for locking code.
    volatile ULONG   frontIndex;
    ULONG   backIndex;
    ULONG   endIndex;
    ULONG   maximumIndex;

    // For P3RX 2D DMA:
    ULONG        lastAddr;
    PXRXdmaInfo    pxrxDMA;

    // array to contain the DMA queue
    DMABufferQueue  dmaQueue[MAX_DMA_QUEUE_ENTRIES];
} INTERRUPT_CONTROL_BLOCK, *PINTERRUPT_CONTROL_BLOCK;

#define REQUEST_INTR_CMD_BLOCK_MUTEX(pBlock, bHaveMutex) \
{ \
    pBlock->bMiniportHasAccess = TRUE; \
    if(!pBlock->bDisplayDriverHasAccess) \
    { \
        bHaveMutex = TRUE; \
    } \
    else \
    { \
        bHaveMutex = FALSE; \
        pBlock->bMiniportHasAccess = FALSE; \
    } \
}

#define RELEASE_INTR_CMD_BLOCK_MUTEX(pBlock) \
{ \
    pBlock->bMiniportHasAccess = FALSE; \
}

//
// structure containing information about the interrupt control block
//
typedef struct _interrupt_control_buffer_ {

    PHYSICAL_ADDRESS        PhysAddress;
    INTERRUPT_CONTROL_BLOCK ControlBlock;
    PVOID                   kdpc;
    BOOLEAN                 bInterruptsInitialized;
} PERM3_INTERRUPT_CTRLBUF, *PPERM3_INTERRUPT_CTRLBUF;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\mini\i2c.c ===
/***************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
* 
*   i2c.c
* 
* Abstract:
* 
*   This module contains the code that implements the i2c interface feature
* 
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2001 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

#include "perm3.h"
#include "i2c.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,GetCookie)
#pragma alloc_text(PAGE,I2CBusOpenCRT)
#pragma alloc_text(PAGE,I2CBusOpenDFP)
#pragma alloc_text(PAGE,I2CBusOpen)
#pragma alloc_text(PAGE,I2CBusAccessCRT)
#pragma alloc_text(PAGE,I2CBusAccessDFP)
#pragma alloc_text(PAGE,I2CBusAccess)
#pragma alloc_text(PAGE,I2CNull)
#pragma alloc_text(PAGE,I2CRead)
#pragma alloc_text(PAGE,I2CWrite)
#pragma alloc_text(PAGE,I2CStart)
#pragma alloc_text(PAGE,I2CStop)
#pragma alloc_text(PAGE,InterfaceReference)
#pragma alloc_text(PAGE,InterfaceDereference)
#pragma alloc_text(PAGE,Perm3QueryInterface)
#endif

VIDEO_I2C_CONTROL
I2CCallbacksCRT = {
    I2CWriteClock, 
    I2CWriteData, 
    I2CReadClock, 
    I2CReadData, 
    0
    };

VIDEO_I2C_CONTROL
I2CCallbacksDFP = {
    I2CWriteClockDFP,
    I2CWriteDataDFP,
    I2CReadClockDFP, 
    I2CReadDataDFP, 
    0
    };

BOOLEAN
GetCookie(
    PVOID DeviceObject,
    PULONG Cookie
    )
{
    *Cookie = 0x12345678;
    return TRUE;
}

VP_STATUS
I2CBusOpenCRT(
    PVOID DeviceObject,
    BOOLEAN bOpen,
    PI2CControl I2CControl
    )

{
    return I2CBusOpen(DeviceObject, bOpen, I2CControl, &I2CCallbacksCRT);
}

VP_STATUS
I2CBusOpenDFP(
    PVOID DeviceObject,
    BOOLEAN bOpen,
    PI2CControl I2CControl
    )

{
    return I2CBusOpen(DeviceObject, bOpen, I2CControl, &I2CCallbacksDFP);
}

VP_STATUS
I2CBusOpen(
    PVOID DeviceObject,
    BOOLEAN bOpen,
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks
    )

{
    PHW_DEVICE_EXTENSION hwDeviceExtension;
    VP_STATUS Status = STATUS_UNSUCCESSFUL;

    hwDeviceExtension = VideoPortGetAssociatedDeviceExtension(DeviceObject);

    VideoPortAcquireDeviceLock(hwDeviceExtension);

    I2CControl->Status = I2C_STATUS_NOERROR;

    if (bOpen) {

        if (I2CControl->ClockRate > MAX_CLOCK_RATE) {
            I2CControl->ClockRate = MAX_CLOCK_RATE;
        }

        I2CCallbacks->I2CDelay = (MAX_CLOCK_RATE / I2CControl->ClockRate) * 10;

        if (GetCookie(DeviceObject, &I2CControl->dwCookie)) {

            Status = STATUS_SUCCESS;
        }

    } else {

        I2CControl->dwCookie = 0;
        Status = STATUS_SUCCESS;
    }

    VideoPortReleaseDeviceLock(hwDeviceExtension);

    return Status;
}

VP_STATUS
I2CBusAccessCRT(
    PVOID DeviceObject,
    PI2CControl I2CControl
    )

{
    return I2CBusAccess(DeviceObject, I2CControl, &I2CCallbacksCRT);
}

VP_STATUS
I2CBusAccessDFP(
    PVOID DeviceObject,
    PI2CControl I2CControl
    )

{
    return I2CBusAccess(DeviceObject, I2CControl, &I2CCallbacksDFP);
}

VP_STATUS
I2CBusAccess(
    PVOID DeviceObject,
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks
    )

{
    PHW_DEVICE_EXTENSION hwDeviceExtension;
    VP_STATUS Status = STATUS_UNSUCCESSFUL;

    hwDeviceExtension = VideoPortGetAssociatedDeviceExtension(DeviceObject);

    VideoPortAcquireDeviceLock(hwDeviceExtension);

    I2CControl->Status = I2C_STATUS_NOERROR;

    if (I2CControl->ClockRate > MAX_CLOCK_RATE) {
        I2CControl->ClockRate = MAX_CLOCK_RATE;
    }

    I2CCallbacks->I2CDelay = (MAX_CLOCK_RATE / I2CControl->ClockRate) * 10;

    switch(I2CControl->Command) {

    case I2C_COMMAND_NULL:

        I2CNull(I2CControl, I2CCallbacks, hwDeviceExtension);
        break;

    case I2C_COMMAND_READ:

        I2CRead(I2CControl, I2CCallbacks, hwDeviceExtension);
        break;

    case I2C_COMMAND_WRITE:

        I2CWrite(I2CControl, I2CCallbacks, hwDeviceExtension);
        break;

    case I2C_COMMAND_RESET:

        //
        // A reset is just a stop.
        //

        I2CStop(I2CControl, I2CCallbacks, hwDeviceExtension);
        break;

    case I2C_COMMAND_STATUS:

        break;

    default:
        I2CControl->Status = I2C_STATUS_ERROR;
    }

    VideoPortReleaseDeviceLock(hwDeviceExtension);

    return I2CControl->Status;
}

ULONG
I2CNull(
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

{
    I2CControl->Status = I2C_STATUS_NOERROR;

    if (I2CControl->Flags & I2C_FLAGS_DATACHAINING) {
        hwDeviceExtension->I2CInterface.I2CStop(hwDeviceExtension, I2CCallbacks);
        hwDeviceExtension->I2CInterface.I2CStart(hwDeviceExtension, I2CCallbacks);
    }

    if (I2CControl->Flags & I2C_FLAGS_START) {
        hwDeviceExtension->I2CInterface.I2CStart(hwDeviceExtension, I2CCallbacks);
    }

    if (I2CControl->Flags & I2C_FLAGS_STOP) {
        hwDeviceExtension->I2CInterface.I2CStop(hwDeviceExtension, I2CCallbacks);
    }

    return I2CControl->Status;
}

ULONG
I2CRead(
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

{
    BOOLEAN Result;

    I2CControl->Status = I2C_STATUS_NOERROR;

    if (I2CControl->Flags & I2C_FLAGS_DATACHAINING) {
        hwDeviceExtension->I2CInterface.I2CStop(hwDeviceExtension, I2CCallbacks);
        hwDeviceExtension->I2CInterface.I2CStart(hwDeviceExtension, I2CCallbacks);
    }

    if (I2CControl->Flags & I2C_FLAGS_START) {
        hwDeviceExtension->I2CInterface.I2CStart(hwDeviceExtension, I2CCallbacks);
    }

    Result = hwDeviceExtension->I2CInterface.I2CRead(
                 hwDeviceExtension,
                 I2CCallbacks,
                 &I2CControl->Data,
                 1,
                 (I2CControl->Flags & I2C_FLAGS_ACK) ? FALSE : TRUE);

    if (Result == TRUE) {
        I2CControl->Status = I2C_STATUS_NOERROR;
    } else {
        I2CControl->Status = I2C_STATUS_ERROR;
    }

    if (I2CControl->Flags & I2C_FLAGS_STOP) {
        hwDeviceExtension->I2CInterface.I2CStop(hwDeviceExtension, I2CCallbacks);
    }

    return I2CControl->Status;
}

ULONG
I2CWrite(
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

{
    BOOLEAN Result;

    I2CControl->Status = I2C_STATUS_NOERROR;

    if (I2CControl->Flags & I2C_FLAGS_DATACHAINING) {
        hwDeviceExtension->I2CInterface.I2CStop(hwDeviceExtension, I2CCallbacks);
        hwDeviceExtension->I2CInterface.I2CStart(hwDeviceExtension, I2CCallbacks);
    }

    if (I2CControl->Flags & I2C_FLAGS_START) {
        hwDeviceExtension->I2CInterface.I2CStart(hwDeviceExtension, I2CCallbacks);
    }

    Result = hwDeviceExtension->I2CInterface.I2CWrite(
                 hwDeviceExtension,
                 I2CCallbacks,
                 &I2CControl->Data,
                 1);

    if (Result == TRUE) {
        I2CControl->Status = I2C_STATUS_NOERROR;
    } else {
        I2CControl->Status = I2C_STATUS_ERROR;
    }

    if (I2CControl->Flags & I2C_FLAGS_STOP) {
        hwDeviceExtension->I2CInterface.I2CStop(hwDeviceExtension, I2CCallbacks);
    }

    return I2CControl->Status;
}

ULONG
I2CStop(
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

{
    BOOLEAN Result;

    Result = hwDeviceExtension->I2CInterface.I2CStop(hwDeviceExtension, I2CCallbacks);

    if (Result == TRUE) {
        I2CControl->Status = I2C_STATUS_NOERROR;
    } else {
        I2CControl->Status = I2C_STATUS_ERROR;
    }

    return I2CControl->Status;
}

ULONG
I2CStart(
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

{
    BOOLEAN Result;

    Result = hwDeviceExtension->I2CInterface.I2CStart(hwDeviceExtension, I2CCallbacks);

    if (Result == TRUE) {
        I2CControl->Status = I2C_STATUS_NOERROR;
    } else {
        I2CControl->Status = I2C_STATUS_ERROR;
    }

    return I2CControl->Status;
}

VOID
InterfaceReference(
    IN PVOID pContext
    )

{
    return;
}

VOID
InterfaceDereference(
    IN PVOID pContext
    )

{
    return;
}


VP_STATUS
Perm3QueryInterface(
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE pQueryInterface
    )

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS Status;
    ULONG HwID;

    if (IsEqualGUID(pQueryInterface->InterfaceType, &GUID_I2C_INTERFACE)) {

        I2CINTERFACE *Interface = (I2CINTERFACE *)pQueryInterface->Interface;

        if ((pQueryInterface->Size == sizeof(I2CINTERFACE)) &&
            (pQueryInterface->Version == 2))
        {

            //
            // Get interface pointers for i2c interface help functions
            //

            if (hwDeviceExtension->I2CInterfaceAcquired == FALSE) {

                hwDeviceExtension->I2CInterface.Size = sizeof(VIDEO_PORT_I2C_INTERFACE_2);
                hwDeviceExtension->I2CInterface.Version = VIDEO_PORT_I2C_INTERFACE_VERSION_2;

                Status = VideoPortQueryServices(
                             hwDeviceExtension,
                             VideoPortServicesI2C,
                             (PINTERFACE)&hwDeviceExtension->I2CInterface);

                if (Status != NO_ERROR) {

                    VideoDebugPrint((1, "Perm3QueryInterface: Failed to acquire I2C services\n"));
                    return Status;
                }

                hwDeviceExtension->I2CInterfaceAcquired = TRUE;
            }

            if (((ULONG_PTR)pQueryInterface->InterfaceSpecificData != 0) &&
                ((ULONG_PTR)pQueryInterface->InterfaceSpecificData != -1)) {

                //
                // Get the HwID for the child requesting this interface
                //

                HwID = VideoPortGetAssociatedDeviceID(
                           pQueryInterface->InterfaceSpecificData);

            } else {

                if (hwDeviceExtension->Perm3Capabilities & PERM3_DFP_MON_ATTACHED) {
                    HwID = PERM3_DFP_MONITOR;
                } else {
                    HwID = PERM3_DDC_MONITOR;
                }
            }

            //
            // Initialize the interface
            //

            Interface->_vddInterface.Size = sizeof(I2CINTERFACE);
            Interface->_vddInterface.Version = 2;
            Interface->_vddInterface.Context = HwDeviceExtension;

            Interface->_vddInterface.InterfaceReference = InterfaceReference;
            Interface->_vddInterface.InterfaceDereference = InterfaceDereference;

            if (HwID == PERM3_DDC_MONITOR) {

                Interface->i2cOpen = I2CBusOpenCRT;
                Interface->i2cAccess = I2CBusAccessCRT;

            } else if (HwID == PERM3_DFP_MONITOR) {

                Interface->i2cOpen = I2CBusOpenDFP;
                Interface->i2cAccess = I2CBusAccessDFP;
            }

            //
            // Reference the interface before handing it out
            //

            Interface->_vddInterface.InterfaceReference(Interface->_vddInterface.Context);

            Status = NO_ERROR;

        } else {

            VideoDebugPrint((1, "Perm3QueryInterface: Size or version incorrect\n"));
            Status = ERROR_INVALID_PARAMETER;
        }

    } else {

        VideoDebugPrint((1, "Perm3QueryInteface: Unsupported Interface\n"));
        Status = ERROR_INVALID_PARAMETER;
    }

    VideoDebugPrint((1, "Perm3QueryInterface: Status = 0x%x\n", Status));
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\mini\interupt.c ===
/***************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
*
*   interupt.c
*
* Abstract:
*
*    This module contains code to control interrupts for Permedia 3. 
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2001 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

#include "perm3.h"

#pragma alloc_text(PAGE,Perm3InitializeInterruptBlock)

BOOLEAN
Perm3VideoInterrupt(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    Permedia3 interrupt service routine. 

    THIS ROUTINE CANNOT BE PAGED

Arguments:

    HwDeviceExtension
        Supplies a pointer to the miniport's device extension.

Return Value:

    Return FALSE if it is not our interrupt. Otherwise, we'll dismiss the 
    interrupt on Permedia 3 before returning TRUE.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PINTERRUPT_CONTROL_BLOCK pBlock;
    ULONG intrFlags;
    ULONG enableFlags;
    ULONG backIndex;
    ULONG bHaveCommandBlockMutex = FALSE;
    ULONG errFlags = 0;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    pBlock = &hwDeviceExtension->InterruptControl.ControlBlock;

    if(!hwDeviceExtension->InterruptControl.bInterruptsInitialized) {
   
        //
        // This is not our interrupt since we don't generate interrupt
        // before the interrpt block got initialized
        //

        return(FALSE);
    }

    if (hwDeviceExtension->PreviousPowerState != VideoPowerOn) {

        //
        // We reach here because we are sharing IRQ with other devices
        // and another device on the chain is in D0 and functioning
        //

        return(FALSE);
    }

    //
    // Find out what caused the interrupt. We AND with the enabled interrupts
    // since the flags are set if the event occurred even though no interrupt
    // was enabled.
    //

    intrFlags = VideoPortReadRegisterUlong(INT_FLAGS);
    enableFlags = VideoPortReadRegisterUlong(INT_ENABLE);

    intrFlags &= enableFlags;

    if (intrFlags == 0) {

        return FALSE;
    }

    //
    // Clear the interrupts we detected.
    //

    VideoPortWriteRegisterUlong(INT_FLAGS, intrFlags);
    VideoPortReadRegisterUlong(INT_FLAGS);

    if((pBlock->Control & PXRX_CHECK_VFIFO_IN_VBLANK) || 
        (intrFlags & INTR_ERROR_SET)) {

        errFlags = VideoPortReadRegisterUlong(ERROR_FLAGS);

        //
        // Keep a record of the errors. It will help us to debug
        // hardware issues
        //

        if (errFlags & ERROR_VFIFO_UNDERRUN) {
            hwDeviceExtension->UnderflowErrors++; 
        }

        if (errFlags & ERROR_OUT_FIFO) {
            hwDeviceExtension->OutputFifoErrors++;
        }

        if (errFlags & ERROR_IN_FIFO) {
            hwDeviceExtension->InputFifoErrors++; 
        }

        if (errFlags) {
            hwDeviceExtension->TotalErrors++;
        }

    }

    //
    // Handle VBLANK interrupt
    //

    if (intrFlags & INTR_VBLANK_SET) {
   
        //
        // Need this only on very first interrupt but it's not a big thing.
        //

        pBlock->Control |= VBLANK_INTERRUPT_AVAILABLE;

        //
        // Get General Mutex
        //

        REQUEST_INTR_CMD_BLOCK_MUTEX((&(pBlock->General)), bHaveCommandBlockMutex);

        if(bHaveCommandBlockMutex) {
       
            ULONG ulValue;

            //
            // DirectDraw needs to have it's VBLANK flag set, when it
            // sets the DIRECTDRAW_VBLANK_ENABLED bit.
            //

            if( pBlock->Control & (DIRECTDRAW_VBLANK_ENABLED | PXRX_SEND_ON_VBLANK_ENABLED | PXRX_CHECK_VFIFO_IN_VBLANK) ) {
           
                if( pBlock->Control & DIRECTDRAW_VBLANK_ENABLED ) {
	
                    pBlock->DDRAW_VBLANK = TRUE;
                }

                //
                // Don't need to do anything here. The actual processing is
                // lower down, outside of the VBlank mutex.
                //

            } else {

                //
                // Disable VBLANK interrupts. DD enables them when it needs to
                //

                VideoPortWriteRegisterUlong(INT_ENABLE, (enableFlags & ~INTR_ENABLE_VBLANK));
            }

            //
            // If DMA was suspended till VBLANK then simulate a DMA interrupt
            // to start it off again.
            //

            if (pBlock->Control & SUSPEND_DMA_TILL_VBLANK) {
           
                pBlock->Control &= ~SUSPEND_DMA_TILL_VBLANK;

                //
                // execute the DMA interrupt code
                //

                intrFlags |= INTR_ERROR_SET;  
            }

            RELEASE_INTR_CMD_BLOCK_MUTEX((&(pBlock->General)));
        }


        if( (pBlock->Control & PXRX_CHECK_VFIFO_IN_VBLANK) &&
            (--hwDeviceExtension->VideoFifoControlCountdown == 0) ) {
       
            //
            // It's time to check the error flags for an underrun (we don't
            // keep the error interrupt turned on for long because Perm3
            // generates a lot of spurious host-in DMA errors)
            //

            if(enableFlags & INTR_ERROR_SET) {
           
                //
                // Turn off the error interrupts now and rely on the periodic VBLANK check
                //

                enableFlags &= ~INTR_ERROR_SET;
                VideoPortWriteRegisterUlong(INT_ENABLE, enableFlags);
            }

            //
            // Set-up counter for our periodic check
            //

            hwDeviceExtension->VideoFifoControlCountdown = NUM_VBLANKS_BETWEEN_VFIFO_CHECKS;

            if(errFlags & ERROR_VFIFO_UNDERRUN) {
               
                if((enableFlags & INTR_ERROR_SET) == 0) {
                   
                    //
                    // We've got a video FIFO underrun error: turn on error
                    // interrupts for a little while in order to catch any
                    // other errors ASAP
                    //

                    hwDeviceExtension->VideoFifoControlCountdown = NUM_VBLANKS_AFTER_VFIFO_ERROR;

                    VideoPortWriteRegisterUlong(INT_ENABLE, 
                                                enableFlags | INTR_ERROR_SET);
                }
            }
        }
    }

    //
    // Handle underrun error
    //

    if(errFlags & ERROR_VFIFO_UNDERRUN) {
       
        ULONG highWater, lowWater;

        //
        // Clear the error
        //

        VideoPortWriteRegisterUlong(ERROR_FLAGS, ERROR_VFIFO_UNDERRUN);

        //
        // Lower the video FIFO thresholds. If the new upper threshold is 0
        // (indicating the thresholds are currently both 1) then we can't
        // go any lower, so just leave the underrun bit set (that way at
        // least we won't get any more error interrupts)
        //

        highWater = ((hwDeviceExtension->VideoFifoControl >> 8) & 0xff) - 1;

        if(highWater) {
           
            //
            // Load up the new FIFO control and clear the underrun bit.
            // The lower threshold is set to 8 if the upper threshold
            // is >= 15, otherwise it's set to 1/2 the  upper threshold
            //

            lowWater = highWater >= 15 ? 8 : ((highWater + 1) >> 1);

            hwDeviceExtension->VideoFifoControl = (1 << 16) | 
                                                  (highWater << 8) | 
                                                   lowWater; 

            do {
               
                VideoPortWriteRegisterUlong(VIDEO_FIFO_CTL, 
                                            hwDeviceExtension->VideoFifoControl);

            } while(VideoPortReadRegisterUlong(VIDEO_FIFO_CTL) & (1 << 16));

            VideoDebugPrint((3, "Perm3: Setting new Video Fifo thresholds to %d and %d\n", highWater, lowWater));
        } 
    }

    //
    // Handle outfifo error
    //

    if(errFlags & ERROR_OUT_FIFO) {

        //
        // If we got here by generating an OutputFIFO error, clear it
        //

        VideoPortWriteRegisterUlong(ERROR_FLAGS, ERROR_OUT_FIFO);

#ifdef MASK_OUTFIFO_ERROR_INTERRUPT
        enableFlags &= ~INTR_ERROR_SET;
        VideoPortWriteRegisterUlong(INT_ENABLE, enableFlags);
#endif

    }


    //
    // The error interrupt occurs each time the display driver adds an entry
    // to the queue. We treat it exactly as though we had received a DMA
    // interrupt.
    //
   
    if (intrFlags & (INTR_DMA_SET | INTR_ERROR_SET)) {

        //
        // if suspended till VBLANK we can't do any DMA.
        //

        if (pBlock->Control & SUSPEND_DMA_TILL_VBLANK) {
       
            VideoDebugPrint(( 1, "Perm3: DMA suspended till VBLANK\n"));
            return(TRUE);
        }

        //
        // If the previous DMA has not completed we can't do anything. We've
        // cleared the interrupt flag for this interrupt so even if the DMA
        // completes before we return, we'll immediately get another
        // interrupt. Since we will be getting another interrupt we do not
        // have to clear the InterruptPending flag.
        //

        if (VideoPortReadRegisterUlong(DMA_COUNT) != 0) {

            //
            // DMA in progress, leaving
            //

            return(TRUE);
        }

        //
        // We may return without starting any DMA and hence not expecting any
        // interrupt so clear the InterruptPending flag. This will force the
        // display driver to wake us. MUST DO THIS BEFORE CHECKING THE QUEUE.
        // Since the display driver adds entries and then checks the flag, we
        // must do it in the reverse order.
        //

        pBlock->InterruptPending = 0;

        //
        // if the DMA queue is empty then we have nothing to do
        //

        backIndex = pBlock->backIndex;

        if (pBlock->frontIndex == backIndex) {
       
            //
            // Queue is empty, leaving.
            //

            return(TRUE);
        }

        //
        // Since we know we'll get a DMA interrupt, we don't need a wakeup so
        // set the InterruptPending flag to true.
        //

        pBlock->InterruptPending = 1;

        //
        // kick off DMA for the next Q entry and remove it. DO NOT remove from
        // the queue first because on a multi-processor machine the display
        // driver could modify the now free queue entry before we read it.
        //
       
        VideoPortWriteRegisterUlong(DMA_ADDRESS, pBlock->dmaQueue[backIndex].address);
        VideoPortWriteRegisterUlong(DMA_COUNT,   pBlock->dmaQueue[backIndex].count);

        //
        // Keep track of where the last DMA to start was from:
        //

        pBlock->lastAddr = pBlock->dmaQueue[backIndex].address;

        //
        // now remove the entry from the queue
        //

        if (++backIndex == pBlock->endIndex)
            backIndex = 0;

        pBlock->backIndex = backIndex;
    }

    return TRUE;
}

BOOLEAN
Perm3InitializeInterruptBlock(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

/*++

Routine Description:

    Do any initialization needed for interrupts, such as allocating the shared
    memory control block.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value: 

    TRUE 

--*/

{
    PVOID HwDeviceExtension = (PVOID)hwDeviceExtension;
    PINTERRUPT_CONTROL_BLOCK pBlock;
    PVOID SavedPtr;
    PVOID pkdpc;

    //
    //  This is set to zero since it is on longer used
    //

    hwDeviceExtension->InterruptControl.PhysAddress.LowPart = 
    hwDeviceExtension->InterruptControl.PhysAddress.HighPart = 0;
   
    //
    // Set up the control block
    //
    
    pBlock = &hwDeviceExtension->InterruptControl.ControlBlock;    

    //
    // Initialize the circular DMA queue
    //

    pBlock->frontIndex = pBlock->backIndex  = 0;
    pBlock->maximumIndex = MAX_DMA_QUEUE_ENTRIES - 1;

    //
    // The size of the queue we actually use is dynamically configurable but
    // initialize it to be as small as possible. This default size will work
    // for all interrupt driven DMA buffers regardless of how many buffers
    // are actually available.
    //

    pBlock->endIndex = 2;

    //
    // Initially no interrupts are available. Later we try to enable the
    // interrupts and if they happen the interrupt handler will set the
    // available bits in this word. So it's a sort of auto-sensing mechanism.
    //

    pBlock->Control = 0;
    pBlock->InterruptPending = 0;

    //
    // Initialize the VBLANK interrupt command field
    //

    pBlock->VBCommand = NO_COMMAND;

    //
    // Initialize the General update in VBLANK fields (only used by P2)
    //

    pBlock->General.bDisplayDriverHasAccess = FALSE;
    pBlock->General.bMiniportHasAccess = FALSE;

    VideoPortZeroMemory( &pBlock->pxrxDMA, sizeof(pBlock->pxrxDMA) );

    hwDeviceExtension->InterruptControl.bInterruptsInitialized = TRUE;

    hwDeviceExtension->OutputFifoErrors = 0;
    hwDeviceExtension->InputFifoErrors = 0; 
    hwDeviceExtension->UnderflowErrors = 0; 
    hwDeviceExtension->TotalErrors = 0;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\mini\perm3.h ===
/***************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
*
*   perm3.h
*
* Abstract:
*
*   This module contains the definitions for the Permedia3 miniport driver.
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2001 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

//
// This line will cause the DEFINE_GUID lines in i2cgpio.h actually do something
//

#define INITGUID

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"
#include "interupt.h"

#define GAMMA_CORRECTION 1
#define MASK_OUTFIFO_ERROR_INTERRUPT 1
//
// Define an assert macro for debugging
//

#if DBG
#define PERM3_ASSERT(x, y) if (!(x)) { VideoDebugPrint((0, (y))); ASSERT(FALSE); }
#else
#define PERM3_ASSERT(x, y)
#endif

//
// Include definitions for all supported RAMDACS
//

#include "p3rd.h"

//
// We use 'Int 10' to do mode switching on the x86. 
//

#if defined(i386)
    #define INT10_MODE_SET  1
#endif

//
// Default clock speed in Hz for the reference board. The actual speed
// is looked up in the registry. Use this if no registry entry is found
// or the registry entry is zero.
//

#define PERMEDIA3_DEFAULT_CLOCK_SPEED       ( 80 * (1000*1000))
#define PERMEDIA3_DEFAULT_CLOCK_SPEED_ALT   ( 80 * (1000*1000))
#define PERMEDIA3_MAX_CLOCK_SPEED           (250 * (1000*1000))
#define PERMEDIA3_DEFAULT_MCLK_SPEED        ( 80 * (1000*1000))
#define PERMEDIA3_DEFAULT_SCLK_SPEED        ( 70 * (1000*1000))

//
// Maximum pixelclock values that the RAMDAC can handle (in 100's hz).
//

#define P3_MAX_PIXELCLOCK 2700000      // RAMDAC rated at 270 Mhz
#define P4_REVB_MAX_PIXELCLOCK 3000000 // RAMDAC rated at 300 Mhz

//
// Maximum amount of video data per second, that the rasterizer
// chip can send to the RAMDAC (limited by SDRAM/SGRAM throuput).
//

#define P3_MAX_PIXELDATA  15000000   // 1500 million bytes/sec (in 100's bytes)

//
// Base address numbers for the Perm3 PCI regions in which we're interested.
// These are indexes into the AccessRanges array we get from probing the
// device. 
//

#define PCI_CTRL_BASE_INDEX       0
#define PCI_LB_BASE_INDEX         1
#define PCI_FB_BASE_INDEX         2

#define ROM_MAPPED_LENGTH       0x10000

#define VENDOR_ID_3DLABS        0x3D3D
#define PERMEDIA3_ID            0x000A
#define PERMEDIA4_ID            0x000C

//
// Capabilities flags
//
// These are private flags passed to the Permedia 3 display driver. They're
// put in the high word of the 'AttributeFlags' field of the
// 'VIDEO_MODE_INFORMATION' structure (found in 'ntddvdeo.h') passed
// to the display driver via an 'VIDEO_QUERY_AVAIL_MODES' or
// 'VIDEO_QUERY_CURRENT_MODE' IOCTL.
//
// NOTE: These definitions must match those in the Permedia 3 display driver's
//       'driver.h'!

typedef enum {
    CAPS_ZOOM_X_BY2      = 0x00000001,   // Hardware has zoomed by 2 in X
    CAPS_ZOOM_Y_BY2      = 0x00000002,   // Hardware has zoomed by 2 in Y
    CAPS_QUEUED_DMA      = 0x00000008,   // DMA address/count via the FIFO
    CAPS_LOGICAL_DMA     = 0x00000010,   // DMA through logical address table
    CAPS_USE_AGP_DMA     = 0x00000020,   // AGP DMA can be used.
    CAPS_P3RD_POINTER    = 0x00000040,   // Use the 3Dlabs P3RD RAMDAC
    CAPS_STEREO          = 0x00000080,   // Stereo mode enabled.
    CAPS_SW_POINTER      = 0x00010000,   // No hardware pointer; use software simulation
    CAPS_GLYPH_EXPAND    = 0x00020000,   // Use glyph-expand method to draw text.
    CAPS_FAST_FILL_BUG   = 0x00080000,   // chip fast fill bug exists
    CAPS_INTERRUPTS      = 0x00100000,   // interrupts supported
    CAPS_DMA_AVAILABLE   = 0x00200000,   // DMA is supported
    CAPS_DISABLE_OVERLAY = 0x00400000,   // chip do not support overlay
} CAPS;

//
// The capabilities of a Perm3 board. 
//

typedef enum {
    PERM3_NOCAPS             = 0x00000000, // No additional capabilities
    PERM3_SGRAM              = 0x00000001, // SGRAM board (else SDRAM)
    PERM3_DFP                = 0x00000002, // Digital flat panel
    PERM3_DFP_MON_ATTACHED   = 0x00000010, // DFP Monitor is attached
    PERM3_USE_BYTE_DOUBLING  = 0x00000040  // Current mode requires byte-doubling
} PERM3_CAPS;

//
// Supported board definitions.
//

typedef enum _PERM3_BOARDS {
    PERMEDIA3_BOARD = 17,
} PERM3_BOARDS;

//
// Chip type definitions
//

typedef enum _PERM3_CHIPSETS {
    PERMEDIA3 = 5,
} PERM3_CHIPSET;

//
// Supported RAMDAC definitions.
//

typedef enum _PERM3_RAMDACS {
    P3RD_RAMDAC = 14,
} PERM3_RAMDACS;

//
// macros to add padding words to the structures. For the core registers we use
// the tag ids when specifying the pad. So we must multiply by 8 to get a byte
// pad. We need to add an id to make each pad field in the struct unique. The
// id is irrelevant as long as it's different from every other id used in the
// same struct. 
//

#define PAD(id, n)              UCHAR   pad##id[n]
#define PADRANGE(id, n)         PAD(id, (n)-sizeof(PERM3_REG))
#define PADCORERANGE(id, n)     PADRANGE(id, (n)<<3)

//
// Perm3 registers are 32 bits wide and live on 64-bit boundaries.
//

typedef struct {
    ULONG   reg;
    ULONG   pad;
} PERM3_REG;

//
// Permedia 3 PCI Region 0 Address MAP:
//
// All registers are on 64-bit boundaries so we have to define a number of
// padding words. The number given in the comments are offsets from the start
// of the PCI region.
//

typedef struct _perm3_region0_map {

    // Control Status Registers:
    PERM3_REG       ResetStatus;                // 0000h
    PERM3_REG       IntEnable;                  // 0008h
    PERM3_REG       IntFlags;                   // 0010h
    PERM3_REG       InFIFOSpace;                // 0018h
    PERM3_REG       OutFIFOWords;               // 0020h
    PERM3_REG       DMAAddress;                 // 0028h
    PERM3_REG       DMACount;                   // 0030h
    PERM3_REG       ErrorFlags;                 // 0038h
    PERM3_REG       VClkCtl;                    // 0040h
    PERM3_REG       TestRegister;               // 0048h
    union a0 {
        // GLINT
        struct b0 {
            PERM3_REG       Aperture0;          // 0050h
            PERM3_REG       Aperture1;          // 0058h
        };
        // PERMEDIA
        struct b1 {
            PERM3_REG       ApertureOne;        // 0050h
            PERM3_REG       ApertureTwo;        // 0058h
        };
    };
    PERM3_REG       DMAControl;                 // 0060h
    PERM3_REG       DisconnectControl;          // 0068h

    // PERMEDIA only
    PERM3_REG       ChipConfig;                 // 0070h
    PERM3_REG       AGPControl;                 // 0078h - Px/Rx
    PERM3_REG       OutDMAAddress;              // 0080h
    PERM3_REG       OutDMACount;                // 0088h
    PERM3_REG       AGPTexBaseAddress;          // 0090h

    PADRANGE(201, 0xA0-0x90);
    PERM3_REG       ByDMAAddress;               // 00A0h
    PADRANGE(202, 0xB8-0xA0);

    PERM3_REG       ByDMAStride;                // 00B8h
    PERM3_REG       ByDMAMemAddr;               // 00C0h
    PERM3_REG       ByDMASize;                  // 00C8h
    PERM3_REG       ByDMAByteMask;              // 00D0h
    PERM3_REG       ByDMAControl;               // 00D8h
    PADRANGE(203, 0xE8-0xD8);

    PERM3_REG       ByDMAComplete;              // 00E8h
    PADRANGE(204, 0x100-0xE8);

    // Paged texture management registers.
    PERM3_REG        HostTextureAddress;        // 0100h
    PERM3_REG        TextureDownloadControl;    // 0108h
    PERM3_REG        TextureOperation;          // 0110h
    PERM3_REG        LogicalTexturePage;        // 0118h
    PERM3_REG        TextureDMAAddress;         // 0120h
    PERM3_REG        TextureFIFOSpace;          // 0128h
    PADRANGE(205, 0x300-0x128);

    PERM3_REG        ByAperture1Mode;           // 0300h
    PERM3_REG        ByAperture1Stride;         // 0308h
    PADRANGE(206, 0x328-0x308);

    PERM3_REG        ByAperture2Mode;           // 0328h
    PERM3_REG        ByAperture2Stride;         // 0330h
    PADRANGE(207, 0x350-0x330);

    PERM3_REG        ByDMAReadMode;             // 0350h - Px/Rx only
    PERM3_REG        ByDMAReadStride;           // 0358h - Px/Rx only
    PADRANGE(208, 0x800-0x358);

    //
    // GLINTdelta registers. Registers with the same functionality as on GLINT
    // are at the same offset. XXX are not real registers.
    //

    PERM3_REG       DeltaReset;                 // 0800h
    PERM3_REG       DeltaIntEnable;             // 0808h
    PERM3_REG       DeltaIntFlags;              // 0810h
    PERM3_REG       DeltaInFIFOSpaceXXX;        // 0818h
    PERM3_REG       DeltaOutFIFOWordsXXX;       // 0820h
    PERM3_REG       DeltaDMAAddressXXX;         // 0828h
    PERM3_REG       DeltaDMACountXXX;           // 0830h
    PERM3_REG       DeltaErrorFlags;            // 0838h
    PERM3_REG       DeltaVClkCtlXXX;            // 0840h
    PERM3_REG       DeltaTestRegister;          // 0848h
    PERM3_REG       DeltaAperture0XXX;          // 0850h
    PERM3_REG       DeltaAperture1XXX;          // 0858h
    PERM3_REG       DeltaDMAControlXXX;         // 0860h
    PERM3_REG       DeltaDisconnectControl;     // 0868h

    //
    // GLINTgamma registers
    //

    PERM3_REG        GammaChipConfig;            // 0870h
    PERM3_REG        GammaCSRAperture;           // 0878h
    PADRANGE(3, 0x0c00-0x878);
    PERM3_REG        GammaPageTableAddr;         // 0c00h
    PERM3_REG        GammaPageTableLength;       // 0c08h
    PADRANGE(301, 0x0c38-0x0c08);
    PERM3_REG        GammaDelayTimer;            // 0c38h
    PERM3_REG        GammaCommandMode;           // 0c40h
    PERM3_REG        GammaCommandIntEnable;      // 0c48h
    PERM3_REG        GammaCommandIntFlags;       // 0c50h
    PERM3_REG        GammaCommandErrorFlags;     // 0c58h
    PERM3_REG        GammaCommandStatus;         // 0c60h
    PERM3_REG        GammaCommandFaultingAddr;   // 0c68h
    PERM3_REG        GammaVertexFaultingAddr;    // 0c70h
    PADRANGE(302, 0x0c88-0x0c70);
    PERM3_REG        GammaWriteFaultingAddr;     // 0c88h
    PADRANGE(303, 0x0c98-0x0c88);
    PERM3_REG        GammaFeedbackSelectCount;   // 0c98h
    PADRANGE(304, 0x0cb8-0x0c98);
    PERM3_REG        GammaProcessorMode;         // 0cb8h
    PADRANGE(305, 0x0d00-0x0cb8);
    PERM3_REG        GammaVGAShadow;             // 0d00h
    PERM3_REG        GammaMultiGLINTAperture;    // 0d08h    
    PERM3_REG        GammaMultiGLINT1;           // 0d10h
    PERM3_REG        GammaMultiGLINT2;           // 0d18h
    PADRANGE(306, 0x0f00-0x0d18);
    PERM3_REG        GammaSerialAccess;          // 0f00h
    PADRANGE(307, 0x1000-0x0f00);

    // Localbuffer Registers
    union x0 {                                   // 1000h
        PERM3_REG   LBMemoryCtl;                 // GLINT
        PERM3_REG   Reboot;                      // PERMEDIA
    };
    PERM3_REG       LBMemoryEDO;                 // 1008h
    PADRANGE(308, 0x1018-0x1008);

    // PERMEDIA3 only
    PERM3_REG       LocalMemCaps;                // 1018h
    PERM3_REG       LocalMemTiming;              // 1020h
    PERM3_REG       LocalMemControl;             // 1028h
    PERM3_REG       LocalMemRefresh;             // 1030h
    PERM3_REG       LocalMemPowerDown;           // 1038h

    // PERMEDIA & PERMEDIA2 only
    PERM3_REG       MemControl;                  // 1040h

    // PERMEDIA3 only
    PADRANGE(4, 0x1068-0x1040);
    PERM3_REG       LocalMemProfileMask0;        // 1068h
    PERM3_REG       LocalMemProfileCount0;       // 1070h
    PERM3_REG       LocalMemProfileMask1;        // 1078h

    // PERMEDIA & PERMEDIA2 only
    PERM3_REG       BootAddress;                 // 1080h   [= LocalMemProfileCount1 on PxRx]
    PADRANGE(5, 0x10C0-0x1080);
    PERM3_REG       MemConfig;                   // 10C0h
    PADRANGE(6, 0x1100-0x10C0);
    PERM3_REG       BypassWriteMask;             // 1100h
    PADRANGE(7, 0x1140-0x1100);
    PERM3_REG       FramebufferWriteMask;        // 1140h
    PADRANGE(8, 0x1180-0x1140);
    PERM3_REG       Count;                       // 1180h
    PADRANGE(9, 0x1800-0x1180);

    // Framebuffer Registers
    PERM3_REG       FBMemoryCtl;                 // 1800h
    PERM3_REG       FBModeSel;                   // 1808h
    PERM3_REG       FBGCWrMask;                  // 1810h
    PERM3_REG       FBGCColorMask;               // 1818h
    PERM3_REG       FBTXMemCtl;                  // 1820h
    PADRANGE(10, 0x2000-0x1820);
               
    // Graphics Core FIFO Interface
    PERM3_REG       FIFOInterface;               // 2000h
    PADRANGE(11, 0x3000-0x2000);

    // Internal Video Registers
    union x1 {
        // GLINT
        struct s1 {
            PERM3_REG   VTGHLimit;               // 3000h
            PERM3_REG   VTGHSyncStart;           // 3008h
            PERM3_REG   VTGHSyncEnd;             // 3010h
            PERM3_REG   VTGHBlankEnd;            // 3018h
            PERM3_REG   VTGVLimit;               // 3020h
            PERM3_REG   VTGVSyncStart;           // 3028h
            PERM3_REG   VTGVSyncEnd;             // 3030h
            PERM3_REG   VTGVBlankEnd;            // 3038h
            PERM3_REG   VTGHGateStart;           // 3040h
            PERM3_REG   VTGHGateEnd;             // 3048h
            PERM3_REG   VTGVGateStart;           // 3050h
            PERM3_REG   VTGVGateEnd;             // 3058h
            PERM3_REG   VTGPolarity;             // 3060h
            PERM3_REG   VTGFrameRowAddr;         // 3068h
            PERM3_REG   VTGVLineNumber;          // 3070h
            PERM3_REG   VTGSerialClk;            // 3078h
            PERM3_REG   VTGModeCtl;              // 3080h
        };
        // PERMEDIA
        struct s2 {
            PERM3_REG   ScreenBase;              // 3000h
            PERM3_REG   ScreenStride;            // 3008h
            PERM3_REG   HTotal;                  // 3010h
            PERM3_REG   HgEnd;                   // 3018h
            PERM3_REG   HbEnd;                   // 3020h
            PERM3_REG   HsStart;                 // 3028h
            PERM3_REG   HsEnd;                   // 3030h
            PERM3_REG   VTotal;                  // 3038h
            PERM3_REG   VbEnd;                   // 3040h
            PERM3_REG   VsStart;                 // 3048h
            PERM3_REG   VsEnd;                   // 3050h
            PERM3_REG   VideoControl;            // 3058h
            PERM3_REG   InterruptLine;           // 3060h
            PERM3_REG   DDCData;                 // 3068h
            PERM3_REG   LineCount;               // 3070h
            PERM3_REG   VFifoCtl;                // 3078h
            PERM3_REG   ScreenBaseRight;         // 3080h
        };
    };

    PERM3_REG   MiscControl;                     // 3088h

    PADRANGE(111, 0x3100-0x3088);

    PERM3_REG  VideoOverlayUpdate;               // 0x3100
    PERM3_REG  VideoOverlayMode;                 // 0x3108
    PERM3_REG  VideoOverlayFifoControl;          // 0x3110
    PERM3_REG  VideoOverlayIndex;                // 0x3118
    PERM3_REG  VideoOverlayBase0;                // 0x3120
    PERM3_REG  VideoOverlayBase1;                // 0x3128
    PERM3_REG  VideoOverlayBase2;                // 0x3130
    PERM3_REG  VideoOverlayStride;               // 0x3138
    PERM3_REG  VideoOverlayWidth;                // 0x3140
    PERM3_REG  VideoOverlayHeight;               // 0x3148
    PERM3_REG  VideoOverlayOrigin;               // 0x3150
    PERM3_REG  VideoOverlayShrinkXDelta;         // 0x3158
    PERM3_REG  VideoOverlayZoomXDelta;           // 0x3160
    PERM3_REG  VideoOverlayYDelta;               // 0x3168
    PERM3_REG  VideoOverlayFieldOffset;          // 0x3170
    PERM3_REG  VideoOverlayStatus;               // 0x3178

    //
    // External Video Control Registers
    // Need to cast this to a struct for a particular video generator
    //

    PADRANGE(12, 0x4000-0x3178);
    PERM3_REG       ExternalVideo;               // 4000h
    PADRANGE(13, 0x4080-0x4000);

    //
    // Mentor Dual-TX clock chip registers
    //

    PERM3_REG       MentorICDControl;            // 4080h

    //
    // for future: MentorDoubleWrite is at 40C0: 0 = single write, 1 = double
    //             NB must have 2-way interleaved memory

    PADRANGE(14, 0x4800-0x4080);

    PERM3_REG       GloriaControl;               // 4800h

    PADRANGE(15, 0x5000-0x4800);
    PERM3_REG       DemonProDWAndStatus;         // 5000h - Pro
    PADRANGE(151, 0x5800-0x5000);

    //
    // P2 video streams registers
    //

    PERM3_REG        VSConfiguration;            // 5800h
    PERM3_REG        VSStatus;                   // 5808h
    PERM3_REG        VSSerialBusControl;         // 5810h
    PADRANGE(16, 0x5A00-0x5810);
    PERM3_REG        VSBControl;                 // 5A00h
    PADRANGE(161, 0x6000-0x5A00);

    union x2 {
        struct s3 {
            PERM3_REG   RacerDoubleWrite;        // 6000h
            PERM3_REG   RacerBankSelect;         // 6008h
            PERM3_REG   DualTxVgaSwitch;         // 6010h
            PERM3_REG   DDC1ReadAddress;         // 6018h
        };
        struct s4 {

            //
            // the following array is actually 1024 bytes long
            //

            UCHAR       PermediaVgaCtrl[4*sizeof(PERM3_REG)];
        };
    };
    PADRANGE(17, 0x7000-0x6018);
    union {
        PERM3_REG       DemonProUBufB;           // 7000h - Pro
        PERM3_REG        TextureDataFifo;
    };
    PADRANGE(171, 0x8000-0x7000);

} Perm3ControlRegMap, *pPerm3ControlRegMap;

//
// Permedia 3 Interrupt Control Bits
//

// InterruptEnable register
#define INTR_DISABLE_ALL        0
#define INTR_ENABLE_DMA         (1 << 0)
#define INTR_ENABLE_SYNC        (1 << 1)
#define INTR_ENABLE_EXTERNAL    (1 << 2)
#define INTR_ENABLE_ERROR       (1 << 3)
#define INTR_ENABLE_VBLANK      (1 << 4)
#define INTR_ENABLE_GCOMMAND    (1 << 13)

// InterruptFlags register
#define INTR_DMA_SET            (1 << 0)
#define INTR_SYNC_SET           (1 << 1)
#define INTR_EXTERNAL_SET       (1 << 2)
#define INTR_ERROR_SET          (1 << 3)
#define INTR_VBLANK_SET         (1 << 4)
#define INTR_TEXTURE_FAULT_SET  (1 << 6)
#define INTR_GCOMMAND_SET       (1 << 13)

#define INTR_CLEAR_ALL          (0x1f | (1 << 13))
#define INTR_CLEAR_DMA          (1 << 0)
#define INTR_CLEAR_SYNC         (1 << 1)
#define INTR_CLEAR_EXTERNAL     (1 << 2)
#define INTR_CLEAR_ERROR        (1 << 3)
#define INTR_CLEAR_VBLANK       (1 << 4)

// Error Flags
#define ERROR_IN_FIFO           (1 << 0)
#define ERROR_OUT_FIFO          (1 << 1)
#define ERROR_MESSAGE           (1 << 2)
#define DMA_ERROR               (1 << 3)
#define ERROR_VFIFO_UNDERRUN    (1 << 4)

//
// Macros which takes a Perm3 tag name or control register name and translates
// it to a register address. Data must be written to these addresses using
// VideoPortWriteRegisterUlong and read using VideoPortReadRegisterUlong.
// e.g. dma_count = VideoPortReadRegisterUlong(DMA_COUNT);
//

#define CTRL_REG_ADDR(reg)       ((PULONG)&(pCtrlRegs->reg))
#define CTRL_REG_OFFSET(regAddr) ((ULONG)(((ULONG_PTR)regAddr) - ((ULONG_PTR)pCtrlRegs)))

//
// Defines for the different control registers needed by Permedia 3. 
// These macros can be used as the address part.  
//

#define RESET_STATUS            CTRL_REG_ADDR(ResetStatus) 
#define INT_ENABLE              CTRL_REG_ADDR(IntEnable) 
#define INT_FLAGS               CTRL_REG_ADDR(IntFlags) 
#define IN_FIFO_SPACE           CTRL_REG_ADDR(InFIFOSpace) 
#define OUT_FIFO_WORDS          CTRL_REG_ADDR(OutFIFOWords) 
#define DMA_ADDRESS             CTRL_REG_ADDR(DMAAddress) 
#define DMA_COUNT               CTRL_REG_ADDR(DMACount) 
#define DMA_OUT_ADDRESS         CTRL_REG_ADDR(OutDMAAddress)
#define DMA_OUT_COUNT           CTRL_REG_ADDR(OutDMACount)
#define ERROR_FLAGS             CTRL_REG_ADDR(ErrorFlags) 
#define V_CLK_CTL               CTRL_REG_ADDR(VClkCtl) 
#define TEST_REGISTER           CTRL_REG_ADDR(TestRegister) 
#define APERTURE_0              CTRL_REG_ADDR(Aperture0) 
#define APERTURE_1              CTRL_REG_ADDR(Aperture1) 
#define DMA_CONTROL             CTRL_REG_ADDR(DMAControl) 
#define LB_MEMORY_CTL           CTRL_REG_ADDR(LBMemoryCtl) 
#define LB_MEMORY_EDO           CTRL_REG_ADDR(LBMemoryEDO) 
#define FB_MEMORY_CTL           CTRL_REG_ADDR(FBMemoryCtl) 
#define FB_MODE_SEL             CTRL_REG_ADDR(FBModeSel) 
#define FB_GC_WRITEMASK         CTRL_REG_ADDR(FBGCWrMask) 
#define FB_GC_COLORMASK         CTRL_REG_ADDR(FBGCColorMask) 
#define FB_TX_MEM_CTL           CTRL_REG_ADDR(FBTXMemCtl) 
#define FIFO_INTERFACE          CTRL_REG_ADDR(FIFOInterface) 
#define DISCONNECT_CONTROL      CTRL_REG_ADDR(DisconnectControl)
#define BY_DMACOMPLETE          CTRL_REG_ADDR(ByDMAComplete) 
#define AGP_TEX_BASE_ADDRESS    CTRL_REG_ADDR(AGPTexBaseAddress)

// Bypass mode registers

#define BY_APERTURE1_MODE       CTRL_REG_ADDR(ByAperture1Mode)
#define BY_APERTURE1_STRIDE     CTRL_REG_ADDR(ByAperture1Stride)
#define BY_APERTURE2_MODE       CTRL_REG_ADDR(ByAperture2Mode)
#define BY_APERTURE2_STRIDE     CTRL_REG_ADDR(ByAperture2Stride)
#define BY_DMA_READ_MODE        CTRL_REG_ADDR(ByDMAReadMode)
#define BY_DMA_READ_STRIDE      CTRL_REG_ADDR(ByDMAReadStride)

// Delta control registers

#define DELTA_RESET_STATUS      CTRL_REG_ADDR(DeltaReset) 
#define DELTA_INT_ENABLE        CTRL_REG_ADDR(DeltaIntEnable) 
#define DELTA_INT_FLAGS         CTRL_REG_ADDR(DeltaIntFlags) 

// Permedia 3 Registers

#define APERTURE_ONE            CTRL_REG_ADDR(ApertureOne) 
#define APERTURE_TWO            CTRL_REG_ADDR(ApertureTwo)
#define BYPASS_WRITE_MASK       CTRL_REG_ADDR(BypassWriteMask)
#define FRAMEBUFFER_WRITE_MASK  CTRL_REG_ADDR(FramebufferWriteMask)
#define MEM_CONTROL             CTRL_REG_ADDR(MemControl)
#define BOOT_ADDRESS            CTRL_REG_ADDR(BootAddress)
#define MEM_CONFIG              CTRL_REG_ADDR(MemConfig) 
#define CHIP_CONFIG             CTRL_REG_ADDR(ChipConfig) 
#define AGP_CONTROL             CTRL_REG_ADDR(AGPControl) 
#define SGRAM_REBOOT            CTRL_REG_ADDR(Reboot) 
#define SCREEN_BASE             CTRL_REG_ADDR(ScreenBase) 
#define SCREEN_BASE_RIGHT       CTRL_REG_ADDR(ScreenBaseRight)
#define SCREEN_STRIDE           CTRL_REG_ADDR(ScreenStride) 
#define H_TOTAL                 CTRL_REG_ADDR(HTotal) 
#define HG_END                  CTRL_REG_ADDR(HgEnd) 
#define HB_END                  CTRL_REG_ADDR(HbEnd) 
#define HS_START                CTRL_REG_ADDR(HsStart) 
#define HS_END                  CTRL_REG_ADDR(HsEnd) 
#define V_TOTAL                 CTRL_REG_ADDR(VTotal) 
#define VB_END                  CTRL_REG_ADDR(VbEnd) 
#define VS_START                CTRL_REG_ADDR(VsStart) 
#define VS_END                  CTRL_REG_ADDR(VsEnd) 
#define VIDEO_CONTROL           CTRL_REG_ADDR(VideoControl) 
#define INTERRUPT_LINE          CTRL_REG_ADDR(InterruptLine) 
#define DDC_DATA                CTRL_REG_ADDR(DDCData) 
#define LINE_COUNT              CTRL_REG_ADDR(LineCount)
#define VIDEO_FIFO_CTL          CTRL_REG_ADDR(VFifoCtl)
#define MISC_CONTROL            CTRL_REG_ADDR(MiscControl) 


// Permedia 3 Video Streams registers

#define VSTREAM_CONFIG          CTRL_REG_ADDR(VSConfiguration)
#define VSTREAM_SERIAL_CONTROL  CTRL_REG_ADDR(VSSerialBusControl) 
#define VSTREAM_B_CONTROL       CTRL_REG_ADDR(VSBControl) 

#define VSTREAM_CONFIG_UNITMODE_MASK        (0x7 << 0)
#define VSTREAM_CONFIG_UNITMODE_FP          (0x6 << 0)
#define VSTREAM_CONFIG_UNITMODE_CRT         (0x0 << 0)
#define VSTREAM_SERIAL_CONTROL_DATAIN       (0x1 << 0)
#define VSTREAM_SERIAL_CONTROL_CLKIN        (0x1 << 1)
#define VSTREAM_SERIAL_CONTROL_DATAOUT      (0x1 << 2)
#define VSTREAM_SERIAL_CONTROL_CLKOUT       (0x1 << 3)
#define VSTREAM_B_CONTROL_RAMDAC_ENABLE     (0x1 << 14)
#define VSTREAM_B_CONTROL_RAMDAC_DISABLE    (0x0 << 14)

//
// Memory mapped VGA access
//

#define PERMEDIA_MMVGA_INDEX_REG    ((PVOID)(&(pCtrlRegs->PermediaVgaCtrl[0x3C4])))
#define PERMEDIA_MMVGA_DATA_REG     (&(pCtrlRegs->PermediaVgaCtrl[0x3C5]))
#define PERMEDIA_MMVGA_STAT_REG     (&(pCtrlRegs->PermediaVgaCtrl[0x3DA]))

#define PERMEDIA_VGA_CTRL_INDEX     5
#define PERMEDIA_VGA_ENABLE         (1 << 3)
#define PERMEDIA_VGA_STAT_VSYNC     (1 << 3)
#define PERMEDIA_VGA_LOCK_INDEX1    6
#define PERMEDIA_VGA_LOCK_INDEX2    7
#define PERMEDIA_VGA_LOCK_DATA1     0x0
#define PERMEDIA_VGA_LOCK_DATA2     0x0
#define PERMEDIA_VGA_UNLOCK_DATA1   0x3D
#define PERMEDIA_VGA_UNLOCK_DATA2   0xDB

//
// Lock VGA registers, only applicable to P3 and later, note that we only
// need to write to 1 of the LOCK registers not both
//

#define LOCK_VGA_REGISTERS() {                                                                \
        VideoPortWriteRegisterUchar( PERMEDIA_MMVGA_INDEX_REG, PERMEDIA_VGA_LOCK_INDEX1 );    \
        VideoPortWriteRegisterUchar( PERMEDIA_MMVGA_DATA_REG,  PERMEDIA_VGA_LOCK_DATA1 );    \
}

//
// Unlock VGA registers, only applicable to P3 and later. We have to write
// special magic code to unlock the registers. Note that this should be done
// using 2 short writes rather than 4 byte ones, but I've left it in for
// readability.
//

#define UNLOCK_VGA_REGISTERS() {                                                            \
        VideoPortWriteRegisterUchar( PERMEDIA_MMVGA_INDEX_REG, PERMEDIA_VGA_LOCK_INDEX1 );    \
        VideoPortWriteRegisterUchar( PERMEDIA_MMVGA_DATA_REG,  PERMEDIA_VGA_UNLOCK_DATA1 );    \
        VideoPortWriteRegisterUchar( PERMEDIA_MMVGA_INDEX_REG, PERMEDIA_VGA_LOCK_INDEX2 );    \
        VideoPortWriteRegisterUchar( PERMEDIA_MMVGA_DATA_REG,  PERMEDIA_VGA_UNLOCK_DATA2 );    \
}

#define VC_FORCED_HIGH     0
#define VC_ACTIVE_HIGH     1
#define VC_FORCED_LOW      2
#define VC_ACTIVE_LOW      3
#define VC_HSYNC(x)        (x << 3)
#define VC_VSYNC(x)        (x << 5)
#define VC_ON              1
#define VC_OFF             0
#define VC_DPMS_MASK       (VC_HSYNC(3) | VC_VSYNC(3) | VC_ON)

#define VC_DPMS_STANDBY    (VC_HSYNC(VC_FORCED_LOW)  | VC_VSYNC(VC_ACTIVE_HIGH) | VC_OFF)
#define VC_DPMS_SUSPEND    (VC_HSYNC(VC_ACTIVE_HIGH) | VC_VSYNC(VC_FORCED_LOW)  | VC_OFF)
#define VC_DPMS_OFF        (VC_HSYNC(VC_FORCED_LOW)  | VC_VSYNC(VC_FORCED_LOW)  | VC_OFF)

//
// DisconnectControl bits
//

#define DISCONNECT_INPUT_FIFO_ENABLE    0x1
#define DISCONNECT_OUTPUT_FIFO_ENABLE   0x2
#define DISCONNECT_INOUT_ENABLE         (DISCONNECT_INPUT_FIFO_ENABLE | \
                                         DISCONNECT_OUTPUT_FIFO_ENABLE)

// PXRX memory timing registers
#define PXRX_LOCAL_MEM_CAPS          CTRL_REG_ADDR(LocalMemCaps)
#define PXRX_LOCAL_MEM_CONTROL       CTRL_REG_ADDR(LocalMemControl)
#define PXRX_LOCAL_MEM_POWER_DOWN    CTRL_REG_ADDR(LocalMemPowerDown)
#define PXRX_LOCAL_MEM_REFRESH       CTRL_REG_ADDR(LocalMemRefresh)
#define PXRX_LOCAL_MEM_TIMING        CTRL_REG_ADDR(LocalMemTiming)

// Values for the MISC_CONTROL
#define PXRX_MISC_CONTROL_STRIPE_MODE_DISABLE    (0 << 0)    // Stripe mode
#define PXRX_MISC_CONTROL_STRIPE_MODE_PRIMARY    (1 << 0)
#define PXRX_MISC_CONTROL_STRIPE_MODE_SECONDARY  (2 << 0)

#define PXRX_MISC_CONTROL_STRIPE_SIZE_1          (0 << 4)    // Stripe size
#define PXRX_MISC_CONTROL_STRIPE_SIZE_2          (1 << 4)
#define PXRX_MISC_CONTROL_STRIPE_SIZE_4          (2 << 4)
#define PXRX_MISC_CONTROL_STRIPE_SIZE_8          (3 << 4)
#define PXRX_MISC_CONTROL_STRIPE_SIZE_16         (4 << 4)

#define PXRX_MISC_CONTROL_BYTE_DBL_DISABLE       (0 << 7)    // Byte doubling
#define PXRX_MISC_CONTROL_BYTE_DBL_ENABLE        (1 << 7)

//
// Characteristics of each mode
//

typedef struct _PERM3_VIDEO_MODES {

    // Leave INT10 fields in for later chips which have VGA
    USHORT Int10ModeNumberContiguous;
    USHORT Int10ModeNumberNoncontiguous;
    ULONG ScreenStrideContiguous;
    VIDEO_MODE_INFORMATION ModeInformation;

} PERM3_VIDEO_MODES, *PPERM3_VIDEO_MODES;

//
// Mode-set specific information.
//

typedef struct _PERM3_VIDEO_FREQUENCIES {
    ULONG BitsPerPel;
    ULONG ScreenWidth;
    ULONG ScreenHeight;
    ULONG ScreenFrequency;
    PPERM3_VIDEO_MODES ModeEntry;
    ULONG ModeIndex;
    UCHAR ModeValid;
    ULONG PixelClock;
} PERM3_VIDEO_FREQUENCIES, *PPERM3_VIDEO_FREQUENCIES;

//
// Monitor & screen mode information:
// structure of timing data contained in the registry
//

typedef struct {
    USHORT   HTot;   // Hor Total Time
    UCHAR    HFP;    // Hor Front Porch
    UCHAR    HST;    // Hor Sync Time
    UCHAR    HBP;    // Hor Back Porch
    UCHAR    HSP;    // Hor Sync Polarity
    USHORT   VTot;   // Ver Total Time   
    UCHAR    VFP;    // Ver Front Porch  
    UCHAR    VST;    // Ver Sync Time    
    UCHAR    VBP;    // Ver Back Porch   
    UCHAR    VSP;    // Ver Sync Polarity
    ULONG    pClk;   // Pixel clock
} VESA_TIMING_STANDARD;

typedef struct {
    ULONG    width;
    ULONG    height;
    ULONG    refresh;
} MODE_INFO;

typedef struct {
    MODE_INFO               basic;
    VESA_TIMING_STANDARD    vesa;
} TIMING_INFO;

#define MI_FLAGS_READ_DDC          (1 << 3)
#define MI_FLAGS_DOES_DDC          (1 << 4)
#define MI_FLAGS_FUDGED_VH         (1 << 5)
#define MI_FLAGS_FUDGED_PCLK       (1 << 6)
#define MI_FLAGS_FUDGED_XY         (1 << 7)
#define MI_FLAGS_LIMIT_XY          (1 << 8)

typedef struct {
    ULONG flags;
    char  id[8];
    char  name[16];         // name[14] but need to ensure dword packing
    ULONG fhMin, fhMax;
    ULONG fvMin, fvMax;
    ULONG pClkMin, pClkMax;
    ULONG timingNum;
    ULONG xMin, xMax, yMin, yMax;
    ULONG timingMax;
    TIMING_INFO *timingList;
    PERM3_VIDEO_FREQUENCIES  *frequencyTable;
    ULONG numAvailableModes;
    ULONG numTotalModes;
} MONITOR_INFO;

typedef struct {
    ULONG fH, fV;
    ULONG pClk;
} FREQUENCIES;

//
// Framebuffer Aperture Information: currently only of interest to GeoTwin
// boards to allow for upload DMA directly from FB0 to FB1 and vice versa
//

typedef struct FrameBuffer_Aperture_Info
{
    PHYSICAL_ADDRESS pphysBaseAddr;
    ULONG            cjLength;
}
FBAPI;

//
// PCI device information. Used in an IOCTL return. Ensure this is the same
// as in the display driver 
// Never rearrange the existing order, just append to the end (see
// IOCTL_VIDEO_QUERY_DEVICE_INFO in display driver)
//

typedef struct _Perm3_Device_Info {
    ULONG SubsystemId;
    ULONG SubsystemVendorId;
    ULONG VendorId;
    ULONG DeviceId;
    ULONG RevisionId;
    ULONG DeltaRevId;
    ULONG GammaRevId;
    ULONG BoardId;
    ULONG LocalbufferLength;
    ULONG LocalbufferWidth;
    ULONG ActualDacId;
    FBAPI FBAperture[2];         // Physical addresses for geo twin framebuffers
    PVOID FBApertureVirtual[2];  // Virtual addresses for geo twin framebuffers
    PVOID FBApertureMapped [2];  // Mapped physical/logical addresses for geo twin framebuffers
    PUCHAR pCNB20;
    PHYSICAL_ADDRESS pphysFrameBuffer; // physical address of the framebuffer (use FBAperture instead for geo twins)
} Perm3_Device_Info;

// Definition of the IOCTL_VIDEO_QUERY_GENERAL_DMA_BUFFER

typedef struct _GENERAL_DMA_BUFFER {
    PHYSICAL_ADDRESS    physAddr;        // physical address of DMA buffer
    PVOID               virtAddr;        // mapped virtual address
    ULONG               size;            // size in bytes
    BOOLEAN             cacheEnabled;    // Whether buffer is cached
} GENERAL_DMA_BUFFER, *PGENERAL_DMA_BUFFER;

// 
// The following are the definition for the LUT cache. The aim of the LUT cache
// is to stop sparkling from occurring, bu only writing those LUT entries that
// have changed to the chip, we can only do this by remembering what is already
// down there. The 'mystify' screen saver on P2 demonstrates the problem.
//

#define LUT_CACHE_INIT()        {VideoPortZeroMemory (&(hwDeviceExtension->LUTCache), sizeof (hwDeviceExtension->LUTCache));}
#define LUT_CACHE_SETSIZE(sz)    {hwDeviceExtension->LUTCache.LUTCache.NumEntries = (sz);}
#define LUT_CACHE_SETFIRST(frst){hwDeviceExtension->LUTCache.LUTCache.FirstEntry = (frst);}

#define LUT_CACHE_SETRGB(idx,zr,zg,zb) {    \
    hwDeviceExtension->LUTCache.LUTCache.LookupTable [idx].RgbArray.Red   = (UCHAR) (zr); \
    hwDeviceExtension->LUTCache.LUTCache.LookupTable [idx].RgbArray.Green = (UCHAR) (zg); \
    hwDeviceExtension->LUTCache.LUTCache.LookupTable [idx].RgbArray.Blue  = (UCHAR) (zb); \
}


typedef struct {
    VIDEO_CLUT LUTCache;             // Header  plus 1 LUT entry
    VIDEO_CLUTDATA LUTData [255];    // the other 255 LUT entries
} LUT_CACHE;

//
// Possible regions:
//   Gamma ctl 
//   Perm3 ctl
//   LB
//   FB
//

#define MAX_RESERVED_REGIONS 4

#define MAX_REGISTER_INITIALIZATION_TABLE_ENTRIES 10
#define MAX_REGISTER_INITIALIZATION_TABLE_ULONGS (2 * MAX_REGISTER_INITIALIZATION_TABLE_ENTRIES)

//
// Define device extension structure. This is device dependent/private
// information.
//

typedef struct _HW_DEVICE_EXTENSION {
    pPerm3ControlRegMap ctrlRegBase[1];
    PVOID pFramebuffer;
    PVOID pRamdac;
    PHYSICAL_ADDRESS PhysicalFrameAddress;
    ULONG FrameLength;
    PHYSICAL_ADDRESS PhysicalRegisterAddress;
    ULONG RegisterLength;
    UCHAR RegisterSpace;
    ULONG SavedControlAddress;
    PPERM3_VIDEO_MODES ActiveModeEntry;
    PERM3_VIDEO_FREQUENCIES ActiveFrequencyEntry;
    PCI_SLOT_NUMBER pciSlot;
    ULONG DacId;
    ULONG ChipClockSpeed;
    ULONG ChipClockSpeedAlt;
    ULONG GlintGammaClockSpeed;
    ULONG PXRXLastClockSpeed;
    ULONG RefClockSpeed;
    ULONG Capabilities;
    ULONG AdapterMemorySize;
    ULONG PhysicalFrameIoSpace;
    BOOLEAN bIsAGP;

    Perm3_Device_Info deviceInfo;

    ULONG BiosVersionMajorNumber;
    ULONG BiosVersionMinorNumber;

    //
    // Shared memory for comms with the display driver
    //

    PERM3_INTERRUPT_CTRLBUF InterruptControl;

    //
    // Shared memory for comms with the display driver
    //

    PERM3_INTERRUPT_CTRLBUF InterruptTextureControl;

    //
    // DMA Buffer definitions
    //

    GENERAL_DMA_BUFFER LineDMABuffer;
    GENERAL_DMA_BUFFER P3RXDMABuffer;

    //
    // PCI Config Information
    //

    ULONG bVGAEnabled;
    VIDEO_ACCESS_RANGE PciAccessRange[MAX_RESERVED_REGIONS+1];

    //
    // Initialization table
    //

    ULONG aulInitializationTable[MAX_REGISTER_INITIALIZATION_TABLE_ULONGS];
    ULONG culTableEntries;

    //
    // Extended BIOS initialisation variables
    //

    BOOLEAN bHaveExtendedClocks;
    ULONG ulPXRXCoreClock;
    ULONG ulPXRXMemoryClock;
    ULONG ulPXRXMemoryClockSrc;
    ULONG ulPXRXSetupClock;
    ULONG ulPXRXSetupClockSrc;
    ULONG ulPXRXGammaClock;
    ULONG ulPXRXCoreClockAlt;

    //
    // LUT cache
    //

    LUT_CACHE LUTCache;

    ULONG IntEnable;
    ULONG VideoFifoControlCountdown;

    BOOLEAN bVTGRunning;
    PPERM3_VIDEO_FREQUENCIES pFrequencyDefault;

    //
    // State save variables (for power management)
    //

    ULONG VideoControlMonitorON;
    ULONG VideoControl;
    ULONG PreviousPowerState;
    BOOLEAN bMonitorPoweredOn;
    ULONG VideoFifoControl;

    //
    // Monitor configuration stuff:
    //

    MONITOR_INFO monitorInfo;

    //
    // Perm3 Capabilities
    //

    PERM3_CAPS Perm3Capabilities;

    //
    // Error detected in interrupt routine
    //

    ULONG OutputFifoErrors;
    ULONG InputFifoErrors; 
    ULONG UnderflowErrors; 
    ULONG TotalErrors;

    //
    // I2C Support
    //

    BOOLEAN I2CInterfaceAcquired;
    VIDEO_PORT_I2C_INTERFACE_2 I2CInterface;

    ULONG (*WinXpVideoPortGetAssociatedDeviceID)(PVOID);
    VP_STATUS (*WinXpSp1VideoPortRegisterBugcheckCallback)(PVOID,ULONG,PVIDEO_BUGCHECK_CALLBACK,ULONG);

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

#define VideoPortGetAssociatedDeviceID \
        hwDeviceExtension->WinXpVideoPortGetAssociatedDeviceID

// PCI configuration region device specific defines
#define AGP_CAP_ID            2       // PCIsig AGP Cap ID
#define AGP_CAP_PTR_OFFSET    0x34    // offset to start of capabilities list

//
// Highest valid DAC color register index.
//

#define VIDEO_MAX_COLOR_REGISTER  0xFF
#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * (VIDEO_MAX_COLOR_REGISTER+1)))

//
// Data
//

extern PERM3_VIDEO_MODES Perm3Modes[];
extern const ULONG NumPerm3VideoModes;

extern VIDEO_ACCESS_RANGE Perm3LegacyResourceList[];
extern ULONG Perm3LegacyResourceEntries;

//
// PXRX Registry Strings
//

#define PERM3_REG_STRING_CORECLKSPEED      L"PXRX.CoreClockSpeed"
#define PERM3_REG_STRING_CORECLKSPEEDALT   L"PXRX.CoreClockSpeedAlt"
#define PERM3_REG_STRING_REFCLKSPEED       L"PXRX.RefClockSpeed"

//
// IOCTL and structure definitions for mapping DMA buffers
//

#define IOCTL_VIDEO_QUERY_NUM_DMA_BUFFERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD0, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_DMA_BUFFERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD1, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_DEVICE_INFO \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD2, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD3, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_REGISTRY_DWORD \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD5, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_REG_SAVE_GAMMA_LUT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD7, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD8, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_GENERAL_DMA_BUFFER \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD9, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_COLOR_REGISTERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DDB, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Extract timings from VESA structure in a form that can be programmed into
// the Perm3 timing generator.
//

#define  GetHtotFromVESA(VESATmgs) ((VESATmgs)->HTot)
#define  GetHssFromVESA(VESATmgs)  ((VESATmgs)->HFP)
#define  GetHseFromVESA(VESATmgs)  ((VESATmgs)->HFP + (VESATmgs)->HST)
#define  GetHbeFromVESA(VESATmgs)  ((VESATmgs)->HFP + (VESATmgs)->HST + (VESATmgs)->HBP)
#define  GetHspFromVESA(VESATmgs)  ((VESATmgs)->HSP)
#define  GetVtotFromVESA(VESATmgs) ((VESATmgs)->VTot)
#define  GetVssFromVESA(VESATmgs)  ((VESATmgs)->VFP)
#define  GetVseFromVESA(VESATmgs)  ((VESATmgs)->VFP + (VESATmgs)->VST)
#define  GetVbeFromVESA(VESATmgs)  ((VESATmgs)->VFP + (VESATmgs)->VST + (VESATmgs)->VBP)
#define  GetVspFromVESA(VESATmgs)  ((VESATmgs)->VSP)

//
// Permedia 3 programs the video fifo thresholds using an iterative method
// to get the optimal values. Originally I tried this using the error
// interrupt to capture video fifo underruns, unfortunately the Perm3
// generates a number of spurious (I think) host-in DMA errors too
// which makes it too expansive to keep error interrupts on all the time.
// Instead we do a periodic check using the vblank interrupt (this can be
// kept on all the time as it's not too frequent)
//

#define NUM_VBLANKS_BETWEEN_VFIFO_CHECKS 10
#define NUM_VBLANKS_AFTER_VFIFO_ERROR 2

#define SUBVENDORID_3DLABS        0x3D3D // Sub-system Vendor ID
#define SUBDEVICEID_P3_VX1_PCI    0x0121 // Sub-system Device ID: P3+16MB SDRAM
#define SUBDEVICEID_P3_VX1_AGP    0x0125 // Sub-system Device ID: P3+32MB SDRAM (VX1)
#define SUBDEVICEID_P3_VX1_1600SW 0x0800 // Sub-system Device ID: P3+32MB SDRAM (VX1-1600SW)
#define SUBDEVICEID_P3_32D_AGP    0x0127 // Sub-system Device ID: P3+32MB SDRAM (Permedia3 Create!)
#define SUBDEVICEID_P4_VX1_AGP    0x0144 // Sub-system Device ID: P4+32MB SDRAM (VX1)

//
// All our child IDs begin 0x1357bd so they are readily identifiable as our own
//

#define PERM3_DDC_MONITOR    (0x1357bd00)
#define PERM3_NONDDC_MONITOR (0x1357bd01)
#define PERM3_DFP_MONITOR    (0x1357bd02)

//
// Function prototypes
//

//
// Functions in perm3.c
//

VP_STATUS
Perm3FindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
Perm3Initialize(
    PVOID HwDeviceExtension
    );

VP_STATUS
Perm3QueryInterface(
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE pQueryInterface
    );

VOID
ConstructValidModesList(
    PVOID HwDeviceExtension,
    MONITOR_INFO *mi
    );

VOID
InitializePostRegisters(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

BOOLEAN
Perm3ResetHW(
    PVOID HwDeviceExtension,
    ULONG Columns,
    ULONG Rows
    );

VP_STATUS
Perm3SetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize,
    BOOLEAN ForceRAMDACWrite,
    BOOLEAN UpdateCache
    );

VP_STATUS
Perm3RegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VOID 
BuildInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

VOID 
CopyROMInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    PVOID pvROMAddress
    );

VOID 
GenerateInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

VOID 
ProcessInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

ULONG 
UlongToString(
    ULONG i, 
    PWSTR pwsz
    );

ULONG 
ProbeRAMSize(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    PULONG FBAddr, 
    ULONG FBMappedSize
    );

BOOLEAN Perm3AssignResources(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

BOOLEAN 
Perm3ConfigurePci(
    PVOID HwDeviceExtension
    );

ULONG 
GetBoardCapabilities(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    ULONG SubsystemID, 
    ULONG SubdeviceID
    );

VOID 
SetHardwareInfoRegistries(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

BOOLEAN 
MapResource(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

//
// Functions in perm3io.c
//

BOOLEAN
Perm3StartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

VOID
Perm3GetClockSpeeds(
    PVOID HwDeviceExtension
    );

VOID
ZeroMemAndDac(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG RequestedMode
    );

VP_STATUS 
SetCurrentVideoMode(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    ULONG modeNumber, 
    BOOLEAN bZeroMemory
    );

VP_STATUS
Perm3RetrieveGammaCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VOID 
ReadChipClockSpeedFromROM (
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    ULONG * pChipClkSpeed
    );


//
// Functions in video.c
//

BOOLEAN
InitializeVideo(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PPERM3_VIDEO_FREQUENCIES VideoMode
    );

VOID 
SwitchToHiResMode(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    BOOLEAN bHiRes
    );

BOOLEAN 
Program_P3RD(
    PHW_DEVICE_EXTENSION, 
    PPERM3_VIDEO_FREQUENCIES,  
    ULONG, 
    ULONG, 
    ULONG, 
    PULONG, 
    PULONG, 
    PULONG
    );

ULONG 
P3RD_CalculateMNPForClock(
    PVOID HwDeviceExtension,
    ULONG RefClock,
    ULONG ReqClock,
    ULONG *rM,
    ULONG *rN,
    ULONG *rP
    );

ULONG 
P4RD_CalculateMNPForClock(
    PVOID HwDeviceExtension,
    ULONG RefClock,
    ULONG ReqClock,
    ULONG *rM,
    ULONG *rN,
    ULONG *rP
    );

//
// Functions in power.c
//

VP_STATUS
Perm3GetPowerState(
    PVOID HwDeviceExtension,
    ULONG HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

VP_STATUS
Perm3SetPowerState(
    PVOID HwDeviceExtension,
    ULONG HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

ULONG 
Perm3GetChildDescriptor(PVOID HwDeviceExtension, 
    PVIDEO_CHILD_ENUM_INFO pChildInfo, 
    PVIDEO_CHILD_TYPE pChildType,
    PUCHAR pChildDescriptor, 
    PULONG pUId, 
    PULONG Unused);

VOID 
ProgramDFP(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

BOOLEAN
GetDFPEdid(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PUCHAR EdidBuffer,
    LONG  EdidSize
    );

VOID 
I2CWriteClock(
    PVOID HwDeviceExtension, 
    UCHAR data
    );

VOID 
I2CWriteData(
    PVOID HwDeviceExtension, 
    UCHAR data
    );

BOOLEAN 
I2CReadClock(
    PVOID HwDeviceExtension
    );

BOOLEAN 
I2CReadData(
    PVOID HwDeviceExtension
    );

VOID 
I2CWriteClockDFP(
    PVOID HwDeviceExtension, 
    UCHAR data
    );

VOID 
I2CWriteDataDFP(
    PVOID HwDeviceExtension, 
    UCHAR data
    );

BOOLEAN 
I2CReadClockDFP(
    PVOID HwDeviceExtension
    );

BOOLEAN 
I2CReadDataDFP(
    PVOID HwDeviceExtension
    );

//
// Functions in interupt.c
//

BOOLEAN
Perm3InitializeInterruptBlock(
    PVOID   HwDeviceExtension
    );

BOOLEAN
Perm3VideoInterrupt(
    PVOID HwDeviceExtension
    );

//
// Functions in perm3dat.c
//

BOOLEAN GetVideoTiming (
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG xRes, 
    ULONG yRes, 
    ULONG Freq, 
    ULONG Depth,
    VESA_TIMING_STANDARD *VESATimings
    );

BOOLEAN
BuildFrequencyList( 
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    MONITOR_INFO* 
    );

BOOLEAN
BuildFrequencyListFromVESA( 
    MONITOR_INFO *mi, 
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

BOOLEAN 
BuildFrequencyListForSGIDFP( 
    MONITOR_INFO *mi, 
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );
 
BOOLEAN    
GrowTimingList( 
    PVOID HwDeviceExtension,
    MONITOR_INFO *mi 
    );

BOOLEAN   
CopyMonitorTimings( 
    PVOID HwDeviceExtension,
    MONITOR_INFO *srcMI, 
    MONITOR_INFO *destMI 
    );

VOID 
testExtendRanges( 
    MONITOR_INFO *mi, 
    TIMING_INFO *ti, 
    FREQUENCIES *freq 
    );

//
// bugcheck callback support
//

#define PERM3_BUGCHECK_DATA_SIZE 0x100

VOID
Perm3BugcheckCallback(
    PVOID HwDeviceExtension,
    ULONG BugcheckCode,
    PUCHAR Buffer,
    ULONG BufferSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\mini\perm3.c ===
/***************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
*
*   perm3.c
*
* Abstract:
*
*   This module contains the code that implements the Permedia 3 miniport 
*   driver
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2001 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

#include "perm3.h"
#include "string.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,Perm3FindAdapter)
#pragma alloc_text(PAGE,Perm3AssignResources)
#pragma alloc_text(PAGE,Perm3ConfigurePci)
#pragma alloc_text(PAGE,GetBoardCapabilities)
#pragma alloc_text(PAGE,Perm3Initialize)
#pragma alloc_text(PAGE,SetHardwareInfoRegistries)
#pragma alloc_text(PAGE,UlongToString)
#pragma alloc_text(PAGE,MapResource)
#pragma alloc_text(PAGE,ProbeRAMSize)
#pragma alloc_text(PAGE,InitializePostRegisters)
#pragma alloc_text(PAGE,ConstructValidModesList)
#pragma alloc_text(PAGE,Perm3RegistryCallback)
#pragma alloc_text(PAGE,BuildInitializationTable)
#pragma alloc_text(PAGE,CopyROMInitializationTable)
#pragma alloc_text(PAGE,GenerateInitializationTable)
#pragma alloc_text(PAGE,ProcessInitializationTable)
#endif

ULONG
DriverEntry (
    PVOID Context1,
    PVOID Context2
    )

/*+++

Routine Description:

    DriverEntry is the initial entry point into the video miniport driver.

Arguments:

    Context1
        First context value passed by the operating system. This is the 
        value with which the miniport driver calls VideoPortInitialize().

    Context2
        Second context value passed by the operating system. This is the 
        value with which the miniport driver calls VideoPortInitialize().

Return Value:

    Status from VideoPortInitialize()

---*/

{
    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG initializationStatus;

    //
    // Zero out structure.
    //

    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));


    //
    // Set entry points.
    //

    hwInitData.HwFindAdapter = Perm3FindAdapter;
    hwInitData.HwInitialize = Perm3Initialize;
    hwInitData.HwStartIO = Perm3StartIO;
    hwInitData.HwResetHw = Perm3ResetHW;
    hwInitData.HwInterrupt = Perm3VideoInterrupt;
    hwInitData.HwGetPowerState = Perm3GetPowerState;
    hwInitData.HwSetPowerState = Perm3SetPowerState;
    hwInitData.HwGetVideoChildDescriptor = Perm3GetChildDescriptor;
    hwInitData.HwQueryInterface = Perm3QueryInterface;

    //
    // Declare the legacy resources
    //

    hwInitData.HwLegacyResourceList = Perm3LegacyResourceList;
    hwInitData.HwLegacyResourceCount = Perm3LegacyResourceEntries;

    //
    // This device only supports the PCI bus.
    //

    hwInitData.AdapterInterfaceType = PCIBus;

    //
    // Determine the size required for the device extension.
    //
  
    hwInitData.HwDeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

    //
    // Specify sizes of structure and extension.
    //

    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    initializationStatus = VideoPortInitialize (Context1,
                                                Context2,
                                                &hwInitData,
                                                NULL);

#ifdef SIZE_OF_W2K_VIDEO_HW_INITIALIZATION_DATA
//
//  This check will only be compiled under a Windows XP build environment where
//  the size of VIDEO_HW_INITIALIZATION_DATA has changed relative to Windows 2000
//  and therefore SIZE_OF_W2K_VIDEO_HW_INITIALIZATION_DATA is defined in order to
//  be able to load (in case of need) under Windows 2000
//
    if(initializationStatus != NO_ERROR) {
  
        //
        // This is to make sure the driver could load on Win2k as well
        //

        hwInitData.HwInitDataSize = SIZE_OF_W2K_VIDEO_HW_INITIALIZATION_DATA;

        //
        // We will only support QueryInterface on WinXP
        //

        hwInitData.HwQueryInterface = NULL;

        initializationStatus = VideoPortInitialize(Context1,
                                                   Context2,
                                                   &hwInitData,
                                                   NULL);
    }
#endif // SIZE_OF_W2K_VIDEO_HW_INITIALIZATION_DATA

    return initializationStatus;

} // end DriverEntry()

VP_STATUS 
Perm3FindAdapter (
    PVOID HwDeviceExtension, 
    PVOID HwContext, 
    PWSTR ArgumentString, 
    PVIDEO_PORT_CONFIG_INFO ConfigInfo, 
    PUCHAR Again
    )

/*+++

Routine Description:

    This routine gets the access ranges for a device on an enumerable
    bus and, if necessary, determines the device type.

Arguments:

    HwDeviceExtension
        Points to the driver's per-device storage area.

    HwContext
        Is NULL and should be ignored by the miniport.

    ArgumentString
        Suuplies a NULL terminated ASCII string. This string originates
        from the user. This pointer can be NULL.

    ConfigInfo
        Points to a VIDEO_PORT_CONFIG_INFO structure. The video port driver 
        allocates memory for and initializes this structure with any known 
        configuration information, such as values the miniport driver set 
        in the VIDEO_HW_INITIALIZATION_DATA and the SystemIoBusNumber. 

    Again
        Should be ignored by the miniport driver. 

Return Value:

    This routine must return one of the following status codes:

    NO_ERROR
        Indicates success.

    ERROR_INVALID_PARAMETER
        Indicates that the adapter could not be properly configured or
        information was inconsistent. (NOTE: This does not mean that the
        adapter could not be initialized. Miniports must not attempt to
        initialize the adapter in this routine.)

    ERROR_DEV_NOT_EXIST
        Indicates, for a non-enumerable bus, that the miniport driver could
        not find the device.

---*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    VideoDebugPrint((3, "Perm3: Perm3FindAdapter called for bus %d. hwDeviceExtension at 0x%x\n", 
                         ConfigInfo->SystemIoBusNumber, hwDeviceExtension));

    //
    // Make sure the size of the structure is at least as large as what we
    // are expecting.
    //

    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO)) {

        VideoDebugPrint((0, "Perm3: bad size for VIDEO_PORT_CONFIG_INFO\n"));
        return (ERROR_INVALID_PARAMETER);
    }

    if(!Perm3ConfigurePci(hwDeviceExtension)) {

        VideoDebugPrint((0, "Perm3: Perm3ConfigurePci failed! \n"));
        return (ERROR_INVALID_PARAMETER);
    }

    if (!Perm3AssignResources(hwDeviceExtension)) {

        VideoDebugPrint((0, "Perm3: Perm3AssignResources failed! \n"));
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // For I2C support we want to be able to associate a hwId with a
    // child device.  Use the new VideoPortGetAssociatedDeviceID call
    // to get this information.
    //
    // This call will return NULL on Win2k but this is ok, because we
    // won't expose QueryInterface on Win2k, and thus will not try
    // to use this function.
    //

    hwDeviceExtension->WinXpVideoPortGetAssociatedDeviceID =
        ConfigInfo->VideoPortGetProcAddress(hwDeviceExtension,
                                            "VideoPortGetAssociatedDeviceID");

    hwDeviceExtension->WinXpSp1VideoPortRegisterBugcheckCallback =
        ConfigInfo->VideoPortGetProcAddress(hwDeviceExtension,
                                            "VideoPortRegisterBugcheckCallback");

    //
    // Clear out the Emulator entries and the state size since this driver
    // does not support them.
    //

    ConfigInfo->NumEmulatorAccessEntries = 0;
    ConfigInfo->EmulatorAccessEntries = NULL;
    ConfigInfo->EmulatorAccessEntriesContext = 0;

    //
    // This driver does not do SAVE/RESTORE of hardware state.
    //

    ConfigInfo->HardwareStateSize = 0;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart = 0x000A0000;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryLength = 0x00020000;

    //
    // Will be initialized in BuildInitializationTable
    //

    hwDeviceExtension->culTableEntries = 0;

    //
    // Will be initialized in ConstructValidModesList
    //

    hwDeviceExtension->pFrequencyDefault = NULL;

    //
    // We'll set this TRUE when in InitializeVideo after programming the VTG
    //

    hwDeviceExtension->bVTGRunning = FALSE;

    //
    // Set up the defaults to indicate that we couldn't allocate a buffer 
    //

    hwDeviceExtension->LineDMABuffer.virtAddr = 0;
    hwDeviceExtension->LineDMABuffer.size = 0;
    hwDeviceExtension->LineDMABuffer.cacheEnabled = FALSE;
    hwDeviceExtension->BiosVersionMajorNumber = 0xffffffff;
    hwDeviceExtension->BiosVersionMinorNumber = 0xffffffff;
    hwDeviceExtension->ChipClockSpeed = 0;
    hwDeviceExtension->ChipClockSpeedAlt = 0;
    hwDeviceExtension->RefClockSpeed = 0;
    hwDeviceExtension->bMonitorPoweredOn = TRUE;
    hwDeviceExtension->PreviousPowerState = VideoPowerOn;

    if ((ConfigInfo->BusInterruptLevel | ConfigInfo->BusInterruptVector) != 0) {

        hwDeviceExtension->Capabilities |= CAPS_INTERRUPTS;
    }

    if (hwDeviceExtension->deviceInfo.DeviceId == PERMEDIA4_ID) {
        hwDeviceExtension->Capabilities |= CAPS_DISABLE_OVERLAY;
    }

    //
    // If the support is present; register a bugcheck callback
    //

    if (hwDeviceExtension->WinXpSp1VideoPortRegisterBugcheckCallback) {

        hwDeviceExtension->WinXpSp1VideoPortRegisterBugcheckCallback(
            hwDeviceExtension,
            0xEA,
            Perm3BugcheckCallback,
            PERM3_BUGCHECK_DATA_SIZE);
    }

    return(NO_ERROR);

} // end Perm3FindAdapter()

BOOLEAN 
Perm3AssignResources(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

/*+++

Routine Description:

    This routine allocates resources required by a device

---*/

{
    VIDEO_ACCESS_RANGE *aAccessRanges = hwDeviceExtension->PciAccessRange;
    ULONG cAccessRanges = sizeof(hwDeviceExtension->PciAccessRange) / sizeof(VIDEO_ACCESS_RANGE);
    VP_STATUS status;
    
    VideoPortZeroMemory((PVOID)aAccessRanges, 
                        cAccessRanges * sizeof(VIDEO_ACCESS_RANGE));

    status = VideoPortGetAccessRanges(hwDeviceExtension, 
                                      0, 
                                      NULL, 
                                      cAccessRanges, 
                                      aAccessRanges,
                                      NULL, 
                                      NULL, 
                                      (PULONG) &(hwDeviceExtension->pciSlot));

    if (status != NO_ERROR) {

        VideoDebugPrint((0, "Perm3: VideoPortGetAccessRanges failed. error 0x%x\n", status));
        return(FALSE);
    }

    return(TRUE);
}

BOOLEAN 
Perm3ConfigurePci(
    PVOID HwDeviceExtension
    )

/*+++

Routine Description:

    This routine gets information from PCI config space and turn on memory 
    and busmaster enable bits.

Return Value:

     TRUE if successful

---*/
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PCI_COMMON_CONFIG PciConfig;
    PCI_COMMON_CONFIG *PciData = &PciConfig;
    ULONG ul;
    UCHAR *ajPciData;
    UCHAR ChipCapPtr;

    //
    // When accessing the chip's PCI config region, be sure not to
    // touch the indirect access registers. Gamma has an EEPROM access 
    // reigter @ 0x80, Perm3 have indirect access registers from 0xF8.
    //

    ul = VideoPortGetBusData(hwDeviceExtension, 
                             PCIConfiguration, 
                             0, 
                             PciData, 
                             0, 
                             80);

    if(ul == 0) {

        VideoDebugPrint((0, "Perm3: VideoPortGetBusData Failed \n"));
        return (FALSE);
    }     

    hwDeviceExtension->deviceInfo.VendorId = PciConfig.VendorID;
    hwDeviceExtension->deviceInfo.DeviceId = PciConfig.DeviceID;
    hwDeviceExtension->deviceInfo.RevisionId = PciConfig.RevisionID;
    hwDeviceExtension->deviceInfo.SubsystemId = PciConfig.u.type0.SubSystemID;
    hwDeviceExtension->deviceInfo.SubsystemVendorId = PciConfig.u.type0.SubVendorID;
    hwDeviceExtension->deviceInfo.GammaRevId = 0;
    hwDeviceExtension->deviceInfo.DeltaRevId = 0;

    //
    // in multi-adapter systems we need to check if the device is 
    // decoding VGA resource
    //

    VideoPortGetVgaStatus( HwDeviceExtension, &ul);
    hwDeviceExtension->bVGAEnabled = (ul & DEVICE_VGA_ENABLED) ? TRUE : FALSE;

    //
    // Find the board capabilities
    //

    hwDeviceExtension->Perm3Capabilities =
                       GetBoardCapabilities(hwDeviceExtension, 
                                            PciData->u.type0.SubVendorID, 
                                            PciData->u.type0.SubSystemID);

    //
    // Determin if it is a AGP card by searching the AGP_CAP_ID
    //

    ajPciData = (UCHAR *)PciData;
    ChipCapPtr = ajPciData[AGP_CAP_PTR_OFFSET];

    hwDeviceExtension->bIsAGP = FALSE;

    while (ChipCapPtr && (ajPciData[ChipCapPtr] != AGP_CAP_ID)) {

        //
        // follow the next ptr    
        //

        ChipCapPtr = ajPciData[ChipCapPtr+1];
    }

    if(ajPciData[ChipCapPtr] == AGP_CAP_ID) {

        hwDeviceExtension->bIsAGP = TRUE;
    }

    PciData->LatencyTimer = 0xff;
    PciData->Command |= (PCI_ENABLE_MEMORY_SPACE | PCI_ENABLE_BUS_MASTER);

    ul = VideoPortSetBusData(HwDeviceExtension, 
                             PCIConfiguration, 
                             0, 
                             PciData, 
                             0, 
                             PCI_COMMON_HDR_LENGTH);    

    if (ul < PCI_COMMON_HDR_LENGTH) {
        return (FALSE);
    }

    return (TRUE);
}

ULONG
GetBoardCapabilities(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    ULONG SubvendorID, 
    ULONG SubdeviceID
    )
/*+++

Routine Description:

    Return a list of capabilities of the perm3 board. 

---*/
{
    PERM3_CAPS Perm3Caps = 0;

    if (SubvendorID == SUBVENDORID_3DLABS) {
   
        //
        // Check for SGRAM and DFP
        //
        switch (SubdeviceID) {

            case SUBDEVICEID_P3_VX1_1600SW:       
                Perm3Caps |= PERM3_DFP; 
                break;
        }

    }

    return (Perm3Caps);
}


BOOLEAN 
Perm3Initialize(
    PVOID HwDeviceExtension
    )

/*+++

Routine Description:

    This routine does one time initialization of the device

Arguments:

    HwDeviceExtension
        Points to the driver's per-device storage area.

Return Value:

    TRUE if successful

---*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS vpStatus;
    ULONG ul;
    pPerm3ControlRegMap pCtrlRegs;

    VideoDebugPrint((3, "Perm3: Perm3Initialize called, hwDeviceExtension = %p\n", hwDeviceExtension));

    //
    // Map the control register, framebufer and initialize memory control 
    // registers on the way
    //

    if(!MapResource(hwDeviceExtension)) {

        VideoDebugPrint((0, "Perm3: failed to map the framebuffer and control registers\n"));
        return(FALSE);
    }

    //
    // At this time ctrlRegBase should be initialized
    //

    pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];
    hwDeviceExtension->pRamdac = &(pCtrlRegs->ExternalVideo);

    hwDeviceExtension->DacId = P3RD_RAMDAC;
    hwDeviceExtension->deviceInfo.ActualDacId = P3RD_RAMDAC;
    hwDeviceExtension->deviceInfo.BoardId = PERMEDIA3_BOARD;

    if(!hwDeviceExtension->bIsAGP) {

        ul = VideoPortReadRegisterUlong(CHIP_CONFIG);
        ul &= ~(1 << 9);
        VideoPortWriteRegisterUlong(CHIP_CONFIG, ul);
    }

    //
    // Save hardware information to the registry
    //

    SetHardwareInfoRegistries(hwDeviceExtension);

    ConstructValidModesList(hwDeviceExtension, 
                            &hwDeviceExtension->monitorInfo);

    if (hwDeviceExtension->monitorInfo.numAvailableModes == 0) {
   
        VideoDebugPrint((0, "Perm3: No video modes available\n"));
        return(FALSE);
    }

    //
    // if we have interrupts available do any interrupt initialization.
    //

    if (hwDeviceExtension->Capabilities & CAPS_INTERRUPTS) {

        if (!Perm3InitializeInterruptBlock(hwDeviceExtension))
            hwDeviceExtension->Capabilities &= ~CAPS_INTERRUPTS;
    }

    return TRUE;

} // end Perm3Initialize()


VOID
SetHardwareInfoRegistries(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

/*+++

Routine Description:

    Determine the hardware information and save them in the registry

---*/
{
    PWSTR pwszChip, pwszDAC, pwszAdapterString, pwszBiosString, pwsz;
    ULONG cbChip, cbDAC, cbAdapterString, cbBiosString, ul;
    WCHAR StringBuffer[60];
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    //
    // Get the device name
    //

    cbChip = sizeof(L"3Dlabs PERMEDIA 3");
    pwszChip = L"3Dlabs PERMEDIA 3";

    //
    // Get the board name
    //

    if(hwDeviceExtension->deviceInfo.SubsystemVendorId == SUBVENDORID_3DLABS){
                                 
        switch (hwDeviceExtension->deviceInfo.SubsystemId) {
           
            case SUBDEVICEID_P3_32D_AGP:
                cbAdapterString = sizeof(L"3Dlabs Permedia3 Create!");
                pwszAdapterString = L"3Dlabs Permedia3 Create!";
                break;

            case SUBDEVICEID_P3_VX1_AGP:
            case SUBDEVICEID_P3_VX1_PCI:
                cbAdapterString = sizeof(L"3Dlabs Oxygen VX1");
                pwszAdapterString = L"3Dlabs Oxygen VX1";
                break;

            case SUBDEVICEID_P3_VX1_1600SW:
                cbAdapterString = sizeof(L"3Dlabs Oxygen VX1 1600SW");
                pwszAdapterString = L"3Dlabs Oxygen VX1 1600SW";
                break;

            default:
                cbAdapterString = sizeof(L"3Dlabs PERMEDIA 3");
                pwszAdapterString = L"3Dlabs PERMEDIA 3";
                break;
        }

    } else {
      
        //
        // Non-3Dlabs board, just call it a P3
        //

        cbAdapterString = sizeof(L"PERMEDIA 3");
        pwszAdapterString = L"PERMEDIA 3";
    }
    
    //
    // Get the RAMDAC name
    //

    pwszDAC = L"3Dlabs P3RD";
    cbDAC = sizeof(L"3Dlabs P3RD");

    //
    // get the BIOS version number string
    //

    pwszBiosString = StringBuffer;
    cbBiosString = sizeof(L"Version ");
    VideoPortMoveMemory((PVOID)StringBuffer, (PVOID)(L"Version "), cbBiosString);

    pwsz = pwszBiosString + (cbBiosString >> 1) - 1; // position on L'\0';

    if(hwDeviceExtension->BiosVersionMajorNumber != 0xffffffff) {
   
        ul = UlongToString(hwDeviceExtension->BiosVersionMajorNumber, pwsz);
        cbBiosString += ul << 1;
        pwsz += ul;

        *pwsz++ = L'.';
        cbBiosString += sizeof(L'.');

        ul = UlongToString(hwDeviceExtension->BiosVersionMinorNumber, pwsz);
        cbBiosString += ul << 1;
    }

    //
    // We now have a complete hardware description of the hardware.
    // Save the information to the registry so it can be used by
    // configuration programs - such as the display applet.
    //

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.ChipType",
                                   pwszChip,
                                   cbChip);

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.DacType",
                                   pwszDAC,
                                   cbDAC);

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.MemorySize",
                                   &hwDeviceExtension->AdapterMemorySize,
                                   sizeof(ULONG));

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.AdapterString",
                                   pwszAdapterString,
                                   cbAdapterString);

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.BiosString",
                                   pwszBiosString,
                                   cbBiosString);
}

ULONG 
UlongToString(
    ULONG i, 
    PWSTR pwsz
    )

/*+++

Arguments:

    i
        Input number

    pwsz
        Output wide string: it is the user's responsibility to ensure this
        is wide enough

Return Value:

    Number of wide characters returned in pwsz

---*/

{
    ULONG j, k;
    BOOLEAN bSignificantDigit = FALSE;
    ULONG cwch = 0;

    if(i == 0) {

        *pwsz++ = L'0';
        ++cwch;

    } else {

        //
        // maxmium 10^n representable in a ulong
        //

        j = 1000000000;

        while(i || j) {
        
            if(i && i >= j) {
           
                k = i / j;
                i -= k * j;
                bSignificantDigit = TRUE;

            } else {

                k = 0;
            }

            if(k || bSignificantDigit) {
            
                *pwsz++ = L'0' + (WCHAR)k;
                ++cwch;
            }

            j /= 10;
        }
    }

    *pwsz = L'\0';

    return(cwch);
}
 

BOOLEAN 
MapResource(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

/*+++

Routine Description:

    Get the mapped addresses of the control registers and framebuffer 


Arguments:

    HwDeviceExtension
        Points to the driver's per-device storage area.

Return Value: 

    TRUE if successful

---*/

{
    VIDEO_ACCESS_RANGE *pciAccessRange = hwDeviceExtension->PciAccessRange;
    ULONG fbMappedSize, fbRealSize;
    ULONG sz;
    pPerm3ControlRegMap pCtrlRegs;

    //
    //  Map Control Registers
    //

    pCtrlRegs = 
         VideoPortGetDeviceBase(hwDeviceExtension,
                                pciAccessRange[PCI_CTRL_BASE_INDEX].RangeStart,
                                pciAccessRange[PCI_CTRL_BASE_INDEX].RangeLength,
                                pciAccessRange[PCI_CTRL_BASE_INDEX].RangeInIoSpace);

    if (pCtrlRegs == NULL) {

        VideoDebugPrint((0, "Perm3: map control register failed\n"));
        return FALSE;
    }

    hwDeviceExtension->ctrlRegBase[0] = pCtrlRegs;

    //
    // Map Framebuffer
    //
    
    pciAccessRange[PCI_FB_BASE_INDEX].RangeInIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;

    hwDeviceExtension->pFramebuffer = 
            VideoPortGetDeviceBase(hwDeviceExtension, 
                                   pciAccessRange[PCI_FB_BASE_INDEX].RangeStart,
                                   pciAccessRange[PCI_FB_BASE_INDEX].RangeLength,
                                   pciAccessRange[PCI_FB_BASE_INDEX].RangeInIoSpace);

    if(hwDeviceExtension->pFramebuffer == NULL) {

        //
        // If we failed to map the whole range for some reason then try to
        // map part of it. We reduce the amount we map till we succeed
        // or the size gets to zero in which case we really have failed.
        //

        for (sz = pciAccessRange[PCI_FB_BASE_INDEX].RangeLength; 
             sz > 0; 
             sz -= 1024*1024) {
       
            pciAccessRange[PCI_FB_BASE_INDEX].RangeInIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;

            hwDeviceExtension->pFramebuffer = 
                    VideoPortGetDeviceBase(hwDeviceExtension, 
                                           pciAccessRange[PCI_FB_BASE_INDEX].RangeStart,
                                           sz,
                                           pciAccessRange[PCI_FB_BASE_INDEX].RangeInIoSpace);

            if(hwDeviceExtension->pFramebuffer != NULL) {
                pciAccessRange[PCI_FB_BASE_INDEX].RangeLength = sz;
                break;
            }
        }

        //
        // if sz is zero, well we tried ...
        //

        if (sz == 0) {

            VideoDebugPrint((0, "Perm3: map framebuffer failed\n"));
            return(FALSE);
        }   
    }

    VideoDebugPrint((3, "Perm3: FB mapped at 0x%x for length 0x%x (%s)\n", 
                         hwDeviceExtension->pFramebuffer, 
                         pciAccessRange[PCI_FB_BASE_INDEX].RangeLength,
                         pciAccessRange[PCI_FB_BASE_INDEX].RangeInIoSpace ? "I/O Ports" : "MemMapped"));

    //
    // Initialize the RAM registers and then probe the framebuffer size
    //

    InitializePostRegisters(hwDeviceExtension);

    fbMappedSize = pciAccessRange[PCI_FB_BASE_INDEX].RangeLength;

    if ((fbRealSize = ProbeRAMSize (hwDeviceExtension, 
                                    hwDeviceExtension->pFramebuffer, 
                                    fbMappedSize)) == 0 ) {

        VideoPortFreeDeviceBase(hwDeviceExtension, 
                                hwDeviceExtension->pFramebuffer);

        VideoDebugPrint((0, "perm3: ProbeRAMSize returned 0\n"));
        return (FALSE);
    }

    if (fbRealSize < fbMappedSize) {

        pciAccessRange[PCI_FB_BASE_INDEX].RangeLength = fbRealSize;

        VideoDebugPrint((3, "perm3: RAM dynamically resized to length 0x%x\n",
                             fbRealSize));
    }

    //
    // Finally, if the RAM size is actually smaller than the region that
    // we mapped, remap to the smaller size to save on page table entries.
    //

    if (fbMappedSize > pciAccessRange[PCI_FB_BASE_INDEX].RangeLength) {
   
        VideoPortFreeDeviceBase(hwDeviceExtension, 
                                hwDeviceExtension->pFramebuffer);

        pciAccessRange[PCI_FB_BASE_INDEX].RangeInIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;

        if ((hwDeviceExtension->pFramebuffer =
                     VideoPortGetDeviceBase(hwDeviceExtension,
                                            pciAccessRange[PCI_FB_BASE_INDEX].RangeStart,
                                            pciAccessRange[PCI_FB_BASE_INDEX].RangeLength,
                                            pciAccessRange[PCI_FB_BASE_INDEX].RangeInIoSpace
                                            )) == NULL) {
            //
            // This shouldn't happen but we'd better check
            //

            VideoDebugPrint((0, "Perm3: Remap of framebuffer to smaller size failed!\n"));
            return FALSE;
        }

        VideoDebugPrint((3, "Perm3: Remapped framebuffer memory to 0x%x, size 0x%x\n",
                             hwDeviceExtension->pFramebuffer,
                             pciAccessRange[PCI_FB_BASE_INDEX].RangeLength));
    }

    //
    // Record the size of the video memory.
    //

    hwDeviceExtension->PhysicalFrameIoSpace = 0;
    hwDeviceExtension->AdapterMemorySize = 
                       pciAccessRange[PCI_FB_BASE_INDEX].RangeLength;

    //
    // Record Frame buffer information
    //

    hwDeviceExtension->PhysicalFrameAddress = 
                       pciAccessRange[PCI_FB_BASE_INDEX].RangeStart;
    hwDeviceExtension->FrameLength = 
                       pciAccessRange[PCI_FB_BASE_INDEX].RangeLength;

    //
    // Record Control Register information
    //

    hwDeviceExtension->PhysicalRegisterAddress = 
                       pciAccessRange[PCI_CTRL_BASE_INDEX].RangeStart;
    hwDeviceExtension->RegisterLength = 
                       pciAccessRange[PCI_CTRL_BASE_INDEX].RangeLength;
    hwDeviceExtension->RegisterSpace = 
                       pciAccessRange[PCI_CTRL_BASE_INDEX].RangeInIoSpace;

    return(TRUE);
}

    
ULONG 
ProbeRAMSize(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    PULONG FBBaseAddress, 
    ULONG FBMappedSize
    )
/*+++

Routine Description:

    Dynamically size the on-board memory for the Permedia3

Arguments:

    HwDeviceExtension
        Supplies a pointer to the miniport's device extension.

    FBBaseAddress
        Starting address of framebuffer 

    FBMappedSize
        Mapped size

Return Value:

    Size, in bytes, of the memory.

---*/

{
    PULONG pV, pVStart, pVEnd;
    ULONG  realFBLength, testPattern, probeSize, temp, startLong1, startLong2;
    ULONG_PTR ulPtr;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    //
    // Dynamically size the SGRAM/SDRAM. Sample every 128K. We start
    // at the end of memory and work our way up writing the address into 
    // memory at that address. We do this every 'probeSize' DWORDS.
    // We then validate the data by reading it back again, starting from
    // the end of memory working our way up until we read a value back 
    // from memory that matches the address that we are at.
    //
    // Note that this algorithm does a destructive test of memory !!
    //

    testPattern = 0x55aa33cc;
    probeSize = (128 * 1024 / sizeof(ULONG));   // In DWords
    pVStart = (PULONG)FBBaseAddress;
    pVEnd = (PULONG)((ULONG_PTR)pVStart + (ULONG_PTR)FBMappedSize);

    //
    // Check out address zero, just in case the memory is really messed up.
    // We also save away the first 2 long words and restore them at the end, 
    // otherwise our boot screen looks wonky.
    //

    startLong1 = VideoPortReadRegisterUlong(pVStart);
    startLong2 = VideoPortReadRegisterUlong(pVStart+1);
    VideoPortWriteRegisterUlong(pVStart, testPattern);
    VideoPortWriteRegisterUlong(pVStart+1, 0);

    if ((temp = VideoPortReadRegisterUlong(pVStart)) != testPattern) {
   
        VideoDebugPrint((0, "Perm3: Cannot access SGRAM/SDRAM. Expected 0x%x, got 0x%x\n", testPattern, temp));
        realFBLength = 0;

    } else {
   
        //
        // Restore first 2 long words otherwise we end up with a corrupt
        // VGA boot screen
        //

        VideoPortWriteRegisterUlong(pVStart, startLong1);
        VideoPortWriteRegisterUlong(pVStart+1, startLong2);

        //
        // Write the memory address at the memory address, starting from the
        // end of memory and working our way down.
        //

        for (pV = pVEnd - probeSize; pV >= pVStart; pV -= probeSize) {

            ulPtr = (ULONG_PTR)pV & 0xFFFFFFFF;
            VideoPortWriteRegisterUlong(pV, (ULONG) ulPtr);
        }

        //
        // Read the data at the memory address, starting from the end of memory
        // and working our way down. If the address is correct then we stop and
        // work out the memory size.
        //

        for (pV = pVEnd - probeSize; pV >= pVStart; pV -= probeSize) {
       
            ulPtr = (ULONG_PTR)pV & 0xFFFFFFFF;

            if (VideoPortReadRegisterUlong(pV) == (ULONG) ulPtr) {
                pV += probeSize;
                break;
            }
        }
        
        realFBLength = (ULONG)((PUCHAR) pV - (PUCHAR) pVStart);
    }

    //
    // Restore first 2 long words again, otherwise we end up with a corrupt
    // VGA boot screen
    //

    VideoPortWriteRegisterUlong(pVStart, startLong1);
    VideoPortWriteRegisterUlong(pVStart+1, startLong2);

    VideoDebugPrint((3, "Perm3: ProbeRAMSize returning length %d (0x%x) bytes\n", realFBLength, realFBLength));
    return (realFBLength);
}

VOID
InitializePostRegisters(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )
{
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    //
    // Build the initialization table if it is empty
    //

    if (hwDeviceExtension->culTableEntries == 0) {

        BuildInitializationTable(hwDeviceExtension);
    }

    ASSERT(hwDeviceExtension->culTableEntries != 0); 
    
    ProcessInitializationTable(hwDeviceExtension);

    VideoPortWriteRegisterUlong(APERTURE_ONE, 0x0);
    VideoPortWriteRegisterUlong(APERTURE_TWO, 0x0);
    VideoPortWriteRegisterUlong(BYPASS_WRITE_MASK, 0xFFFFFFFF);
}


VOID
ConstructValidModesList(
    PVOID HwDeviceExtension,
    MONITOR_INFO *mi
    )

/*+++

Routine Description:

    Here we prune valid modes, based on rules according to the chip
    capabilities and memory requirements.

---*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PPERM3_VIDEO_FREQUENCIES FrequencyEntry;
    PPERM3_VIDEO_MODES ModeEntry;
    BOOLEAN AllowForZBuffer;
    LONG AdapterMemorySize;
    ULONG ModeIndex, i;
    ULONG localBufferSizeInBytes = 2;

    AllowForZBuffer = TRUE;

    mi->numAvailableModes = 0;

    //
    // Since there are a number of frequencies possible for each
    // distinct resolution/colour depth, we cycle through the
    // frequency table and find the appropriate mode entry for that
    // frequency entry.
    //

    if (!BuildFrequencyList(hwDeviceExtension, mi))
        return;

    for (FrequencyEntry = mi->frequencyTable, ModeIndex = 0;
         FrequencyEntry->BitsPerPel != 0;
         FrequencyEntry++, ModeIndex++) {

        //
        // Find the mode for this entry.  First, assume we won't find one.
        //

        FrequencyEntry->ModeValid = FALSE;
        FrequencyEntry->ModeIndex = ModeIndex;

        for (ModeEntry = Perm3Modes, i = 0;  
             i < NumPerm3VideoModes; 
             ModeEntry++, i++) {

            if ((FrequencyEntry->BitsPerPel ==
                    ModeEntry->ModeInformation.BitsPerPlane) &&
                (FrequencyEntry->ScreenHeight ==
                    ModeEntry->ModeInformation.VisScreenHeight) &&
                (FrequencyEntry->ScreenWidth ==
                    ModeEntry->ModeInformation.VisScreenWidth)) {

                AdapterMemorySize = (LONG)hwDeviceExtension->AdapterMemorySize;

                //
                // Allow for a Z buffer on Permedia3. It's always 16 bits deep.
                //

                if (AllowForZBuffer) {
                    AdapterMemorySize -= 
                          (LONG)(ModeEntry->ModeInformation.VisScreenWidth *
                                 ModeEntry->ModeInformation.VisScreenHeight *
                                 localBufferSizeInBytes);
                }

                //
                // If we need to be double buffered then we only have half this
                // remainder for the visible screen. 12bpp is special since
                // each pixel contains both front and back.
                //

                if ((FrequencyEntry->BitsPerPel != 12))
                    AdapterMemorySize /= 2;

                //
                // We've found a mode table entry that matches this frequency
                // table entry.  Now we'll figure out if we can actually do
                // this mode/frequency combination.  For now, assume we'll
                // succeed.
                //

                FrequencyEntry->ModeEntry = ModeEntry;
                FrequencyEntry->ModeValid = TRUE;

                VideoDebugPrint((3, "Perm3: Trying mode: %dbpp, w x h %d x %d @ %dHz... ",
                                ModeEntry->ModeInformation.BitsPerPlane,
                                ModeEntry->ModeInformation.VisScreenWidth,
                                ModeEntry->ModeInformation.VisScreenHeight,
                                FrequencyEntry->ScreenFrequency
                                ));

                //
                // Rule: Refuses to handle <60Hz refresh.
                //

                if( (FrequencyEntry->ScreenFrequency < 60) && 
                    !(hwDeviceExtension->Perm3Capabilities & PERM3_DFP_MON_ATTACHED) ) {

                    FrequencyEntry->ModeValid = FALSE;
                }

                if( (hwDeviceExtension->Perm3Capabilities & PERM3_DFP_MON_ATTACHED) &&
                    (FrequencyEntry->BitsPerPel == 8) ) {

                     FrequencyEntry->ModeValid = FALSE;
                }

                //
                // Rule: On Perm3, if this is an eight-bit mode that requires
                // us to use byte doubling then the pixel-clock validation is 
                // more strict because we have to double the pixel clock.
                //

                if (FrequencyEntry->BitsPerPel == 8) {

                    VESA_TIMING_STANDARD  VESATimings;

                    //
                    // Get the timing parameters for this mode.
                    //

                    if (GetVideoTiming(HwDeviceExtension,
                                        ModeEntry->ModeInformation.VisScreenWidth,
                                        ModeEntry->ModeInformation.VisScreenHeight,
                                        FrequencyEntry->ScreenFrequency,
                                        FrequencyEntry->BitsPerPel,
                                        &VESATimings)) {

                        if ( P3RD_CHECK_BYTE_DOUBLING (hwDeviceExtension, 
                                                       FrequencyEntry->BitsPerPel, 
                                                       &VESATimings) &&
                            (VESATimings.pClk << 1) > P3_MAX_PIXELCLOCK ) {

                            VideoDebugPrint((3, "Perm3: Bad 8BPP pixelclock\n"));
                            FrequencyEntry->ModeValid = FALSE;
                        }

                    } else {

                            VideoDebugPrint((0, "Perm3: GetVideoTiming failed\n"));
                            FrequencyEntry->ModeValid = FALSE;
                        }
                    }

                //
                // Rule: Do not support 15BPP (555 mode)
                //

                if ( FrequencyEntry->BitsPerPel == 15 ) {

                    FrequencyEntry->ModeValid = FALSE;
                }  

                ModeEntry->ModeInformation.ScreenStride = ModeEntry->ScreenStrideContiguous;

                //
                // Rule: We have to have enough memory to handle the mode.                
                //

                if ((LONG)(ModeEntry->ModeInformation.VisScreenHeight *
                           ModeEntry->ModeInformation.ScreenStride) >
                           AdapterMemorySize) {

                    FrequencyEntry->ModeValid = FALSE;
                }

                //
                // Rule: No 12 bpp, only need 60Hz at 1280 true color.
                //

                {
                    ULONG pixelData;
                    ULONG DacDepth = FrequencyEntry->BitsPerPel;

                    //
                    // We need the proper pixel size to calculate timing values
                    //

                    if (DacDepth == 15) {
                        DacDepth = 16;
                    } else if (DacDepth == 12) {
                        DacDepth = 32;
                    }
                    
                    pixelData = FrequencyEntry->PixelClock * (DacDepth / 8);

                    if ((( FrequencyEntry->PixelClock > P3_MAX_PIXELCLOCK || 
                             pixelData > P3_MAX_PIXELDATA ))) {
                   
                        FrequencyEntry->ModeValid = FALSE;
                    }
               }

                //
                // Do not supports 24bpp
                //

                if(FrequencyEntry->BitsPerPel == 24) {
               
                    FrequencyEntry->ModeValid = FALSE;
                }

                //
                // Don't forget to count it if it's still a valid mode after
                // applying all those rules.
                //

                if ( FrequencyEntry->ModeValid ) {

                    if (hwDeviceExtension->pFrequencyDefault == NULL &&
                        ModeEntry->ModeInformation.BitsPerPlane == 8 &&
                        ModeEntry->ModeInformation.VisScreenWidth == 640 &&
                        ModeEntry->ModeInformation.VisScreenHeight == 480 ) {
                   
                        hwDeviceExtension->pFrequencyDefault = FrequencyEntry;
                    }

                    ModeEntry->ModeInformation.ModeIndex = mi->numAvailableModes++;
                }
                             
                //
                // We've found a mode for this frequency entry, so we
                // can break out of the mode loop:
                //

                break;
                                     
            }
        }
    }

    mi->numTotalModes = ModeIndex;

    VideoDebugPrint((3, "perm3: %d total modes\n", ModeIndex));
    VideoDebugPrint((3, "perm3: %d total valid modes\n", mi->numAvailableModes));
}


VP_STATUS
Perm3RegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )

/*+++

Routine Description:

    This routine is used to read back various registry values.

Arguments:

    HwDeviceExtension 
        Supplies a pointer to the miniport's device extension.

    Context 
        Context value passed to the get registry parameters routine.
        If this is not null assume it's a ULONG* and save the data value in it.

    ValueName
        Name of the value requested.

    ValueData
        Pointer to the requested data.

    ValueLength
        Length of the requested data.

Return Value:

    If the variable doesn't exist return an error,
    else if a context is supplied assume it's a PULONG and fill in the value
    and return no error, else if the value is non-zero return an error.

---*/

{
    if (ValueLength) {

        if (Context) {

            *(ULONG *)Context = *(PULONG)ValueData;

        } else if (*((PULONG)ValueData) != 0) {

            return ERROR_INVALID_PARAMETER;
        }

        return NO_ERROR;

    } else {

        return ERROR_INVALID_PARAMETER;
    }

} // end Perm3RegistryCallback()


BOOLEAN
Perm3ResetHW(
    PVOID HwDeviceExtension,
    ULONG Columns,
    ULONG Rows
    )

/*+++

Routine Description:

    This routine resets the adapter to character mode.

    THIS FUNCTION CANNOT BE PAGED.

Arguments:

    hwDeviceExtension
        Points to the miniport's per-adapter storage area. 

    Columns
        Specifies the number of columns of the mode to be set up.

    Rows
       Specifies the number of rows of the mode to be set up.

Return Value:

    We always return FALSE to force the HAL to do an INT10 reset.

---*/

{
    //
    // return false so the HAL does an INT10 mode 3
    //

    return(FALSE);
}

VOID
BuildInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )  

/*+++

Routine Description:

    Read the ROM, if any is present, and extract any data needed for 
    chip set-up

Arguments:

    HwDeviceExtension
        Points to the driver's per-device storage area.

---*/

{
    PVOID romAddress;
    
    romAddress = VideoPortGetRomImage(hwDeviceExtension,
                                      NULL,
                                      0,
                                      ROM_MAPPED_LENGTH);


    if (romAddress) {
   
        //
        // We'll take a copy of the initialization table in the exansion 
        // ROM now so that we can run through the initialization ourselves, 
        // later on
        //

        CopyROMInitializationTable(hwDeviceExtension, romAddress);

        //
        // Free the ROM address since we do not need it anymore.
        //

        romAddress = VideoPortGetRomImage(hwDeviceExtension, NULL, 0, 0);
                                          
    }

    if (hwDeviceExtension->culTableEntries == 0) {
   
        //
        // No initialization table, but Perm3 really needs one in order
        // to come out of sleep mode correctly. 
        //

        GenerateInitializationTable(hwDeviceExtension);
    }
}

VOID 
CopyROMInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    PVOID pvROMAddress
    )

/*+++

Routine Description:

    This function should be called for devices that have an expansion ROM
    which contains a register initialisation table. The function assumes
    the ROM is present.

Arguments:

    HwDeviceExtension
        Points to the device extension of the device whose ROM is to be read

    pvROMAddress
        Base address of the expansion ROM. This function assumes that the 
        offset to the initialization table is defined at 0x1c from the 
        beginning of ROM

---*/

{
    PULONG pulROMTable;
    PULONG pul;
    ULONG cEntries;
    ULONG ul, regHdr;

    hwDeviceExtension->culTableEntries = 0;

    //
    // The 2-byte offset to the initialization table is given at 0x1c
    // from the start of ROM
    //

    ul = VideoPortReadRegisterUshort((USHORT *)(0x1c + (PCHAR)pvROMAddress));
    pulROMTable = (PULONG)(ul + (PCHAR)pvROMAddress);
    
    //
    // The table header (32 bits) has an identification code and a count
    // of the number of entries in the table
    //

    regHdr = VideoPortReadRegisterUlong(pulROMTable++);

    while ((regHdr >> 16) == 0x3d3d) {
   
        ULONG BiosID = (regHdr >> 8) & 0xFF;

        switch (BiosID){
        
            case 0:

                //
                //    BIOS partition 0
                //    ----------------
                //    This BIOS region holds the memory timings for Perm3 chip.
                //    We also look up the version number.
                //

                //
                // the 2-byte BIOS version number in in the form of
                // <MajorNum>.<MinorNum>
                //

                hwDeviceExtension->BiosVersionMajorNumber =
                                  (ULONG)VideoPortReadRegisterUchar((PCHAR)(0x7 + (PCHAR)pvROMAddress) ); 
                                      
                hwDeviceExtension->BiosVersionMinorNumber = 
                                  (ULONG)VideoPortReadRegisterUchar((PCHAR)(0x8 + (PCHAR)pvROMAddress)); 

                //
                // number of register address & data pairs
                //

                cEntries = regHdr & 0xffff;

                if(cEntries > 0) {
               
                    //
                    // This assert, and the one after the copy should ensure
                    // we don't write past the end of the table
                    //

                    PERM3_ASSERT( cEntries * sizeof(ULONG) * 2 <= sizeof(hwDeviceExtension->aulInitializationTable), 
                                  "Perm3: too many initialization entries\n");

                    //
                    // Each entry contains two 32-bit words
                    //

                    pul = hwDeviceExtension->aulInitializationTable;
                    ul = cEntries << 1;

                    while(ul--) {
                        *pul++ = VideoPortReadRegisterUlong(pulROMTable);
                        ++pulROMTable;
                    }

                    hwDeviceExtension->culTableEntries = 
                                      (ULONG)(pul - (ULONG *)hwDeviceExtension->aulInitializationTable) >> 1;

                    PERM3_ASSERT( cEntries == hwDeviceExtension->culTableEntries, 
                                  "Perm3: generated different size init table to that expected\n");

#if DBG
                    //
                    // Output the initialization table
                    //

                    pul = hwDeviceExtension->aulInitializationTable;
                    ul = hwDeviceExtension->culTableEntries;
 
                    while(ul--) {
                   
                        ULONG ulReg;
                        ULONG ulRegData;

                        ulReg = *pul++;
                        ulRegData = *pul++;
                        VideoDebugPrint((3, "Perm3: CopyROMInitializationTable: register %08.8Xh with %08.8Xh\n", 
                                         ulReg, ulRegData));
                    }
#endif
                }

                break;

            case 1:

                //
                //    BIOS partition 1
                //    ----------------
                //    This BIOS region holds the extended clock settings
                //    for Perm3 chips.
                //

                PERM3_ASSERT((regHdr & 0xffff) == 0x0103,  
                              "Perm3: Extended table doesn't have right cnt/ID\n");

                //
                // Some Perm3 boards have a whole set of clocks defined in
                // the BIOS. The high nibble defines the source for the
                // clock, this isn't relevant for anything but MCLK and
                // SCLK on Perm3.
                //

                hwDeviceExtension->bHaveExtendedClocks  = TRUE;

                hwDeviceExtension->ulPXRXCoreClock = 
                    ( VideoPortReadRegisterUlong(pulROMTable++) & 0xFFFFFF ) * 1000 * 1000;

                hwDeviceExtension->ulPXRXMemoryClock = 
                    VideoPortReadRegisterUlong(pulROMTable++);

                hwDeviceExtension->ulPXRXMemoryClockSrc = 
                    (hwDeviceExtension->ulPXRXMemoryClock >> 28) << 4;

                hwDeviceExtension->ulPXRXMemoryClock = 
                    (hwDeviceExtension->ulPXRXMemoryClock & 0xFFFFFF) * 1000 * 1000;

                hwDeviceExtension->ulPXRXSetupClock = 
                    VideoPortReadRegisterUlong(pulROMTable++);

                hwDeviceExtension->ulPXRXSetupClockSrc = 
                    (hwDeviceExtension->ulPXRXSetupClock >> 28) << 4;

                hwDeviceExtension->ulPXRXSetupClock = 
                    (hwDeviceExtension->ulPXRXSetupClock & 0xFFFFFF) * 1000 * 1000;

                hwDeviceExtension->ulPXRXGammaClock = 
                    (VideoPortReadRegisterUlong(pulROMTable++) & 0xFFFFFF) * 1000 * 1000;

                hwDeviceExtension->ulPXRXCoreClockAlt = 
                    (VideoPortReadRegisterUlong(pulROMTable++) & 0xFFFFFF) * 1000 * 1000;

                VideoDebugPrint((3, "Perm3: core clock %d, core clock alt %d\n", 
                                     hwDeviceExtension->ulPXRXCoreClock, 
                                     hwDeviceExtension->ulPXRXCoreClockAlt));

                VideoDebugPrint((3, "Perm3: Mem clock %d, mem clock src 0x%x\n", 
                                     hwDeviceExtension->ulPXRXMemoryClock, 
                                     hwDeviceExtension->ulPXRXMemoryClockSrc));

                VideoDebugPrint((3, "Perm3: setup clock %d, setup clock src 0x%x\n", 
                                     hwDeviceExtension->ulPXRXSetupClock, 
                                     hwDeviceExtension->ulPXRXSetupClockSrc));

                VideoDebugPrint((3, "Perm3: Gamma clock %d\n", 
                                     hwDeviceExtension->ulPXRXGammaClock));

                break;
        
            default:
                VideoDebugPrint((3, "Perm3: Extended table doesn't have right cnt/ID !\n"));
        }
    
        regHdr = VideoPortReadRegisterUlong(pulROMTable++);
    }
}

VOID 
GenerateInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

/*+++

Routine Description:

    Creates a register initialization table (called if we can't read one
    from ROM). If VGA is enabled the registers are already initialized so
    we just read them back, otherwise we have to use default values

Arguments:

    HwDeviceExtension
        Points to the driver's per-device storage area.

---*/

{
    ULONG   cEntries;
    PULONG  pul;
    ULONG   ul;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    hwDeviceExtension->culTableEntries = 0;

    cEntries = 4;

    //
    // This assert, and the one after the copy should ensure we don't
    // write past the end of the table
    //

    PERM3_ASSERT(cEntries * sizeof(ULONG) * 2 <= sizeof(hwDeviceExtension->aulInitializationTable), 
                 "Perm3: too many initialization entries\n");

    //
    // Each entry contains two 32-bit words
    //

    pul = hwDeviceExtension->aulInitializationTable;

    if (hwDeviceExtension->bVGAEnabled) {
       
        //
        // No initialization table but VGA is running so our key
        // registers have been initialized to sensible values
        //

        //
        // key entries are: ROM control, Boot Address, Memory Config
        // and VStream Config
        //

        *pul++ = CTRL_REG_OFFSET(PXRX_LOCAL_MEM_CAPS);
        *pul++ = VideoPortReadRegisterUlong(PXRX_LOCAL_MEM_CAPS);

        *pul++ = CTRL_REG_OFFSET(PXRX_LOCAL_MEM_CONTROL);
        *pul++ = VideoPortReadRegisterUlong(PXRX_LOCAL_MEM_CONTROL);

        *pul++ = CTRL_REG_OFFSET(PXRX_LOCAL_MEM_REFRESH);
        *pul++ = VideoPortReadRegisterUlong(PXRX_LOCAL_MEM_REFRESH);

        *pul++ = CTRL_REG_OFFSET(PXRX_LOCAL_MEM_TIMING);
        *pul++ = VideoPortReadRegisterUlong(PXRX_LOCAL_MEM_TIMING);

    } else {

        *pul++ = CTRL_REG_OFFSET(PXRX_LOCAL_MEM_CAPS);
        *pul++ = 0x30E311B8;

        *pul++ = CTRL_REG_OFFSET(PXRX_LOCAL_MEM_CONTROL);
        *pul++ = 0x08000002; // figures for 80 MHz

        *pul++ = CTRL_REG_OFFSET(PXRX_LOCAL_MEM_REFRESH);
        *pul++ = 0x0000006B;

        *pul++ = CTRL_REG_OFFSET(PXRX_LOCAL_MEM_TIMING);
        *pul++ = 0x08501204;
    }

    hwDeviceExtension->culTableEntries = 
            (ULONG)(pul - (ULONG *)hwDeviceExtension->aulInitializationTable) >> 1;

#if DBG

    if (cEntries != hwDeviceExtension->culTableEntries)
        VideoDebugPrint((0, "Perm3: generated different size init table to that expected\n"));

    //
    // Output the initialization table
    //

    pul = hwDeviceExtension->aulInitializationTable;
    ul = hwDeviceExtension->culTableEntries;

    while(ul--) {
    
        ULONG ulReg;
        ULONG ulRegData;

        ulReg = *pul++;
        ulRegData = *pul++;
        VideoDebugPrint((3, "Perm3: GenerateInitializationTable: register %08.8Xh with %08.8Xh\n", 
                             ulReg, ulRegData));
    }

#endif

}

VOID 
ProcessInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

/*+++

Routine Description:
    This function processes the register initialization table

---*/

{
    PULONG  pul;
    ULONG   cul;
    ULONG   ulRegAddr, ulRegData;
    PULONG  pulReg;
    ULONG   BaseAddrSelect;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    pul = (PULONG)hwDeviceExtension->aulInitializationTable;
    cul = hwDeviceExtension->culTableEntries;

    while(cul--) {
   
        ulRegAddr = *pul++;
        ulRegData = *pul++;

        BaseAddrSelect = ulRegAddr >> 29;

        if(BaseAddrSelect == 0) {
       
            //
            // The offset is from the start of the control registers
            //

            pulReg = (PULONG)((ULONG_PTR)pCtrlRegs + (ulRegAddr & 0x3FFFFF));

        } else {

            continue;
        }

        VideoDebugPrint((3, "ProcessInitializationTable: initializing (region %d) register %08.8Xh with %08.8Xh\n", 
                             BaseAddrSelect, pulReg, ulRegData));

        VideoPortWriteRegisterUlong(pulReg, ulRegData);
    }

    //
    // We need a small delay after initializing the above registers
    //

    VideoPortStallExecution(5);

}

/*++

Routine Description:

    This function is called when a bugcheck EA occurs due to a failure in
    the perm3 display driver.  The callback allows the driver to collect
    information that will make diagnosing the problem easier.  This data
    is then added to the dump file that the system creates when the crash
    occurs.

Arguments:

    HwDeviceExtension
	Points to the device extension of the device whose ROM is to be read

    BugcheckCode
	The bugcheck code for which this callback is being invoked.  Currently
	this will always be 0xEA.

    Buffer
	The location into which you should write the data you want to append
	to the dump file.

    BufferSize
	The size of the buffer supplied.

Returns:

    none

Notes:

    This routine can be called at any time, and at any IRQL level.  Thus you
    must not touch any pageable code or data in this function.

--*/

VOID
Perm3BugcheckCallback(
    PVOID HwDeviceExtension,
    ULONG BugcheckCode,
    PUCHAR Buffer,
    ULONG BufferSize
    )

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    //
    // Copy the data you want to append to the minidump here.  You may want
    // to collect data on the hardware state, driver state, or any other
    // data that may help you diagnose the 0xEA via the dump file.
    //

    if (BufferSize >= PERM3_BUGCHECK_DATA_SIZE) {
        strcpy(Buffer, "This is the sample perm3 bugcheck data!");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\mini\p3rd.h ===
/***************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
*
*   p3rd.h
*
* Abstract:
*
*   This module contains the definitions for the 3Dlabs P3 RAMDAC
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2001 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

//
// RAMDAC registers live on 64 bit boundaries. Leave it up to individual
// RAMDAC definitions to determine what registers are available and how
// many bits wide the registers really are.
//

typedef struct {
    volatile ULONG   reg;
    volatile ULONG   pad;
} RAMDAC_REG;

//
// structure with all the direct access registers
//

typedef struct _p3rd_regs {

    RAMDAC_REG    RDPaletteWriteAddress;
    RAMDAC_REG    RDPaletteData;
    RAMDAC_REG    RDPixelMask;
    RAMDAC_REG    RDPaletteAddressRead;
    RAMDAC_REG    RDIndexLow;
    RAMDAC_REG    RDIndexHigh;
    RAMDAC_REG    RDIndexedData;
    RAMDAC_REG    RDIndexControl;
} P3RDRAMDAC;

//
// Use the following macros as the address to pass to the
// VideoPortWriteRegisterUlong function
//

#define P3RD_PAL_WR_ADDR   ((PULONG)&(pP3RDRegs->RDPaletteWriteAddress.reg))
#define P3RD_PAL_RD_ADDR   ((PULONG)&(pP3RDRegs->RDPaletteAddressRead.reg))
#define P3RD_PAL_DATA      ((PULONG)&(pP3RDRegs->RDPaletteData.reg))
#define P3RD_PIXEL_MASK    ((PULONG)&(pP3RDRegs->RDPixelMask.reg))
#define P3RD_INDEX_ADDR_LO ((PULONG)&(pP3RDRegs->RDIndexLow.reg))
#define P3RD_INDEX_ADDR_HI ((PULONG)&(pP3RDRegs->RDIndexHigh.reg))
#define P3RD_INDEX_DATA    ((PULONG)&(pP3RDRegs->RDIndexedData.reg))
#define P3RD_INDEX_CONTROL ((PULONG)&(pP3RDRegs->RDIndexControl.reg))

//
// bit field definitions for the direct access registers
//

#define P3RD_IDX_CTL_AUTOINCREMENT_ENABLED  0x01

//
// Indexed register definitions accessed via P3RD_LOAD_INDEX_REG() 
// and P3RD_READ_INDEX_REG()
//

#define P3RD_MISC_CONTROL               0x0000
#define P3RD_SYNC_CONTROL               0x0001
#define P3RD_DAC_CONTROL                0x0002
#define P3RD_PIXEL_SIZE                 0x0003
#define P3RD_COLOR_FORMAT               0x0004
#define P3RD_CURSOR_MODE                0x0005
#define P3RD_CURSOR_CONTROL             0x0006
#define P3RD_CURSOR_X_LOW               0x0007
#define P3RD_CURSOR_X_HIGH              0x0008
#define P3RD_CURSOR_Y_LOW               0x0009
#define P3RD_CURSOR_Y_HIGH              0x000a
#define P3RD_CURSOR_HOTSPOT_X           0x000b
#define P3RD_CURSOR_HOTSPOT_Y           0x000c
#define P3RD_OVERLAY_KEY                0x000d
#define P3RD_PAN                        0x000e
#define P3RD_SENSE                      0x000f
#define P3RD_CHECK_CONTROL              0x0018
#define P3RD_CHECK_PIXEL_RED            0x0019
#define P3RD_CHECK_PIXEL_GREEN          0x001a
#define P3RD_CHECK_PIXEL_BLUE           0x001b
#define P3RD_CHECK_LUT_RED              0x001c
#define P3RD_CHECK_LUT_GREEN            0x001d
#define P3RD_CHECK_LUT_BLUE             0x001e
#define P3RD_SCRATCH                    0x001f
#define P3RD_VIDEO_OVERLAY_CONTROL      0x0020
#define P3RD_VIDEO_OVERLAY_X_START_LOW  0x0021
#define P3RD_VIDEO_OVERLAY_X_START_HIGH 0x0022
#define P3RD_VIDEO_OVERLAY_Y_START_LOW  0x0023
#define P3RD_VIDEO_OVERLAY_Y_START_HIGH 0x0024
#define P3RD_VIDEO_OVERLAY_X_END_LOW    0x0025
#define P3RD_VIDEO_OVERLAY_X_END_HIGH   0x0026
#define P3RD_VIDEO_OVERLAY_Y_END_LOW    0x0027
#define P3RD_VIDEO_OVERLAY_Y_END_HIGH   0x0028
#define P3RD_VIDEO_OVERLAY_KEY_R        0x0029
#define P3RD_VIDEO_OVERLAY_KEY_G        0x002A
#define P3RD_VIDEO_OVERLAY_KEY_B        0x002B
#define P3RD_VIDEO_OVERLAY_BLEND        0x002C

#define P3RD_DCLK_SETUP_1               0x01f0
#define P3RD_DCLK_SETUP_2               0x01f1
#define P3RD_KCLK_SETUP_1               0x01f2
#define P3RD_KCLK_SETUP_2               0x01f3
#define P3RD_DCLK_CONTROL               0x0200
#define P3RD_DCLK0_PRE_SCALE            0x0201
#define P3RD_DCLK0_FEEDBACK_SCALE       0x0202
#define P3RD_DCLK0_POST_SCALE           0x0203
#define P3RD_DCLK1_PRE_SCALE            0x0204
#define P3RD_DCLK1_FEEDBACK_SCALE       0x0205
#define P3RD_DCLK1_POST_SCALE           0x0206
#define P3RD_DCLK2_PRE_SCALE            0x0207
#define P3RD_DCLK2_FEEDBACK_SCALE       0x0208
#define P3RD_DCLK2_POST_SCALE           0x0209
#define P3RD_DCLK3_PRE_SCALE            0x020a
#define P3RD_DCLK3_FEEDBACK_SCALE       0x020b
#define P3RD_DCLK3_POST_SCALE           0x020c
#define P3RD_KCLK_CONTROL               0x020d
#define P3RD_KCLK_PRE_SCALE             0x020e
#define P3RD_KCLK_FEEDBACK_SCALE        0x020f
#define P3RD_KCLK_POST_SCALE            0x0210
#define P3RD_MCLK_CONTROL               0x0211
#define P3RD_SCLK_CONTROL               0x0215
#define P3RD_CURSOR_PALETTE_START       0x0303        // 303..32f
#define P3RD_CURSOR_PATTERN_START       0x0400        // 400..7ff

//
// Defaults for the MCLK and KCLK clock source registers
//

#define P3RD_DEFAULT_MCLK_SRC P3RD_MCLK_CONTROL_KCLK
#define P3RD_DEFAULT_SCLK_SRC P3RD_SCLK_CONTROL_KCLK

//
// Bit field definitions for the indexed registers
//

#define P3RD_MISC_CONTROL_STEREO_DBL_BUFFER_ENABLED   0x80
#define P3RD_MISC_CONTROL_VSB_OUTPUT_ENABLED          0x40
#define P3RD_MISC_CONTROL_PIXEL_DBL_BUFFER_ENABLED    0x20
#define P3RD_MISC_CONTROL_OVERLAYS_ENABLED            0x10
#define P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED        0x08
#define P3RD_MISC_CONTROL_LAST_READ_ADDRESS_ENABLED   0x04
#define P3RD_MISC_CONTROL_PIXEL_DOUBLE                0x02
#define P3RD_MISC_CONTROL_HIGHCOLORRES                0x01

#define P3RD_SYNC_CONTROL_VSYNC_ACTIVE_LOW    0x00
#define P3RD_SYNC_CONTROL_VSYNC_ACTIVE_HIGH   0x08
#define P3RD_SYNC_CONTROL_VSYNC_INACTIVE      0x20
#define P3RD_SYNC_CONTROL_HSYNC_ACTIVE_LOW    0x00
#define P3RD_SYNC_CONTROL_HSYNC_ACTIVE_HIGH   0x01
#define P3RD_SYNC_CONTROL_HSYNC_INACTIVE      0x04

#define P3RD_DAC_CONTROL_BLANK_PEDESTAL_ENABLED    0x80

#define P3RD_PIXEL_SIZE_8BPP            0x00
#define P3RD_PIXEL_SIZE_16BPP           0x01
#define P3RD_PIXEL_SIZE_24_BPP          0x04
#define P3RD_PIXEL_SIZE_32BPP           0x02

#define P3RD_COLOR_FORMAT_CI8           0x0e
#define P3RD_COLOR_FORMAT_8BPP          0x05
#define P3RD_COLOR_FORMAT_15BPP         0x01
#define P3RD_COLOR_FORMAT_16BPP         0x10
#define P3RD_COLOR_FORMAT_32BPP         0x00
#define P3RD_COLOR_FORMAT_LINEAR_EXT    0x40
#define P3RD_COLOR_FORMAT_RGB           0x20

#define P3RD_CURSOR_MODE_REVERSE        0x40
#define P3RD_CURSOR_MODE_WINDOWS        0x00
#define P3RD_CURSOR_MODE_X              0x10
#define P3RD_CURSOR_MODE_3COLOR         0x20
#define P3RD_CURSOR_MODE_15COLOR        0x30
#define P3RD_CURSOR_MODE_64x64          0x00
#define P3RD_CURSOR_MODE_P0_32x32x2     0x02
#define P3RD_CURSOR_MODE_P1_32x32x2     0x04
#define P3RD_CURSOR_MODE_P2_32x32x2     0x06
#define P3RD_CURSOR_MODE_P3_32x32x2     0x08
#define P3RD_CURSOR_MODE_P01_32x32x4    0x0a
#define P3RD_CURSOR_MODE_P23_32x32x4    0x0c
#define P3RD_CURSOR_MODE_ENABLED        0x01

#define P3RD_CURSOR_CONTROL_RPOS_ENABLED 0x04
#define P3RD_CURSOR_CONTROL_DOUBLE_Y     0x02
#define P3RD_CURSOR_CONTROL_DOUBLE_X     0x01

#define P3RD_DCLK_CONTROL_LOCKED         0x02    // read-only
#define P3RD_DCLK_CONTROL_ENABLED        0x01
#define P3RD_DCLK_CONTROL_RUN            0x08

#define P3RD_KCLK_CONTROL_LOCKED         0x02    // read-only
#define P3RD_KCLK_CONTROL_ENABLED        0x01
#define P3RD_KCLK_CONTROL_RUN            (0x2<<2)
#define P3RD_KCLK_CONTROL_PCLK           (0x0<<4)
#define P3RD_KCLK_CONTROL_HALF_PCLK      (0x1<<4)
#define P3RD_KCLK_CONTROL_PLL            (0x2<<4)

#define P3RD_MCLK_CONTROL_ENABLED        0x01
#define P3RD_MCLK_CONTROL_DRIVE_LOW      (0x0<<2)
#define P3RD_MCLK_CONTROL_DRIVE_HIGH     (0x1<<2)
#define P3RD_MCLK_CONTROL_RUN            (0x2<<2)
#define P3RD_MCLK_CONTROL_LOW_POWER      (0x3<<2)
#define P3RD_MCLK_CONTROL_HALF_PCLK      (0x1<<4)
#define P3RD_MCLK_CONTROL_PCLK           (0x0<<4)
#define P3RD_MCLK_CONTROL_HALF_EXTMCLK   (0x3<<4)
#define P3RD_MCLK_CONTROL_EXTMCLK        (0x4<<4)
#define P3RD_MCLK_CONTROL_HALF_KCLK      (0x5<<4)
#define P3RD_MCLK_CONTROL_KCLK           (0x6<<4)

#define P3RD_SCLK_CONTROL_ENABLED        0x01
#define P3RD_SCLK_CONTROL_DRIVE_LOW      (0x0<<2)
#define P3RD_SCLK_CONTROL_DRIVE_HIGH     (0x1<<2)
#define P3RD_SCLK_CONTROL_RUN            (0x2<<2)
#define P3RD_SCLK_CONTROL_LOW_POWER      (0x3<<2)
#define P3RD_SCLK_CONTROL_HALF_PCLK      (0x1<<4)
#define P3RD_SCLK_CONTROL_PCLK           (0x0<<4)
#define P3RD_SCLK_CONTROL_HALF_EXTSCLK   (0x3<<4)
#define P3RD_SCLK_CONTROL_EXTSCLK        (0x4<<4)
#define P3RD_SCLK_CONTROL_HALF_KCLK      (0x5<<4)
#define P3RD_SCLK_CONTROL_KCLK           (0x6<<4)

#define P3RD_CURSOR_PALETTE_CURSOR_RGB(RGBIndex, Red, Green, Blue) \
{ \
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_PALETTE_START+3*(int)RGBIndex+0, Red); \
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_PALETTE_START+3*(int)RGBIndex+1, Green); \
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_PALETTE_START+3*(int)RGBIndex+2, Blue); \
}


#if 0

//
// Need a delay between each write to the P3RD. The only way to guarantee
// that the write has completed is to read from a Permedia 3 control register.
// Reading forces any posted writes to be flushed out. PPC needs 2 reads
// to give us enough time.
//

#define P3RD_DELAY \
{ \
    volatile LONG __junk; \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
}

#else
#define P3RD_DELAY
#endif

//
// Macro to load a given data value into an internal P3RD register. The
// second macro loads an internal index register assuming that we have
// already zeroed the high address register.
//

#define P3RD_INDEX_REG(index) \
{ \
    /*VideoDebugPrint((0, "*(0x%x) <-- 0x%x\n", P3RD_INDEX_ADDR_LO, (index) & 0xff)); */\
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_LO, (ULONG)((index) & 0xff)); \
    P3RD_DELAY; \
    /*VideoDebugPrint((0, "*(0x%x) <-- 0x%x\n", P3RD_INDEX_ADDR_HI, (index) >> 8)); */\
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_HI, (ULONG)((index) >> 8)); \
    P3RD_DELAY; \
}

#define P3RD_LOAD_DATA(data) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
    P3RD_DELAY; \
}

#define P3RD_LOAD_INDEX_REG(index, data) \
{ \
    P3RD_INDEX_REG(index);                            \
    /*VideoDebugPrint((0, "*(0x%x) <-- 0x%x\n", P3RD_INDEX_DATA, (data) & 0xff)); */\
    VideoPortWriteRegisterUlong(P3RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
    P3RD_DELAY; \
}

#define P3RD_READ_INDEX_REG(index, data) \
{ \
    P3RD_INDEX_REG(index);                            \
    data = VideoPortReadRegisterUlong(P3RD_INDEX_DATA) & 0xff;   \
    P3RD_DELAY; \
    /*VideoDebugPrint((0, "0x%x <-- *(0x%x)\n", data, P3RD_INDEX_DATA));*/ \
}

#define P3RD_LOAD_INDEX_REG_LO(index, data) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_LO, (ULONG)(index));  \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_INDEX_DATA,    (ULONG)(data));   \
    P3RD_DELAY; \
}

//
// Macros to load a given RGB triple into the P3RD palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use P3RD_PALETTE_START and multiple P3RD_LOAD_PALETTE calls to load
// a contiguous set of entries. Use P3RD_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//

#define P3RD_PALETTE_START_WR(index) \
{ \
    VideoPortWriteRegisterUlong(P3RD_PAL_WR_ADDR,     (ULONG)(index));    \
    P3RD_DELAY; \
}

#define P3RD_PALETTE_START_RD(index) \
{ \
    VideoPortWriteRegisterUlong(P3RD_PAL_RD_ADDR,     (ULONG)(index));    \
    P3RD_DELAY; \
}

#define P3RD_LOAD_PALETTE(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(red));      \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(green));    \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(blue));     \
    P3RD_DELAY; \
}

#define P3RD_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(P3RD_PAL_WR_ADDR, (ULONG)(index));    \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(red));      \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(green));    \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(blue));     \
    P3RD_DELAY; \
}

//
// Macro to read back a given RGB triple from the P3RD palette. Use after
// a call to P3RD_PALETTE_START_RD
//

#define P3RD_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR)(VideoPortReadRegisterUlong(P3RD_PAL_DATA) & 0xff);    \
    P3RD_DELAY; \
    green = (UCHAR)(VideoPortReadRegisterUlong(P3RD_PAL_DATA) & 0xff);    \
    P3RD_DELAY; \
    blue  = (UCHAR)(VideoPortReadRegisterUlong(P3RD_PAL_DATA) & 0xff);    \
    P3RD_DELAY; \
}

//
// Macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//

#define P3RD_SET_PIXEL_READMASK(mask) \
{ \
    VideoPortWriteRegisterUlong(P3RD_PIXEL_MASK,  (ULONG)(mask)); \
    P3RD_DELAY; \
}

#define P3RD_READ_PIXEL_READMASK(mask) \
{ \
    mask = VideoPortReadRegisterUlong(P3RD_PIXEL_MASK) & 0xff; \
}

//
// Macros to load values into the cursor array usage is
// P3RD_CURSOR_ARRAR_START() followed by n iterations of 
// P3RD_LOAD_CURSOR_ARRAY() or P3RD_READ_CURSOR_ARRAY()
//

#define P3RD_CURSOR_ARRAY_START(offset) \
{ \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_LO, (ULONG)(((offset)+P3RD_CURSOR_PATTERN_START) & 0xff));  \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_HI, (ULONG)(((offset)+P3RD_CURSOR_PATTERN_START) >> 8));    \
    P3RD_DELAY; \
}

#define P3RD_LOAD_CURSOR_ARRAY(data) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_DATA, (ULONG)(data)); \
    P3RD_DELAY; \
}

#define P3RD_READ_CURSOR_ARRAY(data) \
{ \
    data = VideoPortReadRegisterUlong(P3RD_INDEX_DATA) & 0xff; \
    P3RD_DELAY; \
}

#define P3RD_SET_CURSOR_MODE(data) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_LO, (ULONG)((P3RD_CURSOR_MODE) & 0xff)); \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_HI, (ULONG)((P3RD_CURSOR_MODE) >> 8)); \
    VideoPortWriteRegisterUlong(P3RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
}

//    
// Macro to move the cursor
//

#define P3RD_MOVE_CURSOR(x, y) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_HI, (ULONG)0);              \
    P3RD_DELAY; \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_X_LOW,       (ULONG)((x) & 0xff));   \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_X_HIGH,      (ULONG)((x) >> 8));     \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_Y_LOW,       (ULONG)((y) & 0xff));   \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_Y_HIGH,      (ULONG)((y) >> 8));     \
}

//    
// Macro to change the cursor hotspot
//

#define P3RD_CURSOR_HOTSPOT(x, y) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_HI,   (ULONG)(0)); \
    P3RD_DELAY; \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_HOTSPOT_X,  (ULONG)(x));    \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_HOTSPOT_Y,  (ULONG)(y));    \
}

//    
// Macro to change the cursor color
//

#define P3RD_CURSOR_COLOR(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_HI,   (ULONG)(0)); \
    P3RD_DELAY; \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_HOTSPOT_X,  (ULONG)(x));    \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_HOTSPOT_Y,  (ULONG)(y));    \
}

//
// Warning the Perm3 has an upside down cursor LUT, which means that
// items read from LUT entry 0 are actually read from entry 14.
// Therefore we have some macros to calculate the right value.
//

#define P3RD_REVERSE_LUT_INDEX    1
#if P3RD_REVERSE_LUT_INDEX
#define P3RD_CALCULATE_LUT_INDEX(x) (14 - x)
#else  
#define P3RD_CALCULATE_LUT_INDEX(x) (x)
#endif 

//    
// Check to see whether byte doubling is required. If, at 8BPP, any of the
// VESA horizontal parameters have the bottom bit set then we need to put
// the chip into 64-bit, byte-doubling mode.
//    

#define P3RD_CHECK_8BPP_NEED64BITDAC(VESATmgs)((BOOLEAN)((GetHtotFromVESA(VESATmgs) |   \
                                                          GetHssFromVESA(VESATmgs)  |   \
                                                          GetHseFromVESA(VESATmgs)  |   \
                                                          GetHbeFromVESA(VESATmgs)  ) & 0x1))

//    
// Check whether the current mode needs to be pixel doubled (i.e are we at
// 8BPP andwe fufill the above criteria.
//    

#define P3RD_CHECK_BYTE_DOUBLING(hwDeviceExtension,pixelDepth,VESATmgs)     \
                                 (pixelDepth <= 8 &&                        \
                                  P3RD_CHECK_8BPP_NEED64BITDAC(&VESATimings))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\mini\perm3dat.c ===
/**************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
*
*   perm3dat.c
*
* Abstract:
*
*  This module contains all the global data used by the Permedia3 driver.
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2001 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

#include "perm3.h"

//
// DATA STRUCTURES
// ===============
//

#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGEDATA")
#endif


//
//              RangeStart        RangeLength
//              |                 |      RangeInIoSpace
//              |                 |      |  RangeVisible
//        +-----+-----+           |      |  |  RangeShareable
//        |           |           |      |  |  |  RangePassive
//        v           v           v      v  v  v  v
VIDEO_ACCESS_RANGE Perm3LegacyResourceList[] = 
{
    {0x000C0000, 0x00000000, 0x00010000, 0, 0, 0, 0}, // ROM location
    {0x000A0000, 0x00000000, 0x00020000, 0, 0, 1, 0}, // Frame buffer
    {0x000003B0, 0x00000000, 0x0000000B, 1, 1, 1, 0}, // VGA regs
    {0x000003C0, 0x00000000, 0x0000001F, 1, 1, 1, 0}, // VGA regs
};

ULONG Perm3LegacyResourceEntries = sizeof Perm3LegacyResourceList / sizeof Perm3LegacyResourceList[0];

//
// Video mode table - Lists the information about each individual mode.
//
// Note that any new modes should be added here and to the appropriate
// PERM3_VIDEO_FREQUENCIES tables.
//

PERM3_VIDEO_MODES Perm3Modes[] = {
    {                   // 320x200x8bpp

      0x0201,           // 'Contiguous' Int 10 mode number (for high-colour)
      0x0201,           // 'Noncontiguous' Int 10 mode number
      320,              // 'Contiguous' screen stride
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          320,                            // X Resolution, in pixels
          200,                            // Y Resolution, in pixels
          320,                            // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          8,                              // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00000000,                     // Mask for Red Pixels in non-palette modes
          0x00000000,                     // Mask for Green Pixels in non-palette modes
          0x00000000,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
              VIDEO_MODE_MANAGED_PALETTE, // Mode description flags.
          0,                              // Video Memory Bitmap Width (filled
                                          // in later)
          0                               // Video Memory Bitmap Height (filled
                                          // in later)
        },
    },

    {                   // 320x240x8bpp

      0x0201,           // 'Contiguous' Int 10 mode number (for high-colour)
      0x0201,           // 'Noncontiguous' Int 10 mode number
      320,              // 'Contiguous' screen stride
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          320,                            // X Resolution, in pixels
          240,                            // Y Resolution, in pixels
          320,                            // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          8,                              // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00000000,                     // Mask for Red Pixels in non-palette modes
          0x00000000,                     // Mask for Green Pixels in non-palette modes
          0x00000000,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
              VIDEO_MODE_MANAGED_PALETTE, // Mode description flags.
          0,                              // Video Memory Bitmap Width (filled
                                          // in later)
          0                               // Video Memory Bitmap Height (filled
                                          // in later)
        },
    },

    {                   // 512x384x8bpp

      0x0201,           // 'Contiguous' Int 10 mode number (for high-colour)
      0x0201,           // 'Noncontiguous' Int 10 mode number
      512,              // 'Contiguous' screen stride
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          512,                            // X Resolution, in pixels
          384,                            // Y Resolution, in pixels
          512,                            // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          8,                              // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00000000,                     // Mask for Red Pixels in non-palette modes
          0x00000000,                     // Mask for Green Pixels in non-palette modes
          0x00000000,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
              VIDEO_MODE_MANAGED_PALETTE, // Mode description flags.
          0,                              // Video Memory Bitmap Width (filled
                                          // in later)
          0                               // Video Memory Bitmap Height (filled
                                          // in later)
        },
    },

    {                   // 640x400x8bpp

      0x0201,           // 'Contiguous' Int 10 mode number (for high-colour)
      0x0201,           // 'Noncontiguous' Int 10 mode number
      640,              // 'Contiguous' screen stride
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          640,                            // X Resolution, in pixels
          400,                            // Y Resolution, in pixels
          640,                            // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          8,                              // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00000000,                     // Mask for Red Pixels in non-palette modes
          0x00000000,                     // Mask for Green Pixels in non-palette modes
          0x00000000,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
              VIDEO_MODE_MANAGED_PALETTE, // Mode description flags.
          0,                              // Video Memory Bitmap Width (filled
                                          // in later)
          0                               // Video Memory Bitmap Height (filled
                                          // in later)
        },
    },

    {                   // 640x480x8bpp

      0x0201,           // 'Contiguous' Int 10 mode number (for high-colour)
      0x0201,           // 'Noncontiguous' Int 10 mode number
      640,              // 'Contiguous' screen stride
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          640,                            // X Resolution, in pixels
          480,                            // Y Resolution, in pixels
          640,                            // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          8,                              // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00000000,                     // Mask for Red Pixels in non-palette modes
          0x00000000,                     // Mask for Green Pixels in non-palette modes
          0x00000000,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
              VIDEO_MODE_MANAGED_PALETTE, // Mode description flags.
          0,                              // Video Memory Bitmap Width (filled
                                          // in later)
          0                               // Video Memory Bitmap Height (filled
                                          // in later)
        },
    },

    {                           // 800x600x8bpp
      0x0103,
      0x0203,
      800,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          800,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 1024x768x8bpp
      0x0205,
      0x0205,
      1024,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          1024,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 1152x864x8bpp
      0x0207,
      0x0207,
      1152,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          864,
          1152,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 1280x800x8bpp
      0x0207,
      0x0207,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          800,
          1280,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 1280x960x8bpp
      0x0207,
      0x0207,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          960,
          1280,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 1280x1024x8bpp
      0x0107,
      0x0107,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          1280,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 1600x1000x8bpp
      0x0120,
      0x0120,
      1600,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1000,
          1600,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 1600x1024x8bpp
      0x0120,
      0x0120,
      1600,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1024,
          1600,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 1600x1200x8bpp
      0x0120,
      0x0120,
      1600,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          1600,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 1920x1080x8bpp
      0x0120,
      0x0120,
      1920,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1920,
          1080,
          1920,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 1920x1200x8bpp
      0x0120,
      0x0120,
      1920,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1920,
          1200,
          1920,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 320x200x16bpp
      0x0111,
      0x0211,
      640,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          320,
          200,
          640,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 320x240x16bpp
      0x0111,
      0x0211,
      640,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          320,
          240,
          640,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 512x384x16bpp
      0x0111,
      0x0211,
      1024,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          512,
          384,
          1024,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 640x400x16bpp
      0x0111,
      0x0211,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          400,
          1280,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 640x480x16bpp
      0x0111,
      0x0211,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          480,
          1280,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 800x600x16bpp
      0x0114,
      0x0214,
      1600,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          1600,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1024x768x16bpp
      0x0117,
      0x0117,
      2048,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          2048,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1152x864x16bpp
      0x0118,
      0x0222,
      2304,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          864,
          2304,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1280x800x16bpp
      0x011A,
      0x021A,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          800,
          2560,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1280x960x16bpp
      0x011A,
      0x021A,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          960,
          2560,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1280x1024x16bpp
      0x011A,
      0x021A,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          2560,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1600x1000x16bpp
      0x0121,
      0x0121,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1000,
          3200,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1600x1024x16bpp
      0x0121,
      0x0121,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1024,
          3200,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1600x1200x16bpp
      0x0121,
      0x0121,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          3200,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1920x1080x16bpp
      0x0121,
      0x0121,
      3840,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1920,
          1080,
          3840,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1920x1200x16bpp
      0x0121,
      0x0121,
      3840,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1920,
          1200,
          3840,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 320x200x15bpp
      0x0111,
      0x0211,
      640,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          320,
          200,
          640,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 320x240x15bpp
      0x0111,
      0x0211,
      640,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          320,
          240,
          640,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 512x384x15bpp
      0x0111,
      0x0211,
      1024,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          512,
          384,
          1024,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 640x400x15bpp
      0x0111,
      0x0211,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          400,
          1280,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 640x480x15bpp
      0x0111,
      0x0211,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          480,
          1280,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 800x600x15bpp
      0x0114,
      0x0214,
      1600,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          1600,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1024x768x15bpp
      0x0117,
      0x0117,
      2048,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          2048,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1152x864x15bpp
      0x0118,
      0x0222,
      2304,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          864,
          2304,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1280x800x15bpp
      0x011A,
      0x021A,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          800,
          2560,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1280x960x15bpp
      0x011A,
      0x021A,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          960,
          2560,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1280x1024x15bpp
      0x011A,
      0x021A,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          2560,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1600x1000x15bpp
      0x0121,
      0x0121,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1000,
          3200,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1600x1024x15bpp
      0x0121,
      0x0121,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1024,
          3200,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1600x1200x15bpp
      0x0121,
      0x0121,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          3200,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1920x1080x15bpp
      0x0121,
      0x0121,
      3840,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1920,
          1080,
          3840,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1920x1200x15bpp
      0x0121,
      0x0121,
      3840,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1920,
          1200,
          3840,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 640x480x12bpp
      0x0112,
      0x0220,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          480,
          2560,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,   // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 800x600x12bpp
      0x0115,
      0x0221,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          3200,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,   // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1024x768x12bpp
      0x0118,
      0x0222,
      4096,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          4096,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,   // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1152x864x12bpp
      0x0118,
      0x0222,
      4608,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          864,
          4608,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,   // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

     {                   // 1280x960x12bpp
      0x011B,
      0x011B,
      5120,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          960,
          5120,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,   // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1280x1024x12bpp
      0x011B,
      0x011B,
      5120,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          5120,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,   // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1600x1200x12bpp
      0x0122,
      0x0122,
      6400,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          6400,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,   // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1920x1080x12bpp
      0x0122,
      0x0122,
      7680,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1920,
          1080,
          7680,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,   // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 320x200x32bpp
      0x0112,
      0x0220,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          320,
          200,
          1280,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 320x240x32bpp
      0x0112,
      0x0220,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          320,
          240,
          1280,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 512x384x32bpp
      0x0112,
      0x0220,
      2048,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          512,
          384,
          2048,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 640x400x32bpp
      0x0112,
      0x0220,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          400,
          2560,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 640x480x32bpp
      0x0112,
      0x0220,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          480,
          2560,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 800x600x32bpp
      0x0115,
      0x0221,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          3200,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1024x768x32bpp
      0x0118,
      0x0222,
      4096,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          4096,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1152x864x32bpp
      0x0118,
      0x0222,
      4608,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          864,
          4608,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1280x800x32bpp
      0x011B,
      0x011B,
      5120,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          800,
          5120,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1280x960x32bpp
      0x011B,
      0x011B,
      5120,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          960,
          5120,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1280x1024x32bpp
      0x011B,
      0x011B,
      5120,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          5120,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1600x1000x32bpp
      0x0122,
      0x0122,
      6400,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1000,
          6400,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1600x1024x32bpp
      0x0122,
      0x0122,
      6400,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1024,
          6400,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1600x1200x32bpp
      0x0122,
      0x0122,
      6400,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          6400,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1920x1080x32bpp
      0x0122,
      0x0122,
      7680,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1920,
          1080,
          7680,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1920x1200x32bpp
      0x0122,
      0x0122,
      7680,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1920,
          1200,
          7680,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                                     // 640x480x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      1920,                               // 'Contiguous' screen stride (640 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          640,                            // X Resolution, in pixels
          480,                            // Y Resolution, in pixels
          1920,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },

    {                                     // 800x600x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      2400,                               // 'Contiguous' screen stride (800 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          800,                            // X Resolution, in pixels
          600,                            // Y Resolution, in pixels
          2400,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },

    {                                     // 1024x768x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      3072,                               // 'Contiguous' screen stride (1024 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          1024,                           // X Resolution, in pixels
          768,                            // Y Resolution, in pixels
          3072,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },

    {                                     // 1152x864x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      3456,                               // 'Contiguous' screen stride (1152 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          1152,                           // X Resolution, in pixels
          864,                            // Y Resolution, in pixels
          3072,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },

    {                                     // 1280x1024x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      3840,                               // 'Contiguous' screen stride (1280 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          3840,                           // X Resolution, in pixels
          1280,                           // Y Resolution, in pixels
          1024,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },

    {                                     // 1600x1200x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      4800,                               // 'Contiguous' screen stride (1600 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          1600,                           // X Resolution, in pixels
          1280,                           // Y Resolution, in pixels
          4800,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },
};

const ULONG NumPerm3VideoModes = sizeof(Perm3Modes) / sizeof(Perm3Modes[0]);

ULONG Perm3DepthList [] = { 8, 15, 16, 24, 32 };

#define Perm3DepthCnt (sizeof(Perm3DepthList) / sizeof(Perm3DepthList[0]))

/*+++

    Data format is:
        Horizontal total time (chars)
        Horizontal right border + front porch (chars)
        Horizontal sync time (chars)
        Horizontal back porch + left border (chars)
        Horizontal sync polarity

        Vertical total time (lines)
        Vertical bottom border + front porch (lines)
        Vertical sync time (lines)
        Vertical back porch + top border (lines)
        Vertical sync polarity

        Pixel clock
---*/

#define NEG        0
#define POS        1

//
// This is our hybrid of DMTF modes and GTF modes which we call the 'VESA' 
// mode list:
//

TIMING_INFO VESA_LIST[] =
{

//  The first entry in the list must be 640x480x60 as this is the mode Windows
//  defaults to when it has somehow been set to an invalid or non-existant mode.

    {{ 640, 480, 60},    { 100,  2, 12,  6, NEG,  525,10, 2, 33, NEG,  251750}},    // DMTF

//  Don't bother for now.
//  {{ 640, 480, 72},    { 104,  3,  5, 16, NEG,  520, 9, 3, 28, NEG,  315000}},    // DMTF

    {{ 640, 480, 75},    { 105,  2,  8, 15, NEG,  500, 1, 3, 16, NEG,  315000}},    // DMTF
    {{ 640, 480, 85},    { 104,  7,  7, 10, NEG,  509, 1, 3, 25, NEG,  360000}},    // DMTF
    {{ 640, 480,100},    { 106,  5,  8, 13, NEG,  509, 1, 3, 25, NEG,  431630}},    // GTF

//           <--320 x 400-->      <--320 x 200-->     <320x400/2>
//  320x200x60 has an fH of 25kHz which is too slow for most monitors
//  {{ 320, 200, 60},    {  48,  0,  4,  4, NEG,  208, 1, 3,  4, POS,   47810}},    // GTF (hybrid of 320 x 400)
    {{ 320, 200, 75},    {  50,  1,  4,  5, NEG,  210, 1, 3,  6, POS,   62700}},    // GTF (hybrid of 320 x 400)
//  {{ 320, 200, 85},    {  52,  2,  4,  6, NEG,  211, 1, 3,  7, POS,   74435}},    // GTF (hybrid of 320 x 400)
//  {{ 320, 200,100},    {  52,  2,  4,  6, NEG,  213, 1, 3,  9, POS,   88190}},    // GTF (hybrid of 320 x 400)

//  {{ 320, 240, 60},    {  50,  1,  4,  5, NEG,  249, 1, 3,  5, POS,   59640}},    // GTF (hybrid of 320 x 480)
    {{ 320, 240, 75},    {  52,  2,  4,  6, NEG,  251, 1, 3,  7, POS,   78310}},    // GTF (hybrid of 320 x 480)
//  {{ 320, 240, 85},    {  52,  2,  4,  6, NEG,  253, 1, 3,  9, POS,   89285}},    // GTF (hybrid of 320 x 480)
//  {{ 320, 240,100},    {  52,  2,  4,  6, NEG,  255, 1, 3, 11, POS,  105870}},    // GTF (hybrid of 320 x 480)

//  DX does not work as these require a screen stride.
//  {{ 400, 300, 60},    {  64,  2,  5,  7, NEG,  311, 1, 3,  7, POS,   86580}},    // GTF (hybrid of 400 x 600)
//  {{ 400, 300, 75},    {  66,  3,  5,  8, NEG,  314, 1, 3, 10, POS,  113040}},    // GTF (hybrid of 400 x 600)
//  {{ 400, 300, 85},    {  66,  3,  5,  8, NEG,  316, 1, 3, 12, POS,  133230}},    // GTF (hybrid of 400 x 600)
//  {{ 400, 300,100},    {  66,  3,  5,  8, NEG,  319, 1, 3, 15, POS,  158220}},    // GTF (hybrid of 400 x 600)

//  512x384x60 has an fH of 24kHz which is too slow for most monitors
//  {{ 512, 384, 60},    {  78,  1,  6,  7, NEG,  398, 1, 3, 10, POS,  149010}},    // GTF
    {{ 512, 384, 75},    {  80,  2,  6,  8, NEG,  402, 1, 3, 14, POS,  192960}},    // GTF
//  {{ 512, 384, 85},    {  82,  2,  7,  9, NEG,  404, 1, 3, 16, POS,  225270}},    // GTF
//  {{ 512, 384,100},    {  82,  2,  7,  9, NEG,  407, 1, 3, 19, POS,  266990}},    // GTF

//  Don't bother for now.
//  {{ 640, 350, 85},    { 104,  4,  8, 12, POS,  445,32, 3, 60, NEG,  315000}},    // DMTF

//  {{ 640, 400, 60},    {  98,  1,  8,  9, NEG,  415, 1, 3, 11, POS,  195220}},    // GTF
    {{ 640, 400, 75},    { 100,  2,  8, 10, NEG,  418, 1, 3, 14, POS,  250800}},    // GTF
//  {{ 640, 400, 85},    { 104,  4,  8, 12, NEG,  445, 1, 3, 41, POS,  315000}},    // DMTF
//  {{ 640, 400,100},    { 104,  4,  8, 12, NEG,  424, 1, 3, 20, POS,  352770}},    // GTF

//  DX does not work as this requires a screen stride.
//  {{ 720, 400, 85},    { 104,  4,  8, 12, NEG,  446, 1, 3, 42, POS,  355000}},    // DMTF

//  Don't bother for now.
//  {{ 800, 600, 56},    { 128,  3,  9, 16, POS,  625, 1, 2, 22, POS,  360000}},    // DMTF
    {{ 800, 600, 60},    { 132,  5, 16, 11, POS,  628, 1, 4, 23, POS,  400000}},    // DMTF
//  {{ 800, 600, 72},    { 130,  7, 15,  8, POS,  666,37, 6, 23, POS,  500000}},    // DMTF
    {{ 800, 600, 75},    { 132,  2, 10, 20, POS,  625, 1, 3, 21, POS,  495000}},    // DMTF
    {{ 800, 600, 85},    { 131,  4,  8, 19, POS,  631, 1, 3, 27, POS,  562500}},    // DMTF
    {{ 800, 600,100},    { 134,  6, 11, 17, NEG,  636, 1, 3, 32, POS,  681790}},    // GTF

//  DX does not work as these require a screen stride.
//  {{ 856, 480, 60},    { 133,  2, 11, 13, NEG,  497, 1, 3, 13, POS,  317280}},    // GTF
//  {{ 856, 480, 75},    { 137,  4, 11, 15, NEG,  502, 1, 3, 18, POS,  412640}},    // GTF
//  {{ 856, 480, 85},    { 139,  5, 11, 16, NEG,  505, 1, 3, 21, POS,  477330}},    // GTF
//  {{ 856, 480,100},    { 141,  6, 11, 17, NEG,  509, 1, 3, 25, POS,  574150}},    // GTF

    {{1024, 768, 60},    { 168,  3, 17, 20, NEG,  806, 3, 6, 29, NEG,  650000}},    // DMTF
//  Don't bother for now.
//  {{1024, 768, 70},    { 166,  3, 17, 18, NEG,  806, 3, 6, 29, NEG,  750000}},    // DMTF
    {{1024, 768, 75},    { 164,  2, 12, 22, POS,  800, 1, 3, 28, POS,  787500}},    // DMTF
    {{1024, 768, 85},    { 172,  6, 12, 26, POS,  808, 1, 3, 36, POS,  945000}},    // DMTF
    {{1024, 768,100},    { 174,  9, 14, 23, NEG,  814, 1, 3, 42, POS, 1133090}},    // GTF
    {{1024, 768,120},    { 176, 10, 14, 24, NEG,  823, 1, 3, 51, POS, 1390540}},    // GTF

    {{1152, 864, 60},    { 190,  8, 15, 23, NEG,  895, 1, 3, 27, POS,  816240}},    // GTF
    {{1152, 864, 75},    { 200,  8, 16, 32, POS,  900, 1, 3, 32, POS, 1080000}},    // DMTF
    {{1152, 864, 85},    { 194,  9, 16, 25, NEG,  907, 1, 3, 39, POS, 1196510}},    // GTF
    {{1152, 864,100},    { 196, 10, 16, 26, NEG,  915, 1, 3, 47, POS, 1434720}},    // GTF
    {{1152, 864,120},    { 198, 11, 16, 27, NEG,  926, 1, 3, 58, POS, 1760140}},    // GTF

    {{1280, 960, 60},    { 225, 12, 14, 39, POS, 1000, 1, 3, 36, POS, 1080000}},    // DMTF
    {{1280, 960, 75},    { 216, 11, 17, 28, NEG, 1002, 1, 3, 38, POS, 1298590}},    // GTF
    {{1280, 960, 85},    { 216,  8, 20, 28, POS, 1011, 1, 3, 47, POS, 1485000}},    // DMTF
    {{1280, 960,100},    { 220, 12, 18, 30, NEG, 1017, 1, 3, 53, POS, 1789920}},    // GTF
    {{1280, 960,120},    { 220, 12, 18, 30, NEG, 1029, 1, 3, 65, POS, 2173250}},    // GTF

    {{1280,1024, 60},    { 211,  6, 14, 31, POS, 1066, 1, 3, 38, POS, 1080000}},    // DMTF
    {{1280,1024, 75},    { 211,  2, 18, 31, POS, 1066, 1, 3, 38, POS, 1350000}},    // DMTF
    {{1280,1024, 85},    { 216,  8, 20, 28, POS, 1072, 1, 3, 44, POS, 1575000}},    // DMTF
    {{1280,1024,100},    { 220, 12, 18, 30, NEG, 1085, 1, 3, 57, POS, 1909600}},    // GTF
    {{1280,1024,120},    { 222, 13, 18, 31, NEG, 1097, 1, 3, 69, POS, 2337930}},    // GTF

    {{1600,1200, 60},    { 270,  8, 24, 38, POS, 1250, 1, 3, 46, POS, 1620000}},    // DMTF
//  Don't bother for now.
//  {{1600,1200, 65},    { 270,  8, 24, 38, POS, 1250, 1, 3, 46, POS, 1755000}},    // DMTF
//  {{1600,1200, 70},    { 270,  8, 24, 38, POS, 1250, 1, 3, 46, POS, 1890000}},    // DMTF
    {{1600,1200, 75},    { 270,  8, 24, 38, POS, 1250, 1, 3, 46, POS, 2025000}},    // DMTF
    {{1600,1200, 85},    { 270,  8, 24, 38, POS, 1250, 1, 3, 46, POS, 2295000}},    // DMTF
    {{1600,1200,100},    { 276, 16, 22, 38, NEG, 1271, 1, 3, 67, POS, 2806370}},    // GTF

    {{1920,1080, 60},    { 322, 15, 26, 41, NEG, 1118, 1, 3, 34, POS, 1727980}},    // GTF
    {{1920,1080, 75},    { 326, 17, 26, 43, NEG, 1128, 1, 3, 44, POS, 2206370}},    // GTF
    {{1920,1080, 85},    { 328, 18, 26, 44, NEG, 1134, 1, 3, 50, POS, 2529270}},    // GTF
    {{1920,1080,100},    { 330, 19, 26, 45, NEG, 1144, 1, 3, 60, POS, 3020160}},    // GTF

    {{1920,1200, 60},    { 324, 16, 26, 42, NEG, 1242, 1, 3, 38, POS, 1931560}},    // GTF
    {{1920,1200, 75},    { 328, 18, 26, 44, NEG, 1253, 1, 3, 49, POS, 2465900}},    // GTF
    {{1920,1200, 85},    { 330, 19, 26, 45, NEG, 1260, 1, 3, 56, POS, 2827440}},    // GTF
    {{1920,1200,100},    { 332, 19, 27, 46, NEG, 1271, 1, 3, 67, POS, 3375780}},    // GTF
};

TIMING_INFO SGIDFP_LIST[] =
{
    {{1600,1024, 60},    { 302, 30, 24, 48, POS, 1067, 3, 3, 37, POS, 1069100}},
};

#undef NEG
#undef POS

#define VESA_COUNT      (sizeof(VESA_LIST) / sizeof(VESA_LIST[0]))
#define SGIDFP_COUNT   (sizeof(SGIDFP_LIST) / sizeof(SGIDFP_LIST[0]))

#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif


//
// THE CODE
// ========
//

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,GetVideoTiming)
#pragma alloc_text(PAGE,CopyMonitorTimings)
#pragma alloc_text(PAGE,GrowTimingList)
#pragma alloc_text(PAGE,testExtendRanges)
#pragma alloc_text(PAGE,BuildFrequencyList)
#pragma alloc_text(PAGE,BuildFrequencyListForSGIDFP)
#pragma alloc_text(PAGE,BuildFrequencyListFromVESA)
#endif // ALLOC_PRAGMA

BOOLEAN 
GetVideoTiming( 
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    ULONG xRes, 
    ULONG yRes, 
    ULONG Freq, 
    ULONG Depth,
    VESA_TIMING_STANDARD *VESATimings
    ) 

/*+++

Routine Description:

    Given a width, height and frequency this function will return a 
    VESA timing information.

    The information is extracted from the VESA_LIST.

---*/

{
    TIMING_INFO *list = hwDeviceExtension->monitorInfo.timingList;
    ULONG count = hwDeviceExtension->monitorInfo.timingNum;
    ULONG i;
    BOOLEAN retVal;

    retVal = FALSE; 

    //
    // Loop through the table looking for a match
    //

    for( i = 0; !retVal && (i < count); i++ ) {

        //
        // Comparewidth, height and frequency
        //

        if( list[i].basic.width == xRes  &&
            list[i].basic.height == yRes &&
            list[i].basic.refresh == Freq ) {

            //
            // We got a match
            //

            *VESATimings = list[i].vesa;

            retVal = TRUE;
        }
    }

    //
    // Fix up pixel clock, just in case it hasn't been set
    //

    if (retVal && VESATimings->pClk == 0) {

        VideoDebugPrint((0, "Perm3: Pixel clock is zero - recalculating!"));

        VESATimings->pClk = 
            (8 * VESATimings->HTot * VESATimings->VTot * Freq) / 100;
    }

    return retVal;
}


BOOLEAN
CopyMonitorTimings( 
    PVOID HwDeviceExtension,
    MONITOR_INFO *srcMI, 
    MONITOR_INFO *mi 
    ) 
{
    ULONG i, j, k;
    VP_STATUS status;

    if( mi->timingList ) {

        VideoPortReleaseBuffer(HwDeviceExtension, mi->timingList);
        mi->timingList = NULL;
    }

    if( mi->frequencyTable ) {

        VideoPortReleaseBuffer(HwDeviceExtension, mi->frequencyTable);
        mi->frequencyTable = NULL;
    }

    *mi = *srcMI;

    status = VideoPortAllocateBuffer(HwDeviceExtension, 
                                     sizeof(*mi->timingList ) * (mi->timingNum + 1),
                                     &(mi->timingList));

    if (status != NO_ERROR) {
        return FALSE;
    }
   
    status = VideoPortAllocateBuffer(HwDeviceExtension, 
                                     sizeof(*mi->frequencyTable) * 
                                     (mi->timingNum + 1) * Perm3DepthCnt, 
                                     &(mi->frequencyTable));

    if (status != NO_ERROR) {

        VideoPortReleaseBuffer(HwDeviceExtension, mi->timingList);
        mi->timingList = NULL;
        return FALSE;
    }

    VideoPortZeroMemory(mi->frequencyTable, 
                        sizeof(*mi->frequencyTable) * (mi->timingNum + 1) * Perm3DepthCnt );

    mi->timingMax = mi->timingNum;

    for( i = k = 0; i < mi->timingNum; i++ ) {

        mi->timingList[i] = srcMI->timingList[i];
        
        for( j = 0; j < Perm3DepthCnt; j++, k++ ) {
	
            mi->frequencyTable[k].BitsPerPel      = Perm3DepthList[j];
            mi->frequencyTable[k].ScreenWidth     = mi->timingList[i].basic.width;
            mi->frequencyTable[k].ScreenHeight    = mi->timingList[i].basic.height;
            mi->frequencyTable[k].ScreenFrequency = mi->timingList[i].basic.refresh;
            mi->frequencyTable[k].PixelClock      = mi->timingList[i].vesa.pClk;
        }
    }

    //
    // Ensure the lists are terminted
    //

    mi->frequencyTable[k].BitsPerPel = 0;
    mi->timingList[i].basic.width = 0;
    return TRUE;
}

BOOLEAN 
GrowTimingList( 
    PVOID HwDeviceExtension,
    MONITOR_INFO *mi 
    ) 
{

    ULONG newSize = mi->timingNum + 100;
    TIMING_INFO *newList;
    VP_STATUS status;

    status = VideoPortAllocateBuffer(HwDeviceExtension, 
                                     sizeof(*newList) * newSize, 
                                     &(newList));

    if (status != NO_ERROR) {
        return FALSE;
    }

    VideoPortZeroMemory( newList, sizeof(*newList) * newSize );
    VideoPortMoveMemory( newList, mi->timingList, sizeof(*newList) * mi->timingNum );

    if( mi->timingList )
        VideoPortReleaseBuffer( HwDeviceExtension, mi->timingList );

    mi->timingList = newList;
    mi->timingMax = newSize;
    return TRUE;
}

VOID 
testExtendRanges( 
    MONITOR_INFO *mi, 
    TIMING_INFO *ti, 
    FREQUENCIES *freq 
    ) 
{

    if( mi->flags & MI_FLAGS_FUDGED_VH ) {

        if( freq->fH > mi->fhMax )
            mi->fhMax = freq->fH;
        if( freq->fH < mi->fhMin )
            mi->fhMin = freq->fH;

        if( freq->fV > mi->fvMax )
            mi->fvMax = freq->fV;
        if( freq->fV < mi->fvMin )
            mi->fvMin = freq->fV;
    }

    if( mi->flags & MI_FLAGS_FUDGED_PCLK ) {

        if( freq->pClk < mi->pClkMin ) {
            mi->pClkMin = freq->pClk;
        }

        if( freq->pClk > mi->pClkMax ) {
            mi->pClkMax = freq->pClk;
        }
    }

    if( mi->flags & MI_FLAGS_FUDGED_XY ) {

        if( ti->basic.width < mi->xMin ) {
            mi->xMin = ti->basic.width;
        }

        if( ti->basic.width > mi->xMax ) {
            mi->xMax = ti->basic.width;
        }

        if( ti->basic.height < mi->yMin ) {
            mi->yMin = ti->basic.height;
        }

        if( ti->basic.height > mi->yMax ) {
            mi->yMax = ti->basic.height;
        }
    }
}


BOOLEAN 
BuildFrequencyList( 
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    MONITOR_INFO *mi 
    ) 
{

    MONITOR_INFO newMI;
    ULONG i, j, k;
    BOOLEAN bRet = FALSE;
    BOOLEAN bRet1;
    UCHAR EdidBuffer[256];

    VideoPortZeroMemory(&newMI, sizeof(newMI));

    newMI.flags = mi->flags;
    newMI.flags |= ( MI_FLAGS_FUDGED_VH | 
                     MI_FLAGS_FUDGED_PCLK | 
                     MI_FLAGS_FUDGED_XY);

    newMI.fhMin   = 0xFFFFFFFF;    
    newMI.fhMax   = 0;
    newMI.fvMin   = 0xFFFFFFFF;  
    newMI.fvMax   = 0;
    newMI.pClkMin = 0xFFFFFFFF;   
    newMI.pClkMax = 0;
    newMI.xMin    = 0xFFFFFFFF;    
    newMI.xMax    = 0;
    newMI.yMin    = 0xFFFFFFFF;    
    newMI.yMax    = 0;

    if ((hwDeviceExtension->deviceInfo.SubsystemId == 
                            SUBDEVICEID_P3_VX1_1600SW) &&
        GetDFPEdid(hwDeviceExtension, EdidBuffer, sizeof(EdidBuffer))) {

        bRet1 = BuildFrequencyListForSGIDFP(&newMI, 
                                            hwDeviceExtension);
    } else {

        bRet1 = BuildFrequencyListFromVESA(&newMI, 
                                          hwDeviceExtension);
    }

    if (bRet1) {

        //
        // Copy the lists about:
        //

        if(CopyMonitorTimings((PVOID)hwDeviceExtension, &newMI, mi))
            bRet = TRUE;
    }

    if(newMI.timingList) {

        VideoPortReleaseBuffer((PVOID)hwDeviceExtension, newMI.timingList);
        newMI.timingList = NULL;
    }

    return bRet;
}

BOOLEAN 
BuildFrequencyListFromVESA( 
    MONITOR_INFO *mi, 
    PHW_DEVICE_EXTENSION hwDeviceExtension 
    ) 
{
    ULONG realCount = VESA_COUNT;
    TIMING_INFO *realList = VESA_LIST;
    TIMING_INFO *ti;
    FREQUENCIES freq;

    //
    // loop through the list of resolutions
    //

    for( mi->timingNum = 0; mi->timingNum < realCount; mi->timingNum++ ) {

        if( mi->timingNum >= mi->timingMax ) {

            if(!GrowTimingList((PVOID)hwDeviceExtension, mi)) {
                return FALSE;
            }
        }

        ti = &mi->timingList[mi->timingNum];

        *ti = realList[mi->timingNum];

        if( !ti->vesa.pClk ) {
            ti->vesa.pClk = ((ti->vesa.HTot * ti->vesa.VTot * 8) / 100) * ti->basic.refresh;
        }

        freq.pClk = ti->vesa.pClk;
        freq.fH = (freq.pClk * 100) / (ti->vesa.HTot * 8);
        freq.fV = (freq.pClk * 100) / (ti->vesa.HTot * ti->vesa.VTot * 8);
        testExtendRanges( mi, ti, &freq );
    }

    return TRUE;
}


BOOLEAN 
BuildFrequencyListForSGIDFP( 
    MONITOR_INFO *mi, 
    PHW_DEVICE_EXTENSION hwDeviceExtension 
    ) 
{
    ULONG realCount = SGIDFP_COUNT;
    TIMING_INFO *realList = SGIDFP_LIST;
    TIMING_INFO *ti;
    FREQUENCIES freq;

    //
    // Loop through the list of resolutions
    //

    for( mi->timingNum = 0; mi->timingNum < realCount; mi->timingNum++ ) {

        if( mi->timingNum >= mi->timingMax ) {

            if(!GrowTimingList((PVOID)hwDeviceExtension, mi)) {
                return FALSE;
            }
        }

        ti = &mi->timingList[mi->timingNum];

        *ti = realList[mi->timingNum];

        if( !ti->vesa.pClk ) {

            ti->vesa.pClk = ((ti->vesa.HTot * ti->vesa.VTot * 8) / 100) * ti->basic.refresh;
        }

        freq.pClk = ti->vesa.pClk;
        freq.fH = (freq.pClk * 100) / (ti->vesa.HTot * 8);
        freq.fV = (freq.pClk * 100) / (ti->vesa.HTot * ti->vesa.VTot * 8);
        testExtendRanges( mi, ti, &freq );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\mini\perm3io.c ===
/***************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
*
*   perm3io.c
*
* Abstract:
*
*   This module contains the code that implements the Permedia 3 miniport 
*   driver
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2001 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

#include "perm3.h"

#pragma alloc_text(PAGE,Perm3StartIO)
#pragma alloc_text(PAGE,Perm3RetrieveGammaCallback)
#pragma alloc_text(PAGE,SetCurrentVideoMode)
#pragma alloc_text(PAGE,Perm3SetColorLookup)
#pragma alloc_text(PAGE,Perm3GetClockSpeeds)
#pragma alloc_text(PAGE,ZeroMemAndDac)
#pragma alloc_text(PAGE,ReadChipClockSpeedFromROM)

BOOLEAN
Perm3StartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )

/*+++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    accepts a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension
        Supplies a pointer to the miniport's device extension.

    RequestPacket 
        Pointer to the video request packet. This structure contains all 
        the parameters originally passed to EngDeviceIoControl.

Return Value:

    Return TRUE indicating that it has completed the request.

---*/

{
    VP_STATUS status;
    ULONG inIoSpace;
    PVIDEO_MODE_INFORMATION modeInformation;
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    PVIDEO_CLUT clutBuffer;
    ULONG RequestedMode;
    ULONG modeNumber;
    ULONG ulValue;
    PVIDEOPARAMETERS pVideoParams;
    HANDLE ProcessHandle;
    PPERM3_VIDEO_MODES ModeEntry;
    PERM3_VIDEO_FREQUENCIES FrequencyEntry;
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;

    //
    // Switch on the IoContolCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //

    switch (RequestPacket->IoControlCode) {

        case IOCTL_VIDEO_QUERY_REGISTRY_DWORD:

            VideoDebugPrint((3, "Perm3: got IOCTL_VIDEO_QUERY_REGISTRY_DWORD\n"));

            if ( RequestPacket->OutputBufferLength <
                 (RequestPacket->StatusBlock->Information = sizeof(ULONG))) {

                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                                    RequestPacket->InputBuffer,
                                                    FALSE,
                                                    Perm3RegistryCallback,
                                                    &ulValue );
            if (status != NO_ERROR) {

                VideoDebugPrint((1, "Perm3: Reading registry entry %S failed\n", 
                                     RequestPacket->InputBuffer));

                status = ERROR_INVALID_PARAMETER;
                break;
            }

            *(PULONG)(RequestPacket->OutputBuffer) = ulValue;
            break;

        case IOCTL_VIDEO_REG_SAVE_GAMMA_LUT:

            VideoDebugPrint((3, "Perm3: got IOCTL_VIDEO_REG_SAVE_GAMMA_LUT\n"));

            if ( RequestPacket->InputBufferLength <
                 (RequestPacket->StatusBlock->Information = MAX_CLUT_SIZE)) {

                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
        
            status = VideoPortSetRegistryParameters(HwDeviceExtension,
                                                    L"DisplayGammaLUT",
                                                    RequestPacket->InputBuffer,
                                                    MAX_CLUT_SIZE);

            if (status != NO_ERROR) {

                VideoDebugPrint((0, "Perm3: VideoPortSetRegistryParameters failed to save gamma LUT\n"));
            }

            break;


        case IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT:

            VideoDebugPrint((3, "Perm3: got IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT\n"));

            if ( RequestPacket->OutputBufferLength <
                 (RequestPacket->StatusBlock->Information = MAX_CLUT_SIZE)) {
               
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
        
            status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                                    L"DisplayGammaLUT",
                                                    FALSE,
                                                    Perm3RetrieveGammaCallback,
                                                    RequestPacket->InputBuffer);

            if (status != NO_ERROR) {

                VideoDebugPrint((0, "Perm3: VideoPortGetRegistryParameters failed to retrieve gamma LUT\n"));
            }

            break;

        case IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF:

            {
                PPERM3_INTERRUPT_CTRLBUF pIntrCtrl;
    
                VideoDebugPrint((3, "Perm3: got IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF\n"));

                if (RequestPacket->OutputBufferLength <
                    (RequestPacket->StatusBlock->Information = sizeof(PVOID))) {

                    status = ERROR_INSUFFICIENT_BUFFER;
                    break;
                }

                pIntrCtrl = &hwDeviceExtension->InterruptControl;

                if (!(hwDeviceExtension->Capabilities & CAPS_INTERRUPTS)) {

                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                //
                // display driver is in kernel so our address is valid
                //

                *(PVOID*)RequestPacket->OutputBuffer = &pIntrCtrl->ControlBlock;

                status = NO_ERROR;
                break;
            }

        case IOCTL_VIDEO_QUERY_DEVICE_INFO:
  
            VideoDebugPrint((3, "Perm3: QUERY_deviceInfo\n"));

            if ( RequestPacket->OutputBufferLength != 
                 (RequestPacket->StatusBlock->Information = sizeof(Perm3_Device_Info))) {

                VideoDebugPrint((0, "Perm3: the requested size of device info is wrong!\n"));
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            //
            // Copy our local PCI info to the output buffer
            //

            VideoPortMoveMemory( RequestPacket->OutputBuffer, 
                                 &hwDeviceExtension->deviceInfo, 
                                 sizeof(Perm3_Device_Info) );

            status = NO_ERROR;
            break;

        case IOCTL_VIDEO_MAP_VIDEO_MEMORY:
  
            VideoDebugPrint((3, "Perm3: MapVideoMemory\n"));

            if ( (RequestPacket->OutputBufferLength <
                 (RequestPacket->StatusBlock->Information =
                                     sizeof(VIDEO_MEMORY_INFORMATION))) ||
                 (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) ) {

                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            memoryInformation = RequestPacket->OutputBuffer;

            memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
                    (RequestPacket->InputBuffer))->RequestedVirtualAddress;

            memoryInformation->VideoRamLength = 
                    hwDeviceExtension->FrameLength;

            inIoSpace = hwDeviceExtension->PhysicalFrameIoSpace;

            //
            // Performance:
            //
            // Enable USWC on the P6 processor.
            //
            // We only do it for the frame buffer. Memory mapped registers
            // usually can not be mapped USWC 
            //

            inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;

            status = VideoPortMapMemory(HwDeviceExtension,
                                        hwDeviceExtension->PhysicalFrameAddress,
                                        &(memoryInformation->VideoRamLength),
                                        &inIoSpace,
                                        &(memoryInformation->VideoRamBase));

            if (status != NO_ERROR) {

                VideoDebugPrint((0, "Perm3: VideoPortMapMemory failed with error %d\n", status));
                break;
            }

            memoryInformation->FrameBufferBase   = memoryInformation->VideoRamBase;
            memoryInformation->FrameBufferLength = memoryInformation->VideoRamLength;

            break;


        case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:

            VideoDebugPrint((3, "Perm3: UnMapVideoMemory\n"));

            if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) {

                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            status = VideoPortUnmapMemory (HwDeviceExtension, 
                                           ((PVIDEO_MEMORY) (RequestPacket->InputBuffer))->RequestedVirtualAddress, 
                                           0);

            break;

    case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:

        VideoDebugPrint((3, "Perm3: QueryPublicAccessRanges\n"));

        {
           PVIDEO_PUBLIC_ACCESS_RANGES portAccess;
           ULONG physicalPortLength;
           PVOID VirtualAddress;
           PHYSICAL_ADDRESS PhysicalAddress;
           ULONG requiredOPSize;

           //
           // Calculate minimum size of return buffer. There is
           // 1 public access range for single graphics chip systems.
           //

           requiredOPSize = sizeof(VIDEO_PUBLIC_ACCESS_RANGES);

           //
           // Validate the output buffer length
           //

           if ( (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information = requiredOPSize)) ||
                (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY))) {

               status = ERROR_INSUFFICIENT_BUFFER;
               break;
           }
           
           ProcessHandle = (HANDLE)(((PVIDEO_MEMORY)
                    (RequestPacket->InputBuffer))->RequestedVirtualAddress);
           
           if (ProcessHandle != (HANDLE)0) {
           
                //
                // map 4K area for a process
                //

                VideoDebugPrint((3, "Mapping in 4K area from Control registers\n"));

                VirtualAddress = (PVOID)ProcessHandle;

                PhysicalAddress = hwDeviceExtension->PhysicalRegisterAddress;
                PhysicalAddress.LowPart += 0x2000;
                physicalPortLength = 0x1000;

           } else {

                VideoDebugPrint((3, "Mapping in all Control registers\n"));

                VirtualAddress = NULL;

                PhysicalAddress = hwDeviceExtension->PhysicalRegisterAddress;
                physicalPortLength = hwDeviceExtension->RegisterLength;
           }

           portAccess = RequestPacket->OutputBuffer;

           portAccess->VirtualAddress  = VirtualAddress;
           portAccess->InIoSpace       = hwDeviceExtension->RegisterSpace;
           portAccess->MappedInIoSpace = portAccess->InIoSpace;

           status = VideoPortMapMemory(HwDeviceExtension,
                                       PhysicalAddress,
                                       &physicalPortLength,
                                       &(portAccess->MappedInIoSpace),
                                       &(portAccess->VirtualAddress));
        }

        break;


    case IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES:

        VideoDebugPrint((3, "Perm3: FreePublicAccessRanges\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) {

            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        status = VideoPortUnmapMemory(HwDeviceExtension,
                                      ((PVIDEO_MEMORY)(RequestPacket->InputBuffer))->RequestedVirtualAddress,
                                      0);

        break;


    case IOCTL_VIDEO_QUERY_AVAIL_MODES:

        VideoDebugPrint((3, "Perm3: QueryAvailableModes\n"));

        if (RequestPacket->OutputBufferLength <
            (RequestPacket->StatusBlock->Information =
                 hwDeviceExtension->monitorInfo.numAvailableModes
                                  * sizeof(VIDEO_MODE_INFORMATION)) ) {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            PPERM3_VIDEO_FREQUENCIES pFrequencyEntry;

            modeInformation = RequestPacket->OutputBuffer;

            if (!hwDeviceExtension->monitorInfo.frequencyTable) {

                VideoDebugPrint((0, "Perm3: hwDeviceExtension->monitorInfo.frequencyTable is null!\n"));
                status = ERROR_INVALID_PARAMETER;

            } else {

                for (pFrequencyEntry = hwDeviceExtension->monitorInfo.frequencyTable;
                     pFrequencyEntry->BitsPerPel != 0;
                     pFrequencyEntry++) {

                    if (pFrequencyEntry->ModeValid) {

                        if( pFrequencyEntry->ModeEntry ) {
                            *modeInformation = pFrequencyEntry->ModeEntry->ModeInformation;
                            modeInformation->Frequency = pFrequencyEntry->ScreenFrequency;
                            modeInformation->ModeIndex = pFrequencyEntry->ModeIndex;
                            modeInformation++;
                        }
                    } 
                }

                status = NO_ERROR;
            }
        }

        break;


     case IOCTL_VIDEO_QUERY_CURRENT_MODE:

        VideoDebugPrint((3, "Perm3: Query current mode. Current mode is %d\n",
            hwDeviceExtension->ActiveModeEntry->ModeInformation.ModeIndex));

        if (RequestPacket->OutputBufferLength <
            (RequestPacket->StatusBlock->Information = sizeof(VIDEO_MODE_INFORMATION))) {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            *((PVIDEO_MODE_INFORMATION)RequestPacket->OutputBuffer) =
                      hwDeviceExtension->ActiveModeEntry->ModeInformation;

            ((PVIDEO_MODE_INFORMATION)RequestPacket->OutputBuffer)->Frequency =
                     hwDeviceExtension->ActiveFrequencyEntry.ScreenFrequency;

            status = NO_ERROR;
        }

        break;


    case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

        VideoDebugPrint((3, "Perm3: QueryNumAvailableModes (= %d)\n",
                hwDeviceExtension->monitorInfo.numAvailableModes));

        //
        // Find out the size of the data to be put in the the buffer and
        // return that in the status information (whether or not the
        // information is there). If the buffer passed in is not large
        // enough return an appropriate error code.
        //

        if (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information =
                                                sizeof(VIDEO_NUM_MODES)) ) {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)->NumModes =
                hwDeviceExtension->monitorInfo.numAvailableModes;

            ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)->ModeInformationLength =
                sizeof(VIDEO_MODE_INFORMATION);

            status = NO_ERROR;
        }

        break;


    case IOCTL_VIDEO_SET_CURRENT_MODE:

        VideoDebugPrint((3, "Perm3: SetCurrentMode\n"));

        //
        // Check if the size of the data in the input buffer is large enough.
        //

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MODE)) {
       
            RequestPacket->StatusBlock->Information = sizeof(VIDEO_MODE);
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        RequestedMode = ((PVIDEO_MODE) RequestPacket->InputBuffer)->RequestedMode;
        modeNumber = RequestedMode & ~VIDEO_MODE_NO_ZERO_MEMORY;

        if ((modeNumber >= hwDeviceExtension->monitorInfo.numTotalModes) ||
            !(hwDeviceExtension->monitorInfo.frequencyTable[modeNumber].ModeValid))  {
       
            RequestPacket->StatusBlock->Information = hwDeviceExtension->monitorInfo.numTotalModes;
            status = ERROR_INVALID_PARAMETER;
            break;
        }

        ulValue = ((RequestedMode & VIDEO_MODE_NO_ZERO_MEMORY) == 0);

        status = SetCurrentVideoMode(hwDeviceExtension, modeNumber, (BOOLEAN)ulValue);

        if(status != NO_ERROR) {

            RequestPacket->StatusBlock->Information = modeNumber;
        }

        break;

    case IOCTL_VIDEO_SET_COLOR_REGISTERS:

        VideoDebugPrint((3, "Perm3: SetColorRegs\n"));

        clutBuffer = (PVIDEO_CLUT) RequestPacket->InputBuffer;

        status = Perm3SetColorLookup(hwDeviceExtension,
                                     clutBuffer,
                                     RequestPacket->InputBufferLength,
                                     FALSE,   // Only update if different from cache
                                     TRUE);   // Update cache entries as well as RAMDAC
        break;


    case IOCTL_VIDEO_GET_COLOR_REGISTERS:
        {
            const int cchMinLUTSize = 256 * 3;
            UCHAR *pLUTBuffer = (char *)RequestPacket->OutputBuffer;
            UCHAR red, green, blue;
            int index;

            VideoDebugPrint((3, "Perm3: GetColorRegs\n"));

            if ((int)RequestPacket->OutputBufferLength < cchMinLUTSize) {

                RequestPacket->StatusBlock->Information = cchMinLUTSize;
                status = ERROR_INSUFFICIENT_BUFFER;

            } else {

                P3RDRAMDAC *pP3RDRegs = (P3RDRAMDAC *)hwDeviceExtension->pRamdac;

                P3RD_PALETTE_START_RD(0);

                for (index = 0; index < 256; ++index) {

                    P3RD_READ_PALETTE (red, green, blue);
                    *pLUTBuffer++ = red;
                    *pLUTBuffer++ = green;
                    *pLUTBuffer++ = blue;
                }

                status = NO_ERROR;
                RequestPacket->StatusBlock->Information = RequestPacket->OutputBufferLength;
            }
        }
        break;

    case IOCTL_VIDEO_RESET_DEVICE:

        VideoDebugPrint((3, "Perm3: RESET_DEVICE\n"));

        if(hwDeviceExtension->bVGAEnabled) {

            //
            // Only reset the device if the monitor is on.  If it is off,
            // then executing the int10 will turn it back on.
            //

            if (hwDeviceExtension->bMonitorPoweredOn) {

                //
                // Do an Int10 to mode 3 will put the VGA to a known state.
                //

                VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
                biosArguments.Eax = 0x0003;
                VideoPortInt10(HwDeviceExtension, &biosArguments);
           }
        }

        status = NO_ERROR;
        break;

    case IOCTL_VIDEO_SHARE_VIDEO_MEMORY:

        {
        PVIDEO_SHARE_MEMORY pShareMemory;
        PVIDEO_SHARE_MEMORY_INFORMATION pShareMemoryInformation;
        PHYSICAL_ADDRESS shareAddress;
        PVOID virtualAddress;
        ULONG sharedViewSize;

        VideoDebugPrint((3, "Perm3: ShareVideoMemory\n"));

        if ( (RequestPacket->OutputBufferLength < sizeof(VIDEO_SHARE_MEMORY_INFORMATION)) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) ) {

            VideoDebugPrint((0, "Perm3: IOCTL_VIDEO_SHARE_VIDEO_MEMORY: ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        pShareMemory = RequestPacket->InputBuffer;

        if ( (pShareMemory->ViewOffset > hwDeviceExtension->AdapterMemorySize) ||
             ((pShareMemory->ViewOffset + pShareMemory->ViewSize) >
                  hwDeviceExtension->AdapterMemorySize) ) {

            VideoDebugPrint((0, "Perm3: IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INVALID_PARAMETER\n"));
            status = ERROR_INVALID_PARAMETER;
            break;
        }

        RequestPacket->StatusBlock->Information =
                                    sizeof(VIDEO_SHARE_MEMORY_INFORMATION);

        //
        // Beware: the input buffer and the output buffer are the same
        // buffer, and therefore data should not be copied from one to the
        // other
        //

        virtualAddress = pShareMemory->ProcessHandle;
        sharedViewSize = pShareMemory->ViewSize;

        inIoSpace = hwDeviceExtension->PhysicalFrameIoSpace;

        //
        // NOTE: we are ignoring ViewOffset
        //

        shareAddress.QuadPart =
            hwDeviceExtension->PhysicalFrameAddress.QuadPart;

        //
        // Performance:
        //
        // Enable USWC. We only do it for the frame buffer.
        // Memory mapped registers usually can not be mapped USWC 
        //

        inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;

        //
        // Unlike the MAP_MEMORY IOCTL, in this case we can not map extra
        // address space since the application could actually use the
        // pointer we return to it to touch locations in the address space
        // that do not have actual video memory in them.
        //
        // An app doing this would cause the machine to crash.
        //

        status = VideoPortMapMemory(hwDeviceExtension,
                                    shareAddress,
                                    &sharedViewSize,
                                    &inIoSpace,
                                    &virtualAddress);

        pShareMemoryInformation = RequestPacket->OutputBuffer;
        pShareMemoryInformation->SharedViewOffset = pShareMemory->ViewOffset;
        pShareMemoryInformation->VirtualAddress = virtualAddress;
        pShareMemoryInformation->SharedViewSize = sharedViewSize;

        }

        break;

    case IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY:
        {

        PVIDEO_SHARE_MEMORY pShareMemory;

        VideoDebugPrint((3, "Perm3: UnshareVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_SHARE_MEMORY)) {

            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        pShareMemory = RequestPacket->InputBuffer;

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      pShareMemory->RequestedVirtualAddress,
                                      pShareMemory->ProcessHandle);
        }

        break;

    case IOCTL_VIDEO_QUERY_GENERAL_DMA_BUFFER:

        //
        // Return the line DMA buffer information. The
        // buffer size and virtual address will be zero if
        // the buffer couldn't be allocated.
        //

        if( (RequestPacket->OutputBufferLength < (RequestPacket->StatusBlock->Information = sizeof(GENERAL_DMA_BUFFER))) ||
            (RequestPacket->InputBufferLength != sizeof(ULONG)) ) {

            //
            // They've give us a duff buffer.
            //

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            GENERAL_DMA_BUFFER *local = NULL, *remote = (PGENERAL_DMA_BUFFER) RequestPacket->OutputBuffer;
            ULONG *bufferNum = (PULONG) RequestPacket->InputBuffer;

            status = NO_ERROR;
            switch( *bufferNum ) {

                case 1:
                    local = &hwDeviceExtension->LineDMABuffer;
                break;

                case 2:
                    local = &hwDeviceExtension->P3RXDMABuffer;
                break;

                default:
                    status = ERROR_INVALID_PARAMETER;
                break;
            }

            //
            // We need the buffer even if DMA/interrupts don't work
            //

            if(*bufferNum == 2 || 
               (local && hwDeviceExtension->Capabilities & CAPS_DMA_AVAILABLE)) {

                //
                // They've give us a correctly-sized buffer. So copy
                // the relevant buffer info.
                //

                *remote = *local;

            } else {

                remote->physAddr.LowPart = 0;
                remote->virtAddr = 0;
                remote->size = 0;
            }
        }
        
        break;

    case IOCTL_VIDEO_HANDLE_VIDEOPARAMETERS:

        VideoDebugPrint((3, "Perm3: HandleVideoParameters\n"));

        //
        // We don't support a tv connector so just return NO_ERROR here
        //

        pVideoParams = (PVIDEOPARAMETERS) (RequestPacket->InputBuffer);

        if (pVideoParams->dwCommand == VP_COMMAND_GET) {
       
            pVideoParams = (PVIDEOPARAMETERS) (RequestPacket->OutputBuffer);
            pVideoParams->dwFlags = 0;
        }

        RequestPacket->StatusBlock->Information = sizeof(VIDEOPARAMETERS);
        status = NO_ERROR;
        break;
       
    //
    // if we get here, an invalid IoControlCode was specified.
    //

    default:

#if DBG
        VideoDebugPrint((3, "Perm3: Fell through perm3 startIO routine - invalid command (0x%x)\n", RequestPacket->IoControlCode));
#endif
        status = ERROR_INVALID_FUNCTION;
        break;

    }

    RequestPacket->StatusBlock->Status = status;

    if( status != NO_ERROR )
        RequestPacket->StatusBlock->Information = 0;

    VideoDebugPrint((3, "Perm3: Leaving StartIO routine. Status = 0x%x, Information = 0x%x\n",
                         RequestPacket->StatusBlock->Status, RequestPacket->StatusBlock->Information));


    return TRUE;

} // end Perm3StartIO()

VP_STATUS
Perm3RetrieveGammaCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )

/*+++

Routine Description:

    This routine is used to read back the gamma LUT from the registry.

Arguments:

    HwDeviceExtension
        Supplies a pointer to the miniport's device extension.

    Context
        Context value passed to the get registry paramters routine

    ValueName 
        Name of the value requested.

    ValueData 
        Pointer to the requested data.

    ValueLength 
        Length of the requested data.

Return Value:

    if the variable doesn't exist return an error, else copy the gamma 
    lut into the supplied pointer

---*/

{
    if (ValueLength != MAX_CLUT_SIZE) {
   
        VideoDebugPrint((0, "Perm3: Perm3RetrieveGammaCallback got ValueLength of %d\n", ValueLength));
        return ERROR_INVALID_PARAMETER;
    }

    VideoPortMoveMemory(Context, ValueData, MAX_CLUT_SIZE);

    return NO_ERROR;

} // end Perm3RetrieveGammaCallback()


VP_STATUS 
SetCurrentVideoMode(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    ULONG modeNumber, 
    BOOLEAN bZeroMemory
    )
{
    PERM3_VIDEO_FREQUENCIES FrequencyEntry;
    PPERM3_VIDEO_MODES ModeEntry;
    ULONG ulValue;
    VP_STATUS rc = NO_ERROR;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    //
    // set the current mode, but turn off interrupts before we do so to 
    // avoid any spurious video FIFO underrun errors - InitializeVideo can 
    // opt to turn these on by setting hwDeviceExtension->IntEnable which
    // we'll load into INT_ENABLE before exiting from this routine
    //

    hwDeviceExtension->IntEnable = VideoPortReadRegisterUlong(INT_ENABLE);

    VideoPortWriteRegisterUlong( INT_ENABLE, 
                                 hwDeviceExtension->IntEnable & 
                                 ~(INTR_ERROR_SET | INTR_VBLANK_SET));

    //
    // disable stereo support
    //

    hwDeviceExtension->Capabilities &= ~CAPS_STEREO;

    //
    // Re-sample the clock speed. This allows us to change the clock speed
    // on the fly
    //

    Perm3GetClockSpeeds(hwDeviceExtension);

    FrequencyEntry = hwDeviceExtension->monitorInfo.frequencyTable[modeNumber];
    ModeEntry = FrequencyEntry.ModeEntry;

    //
    // At this point, 'ModeEntry' and 'FrequencyEntry' point to the necessary
    // table entries required for setting the requested mode.
    //

    //
    // Zero the DAC and the Screen buffer memory.
    //

    ulValue = modeNumber;

    if(!bZeroMemory)
        ulValue |= VIDEO_MODE_NO_ZERO_MEMORY;

    ZeroMemAndDac(hwDeviceExtension, ulValue);

    ModeEntry->ModeInformation.DriverSpecificAttributeFlags = hwDeviceExtension->Capabilities;

    //
    // For low resolution modes we may have to do various tricks
    // such as line doubling and getting the RAMDAC to zoom.
    // Record any such zoom in the Mode DeviceAttributes field.
    // Primarily this is to allow the display driver to compensate
    // when asked to move the cursor or change its shape.
    //
    // Currently, low res means lower than 512 pixels width.
    //

    if (FrequencyEntry.ScreenWidth < 512) {
      
        //
        // Permedia 3 does line doubling. If using a TVP we must
        // get it to zoom by 2 in X to get the pixel rate up.
        //

        ModeEntry->ModeInformation.DriverSpecificAttributeFlags |= CAPS_ZOOM_Y_BY2;
    }

    if (!InitializeVideo(hwDeviceExtension, &FrequencyEntry)) {
   
        VideoDebugPrint((0, "Perm3: InitializeVideo failed\n"));
        rc = ERROR_INVALID_PARAMETER;
        goto end;
    }        

    //
    // Save the mode since we know the rest will work.
    //

    hwDeviceExtension->ActiveModeEntry = ModeEntry;
    hwDeviceExtension->ActiveFrequencyEntry = FrequencyEntry;

    //
    // Update VIDEO_MODE_INFORMATION fields
    //
    // Now that we've set the mode, we now know the screen stride, and
    // so can update some fields in the VIDEO_MODE_INFORMATION
    // structure for this mode.  The Permedia 3 display driver is expected to
    // call IOCTL_VIDEO_QUERY_CURRENT_MODE to query these corrected
    // values.
    //

    //
    // Calculate the bitmap width (note the '+ 1' on BitsPerPlane is
    // so that '15bpp' works out right). 12bpp is special in that we
    // support it as sparse nibbles within a 32-bit pixel. ScreenStride
    // is in bytes; VideoMemoryBitmapWidth is measured in pixels;
    //

    if (ModeEntry->ModeInformation.BitsPerPlane != 12) {
   
        ModeEntry->ModeInformation.VideoMemoryBitmapWidth =
           ModeEntry->ModeInformation.ScreenStride / ((ModeEntry->ModeInformation.BitsPerPlane + 1) >> 3);

    } else {

        ModeEntry->ModeInformation.VideoMemoryBitmapWidth =
           ModeEntry->ModeInformation.ScreenStride >> 2;
    }

    ulValue = hwDeviceExtension->AdapterMemorySize;

    ModeEntry->ModeInformation.VideoMemoryBitmapHeight = ulValue / ModeEntry->ModeInformation.ScreenStride;

end:

    //
    // set-up the interrupt enable 
    //

    VideoPortWriteRegisterUlong(INT_ENABLE, hwDeviceExtension->IntEnable);
    return(rc);
} 

VP_STATUS
Perm3SetColorLookup(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize,
    BOOLEAN ForceRAMDACWrite,
    BOOLEAN UpdateCache
    )

/*+++

Routine Description:

    This routine sets a specified portion of the color lookup table settings.

Arguments:

    hwDeviceExtension
        Pointer to the miniport driver's device extension.

    ClutBufferSize
        Length of the input buffer supplied by the user.

    ClutBuffer
        Pointer to the structure containing the color lookup table.

    ForceRAMDACWrite
        When it is set to FALSE, only update if different from cache

    UpdateCache
        When it is set to TRUE, update cache entries as well as RAMDAC

Return Value:

    VP_STATUS

---*/

{
    USHORT i, j;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ( (ClutBufferSize < (sizeof(VIDEO_CLUT) - sizeof(ULONG))) ||
         (ClutBufferSize < (sizeof(VIDEO_CLUT) +
                     (sizeof(ULONG) * (ClutBuffer->NumEntries - 1))) ) ) {

        VideoDebugPrint((0, "Perm3: Perm3SetColorLookup: insufficient buffer (was %d, min %d)\n",
                             ClutBufferSize,
                            (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * (ClutBuffer->NumEntries - 1)))));
        
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Check to see if the parameters are valid.
    //

    if ( (ClutBuffer->NumEntries == 0) ||
         (ClutBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER) ||
         (ClutBuffer->FirstEntry + ClutBuffer->NumEntries >
                                     VIDEO_MAX_COLOR_REGISTER + 1) ) {

        VideoDebugPrint((0, "Perm3: Perm3SetColorLookup: invalid parameter\n"));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Set CLUT registers directly on the hardware. 
    //
    
    {

    P3RDRAMDAC *pP3RDRegs = (P3RDRAMDAC *)hwDeviceExtension->pRamdac;
    PVIDEO_CLUT LUTCachePtr = &(hwDeviceExtension->LUTCache.LUTCache);

    //
    // RAMDAC Programming phase
    //

    for (i = 0, j = ClutBuffer->FirstEntry; 
         i < ClutBuffer->NumEntries; 
         i++, j++)  {

        //
        // Update the RAMDAC entry if it has changed or if we have been
        // told to overwrite it.

        if (ForceRAMDACWrite || 
                ( LUTCachePtr->LookupTable[j].RgbLong != 
                  ClutBuffer->LookupTable[i].RgbLong)  ) {

            P3RD_LOAD_PALETTE_INDEX (j,
                                     ClutBuffer->LookupTable[i].RgbArray.Red,
                                     ClutBuffer->LookupTable[i].RgbArray.Green,
                                     ClutBuffer->LookupTable[i].RgbArray.Blue);
        }

        //
        // Update the cache, if instructed to do so
        //

        if (UpdateCache) {

            LUTCachePtr->LookupTable[j].RgbLong = ClutBuffer->LookupTable[i].RgbLong;
        }
    }

    }

    return NO_ERROR;
}

VOID
Perm3GetClockSpeeds(
    PVOID HwDeviceExtension
    )

/*+++

Routine Description:

    Work out the chip clock speed and save in hwDeviceExtension.

Arguments:

    hwDeviceExtension
        Supplies a pointer to the miniport's device extension.

Return Value:

    On return the following values will be in hwDeviceExtension:
        ChipClockSpeed: this is the desired speed for the chip
        RefClockSpeed:  this is the speed of the oscillator input on the board

---*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ulValue;
    VP_STATUS status;

    //
    // force recalculation of clock speeds every time 
    //

    hwDeviceExtension->ChipClockSpeed = 0;
    hwDeviceExtension->RefClockSpeed  = 0;
    hwDeviceExtension->RefClockSpeed = 0;

    //
    // If a clock speed has been specified in the registry then validate it
    //

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            PERM3_REG_STRING_REFCLKSPEED,
                                            FALSE,
                                            Perm3RegistryCallback,
                                            &hwDeviceExtension->RefClockSpeed
                                            );

    if (status != NO_ERROR || hwDeviceExtension->RefClockSpeed == 0) {

        //
        // Use default setting
        //

        hwDeviceExtension->RefClockSpeed = 14318200;
    }

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            PERM3_REG_STRING_CORECLKSPEEDALT,
                                            FALSE,
                                            Perm3RegistryCallback,
                                            &hwDeviceExtension->ChipClockSpeedAlt
                                            );

    if (status != NO_ERROR || hwDeviceExtension->ChipClockSpeedAlt == 0) {
           
        //
        // If we have read the alt core clock speed from ROM then
        // we will have set hwDeviceExtension->bHaveExtendedClocks,
        // so use that value
        //

        if (hwDeviceExtension->bHaveExtendedClocks) {

            hwDeviceExtension->ChipClockSpeedAlt = 
                               hwDeviceExtension->ulPXRXCoreClockAlt;
        }
                
        //
        // If we haven't got a valid value then use the default
        //

        if (hwDeviceExtension->ChipClockSpeedAlt == 0) {

            hwDeviceExtension->ChipClockSpeedAlt = 
                               PERMEDIA3_DEFAULT_CLOCK_SPEED_ALT;
        }

    } else {

        hwDeviceExtension->ChipClockSpeedAlt *= 1000*1000;
    }

    //
    // Can override default chip clock speed in registry.
    //

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            PERM3_REG_STRING_CORECLKSPEED,
                                            FALSE,
                                            Perm3RegistryCallback,
                                            &hwDeviceExtension->ChipClockSpeed 
                                            );

    //
    // If a clock speed has been specified in the registry
    // then validate it
    //

    if (status == NO_ERROR && hwDeviceExtension->ChipClockSpeed != 0) {

        hwDeviceExtension->ChipClockSpeed *= (1000*1000); 

        if (hwDeviceExtension->ChipClockSpeed > PERMEDIA3_MAX_CLOCK_SPEED) {

            hwDeviceExtension->ChipClockSpeed = PERMEDIA3_MAX_CLOCK_SPEED;
        }

    } else {
           
        //
        // If the chip clock speed was not set in the registry
        // then read it from the ROM
        //

        if (hwDeviceExtension->ChipClockSpeed == 0) {
               
            //
            // On later BIOSes the core clock is in a different bit
            // of ROM and hwDeviceExtension->bHaveExtendedClocks will
            // be set to say that we have already read it from ROM.
            //

            if (hwDeviceExtension->bHaveExtendedClocks) {
                hwDeviceExtension->ChipClockSpeed = 
                                   hwDeviceExtension->ulPXRXCoreClock;
            } else {
                ReadChipClockSpeedFromROM (
                                   hwDeviceExtension, 
                                   &hwDeviceExtension->ChipClockSpeed );

            }
                
            //
            // If there isn't a clock-speed in the ROM then use
            // the defined default
            //

            if (hwDeviceExtension->ChipClockSpeed == 0) {
                hwDeviceExtension->ChipClockSpeed = 
                                   PERMEDIA3_DEFAULT_CLOCK_SPEED;
            }
        }
    }

    VideoDebugPrint((3, "Perm3: Chip clock speed now set to %d Hz\n",
                         hwDeviceExtension->ChipClockSpeed));

    VideoDebugPrint((3, "Perm3: Chip ALT clock speed now set to %d Hz\n",
                         hwDeviceExtension->ChipClockSpeedAlt));

    VideoDebugPrint((3, "Perm3: Ref  clock speed now set to %d Hz\n",
                         hwDeviceExtension->RefClockSpeed));
}

VOID
ZeroMemAndDac(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    ULONG RequestedMode
    )

/*+++

Routine Description:

    Initialize the DAC to 0 (black) and clear the framebuffer
Arguments:

    hwDeviceExtension 
        Supplies a pointer to the miniport's device extension.

    RequestedMode
        use the VIDEO_MODE_NO_ZERO_MEMORY bit to determine if the
        framebuffer should be cleared

Return Value:

    None

---*/

{
    ULONG  i;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];
    P3RDRAMDAC *pP3RDRegs = (P3RDRAMDAC *)hwDeviceExtension->pRamdac;

    //
    // Turn off the screen at the DAC.
    //

    VideoDebugPrint((3, "Perm3: turning off readmask and zeroing LUT\n"));

    P3RD_SET_PIXEL_READMASK (0x0);
    P3RD_PALETTE_START_WR (0);

    for (i = 0; i <= VIDEO_MAX_COLOR_REGISTER; i++) {
        P3RD_LOAD_PALETTE (0, 0, 0);
    }

    if (!(RequestedMode & VIDEO_MODE_NO_ZERO_MEMORY)) {
   
        //
        // Zero the memory. Don't use Perm3 as we would have to save/restore
        // state and that's a pain. This is not time critical.
        //

        VideoPortZeroDeviceMemory(hwDeviceExtension->pFramebuffer,
                                  hwDeviceExtension->FrameLength);

    }

    //
    // Turn on the screen at the DAC
    //

    VideoDebugPrint((3, "Perm3: turning on readmask\n"));

    P3RD_SET_PIXEL_READMASK (0xff);

    LUT_CACHE_INIT();   

    return;

}

VOID
ReadChipClockSpeedFromROM (
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    ULONG * pChipClkSpeed
    )

/*+++

Routine Description:

    Read the chip clock speed (in MHz) from the Video ROM BIOS
    (offset 0xA in the BIOS)    

Arguments:

    hwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

    none

---*/

{
    //
    // Read the chip clock speed (in MHz) from the Video ROM BIOS (offset
    // 0xA in the BIOS)    
    // This involves changing the aperture 2 register so aperture better 
    // be completely idle or we could be in trouble; fortunately we only 
    // call this function during a mode change and expect aperture 2 (the 
    // FrameBuffer) to be idle
    //

    UCHAR clkSpeed;
    ULONG Default;
    UCHAR *p = (UCHAR *)hwDeviceExtension->pFramebuffer;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];
        
    Default = VideoPortReadRegisterUlong(APERTURE_TWO);
    
    //
    // r/w via aperture 2 actually go to ROM
    //

    VideoPortWriteRegisterUlong(APERTURE_TWO, Default | 0x200);

    //
    //  If we have a valid ROM then read the clock pseed
    //

    if (VideoPortReadRegisterUshort ((USHORT *) p) == 0xAA55) {
   
        //
        // Get the clock speed
        //

        clkSpeed = VideoPortReadRegisterUchar(&(p[0xA]));

        //
        // Some boards, such as ones by Creative, have been know to set offset
        // 0xA to random-ish values. Creative use the following test to determine
        // whether they have a sensible value, so that is what we will use.
        //

        if (clkSpeed > 50) {

            *pChipClkSpeed = clkSpeed;
            *pChipClkSpeed *= (1000*1000); 
        }

        VideoDebugPrint((3, "Perm3: ROM clk speed value 0x%x\n", (ULONG) VideoPortReadRegisterUchar(&(p[0xA]))));

    } else {
   
        VideoDebugPrint((0, "Perm3: Bad BIOS ROM header 0x%x\n", (ULONG) VideoPortReadRegisterUshort ((USHORT *) p)));
    }

    VideoPortWriteRegisterUlong(APERTURE_TWO, Default);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\mini\power.c ===
/***************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
* 
*   power.c
* 
* Abstract:
* 
*   This module contains the code that implements the power management features
* 
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2001 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

#include "perm3.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,Perm3GetPowerState)
#pragma alloc_text(PAGE,Perm3SetPowerState)
#pragma alloc_text(PAGE,Perm3GetChildDescriptor)
#pragma alloc_text(PAGE,ProgramDFP)
#pragma alloc_text(PAGE,GetDFPEdid)
#pragma alloc_text(PAGE,I2CWriteClock)
#pragma alloc_text(PAGE,I2CWriteData)
#pragma alloc_text(PAGE,I2CReadClock)
#pragma alloc_text(PAGE,I2CReadData)
#pragma alloc_text(PAGE,I2CWriteClockDFP)
#pragma alloc_text(PAGE,I2CWriteDataDFP)
#pragma alloc_text(PAGE,I2CReadClockDFP)
#pragma alloc_text(PAGE,I2CReadDataDFP)
#endif

DDC_CONTROL
DDCControlCRT = {
    sizeof(DDC_CONTROL),
    I2CWriteClock, 
    I2CWriteData, 
    I2CReadClock, 
    I2CReadData, 
    0
    };

DDC_CONTROL
DDCControlDFP = {
    sizeof(DDC_CONTROL),
    I2CWriteClockDFP,
    I2CWriteDataDFP,
    I2CReadClockDFP, 
    I2CReadDataDFP, 
    0
    };

VP_STATUS 
Perm3GetPowerState(
    PVOID HwDeviceExtension, 
    ULONG HwId, 
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    )
/*+++

Routine Description:

    Queries whether the device can support the requested power state.
    
Arguments:

    HwDeviceExtension
        Pointer to our hardware device extension structure.

    HwId 
        Points to a 32-bit number that uniquely identifies the device that 
        the miniport should query. 

    VideoPowerControl
        Points to a VIDEO_POWER_MANAGEMENT structure that specifies the 
        power state for which support is being queried.

Return Value:

    NO_ERROR, if the device supports the requested power state, or error code.

---*/

{
    VP_STATUS status;
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    VideoDebugPrint((3, "Perm3: Perm3GetPowerState: hwId(0x%x) state = %d\n", 
                         HwId, VideoPowerControl->PowerState ));

    switch(HwId) {

        case PERM3_DDC_MONITOR:
        case PERM3_NONDDC_MONITOR:

            switch ( VideoPowerControl->PowerState ) {

                case VideoPowerOn:
                case VideoPowerStandBy:
                case VideoPowerSuspend:
                case VideoPowerOff:
                case VideoPowerHibernate:
                case VideoPowerShutdown:
                    status = NO_ERROR;
                    break;

                default:

                    VideoDebugPrint((0, "Perm3: Perm3GetPowerState: Unknown monitor PowerState = %d\n", 
                                         VideoPowerControl->PowerState ));
                    ASSERT(FALSE);
                    status = ERROR_INVALID_PARAMETER;
            }

            break;

        case DISPLAY_ADAPTER_HW_ID:

            switch ( VideoPowerControl->PowerState ) {

                case VideoPowerOn:
                case VideoPowerStandBy:
                case VideoPowerSuspend:
                case VideoPowerOff:
                case VideoPowerHibernate:
                case VideoPowerShutdown:

                    status = NO_ERROR;
                    break;

                default:

                    VideoDebugPrint((0, "Perm3: Perm3GetPowerState: Unknown adapter PowerState = %d\n", 
                                         VideoPowerControl->PowerState ));
                    ASSERT(FALSE);
                    status = ERROR_INVALID_PARAMETER;
            }

            break;

        default:

            VideoDebugPrint((0, "Perm3: Perm3GetPowerState: Unknown hwId(0x%x)", HwId));
            ASSERT(FALSE);
            status = ERROR_INVALID_PARAMETER;
    }

    return(status);
}

VP_STATUS 
Perm3SetPowerState(
    PVOID HwDeviceExtension, 
    ULONG HwId, 
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    )
/*+++

Routine Description:

    Sets the power state of the specified device.

Arguments:

    HwDeviceExtension 
        Pointer to our hardware device extension structure.

    HwId
        Points to a 32-bit number that uniquely identifies the device 
        for which the miniport should set the power state. 

    VideoPowerControl
        Points to a VIDEO_POWER_MANAGEMENT structure that specifies the 
        power state to be set.

Return Value:

    NO_ERROR

---*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG Polarity;
    
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    VideoDebugPrint((3, "Perm3: Perm3SetPowerState: hwId(0x%x) state = %d\n", 
                         HwId, VideoPowerControl->PowerState));

    switch(HwId) {
   
        case PERM3_DDC_MONITOR:
        case PERM3_NONDDC_MONITOR:

            Polarity = VideoPortReadRegisterUlong(VIDEO_CONTROL);
            Polarity &= ~VC_DPMS_MASK;

            switch (VideoPowerControl->PowerState) {
       
                case VideoPowerOn:
                     VideoPortWriteRegisterUlong(VIDEO_CONTROL, 
                                                 Polarity | hwDeviceExtension->VideoControlMonitorON);
                     break;

                case VideoPowerStandBy:
                     VideoPortWriteRegisterUlong(VIDEO_CONTROL, 
                                                 Polarity | VC_DPMS_STANDBY);
                     break;

                case VideoPowerSuspend:
                     VideoPortWriteRegisterUlong(VIDEO_CONTROL, 
                                                 Polarity | VC_DPMS_SUSPEND);
                     break;

                case VideoPowerShutdown:
                case VideoPowerOff:
                     VideoPortWriteRegisterUlong(VIDEO_CONTROL, 
                                                 Polarity | VC_DPMS_OFF);
                     break;

                case VideoPowerHibernate:

                     //   
                     // The monitor for the vga enabled video device must
                     // stay on at hibernate.
                     //

                     break;

                default:
                    VideoDebugPrint((0, "Perm3: Perm3GetPowerState: Unknown monitor PowerState(0x%x)\n", 
                                         VideoPowerControl->PowerState));
                    ASSERT(FALSE);
            }

            //
            // Track the current monitor power state
            //

            hwDeviceExtension->bMonitorPoweredOn =
                    (VideoPowerControl->PowerState == VideoPowerOn) ||
                    (VideoPowerControl->PowerState == VideoPowerHibernate);

            break;

        case DISPLAY_ADAPTER_HW_ID:

            switch (VideoPowerControl->PowerState) {
       
                case VideoPowerOn:

                    if ((hwDeviceExtension->PreviousPowerState == VideoPowerOff) ||
                        (hwDeviceExtension->PreviousPowerState == VideoPowerSuspend) ||
                        (hwDeviceExtension->PreviousPowerState == VideoPowerHibernate)){
           
                        //
                        // Turn off the monitor while we power back up so 
                        // the user doesn't see any screen corruption
                        //

                        Polarity = VideoPortReadRegisterUlong(VIDEO_CONTROL);
                        Polarity &= ~VC_DPMS_MASK;
                        VideoPortWriteRegisterUlong(VIDEO_CONTROL, Polarity | VC_DPMS_OFF);

                        //
                        // Miniport driver can not rely on video bios to
                        // initialize the device registers while resuming
                        // from VideoPowerOff and VideoPowerSuspend. 
                        // 
                        // This is also true for the secondary (vga disabled) 
                        // video device while resuming from VideoPowerHibernate
                        // 

                        InitializePostRegisters(hwDeviceExtension);
                    }

                    break;

                case VideoPowerStandBy:
                case VideoPowerSuspend:
                case VideoPowerOff:
                case VideoPowerHibernate:

                    break;

                case VideoPowerShutdown:

                    // 
                    // We need to make sure no interrupts will be generated
                    // after the device being powered down
                    // 

                    VideoPortWriteRegisterUlong(INT_ENABLE, 0);
                    break;

                default:

                    VideoDebugPrint((0, "Perm3: Perm3GetPowerState: Unknown adapter PowerState(0x%x)\n", 
                                         VideoPowerControl->PowerState));
                    ASSERT(FALSE);
            }

            hwDeviceExtension->PreviousPowerState = VideoPowerControl->PowerState;
            break;

        default:

            VideoDebugPrint((0, "Perm3: Perm3SetPowerState: Unknown hwId(0x%x)\n", 
                                 HwId));
            ASSERT(FALSE);
    }

    return(NO_ERROR);
}

ULONG 
Perm3GetChildDescriptor(
    PVOID HwDeviceExtension, 
    PVIDEO_CHILD_ENUM_INFO pChildInfo, 
    PVIDEO_CHILD_TYPE pChildType,
    PUCHAR pChildDescriptor, 
    PULONG pUId, 
    PULONG Unused
    )

/*+++

Routine Description:

    Enumerates all child devices attached to the specified device.

    This includes DDC monitors attached to the board, as well as other devices
    which may be connected to a proprietary bus.

Arguments:

    HwDeviceExtension 
        Pointer to our hardware device extension structure.

    ChildEnumInfo
        Pointer to VIDEO_CHILD_ENUM_INFO structure that describes the 
        device being enumerated. 

    pChildType
        Points to a location in which the miniport returns the type of 
        child being enumerated. 

    pChildDescriptor
        Points to a buffer in which the miniport can return data that 
        identifies the device. 

    pUId
        Points to the location in which the miniport returns a unique 
        32-bit identifier for this device. 

    pUnused
        Is unused and must be set to zero. 

Return Value:

    ERROR_MORE_DATA 
        There are more devices to be enumerated. 

    ERROR_NO_MORE_DEVICES 
        There are no more devices to be enumerated. 

    ERROR_INVALID_NAME 
        The miniport could not enumerate the child device identified in 
        ChildEnumInfo but does have more devices to be enumerated. 

---*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    VideoDebugPrint((3, "Perm3: Perm3GetChildDescriptor called\n"));

    switch(pChildInfo->ChildIndex) {
   
        case 0:

            //
            // Case 0 is used to enumerate devices found by the ACPI firmware.
            // We don't currently support ACPI devices
            //

            break;

        case 1:

            //
            // Treat index 1 as monitor
            //

            *pChildType = Monitor;
             
            //
            // First we search for a DFP monitor
            //

            if (GetDFPEdid(hwDeviceExtension, 
                           pChildDescriptor, 
                           pChildInfo->ChildDescriptorSize)) {

                //
                // found a DFP monitor
                //

                *pUId = PERM3_DFP_MONITOR;

                return(VIDEO_ENUM_MORE_DEVICES);
            } 

            //
            // If we didn't find a DFP, try to detect a DDC CRT monitor
            // 

            if(VideoPortDDCMonitorHelper(HwDeviceExtension, 
                                         &DDCControlCRT, 
                                         pChildDescriptor, 
                                         pChildInfo->ChildDescriptorSize)) {
                //
                // found a DDC monitor
                //

                *pUId = PERM3_DDC_MONITOR;

            } else {

                //
                // failed: assume non-DDC monitor
                //

                *pUId = PERM3_NONDDC_MONITOR;
            }

            return(VIDEO_ENUM_MORE_DEVICES);

    }

    return(ERROR_NO_MORE_DEVICES);
}

VOID
ProgramDFP(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )
/*+++

Routine Description:

    Program the Perm3 chip to use DFP or not use DFP, depending on whether
    PERM3_DFP and PERM3_DFP_MON_ATTACHED are enabled in Perm3Capabilities.

---*/
{
    //
    // We only try this on boards that are DFP-capable.
    //

    if (hwDeviceExtension->Perm3Capabilities & PERM3_DFP) {
   
        ULONG rdMisc, vsConf, vsBCtl;
        pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];
        P3RDRAMDAC *pP3RDRegs = (P3RDRAMDAC *)hwDeviceExtension->pRamdac;

        //
        // Get values of registers that we are going to trash
        //

        P3RD_READ_INDEX_REG(P3RD_MISC_CONTROL, rdMisc);

        //
        // Find out the values of the registers
        //

        vsConf = VideoPortReadRegisterUlong(VSTREAM_CONFIG);
        vsBCtl = VideoPortReadRegisterUlong(VSTREAM_B_CONTROL);

        //
        // Clear these bits
        //

        rdMisc &= ~P3RD_MISC_CONTROL_VSB_OUTPUT_ENABLED;
        vsConf &= ~VSTREAM_CONFIG_UNITMODE_MASK;
        vsBCtl &= ~VSTREAM_B_CONTROL_RAMDAC_ENABLE;

        if (hwDeviceExtension->Perm3Capabilities & PERM3_DFP_MON_ATTACHED) {

            //        
            // Enable flat panel output as follows:
            //        

            rdMisc |= P3RD_MISC_CONTROL_VSB_OUTPUT_ENABLED;
            vsConf |= VSTREAM_CONFIG_UNITMODE_FP;
            vsBCtl |= VSTREAM_B_CONTROL_RAMDAC_ENABLE;
        } 
        else {
        
            //        
            // set up the registers for non-DFP mode.
            //        

            rdMisc &= (~P3RD_MISC_CONTROL_VSB_OUTPUT_ENABLED);
            vsConf |= VSTREAM_CONFIG_UNITMODE_CRT;
            vsBCtl |= VSTREAM_B_CONTROL_RAMDAC_DISABLE;
        }
        
        VideoDebugPrint((3, "Perm3: P3RD_ProgramDFP: PXRXCaps 0x%x, misc 0x%x, conf 0x%x, ctl 0x%x\n",
                             hwDeviceExtension->Perm3Capabilities, rdMisc, vsConf, vsBCtl));

        //
        // Program the registers
        //

        P3RD_LOAD_INDEX_REG(P3RD_MISC_CONTROL, rdMisc);
        VideoPortWriteRegisterUlong(VSTREAM_CONFIG, vsConf);
        VideoPortWriteRegisterUlong(VSTREAM_B_CONTROL, vsBCtl);
    }
}


VOID 
I2CWriteClock(
    PVOID HwDeviceExtension, 
    UCHAR data
    )
{
    const ULONG nbitClock = 3;
    const ULONG ClockMask = 1 << nbitClock;
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ul;

    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    ul = VideoPortReadRegisterUlong(DDC_DATA);
    ul &= ~ClockMask;
    ul |= (data & 1) << nbitClock;
    VideoPortWriteRegisterUlong(DDC_DATA, ul);
}

VOID 
I2CWriteData(
    PVOID HwDeviceExtension, 
    UCHAR data
    )
{
    const ULONG nbitData = 2;
    const ULONG DataMask = 1 << nbitData;
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ul;
    
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    ul = VideoPortReadRegisterUlong(DDC_DATA);
    ul &= ~DataMask;
    ul |= ((data & 1) << nbitData);
    VideoPortWriteRegisterUlong(DDC_DATA, ul);
}

BOOLEAN 
I2CReadClock(
    PVOID HwDeviceExtension
    )
{
    const ULONG nbitClock = 1;
    const ULONG ClockMask = 1 << nbitClock;
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ul;
    
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    ul = VideoPortReadRegisterUlong(DDC_DATA);
    ul &= ClockMask;
    ul >>= nbitClock;

    return((BOOLEAN)ul);
}

BOOLEAN 
I2CReadData(
    PVOID HwDeviceExtension
    )
{
    const ULONG nbitData = 0;
    const ULONG DataMask = 1 << nbitData;
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ul;
    
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    ul = VideoPortReadRegisterUlong(DDC_DATA);
    ul &= DataMask;
    ul >>= nbitData;

    return((BOOLEAN)ul);
}


BOOLEAN 
I2CReadDataDFP(
    PHW_DEVICE_EXTENSION hwDeviceExtension 
    )
{
    ULONG ul;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    ul = VideoPortReadRegisterUlong(VSTREAM_SERIAL_CONTROL);
    ul &= VSTREAM_SERIAL_CONTROL_DATAIN;
    return (ul != 0);
}

BOOLEAN 
I2CReadClockDFP(
    PHW_DEVICE_EXTENSION hwDeviceExtension 
    )
{
    ULONG ul;
    
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    ul = VideoPortReadRegisterUlong(VSTREAM_SERIAL_CONTROL);
    ul &= VSTREAM_SERIAL_CONTROL_CLKIN;
    return (ul != 0);
}
VOID
I2CWriteDataDFP(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    UCHAR data 
    )
{
    ULONG ul = 0x0000E000;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    ul |= VideoPortReadRegisterUlong(VSTREAM_SERIAL_CONTROL);

    ul &= ~VSTREAM_SERIAL_CONTROL_DATAOUT;
    if(data & 1)
        ul |= VSTREAM_SERIAL_CONTROL_DATAOUT;
    
    VideoPortWriteRegisterUlong (VSTREAM_SERIAL_CONTROL, ul);
}
VOID
I2CWriteClockDFP(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    UCHAR data 
    )
{
    ULONG ul = 0x0000E000;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    ul |= VideoPortReadRegisterUlong(VSTREAM_SERIAL_CONTROL);

    ul &= ~VSTREAM_SERIAL_CONTROL_CLKOUT;
    if (data & 1)
        ul |= VSTREAM_SERIAL_CONTROL_CLKOUT;

    VideoPortWriteRegisterUlong (VSTREAM_SERIAL_CONTROL, ul);
}

BOOLEAN
GetDFPEdid(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PUCHAR EdidBuffer,
    LONG EdidSize
    )
{
    BOOLEAN DFPPresent = FALSE;

    //
    // If this board is capable of driving a DFP then try using DDC to see
    // if there is a monitor there.
    //

    if (hwDeviceExtension->Perm3Capabilities & PERM3_DFP) {

        //
        // Let's say that we have a monitor attached
        //

        hwDeviceExtension->Perm3Capabilities |= PERM3_DFP_MON_ATTACHED;

        //
        // Set up the DFP accordingly
        //

        ProgramDFP(hwDeviceExtension);

        DFPPresent = VideoPortDDCMonitorHelper(hwDeviceExtension, 
                                               &DDCControlDFP,
                                               EdidBuffer, 
                                               EdidSize);
    }

    //
    // If the board doesn't support flat panel or one isn't attached then
    // configure ourselves for non-DFP working.
    //

    if (!DFPPresent) {

        //
        // Well DDC says we don't have a DFP monitor attached, clear this bit
        //

        hwDeviceExtension->Perm3Capabilities &= ~PERM3_DFP_MON_ATTACHED;

        //
        // Set up the DFP accordingly
        //

        ProgramDFP(hwDeviceExtension);
    }

    return (DFPPresent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\mini\video.c ===
/***************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
*
*   video.c
*
* Abstract:
*
*    This module contains the code to setup the timing values for chips
*    and RAMDACs
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2001 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

#include "perm3.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,InitializeVideo)
#pragma alloc_text(PAGE,P3RD_CalculateMNPForClock)
#pragma alloc_text(PAGE,P4RD_CalculateMNPForClock)
#pragma alloc_text(PAGE,SwitchToHiResMode)
#pragma alloc_text(PAGE,Program_P3RD)
#endif

#define ROTATE_LEFT_DWORD(dWord,cnt) (((cnt) < 0) ? (dWord) >> ((-cnt)) : (dWord) << (cnt))
#define ROTATE_RTIGHT_DWORD(dWord,cnt) (((cnt) < 0) ? (dWord) << ((-cnt)) : (dWord) >> (cnt))

#define INITIALFREQERR 100000

BOOLEAN
InitializeVideo(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PPERM3_VIDEO_FREQUENCIES VideoMode
    )
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PVIDEO_MODE_INFORMATION VideoModeInfo = &VideoMode->ModeEntry->ModeInformation;
    LONG dShift, dStrideShift;
    VESA_TIMING_STANDARD VESATimings;
    ULONG ulValue;
    ULONG Htot, Hss, Hse, Hbe, Hsp;
    ULONG Vtot, Vss, Vse, Vbe, Vsp;
    ULONG PixelClock, Freq, MemClock;
    ULONG RefClkSpeed, SystemClock;    // Speed of clocks in 100Hz units
    ULONG VTGPolarity;
    ULONG M, N, P, C, Q;
    ULONG DacDepth, depth, xRes, yRes;
    ULONG xStride;
    ULONG pixelData;
    ULONG ulMiscCtl;
    ULONG highWater, loWater;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    depth = VideoMode->BitsPerPel;
    xRes = VideoMode->ScreenWidth;
    yRes = VideoMode->ScreenHeight;
    Freq = VideoMode->ScreenFrequency;

    //
    // For timing calculations need full depth in bits
    //

    if ((DacDepth = depth) == 15) {

        DacDepth = 16;

    } else if (depth == 12) {

        DacDepth = 32;
    }

    //
    // Convert screen stride from bytes to pixels
    //

    xStride = (8 * VideoModeInfo->ScreenStride) / DacDepth;

    VideoDebugPrint((3, "Perm3: InitializeVideo called: depth %d, xres %d, yres %d, freq %d, xStride %d\n",
                         depth, xRes, yRes, Freq, xStride));

    //
    // Ensure minimum frequency of 60 Hz
    //

    if ((Freq < 60) && 
        !(hwDeviceExtension->Perm3Capabilities & PERM3_DFP_MON_ATTACHED)) {

        VideoDebugPrint((3, "Perm3: Frequency raised to minimum of 60Hz\n"));
        Freq = 60;
    }

    //
    // Get the video timing, from the registry, if an entry exists, or from
    // the list of defaults, if it doesn't.
    //

    if( !GetVideoTiming(HwDeviceExtension, 
                        xRes, 
                        yRes, 
                        Freq, 
                        DacDepth, 
                        &VESATimings)) {

        VideoDebugPrint((0, "Perm3: GetVideoTiming failed."));
        return (FALSE);
    }

    //
    // We have got a valid set of VESA timigs
    // Extract timings from VESA list in a form that can be programmed into
    // the Perm3 timing generator.
    //

    Htot = GetHtotFromVESA (&VESATimings);
    Hss  = GetHssFromVESA  (&VESATimings);
    Hse  = GetHseFromVESA  (&VESATimings);
    Hbe  = GetHbeFromVESA  (&VESATimings);
    Hsp  = GetHspFromVESA  (&VESATimings);
    Vtot = GetVtotFromVESA (&VESATimings);
    Vss  = GetVssFromVESA  (&VESATimings);
    Vse  = GetVseFromVESA  (&VESATimings);
    Vbe  = GetVbeFromVESA  (&VESATimings);
    Vsp  = GetVspFromVESA  (&VESATimings);

    PixelClock = VESATimings.pClk;

    //
    // At 8BPP, if any of the horizontal parameters have any the bottom
    // bit set then we need to put the chip into 64-bit, pixel-doubling mode.
    //

    hwDeviceExtension->Perm3Capabilities &= ~PERM3_USE_BYTE_DOUBLING;
    
    //
    // If this resolution requires is one that requires pixel doubling then
    // set the flag
    //

    if (P3RD_CHECK_BYTE_DOUBLING(hwDeviceExtension, DacDepth, &VESATimings)) {

        hwDeviceExtension->Perm3Capabilities |= PERM3_USE_BYTE_DOUBLING;
    }

    VideoDebugPrint((3, "Perm3: P3RD %s require pixel-doubling, PXRXCaps 0x%x\n", 
        (hwDeviceExtension->Perm3Capabilities & PERM3_USE_BYTE_DOUBLING) ? "Do" : "Don't",
        hwDeviceExtension->Perm3Capabilities));

    //
    // if we're zooming by 2 in Y then double the vertical timing values.
    //

    if (VideoModeInfo->DriverSpecificAttributeFlags & CAPS_ZOOM_Y_BY2) {
  
        Vtot *= 2;
        Vss  *= 2;
        Vse  *= 2;
        Vbe  *= 2;
        PixelClock *= 2;
    }

    pixelData = PixelClock * (DacDepth / 8);

    if (pixelData > P3_MAX_PIXELDATA) {

        //
        // Failed pixelData validation
        //

        return (FALSE);
    }

    RefClkSpeed = hwDeviceExtension->RefClockSpeed  / 100;   // 100Hz units
    SystemClock = hwDeviceExtension->ChipClockSpeed / 100;   // 100Hz units

    //
    //  We do some basic initialization before setting up MCLK.
    //

    //
    //  disable the video control register
    //

    hwDeviceExtension->VideoControl = 0;

    VideoPortWriteRegisterUlong( VIDEO_CONTROL, 
                                 hwDeviceExtension->VideoControl );

    SwitchToHiResMode(hwDeviceExtension, TRUE);

    //
    // Setup Ramdac.
    //

    if(!Program_P3RD(HwDeviceExtension, 
                     VideoMode, 
                     Hsp, 
                     Vsp, 
                     RefClkSpeed, 
                     &SystemClock, 
                     &PixelClock, 
                     &MemClock)) {

        return(FALSE);
    }

    //
    // Set the LUT cache size to 256 and the first entry to zero, then
    // write the LUT cache to the LUT
    //

    LUT_CACHE_SETSIZE (256);
    LUT_CACHE_SETFIRST (0);

    (VOID) Perm3SetColorLookup (hwDeviceExtension,
                                &(hwDeviceExtension->LUTCache.LUTCache),
                                sizeof (hwDeviceExtension->LUTCache),
                                TRUE,     // Always update RAMDAC 
                                FALSE);   // Don't Update cache entries
    //
    // Setup VTG
    //

    //
    // We have to set or clear byte doubling for Perm3,depending on 
    //the whether the byte doubling capabilities flag is set.
    //

    ulMiscCtl = VideoPortReadRegisterUlong(MISC_CONTROL);

    ulMiscCtl &= ~PXRX_MISC_CONTROL_BYTE_DBL_ENABLE;
    ulMiscCtl |= (hwDeviceExtension->Perm3Capabilities & PERM3_USE_BYTE_DOUBLING) ? 
                  PXRX_MISC_CONTROL_BYTE_DBL_ENABLE : 0;

    VideoPortWriteRegisterUlong(MISC_CONTROL, ulMiscCtl);

    //
    // RAMDAC pll pins for VClkCtl            
    //

    ulValue = 3;   

    //
    // dShift is now used as a rotate count (it can be negative), instead of a
    // shift count. This means it won't work with 24-bit packed framebuffer 
    // layouts.
    //

   if (hwDeviceExtension->Perm3Capabilities & PERM3_USE_BYTE_DOUBLING) {

        //
        // Pretend we have a 64-bit pixel bus
        //

        dShift = DacDepth >> 4;

    } else if (DacDepth > 8) {

        //
        // 128-bit pixel bus
        //

        dShift = DacDepth >> 5; 

    } else  {

        //
        // We need a shift right not left
        //

        dShift = -1;
    }

    //
    // Stride & screenBase in 128-bit units
    //

    dStrideShift = 4;

    //
    // must load HgEnd before ScreenBase
    //

    VideoPortWriteRegisterUlong(HG_END, ROTATE_LEFT_DWORD (Hbe, dShift));
    VideoPortWriteRegisterUlong(V_CLK_CTL, ulValue);

    //
    // We just load the right screenbase with zero (the same as the left).
    // The display driver will update this when stereo buffers have been
    // allocated and stereo apps start running.
    //

    VideoPortWriteRegisterUlong(SCREEN_BASE_RIGHT, 0);
    VideoPortWriteRegisterUlong(SCREEN_BASE,0);
    VideoPortWriteRegisterUlong(SCREEN_STRIDE, (xStride >> dStrideShift) * (DacDepth >> 3)); // 64-bit units
    VideoPortWriteRegisterUlong(H_TOTAL,(ROTATE_LEFT_DWORD (Htot, dShift)) - 1);
    VideoPortWriteRegisterUlong(HS_START, ROTATE_LEFT_DWORD (Hss, dShift));
    VideoPortWriteRegisterUlong(HS_END, ROTATE_LEFT_DWORD (Hse, dShift));
    VideoPortWriteRegisterUlong(HB_END, ROTATE_LEFT_DWORD (Hbe, dShift));
    VideoPortWriteRegisterUlong(V_TOTAL, Vtot - 1);
    VideoPortWriteRegisterUlong(VS_START, Vss - 1);
    VideoPortWriteRegisterUlong(VS_END, Vse - 1);
    VideoPortWriteRegisterUlong(VB_END, Vbe);

    //
    // We need this to ensure that we get interrupts at the right time
    //

    VideoPortWriteRegisterUlong (INTERRUPT_LINE, 0);
            
    //
    // Set up video fifo stuff for Perm3
    //

    if(hwDeviceExtension->Capabilities & CAPS_INTERRUPTS) {
            
        //
        // We can use our reiterative formula. We start by setting
        // the thresholds to sensible values for a lo-res mode
        // (640x480x8) then turn on the FIFO  underrun error interrupt
        // (we do this after the mode change to avoid spurious
        // interrupts). In the interrupt routine we adjust the
        // thresholds whenever we get an underrun error
        //

        loWater = 8;
        highWater = 28;
                
        hwDeviceExtension->VideoFifoControl = (1 << 16) | (highWater << 8) | loWater;

        //
        // we'll want check for video FIFO errors via the error
        // interrupt only for a short time as P3/R3 generates a
        // lot of spurious interrupts too. Use the VBLANK interrupt
        // to time the period that we keep error interrupts enabled
        //

        hwDeviceExtension->VideoFifoControlCountdown = 20 * Freq;

        //
        // Don't actually update this register until we've left 
        // InitializeVideo - we don't want to enable error interrupts 
        // until the mode change has settled
        //

        hwDeviceExtension->IntEnable |= INTR_ERROR_SET | INTR_VBLANK_SET;

        //
        // We want VBLANK interrupts permanently enabled so that we
        // can monitor error flags for video FIFO underruns
        //

        hwDeviceExtension->InterruptControl.ControlBlock.Control |= PXRX_CHECK_VFIFO_IN_VBLANK;

    } else {

        //
        // We don't have interrupts calculate safe thresholds for
        // this mode. The high threshold can be determined using
        // the following formula.
        //

        highWater = ((PixelClock / 80) * (33 * DacDepth)) / MemClock;

        if (highWater < 28) {
               
            highWater = 28 - highWater;

            //
            // Low threshhold should be the lower of highWater/2 or 8.
            //

            loWater = (highWater + 1) / 2;

            if (loWater > 8)
                loWater = 8;

        } else {

            //
            // We don't have an algorithm for this so choose a safe value 
            //

            highWater = 0x01;
            loWater = 0x01;
        }

        hwDeviceExtension->VideoFifoControl = (highWater << 8) | loWater;
    }

    VideoPortWriteRegisterUlong(VIDEO_FIFO_CTL, hwDeviceExtension->VideoFifoControl);
        
    //
    // On a Perm3 set up the memory refresh counter
    // Memory refresh needs to be 64000 times per second.
    //

    ulValue = ((MemClock/640) - 16) / 32;
    VideoPortWriteRegisterUlong(PXRX_LOCAL_MEM_REFRESH, (ulValue << 1) | 1);

    VideoDebugPrint((3, "Perm3: Setting LocalMemRefresh to 0x%x\n", 
                         (ulValue << 1) | 1));

    //
    // enable H & V syncs to active high (the RAMDAC will invert these as necessary)
    // Enable video out.
    //

    VTGPolarity = (1 << 5) | (1 << 3) | 1;
            
    //
    // Set BufferSwapCtl to FreeRunning
    //

    VTGPolarity |= (1 << 9);

    //
    // Set up pixel size, this register is only on PXRX.
    //

    if (DacDepth == 8) {

        VTGPolarity |= (0 << 19);

    } else if (DacDepth == 16) {

        VTGPolarity |= (1 << 19);

    } else if (DacDepth == 32) {

        VTGPolarity |= (2 << 19);
    }

    //
    //  Do not Pitch
    //

    VTGPolarity |= (0 << 18);
            
    //
    // Set the stereo bit if it's enabled.
    //

    if(hwDeviceExtension->Capabilities & CAPS_STEREO) {

        VTGPolarity |= (1 << 11);

        //
        // Set RightEyeCtl bit to 1 as default
        //

        VTGPolarity |= (1 << 12);
    }

    if (VideoModeInfo->DriverSpecificAttributeFlags & CAPS_ZOOM_Y_BY2) {

        VTGPolarity |= (1 << 2);
    }

    hwDeviceExtension->VideoControlMonitorON = VTGPolarity & VC_DPMS_MASK;
    hwDeviceExtension->VideoControl = VTGPolarity;

    VideoPortWriteRegisterUlong( VIDEO_CONTROL, 
                                 hwDeviceExtension->VideoControl );  

    //
    // Record the final chip clock in the registry
    //

    SystemClock *= 100;
    VideoPortSetRegistryParameters(HwDeviceExtension,
                                       L"HardwareInformation.CurrentChipClockSpeed",
                                       &SystemClock,
                                       sizeof(ULONG));
    MemClock *= 100;
    VideoPortSetRegistryParameters(HwDeviceExtension,
                                       L"HardwareInformation.CurrentMemClockSpeed",
                                       &MemClock,
                                       sizeof(ULONG));

    PixelClock *= 100;
    VideoPortSetRegistryParameters(HwDeviceExtension,
                                       L"HardwareInformation.CurrentPixelClockSpeed",
                                       &PixelClock,
                                       sizeof(ULONG));
 
    hwDeviceExtension->bVTGRunning = TRUE;

    VideoDebugPrint((3, "Perm3: InitializeVideo Finished\n"));
    return(TRUE);
}

ULONG 
P3RD_CalculateMNPForClock(
    PVOID HwDeviceExtension,
    ULONG RefClock,        // In 100Hz units
    ULONG ReqClock,        // In 100Hz units
    ULONG *rM,             // M Out (feedback scaler)
    ULONG *rN,             // N Out (prescaler)
    ULONG *rP              // P Out (postscaler)
    )

/*+++

Routine Description:

     Calculates prescaler, feedback scaler and postscaler values for the
     STMACRO PLL71FS used by P3RD.

---*/
{
    const ULONG fMinVCO = 2000000;    // min fVCO is 200MHz (in 100Hz units)
    const ULONG fMaxVCO = 6220000;    // max fVCO is 622MHz (in 100Hz units)
    const ULONG fMinINTREF = 10000;   // min fINTREF is 1MHz (in 100Hz units)
    const ULONG fMaxINTREF = 20000;   // max fINTREF is 2MHz (in 100Hz units)
    ULONG M, N, P;
    ULONG fINTREF;
    ULONG fVCO;
    ULONG ActualClock;
    LONG  Error;
    LONG  LowestError = INITIALFREQERR;
    BOOLEAN bFoundFreq = FALSE;
    LONG  cInnerLoopIterations = 0;
    LONG  LoopCount;
    ULONG fVCOLowest, fVCOHighest;

    for(P = 0; P <= 5; ++P) {

        //
        // it's pointless going through the main loop if all values of
        // N produce an fVCO outside the acceptable range
        //

        N = 1;
        M = (N * (1 << P) * ReqClock) / (2 * RefClock);
        fVCOLowest = (2 * RefClock * M) / N;

        N = 255;
        M = (N * (1 << P) * ReqClock) / (2 * RefClock);
        fVCOHighest = (2 * RefClock * M) / N;

        if(fVCOHighest < fMinVCO || fVCOLowest > fMaxVCO) {

            continue;
        }

        for(N = 1; N <= 255; ++N, ++cInnerLoopIterations) {
       
            fINTREF = RefClock / N;

            if(fINTREF < fMinINTREF || fINTREF > fMaxINTREF) {

                if(fINTREF > fMaxINTREF){

                    //
                    // hopefully we'll get into range as the prescale value
                    // increases
                    //

                    continue;

                } else {

                    //
                    // already below minimum and it'll only get worse: move to
                    // the next postscale value
                    //

                    break;
                }
            }

            M = (N * (1 << P) * ReqClock) / (2 * RefClock);

            if(M > 255) {
            
                //
                // M, N & P registers are only 8 bits wide
                //

                break;
            }

            //
            // We can expect rounding errors in calculating M, which will
            // always be rounded down.  So we'll checkout our calculated
            // value of M along with (M+1)
            //

            for(LoopCount = (M == 255) ? 1 : 2; --LoopCount >= 0; ++M) {
            
                fVCO = (2 * RefClock * M) / N;

                if(fVCO >= fMinVCO && fVCO <= fMaxVCO) {
               
                    ActualClock = fVCO / (1 << P);

                    Error = ActualClock - ReqClock;

                    if(Error < 0)
                        Error = -Error;

                    if(Error < LowestError) {

                        bFoundFreq = TRUE;
                        LowestError = Error;
                        *rM = M;
                        *rN = N;
                        *rP = P;

                        if(Error == 0)
                            goto Done;
                    }
                }
            }
        }
    }

Done:
    
    if(bFoundFreq)
        ActualClock = (2 * RefClock * (*rM)) / ((*rN) * (1 << (*rP)));
    else
        ActualClock = 0;
    
    return(ActualClock);
}

ULONG P4RD_CalculateMNPForClock(
    PVOID hwDeviceExtension,
    ULONG RefClock,        // In 100Hz units
    ULONG ReqClock,        // In 100Hz units
    ULONG *rM,             // M Out (feedback scaler)
    ULONG *rN,             // N Out (prescaler)
    ULONG *rP              // P Out (postscaler)
    )

/*+++

Routine Description:

     Calculates prescaler, feedback scaler and postscaler values for the
     nurlogic NLC_PLL260i used by P4RD.

---*/

{
    const ULONG fMinVCO = 2000000;    // min fVCO is 200MHz (in 100Hz units)
    const ULONG fMaxVCO = 4000000;    // max fVCO is 400MHz (in 100Hz units)
    const ULONG fMinINTREF = 10000;   // min fINTREF is 1MHz (in 100Hz units)
    const ULONG fMaxINTREF = 20000;   // max fINTREF is 2MHz (in 100Hz units)
    ULONG M, N, P;
    ULONG fINTREF;
    ULONG fVCO;
    ULONG ActualClock;
    LONG Error;
    LONG LowestError = INITIALFREQERR;
    BOOLEAN bFoundFreq = FALSE;
    LONG cInnerLoopIterations = 0;
    LONG LoopCount;


    //
    // Actual Equations:
    //        fVCO = (RefClock * M)/(N+1)
    //        PIXELCLOCK = fVCO/(1<<p)
    //        200 <= fVCO <= 400
    //        24 <= M <= 80
    //        1 <= N <= 15
    //        0 <= P <= 3
    //        1Mhz < RefClock/(N+1) <= 2Mhz - not used
    //
    // For refclk == 14.318 we have the tighter equations:
    //        32 <= M <= 80
    //        3 <= N <= 12

    #define P4RD_PLL_MIN_P 0
    #define P4RD_PLL_MAX_P 3
    #define P4RD_PLL_MIN_N 1
    #define P4RD_PLL_MAX_N 12
    #define P4RD_PLL_MIN_M 24
    #define P4RD_PLL_MAX_M 80

    for(P = P4RD_PLL_MIN_P; P <= P4RD_PLL_MAX_P; ++P) {

        ULONG fVCOLowest, fVCOHighest;
  
        //
        // It's pointless going through the main loop if all values 
        // of N produce an fVCO outside the acceptable range
        //

        N = P4RD_PLL_MIN_N;
        M = ((N + 1) * (1 << P) * ReqClock) / RefClock;

        fVCOLowest = (RefClock * M) / (N + 1);

        N = P4RD_PLL_MAX_N;
        M = ((N + 1) * (1 << P) * ReqClock) / RefClock;

        fVCOHighest = (RefClock * M) / (N + 1);

        if(fVCOHighest < fMinVCO || fVCOLowest > fMaxVCO) {

            continue;
        }

        for( N = P4RD_PLL_MIN_N; 
             N <= P4RD_PLL_MAX_N; 
             ++N, ++cInnerLoopIterations ) {

            M = ((N + 1) * (1 << P) * ReqClock) / RefClock;

            if(M > P4RD_PLL_MAX_M || M < P4RD_PLL_MIN_M) {
           
                //
                // M is only 7 bits wide
                //

                continue;
            }

            //
            // We can expect rounding errors in calculating M, which
            // will always be rounded down. So we'll checkout our 
            // calculated value of M along with (M+1)
            //

            for( LoopCount = (M == P4RD_PLL_MAX_M) ? 1 : 2; 
                 --LoopCount >= 0; 
                 ++M ) {

                fVCO = (RefClock * M) / (N + 1);

                if(fVCO >= fMinVCO && fVCO <= fMaxVCO) {
               
                    ActualClock = fVCO / (1 << P);
                    Error = ActualClock - ReqClock;

                    if(Error < 0)
                        Error = -Error;
                    //
                    // It is desirable that we use the lowest value of N if the
                    // frequencies are the same.
                    //

                    if((Error < LowestError) || 
                       (Error == LowestError && N < *rN)) {
                    
                        bFoundFreq = TRUE;
                        LowestError = Error;
                        *rM = M;
                        *rN = N;
                        *rP = P;

                        if(Error == 0)
                            goto Done;
                    }
                }
            }
        }
    }

Done:
   
    if(bFoundFreq)
        ActualClock = (RefClock * (*rM)) / (((*rN) + 1) * (1 <<(*rP)));
    else
        ActualClock = 0;

    return(ActualClock);
}


BOOLEAN Program_P3RD(
    PHW_DEVICE_EXTENSION HwDeviceExtension, 
    PPERM3_VIDEO_FREQUENCIES VideoMode, 
    ULONG Hsp, 
    ULONG Vsp,
    ULONG RefClkSpeed, 
    PULONG pSystemClock, 
    PULONG pPixelClock, 
    PULONG pMemClock
    )

/*+++

Routine Description:

       Initializes the P3RD registers and programs the DClk (pixel clock)
       and MClk (system clock) PLLs. After programming the MClk, the
       contents of all registers in the graphics core, the memory controller
       and the video control should be assumed to be undefined

---*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PVIDEO_MODE_INFORMATION VideoModeInfo = &VideoMode->ModeEntry->ModeInformation;
    ULONG DacDepth, depth;
    ULONG index;
    ULONG color;
    ULONG ulValue;
    UCHAR pixelCtrl;
    ULONG mClkSrc = 0, sClkSrc = 0;
    VP_STATUS status;
    ULONG M, N, P;

    //
    // If we are using 64-bit mode then we need to double the pixel 
    // clock and set the pixel doubling bit in the RAMDAC.
    //

    ULONG pixelClock = (hwDeviceExtension->Perm3Capabilities & PERM3_USE_BYTE_DOUBLING) ? (*pPixelClock) << 1 : (*pPixelClock);        

    //
    // Double the desired system clock as P3 has a divider, which divides 
    // this down again.
    //

    ULONG coreClock = (*pSystemClock << 1);
                                              
    
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];
    P3RDRAMDAC *pP3RDRegs = (P3RDRAMDAC *)hwDeviceExtension->pRamdac;

    mClkSrc = (hwDeviceExtension->bHaveExtendedClocks ? hwDeviceExtension->ulPXRXMemoryClockSrc : P3RD_DEFAULT_MCLK_SRC);
    sClkSrc = (hwDeviceExtension->bHaveExtendedClocks ? hwDeviceExtension->ulPXRXSetupClockSrc: P3RD_DEFAULT_SCLK_SRC);

    depth = VideoMode->BitsPerPel;

    //
    // For timing calculations need full depth in bits
    //

    if ((DacDepth = depth) == 15) {
        DacDepth = 16;
    }
    else if (depth == 12) {
        DacDepth = 32;
    }

    //
    // Set up Misc Control
    //

    P3RD_READ_INDEX_REG(P3RD_MISC_CONTROL, ulValue);

    ulValue &= ~( P3RD_MISC_CONTROL_HIGHCOLORRES | 
                  P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED |
                  P3RD_MISC_CONTROL_PIXEL_DOUBLE );

    P3RD_LOAD_INDEX_REG(P3RD_MISC_CONTROL, 
                        ulValue | 
                        P3RD_MISC_CONTROL_HIGHCOLORRES | 
                        P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED);

    VideoPortWriteRegisterUlong(P3RD_INDEX_CONTROL,
                                P3RD_IDX_CTL_AUTOINCREMENT_ENABLED);

    ulValue = (Hsp ? P3RD_SYNC_CONTROL_HSYNC_ACTIVE_HIGH : P3RD_SYNC_CONTROL_HSYNC_ACTIVE_LOW) |
              (Vsp ? P3RD_SYNC_CONTROL_VSYNC_ACTIVE_HIGH : P3RD_SYNC_CONTROL_VSYNC_ACTIVE_LOW);

    P3RD_LOAD_INDEX_REG(P3RD_SYNC_CONTROL, ulValue);
    P3RD_LOAD_INDEX_REG(P3RD_DAC_CONTROL, 
                        P3RD_DAC_CONTROL_BLANK_PEDESTAL_ENABLED);

    ulValue = 0;

    if (hwDeviceExtension->Perm3Capabilities & PERM3_USE_BYTE_DOUBLING) {
   
        ulValue |= P3RD_CURSOR_CONTROL_DOUBLE_X;
    }

    if (VideoModeInfo->DriverSpecificAttributeFlags & CAPS_ZOOM_Y_BY2) {
   
        ulValue |= P3RD_CURSOR_CONTROL_DOUBLE_Y;
    }

    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_CONTROL,   ulValue);
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_MODE,      0);
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_X_LOW,     0);
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_X_HIGH,    0);
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_Y_LOW,     0);
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_Y_HIGH,    0xff);
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_HOTSPOT_X, 0);
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_HOTSPOT_Y, 0);
    P3RD_LOAD_INDEX_REG(P3RD_PAN, 0);

    //
    // The first 3-color cursor is the mini cursor which is always
    // black & white. Set it up here

    P3RD_CURSOR_PALETTE_CURSOR_RGB(P3RD_CALCULATE_LUT_INDEX(0), 0x00,0x00,0x00);
    P3RD_CURSOR_PALETTE_CURSOR_RGB(P3RD_CALCULATE_LUT_INDEX(1), 0xff,0xff,0xff);

    //
    // Stop all clocks
    //

    P3RD_LOAD_INDEX_REG(P3RD_DCLK_CONTROL, 0);
    P3RD_LOAD_INDEX_REG(P3RD_KCLK_CONTROL, 0);
    P3RD_LOAD_INDEX_REG(P3RD_MCLK_CONTROL, 0);
    P3RD_LOAD_INDEX_REG(P3RD_SCLK_CONTROL, 0);

    //
    // Belt and braces let's set MCLK to something just in case
    // Let's enable SCLK and MCLK.
    //

    *pMemClock = PERMEDIA3_DEFAULT_MCLK_SPEED / 100;  // Convert from Hz to 100 Hz

    VideoDebugPrint((3, "Perm3: Program_P3RD: mClkSrc 0x%x, sClkSrc 0x%x, mspeed %d00\n", 
                         mClkSrc, sClkSrc, *pMemClock));

    P3RD_LOAD_INDEX_REG(P3RD_MCLK_CONTROL, 
                        P3RD_MCLK_CONTROL_ENABLED | 
                        P3RD_MCLK_CONTROL_RUN | mClkSrc);

    P3RD_LOAD_INDEX_REG(P3RD_SCLK_CONTROL, 
                        P3RD_SCLK_CONTROL_ENABLED | 
                        P3RD_SCLK_CONTROL_RUN | 
                        sClkSrc);

    if (hwDeviceExtension->deviceInfo.DeviceId == PERMEDIA3_ID ) {
	
        pixelClock = P3RD_CalculateMNPForClock(HwDeviceExtension, 
                                               RefClkSpeed, 
                                               pixelClock, 
                                               &M,
                                               &N,
                                               &P);
    } else {
	
        pixelClock = P4RD_CalculateMNPForClock(HwDeviceExtension, 
                                               RefClkSpeed, 
                                               pixelClock, 
                                               &M,
                                               &N,
                                               &P);
    }

    if(pixelClock == 0) {
   
        VideoDebugPrint((0, "Perm3: Program_P3RD: P3RD_CalculateMNPForClock(PixelClock) failed\n"));
        return(FALSE);
    }

    //
    // load both copies of the dot clock with our times (DCLK0 & DCLK1 reserved for VGA only)
    //

    P3RD_LOAD_INDEX_REG(P3RD_DCLK2_PRE_SCALE,      N);
    P3RD_LOAD_INDEX_REG(P3RD_DCLK2_FEEDBACK_SCALE, M);
    P3RD_LOAD_INDEX_REG(P3RD_DCLK2_POST_SCALE,     P);

    P3RD_LOAD_INDEX_REG(P3RD_DCLK3_PRE_SCALE,      N);
    P3RD_LOAD_INDEX_REG(P3RD_DCLK3_FEEDBACK_SCALE, M);
    P3RD_LOAD_INDEX_REG(P3RD_DCLK3_POST_SCALE,     P);

    if (hwDeviceExtension->deviceInfo.DeviceId == PERMEDIA3_ID ) {
	
        coreClock = P3RD_CalculateMNPForClock(HwDeviceExtension, 
                                              RefClkSpeed, 
                                              coreClock, 
                                              &M, 
                                              &N, 
                                              &P);
    } else {

        coreClock = P4RD_CalculateMNPForClock(HwDeviceExtension, 
                                              RefClkSpeed, 
                                              coreClock, 
                                              &M, 
                                              &N, 
                                              &P);
    }

    if(coreClock == 0) {
   
        VideoDebugPrint((0, "Perm3: Program_P3RD: P3RD_CalculateMNPForClock(SystemClock) failed\n"));
        return(FALSE);
    }

    //
    // load the core clock
    //

    P3RD_LOAD_INDEX_REG(P3RD_KCLK_PRE_SCALE,      N);
    P3RD_LOAD_INDEX_REG(P3RD_KCLK_FEEDBACK_SCALE, M);
    P3RD_LOAD_INDEX_REG(P3RD_KCLK_POST_SCALE,     P);

    //
    // Enable the dot clock
    //

    P3RD_LOAD_INDEX_REG(P3RD_DCLK_CONTROL, 
                        P3RD_DCLK_CONTROL_ENABLED | P3RD_DCLK_CONTROL_RUN);

    M = 0x100000;

    do {
   
        P3RD_READ_INDEX_REG(P3RD_DCLK_CONTROL, ulValue);
    }
    while((ulValue & P3RD_DCLK_CONTROL_LOCKED) == FALSE && --M);

    if((ulValue & P3RD_DCLK_CONTROL_LOCKED) == FALSE) {
   
        VideoDebugPrint((0, "Perm3: Program_P3RD: PixelClock failed to lock\n"));
        return(FALSE);
    }

    //
    // Enable the core clock
    //

    P3RD_LOAD_INDEX_REG(P3RD_KCLK_CONTROL, 
                        P3RD_KCLK_CONTROL_ENABLED | 
                        P3RD_KCLK_CONTROL_RUN | 
                        P3RD_KCLK_CONTROL_PLL);

    M = 0x100000;

    do {
   
        P3RD_READ_INDEX_REG(P3RD_KCLK_CONTROL, ulValue);
    }

    while((ulValue & P3RD_KCLK_CONTROL_LOCKED) == FALSE && --M);

    if((ulValue & P3RD_KCLK_CONTROL_LOCKED) == FALSE) {
   
        VideoDebugPrint((0, "Perm3: Program_P3RD: SystemClock failed to lock\n"));
        return(FALSE);
    }

    switch (depth) {
    
      case 8:

        P3RD_READ_INDEX_REG(P3RD_MISC_CONTROL, ulValue);
        ulValue &= ~P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
        P3RD_LOAD_INDEX_REG(P3RD_MISC_CONTROL, ulValue);
        P3RD_LOAD_INDEX_REG(P3RD_PIXEL_SIZE, P3RD_PIXEL_SIZE_8BPP);

        //
        // Color indexed mode
        //

        P3RD_LOAD_INDEX_REG(P3RD_COLOR_FORMAT, 
                            P3RD_COLOR_FORMAT_CI8 | P3RD_COLOR_FORMAT_RGB);

        break;

      case 15:
      case 16:

        P3RD_LOAD_INDEX_REG(P3RD_PIXEL_SIZE, P3RD_PIXEL_SIZE_16BPP);

#if  GAMMA_CORRECTION
        P3RD_READ_INDEX_REG(P3RD_MISC_CONTROL, ulValue);
        ulValue &= ~P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
        P3RD_LOAD_INDEX_REG(P3RD_MISC_CONTROL, ulValue);

        //
        // load linear ramp into LUT as default
        //

        for (index = 0; index <= 0xff; ++index) {

            LUT_CACHE_SETRGB (index, index, index, index);
        }

        pixelCtrl = 0;
#else
        P3RD_READ_INDEX_REG(P3RD_MISC_CONTROL, ulValue);
        ulValue |= P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
        P3RD_LOAD_INDEX_REG(P3RD_MISC_CONTROL, ulValue);

        pixelCtrl = P3RD_COLOR_FORMAT_LINEAR_EXT;
#endif
        pixelCtrl |= (depth == 16) ? P3RD_COLOR_FORMAT_16BPP : P3RD_COLOR_FORMAT_15BPP;
        pixelCtrl |= P3RD_COLOR_FORMAT_RGB;

        VideoDebugPrint((3, "Perm3: P3RD_COLOR_FORMAT = 0x%x\n", pixelCtrl));

        P3RD_LOAD_INDEX_REG(P3RD_COLOR_FORMAT, pixelCtrl);
        break;

      case 12:
      case 24:
      case 32:

        P3RD_LOAD_INDEX_REG(P3RD_PIXEL_SIZE, P3RD_PIXEL_SIZE_32BPP);

        P3RD_LOAD_INDEX_REG(P3RD_COLOR_FORMAT, 
                            P3RD_COLOR_FORMAT_32BPP | P3RD_COLOR_FORMAT_RGB);

        if (depth == 12) {
        
            USHORT cacheIndex;

            P3RD_READ_INDEX_REG(P3RD_MISC_CONTROL, ulValue);
            ulValue &= ~P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
            P3RD_LOAD_INDEX_REG(P3RD_MISC_CONTROL, ulValue);

            //
            // use auto-increment to load a ramp into entries 0 to 15
            //

            VideoDebugPrint((3, "Perm3: 12 BPP. loading palette\n"));

            for (index = 0, cacheIndex = 0; 
                 index <= 0xff; 
                 index += 0x11, cacheIndex++) {

                LUT_CACHE_SETRGB (index, index, index, index);
            }

            //
            // load ramp in every 16th entry from 16 to 240
            //

            color = 0x11;

            for (index = 0x10; index <= 0xf0; index += 0x10, color += 0x11) {

                LUT_CACHE_SETRGB (index, color, color, color);
            }

            P3RD_SET_PIXEL_READMASK(0x0f);

        } else {

#if  GAMMA_CORRECTION
            P3RD_READ_INDEX_REG(P3RD_MISC_CONTROL, ulValue);
            ulValue &= ~P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
            P3RD_LOAD_INDEX_REG(P3RD_MISC_CONTROL, ulValue);

            //
            // load linear ramp into LUT as default
            //

            for (index = 0; index <= 0xff; ++index) {
                  LUT_CACHE_SETRGB (index, index, index, index);
            }
#else
            P3RD_READ_INDEX_REG(P3RD_MISC_CONTROL, ulValue);
            ulValue |= P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
            P3RD_LOAD_INDEX_REG(P3RD_MISC_CONTROL, ulValue);

#endif  // GAMMA_CORRECTION

        }

        break;

      default:
          VideoDebugPrint((0, "Perm3: Program_P3RD: bad depth %d \n", depth));

      return(FALSE);

    }

    //
    // Blank the analogue display if we are using a DFP, also re-program the 
    // DFPO because the BIOS may have trashed some of the registers
    // that we programmed at start of day.
    //

    if( hwDeviceExtension->Perm3Capabilities & PERM3_DFP_MON_ATTACHED ) {

        //
        // Only blank the CRT if the mode is less than 60Hz refresh.
        //

        if( VideoMode->ScreenFrequency < 60 ) {

            P3RD_LOAD_INDEX_REG(P3RD_DAC_CONTROL, 1);
        }

        ProgramDFP (hwDeviceExtension);
    }

    //
    // Return these values
    //     *pPixelClock = pixelClock;
    //     *pSystemClock = coreClock;
    //

    switch( mClkSrc ) {
        case P3RD_MCLK_CONTROL_HALF_PCLK:
            *pMemClock = 33 * 10000;
        break;

        case P3RD_MCLK_CONTROL_PCLK:
            *pMemClock = 66 * 10000;
        break;

        case P3RD_MCLK_CONTROL_HALF_EXTMCLK:
            *pMemClock = *pMemClock / 2;
        break;

        case P3RD_MCLK_CONTROL_EXTMCLK:
            //*pMemClock = *pMemClock;
        break;

        case P3RD_MCLK_CONTROL_HALF_KCLK:
            *pMemClock = (coreClock >> 1) / 2;
        break;

        case P3RD_MCLK_CONTROL_KCLK:
            *pMemClock = (coreClock >> 1);
        break;
    }

    return(TRUE);
}

VOID 
SwitchToHiResMode(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    BOOLEAN bHiRes)

/*+++

Routine Description:

    This function switches into and out of hi-res mode

---*/
{
    USHORT usData;
    
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    //
    // Enable graphics mode, disable VGA
    //
    // We have to unlock VGA registers on P3 before we can use them
    //

    UNLOCK_VGA_REGISTERS(); 

    VideoPortWriteRegisterUchar(PERMEDIA_MMVGA_INDEX_REG, PERMEDIA_VGA_CTRL_INDEX);
    usData = (USHORT)VideoPortReadRegisterUchar(PERMEDIA_MMVGA_DATA_REG);

    if(bHiRes) {
        usData &= ~PERMEDIA_VGA_ENABLE;
    } else {
        usData |= PERMEDIA_VGA_ENABLE;
    }

    usData = (usData << 8) | PERMEDIA_VGA_CTRL_INDEX;
    VideoPortWriteRegisterUshort(PERMEDIA_MMVGA_INDEX_REG, usData);

    //
    // We must lock VGA registers on P3 after use
    //

    LOCK_VGA_REGISTERS(); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\8514a\disp\bitblt.c ===
/******************************Module*Header*******************************\
* Module Name: bitblt.c
*
* Contains the high-level DrvBitBlt and DrvCopyBits functions.  The low-
* level stuff lives in 'bltio.c'.
*
* Note: Since we've implemented device-bitmaps, any surface that GDI passes
*       to us can have 3 values for its 'iType': STYPE_BITMAP, STYPE_DEVICE
*       or STYPE_DEVBITMAP.  We filter device-bitmaps that we've stored
*       as DIBs fairly high in the code, so after we adjust its 'pptlSrc',
*       we can treat STYPE_DEVBITMAP surfaces the same as STYPE_DEVICE
*       surfaces (e.g., a blt from an off-screen device bitmap to the screen
*       gets treated as a normal screen-to-screen blt).  So throughout
*       this code, we will compare a surface's 'iType' to STYPE_BITMAP:
*       if it's equal, we've got a true DIB, and if it's unequal, we have
*       a screen-to-screen operation.
*
* Copyright (c) 1992-1994 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

#if !GDI_BANKING || DBG

// This table is big, so include it only when we need it...

/******************************Public*Data*********************************\
* ROP3 translation table
*
* Translates the usual ternary rop into A-vector notation.  Each bit in
* this new notation corresponds to a term in a polynomial translation of
* the rop.
*
* Rop(D,S,P) = a + a D + a S + a P + a  DS + a  DP + a  SP + a   DSP
*               0   d     s     p     ds      dp      sp      dsp
*
\**************************************************************************/

BYTE gajRop3[] =
{
    0x00, 0xff, 0xb2, 0x4d, 0xd4, 0x2b, 0x66, 0x99,
    0x90, 0x6f, 0x22, 0xdd, 0x44, 0xbb, 0xf6, 0x09,
    0xe8, 0x17, 0x5a, 0xa5, 0x3c, 0xc3, 0x8e, 0x71,
    0x78, 0x87, 0xca, 0x35, 0xac, 0x53, 0x1e, 0xe1,
    0xa0, 0x5f, 0x12, 0xed, 0x74, 0x8b, 0xc6, 0x39,
    0x30, 0xcf, 0x82, 0x7d, 0xe4, 0x1b, 0x56, 0xa9,
    0x48, 0xb7, 0xfa, 0x05, 0x9c, 0x63, 0x2e, 0xd1,
    0xd8, 0x27, 0x6a, 0x95, 0x0c, 0xf3, 0xbe, 0x41,
    0xc0, 0x3f, 0x72, 0x8d, 0x14, 0xeb, 0xa6, 0x59,
    0x50, 0xaf, 0xe2, 0x1d, 0x84, 0x7b, 0x36, 0xc9,
    0x28, 0xd7, 0x9a, 0x65, 0xfc, 0x03, 0x4e, 0xb1,
    0xb8, 0x47, 0x0a, 0xf5, 0x6c, 0x93, 0xde, 0x21,
    0x60, 0x9f, 0xd2, 0x2d, 0xb4, 0x4b, 0x06, 0xf9,
    0xf0, 0x0f, 0x42, 0xbd, 0x24, 0xdb, 0x96, 0x69,
    0x88, 0x77, 0x3a, 0xc5, 0x5c, 0xa3, 0xee, 0x11,
    0x18, 0xe7, 0xaa, 0x55, 0xcc, 0x33, 0x7e, 0x81,
    0x80, 0x7f, 0x32, 0xcd, 0x54, 0xab, 0xe6, 0x19,
    0x10, 0xef, 0xa2, 0x5d, 0xc4, 0x3b, 0x76, 0x89,
    0x68, 0x97, 0xda, 0x25, 0xbc, 0x43, 0x0e, 0xf1,
    0xf8, 0x07, 0x4a, 0xb5, 0x2c, 0xd3, 0x9e, 0x61,
    0x20, 0xdf, 0x92, 0x6d, 0xf4, 0x0b, 0x46, 0xb9,
    0xb0, 0x4f, 0x02, 0xfd, 0x64, 0x9b, 0xd6, 0x29,
    0xc8, 0x37, 0x7a, 0x85, 0x1c, 0xe3, 0xae, 0x51,
    0x58, 0xa7, 0xea, 0x15, 0x8c, 0x73, 0x3e, 0xc1,
    0x40, 0xbf, 0xf2, 0x0d, 0x94, 0x6b, 0x26, 0xd9,
    0xd0, 0x2f, 0x62, 0x9d, 0x04, 0xfb, 0xb6, 0x49,
    0xa8, 0x57, 0x1a, 0xe5, 0x7c, 0x83, 0xce, 0x31,
    0x38, 0xc7, 0x8a, 0x75, 0xec, 0x13, 0x5e, 0xa1,
    0xe0, 0x1f, 0x52, 0xad, 0x34, 0xcb, 0x86, 0x79,
    0x70, 0x8f, 0xc2, 0x3d, 0xa4, 0x5b, 0x16, 0xe9,
    0x08, 0xf7, 0xba, 0x45, 0xdc, 0x23, 0x6e, 0x91,
    0x98, 0x67, 0x2a, 0xd5, 0x4c, 0xb3, 0xfe, 0x01
};

BYTE gaRop3FromMix[] =
{
    0xFF,  // R2_WHITE          - Allow rop = gaRop3FromMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE          - Allow rop = gaRop3FromMix[mix & 0xFF]
};

#define AVEC_NOT            0x01
#define AVEC_D              0x02
#define AVEC_S              0x04
#define AVEC_P              0x08
#define AVEC_DS             0x10
#define AVEC_DP             0x20
#define AVEC_SP             0x40
#define AVEC_DSP            0x80
#define AVEC_NEED_SOURCE    (AVEC_S | AVEC_DS | AVEC_SP | AVEC_DSP)
#define AVEC_NEED_PATTERN   (AVEC_P | AVEC_DP | AVEC_SP | AVEC_DSP)
#define AVEC_NEED_DEST      (AVEC_D | AVEC_DS | AVEC_DP | AVEC_DSP)

#endif // GDI_BANKING

/******************************Public*Table********************************\
* BYTE gaulHwMixFromRop2[]
*
* Table to convert from a Source and Destination Rop2 to the hardware's
* mix.
\**************************************************************************/

ULONG gaulHwMixFromRop2[] = {
    LOGICAL_0,                      // 00 -- 0      BLACKNESS
    NOT_SCREEN_AND_NOT_NEW,         // 11 -- DSon   NOTSRCERASE
    SCREEN_AND_NOT_NEW,             // 22 -- DSna
    NOT_NEW,                        // 33 -- Sn     NOSRCCOPY
    NOT_SCREEN_AND_NEW,             // 44 -- SDna   SRCERASE
    NOT_SCREEN,                     // 55 -- Dn     DSTINVERT
    SCREEN_XOR_NEW,                 // 66 -- DSx    SRCINVERT
    NOT_SCREEN_OR_NOT_NEW,          // 77 -- DSan
    SCREEN_AND_NEW,                 // 88 -- DSa    SRCAND
    NOT_SCREEN_XOR_NEW,             // 99 -- DSxn
    LEAVE_ALONE,                    // AA -- D
    SCREEN_OR_NOT_NEW,              // BB -- DSno   MERGEPAINT
    OVERPAINT,                      // CC -- S      SRCCOPY
    NOT_SCREEN_OR_NEW,              // DD -- SDno
    SCREEN_OR_NEW,                  // EE -- DSo    SRCPAINT
    LOGICAL_1                       // FF -- 1      WHITENESS
};

/******************************Public*Table********************************\
* BYTE gajHwMixFromMix[]
*
* Table to convert from a GDI mix value to the hardware's mix.
*
* Ordered so that the mix may be calculated from gajHwMixFromMix[mix & 0xf]
* or gajHwMixFromMix[mix & 0xff].
\**************************************************************************/

BYTE gajHwMixFromMix[] = {
    LOGICAL_1,                      // 0  -- 1
    LOGICAL_0,                      // 1  -- 0
    NOT_SCREEN_AND_NOT_NEW,         // 2  -- DPon
    SCREEN_AND_NOT_NEW,             // 3  -- DPna
    NOT_NEW,                        // 4  -- Pn
    NOT_SCREEN_AND_NEW,             // 5  -- PDna
    NOT_SCREEN,                     // 6  -- Dn
    SCREEN_XOR_NEW,                 // 7  -- DPx
    NOT_SCREEN_OR_NOT_NEW,          // 8  -- DPan
    SCREEN_AND_NEW,                 // 9  -- DPa
    NOT_SCREEN_XOR_NEW,             // 10 -- DPxn
    LEAVE_ALONE,                    // 11 -- D
    SCREEN_OR_NOT_NEW,              // 12 -- DPno
    OVERPAINT,                      // 13 -- P
    NOT_SCREEN_OR_NEW,              // 14 -- PDno
    SCREEN_OR_NEW,                  // 15 -- DPo
    LOGICAL_1                       // 16 -- 1
};

/******************************Public*Table********************************\
* BYTE gajLeftMask[] and BYTE gajRightMask[]
*
* Edge tables for vXferScreenTo1bpp.
\**************************************************************************/

BYTE gajLeftMask[]  = { 0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01 };
BYTE gajRightMask[] = { 0xff, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe };

/******************************Public*Routine******************************\
* BOOL bIntersect
*
* If 'prcl1' and 'prcl2' intersect, has a return value of TRUE and returns
* the intersection in 'prclResult'.  If they don't intersect, has a return
* value of FALSE, and 'prclResult' is undefined.
*
\**************************************************************************/

BOOL bIntersect(
RECTL*  prcl1,
RECTL*  prcl2,
RECTL*  prclResult)
{
    prclResult->left  = max(prcl1->left,  prcl2->left);
    prclResult->right = min(prcl1->right, prcl2->right);

    if (prclResult->left < prclResult->right)
    {
        prclResult->top    = max(prcl1->top,    prcl2->top);
        prclResult->bottom = min(prcl1->bottom, prcl2->bottom);

        if (prclResult->top < prclResult->bottom)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* LONG cIntersect
*
* This routine takes a list of rectangles from 'prclIn' and clips them
* in-place to the rectangle 'prclClip'.  The input rectangles don't
* have to intersect 'prclClip'; the return value will reflect the
* number of input rectangles that did intersect, and the intersecting
* rectangles will be densely packed.
*
\**************************************************************************/

LONG cIntersect(
RECTL*  prclClip,
RECTL*  prclIn,         // List of rectangles
LONG    c)              // Can be zero
{
    LONG    cIntersections;
    RECTL*  prclOut;

    cIntersections = 0;
    prclOut        = prclIn;

    for (; c != 0; prclIn++, c--)
    {
        prclOut->left  = max(prclIn->left,  prclClip->left);
        prclOut->right = min(prclIn->right, prclClip->right);

        if (prclOut->left < prclOut->right)
        {
            prclOut->top    = max(prclIn->top,    prclClip->top);
            prclOut->bottom = min(prclIn->bottom, prclClip->bottom);

            if (prclOut->top < prclOut->bottom)
            {
                prclOut++;
                cIntersections++;
            }
        }
    }

    return(cIntersections);
}

/******************************Public*Routine******************************\
* VOID vXferScreenTo1bpp
*
* Performs a SRCCOPY transfer from the screen (when it's 8bpp) to a 1bpp
* bitmap.
*
\**************************************************************************/

#if defined(i386)

VOID vXferScreenTo1bpp(         // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // List of destination rectangles, in relative
                                //   coordinates
ULONG       ulHwForeMix,        // Not used
ULONG       ulHwBackMix,        // Not used
SURFOBJ*    psoDst,             // Destination surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo)               // Provides colour-compressions information
{

    LONG    cPelSize;
    VOID*   pfnCompute;
    SURFOBJ soTmp;
    ULONG*  pulXlate;
    ULONG   ulForeColor;
    POINTL  ptlSrc;
    RECTL   rclTmp;
    BYTE*   pjDst;
    BYTE    jLeftMask;
    BYTE    jRightMask;
    BYTE    jNotLeftMask;
    BYTE    jNotRightMask;
    LONG    cjMiddle;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    LONG    cyTmpScans;
    LONG    cyThis;
    LONG    cyToGo;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(psoDst->iBitmapFormat == BMF_1BPP, "Only 1bpp destinations");
    ASSERTDD(TMP_BUFFER_SIZE >= (ppdev->cxMemory << ppdev->cPelSize),
                "Temp buffer has to be larger than widest possible scan");

    // When the destination is a 1bpp bitmap, the foreground colour
    // maps to '1', and any other colour maps to '0'.

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // When the source is 8bpp or less, we find the forground colour
        // by searching the translate table for the only '1':

        pulXlate = pxlo->pulXlate;
        while (*pulXlate != 1)
            pulXlate++;

        ulForeColor = pulXlate - pxlo->pulXlate;
    }
    else
    {
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) ||
                 (ppdev->iBitmapFormat == BMF_32BPP),
                 "This routine only supports 8, 16 or 32bpp");

        // When the source has a depth greater than 8bpp, the foreground
        // colour will be the first entry in the translate table we get
        // from calling 'piVector':

        pulXlate = XLATEOBJ_piVector(pxlo);

        ulForeColor = 0;
        if (pulXlate != NULL)           // This check isn't really needed...
            ulForeColor = pulXlate[0];
    }

    // We use the temporary buffer to keep a copy of the source
    // rectangle:

    soTmp.pvScan0 = ppdev->pvTmpBuffer;

    do {
        // ptlSrc points to the upper-left corner of the screen rectangle
        // for the current batch:

        ptlSrc.x = prcl->left + (pptlSrc->x - prclDst->left);
        ptlSrc.y = prcl->top  + (pptlSrc->y - prclDst->top);

        // vGetBits takes absolute coordinates for the source point:

        ptlSrc.x += ppdev->xOffset;
        ptlSrc.y += ppdev->yOffset;

        pjDst = (BYTE*) psoDst->pvScan0 + (prcl->top * psoDst->lDelta)
                                        + (prcl->left >> 3);

        cPelSize = ppdev->cPelSize;

        soTmp.lDelta = (((prcl->right + 7L) & ~7L) - (prcl->left & ~7L))
                       << cPelSize;

        // Our temporary buffer, into which we read a copy of the source,
        // may be smaller than the source rectangle.  In that case, we
        // process the source rectangle in batches.
        //
        // cyTmpScans is the number of scans we can do in each batch.
        // cyToGo is the total number of scans we have to do for this
        // rectangle.
        //
        // We take the buffer size less four so that the right edge case
        // can safely read one dword past the end:

        cyTmpScans = (TMP_BUFFER_SIZE - 4) / soTmp.lDelta;
        cyToGo     = prcl->bottom - prcl->top;

        ASSERTDD(cyTmpScans > 0, "Buffer too small for largest possible scan");

        // Initialize variables that don't change within the batch loop:

        rclTmp.top    = 0;
        rclTmp.left   = prcl->left & 7L;
        rclTmp.right  = (prcl->right - prcl->left) + rclTmp.left;

        // Note that we have to be careful with the right mask so that it
        // isn't zero.  A right mask of zero would mean that we'd always be
        // touching one byte past the end of the scan (even though we
        // wouldn't actually be modifying that byte), and we must never
        // access memory past the end of the bitmap (because we can access
        // violate if the bitmap end is exactly page-aligned).

        jLeftMask     = gajLeftMask[rclTmp.left & 7];
        jRightMask    = gajRightMask[rclTmp.right & 7];
        cjMiddle      = ((rclTmp.right - 1) >> 3) - (rclTmp.left >> 3) - 1;

        if (cjMiddle < 0)
        {
            // The blt starts and ends in the same byte:

            jLeftMask &= jRightMask;
            jRightMask = 0;
            cjMiddle   = 0;
        }

        jNotLeftMask  = ~jLeftMask;
        jNotRightMask = ~jRightMask;
        lDstDelta     = psoDst->lDelta - cjMiddle - 2;
                                // Delta from the end of the destination
                                //  to the start on the next scan, accounting
                                //  for 'left' and 'right' bytes

        lSrcDelta     = soTmp.lDelta - ((8 * (cjMiddle + 2)) << cPelSize);
                                // Compute source delta for special cases
                                //  like when cjMiddle gets bumped up to '0',
                                //  and to correct aligned cases

        do {
            // This is the loop that breaks the source rectangle into
            // manageable batches.

            cyThis  = cyTmpScans;
            cyToGo -= cyThis;
            if (cyToGo < 0)
                cyThis += cyToGo;

            rclTmp.bottom = cyThis;

            vGetBits(ppdev, &soTmp, &rclTmp, &ptlSrc);

            ptlSrc.y += cyThis;         // Get ready for next batch loop

            _asm {
                mov     eax,ulForeColor     ;eax = foreground colour
                                            ;ebx = temporary storage
                                            ;ecx = count of middle dst bytes
                                            ;dl  = destination byte accumulator
                                            ;dh  = temporary storage
                mov     esi,soTmp.pvScan0   ;esi = source pointer
                mov     edi,pjDst           ;edi = destination pointer

                ; Figure out the appropriate compute routine:

                mov     ebx,cPelSize
                mov     pfnCompute,offset Compute_Destination_Byte_From_8bpp
                dec     ebx
                jl      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_16bpp
                dec     ebx
                jl      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_32bpp

            Do_Left_Byte:
                call    pfnCompute
                and     dl,jLeftMask
                mov     dh,jNotLeftMask
                and     dh,[edi]
                or      dh,dl
                mov     [edi],dh
                inc     edi
                mov     ecx,cjMiddle
                dec     ecx
                jl      short Do_Right_Byte

            Do_Middle_Bytes:
                call    pfnCompute
                mov     [edi],dl
                inc     edi
                dec     ecx
                jge     short Do_Middle_Bytes

            Do_Right_Byte:
                call    pfnCompute
                and     dl,jRightMask
                mov     dh,jNotRightMask
                and     dh,[edi]
                or      dh,dl
                mov     [edi],dh
                inc     edi

                add     edi,lDstDelta
                add     esi,lSrcDelta
                dec     cyThis
                jnz     short Do_Left_Byte

                mov     pjDst,edi               ;save for next batch

                jmp     All_Done

            Compute_Destination_Byte_From_8bpp:
                mov     bl,[esi]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 0

                mov     bl,[esi+1]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 1

                mov     bl,[esi+2]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 2

                mov     bl,[esi+3]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 3

                mov     bl,[esi+4]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 4

                mov     bl,[esi+5]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 5

                mov     bl,[esi+6]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 6

                mov     bl,[esi+7]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 7

                add     esi,8                   ;advance the source
                ret

            Compute_Destination_Byte_From_16bpp:
                mov     bx,[esi]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 0

                mov     bx,[esi+2]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 1

                mov     bx,[esi+4]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 2

                mov     bx,[esi+6]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 3

                mov     bx,[esi+8]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 4

                mov     bx,[esi+10]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 5

                mov     bx,[esi+12]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 6

                mov     bx,[esi+14]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 7

                add     esi,16                  ;advance the source
                ret

            Compute_Destination_Byte_From_32bpp:
                mov     ebx,[esi]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 0

                mov     ebx,[esi+4]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 1

                mov     ebx,[esi+8]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 2

                mov     ebx,[esi+12]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 3

                mov     ebx,[esi+16]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 4

                mov     ebx,[esi+20]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 5

                mov     ebx,[esi+24]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 6

                mov     ebx,[esi+28]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 7

                add     esi,32                  ;advance the source
                ret

            All_Done:
            }
        } while (cyToGo > 0);

        prcl++;
    } while (--c != 0);
}

#endif // i386

/******************************Public*Routine******************************\
* VOID vMaskRopB8orE2
*
* Performs a 'b8' or 'e2' rop3 when the source is 1bpp or the same colour
* depth as the display with no translate (can be either a DIB or off-screen
* DFB).  Uses the hardware in three passes.
*
\**************************************************************************/

VOID vMaskRopB8orE2(            // Type FNMASK
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of destination rectangles, in relative
                                //   coordinates
ULONG           ulHwForeMix,    // SCREEN_AND_NEW if rop b8,
                                //   SCREEN_AND_NOT_NEW if rop e2
ULONG           ulHwBackMix,    // Not used
SURFOBJ*        psoMsk,         // Not used
POINTL*         pptlMsk,        // Not used
SURFOBJ*        psoSrc,         // Source surface of blt (1bpp or native)
POINTL*         pptlSrc,        // Original unclipped source point
RECTL*          prclDst,        // Original unclipped destination rectangle
ULONG           iSolidColor,    // Colour, 0xffffffff is pattern should be used
RBRUSH*         prb,            // Pointer to our brush realization, if needed
POINTL*         pptlBrush,      // Pattern alignment if needed
XLATEOBJ*       pxlo)           // Translation data if needed
{
    FNFILL*         pfnFill;
    FNXFER*         pfnXfer;
    RBRUSH_COLOR    rbc;

    ASSERTDD((psoSrc->iType == STYPE_BITMAP) || !OVERLAP(prclDst, pptlSrc),
             "Can't overlap on screen-to-screen operations!");
    ASSERTDD((psoSrc->iBitmapFormat == BMF_1BPP) ||
             (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL),
             "Can handle xlates only on 1bpp transfers");
    ASSERTDD((psoSrc->iBitmapFormat == BMF_1BPP) ||
             (psoSrc->iType != STYPE_BITMAP)     ||
             (psoSrc->iBitmapFormat == ppdev->iBitmapFormat),
             "Can handle only 1bpp or native sources");
    ASSERTDD((ulHwForeMix == SCREEN_AND_NOT_NEW) ||
             (ulHwForeMix == SCREEN_AND_NEW),
             "Unexpected mix");

    if (iSolidColor != -1)
    {
        pfnFill         = ppdev->pfnFillSolid;
        rbc.iSolidColor = iSolidColor;
    }
    else
    {
        pfnFill = ppdev->pfnFillPat;
        rbc.prb = prb;
    }

    // 'b8' is 'DSDPxax', and that's exactly what we do:

    pfnFill(ppdev, c, prcl, SCREEN_XOR_NEW, SCREEN_XOR_NEW, rbc, pptlBrush);

    if (psoSrc->iType != STYPE_BITMAP)
        ppdev->pfnCopyBlt(ppdev, c, prcl, ulHwForeMix, pptlSrc, prclDst);
    else
    {
        if (psoSrc->iBitmapFormat == BMF_1BPP)
            pfnXfer = ppdev->pfnXfer1bpp;
        else
            pfnXfer = ppdev->pfnXferNative;

        pfnXfer(ppdev, c, prcl, ulHwForeMix, ulHwForeMix, psoSrc, pptlSrc,
                prclDst, pxlo);
    }

    pfnFill(ppdev, c, prcl, SCREEN_XOR_NEW, SCREEN_XOR_NEW, rbc, pptlBrush);
}

/******************************Public*Routine******************************\
* VOID vMaskRop69or96
*
* Performs a '69' or '96' rop3 when the source is 1bpp or the same colour
* depth as the display with no translate (can be either a DIB or off-screen
* DFB).  Uses the hardware in two passes.
*
\**************************************************************************/

VOID vMaskRop69or96(            // Type FNMASK
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of destination rectangles, in relative
                                //   coordinates
ULONG           ulHwForeMix,    // NOT_SCREEN_XOR_NEW if rop 69,
                                //  SCREEN_XOR_NEW if rop 96
ULONG           ulHwBackMix,    // Not used
SURFOBJ*        psoMsk,         // Not used
POINTL*         pptlMsk,        // Not used
SURFOBJ*        psoSrc,         // Source surface of blt (1bpp or native)
POINTL*         pptlSrc,        // Original unclipped source point
RECTL*          prclDst,        // Original unclipped destination rectangle
ULONG           iSolidColor,    // Colour, 0xffffffff is pattern should be used
RBRUSH*         prb,            // Pointer to our brush realization, if needed
POINTL*         pptlBrush,      // Pattern alignment if needed
XLATEOBJ*       pxlo)           // Translation data if needed
{
    FNFILL*         pfnFill;
    FNXFER*         pfnXfer;
    RBRUSH_COLOR    rbc;

    ASSERTDD((psoSrc->iType == STYPE_BITMAP) || !OVERLAP(prclDst, pptlSrc),
             "Can't overlap on screen-to-screen operations!");
    ASSERTDD((psoSrc->iBitmapFormat == BMF_1BPP) ||
             (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL),
             "Can handle xlates only on 1bpp transfers");
    ASSERTDD((psoSrc->iBitmapFormat == BMF_1BPP) ||
             (psoSrc->iType != STYPE_BITMAP)     ||
             (psoSrc->iBitmapFormat == ppdev->iBitmapFormat),
             "Can handle only 1bpp or native sources");
    ASSERTDD((ulHwForeMix == NOT_SCREEN_XOR_NEW) ||
             (ulHwForeMix == SCREEN_XOR_NEW),
             "Unexpected mix");

    if (iSolidColor != -1)
    {
        pfnFill         = ppdev->pfnFillSolid;
        rbc.iSolidColor = iSolidColor;
    }
    else
    {
        pfnFill = ppdev->pfnFillPat;
        rbc.prb = prb;
    }

    // '69' is 'PDSxxn', and that is exactly what we do:

    if (psoSrc->iType != STYPE_BITMAP)
        ppdev->pfnCopyBlt(ppdev, c, prcl, SCREEN_XOR_NEW, pptlSrc, prclDst);
    else
    {
        if (psoSrc->iBitmapFormat == BMF_1BPP)
            pfnXfer = ppdev->pfnXfer1bpp;
        else
            pfnXfer = ppdev->pfnXferNative;

        pfnXfer(ppdev, c, prcl, SCREEN_XOR_NEW, SCREEN_XOR_NEW, psoSrc, pptlSrc,
                prclDst, pxlo);
    }

    // XOR is commutative, but we do the bitmap transfer first so that
    // we don't have to sit around waiting for the patblt to finish:

    pfnFill(ppdev, c, prcl, ulHwForeMix, ulHwForeMix, rbc, pptlBrush);
}

/******************************Public*Routine******************************\
* VOID vMaskRopAACCorCCAA
*
* Performs an 'AACC' or 'CCAA' simple MaskBlt in three passes using the
* hardware when the source is in off-screen memory.
*
\**************************************************************************/

VOID vMaskRopAACCorCCAA(        // Type FNMASK
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // Array of relative coordinates destination
                                //   rectangles
ULONG           ulHwForeMix,    // Foreground mix
ULONG           ulHwBackMix,    // Background mix
SURFOBJ*        psoMsk,         // Mask surface
POINTL*         pptlMsk,        // Original unclipped mask source point
SURFOBJ*        psoSrc,         // Not used
POINTL*         pptlSrc,        // Original unclipped source point
RECTL*          prclDst,        // Original unclipped destination rectangle
ULONG           iSolidColor,    // Not used
RBRUSH*         prb,            // Not used
POINTL*         pptlBrush,      // Not used
XLATEOBJ*       pxlo)           // Not used
{
    XLATEOBJ    xlo;
    XLATECOLORS xlc;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(pptlMsk != NULL, "Can't have a NULL pptlmask");
    ASSERTDD(psoMsk->iBitmapFormat == BMF_1BPP, "Can only be a 1bpp mask");
    ASSERTDD(!OVERLAP(prclDst, pptlSrc), "Source and dest can't overlap!");
    ASSERTDD((ulHwForeMix == SCREEN_AND_NEW) ||
             (ulHwForeMix == SCREEN_AND_NOT_NEW),
             "Unexpected mix");

    // Fake up a translate:

    xlc.iForeColor = (ULONG) -1;
    xlc.iBackColor = 0;
    xlo.pulXlate   = (ULONG*) &xlc;

    // First XOR the source, then AND the mask, then XOR the source again:

    ppdev->pfnCopyBlt(ppdev, c, prcl, SCREEN_XOR_NEW, pptlSrc, prclDst);

    ppdev->pfnXfer1bpp(ppdev, c, prcl, ulHwForeMix, ulHwForeMix, psoMsk,
                       pptlMsk, prclDst, &xlo);

    ppdev->pfnCopyBlt(ppdev, c, prcl, SCREEN_XOR_NEW, pptlSrc, prclDst);
}

/******************************Public*Routine******************************\
* BOOL bPuntBlt
*
* Has GDI do any drawing operations that we don't specifically handle
* in the driver.
*
\**************************************************************************/

BOOL bPuntBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    #if DBG
    {
        //////////////////////////////////////////////////////////////////////
        // Diagnostics
        //
        // Since calling the engine to do any drawing can be rather painful,
        // particularly when the source is an off-screen DFB (since GDI will
        // have to allocate a DIB and call us to make a temporary copy before
        // it can even start drawing), we'll try to avoid it as much as
        // possible.
        //
        // Here we simply spew out information describing the blt whenever
        // this routine gets called (checked builds only, of course):

        ULONG ulClip;
        PDEV* ppdev;
        ULONG ulAvec;

        if (psoDst->iType != STYPE_BITMAP)
            ppdev = (PDEV*) psoDst->dhpdev;
        else
            ppdev = (PDEV*) psoSrc->dhpdev;

        ulClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

        DISPDBG((1, ">> Punt << Dst format: %li Dst type: %li Clip: %li Rop: %lx",
            psoDst->iBitmapFormat, psoDst->iType, ulClip, rop4));

        if (psoSrc != NULL)
            DISPDBG((1, "        << Src format: %li Src type: %li",
                psoSrc->iBitmapFormat, psoSrc->iType));

        if ((pxlo != NULL) && !(pxlo->flXlate & XO_TRIVIAL) && (psoSrc != NULL))
        {
            if (((psoSrc->iType == STYPE_BITMAP) &&
                 (psoSrc->iBitmapFormat != ppdev->iBitmapFormat)) ||
                ((psoDst->iType == STYPE_BITMAP) &&
                 (psoDst->iBitmapFormat != ppdev->iBitmapFormat)))
            {
                // Don't bother printing the 'xlate' message when the source
                // is a different bitmap format from the destination -- in
                // those cases we know there always has to be a translate.
            }
            else
            {
                DISPDBG((1, "        << With xlate"));
            }
        }

        // The high 2 bytes of rop4 is not guaranteed to be zero. So in order
        // to get the low 8 bits as index, we have to &ffff before do >>
        ulAvec = gajRop3[rop4 & 0xff] | gajRop3[(rop4 & 0xffff) >> 8];

        if ((ulAvec & AVEC_NEED_PATTERN) && (pbo->iSolidColor == -1))
        {
            if (pbo->pvRbrush == NULL)
                DISPDBG((1, "        << With brush -- Not created"));
            else
                DISPDBG((1, "        << With brush -- Created Ok"));
        }
    }
    #endif

    #if GDI_BANKING
    {
        //////////////////////////////////////////////////////////////////////
        // Banked Framebuffer bPuntBlt
        //
        // This section of code handles a PuntBlt when GDI can directly draw
        // on the framebuffer, but the drawing has to be done in banks:

        BANK     bnk;
        PDEV*    ppdev;
        BOOL     b;
        HSURF    hsurfTmp;
        SURFOBJ* psoTmp;
        SIZEL    sizl;
        POINTL   ptlSrc;
        RECTL    rclTmp;
        RECTL    rclDst;

        // We copy the original destination rectangle, and use that in every
        // GDI call-back instead of the original because sometimes GDI is
        // sneaky and points 'prclDst' to '&pco->rclBounds'.  Because we
        // modify 'rclBounds', that would affect 'prclDst', which we don't
        // want to happen:

        rclDst = *prclDst;

        if ((psoSrc == NULL) || (psoSrc->iType == STYPE_BITMAP))
        {
            ASSERTDD(psoDst->iType != STYPE_BITMAP,
                     "Dest should be the screen when given a DIB source");

            // Do a memory-to-screen blt:

            ppdev = (PDEV*) psoDst->dhpdev;

            vBankStart(ppdev, &rclDst, pco, &bnk);

            b = TRUE;
            do {
                b &= EngBitBlt(bnk.pso, psoSrc, psoMsk, bnk.pco, pxlo,
                               &rclDst, pptlSrc, pptlMsk, pbo, pptlBrush,
                               rop4);

            } while (bBankEnum(&bnk));
        }
        else
        {
            // The screen is the source (it may be the destination too...)

            ppdev = (PDEV*) psoSrc->dhpdev;

            ptlSrc.x = pptlSrc->x + ppdev->xOffset;
            ptlSrc.y = pptlSrc->y + ppdev->yOffset;

            if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
            {
                // We have to intersect the destination rectangle with
                // the clip bounds if there is one (consider the case
                // where the app asked to blt a really, really big
                // rectangle from the screen -- prclDst would be really,
                // really big but pco->rclBounds would be the actual
                // area of interest):

                rclDst.left   = max(rclDst.left,   pco->rclBounds.left);
                rclDst.top    = max(rclDst.top,    pco->rclBounds.top);
                rclDst.right  = min(rclDst.right,  pco->rclBounds.right);
                rclDst.bottom = min(rclDst.bottom, pco->rclBounds.bottom);

                // Correspondingly, we have to offset the source point:

                ptlSrc.x += (rclDst.left - prclDst->left);
                ptlSrc.y += (rclDst.top - prclDst->top);
            }

            // We're now either going to do a screen-to-screen or screen-to-DIB
            // blt.  In either case, we're going to create a temporary copy of
            // the source.  (Why do we do this when GDI could do it for us?
            // GDI would create a temporary copy of the DIB for every bank
            // call-back!)

            sizl.cx = rclDst.right  - rclDst.left;
            sizl.cy = rclDst.bottom - rclDst.top;

            // Don't forget to convert from relative to absolute coordinates
            // on the source!  (vBankStart takes care of that for the
            // destination.)

            rclTmp.right  = sizl.cx;
            rclTmp.bottom = sizl.cy;
            rclTmp.left   = 0;
            rclTmp.top    = 0;

            // GDI does guarantee us that the blt extents have already been
            // clipped to the surface boundaries (we don't have to worry
            // here about trying to read where there isn't video memory).
            // Let's just assert to make sure:

            ASSERTDD((ptlSrc.x >= 0) &&
                     (ptlSrc.y >= 0) &&
                     (ptlSrc.x + sizl.cx <= ppdev->cxMemory) &&
                     (ptlSrc.y + sizl.cy <= ppdev->cyMemory),
                     "Source rectangle out of bounds!");

            hsurfTmp = (HSURF) EngCreateBitmap(sizl,
                                               0,    // Let GDI choose ulWidth
                                               ppdev->iBitmapFormat,
                                               0,    // Don't need any options
                                               NULL);// Let GDI allocate

            if (hsurfTmp != 0)
            {
                psoTmp = EngLockSurface(hsurfTmp);

                if (psoTmp != NULL)
                {
                    vGetBits(ppdev, psoTmp, &rclTmp, &ptlSrc);

                    if (psoDst->iType == STYPE_BITMAP)
                    {
                        // It was a Screen-to-DIB blt; now it's a DIB-to-DIB
                        // blt.  Note that the source point is (0, 0) in our
                        // temporary surface:

                        b = EngBitBlt(psoDst, psoTmp, psoMsk, pco, pxlo,
                                      &rclDst, (POINTL*) &rclTmp, pptlMsk,
                                      pbo, pptlBrush, rop4);
                    }
                    else
                    {
                        // It was a Screen-to-Screen blt; now it's a DIB-to-
                        // screen blt.  Note that the source point is (0, 0)
                        // in our temporary surface:

                        vBankStart(ppdev, &rclDst, pco, &bnk);

                        b = TRUE;
                        do {
                            b &= EngBitBlt(bnk.pso, psoTmp, psoMsk, bnk.pco,
                                           pxlo, &rclDst, (POINTL*) &rclTmp,
                                           pptlMsk, pbo, pptlBrush, rop4);

                        } while (bBankEnum(&bnk));
                    }

                    EngUnlockSurface(psoTmp);
                }

                EngDeleteSurface(hsurfTmp);
            }
        }

        return(b);
    }
    #else
    {
        //////////////////////////////////////////////////////////////////////
        // Really Slow bPuntBlt
        //
        // Here we handle a PuntBlt when GDI can't draw directly on the
        // framebuffer (as on the Alpha, which can't do it because of its
        // 32 bit bus).  If you thought the banked version was slow, just
        // look at this one.  Guaranteed, there will be at least one bitmap
        // allocation and extra copy involved; there could be two if it's a
        // screen-to-screen operation.

        PDEV*   ppdev;
        POINTL  ptlSrc;
        RECTL   rclDst;
        SIZEL   sizl;
        ULONG   ulAvec;
        BOOL    bSrcIsScreen;
        HSURF   hsurfSrc;
        RECTL   rclTmp;
        BOOL    b;
        LONG    lDelta;
        BYTE*   pjBits;
        BYTE*   pjScan0;
        HSURF   hsurfDst;
        RECTL   rclScreen;

        b = FALSE;          // Fore error cases, assume we'll fail

        rclDst = *prclDst;
        if (pptlSrc != NULL)
            ptlSrc = *pptlSrc;

        if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
        {
            // We have to intersect the destination rectangle with
            // the clip bounds if there is one (consider the case
            // where the app asked to blt a really, really big
            // rectangle from the screen -- prclDst would be really,
            // really big but pco->rclBounds would be the actual
            // area of interest):

            rclDst.left   = max(rclDst.left,   pco->rclBounds.left);
            rclDst.top    = max(rclDst.top,    pco->rclBounds.top);
            rclDst.right  = min(rclDst.right,  pco->rclBounds.right);
            rclDst.bottom = min(rclDst.bottom, pco->rclBounds.bottom);

            ptlSrc.x += (rclDst.left - prclDst->left);
            ptlSrc.y += (rclDst.top  - prclDst->top);
        }

        sizl.cx = rclDst.right  - rclDst.left;
        sizl.cy = rclDst.bottom - rclDst.top;

        // The high 2 bytes of rop4 is not guaranteed to be zero. So in order
        // to get the low 8 bits as index, we have to &ffff before do >>
        ulAvec = gajRop3[rop4 & 0xff] | gajRop3[(rop4 & 0xffff) >> 8];

        bSrcIsScreen = ((ulAvec & AVEC_NEED_SOURCE) &&
                        (psoSrc->iType != STYPE_BITMAP));

        if (bSrcIsScreen)
        {
            ppdev = (PDEV*) psoSrc->dhpdev;

            // We need to create a copy of the source rectangle:

            hsurfSrc = (HSURF) EngCreateBitmap(sizl, 0, ppdev->iBitmapFormat,
                                               0, NULL);
            if (hsurfSrc == 0)
                goto Error_0;

            psoSrc = EngLockSurface(hsurfSrc);
            if (psoSrc == NULL)
                goto Error_1;

            rclTmp.left   = 0;
            rclTmp.top    = 0;
            rclTmp.right  = sizl.cx;
            rclTmp.bottom = sizl.cy;

            // vGetBits takes absolute coordinates for the source point:

            ptlSrc.x += ppdev->xOffset;
            ptlSrc.y += ppdev->yOffset;

            vGetBits(ppdev, psoSrc, &rclTmp, &ptlSrc);

            // The source will now come from (0, 0) of our temporary source
            // surface:

            ptlSrc.x = 0;
            ptlSrc.y = 0;
        }

        if (psoDst->iType == STYPE_BITMAP)
        {
            b = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, &rclDst, &ptlSrc,
                          pptlMsk, pbo, pptlBrush, rop4);
        }
        else
        {
            ppdev = (PDEV*) psoDst->dhpdev;

            // We need to create a temporary work buffer.  We have to do
            // some fudging with the offsets so that the upper-left corner
            // of the (relative coordinates) clip object bounds passed to
            // GDI will be transformed to the upper-left corner of our
            // temporary bitmap.

            // The alignment doesn't have to be as tight as this at 16bpp
            // and 32bpp, but it won't hurt:

            lDelta = (((rclDst.right + 3) & ~3L) - (rclDst.left & ~3L))
                   << ppdev->cPelSize;

            // We're actually only allocating a bitmap that is 'sizl.cx' x
            // 'sizl.cy' in size:

            pjBits = EngAllocMem(0, lDelta * sizl.cy, ALLOC_TAG);
            if (pjBits == NULL)
                goto Error_2;

            // We now adjust the surface's 'pvScan0' so that when GDI thinks
            // it's writing to pixel (rclDst.top, rclDst.left), it will
            // actually be writing to the upper-left pixel of our temporary
            // bitmap:

            pjScan0 = pjBits - (rclDst.top * lDelta)
                             - ((rclDst.left & ~3L) << ppdev->cPelSize);

            ASSERTDD((((ULONG) pjScan0) & 3) == 0,
                    "pvScan0 must be dword aligned!");

            // The checked build of GDI sometimes checks on blts that
            // prclDst->right <= pso->sizl.cx, so we lie to it about
            // the size of our bitmap:

            sizl.cx = rclDst.right;
            sizl.cy = rclDst.bottom;

            hsurfDst = (HSURF) EngCreateBitmap(
                        sizl,                   // Bitmap covers rectangle
                        lDelta,                 // Use this delta
                        ppdev->iBitmapFormat,   // Same colour depth
                        BMF_TOPDOWN,            // Must have a positive delta
                        pjScan0);               // Where (0, 0) would be

            if ((hsurfDst == 0) ||
                (!EngAssociateSurface(hsurfDst, ppdev->hdevEng, 0)))
                goto Error_3;

            psoDst = EngLockSurface(hsurfDst);
            if (psoDst == NULL)
                goto Error_4;

            // Make sure that the rectangle we Get/Put from/to the screen
            // is in absolute coordinates:

            rclScreen.left   = rclDst.left   + ppdev->xOffset;
            rclScreen.right  = rclDst.right  + ppdev->xOffset;
            rclScreen.top    = rclDst.top    + ppdev->yOffset;
            rclScreen.bottom = rclDst.bottom + ppdev->yOffset;

            // It would be nice to get a copy of the destination rectangle
            // only when the ROP involves the destination (or when the source
            // is an RLE), but we can't do that.  If the brush is truly NULL,
            // GDI will immediately return TRUE from EngBitBlt, without
            // modifying the temporary bitmap -- and we would proceed to
            // copy the uninitialized temporary bitmap back to the screen.

            vGetBits(ppdev, psoDst, &rclDst, (POINTL*) &rclScreen);

            b = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, &rclDst, &ptlSrc,
                          pptlMsk, pbo, pptlBrush, rop4);

            vPutBits(ppdev, psoDst, &rclScreen, (POINTL*) &rclDst);

            EngUnlockSurface(psoDst);

        Error_4:

            EngDeleteSurface(hsurfDst);

        Error_3:

            EngFreeMem(pjBits);
        }

        Error_2:

        if (bSrcIsScreen)
        {
            EngUnlockSurface(psoSrc);

        Error_1:

            EngDeleteSurface(hsurfSrc);
        }

        Error_0:

        return(b);
    }
    #endif
}

/******************************Public*Routine******************************\
* BOOL DrvBitBlt
*
* Implements the workhorse routine of a display driver.
*
\**************************************************************************/

BOOL DrvBitBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    PDEV*           ppdev;
    DSURF*          pdsurfDst;
    DSURF*          pdsurfSrc;
    POINTL          ptlSrc;
    BYTE            jClip;
    BOOL            bMore;
    ULONG           ulHwForeMix;
    ULONG           ulHwBackMix;
    CLIPENUM        ce;
    LONG            c;
    RECTL           rcl;
    ULONG           rop2;
    ULONG           rop3;
    FNFILL*         pfnFill;
    FNMASK*         pfnMask;
    RBRUSH_COLOR    rbc;         // Realized brush or solid colour
    ULONG           iSolidColor;
    RBRUSH*         prb;
    XLATECOLORS     xlc;
    XLATEOBJ        xlo;
    ULONG*          pulXlate;
    ULONG           ulTmp;
    FNXFER*         pfnXfer;
    ULONG           iSrcBitmapFormat;
    ULONG           iDir;

    jClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if (psoSrc == NULL)
    {
        ///////////////////////////////////////////////////////////////////
        // Fills
        ///////////////////////////////////////////////////////////////////

        // Fills are this function's "raison d'etre" (which is French
        // for "purple armadillo"), so we handle them as quickly as
        // possible:

        pdsurfDst = (DSURF*) psoDst->dhsurf;

        ASSERTDD((psoDst->iType == STYPE_DEVICE) ||
                 (psoDst->iType == STYPE_DEVBITMAP),
                 "Expect only device destinations when no source");

        if (pdsurfDst->dt == DT_SCREEN)
        {
            ppdev = (PDEV*) psoDst->dhpdev;

            ppdev->xOffset = pdsurfDst->poh->x;
            ppdev->yOffset = pdsurfDst->poh->y;

            // Make sure it doesn't involve a mask (i.e., it's really a
            // Rop3):

            if ((rop4 >> 8) == (rop4 & 0xff))
            {
                rop2 = (BYTE) (rop4 & 0xff);

                // We now want to see if we can convert this Rop3 to a Rop2
                // between the Destination and the Pattern.  We could do
                // a byte look-up on 'Rop3', but that would involve a
                // 1/4 Kbyte table which sort of big.  So we twiddle
                // the bits of the Rop3 to get a Rop2.

                if ((((rop2 >> 2) ^ (rop2)) & 0x33) == 0)
                {
                    // The ROP3 doesn't require a source...

                    rop2 >>= 2;
                    rop2 &= 0xf;  // Effectively rop2 between Dest and Pattern

                    // Admittedly, we're doing a lookup here to convert the
                    // rop2 to the hardware mix, but it's only 16 entries
                    // long:

                    ulHwForeMix = gaulHwMixFromRop2[rop2];
                    ulHwBackMix = ulHwForeMix;

                    ppdev->bRealizeTransparent = FALSE;

                    // The nice thing about the mix values for this hardware
                    // is that they are ordered so that values 0 through 3
                    // are the ones that don't require a source.  So we can
                    // do a simple logical-and operation on the hardware mix
                    // to see if we need to get a brush:

                    // NOTE: The following check depends on the actual ordering
                    //       of the mix values for the hardware!  If your mixes
                    //       are ordered differently, you may have to make this
                    //       into a 16-case switch statement on (rop2 + 1),
                    //       comparing it to each of the R2_ rops declared in
                    //       windows.h.

                Fill_It:

                    pfnFill = ppdev->pfnFillSolid;
                    if (ulHwForeMix & MIX_NEEDSPATTERN)
                    {
                        rbc.iSolidColor = pbo->iSolidColor;
                        if (rbc.iSolidColor == -1)
                        {
                            // Try and realize the pattern brush; by doing
                            // this call-back, GDI will eventually call us
                            // again through DrvRealizeBrush:

                            rbc.prb = pbo->pvRbrush;
                            if (rbc.prb == NULL)
                            {
                                rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                                if (rbc.prb == NULL)
                                {
                                    // If we couldn't realize the brush, punt
                                    // the call (it may have been a non 8x8
                                    // brush or something, which we can't be
                                    // bothered to handle, so let GDI do the
                                    // drawing):

                                    goto Punt_It;
                                }
                            }
                            pfnFill = ppdev->pfnFillPat;
                        }
                    }

                    // Note that these 2 'if's are more efficient than
                    // a switch statement:

                    if (jClip == DC_TRIVIAL)
                    {
                        pfnFill(ppdev, 1, prclDst, ulHwForeMix, ulHwBackMix,
                                rbc, pptlBrush);
                        goto All_Done;
                    }
                    else if (jClip == DC_RECT)
                    {
                        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                            pfnFill(ppdev, 1, &rcl, ulHwForeMix, ulHwBackMix,
                                    rbc, pptlBrush);
                        goto All_Done;
                    }
                    else
                    {
                        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                           CD_ANY, 0);

                        do {
                            bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                                  (ULONG*) &ce);

                            c = cIntersect(prclDst, ce.arcl, ce.c);

                            if (c != 0)
                                pfnFill(ppdev, c, ce.arcl, ulHwForeMix,
                                        ulHwBackMix, rbc, pptlBrush);

                        } while (bMore);
                        goto All_Done;
                    }
                }
            }
        }
    }

    if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVBITMAP))
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        if (pdsurfSrc->dt == DT_DIB)
        {
            // Here we consider putting a DIB DFB back into off-screen
            // memory.  If there's a translate, it's probably not worth
            // moving since we won't be able to use the hardware to do
            // the blt (a similar argument could be made for weird rops
            // and stuff that we'll only end up having GDI simulate, but
            // those should happen infrequently enough that I don't care).

            if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
            {
                ppdev = (PDEV*) psoSrc->dhpdev;

                // See 'DrvCopyBits' for some more comments on how this
                // moving-it-back-into-off-screen-memory thing works:

                if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
                {
                    if (--pdsurfSrc->cBlt == 0)
                    {
                        if (bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfSrc))
                            goto Continue_It;
                    }
                }
                else
                {
                    // Some space was freed up in off-screen memory,
                    // so reset the counter for this DFB:

                    pdsurfSrc->iUniq = ppdev->iHeapUniq;
                    pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
                }
            }

            psoSrc = pdsurfSrc->pso;

            // Handle the case where the source is a DIB DFB and the
            // destination is a regular bitmap:

            if (psoDst->iType == STYPE_BITMAP)
                goto EngBitBlt_It;

        }
    }

Continue_It:

    if (psoDst->iType == STYPE_DEVBITMAP)
    {
        pdsurfDst = (DSURF*) psoDst->dhsurf;
        if (pdsurfDst->dt == DT_DIB)
        {
            psoDst = pdsurfDst->pso;

            // If the destination is a DIB, we can only handle this
            // call if the source is not a DIB:

            if ((psoSrc == NULL) || (psoSrc->iType == STYPE_BITMAP))
                goto EngBitBlt_It;
        }
    }

    // At this point, we know that either the source or the destination is
    // not a DIB.  Check for a DFB to screen, DFB to DFB, or screen to DFB
    // case:

    if ((psoSrc != NULL) &&
        (psoDst->iType != STYPE_BITMAP) &&
        (psoSrc->iType != STYPE_BITMAP))
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        pdsurfDst = (DSURF*) psoDst->dhsurf;

        ASSERTDD(pdsurfSrc->dt == DT_SCREEN, "Expected screen source");
        ASSERTDD(pdsurfDst->dt == DT_SCREEN, "Expected screen destination");

        ptlSrc.x = pptlSrc->x - (pdsurfDst->poh->x - pdsurfSrc->poh->x);
        ptlSrc.y = pptlSrc->y - (pdsurfDst->poh->y - pdsurfSrc->poh->y);

        pptlSrc  = &ptlSrc;
        psoSrc   = psoDst;
    }

    if (psoDst->iType != STYPE_BITMAP)
    {
        pdsurfDst = (DSURF*) psoDst->dhsurf;
        ppdev     = (PDEV*)  psoDst->dhpdev;

        ppdev->xOffset = pdsurfDst->poh->x;
        ppdev->yOffset = pdsurfDst->poh->y;
    }
    else
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        ppdev     = (PDEV*)  psoSrc->dhpdev;

        ppdev->xOffset = pdsurfSrc->poh->x;
        ppdev->yOffset = pdsurfSrc->poh->y;
    }

    if ((rop4 >> 8) == (rop4 & 0xff))
    {
        // Since we've already handled the cases where the ROP4 is really
        // a ROP3 and no source is required, we can assert...

        ASSERTDD((psoSrc != NULL) && (pptlSrc != NULL),
                 "Expected no-source case to already have been handled");

        ///////////////////////////////////////////////////////////////////
        // Bitmap transfers
        ///////////////////////////////////////////////////////////////////

        // Since the foreground and background ROPs are the same, we
        // don't have to worry about no stinking masks (it's a simple
        // Rop3).

        rop3 = (rop4 & 0xff);   // Make it into a Rop3 (we keep the rop4
                                //  around in case we decide to punt)

        if (psoDst->iType != STYPE_BITMAP)
        {
            // The destination is the screen:

            if ((rop3 >> 4) == (rop3 & 0xf))
            {
                // The ROP3 doesn't require a pattern:

                rop2 = rop3 & 0xf;      // Make it into a Rop2

                if (psoSrc->iType == STYPE_BITMAP)
                {
                    //////////////////////////////////////////////////
                    // DIB-to-screen blt

                    // This section handles 1bpp, 4bpp and 8bpp sources.
                    // 1bpp should have 'ulHwForeMix' and 'ulHwBackMix' the
                    // same values, and 4bpp and 8bpp ignore 'ulHwBackMix'.

                    ulHwForeMix = gaulHwMixFromRop2[rop2];
                    ulHwBackMix = ulHwForeMix;

                    iSrcBitmapFormat = psoSrc->iBitmapFormat;
                    if (iSrcBitmapFormat == BMF_1BPP)
                    {
                        pfnXfer = ppdev->pfnXfer1bpp;
                        goto Xfer_It;
                    }
                    else if ((iSrcBitmapFormat == ppdev->iBitmapFormat) &&
                             ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
                    {
                        // Plain SRCCOPY blts will be somewhat faster on the S3
                        // if we go through the memory aperture, but
                        // DrvCopyBits should take care of that case, so we
                        // won't bother checking for it here.

                        pfnXfer = ppdev->pfnXferNative;
                        goto Xfer_It;
                    }
                    else if ((iSrcBitmapFormat == BMF_4BPP) &&
                             (ppdev->iBitmapFormat == BMF_8BPP))
                    {
                        pfnXfer = ppdev->pfnXfer4bpp;
                        goto Xfer_It;
                    }
                }
                else // psoSrc->iType != STYPE_BITMAP
                {
                    if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
                    {
                        //////////////////////////////////////////////////
                        // Screen-to-screen blt with no translate

                        ulHwForeMix = gaulHwMixFromRop2[rop2];

                        if (jClip == DC_TRIVIAL)
                        {
                            (ppdev->pfnCopyBlt)(ppdev, 1, prclDst, ulHwForeMix,
                                pptlSrc, prclDst);
                            goto All_Done;
                        }
                        else if (jClip == DC_RECT)
                        {
                            if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                            {
                                (ppdev->pfnCopyBlt)(ppdev, 1, &rcl, ulHwForeMix,
                                    pptlSrc, prclDst);
                            }
                            goto All_Done;
                        }
                        else
                        {
                            // Don't forget that we'll have to draw the
                            // rectangles in the correct direction:

                            if (pptlSrc->y >= prclDst->top)
                            {
                                if (pptlSrc->x >= prclDst->left)
                                    iDir = CD_RIGHTDOWN;
                                else
                                    iDir = CD_LEFTDOWN;
                            }
                            else
                            {
                                if (pptlSrc->x >= prclDst->left)
                                    iDir = CD_RIGHTUP;
                                else
                                    iDir = CD_LEFTUP;
                            }

                            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                               iDir, 0);

                            do {
                                bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                                      (ULONG*) &ce);

                                c = cIntersect(prclDst, ce.arcl, ce.c);

                                if (c != 0)
                                {
                                    (ppdev->pfnCopyBlt)(ppdev, c, ce.arcl,
                                        ulHwForeMix, pptlSrc, prclDst);
                                }

                            } while (bMore);
                            goto All_Done;
                        }
                    }
                }
            }
            else if (psoSrc->iBitmapFormat == BMF_1BPP)
            {
                pulXlate = pxlo->pulXlate;

                if (((pulXlate[0] == 0) && (pulXlate[1] == ppdev->ulWhite)) ||
                    ((pulXlate[1] == 0) && (pulXlate[0] == ppdev->ulWhite)))
                {
                    // When the brush is solid, and the bitmap colours are
                    // black and white, we can handle any rop3 by converting
                    // it to a monochrome blt with separate foreground and
                    // background mixes.
                    //
                    // (Note that with the S3 801/805/928/964, we could handle
                    // patterns too, using the same trick we use in MaskCopy.
                    // This only works for black and white source bitmaps,
                    // which is the most common call, but unfortunately a
                    // certain program which benchmarks these rops messed up
                    // and gives non-black and white colours.  Since I'll
                    // handle those cases using multiple passes, I won't
                    // bother to implement this special trick.)

                    ulHwForeMix = gaulHwMixFromRop2[((rop3 >> 4) & 0xC) |
                                                    ((rop3 >> 2) & 0x3)];
                    ulHwBackMix = gaulHwMixFromRop2[((rop3 >> 2) & 0xC) |
                                                    ((rop3     ) & 0x3)];
                    pptlMsk = pptlSrc;
                    psoMsk  = psoSrc;
                    if (pulXlate[1] == 0)
                    {
                        ulTmp       = ulHwForeMix;
                        ulHwForeMix = ulHwBackMix;
                        ulHwBackMix = ulTmp;
                    }

                    // Fall through if the brush isn't solid:

                    if ( (((ulHwForeMix | ulHwBackMix) & MIX_NEEDSPATTERN) == 0)
                       ||(pbo->iSolidColor != -1) )
                    {
                        goto Handle_Fill_Mask;
                    }
                }
            }

            // Here we special case some often used rop3's that we can
            // do in two or three passes using the hardware.
            //
            // We only handle 1bpp sources, or sources that are the same
            // pixel depth as the screen (either a bitmap or an off-screen
            // DFB) with no xlate:

            if ((psoSrc->iBitmapFormat == BMF_1BPP) ||
                 (((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)) &&
                  ((psoSrc->iType != STYPE_BITMAP) ||
                   (psoSrc->iBitmapFormat == ppdev->iBitmapFormat))))
            {
                if ((psoSrc->iType != STYPE_BITMAP) &&
                    (OVERLAP(prclDst, pptlSrc)))
                {
                    // We don't handle overlapping rectangles on a
                    // screen-to-screen operation:

                    goto Punt_It;
                }

                if (rop3 == 0xb8)
                {
                    ulHwForeMix = SCREEN_AND_NEW;
                    pfnMask     = vMaskRopB8orE2;
                }
                else if (rop3 == 0xe2)
                {
                    ulHwForeMix = SCREEN_AND_NOT_NEW;
                    pfnMask     = vMaskRopB8orE2;
                }
                else if (rop3 == 0x69)
                {
                    ulHwForeMix = NOT_SCREEN_XOR_NEW;
                    pfnMask     = vMaskRop69or96;
                }
                else if (rop3 == 0x96)
                {
                    ulHwForeMix = SCREEN_XOR_NEW;
                    pfnMask     = vMaskRop69or96;
                }
                else
                {
                    goto Punt_It;
                }

                // All the rop3's that we've special cased need a pattern,
                // so it's safe to realize a brush:

                iSolidColor = pbo->iSolidColor;
                if (iSolidColor == -1)
                {
                    prb = pbo->pvRbrush;
                    if (prb == NULL)
                    {
                        ppdev->bRealizeTransparent = FALSE;
                        prb = BRUSHOBJ_pvGetRbrush(pbo);
                        if (prb == NULL)
                            goto Punt_It;
                    }
                }

                goto Mask_It;
            }
        }
        else
        {
            #if defined(i386)
            {
                // We special case screen to monochrome blts because they
                // happen fairly often.  We only handle SRCCOPY rops and
                // monochrome destinations (to handle a true 1bpp DIB
                // destination, we would have to do near-colour searches
                // on every colour; as it is, the foreground colour gets
                // mapped to '1', and everything else gets mapped to '0'):

                if ((psoDst->iBitmapFormat == BMF_1BPP) &&
                    (rop3 == 0xcc) &&
                    (pxlo->flXlate & XO_TO_MONO))
                {
                    pfnXfer = vXferScreenTo1bpp;
                    psoSrc  = psoDst;               // A misnomer, I admit
                    goto Xfer_It;
                }
            }
            #endif // i386
        }
    }

    // We're going to handle some true ROP4s, where there's a foreground
    // ROP3 and a background ROP3 associated with the 1bpp mask.

    else if (psoMsk != NULL)
    {
        // At this point, we've made sure that we have a true ROP4.
        // This is important because we're about to dereference the
        // mask.  I'll assert to make sure that I haven't inadvertently
        // broken the logic for this:

        ASSERTDD((rop4 & 0xff) != (rop4 >> 8), "This handles true ROP4's only");

        ///////////////////////////////////////////////////////////////////
        // True ROP4's
        ///////////////////////////////////////////////////////////////////

        // Handle ROP4 where no source is required for either Rop3:

        if ((((rop4 >> 2) ^ (rop4)) & 0x3333) == 0)
        {
            ulHwForeMix = gaulHwMixFromRop2[(rop4 >> 2)  & 0xf];
            ulHwBackMix = gaulHwMixFromRop2[(rop4 >> 10) & 0xf];

Handle_Fill_Mask:

            pfnXfer = ppdev->pfnXfer1bpp;
            if ((ulHwForeMix & MIX_NEEDSPATTERN) ||
                (ulHwBackMix & MIX_NEEDSPATTERN))
            {
                // Fake up a 1bpp XLATEOBJ (note that we should only
                // dereference 'pbo' when it's required by the mix):

                xlc.iForeColor = pbo->iSolidColor;
                xlc.iBackColor = xlc.iForeColor;

                if (xlc.iForeColor == -1)
                    goto Punt_It;       // We don't handle non-solid brushes
            }

            // Note that when neither the foreground nor the background mix
            // requires a source, the colours in 'xlc' are allowed to be
            // garbage.

            xlo.pulXlate = (ULONG*) &xlc;
            pxlo         = &xlo;
            psoSrc       = psoMsk;
            pptlSrc      = pptlMsk;
            goto Xfer_It;
        }
        else if ((((rop4 >> 4) ^ (rop4)) & 0x0f0f) == 0) // No pattern required
        {
            // We're about to dereference 'psoSrc' and 'pptlSrc' --
            // since we already handled the case where neither ROP3
            // required the source, the ROP4 must require a source,
            // so we're safe.

            ASSERTDD((psoSrc != NULL) && (pptlSrc != NULL),
                     "No source case should already have been handled!");

            // The operation has to be screen-to-screen, and the rectangles
            // cannot overlap:

            if ((psoSrc->iType != STYPE_BITMAP)                  &&
                (psoDst->iType != STYPE_BITMAP)                  &&
                ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)) &&
                !OVERLAP(prclDst, pptlSrc))
            {
                if (ppdev->flCaps & CAPS_MASKBLT_CAPABLE)
                {
                    ulHwForeMix = gaulHwMixFromRop2[rop4 & 0xf];
                    ulHwBackMix = gaulHwMixFromRop2[(rop4 >> 8) & 0xf];

                    pfnMask = ppdev->pfnMaskCopy;
                    goto Mask_It;
                }
                else
                {
                    // We don't have hardware capabilities for doing it in
                    // one pass, but we can still do it in three passes
                    // using the hardware if it's a standard MaskBlt rop:

                    if (rop4 == 0xccaa)
                        ulHwForeMix = SCREEN_AND_NEW;

                    else if (rop4 == 0xaacc)
                        ulHwForeMix = SCREEN_AND_NOT_NEW;

                    else
                        goto Punt_It;

                    pfnMask = vMaskRopAACCorCCAA;
                    goto Mask_It;
                }
            }
        }
    }
    else if ((rop4 & 0xff00) == (0xaa00) &&
             ((((rop4 >> 2) ^ (rop4)) & 0x33) == 0))
    {
        // The only time GDI will ask us to do a true rop4 using the brush
        // mask is when the brush is 1bpp, and the background rop is AA
        // (meaning it's a NOP):

        ASSERTDD(psoMsk == NULL, "This should be the NULL mask case");

        ulHwForeMix = gaulHwMixFromRop2[(rop4 >> 2) & 0xf];
        ulHwBackMix = LEAVE_ALONE;

        ppdev->bRealizeTransparent = TRUE;

        goto Fill_It;
    }

    // Just fall through to Punt_It...

Punt_It:
    return(bPuntBlt(psoDst,
                    psoSrc,
                    psoMsk,
                    pco,
                    pxlo,
                    prclDst,
                    pptlSrc,
                    pptlMsk,
                    pbo,
                    pptlBrush,
                    rop4));

//////////////////////////////////////////////////////////////////////
// Common bitmap transfer

Xfer_It:
    if (jClip == DC_TRIVIAL)
    {
        pfnXfer(ppdev, 1, prclDst, ulHwForeMix, ulHwBackMix, psoSrc, pptlSrc,
                prclDst, pxlo);
        goto All_Done;
    }
    else if (jClip == DC_RECT)
    {
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
            pfnXfer(ppdev, 1, &rcl, ulHwForeMix, ulHwBackMix, psoSrc, pptlSrc,
                    prclDst, pxlo);
        goto All_Done;
    }
    else
    {
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                           CD_ANY, 0);

        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                  (ULONG*) &ce);

            c = cIntersect(prclDst, ce.arcl, ce.c);

            if (c != 0)
            {
                pfnXfer(ppdev, c, ce.arcl, ulHwForeMix, ulHwBackMix, psoSrc,
                        pptlSrc, prclDst, pxlo);
            }

        } while (bMore);
        goto All_Done;
    }

//////////////////////////////////////////////////////////////////////
// Common masked blt

Mask_It:
    if (jClip == DC_TRIVIAL)
    {
        pfnMask(ppdev, 1, prclDst, ulHwForeMix, ulHwBackMix,
                psoMsk, pptlMsk, psoSrc, pptlSrc, prclDst,
                iSolidColor, prb, pptlBrush, pxlo);
        goto All_Done;
    }
    else if (jClip == DC_RECT)
    {
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
            pfnMask(ppdev, 1, &rcl, ulHwForeMix, ulHwBackMix,
                    psoMsk, pptlMsk, psoSrc, pptlSrc, prclDst,
                    iSolidColor, prb, pptlBrush, pxlo);
        goto All_Done;
    }
    else
    {
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                           CD_ANY, 0);

        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                  (ULONG*) &ce);

            c = cIntersect(prclDst, ce.arcl, ce.c);

            if (c != 0)
            {
                pfnMask(ppdev, c, ce.arcl, ulHwForeMix, ulHwBackMix,
                        psoMsk, pptlMsk, psoSrc, pptlSrc, prclDst,
                        iSolidColor, prb, pptlBrush, pxlo);
            }

        } while (bMore);
        goto All_Done;
    }

////////////////////////////////////////////////////////////////////////
// Common DIB blt

EngBitBlt_It:

    // Our driver doesn't handle any blt's between two DIBs.  Normally
    // a driver doesn't have to worry about this, but we do because
    // we have DFBs that may get moved from off-screen memory to a DIB,
    // where we have GDI do all the drawing.  GDI does DIB drawing at
    // a reasonable speed (unless one of the surfaces is a device-
    // managed surface...)
    //
    // If either the source or destination surface in an EngBitBlt
    // call-back is a device-managed surface (meaning it's not a DIB
    // that GDI can draw with), GDI will automatically allocate memory
    // and call the driver's DrvCopyBits routine to create a DIB copy
    // that it can use.  So this means that this could handle all 'punts',
    // and we could conceivably get rid of bPuntBlt.  But this would have
    // a bad performance impact because of the extra memory allocations
    // and bitmap copies -- you really don't want to do this unless you
    // have to (or your surface was created such that GDI can draw
    // directly onto it) -- I've been burned by this because it's not
    // obvious that the performance impact is so bad.
    //
    // That being said, we only call EngBitBlt when all the surfaces
    // are DIBs:

    return(EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst,
                     pptlSrc, pptlMsk, pbo, pptlBrush, rop4));

All_Done:
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL DrvCopyBits
*
* Do fast bitmap copies.
*
* Note that GDI will (usually) automatically adjust the blt extents to
* adjust for any rectangular clipping, so we'll rarely see DC_RECT
* clipping in this routine (and as such, we don't bother special casing
* it).
*
* I'm not sure if the performance benefit from this routine is actually
* worth the increase in code size, since SRCCOPY BitBlts are hardly the
* most common drawing operation we'll get.  But what the heck.
*
* On the S3 it's faster to do straight SRCCOPY bitblt's through the
* memory aperture than to use the data transfer register; as such, this
* routine is the logical place to put this special case.
*
\**************************************************************************/

BOOL DrvCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    PDEV*   ppdev;
    DSURF*  pdsurfSrc;
    DSURF*  pdsurfDst;
    RECTL   rcl;
    POINTL  ptl;
    OH*     pohSrc;
    OH*     pohDst;

    // DrvCopyBits is a fast-path for SRCCOPY blts.  But it can still be
    // pretty complicated: there can be translates, clipping, RLEs,
    // bitmaps that aren't the same format as the screen, plus
    // screen-to-screen, DIB-to-screen or screen-to-DIB operations,
    // not to mention DFBs (device format bitmaps).
    //
    // Rather than making this routine almost as big as DrvBitBlt, I'll
    // handle here only the speed-critical cases, and punt the rest to
    // our DrvBitBlt routine.
    //
    // We'll try to handle anything that doesn't involve clipping:

    if (((pco  == NULL) || (pco->iDComplexity == DC_TRIVIAL)) &&
        ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
    {
        if (psoDst->iType != STYPE_BITMAP)
        {
            // We know the destination is either a DFB or the screen:

            ppdev     = (PDEV*)  psoDst->dhpdev;
            pdsurfDst = (DSURF*) psoDst->dhsurf;

            // See if the source is a plain DIB:

            if (psoSrc->iType != STYPE_BITMAP)
            {
                pdsurfSrc = (DSURF*) psoSrc->dhsurf;

                // Make sure the destination is really the screen or an
                // off-screen DFB (i.e., not a DFB that we've converted
                // to a DIB):

                if (pdsurfDst->dt == DT_SCREEN)
                {
                    ASSERTDD(psoSrc->iType != STYPE_BITMAP, "Can't be a DIB");

                    if (pdsurfSrc->dt == DT_SCREEN)
                    {

                    Screen_To_Screen:

                        //////////////////////////////////////////////////////
                        // Screen-to-screen

                        ASSERTDD((psoSrc->iType != STYPE_BITMAP) &&
                                 (pdsurfSrc->dt == DT_SCREEN)    &&
                                 (psoDst->iType != STYPE_BITMAP) &&
                                 (pdsurfDst->dt == DT_SCREEN),
                                 "Should be a screen-to-screen case");

                        // pfnCopyBlt takes relative coordinates (relative
                        // to the destination surface, that is), so we have
                        // to change the start point to be relative to the
                        // destination surface too:

                        pohSrc = pdsurfSrc->poh;
                        pohDst = pdsurfDst->poh;

                        ptl.x = pptlSrc->x - (pohDst->x - pohSrc->x);
                        ptl.y = pptlSrc->y - (pohDst->y - pohSrc->y);

                        ppdev->xOffset = pohDst->x;
                        ppdev->yOffset = pohDst->y;

                        (ppdev->pfnCopyBlt)(ppdev, 1, prclDst, OVERPAINT, &ptl,
                            prclDst);
                        return(TRUE);
                    }
                    else // (pdsurfSrc->dt != DT_SCREEN)
                    {
                        // Ah ha, the source is a DFB that's really a DIB.

                        ASSERTDD(psoDst->iType != STYPE_BITMAP,
                                "Destination can't be a DIB here");

                        /////////////////////////////////////////////////////
                        // Put It Back Into Off-screen?
                        //
                        // We take this opportunity to decide if we want to
                        // put the DIB back into off-screen memory.  This is
                        // a pretty good place to do it because we have to
                        // copy the bits to some portion of the screen,
                        // anyway.  So we would incur only an extra screen-to-
                        // screen blt at this time, much of which will be
                        // over-lapped with the CPU.
                        //
                        // The simple approach we have taken is to move a DIB
                        // back into off-screen memory only if there's already
                        // room -- we won't throw stuff out to make space
                        // (because it's tough to know what ones to throw out,
                        // and it's easy to get into thrashing scenarios).
                        //
                        // Because it takes some time to see if there's room
                        // in off-screen memory, we only check one in
                        // HEAP_COUNT_DOWN times if there's room.  To bias
                        // in favour of bitmaps that are often blt, the
                        // counters are reset every time any space is freed
                        // up in off-screen memory.  We also don't bother
                        // checking if no space has been freed since the
                        // last time we checked for this DIB.

                        if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
                        {
                            if (--pdsurfSrc->cBlt == 0)
                            {
                                if (bMoveDibToOffscreenDfbIfRoom(ppdev,
                                                                 pdsurfSrc))
                                    goto Screen_To_Screen;
                            }
                        }
                        else
                        {
                            // Some space was freed up in off-screen memory,
                            // so reset the counter for this DFB:

                            pdsurfSrc->iUniq = ppdev->iHeapUniq;
                            pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
                        }

                        // Since the destination is definitely the screen,
                        // we don't have to worry about creating a DIB to
                        // DIB copy case (for which we would have to call
                        // EngCopyBits):

                        psoSrc = pdsurfSrc->pso;

                        goto DIB_To_Screen;
                    }
                }
                else // (pdsurfDst->dt != DT_SCREEN)
                {
                    // Because the source is not a DIB, we don't have to
                    // worry about creating a DIB to DIB case here (although
                    // we'll have to check later to see if the source is
                    // really a DIB that's masquerading as a DFB...)

                    ASSERTDD(psoSrc->iType != STYPE_BITMAP,
                             "Source can't be a DIB here");

                    psoDst = pdsurfDst->pso;

                    goto Screen_To_DIB;
                }
            }
            else if (psoSrc->iBitmapFormat == ppdev->iBitmapFormat)
            {
                // Make sure the destination is really the screen:

                if (pdsurfDst->dt == DT_SCREEN)
                {

                DIB_To_Screen:

                    //////////////////////////////////////////////////////
                    // DIB-to-screen

                    ASSERTDD((psoDst->iType != STYPE_BITMAP) &&
                             (pdsurfDst->dt == DT_SCREEN)    &&
                             (psoSrc->iType == STYPE_BITMAP) &&
                             (psoSrc->iBitmapFormat == ppdev->iBitmapFormat),
                             "Should be a DIB-to-screen case");

                    // vPutBits takes absolute screen coordinates, so
                    // we have to muck with the destination rectangle:

                    pohDst = pdsurfDst->poh;

                    rcl.left   = prclDst->left   + pohDst->x;
                    rcl.right  = prclDst->right  + pohDst->x;
                    rcl.top    = prclDst->top    + pohDst->y;
                    rcl.bottom = prclDst->bottom + pohDst->y;

                    // We use the memory aperture to do the transfer,
                    // because that is supposed to be faster for SRCCOPY
                    // blts than using the data-transfer register:

                    vPutBits(ppdev, psoSrc, &rcl, pptlSrc);
                    return(TRUE);
                }
            }
        }
        else // (psoDst->iType == STYPE_BITMAP)
        {

        Screen_To_DIB:

            pdsurfSrc = (DSURF*) psoSrc->dhsurf;
            ppdev     = (PDEV*)  psoSrc->dhpdev;

            if (psoDst->iBitmapFormat == ppdev->iBitmapFormat)
            {
                if (pdsurfSrc->dt == DT_SCREEN)
                {
                    //////////////////////////////////////////////////////
                    // Screen-to-DIB

                    ASSERTDD((psoSrc->iType != STYPE_BITMAP) &&
                             (pdsurfSrc->dt == DT_SCREEN)    &&
                             (psoDst->iType == STYPE_BITMAP) &&
                             (psoDst->iBitmapFormat == ppdev->iBitmapFormat),
                             "Should be a screen-to-DIB case");

                    // vGetBits takes absolute screen coordinates, so we have
                    // to muck with the source point:

                    pohSrc = pdsurfSrc->poh;

                    ptl.x = pptlSrc->x + pohSrc->x;
                    ptl.y = pptlSrc->y + pohSrc->y;

                    vGetBits(ppdev, psoDst, prclDst, &ptl);
                    return(TRUE);
                }
                else
                {
                    // The source is a DFB that's really a DIB.  Since we
                    // know that the destination is a DIB, we've got a DIB
                    // to DIB operation, and should call EngCopyBits:

                    psoSrc = pdsurfSrc->pso;
                    goto EngCopyBits_It;
                }
            }
        }
    }

    // We can't call DrvBitBlt if we've accidentally converted both
    // surfaces to DIBs, because it isn't equipped to handle it:

    ASSERTDD((psoSrc->iType != STYPE_BITMAP) ||
             (psoDst->iType != STYPE_BITMAP),
             "Accidentally converted both surfaces to DIBs");

    /////////////////////////////////////////////////////////////////
    // A DrvCopyBits is after all just a simplified DrvBitBlt:

    return(DrvBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc, NULL,
                     NULL, NULL, 0x0000CCCC));

EngCopyBits_It:

    ASSERTDD((psoDst->iType == STYPE_BITMAP) &&
             (psoSrc->iType == STYPE_BITMAP),
             "Both surfaces should be DIBs to call EngCopyBits");

    return(EngCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\8514a\disp\brush.c ===
/******************************Module*Header*******************************\
* Module Name: Brush.c
*
* Handles all brush/pattern initialization and realization.
*
* Copyright (c) 1992-1994 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vRealizeDitherPattern
*
* Generates an 8x8 dither pattern, in our internal realization format, for
* the colour ulRGBToDither.  Note that the high byte of ulRGBToDither does
* not need to be set to zero, because vComputeSubspaces ignores it.
\**************************************************************************/

VOID vRealizeDitherPattern(
RBRUSH*     prb,
ULONG       ulRGBToDither)
{
    ULONG           ulNumVertices;
    VERTEX_DATA     vVertexData[4];
    VERTEX_DATA*    pvVertexData;

    // Calculate what colour subspaces are involved in the dither:

    pvVertexData = vComputeSubspaces(ulRGBToDither, vVertexData);

    // Now that we have found the bounding vertices and the number of
    // pixels to dither for each vertex, we can create the dither pattern

    ulNumVertices = pvVertexData - vVertexData;
                      // # of vertices with more than zero pixels in the dither

    // Do the actual dithering:

    vDitherColor(&prb->aulPattern[0], vVertexData, pvVertexData, ulNumVertices);

    prb->fl            = 0;
    prb->ptlBrushOrg.x = -1;
    prb->pbe           = NULL;      // Initialize the fields we need
}

/******************************Public*Routine******************************\
* BOOL DrvRealizeBrush
*
* This function allows us to convert GDI brushes into an internal form
* we can use.  It is called by GDI when we've called BRUSHOBJ_pvGetRbrush
* in some other function like DrvBitBlt, and GDI doesn't happen have a cached
* realization lying around.
*
* Input:
*
*   ppdev->bRealizeTransparent -- Hint for whether or not the brush should be
*                              realized for transparency.  If this hint is
*                              wrong, there will be no error, but the brush
*                              will have to be unnecessarily re-realized.
*
* Note: You should always set 'ppdev->bRealizeTransparent' before calling
*       BRUSHOBJ_pvGetRbrush!
*
\**************************************************************************/

BOOL DrvRealizeBrush(
BRUSHOBJ*   pbo,
SURFOBJ*    psoDst,
SURFOBJ*    psoPattern,
SURFOBJ*    psoMask,
XLATEOBJ*   pxlo,
ULONG       iHatch)
{
    PDEV*   ppdev;
    ULONG   iPatternFormat;
    BYTE*   pjSrc;
    BYT